
        //
        frs->ReadNext(*FirstFrsNumber);

        ntstatus = NtSetEvent(ReadReady, NULL);
        if (!NT_SUCCESS(ntstatus)) {
            DebugPrintTrace(("UNTFS: NtSetEvent failed (%x)\n", ntstatus));
            return ntstatus;
        }
    }

    NtTerminateThread(NtCurrentThread(), STATUS_SUCCESS);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\ntfssa.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "ntfssa.hxx"
#include "message.hxx"
#include "rtmsg.h"

#include "array.hxx"
#include "arrayit.hxx"

#include "mftfile.hxx"
#include "ntfsbit.hxx"
#include "frs.hxx"
#include "wstring.hxx"
#include "indxtree.hxx"
#include "badfile.hxx"
#include "bitfrs.hxx"
#include "attrib.hxx"
#include "attrrec.hxx"
#include "mft.hxx"
#include "logfile.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
#include "ifssys.hxx"

extern "C" {
#include "bootntfs.h"
#include "boot98n.h"
}

#if !defined( _SETUP_LOADER_ ) && !defined( _AUTOCHECK_ )

#include "path.hxx"

#endif // _SETUP_LOADER_

UCHAR NTFS_SA::_MajorVersion = NTFS_CURRENT_MAJOR_VERSION,
      NTFS_SA::_MinorVersion = NTFS_CURRENT_MINOR_VERSION;

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_SA, SUPERAREA, UNTFS_EXPORT );


VOID
NTFS_SA::Construct (
    )
/*++

Routine Description:

    This routine sets an NTFS_SA to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _cleanup_that_requires_reboot = FALSE;
    _boot_sector = NULL;
    memset(&_bpb, 0, sizeof(BIOS_PARAMETER_BLOCK));
    _boot2 = 0;
    _boot3 = 0;
    _NumberOfStages = 0;
    _cvt_zone = 0;
    _cvt_zone_size = 0;
}


VOID
NTFS_SA::Destroy(
    )
/*++

Routine Description:

    This routine returns an NTFS_SA to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _cleanup_that_requires_reboot = FALSE;
    _boot_sector = NULL;
    memset(&_bpb, 0, sizeof(BIOS_PARAMETER_BLOCK));
    _boot2 = 0;
    _boot3 = 0;
    _cvt_zone = 0;
    _cvt_zone_size = 0;
}


UNTFS_EXPORT
NTFS_SA::~NTFS_SA(
    )
/*++

Routine Description:

    Destructor for NTFS_SA.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}



UNTFS_EXPORT
BOOLEAN
NTFS_SA::Initialize(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN OUT  PMESSAGE            Message,
    IN      LCN                 CvtStartZone,
    IN      BIG_INT             CvtZoneSize
    )
/*++

Routine Description:

    This routine returns an NTFS_SA to a default initial state.

Arguments:

    Drive               - Supplies the drive that this MultiSectorBuffer is on
    Message             - Supplies an outlet for messages.
    CvtStartZone        - Supplies the starting cluster of the convert zone
    CvtZoneSize         - Supplies the convert zone size in clusters

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG   num_boot_sectors;

    Destroy();

    DebugAssert(Drive);
    DebugAssert(Message);

    num_boot_sectors = max(1, BYTES_PER_BOOT_SECTOR/Drive->QuerySectorSize());

    if (!_hmem.Initialize() ||
        !SUPERAREA::Initialize(&_hmem, Drive, num_boot_sectors, Message)) {

        return FALSE;
    }

    _boot_sector = (PPACKED_BOOT_SECTOR) SECRUN::GetBuf();

#if defined(FE_SB) && defined(_X86_)
    //
    //  Set the appropriate boot code according to environment.
    //
    if (IsNEC_98 && !_drive->IsATformat()) {
        _bootcode = PC98NtfsBootCode;
        _bootcodesize = sizeof(PC98NtfsBootCode);
    } else {
#endif
        _bootcode = NtfsBootCode;
        _bootcodesize = sizeof(NtfsBootCode);
#if defined(FE_SB) && defined(_X86_)
    }
#endif

    _cvt_zone = CvtStartZone;
    _cvt_zone_size = CvtZoneSize;

    return TRUE;
}

#if defined( _SETUP_LOADER_ )

BOOLEAN
NTFS_SA::Create(
    IN      PCNUMBER_SET    BadSectors,
    IN OUT  PMESSAGE        Message,
    IN      PCWSTRING       Label,
    IN      BOOLEAN         BackwardCompatible,
    IN      ULONG           ClusterSize,
    IN      ULONG           VirtualSectors

    )
{
    // Dummy implementation for Setup-Loader; the real thing
    // is in format.cxx.

    return FALSE;
}

BOOLEAN
NTFS_SA::Create(
    IN      PCNUMBER_SET    BadSectors,
    IN      ULONG           ClusterFactor,
    IN      ULONG           FrsSize,
    IN      ULONG           ClustersPerIndexBuffer,
    IN      ULONG           InitialLogFileSize,
    IN      BOOLEAN         BackwardCompatible,
    IN OUT  PMESSAGE        Message,
    IN      PCWSTRING       Label
    )
{
    // Dummy implementation for Setup-Loader; the real thing
    // is in format.cxx.

    return FALSE;
}


#endif // _SETUP_LOADER_

#if defined( _AUTOCHECK_ ) || defined( _SETUP_LOADER_ )

BOOLEAN
NTFS_SA::RecoverFile(
    IN      PCWSTRING   FullPathFileName,
    IN OUT  PMESSAGE    Message
    )
{
    // Dummy implementation for AUTOCHECK and Setup-Loader

    return FALSE;
}

#else // _AUTOCHECK_ and _SETUP_LOADER_ are NOT defined


BOOLEAN
NTFS_SA::RecoverFile(
    IN      PCWSTRING   FullPathFileName,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine recovers a file on the disk.

Arguments:

    FullPathFileName    - Supplies the file name of the file to recover.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_ATTRIBUTE BitmapAttribute;
    NTFS_MFT_FILE MftFile;
    NTFS_BITMAP_FILE BitmapFile;
    NTFS_BAD_CLUSTER_FILE BadClusterFile;
    NTFS_BITMAP VolumeBitmap;
    NTFS_FILE_RECORD_SEGMENT FrsToRecover;
    NTFS_UPCASE_FILE UpcaseFile;
    NTFS_ATTRIBUTE UpcaseAttribute;
    NTFS_UPCASE_TABLE UpcaseTable;
    BIG_INT BytesRecovered, TotalBytes;
    BOOLEAN Error = FALSE;
    ULONG BadClusters = 0;
    NUMBER_SET BadClusterList;
    UCHAR Major, Minor;
    BOOLEAN CorruptVolume;
    BOOLEAN SystemFile;


    // Lock the drive.

    if (!_drive->Lock()) {

        Message->DisplayMsg(MSG_CANT_LOCK_THE_DRIVE);
        return FALSE;
    }

    // Determine the volume version information.
    //
    QueryVolumeFlagsAndLabel(&CorruptVolume, &Major, &Minor);

    if( CorruptVolume ) {

        Message->DisplayMsg( MSG_NTFS_RECOV_CORRUPT_VOLUME );
        return FALSE;
    }

    if( Major > 3 ) {

        Message->DisplayMsg( MSG_NTFS_RECOV_WRONG_VERSION );
        return FALSE;
    }

    SetVersionNumber( Major, Minor );


    // Initialize and read the MFT, the Bitmap File, the Bitmap, and the
    // Bad Cluster File.
    //
    if( !VolumeBitmap.Initialize( QueryVolumeSectors()/
                                  ((ULONG) QueryClusterFactor()),
                                  FALSE, _drive, QueryClusterFactor()) ||
        !MftFile.Initialize( _drive,
                             QueryMftStartingLcn(),
                             QueryClusterFactor(),
                             QueryFrsSize(),
                             QueryVolumeSectors(),
                             &VolumeBitmap,
                             NULL ) ) {

        Message->DisplayMsg( MSG_INSUFFICIENT_MEMORY );
        return FALSE;
    }

    if( !MftFile.Read() ) {

        DebugPrint( "NTFS_SA::RecoverFile: Cannot read MFT.\n" );

        Message->DisplayMsg( MSG_NTFS_RECOV_CORRUPT_VOLUME );
        return FALSE;
    }

    // Get the upcase table.
    //
    if( !UpcaseFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !UpcaseFile.Read() ||
        !UpcaseFile.QueryAttribute( &UpcaseAttribute, &Error, $DATA ) ||
        !UpcaseTable.Initialize( &UpcaseAttribute ) ) {

        DebugPrint( "UNTFS RecoverFile:Can't get the upcase table.\n" );

        Message->DisplayMsg( MSG_NTFS_RECOV_CORRUPT_VOLUME );
        return FALSE;
    }

    MftFile.SetUpcaseTable( &UpcaseTable );
    MftFile.GetMasterFileTable()->SetUpcaseTable( &UpcaseTable );


    // Initialize the Bitmap file and the Bad Cluster file, and
    // read the volume bitmap.
    //
    if( !BitmapFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !BadClusterFile.Initialize( MftFile.GetMasterFileTable() ) ) {

        Message->DisplayMsg( MSG_INSUFFICIENT_MEMORY );
        return FALSE;
    }

    if( !BitmapFile.Read() ||
        !BitmapFile.QueryAttribute( &BitmapAttribute, &Error, $DATA ) ||
        !VolumeBitmap.Read( &BitmapAttribute ) ||
        !BadClusterFile.Read () ) {

        Message->DisplayMsg( MSG_NTFS_RECOV_CORRUPT_VOLUME );
        return FALSE;
    }


    // Find the File Record Segment.

    if( !QueryFrsFromPath( FullPathFileName,
                           MftFile.GetMasterFileTable(),
                           &VolumeBitmap,
                           &FrsToRecover,
                           &SystemFile,
                           &Error ) ) {

        if( !Error ) {

            Message->DisplayMsg( MSG_RECOV_FILE_NOT_FOUND );
            return FALSE;

        } else {

            Message->DisplayMsg( MSG_INSUFFICIENT_MEMORY );
            return FALSE;
        }
    }


    // If the File Record Segment is a system file, don't recover it.

    if( SystemFile ) {

        Message->DisplayMsg( MSG_NTFS_RECOV_SYSTEM_FILE );
        return FALSE;
    }

    // Recover the File Record Segment.

    if( !BadClusterList.Initialize() ||
        !FrsToRecover.RecoverFile( &VolumeBitmap,
                                   &BadClusterList,
                                   Major,
                                   &BadClusters,
                                   &BytesRecovered,
                                   &TotalBytes ) ||
        !BadClusterFile.Add(&BadClusterList)) {

        Message->DisplayMsg( MSG_NTFS_RECOV_FAILED );

        return FALSE;
    }

    // If any bad clusters were found, we need to flush the bad cluster
    // file and the MFT and write the bitmap.  If no bad clusters were
    // found, then these structures will be unchanged.

    if( BadClusters != 0 ) {

        if( !BadClusterFile.Flush( &VolumeBitmap ) ||
            !MftFile.Flush() ||
            !VolumeBitmap.Write( &BitmapAttribute, &VolumeBitmap ) ) {

            Message->DisplayMsg( MSG_NTFS_RECOV_CANT_WRITE_ELEMENTARY );

            return FALSE;
        }

    }

    Message->DisplayMsg(MSG_RECOV_BYTES_RECOVERED,
                        "%d%d",
                        BytesRecovered.GetLowPart(),
                        TotalBytes.GetLowPart() );

    return TRUE;
}

#endif // _AUTOCHECK_ || _SETUP_LOADER_



UNTFS_EXPORT
BOOLEAN
NTFS_SA::Read(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine reads the NTFS volume's boot sector from disk.
    If the read fails then a message will be printed and then
    we will attempt to find an alternate boot sector, looking
    first at the end of the volume and then in the middle.

Arguments:

    Message - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(Message);

    if (!SECRUN::Read()) {

        Message->DisplayMsg(MSG_NTFS_UNREADABLE_BOOT_SECTOR);

        _boot2 = _drive->QuerySectors() - 1;
        Relocate(_boot2);

        if (!SECRUN::Read() ||
            !IFS_SYSTEM::IsThisNtfs(_drive->QuerySectors(),
                                    _drive->QuerySectorSize(),
                                    (PVOID)_boot_sector)) {

            _boot2 = _drive->QuerySectors()/2;
            Relocate(_boot2);

            if (!SECRUN::Read() ||
                !IFS_SYSTEM::IsThisNtfs(_drive->QuerySectors(),
                                        _drive->QuerySectorSize(),
                                        (PVOID)_boot_sector)) {

                Message->DisplayMsg(MSG_NTFS_ALL_BOOT_SECTORS_UNREADABLE);

                _boot2 = 0;
                Relocate(0);
                return FALSE;
            }
        }

        Relocate(0);
    }

    UnpackBios(&_bpb, &(_boot_sector->PackedBpb));

    if (QueryVolumeSectors() < _drive->QuerySectors()) {
        _boot2 = _drive->QuerySectors() - 1;
    } else {
        _boot2 = _drive->QuerySectors() / 2;
    }

    return TRUE;
}



BOOLEAN
NTFS_SA::Write(
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine writes both of the NTFS volume's boot sector to disk.
    If the write fails on either of the boot sectors then a message
    will be printed.

Arguments:

    Message - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    DebugAssert(Message);

    PackBios(&_bpb, &(_boot_sector->PackedBpb));

    if (SECRUN::Write()) {

        Relocate(_boot2);

        if (!SECRUN::Write()) {

            Message->DisplayMsg(MSG_NTFS_SECOND_BOOT_SECTOR_UNWRITEABLE);
            return FALSE;
        }

        Relocate(0);

    } else {

        Message->DisplayMsg(MSG_NTFS_FIRST_BOOT_SECTOR_UNWRITEABLE);

        Relocate(_boot2);

        if (!SECRUN::Write()) {
            Message->DisplayMsg(MSG_NTFS_ALL_BOOT_SECTORS_UNWRITEABLE);
            Relocate(0);
            return FALSE;
        }

        Relocate(0);
    }

    return TRUE;
}

#if !defined( _AUTOCHECK_ ) && !defined( _SETUP_LOADER_ )


UNTFS_EXPORT
BOOLEAN
NTFS_SA::QueryFrsFromPath(
    IN     PCWSTRING                    FullPathFileName,
    IN OUT PNTFS_MASTER_FILE_TABLE      Mft,
    IN OUT PNTFS_BITMAP                 VolumeBitmap,
    OUT    PNTFS_FILE_RECORD_SEGMENT    TargetFrs,
    OUT    PBOOLEAN                     SystemFile,
    OUT    PBOOLEAN                     InternalError
    )
/*++

Routine Description:

    This method finds the file segment for a specified path.

Arguments:

    FullPathFileName    --  Supplies the full path to the file
    Mft                 --  Supplies the volume's Master File Table
    VolumeBitmap        --  Supplies the volume bitmap
    TargetFrs           --  Supplies a File Record Segment which will be
                            initialized to the desired File Record Segment
    SystemFile          --  Receives TRUE if the file is a system file
    InternalError       --  Receives TRUE if the method fails because of
                            a resource error.

Return Value:

    TRUE upon successful completion.

    If the method succeeds, TargetFrs is initialized to the desired
    File Record Segment.

    If the method fails because of a resource error (ie. because it cannot
    initialize an object), *InternalError is set to TRUE; if it fails
    because it can't find the file, then *InternalError is set to FALSE.

--*/
{
    PATH FullPath;
    NTFS_INDEX_TREE IndexTree;
    DSTRING IndexName;
    PWSTRING CurrentComponent;
    PARRAY PathComponents = NULL;
    PARRAY_ITERATOR Iterator = NULL;
    PFILE_NAME SearchName;
    MFT_SEGMENT_REFERENCE FileReference;
    VCN FileNumber;
    ULONG MaximumBytesInName;

    DebugPtrAssert( SystemFile );

    *SystemFile = FALSE;

    if( !IndexName.Initialize( FileNameIndexNameData ) ||
        !FullPath.Initialize( FullPathFileName ) ||
        (PathComponents = FullPath.QueryComponentArray()) == NULL ||
        (Iterator =
            (PARRAY_ITERATOR)PathComponents->QueryIterator()) == NULL ||
        !TargetFrs->Initialize( ROOT_FILE_NAME_INDEX_NUMBER, Mft ) ||
        !TargetFrs->Read() ||
        (MaximumBytesInName = TargetFrs->QuerySize()) == 0 ||
        (SearchName = (PFILE_NAME)
                      MALLOC(MaximumBytesInName+1+sizeof(FILE_NAME)))
            == NULL ) {

        DebugPrint( "QueryFrsFromPath--cannot initialize helpers\n" );

        if( SearchName != NULL ) {

            FREE( SearchName );
        }

        DELETE( PathComponents );
        DELETE( Iterator );

        *InternalError = TRUE;
        return FALSE;
    }

    while( (CurrentComponent = (PWSTRING)Iterator->GetNext()) != NULL ) {


        // Set up a FILE_NAME structure to be the search key.  We need
        // to set the length field in the header and copy the name.
        // Note that this method only deals with NTFS names (not DOS
        // names), so we also set the file name flag to FILE_NAME_NTFS.

        SearchName->FileNameLength = (UCHAR)CurrentComponent->QueryChCount();
        SearchName->Flags = FILE_NAME_NTFS;

        if( !CurrentComponent->QueryWSTR( 0,
                                          TO_END,
                                          NtfsFileNameGetName( SearchName ),
                                          MaximumBytesInName/sizeof(WCHAR) ) ||
            !IndexTree.Initialize( _drive,
                                   QueryClusterFactor(),
                                   VolumeBitmap,
                                   TargetFrs->GetUpcaseTable(),
                                   TargetFrs->
                                        QueryMaximumAttributeRecordSize(),
                                   TargetFrs,
                                   &IndexName ) ) {

            DebugPrint( "QueryFrsFromPath--Cannot initialize index tree.\n" );

            if( SearchName != NULL ) {

                FREE( SearchName );
            }

            DELETE( PathComponents );
            DELETE( Iterator );

            *InternalError = TRUE;
            return FALSE;
        }

        // Find the current component in the tree:

        if( !IndexTree.QueryFileReference( NtfsFileNameGetLength( SearchName ),
                                           SearchName,
                                           0,
                                           &FileReference,
                                           InternalError ) ) {

            if( SearchName != NULL ) {

                FREE( SearchName );
            }

            DELETE( PathComponents );
            DELETE( Iterator );

            return FALSE;
        }

        //  Initialize and read a File Record Segment based on that
        //  File Reference.  Not only must the FRS be readable, but
        //  its sequence number must match the sequence number in the
        //  File Reference.

        FileNumber.Set( FileReference.LowPart,
                        (LONG) FileReference.HighPart );

        if ( FileNumber < FIRST_USER_FILE_NUMBER )
            *SystemFile = TRUE;

        if( !TargetFrs->Initialize( FileNumber, Mft ) ||
            !TargetFrs->Read() ||
            !(FileReference == TargetFrs->QuerySegmentReference()) ) {

            // Either we were unable to initialize and read this FRS,
            // or its segment reference didn't match (ie. the sequence
            // number is wrong.

            if( SearchName != NULL ) {

                FREE( SearchName );
            }

            DELETE( PathComponents );
            DELETE( Iterator );

            *InternalError = TRUE;
            return FALSE;
        }
    }

    if ( SearchName != NULL ) {

        FREE( SearchName );
    }

    // If we got this far, no errors have been encountered, we've
    // processed the entire path, and TargetFrs has been initialized
    // to the File Record Segment we want.

    return TRUE;
}

#endif // _AUTOCHECK_ || _SETUP_LOADER_


VOID
NTFS_SA::SetVersionNumber(
    IN  UCHAR   Major,
    IN  UCHAR   Minor
    )
{
    _MajorVersion = Major;
    _MinorVersion = Minor;
}


VOID
NTFS_SA::QueryVersionNumber(
    OUT PUCHAR  Major,
    OUT PUCHAR  Minor
    )
{
    *Major = _MajorVersion;
    *Minor = _MinorVersion;
}


UNTFS_EXPORT
USHORT
NTFS_SA::QueryVolumeFlagsAndLabel(
    OUT PBOOLEAN    CorruptVolume,
    OUT PUCHAR      MajorVersion,
    OUT PUCHAR      MinorVersion,
    OUT PWSTRING    Label
    )
/*++

Routine Description:

    This routine fetches the volume flags.

Arguments:

    CorruptVolume   - Returns whether or not a volume corruption was
                        detected.
    MajorVersion    - Returns the major file system version number.
    MinorVersion    - Returns the minor file system version number.
    Label           - Returns the volume label if it exists

Return Value:

    The flags describing this volume's state and optionally the
    volume label

--*/
{
    NTFS_FRS_STRUCTURE      frs;
    HMEM                    hmem;
    LCN                     cluster_number, alternate;
    ULONG                   cluster_offset, alternate_offset;
    PVOID                   p;
    NTFS_ATTRIBUTE_RECORD   attr_rec;
    PVOLUME_INFORMATION     vol_info;
    PCWSTR                  vol_name;

    if (CorruptVolume) {
        *CorruptVolume = FALSE;
    }

    if (MajorVersion) {
        *MajorVersion = 0;
    }

    if (MinorVersion) {
        *MinorVersion = 0;
    }

    if (Label && !Label->Initialize()) {
        DebugAbort("UNTFS: Out of memory\n");
        return FALSE;
    }

    ULONG cluster_size = QueryClusterFactor() * _drive->QuerySectorSize();

    cluster_number = (VOLUME_DASD_NUMBER * QueryFrsSize())/ cluster_size +
        QueryMftStartingLcn();

    cluster_offset = (QueryMftStartingLcn()*cluster_size +
        VOLUME_DASD_NUMBER * QueryFrsSize() - cluster_number * cluster_size).GetLowPart();

    DebugAssert(cluster_offset < cluster_size);

    alternate = (VOLUME_DASD_NUMBER * QueryFrsSize())/ cluster_size +
        QueryMft2StartingLcn();

    alternate_offset = (QueryMft2StartingLcn()*cluster_size +
        VOLUME_DASD_NUMBER * QueryFrsSize() - alternate * cluster_size).GetLowPart();

    for (;;) {

        if (!hmem.Initialize() ||
            !frs.Initialize(&hmem, _drive, cluster_number,
                            QueryClusterFactor(),
                            QueryVolumeSectors(),
                            QueryFrsSize(),
                            NULL,
                            cluster_offset) ||
            !frs.Read()) {

            if (cluster_number == alternate) {
                break;
            } else {
                cluster_number = alternate;
                cluster_offset = alternate_offset;
                continue;
            }
        }

        p = NULL;
        while (p = frs.GetNextAttributeRecord(p)) {

            if (!attr_rec.Initialize(GetDrive(), p)) {
                // the attribute record containing the volume flags
                // is not available--this means that the volume is
                // dirty.
                //
                return VOLUME_DIRTY;
            }

#if ($VOLUME_NAME > $VOLUME_INFORMATION)
#error  Attribute type $VOLUME_NAME should be smaller than that of $VOLUME_INFORMATION
#endif

            if (Label &&
                attr_rec.QueryTypeCode() == $VOLUME_NAME &&
                attr_rec.QueryNameLength() == 0 &&
                attr_rec.QueryResidentValueLength() <= 256 &&
                (vol_name = (PCWSTR) attr_rec.GetResidentValue())) {

                if (!Label->Initialize(vol_name,
                                       attr_rec.QueryResidentValueLength()/sizeof(WCHAR))) {
                    DebugAbort("UNTFS: Out of memory\n");
                    return FALSE;
                }
            }
            if (attr_rec.QueryTypeCode() == $VOLUME_INFORMATION &&
                attr_rec.QueryNameLength() == 0 &&
                attr_rec.QueryRecordLength() > SIZE_OF_RESIDENT_HEADER &&
                attr_rec.QueryResidentValueLength() < attr_rec.QueryRecordLength() &&
                (attr_rec.QueryRecordLength() - attr_rec.QueryResidentValueLength()) >=
                attr_rec.QueryResidentValueOffset() &&
                attr_rec.QueryResidentValueLength() >= sizeof(VOLUME_INFORMATION) &&
                (vol_info = (PVOLUME_INFORMATION) attr_rec.GetResidentValue())) {

                if (MajorVersion) {
                    *MajorVersion = vol_info->MajorVersion;
                }

                if (MinorVersion) {
                    *MinorVersion = vol_info->MinorVersion;
                }

                if (*MajorVersion > 3) {
                    break;  // try the mirror copy
                }

                return (vol_info->VolumeFlags);
            }
        }

        // If the desired attribute wasn't found in the first
        // volume dasd file then check the mirror.

        if (cluster_number == alternate) {
            break;
        } else {
            cluster_number = alternate;
            cluster_offset = alternate_offset;
        }
    }

    if (CorruptVolume) {
        *CorruptVolume = TRUE;
    }

    return VOLUME_DIRTY;
}


BOOLEAN
NTFS_SA::ClearVolumeFlag(
    IN      USHORT                  FlagsToClear,
    IN OUT  PNTFS_LOG_FILE          LogFile,
    IN      BOOLEAN                 WriteSecondLogFilePage,
    IN      LSN                     LargestVolumeLsn,
    OUT     PBOOLEAN                CorruptVolume,
    IN      BOOLEAN                 UpdateMirror
    )
/*++

Routine Description:

    This routine sets the volume clean.

Arguments:

    FlagsToClear            - Supplies the volume flags to clear.
    LogFile                 - Supplies a valid log file.  May be NULL,
                              in which case the log file will not be
                              modified.
    WriteSecondLogFilePage  - Supplies whether or not to write the second
                                log file page.  Ignored if LogFile is NULL.
    LargestVolumeLsn        - This supplies the largest LSN on the volume.
                                This parameter will be used if and
                                only if the previous parameter is TRUE.
    CorruptVolume           - Returns whether or not the volume is corrupt.
    UpdateMirror            - Update the mirror copy of the file record segment

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FRS_STRUCTURE          frs;
    HMEM                        hmem;
    LCN                         volume_file_lcn;
    ULONG                       volume_file_offset;
    PVOID                       p;
    NTFS_ATTRIBUTE_RECORD       attr_rec;
    PVOLUME_INFORMATION         vol_info;
    ULONG                       cluster_size;

    cluster_size = QueryClusterFactor() * _drive->QuerySectorSize();

    if (CorruptVolume) {
        *CorruptVolume = FALSE;
    }

    // Compute the cluster that holds the start of the volume file frs and
    // the offset into that cluster (which will be zero unless the frs size
    // is less than the cluster size.)
    //

    volume_file_lcn = QueryMftStartingLcn();
    volume_file_offset = VOLUME_DASD_NUMBER * QueryFrsSize();

    for (;;) {
        if (!hmem.Initialize() ||
            !frs.Initialize(&hmem, _drive, volume_file_lcn,
                            QueryClusterFactor(),
                            QueryVolumeSectors(),
                            QueryFrsSize(),
                            NULL,
                            volume_file_offset) ||
            !frs.Read()) {

            return FALSE;
        }

        p = NULL;
        while (p = frs.GetNextAttributeRecord(p)) {

            if (!attr_rec.Initialize(GetDrive(), p)) {
                return FALSE;
            }

            if (attr_rec.QueryTypeCode() == $VOLUME_INFORMATION &&
                attr_rec.QueryNameLength() == 0 &&
                attr_rec.QueryRecordLength() > SIZE_OF_RESIDENT_HEADER &&
                attr_rec.QueryResidentValueLength() < attr_rec.QueryRecordLength() &&
                (attr_rec.QueryRecordLength() - attr_rec.QueryResidentValueLength()) >=
                attr_rec.QueryResidentValueOffset() &&
                attr_rec.QueryResidentValueLength() >= sizeof(VOLUME_INFORMATION) &&
                (vol_info = (PVOLUME_INFORMATION) attr_rec.GetResidentValue())) {

                break;
            }
        }

        if (!p) {
            if (CorruptVolume) {
                *CorruptVolume = TRUE;
            }
            return FALSE;
        }

        vol_info->VolumeFlags &= ~(FlagsToClear);
        if (!frs.Write()) {
            return FALSE;
        }

        if (!UpdateMirror ||
            volume_file_lcn == QueryMft2StartingLcn())
            break;

        volume_file_lcn = QueryMft2StartingLcn();
    }

    if( LogFile ) {

        return LogFile->MarkVolumeChecked(WriteSecondLogFilePage,
                                          LargestVolumeLsn);
    } else {

        return TRUE;
    }
}


UCHAR
NTFS_SA::PostReadMultiSectorFixup(
    IN OUT  PVOID           MultiSectorBuffer,
    IN      ULONG           BufferSize,
    IN      PIO_DP_DRIVE    Drive,
    IN      ULONG           ValidSize
    )
/*++

Routine Description:

    This routine first verifies that the first element of the
    update sequence array is written at the end of every
    SEQUENCE_NUMBER_STRIDE bytes till it exceeds the given
    valid size.  If not, then this routine returns FALSE.

    Otherwise this routine swaps the following elements in the
    update sequence array into the appropriate positions in the
    multi sector buffer.

    This routine will also check to make sure that the update
    sequence array is valid and that the BufferSize is appropriate
    for this size of update sequence array.  Otherwise, this
    routine will not update the array sequence and return TRUE.

Arguments:

    MultiSectorBuffer   - Supplies the buffer to be updated.
    BufferSize          - Supplies the number of bytes in this
                            buffer.
    Drive               - Supplies the drive that this MultiSectorBuffer is on
    ValidSize           - Supplies the number of bytes that is
                          valid in this buffer

Return Value:

    UpdateSequenceArrayCheckValueOk (always non-zero)
         - If everything is ok.  If any valid sector does not
           contain the check value, the header signature will
           be changed to 'BAAD'.
    UpdateSequenceArrayMinorError
         - Same as 1 except the check value beyond ValidSize
           is incorrect.
--*/
{
    PUNTFS_MULTI_SECTOR_HEADER  pheader;
    USHORT                      i, size, offset;
    PUPDATE_SEQUENCE_NUMBER     parray, pnumber;
    UCHAR                       rtncode = UpdateSequenceArrayCheckValueOk;

    pheader = (PUNTFS_MULTI_SECTOR_HEADER) MultiSectorBuffer;
    size = pheader->UpdateSequenceArraySize;
    offset = pheader->UpdateSequenceArrayOffset;

    if (BufferSize%SEQUENCE_NUMBER_STRIDE ||
        offset%sizeof(UPDATE_SEQUENCE_NUMBER) ||
        offset + size*sizeof(UPDATE_SEQUENCE_NUMBER) > BufferSize ||
        BufferSize/SEQUENCE_NUMBER_STRIDE + 1 != size) {

#if 0
        // This can happen naturally but the in use bit of the frs should be cleared.
        if (Drive) {

            PMESSAGE    msg = Drive->GetMessage();

            if (msg) {
                msg->Lock();
                msg->Set(MSG_CHKLOG_NTFS_INCORRECT_MULTI_SECTOR_HEADER);
                msg->Log("%x%x%x", BufferSize, offset, size);
                msg->DumpDataToLog(pheader, 0x40);
                msg->Unlock();
            }
        }
        DebugPrintTrace(("Incorrect multi-sector header with total size %d,\n"
                         "USA offset %d, and USA count %d\n",
                         BufferSize, offset, size));
#endif

        return rtncode;
    }

    parray = (PUPDATE_SEQUENCE_NUMBER) ((PCHAR) pheader + offset);

    pnumber = (PUPDATE_SEQUENCE_NUMBER)
              ((PCHAR) pheader + (SEQUENCE_NUMBER_STRIDE -
                                  sizeof(UPDATE_SEQUENCE_NUMBER)));

    for (i = 1; i < size; i++) {

        if (*pnumber != parray[0]) {
            if (ValidSize > 0) {

                if (Drive) {

                    PMESSAGE msg = Drive->GetMessage();

                    if (msg) {
                        msg->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_USA,
                                     "%x%x%x", size, *pnumber, parray[0]);
                    }
                }

                DebugPrintTrace(("Incorrect USA check value at block %d.\n"
                                 "The expected value is %d but found %d\n",
                                 i, *pnumber, parray[0]));

                pheader->Signature[0] = 'B';
                pheader->Signature[1] = 'A';
                pheader->Signature[2] = 'A';
                pheader->Signature[3] = 'D';
                return rtncode;
            } else
                rtncode = UpdateSequenceArrayCheckValueMinorError;
        }

        *pnumber = parray[i];

        if (ValidSize >= SEQUENCE_NUMBER_STRIDE)
            ValidSize -= SEQUENCE_NUMBER_STRIDE;
        else
            ValidSize = 0;

        pnumber = (PUPDATE_SEQUENCE_NUMBER)
                  ((PCHAR) pnumber + SEQUENCE_NUMBER_STRIDE);
    }

    return rtncode;
}


VOID
NTFS_SA::PreWriteMultiSectorFixup(
    IN OUT  PVOID   MultiSectorBuffer,
    IN      ULONG   BufferSize
    )
/*++

Routine Description:

    This routine first checks to see if the update sequence
    array is valid.  If it is then this routine increments the
    first element of the update sequence array.  It then
    writes the value of the first element into the buffer at
    the end of every SEQUENCE_NUMBER_STRIDE bytes while
    saving the old values of those locations in the following
    elements of the update sequence arrary.

Arguments:

    MultiSectorBuffer   - Supplies the buffer to be updated.
    BufferSize          - Supplies the number of bytes in this
                            buffer.

Return Value:

    None.

--*/
{
    PUNTFS_MULTI_SECTOR_HEADER    pheader;
    USHORT                  i, size, offset;
    PUPDATE_SEQUENCE_NUMBER parray, pnumber;

    pheader = (PUNTFS_MULTI_SECTOR_HEADER) MultiSectorBuffer;
    size = pheader->UpdateSequenceArraySize;
    offset = pheader->UpdateSequenceArrayOffset;

    if (BufferSize%SEQUENCE_NUMBER_STRIDE ||
        offset%sizeof(UPDATE_SEQUENCE_NUMBER) ||
        offset + size*sizeof(UPDATE_SEQUENCE_NUMBER) > BufferSize ||
        BufferSize/SEQUENCE_NUMBER_STRIDE + 1 != size) {

        return;
    }

    parray = (PUPDATE_SEQUENCE_NUMBER) ((PCHAR) pheader + offset);


    // Don't allow 0 or all F's to be the update character.

    do {
        parray[0]++;
    } while (parray[0] == 0 || parray[0] == (UPDATE_SEQUENCE_NUMBER) -1);


    for (i = 1; i < size; i++) {

        pnumber = (PUPDATE_SEQUENCE_NUMBER)
                  ((PCHAR) pheader + (i*SEQUENCE_NUMBER_STRIDE -
                   sizeof(UPDATE_SEQUENCE_NUMBER)));

        parray[i] = *pnumber;
        *pnumber = parray[0];
    }
}



UNTFS_EXPORT
BOOLEAN
NTFS_SA::IsNtfsName(
    IN  PCFILE_NAME FileName
    )
/*++

Routine Description:

    This routine computes whether or not the given file name would
    be appropriate under ntfs naming convention. 
    
Arguments:

    FileName    - Supplies the file name to check.

Return Value:

    FALSE   - The supplied name is not a NTFS file name.
    TRUE    - The supplied name is a valid NTFS file name.

--*/
{
    ULONG Index; 
    ULONG NameLength; 
    PCWCHAR NameBuffer; 

    NameLength = FileName->FileNameLength;
    NameBuffer = FileName->FileName;


    //
    //  It better be a unicode string of non-zero length.
    //
    if (NameLength == 0) {

        return FALSE;

    } else {

        //
        //  Check if corresponds to a legal single Ntfs Name.
        //

        for (Index = 0; Index < NameLength; Index += 1) {

            WCHAR Char;

            Char = NameBuffer[Index];

            //
            //  Check for wild card characters (they aren't allowed) and
            //  check for the other illegal characters including the colon and
            //  backslash characters since this can only be a single component.
            //  The list of valid NTFS characters is derived from 
            //  'LocalLegalAnsiCharacterArray' in '/nt/base/ntos/fsrtl/fsrtlpc.c'
            //

            if (Char < 32) {
                return FALSE;
            }

            switch (Char) {
                case '"':
                case '*':
                case '<':
                case '>':
                case '?':
                case '\\':
                case ':':    
                case '|':
                case '/':
                    return FALSE;
            }
        }

    }

    return TRUE;

}

UNTFS_EXPORT
BOOLEAN
NTFS_SA::IsDosName(
    IN  PCFILE_NAME FileName
    )
/*++

Routine Description:

    This routine computes whether or not the given file name would
    be appropriate under DOS's 8.3 naming convention.

Arguments:

    FileName    - Supplies the file name to check.

Return Value:

    FALSE   - The supplied name is not a DOS file name.
    TRUE    - The supplied name is a valid DOS file name.

--*/
{
    ULONG   i, n, name_length, ext_length;
    BOOLEAN dot_yet;
    PCWCHAR p;

    n = FileName->FileNameLength;
    p = FileName->FileName;
    name_length = n;
    ext_length = 0;

    if (n > 12) {
        return FALSE;
    }

    dot_yet = FALSE;
    for (i = 0; i < n; i++) {

        if (p[i] < 32) {
            return FALSE;
        }

        switch (p[i]) {
            case '*':
            case '?':
            case '/':
            case '\\':
            case '|':
            case ',':
            case ';':
            case ':':
            case '+':
            case '=':
            case '<':
            case '>':
            case '[':
            case ']':
            case '"':
                return FALSE;

            case '.':
                if (dot_yet) {
                    return FALSE;
                }
                dot_yet = TRUE;
                name_length = i;
                ext_length = n - i - 1;
                break;
        }
    }

    if (!name_length) {
        return dot_yet && n == 1;
    }

    if (name_length > 8 ||
        p[name_length - 1] == ' ') {

        return FALSE;
    }

    if (!ext_length) {
        return !dot_yet;
    }

    if (ext_length > 3 ||
        p[name_length + 1 + ext_length - 1] == ' ') {

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::IsValidLabel(
    IN PCWSTRING    Label
    )
/*++

Routine Description:

    This method determines whether a specified string is a
    valid NTFS volume label.

Arguments:

    Label   --  Supplies the string to check.

Return Value:

    TRUE if the string is a valid NTFS label.

--*/
{
    CHNUM StringLength, i;

    StringLength = Label->QueryChCount();

    // Limit the ntfs label to 32 characters
    // The placeholder for the label in the VPB can hold only MAXIMUM_VOLUME_LABEL_LENGTH characters
    // as defined in base\ntos\inc\io.h. So all volume labels are limited to that maximum length
    if (StringLength > 32)
        return FALSE;

    for( i = 0; i < StringLength; i++ ) {

        if (Label->QueryChAt(i) < 32) {
            return FALSE;
        }

        /* This check has been removed since NTFS has no restriction on the
           characters that can be used in the label. The code has been retained 
           in case an checks need to be put in in the future  - saroshh
           
        switch (Label->QueryChAt(i)) {
            case '*':
            case '?':
            case '/':
            case '\\':
            case '|':
            case '<':
            case '>':
            case '"':
                return FALSE;
        }
        */
    }

    return TRUE;
}


ULONG
NTFS_SA::QueryDefaultClusterFactor(
    IN PCDP_DRIVE   Drive
    )
/*++

Routine Description:

    This method returns the default number of sectors per cluster
    for a given drive.

Arguments:

    Drive   --  Supplies the drive under consideration.

Return Value:

    The appropriate default cluster factor.

--*/
{
    // Hold off on this analysis until testing says ok.

    BIG_INT cbDiskSize;
    ULONG   cbClusterSize, csecClusterSize;

    cbDiskSize = Drive->QuerySectors()*Drive->QuerySectorSize();

    if (cbDiskSize > (ULONG) 2*1024*1024*1024) {    // > 2 Gig
        cbClusterSize = 4096;
    } else if (cbDiskSize > 1024*1024*1024) {       // > 1 Gig
        cbClusterSize = 2048;
    } else if (cbDiskSize > 512*1024*1024) {        // > 512 Meg
        cbClusterSize = 1024;
    } else {
        cbClusterSize = 512;
    }

    csecClusterSize = cbClusterSize/Drive->QuerySectorSize();
    if (!csecClusterSize) {
        csecClusterSize = 1;
    }

    return csecClusterSize;
}

UNTFS_EXPORT
ULONG
NTFS_SA::QueryDefaultClustersPerIndexBuffer(
    IN PCDP_DRIVE   Drive,
    IN ULONG        ClusterFactor
    )
/*++

Routine Description:

    This method computes the default number of clusters per
    NTFS index allocation buffer.

Arguments:

    Drive           --  supplies the drive under consideration.
    ClusterFactor   --  Supplies the cluster factor for the drive.

Return Value:

    The default number of clusters per NTFS index allocation
    buffer.

--*/
{
    ULONG   ClusterSize;

    if (ClusterFactor) {

        ClusterSize = Drive->QuerySectorSize() * ClusterFactor;

        if (ClusterSize > SMALL_INDEX_BUFFER_SIZE) {

            return 0;
        }

        return( ( SMALL_INDEX_BUFFER_SIZE + ClusterSize - 1 ) / ClusterSize );

    } else {

        ClusterSize = Drive->QuerySectorSize();

        if (ClusterSize > SMALL_INDEX_BUFFER_SIZE) {

            return 0;
        }
        return( ( SMALL_INDEX_BUFFER_SIZE + ClusterSize - 1 ) / ClusterSize );
    }
}

BOOLEAN
NTFS_SA::LogFileMayNeedResize(
    )
/*++

Routine Description:

    This routine

Arguments:



Return Value:

    FALSE           - Failure.
    TRUE            - Success.

--*/
{
    NTFS_FRS_STRUCTURE frs;
    HMEM hmem;
    PVOID p;
    NTFS_ATTRIBUTE_RECORD attr_rec;
    LCN log_file_lcn;
    ULONG log_file_offset;
    BIG_INT log_file_size;
    ULONG cluster_size;

    cluster_size = QueryClusterFactor() * _drive->QuerySectorSize();

    log_file_lcn = QueryMftStartingLcn();
    log_file_offset =  LOG_FILE_NUMBER * QueryFrsSize();

    if (!hmem.Initialize() ||
        !frs.Initialize(&hmem, _drive,
            log_file_lcn,
            QueryClusterFactor(),
            QueryVolumeSectors(),
            QueryFrsSize(),
            NULL,
            log_file_offset) ||
        !frs.Read()) {

        return TRUE;
    }

    p = NULL;
    while (NULL != (p = frs.GetNextAttributeRecord(p))) {

        if (!attr_rec.Initialize(GetDrive(), p)) {
            return TRUE;
        }

        if ($DATA == attr_rec.QueryTypeCode()) {

            ULONG max_size, min_size;

            attr_rec.QueryValueLength(&log_file_size);

            max_size = NTFS_LOG_FILE::QueryMaximumSize(_drive, QueryVolumeSectors());
            min_size = NTFS_LOG_FILE::QueryMinimumSize(_drive, QueryVolumeSectors());

            if (log_file_size < min_size ||
                log_file_size > max_size) {

                return TRUE;

            } else {

                return FALSE;
            }
        }
    }

    return TRUE;
}

UNTFS_EXPORT
BOOLEAN
NTFS_SA::SetVolumeFlag(
    IN      USHORT                  FlagsToSet,
    OUT     PBOOLEAN                CorruptVolume
    )
/*++

Routine Description:

    This routine sets the volume dirty.

Arguments:

    FlagsToSet              - Supplies the volume flags to set.
    CorruptVolume           - Returns whether or not the volume is corrupt.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FRS_STRUCTURE          frs;
    HMEM                        hmem;
    LCN                         volume_file_lcn;
    ULONG                       volume_file_offset;
    PVOID                       p;
    NTFS_ATTRIBUTE_RECORD       attr_rec;
    PVOLUME_INFORMATION         vol_info;

    if (CorruptVolume) {
        *CorruptVolume = FALSE;
    }

    ULONG cluster_size = QueryClusterFactor() * _drive->QuerySectorSize();

    volume_file_lcn = QueryMftStartingLcn();
    volume_file_offset = VOLUME_DASD_NUMBER * QueryFrsSize();

    if (!hmem.Initialize() ||
        !frs.Initialize(&hmem, _drive, volume_file_lcn,
                        QueryClusterFactor(),
                        QueryVolumeSectors(),
                        QueryFrsSize(),
                        NULL,
                        volume_file_offset) ||
        !frs.Read()) {

        return FALSE;
    }

    p = NULL;
    while (p = frs.GetNextAttributeRecord(p)) {

        if (!attr_rec.Initialize(GetDrive(), p)) {
            return FALSE;
        }

        if (attr_rec.QueryTypeCode() == $VOLUME_INFORMATION &&
            attr_rec.QueryNameLength() == 0 &&
            attr_rec.QueryResidentValueLength() >= sizeof(VOLUME_INFORMATION) &&
            (vol_info = (PVOLUME_INFORMATION) attr_rec.GetResidentValue())) {

            break;
        }
    }

    if (!p) {
        if (CorruptVolume) {
            *CorruptVolume = TRUE;
        }
        return FALSE;
    }

    vol_info->VolumeFlags |= FlagsToSet;
    if (!frs.Write()) {
        return FALSE;
    }

    return TRUE;
}

UNTFS_EXPORT
BOOLEAN
NTFS_SA::Read(
    )
/*++

Routine Description:

    This routine simply calls the other read with the default message
    object.

Arguments:

    None.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE msg;

    return Read(&msg);
}

UNTFS_EXPORT
UCHAR
NTFS_SA::QueryClusterFactor(
    ) CONST
/*++

Routine Description:

    This routine returns the number of sectors per cluster.

Arguments:

    None.

Return Value:

    The number of sectors per cluster.

--*/
{
    return _bpb.SectorsPerCluster;
}

UNTFS_EXPORT
BOOLEAN
NTFS_SA::TakeCensus(
    IN  PNTFS_MASTER_FILE_TABLE     Mft,
    IN  ULONG                       ResidentFileSizeThreshhold,
    OUT PNTFS_CENSUS_INFO           Census
    )
/*++

Routine Description:

    This routine examines the MFT and makes a census report on the
    volume.  This is used by convert to determine whether there will
    be enough space on the volume to convert from NTFS to the new
    filesystem.

Arguments:

    ResidentFileSizeThreshhold - Used to determine whether a given resident
                file should be placed in the "small" or "large" resident file
                category.

    Census      - Returns the census information.


Return Value:

    FALSE           - Failure.
    TRUE            - Success.

--*/
{
    BOOLEAN                     error;
    NTFS_ATTRIBUTE              attrib;
    NTFS_FILE_RECORD_SEGMENT    frs;
    ULONG                       i, j;
    ULONG                       num_frs;
    ULONG                       length;

    memset(Census, 0, sizeof(*Census));

    Census->NumFiles;
    Census->BytesLgResidentFiles;
    Census->BytesIndices;
    Census->BytesExternalExtentLists;
    Census->BytesFileNames;

    num_frs = Mft->GetDataAttribute()->QueryValueLength().GetLowPart() / Mft->QueryFrsSize();

    for (i = 0; i < num_frs; i += 1) {

        if (i < FIRST_USER_FILE_NUMBER && i != ROOT_FILE_NAME_INDEX_NUMBER) {
            continue;
        }

        if (!frs.Initialize(i, Mft)) {
            return FALSE;
        }

        if (!frs.Read()) {
            return FALSE;
        }
        if (!frs.IsInUse() || !frs.IsBase()) {
            continue;
        }

        Census->NumFiles += 1;

        //
        // Examine all the data attributes and see which are Large and
        // resident.
        //

        for (j = 0; frs.QueryAttributeByOrdinal(&attrib, &error, $DATA, j); ++j) {

            length = attrib.QueryValueLength().GetLowPart();

            if (attrib.IsResident() && length > ResidentFileSizeThreshhold) {
                Census->BytesLgResidentFiles +=  length;
            }
        }

        //
        // If there's an index present, add in its size.  (We assume there's
        // no more than one.
        //

        if (frs.IsIndexPresent()) {

            if (frs.QueryAttributeByOrdinal(&attrib, &error,
                $INDEX_ALLOCATION, 0)) {

                length = attrib.QueryValueLength().GetLowPart();
                Census->BytesIndices += length;
            }
        }

        //
        // Query all the file names and add in the space they occupy.
        //

        for (j = 0; frs.QueryAttributeByOrdinal(&attrib, &error,
            $FILE_NAME, j); ++j) {

            length = attrib.QueryValueLength().GetLowPart();

            Census->BytesFileNames +=  length;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\ntfschk.cxx ===
/*++

Copyright (c) 1991-2001 Microsoft Corporation

Module Name:

    ntfschk.cxx

Abstract:

    This module implements NTFS CHKDSK.

Author:

    Norbert P. Kusters (norbertk) 29-Jul-91

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

//#define TIMING_ANALYSIS 1
#define USE_CHKDSK_BIT
#define BLOCK_SIZE 256

#include "ulib.hxx"
#include "ntfssa.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "ntfsbit.hxx"
#include "attrcol.hxx"
#include "frsstruc.hxx"
#include "attrib.hxx"
#include "attrrec.hxx"
#include "attrlist.hxx"
#include "list.hxx"
#include "iterator.hxx"
#include "attrdef.hxx"
#include "extents.hxx"
#include "mft.hxx"
#include "mftref.hxx"
#include "bootfile.hxx"
#include "badfile.hxx"
#include "mftfile.hxx"
#include "numset.hxx"
#include "ifssys.hxx"
#include "indxtree.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
#include "frs.hxx"
#include "digraph.hxx"
#include "logfile.hxx"
#include "rcache.hxx"
#include "ifsentry.hxx"

// This global variable used by CHKDSK to compute the largest
// LSN and USN on the volume.

LSN             LargestLsnEncountered;
LARGE_INTEGER   LargestUsnEncountered;
ULONG64         FrsOfLargestUsnEncountered;

struct NTFS_CHKDSK_INTERNAL_INFO {
    ULONG           TotalFrsCount;
    ULONG           BaseFrsCount;
    BIG_INT         TotalNumFileNames;
    ULONG           FilesWithObjectId;
    ULONG           FilesWithReparsePoint;
    ULONG           TotalNumSID;
    LARGE_INTEGER   ElapsedTimeForFileVerification;
    LARGE_INTEGER   ElapsedTimeForIndexVerification;
    LARGE_INTEGER   ElapsedTimeForSDVerification;
    LARGE_INTEGER   ElapsedTimeForUserSpaceVerification;
    LARGE_INTEGER   ElapsedTimeForFreeSpaceVerification;
    LARGE_INTEGER   ElapsedTotalTime;
    LARGE_INTEGER   TimerFrequency;
};

BOOLEAN
EnsureValidFileAttributes(
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   Frs,
    IN OUT  PNTFS_INDEX_TREE            ParentIndex,
       OUT  PBOOLEAN                    SaveIndex,
    IN      ULONG                       FileAttributes,
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message
);

VOID
QueryFileNameFromIndex(
    IN      PFILE_NAME  P,
       OUT  PWCHAR      Buffer,
    IN      CHNUM       BufferLength
);

BOOLEAN
UpdateChkdskInfo(
    IN OUT  PNTFS_FRS_STRUCTURE Frs,
    IN OUT  PNTFS_CHKDSK_INFO   ChkdskInfo,
    IN OUT  PMESSAGE            Message
    )
/*++

Routine Description:

    This routine computes the necessary changes to the chkdsk information
    for this FRS.

Arguments:

    Frs         - Supplies the base FRS.
    ChkdskInfo  - Supplies the current chkdsk information.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG                       file_number;
    BOOLEAN                     is_multi;
    NTFS_ATTRIBUTE_LIST         attr_list;
    PATTRIBUTE_RECORD_HEADER    precord;
    ATTRIBUTE_TYPE_CODE         type_code;
    VCN                         vcn;
    MFT_SEGMENT_REFERENCE       seg_ref;
    USHORT                      tag;
    DSTRING                     name;
    ULONG                       name_length;
    BOOLEAN                     data_present;
    PSTANDARD_INFORMATION2      pstandard;
    ATTR_LIST_CURR_ENTRY        entry;

    file_number = Frs->QueryFileNumber().GetLowPart();

    ChkdskInfo->ReferenceCount[file_number] =
            (SHORT) Frs->QueryReferenceCount();

    if (Frs->QueryReferenceCount() == 0) {

        if (!ChkdskInfo->FilesWithNoReferences.Add(file_number)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    data_present = FALSE;
    is_multi = Frs->QueryAttributeList(&attr_list) && attr_list.ReadList();
    precord = NULL;
    entry.CurrentEntry = NULL;
    for (;;) {

        if (is_multi) {
            if (!attr_list.QueryNextEntry(&entry,
                                          &type_code,
                                          &vcn,
                                          &seg_ref,
                                          &tag,
                                          &name)) {
                break;
            }
            name_length = name.QueryChCount();
        } else {
            if (!(precord = (PATTRIBUTE_RECORD_HEADER)
                            Frs->GetNextAttributeRecord(precord))) {
                break;
            }
            type_code = precord->TypeCode;
            name_length = precord->NameLength;
        }

        switch (type_code) {

            case $STANDARD_INFORMATION:
                if (ChkdskInfo->major >= 2) {
                    if (is_multi) {
                        precord = (PATTRIBUTE_RECORD_HEADER)
                                  Frs->GetAttribute($STANDARD_INFORMATION);
                        if (precord == NULL) {
                            DebugPrintTrace(("Standard Information does not exist "
                                        "in base FRS 0x%I64x\n",
                                        Frs->QueryFileNumber().GetLargeInteger()));
                            return FALSE;
                        }
                        if (precord->Form.Resident.ValueLength ==
                            SIZEOF_NEW_STANDARD_INFORMATION) {

                            pstandard = (PSTANDARD_INFORMATION2)
                                        ((PCHAR)precord +
                                         precord->Form.Resident.ValueOffset);
                            if (pstandard->Usn > LargestUsnEncountered) {
                                LargestUsnEncountered = pstandard->Usn;
                                FrsOfLargestUsnEncountered = file_number;
                            }
                        }
                    } else {
                        if (precord->Form.Resident.ValueLength ==
                            SIZEOF_NEW_STANDARD_INFORMATION) {
                            pstandard = (PSTANDARD_INFORMATION2)
                                        ((PCHAR) precord +
                                         precord->Form.Resident.ValueOffset);
                            if (pstandard->Usn > LargestUsnEncountered) {
                                LargestUsnEncountered = pstandard->Usn;
                                FrsOfLargestUsnEncountered = file_number;
                            }
                        }
                    }
                }
                ChkdskInfo->BaseFrsCount++;
                break;

            case $FILE_NAME:
                ChkdskInfo->TotalNumFileNames += 1;
                ChkdskInfo->NumFileNames[file_number]++;
                break;

            case $INDEX_ROOT:
                ChkdskInfo->CountFilesWithIndices += 1;

            case $INDEX_ALLOCATION:
                ChkdskInfo->FilesWithIndices.SetAllocated(file_number, 1);
                break;

            case $OBJECT_ID:
                if (ChkdskInfo->major >= 2 &&
                    !ChkdskInfo->FilesWithObjectId.Add(file_number)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                break;

            case $REPARSE_POINT:
                if (ChkdskInfo->major >= 2)
                    ChkdskInfo->FilesWithReparsePoint.SetAllocated(file_number, 1);
                break;

            case $EA_INFORMATION:
            case $EA_DATA:
                if (!ChkdskInfo->FilesWithEas.Add(file_number)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                break;

            case $DATA:
                if (!name_length) {
                    data_present = TRUE;
                }
                break;

            default:
                break;
        }
    }

    if (!data_present) {

        ChkdskInfo->FilesWhoNeedData.SetAllocated(file_number, 1);
    }

    return TRUE;
}


BOOLEAN
EnsureValidParentFileName(
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   Frs,
    IN      FILE_REFERENCE              ParentFileReference,
    OUT     PBOOLEAN                    Changes
    )
/*++

Routine Description:

    This method ensures that all file_names for the given file
    point back to the given root-file-reference.

Arguments:

    ChkdskInfo          - Supplies the current chkdsk info.
    Frs                 - Supplies the Frs to verify.
    ParentFileReference - Supplies the file reference for the parent directory.
    Changes             - Returns whether or not there were changes to
                             the file record.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG           i;
    BOOLEAN         error;
    NTFS_ATTRIBUTE  attribute;
    PFILE_NAME      p;
    CHAR            buffer[sizeof(FILE_NAME) + 20*sizeof(WCHAR)];
    WCHAR           buffer1[20];
    WCHAR           buffer2[20];
    PFILE_NAME      new_file_name = (PFILE_NAME) buffer;
    DSTRING         file_name_text;
    BOOLEAN         success;
    ULONG           file_number;
    BOOLEAN         correct_name_encountered;
    BOOLEAN         no_file_name;

    DebugAssert(Changes);
    *Changes = FALSE;

    file_number = Frs->QueryFileNumber().GetLowPart();

    if (ChkdskInfo) {
        if (!GetSystemFileName(ChkdskInfo->major,
                               file_number,
                               &file_name_text,
                               &no_file_name))
            return FALSE;
    } else
        no_file_name = TRUE;

    correct_name_encountered = FALSE;

    for (i = 0; Frs->QueryAttributeByOrdinal(&attribute, &error,
                                             $FILE_NAME, i); i++) {

        p = (PFILE_NAME) attribute.GetResidentValue();
        DebugAssert(p);


        // Remove any file-name that doesn't point back to the root.

        if (!(p->ParentDirectory == ParentFileReference)) {

            PMESSAGE    msg;

            *Changes = TRUE;

            msg = Frs->GetDrive()->GetMessage();
            msg->LogMsg(MSG_CHKLOG_NTFS_FILENAME_HAS_INCORRECT_PARENT,
                         "%I64x%I64x%I64x",
                     Frs->QueryFileNumber().GetLargeInteger(),
                     p->ParentDirectory,
                     ParentFileReference);

            Frs->DeleteResidentAttribute($FILE_NAME, NULL, p,
                attribute.QueryValueLength().GetLowPart(), &success);
            if (ChkdskInfo)
                ChkdskInfo->NumFileNames[file_number]--;
            continue;
        }

        if (!no_file_name) {
            file_name_text.QueryWSTR(0, TO_END, buffer1, 20);
            QueryFileNameFromIndex(p, buffer2, 20);

            if (WSTRING::Stricmp(buffer1, buffer2)) {

                PMESSAGE    msg;

                *Changes = TRUE;

                msg = Frs->GetDrive()->GetMessage();
                msg->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_FILENAME,
                             "%I64x%ws%ws",
                         Frs->QueryFileNumber().GetLargeInteger(),
                         buffer2,
                         buffer1);

                Frs->DeleteResidentAttribute($FILE_NAME, NULL, p,
                    attribute.QueryValueLength().GetLowPart(), &success);
                if (ChkdskInfo)
                    ChkdskInfo->NumFileNames[file_number]--;
            } else
                correct_name_encountered = TRUE;
        }
    }

    if (!correct_name_encountered && !no_file_name) {
        *Changes = TRUE;
        new_file_name->FileNameLength = (UCHAR)file_name_text.QueryChCount();
        new_file_name->ParentDirectory = ParentFileReference;
        new_file_name->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;
        file_name_text.QueryWSTR(0,
                                 TO_END,
                                 new_file_name->FileName,
                                 file_name_text.QueryChCount(),
                                 FALSE);
        if (!Frs->AddFileNameAttribute(new_file_name))
            return FALSE;
        if (ChkdskInfo)
            ChkdskInfo->NumFileNames[file_number]++;
    }

    return TRUE;
}


BOOLEAN
EnsureSystemFilesInUse(
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine goes through all of the system files and ensures that
    they are all in use.  Any that are not in use are created the way
    format would do it.  Besides that this method makes sure that none
    of the system files have file-names that point back to any directory
    besides the root (file 5).  Any offending file-names are tubed.

Arguments:

    ChkdskInfo  - Supplies the current chkdsk info.
    Mft         - Supplies the MFT.
    FixLevel    - Supplies the fix level.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG                       i;
    NTFS_FILE_RECORD_SEGMENT    frs;
    FILE_REFERENCE              root_file_reference;
    BOOLEAN                     changes;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;

    // First to the root index file since the others need to point back
    // to it.

    if (!frs.Initialize(ROOT_FILE_NAME_INDEX_NUMBER, Mft)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!frs.Read()) {
        DebugAbort("Can't read a hotfixed system FRS");
        return FALSE;
    }

    if (!frs.IsInUse()) {

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        ChkdskInfo->NumFileNames[ROOT_FILE_NAME_INDEX_NUMBER] = 1;

        if (!frs.CreateSystemFile()) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs.SetIndexPresent();

        if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
            DebugAbort("can't write system file");
            return FALSE;
        }


    } else if (!frs.IsIndexPresent()) {

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        frs.SetIndexPresent();

        Message->DisplayMsg(MSG_CHK_NTFS_FIX_FLAGS,
                            "%d", ROOT_FILE_NAME_INDEX_NUMBER);

        Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_FILE_NAME_INDEX_PRESENT_BIT,
                     "%x", ROOT_FILE_NAME_INDEX_NUMBER);

        if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
            DebugAbort("can't write system file");
            return FALSE;
        }
    }

    root_file_reference = frs.QuerySegmentReference();

    for (i = 0; i < FIRST_USER_FILE_NUMBER; i++) {

        if (!frs.Initialize(i, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.Read()) {
            DebugAbort("Can't read a hotfixed system FRS");
            return FALSE;
        }

        if (ChkdskInfo->major < 2 ||
            (i != SECURITY_TABLE_NUMBER &&
             i != EXTEND_TABLE_NUMBER &&
             i != ROOT_FILE_NAME_INDEX_NUMBER)) {
            if (!frs.IsInUse()) {

                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                ChkdskInfo->NumFileNames[i] = 1;

                if (!frs.CreateSystemFile(ChkdskInfo->major,
                                          ChkdskInfo->minor)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
                    DebugAbort("can't write system file");
                    return FALSE;
                }

                // Mark this file for consideration when handing out free
                // data attributes.

                ChkdskInfo->FilesWhoNeedData.SetAllocated(frs.QueryFileNumber(), 1);
            }
        } else if (i == SECURITY_TABLE_NUMBER) {
            if (!frs.IsInUse()) {

                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                ChkdskInfo->NumFileNames[i] = 1;

                if (!frs.CreateSystemFile(ChkdskInfo->major,
                                          ChkdskInfo->minor)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                frs.SetViewIndexPresent();

                if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
                    DebugAbort("can't write system file");
                    return FALSE;
                }
            } else if (!frs.IsViewIndexPresent()) {

                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                frs.SetViewIndexPresent();

                Message->DisplayMsg(MSG_CHK_NTFS_FIX_FLAGS,
                                    "%d", SECURITY_TABLE_NUMBER);

                Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_VIEW_INDEX_PRESENT_BIT,
                             "%x", SECURITY_TABLE_NUMBER);

                if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
                    DebugAbort("can't write system file");
                    return FALSE;
                }
            }
        } else if (i == EXTEND_TABLE_NUMBER ||
                   i == ROOT_FILE_NAME_INDEX_NUMBER) {
            if (!frs.IsInUse()) {

                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                ChkdskInfo->NumFileNames[i] = 1;

                if (!frs.CreateSystemFile(ChkdskInfo->major,
                                          ChkdskInfo->minor)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                frs.SetIndexPresent();

                if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
                    DebugAbort("can't write system file");
                    return FALSE;
                }
            } else if (!frs.IsIndexPresent()) {

                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

                frs.SetIndexPresent();

                Message->DisplayMsg(MSG_CHK_NTFS_FIX_FLAGS, "%d", i);

                Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_FILE_NAME_INDEX_PRESENT_BIT,
                             "%x", i);

                if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
                    DebugAbort("can't write system file");
                    return FALSE;
                }
            }

        }

        // Make sure that this file has no $FILE_NAME attribute
        // who's parent is not the root directory.

        if (!EnsureValidParentFileName(ChkdskInfo, &frs,
                                       root_file_reference, &changes)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        ChkdskInfo->ReferenceCount[i] = frs.QueryReferenceCount();

        if (changes) {

            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            Message->DisplayMsg(MSG_CHK_NTFS_FIX_SYSTEM_FILE_NAME,
                                "%d", frs.QueryFileNumber().GetLowPart());

            if (FixLevel != CheckOnly && !frs.Flush(Mft->GetVolumeBitmap())) {
                DebugAbort("can't write system file");
                return FALSE;
            }
        }
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}


BOOLEAN
NTFS_SA::CheckExtendSystemFiles(
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT     ChkdskReport,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine goes through all of the files in \$Extend and make
    sure they all exist, and are in use.  Besides that this method
    makes sure that none of the system files have file-names that
    point back to any directory besides the \$Extend (file 0xB).
    It also makes sure there the proper indices appear in each
    of the files.

Arguments:

    ChkdskInfo   - Supplies the current chkdsk info.
    ChkdskReport - Supplies the current chkdsk report.
    Mft          - Supplies the MFT.
    FixLevel     - Supplies the fix level.
    Message      - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG                       i;
    NTFS_FILE_RECORD_SEGMENT    frs;
    NTFS_FILE_RECORD_SEGMENT    parent_frs;
    FILE_REFERENCE              parent_file_reference;
    BOOLEAN                     changes;
    DSTRING                     index_name;
    NTFS_INDEX_TREE             parent_index;
    NTFS_INDEX_TREE             index;
    BIG_INT                     file_number;
    FILE_NAME                   file_name[2];
    BOOLEAN                     parent_index_need_save;
    BOOLEAN                     index_need_save;
    BOOLEAN                     error;
    PINDEX_ENTRY                found_entry;
    PNTFS_INDEX_BUFFER          ContainingBuffer;
    ULONG                       file_name_size;
    NTFS_ATTRIBUTE              attrib;
    BOOLEAN                     diskErrorsFound;
    BOOLEAN                     alloc_present;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;

    //
    // read in the $Extend FRS as parent
    //

    if (!parent_frs.Initialize(EXTEND_TABLE_NUMBER, Mft)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!parent_frs.Read()) {
        DebugAbort("Can't read a hotfixed system FRS");
        return FALSE;
    }

    parent_file_reference = parent_frs.QuerySegmentReference();

    //
    // Make sure the parent has an $I30 index
    //

    if (!index_name.Initialize(FileNameIndexNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    parent_index_need_save = FALSE;
    if (!parent_frs.IsIndexPresent() ||
        !parent_index.Initialize(_drive,
                                 QueryClusterFactor(),
                                 Mft->GetVolumeBitmap(),
                                 Mft->GetUpcaseTable(),
                                 parent_frs.QuerySize()/2,
                                 &parent_frs,
                                 &index_name)) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_INDEX,
                            "%W%d", &index_name, EXTEND_TABLE_NUMBER);

        if (parent_frs.IsIndexPresent()) {
            Message->LogMsg(MSG_CHKLOG_NTFS_INDEX_IS_MISSING,
                         "%I64x%W",
                         parent_frs.QueryFileNumber().GetLargeInteger(),
                         &index_name);
        } else {
            Message->LogMsg(MSG_CHKLOG_NTFS_FILE_NAME_INDEX_PRESENT_BIT_SET,
                         "%I64x", parent_frs.QueryFileNumber().GetLargeInteger());
        }

        if (!parent_index.Initialize($FILE_NAME,
                                     _drive,
                                     QueryClusterFactor(),
                                     Mft->GetVolumeBitmap(),
                                     Mft->GetUpcaseTable(),
                                     COLLATION_FILE_NAME,
                                     SMALL_INDEX_BUFFER_SIZE,
                                     parent_frs.QuerySize()/2,
                                     &index_name)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SYSTEM_FILE,
                                "%d", EXTEND_TABLE_NUMBER);
            return FALSE;
        }
        parent_frs.SetIndexPresent();
        parent_index_need_save = TRUE;
        ChkdskReport->NumIndices += 1;
    }

    //
    // now check the object id file
    //

    if (!index_name.Initialize(ObjectIdFileName)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (ChkdskInfo->ObjectIdFileNumber.GetLargeInteger() == 0) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_OBJID);

        if (!Mft->AllocateFileRecordSegment(&file_number, FALSE)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_OBJID);
            return FALSE;
        }

        if (!frs.Initialize(file_number, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.CreateExtendSystemFile(&index_name,
                FILE_SYSTEM_FILE | FILE_VIEW_INDEX_PRESENT,
                DUP_VIEW_INDEX_PRESENT)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs.SetReferenceCount(1);

        if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_OBJID);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        ChkdskInfo->ObjectIdFileNumber = file_number;
    } else {

        file_number = ChkdskInfo->ObjectIdFileNumber;

        if (!frs.Initialize(file_number, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.Read()) {
            Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS);
            return FALSE;
        }

        if (!frs.IsSystemFile() || !frs.IsViewIndexPresent()) {

            MSGID   msgid;

            if (frs.IsSystemFile())
                msgid = MSG_CHKLOG_NTFS_MISSING_VIEW_INDEX_PRESENT_BIT;
            else
                msgid = MSG_CHKLOG_NTFS_MISSING_SYSTEM_FILE_BIT;
            Message->LogMsg(msgid, "%I64x", file_number.GetLargeInteger());

            frs.SetSystemFile();
            frs.SetViewIndexPresent();

            Message->DisplayMsg(MSG_CHK_NTFS_FIX_FLAGS,
                                "%d", file_number.GetLowPart());

            if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_OBJID);
                return FALSE;
            }
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }

        if (!EnsureValidFileAttributes(&frs,
                                       &parent_index,
                                       &parent_index_need_save,
                                       DUP_VIEW_INDEX_PRESENT,
                                       ChkdskInfo,
                                       Mft,
                                       FixLevel,
                                       Message))
            return FALSE;
    }

    // Make sure that this file has no $FILE_NAME attribute
    // who's parent is not the extend directory.

    if (!EnsureValidParentFileName(NULL,
                                   &frs,
                                   parent_file_reference,
                                   &changes)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (changes) {

        if (FixLevel != CheckOnly && !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_OBJID);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    // now make sure the $ObjId file name appears
    // in the index entry of its parent

    if (!frs.QueryAttribute(&attrib, &error, $FILE_NAME)) {
        DebugPrint("Unable to locate $FILE_NAME attribute in the object id FRS\n");
        return FALSE;
    }

    DebugAssert(attrib.QueryValueLength().GetHighPart() == 0);

    file_name_size = attrib.QueryValueLength().GetLowPart();

    DebugAssert(file_name_size <= sizeof(FILE_NAME)*2);

    memcpy(file_name, attrib.GetResidentValue(), file_name_size);

    if (!parent_index.QueryEntry(file_name_size,
                                 file_name,
                                 0,
                                 &found_entry,
                                 &ContainingBuffer,
                                 &error)) {

        Message->DisplayMsg(MSG_CHK_NTFS_INSERTING_INDEX_ENTRY,
                            "%d%W", EXTEND_TABLE_NUMBER,
                                 parent_index.GetName());

        if (!parent_index.InsertEntry(file_name_size,
                                      file_name,
                                      frs.QuerySegmentReference())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                "%d%W", EXTEND_TABLE_NUMBER, parent_index.GetName());
            return FALSE;
        }
        parent_index_need_save = TRUE;
    }

    //
    // now check the index of $ObjectId
    //

    if (!index_name.Initialize(ObjectIdIndexNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!index.Initialize(_drive,
                          QueryClusterFactor(),
                          Mft->GetVolumeBitmap(),
                          Mft->GetUpcaseTable(),
                          frs.QuerySize()/2,
                          &frs,
                          &index_name)) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_INDEX,
                            "%W%d", &index_name, frs.QueryFileNumber());

        if (!index.Initialize(0,
                              _drive,
                              QueryClusterFactor(),
                              Mft->GetVolumeBitmap(),
                              Mft->GetUpcaseTable(),
                              COLLATION_ULONGS,
                              SMALL_INDEX_BUFFER_SIZE,
                              frs.QuerySize()/2,
                              &index_name)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_INDEX,
                                "%W%d", &index_name,
                             frs.QueryFileNumber().GetLowPart());
            return FALSE;
        }
        if (FixLevel != CheckOnly &&
            !index.Save(&frs)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_INDEX,
                                "%W%d", &index_name,
                             frs.QueryFileNumber().GetLowPart());
            return FALSE;
        }
        if (!ValidateEntriesInObjIdIndex(&index,
                                         &frs,
                                         ChkdskInfo,
                                         &changes,
                                         Mft,
                                         FixLevel,
                                         Message,
                                         &diskErrorsFound)) {
            return FALSE;
        }
        if (FixLevel != CheckOnly &&
            !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_OBJID);
            return FALSE;
        }
        ChkdskReport->NumIndices += 1;
        alloc_present = frs.QueryAttribute(&attrib,
                                           &error,
                                           $INDEX_ALLOCATION,
                                           &index_name);

        if (!alloc_present && error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (alloc_present) {
           ChkdskReport->BytesInIndices += attrib.QueryAllocatedLength();
        }
    }

    //
    // now check the Reparse Point file
    //

    if (!index_name.Initialize(ReparseFileName)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (ChkdskInfo->ReparseFileNumber.GetLargeInteger() == 0) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_REPARSE);

        if (!Mft->AllocateFileRecordSegment(&file_number, FALSE)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_REPARSE);
            return FALSE;
        }

        if (!frs.Initialize(file_number, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.CreateExtendSystemFile(&index_name,
                FILE_SYSTEM_FILE | FILE_VIEW_INDEX_PRESENT,
                DUP_VIEW_INDEX_PRESENT)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs.SetReferenceCount(1);

        if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_REPARSE);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        ChkdskInfo->ReparseFileNumber = file_number;
    } else {

        file_number = ChkdskInfo->ReparseFileNumber;

        if (!frs.Initialize(file_number, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.Read()) {
            Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS);
            return FALSE;
        }

        if (!frs.IsSystemFile() || !frs.IsViewIndexPresent()) {

            MSGID   msgid;

            if (frs.IsSystemFile())
                msgid = MSG_CHKLOG_NTFS_MISSING_VIEW_INDEX_PRESENT_BIT;
            else
                msgid = MSG_CHKLOG_NTFS_MISSING_SYSTEM_FILE_BIT;
            Message->LogMsg(msgid, "%I64x", file_number.GetLargeInteger());

            frs.SetSystemFile();
            frs.SetViewIndexPresent();

            Message->DisplayMsg(MSG_CHK_NTFS_FIX_FLAGS,
                                "%d", file_number.GetLowPart());

            if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_REPARSE);
                return FALSE;
            }
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }

        if (!EnsureValidFileAttributes(&frs,
                                       &parent_index,
                                       &parent_index_need_save,
                                       DUP_VIEW_INDEX_PRESENT,
                                       ChkdskInfo,
                                       Mft,
                                       FixLevel,
                                       Message))
            return FALSE;
    }

    // Make sure that this file has no $FILE_NAME attribute
    // who's parent is not the extend directory.

    if (!EnsureValidParentFileName(NULL,
                                   &frs,
                                   parent_file_reference,
                                   &changes)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (changes) {

        if (FixLevel != CheckOnly && !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_REPARSE);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    // now make sure the $Reparse file name appears
    // in the index entry of its parent

    if (!frs.QueryAttribute(&attrib, &error, $FILE_NAME)) {
        DebugPrint("Unable to locate $FILE_NAME attribute in the reparse point FRS\n");
        return FALSE;
    }

    DebugAssert(attrib.QueryValueLength().GetHighPart() == 0);

    file_name_size = attrib.QueryValueLength().GetLowPart();

    DebugAssert(file_name_size <= sizeof(FILE_NAME)*2);

    memcpy(file_name, attrib.GetResidentValue(), file_name_size);

    if (!parent_index.QueryEntry(file_name_size,
                                 file_name,
                                 0,
                                 &found_entry,
                                 &ContainingBuffer,
                                 &error)) {

        Message->DisplayMsg(MSG_CHK_NTFS_INSERTING_INDEX_ENTRY,
                            "%d%W", EXTEND_TABLE_NUMBER,
                                 parent_index.GetName());

        if (!parent_index.InsertEntry(file_name_size,
                                      file_name,
                                      frs.QuerySegmentReference())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                "%d%W", EXTEND_TABLE_NUMBER, parent_index.GetName());
            return FALSE;
        }
        parent_index_need_save = TRUE;
    }

    //
    // now check the index of $Reparse
    //

    if (!index_name.Initialize(ReparseIndexNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!index.Initialize(_drive,
                          QueryClusterFactor(),
                          Mft->GetVolumeBitmap(),
                          Mft->GetUpcaseTable(),
                          frs.QuerySize()/2,
                          &frs,
                          &index_name)) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_INDEX,
                            "%W%d", &index_name, frs.QueryFileNumber());

        if (!index.Initialize(0,
                              _drive,
                              QueryClusterFactor(),
                              Mft->GetVolumeBitmap(),
                              Mft->GetUpcaseTable(),
                              COLLATION_ULONGS,
                              SMALL_INDEX_BUFFER_SIZE,
                              frs.QuerySize()/2,
                              &index_name)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_INDEX,
                                "%W%d", &index_name,
                             frs.QueryFileNumber().GetLowPart());
            return FALSE;
        }
        if (FixLevel != CheckOnly &&
            !index.Save(&frs)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_INDEX,
                                "%W%d", &index_name,
                             frs.QueryFileNumber().GetLowPart());
            return FALSE;
        }
        if (!ValidateEntriesInReparseIndex(&index,
                                           &frs,
                                           ChkdskInfo,
                                           &changes,
                                           Mft,
                                           FixLevel,
                                           Message,
                                           &diskErrorsFound)) {
            return FALSE;
        }
        if (FixLevel != CheckOnly &&
            !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_REPARSE);
            return FALSE;
        }
        ChkdskReport->NumIndices += 1;
        alloc_present = frs.QueryAttribute(&attrib,
                                           &error,
                                           $INDEX_ALLOCATION,
                                           &index_name);

        if (!alloc_present && error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (alloc_present) {
           ChkdskReport->BytesInIndices += attrib.QueryAllocatedLength();
        }
    }

    //
    // now check the quota file
    //

    if (!index_name.Initialize(QuotaFileName)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (ChkdskInfo->QuotaFileNumber.GetLargeInteger() == 0) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_QUOTA);

        if (!Mft->AllocateFileRecordSegment(&file_number, FALSE)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_QUOTA);
            return FALSE;
        }

        if (!frs.Initialize(file_number, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.CreateExtendSystemFile(&index_name,
                FILE_SYSTEM_FILE | FILE_VIEW_INDEX_PRESENT,
                DUP_VIEW_INDEX_PRESENT)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs.SetReferenceCount(1);

        if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_QUOTA);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        ChkdskInfo->QuotaFileNumber = file_number;
    } else {

        file_number = ChkdskInfo->QuotaFileNumber;

        if (!frs.Initialize(file_number, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.Read()) {
            Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS);
            return FALSE;
        }

        if (!frs.IsSystemFile() || !frs.IsViewIndexPresent()) {

            MSGID   msgid;

            if (frs.IsSystemFile())
                msgid = MSG_CHKLOG_NTFS_MISSING_VIEW_INDEX_PRESENT_BIT;
            else
                msgid = MSG_CHKLOG_NTFS_MISSING_SYSTEM_FILE_BIT;
            Message->LogMsg(msgid, "%I64x", file_number.GetLargeInteger());

            frs.SetSystemFile();
            frs.SetViewIndexPresent();

            Message->DisplayMsg(MSG_CHK_NTFS_FIX_FLAGS,
                                "%d", file_number.GetLowPart());

            if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_QUOTA);
                return FALSE;
            }
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }

        if (!EnsureValidFileAttributes(&frs,
                                       &parent_index,
                                       &parent_index_need_save,
                                       DUP_VIEW_INDEX_PRESENT,
                                       ChkdskInfo,
                                       Mft,
                                       FixLevel,
                                       Message))
            return FALSE;
    }

    // Make sure that this file has no $FILE_NAME attribute
    // who's parent is not the extend directory.

    if (!EnsureValidParentFileName(NULL,
                                   &frs,
                                   parent_file_reference,
                                   &changes)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (changes) {

        if (FixLevel != CheckOnly && !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_QUOTA);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    // now make sure the $Quota file name appears
    // in the index entry of its parent

    if (!frs.QueryAttribute(&attrib, &error, $FILE_NAME)) {
        DebugPrint("Unable to locate $FILE_NAME attribute in the quota FRS\n");
        return FALSE;
    }

    DebugAssert(attrib.QueryValueLength().GetHighPart() == 0);

    file_name_size = attrib.QueryValueLength().GetLowPart();

    DebugAssert(file_name_size <= sizeof(FILE_NAME)*2);

    memcpy(file_name, attrib.GetResidentValue(), file_name_size);

    if (!parent_index.QueryEntry(file_name_size,
                                 file_name,
                                 0,
                                 &found_entry,
                                 &ContainingBuffer,
                                 &error)) {

        Message->DisplayMsg(MSG_CHK_NTFS_INSERTING_INDEX_ENTRY,
                            "%d%W", EXTEND_TABLE_NUMBER,
                                 parent_index.GetName());

        if (!parent_index.InsertEntry(file_name_size,
                                      file_name,
                                      frs.QuerySegmentReference())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                "%d%W", EXTEND_TABLE_NUMBER, parent_index.GetName());
            return FALSE;
        }
        parent_index_need_save = TRUE;
    }

    //
    // now check the indices of $Quota
    //

    //
    // Check the Sid to Userid index first for $Quota
    //

    if (!index_name.Initialize(Sid2UseridQuotaNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!index.Initialize(_drive,
                          QueryClusterFactor(),
                          Mft->GetVolumeBitmap(),
                          Mft->GetUpcaseTable(),
                          frs.QuerySize()/2,
                          &frs,
                          &index_name)) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_INDEX,
                            "%W%d", &index_name,
                                 frs.QueryFileNumber().GetLowPart());

        if (!index.Initialize(0,
                              _drive,
                              QueryClusterFactor(),
                              Mft->GetVolumeBitmap(),
                              Mft->GetUpcaseTable(),
                              COLLATION_SID,
                              SMALL_INDEX_BUFFER_SIZE,
                              frs.QuerySize()/2,
                              &index_name)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_INDEX,
                                "%W%d", &index_name,
                                     frs.QueryFileNumber().GetLowPart());
            return FALSE;
        }
        if (FixLevel != CheckOnly &&
            !index.Save(&frs)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_INDEX,
                                "%W%d", &index_name,
                             frs.QueryFileNumber().GetLowPart());
            return FALSE;
        }
        if (FixLevel != CheckOnly &&
            !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_QUOTA);
            return FALSE;
        }
        ChkdskReport->NumIndices += 1;
    }

    //
    // now check the Userid to Sid index for $Quota
    //

    if (!index_name.Initialize(Userid2SidQuotaNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!index.Initialize(_drive,
                          QueryClusterFactor(),
                          Mft->GetVolumeBitmap(),
                          Mft->GetUpcaseTable(),
                          frs.QuerySize()/2,
                          &frs,
                          &index_name)) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_INDEX,
                            "%W%d", &index_name,
                                 frs.QueryFileNumber().GetLowPart());

        if (!index.Initialize(0,
                              _drive,
                              QueryClusterFactor(),
                              Mft->GetVolumeBitmap(),
                              Mft->GetUpcaseTable(),
                              COLLATION_ULONG,
                              SMALL_INDEX_BUFFER_SIZE,
                              frs.QuerySize()/2,
                              &index_name)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_INDEX,
                                "%W%d", &index_name,
                                     frs.QueryFileNumber().GetLowPart());
            return FALSE;
        }
        if (FixLevel != CheckOnly &&
            !index.Save(&frs)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_CREATE_INDEX,
                                "%W%d", &index_name,
                                     frs.QueryFileNumber().GetLowPart());
            return FALSE;
        }
        switch (frs.VerifyAndFixQuotaDefaultId(Mft->GetVolumeBitmap(),
                                               FixLevel == CheckOnly)) {
          case NTFS_QUOTA_INDEX_FOUND:
              DebugAssert(FALSE);
              break;

          case NTFS_QUOTA_INDEX_INSERTED:
          case NTFS_QUOTA_DEFAULT_ENTRY_MISSING:
              errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
              Message->DisplayMsg(MSG_CHK_NTFS_DEFAULT_QUOTA_ENTRY_MISSING,
                                "%d%W",
                               frs.QueryFileNumber().GetLowPart(),
                               &index_name);
              break;

          case NTFS_QUOTA_INDEX_NOT_FOUND:
              if (FixLevel != CheckOnly) {
                  DebugAssert(FALSE);
                  return FALSE;
              }
              break;

          case NTFS_QUOTA_ERROR:
              Message->DisplayMsg(MSG_CHK_NO_MEMORY);
              return FALSE;

          case NTFS_QUOTA_INSERT_FAILED:
              ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
              Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                "%d%W",
                               frs.QueryFileNumber().GetLowPart(),
                               index_name);
              return FALSE;
        }

        if (FixLevel != CheckOnly &&
            !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_QUOTA);
            return FALSE;
        }
        ChkdskReport->NumIndices += 1;
        alloc_present = frs.QueryAttribute(&attrib,
                                           &error,
                                           $INDEX_ALLOCATION,
                                           &index_name);

        if (!alloc_present && error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (alloc_present) {
           ChkdskReport->BytesInIndices += attrib.QueryAllocatedLength();
        }
    }

    //
    // now check the Usn Journal file
    //

    if (!index_name.Initialize(UsnJournalFileName)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (ChkdskInfo->UsnJournalFileNumber.GetLargeInteger() == 0) {

#if 0 // if journal file does not exist it means it's not being enabled
      // so don't create one

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_USNJRNL);

        if (!Mft->AllocateFileRecordSegment(&file_number, FALSE)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USNJRNL);
            return FALSE;
        }

        if (!frs.Initialize(file_number, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.CreateExtendSystemFile(&index_name,
                                        FILE_SYSTEM_FILE,
                                        FILE_ATTRIBUTE_SPARSE_FILE)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        frs.SetReferenceCount(1);

        if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USNJRNL);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        ChkdskInfo->UsnJournalFileNumber = file_number;
#endif

    } else {

        file_number = ChkdskInfo->UsnJournalFileNumber;

        ChkdskInfo->FilesWhoNeedData.SetFree(file_number, 1);

        if (!frs.Initialize(file_number, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.Read()) {
            Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS);
            return FALSE;
        }

        if (!frs.IsSystemFile()) {
            frs.SetSystemFile();

            Message->DisplayMsg(MSG_CHK_NTFS_FIX_FLAGS,
                                "%d", file_number.GetLowPart());

            Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_SYSTEM_FILE_BIT,
                         "%I64x", file_number.GetLargeInteger());

            if (FixLevel != CheckOnly && !frs.Flush(NULL)) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USNJRNL);
                return FALSE;
            }
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }

        if (!EnsureValidFileAttributes(&frs,
                                       &parent_index,
                                       &parent_index_need_save,
                                       FILE_ATTRIBUTE_SPARSE_FILE,
                                       ChkdskInfo,
                                       Mft,
                                       FixLevel,
                                       Message))
            return FALSE;
    }

    // Make sure that this file has no $FILE_NAME attribute
    // who's parent is not the $Extend directory.

    if (!EnsureValidParentFileName(NULL,
                                   &frs,
                                   parent_file_reference,
                                   &changes)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (changes) {

        if (FixLevel != CheckOnly && !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USNJRNL);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    // now make sure the $UsnJrnl file name appears
    // in the index entry of its parent

    if (!frs.QueryAttribute(&attrib, &error, $FILE_NAME)) {
        DebugPrint("Unable to locate $FILE_NAME attribute in the Usn Journal FRS\n");
        return FALSE;
    }

    DebugAssert(attrib.QueryValueLength().GetHighPart() == 0);

    file_name_size = attrib.QueryValueLength().GetLowPart();

    DebugAssert(file_name_size <= sizeof(FILE_NAME)*2);

    memcpy(file_name, attrib.GetResidentValue(), file_name_size);

    if (!parent_index.QueryEntry(file_name_size,
                                 file_name,
                                 0,
                                 &found_entry,
                                 &ContainingBuffer,
                                 &error)) {

        Message->DisplayMsg(MSG_CHK_NTFS_INSERTING_INDEX_ENTRY,
                            "%d%W", EXTEND_TABLE_NUMBER,
                                 parent_index.GetName());

        if (!parent_index.InsertEntry(file_name_size,
                                      file_name,
                                      frs.QuerySegmentReference())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                "%d%W", EXTEND_TABLE_NUMBER, parent_index.GetName());
            return FALSE;
        }
        parent_index_need_save = TRUE;
    }

    if (parent_index_need_save) {
        if (FixLevel != CheckOnly &&
            (!parent_index.Save(&parent_frs) ||
             !parent_frs.Flush(Mft->GetVolumeBitmap()))) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SYSTEM_FILE);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}


BOOLEAN
MarkQuotaOutOfDate(
    IN PNTFS_CHKDSK_INFO           ChkdskInfo,
    IN PNTFS_MASTER_FILE_TABLE     Mft,
    IN BOOLEAN                     FixLevel,
    IN OUT PMESSAGE                Message
)
{
    NTFS_FILE_RECORD_SEGMENT    frs;
    DSTRING                     index_name;
    PCINDEX_ENTRY               index_entry;
    PQUOTA_USER_DATA            QuotaUserData;
    NTFS_INDEX_TREE             index;
    ULONG                       depth;
    BOOLEAN                     error;
    NTFS_ATTRIBUTE              attrib;

    if (ChkdskInfo->QuotaFileNumber.GetLargeInteger() == 0) {
        DebugPrint("Quota file number not found.  Please rebuild.\n");
        return TRUE;
    }

    if (!frs.Initialize(ChkdskInfo->QuotaFileNumber, Mft)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }
    if (!frs.Read()) {
        DebugAbort("Previously readable FRS is no longer readable");
        return FALSE;
    }
    if (!index_name.Initialize(Userid2SidQuotaNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    // Check to see if the index exists

    if (!frs.QueryAttribute(&attrib,
                            &error,
                            $INDEX_ROOT,
                            &index_name))
        return TRUE; // does nothing as the index does not exist

    if (!index.Initialize(frs.GetDrive(),
                          frs.QueryClusterFactor(),
                          Mft->GetVolumeBitmap(),
                          Mft->GetUpcaseTable(),
                          frs.QuerySize()/2,
                          &frs,
                          &index_name)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    // Get the first entry - that's the default entry

    index.ResetIterator();
    if (!(index_entry = index.GetNext(&depth, &error))) {
        DebugPrintTrace(("Default Quota Index does not exist"));
        return FALSE;
    }

    if (*((ULONG*)GetIndexEntryValue(index_entry)) != QUOTA_DEFAULTS_ID) {
        DebugPrintTrace(("Default Quota Index not at the beginning of index"));
        return FALSE;
    }
    QuotaUserData = (PQUOTA_USER_DATA)((char*)GetIndexEntryValue(index_entry) + sizeof(ULONG));
    QuotaUserData->QuotaFlags |= QUOTA_FLAG_OUT_OF_DATE;
    if (FixLevel != CheckOnly &&
        (!index.WriteCurrentEntry() ||
        !index.Save(&frs) ||
        !frs.Flush(Mft->GetVolumeBitmap()))) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }
    return TRUE;
}

BOOLEAN
ValidateEa(
    IN      PNTFS_FILE_RECORD_SEGMENT   Frs,
    IN OUT  PNTFS_CHKDSK_REPORT         ChkdskReport,
       OUT  PBOOLEAN                    Errors,
    IN OUT  PNTFS_BITMAP                VolumeBitmap,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message
    )
/*++

Routine Description:

    This routine checks out the given file for any EA related attributes.
    It then makes sure that these are correct.  It will make minor
    corrections to the EA_INFORMATION attribute but beyond that it
    will tube the EA attributes if anything is bad.

Arguments:

    Frs             - Supplies the file with the alleged EAs.
    Errors          - Returns TRUE if error has been found
    VolumeBitmap    - Supplies the volume bitmap.
    FixLevel        - Supplies the fix level.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // Greater than theoretical upper bound for $EA_DATA attribute.
    CONST   MaxEaDataSize   = 256*1024;

    NTFS_ATTRIBUTE  ea_info;
    NTFS_ATTRIBUTE  ea_data;
    HMEM            data_hmem;
    ULONG           data_length;
    BOOLEAN         error;
    BOOLEAN         tube;
    EA_INFORMATION  disk_info;
    EA_INFORMATION  real_info;
    PPACKED_EA      pea;
    PULONG          plength;
    ULONG           packed_total, packed_length;
    ULONG           need_ea_count;
    ULONG           unpacked_total, unpacked_length;
    PCHAR           pend;
    ULONG           num_bytes;
    BOOLEAN         data_present, info_present;

    DebugPtrAssert(Errors);

    tube = *Errors = FALSE;

    data_present = Frs->QueryAttribute(&ea_data, &error, $EA_DATA);
    if (!data_present && error) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }
    info_present = Frs->QueryAttribute(&ea_info, &error, $EA_INFORMATION);
    if (!info_present && error) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!info_present && !data_present) {

        // There are no EAs here.
        return TRUE;
    }


    if (!info_present || !data_present) {

        tube = TRUE;

        Message->LogMsg(MSG_CHKLOG_NTFS_EA_INFO_XOR_EA_DATA,
                     "%I64x%x%x",
                     Frs->QueryFileNumber().GetLargeInteger(),
                     info_present,
                     data_present);

        DebugPrintTrace(("UNTFS: EA_INFO XOR EA_DATA in file 0x%I64x\n",
                         Frs->QueryFileNumber().GetLargeInteger()));

    } else if (ea_info.QueryValueLength() < sizeof(EA_INFORMATION) ||
               ea_info.QueryValueLength().GetHighPart() != 0) {

        tube = TRUE;

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_EA_INFO_LENGTH,
                     "%I64x%I64x",
                     ea_info.QueryValueLength().GetLargeInteger(),
                     Frs->QueryFileNumber().GetLargeInteger());

        DebugPrintTrace(("UNTFS: Bad EA info value length in file 0x%I64x\n",
                         Frs->QueryFileNumber().GetLargeInteger()));

    } else if (ea_data.QueryValueLength() > MaxEaDataSize) {

        tube = TRUE;

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_EA_DATA_LENGTH,
                     "%I64x%I64x",
                     ea_data.QueryValueLength().GetLargeInteger(),
                     Frs->QueryFileNumber().GetLargeInteger());

        DebugPrintTrace(("UNTFS: Bad EA data value length in file 0x%I64x\n",
                         Frs->QueryFileNumber().GetLargeInteger()));

    }

    if (!tube) {

        data_length = ea_data.QueryValueLength().GetLowPart();

        if (!data_hmem.Initialize() ||
            !data_hmem.Acquire(data_length)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!ea_info.Read(&disk_info,
                          0, sizeof(EA_INFORMATION), &num_bytes)) {

            tube = TRUE;

            Message->LogMsg(MSG_CHKLOG_NTFS_UNREADABLE_EA_INFO,
                         "%I64x", Frs->QueryFileNumber().GetLargeInteger());

            DebugPrintTrace(("UNTFS: Unable to read EA Info from file 0x%I64x\n",
                             Frs->QueryFileNumber().GetLargeInteger()));

        } else if (num_bytes != sizeof(EA_INFORMATION)) {

            tube = TRUE;

            Message->LogMsg(MSG_CHKLOG_NTFS_EA_INFO_INCORRECT_SIZE,
                         "%I64x%x%x",
                         Frs->QueryFileNumber().GetLargeInteger(),
                         num_bytes,
                         sizeof(EA_INFORMATION));

            DebugPrintTrace(("UNTFS: EA Info too small in file 0x%I64x\n",
                             Frs->QueryFileNumber().GetLargeInteger()));

        } else if (!ea_data.Read(data_hmem.GetBuf(),
                                 0, data_length, &num_bytes)) {

            tube = TRUE;

            Message->LogMsg(MSG_CHKLOG_NTFS_UNREADABLE_EA_DATA,
                         "%I64x", Frs->QueryFileNumber().GetLargeInteger());

            DebugPrintTrace(("UNTFS: Unable to read EA Data from file 0x%I64x\n",
                             Frs->QueryFileNumber().GetLargeInteger()));

        } else if (num_bytes != data_length) {

            tube = TRUE;

            Message->LogMsg(MSG_CHKLOG_NTFS_EA_DATA_INCORRECT_SIZE,
                         "%I64x%x%x",
                         Frs->QueryFileNumber().GetLargeInteger(),
                         num_bytes,
                         data_length);

            DebugPrintTrace(("UNTFS: EA Data too small in file 0x%I64x\n",
                             Frs->QueryFileNumber().GetLargeInteger()));
        }
    }

    if (!tube) {

        plength = (PULONG) data_hmem.GetBuf();

        pend = (PCHAR) data_hmem.GetBuf() + data_length;

        packed_total = 0;
        need_ea_count = 0;
        unpacked_total = 0;

        while ((PCHAR) plength < pend) {

            if ((PCHAR) plength + sizeof(ULONG) + sizeof(PACKED_EA) > pend) {

                tube = TRUE;

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_CORRUPT_EA_SET);
                Message->Log("%I64x%x",
                             Frs->QueryFileNumber().GetLargeInteger(),
                             pend-(PCHAR)plength);
                Message->DumpDataToLog(plength, (ULONG)min(0x100, max(0, pend-(PCHAR)plength)));
                Message->Unlock();

                DebugPrintTrace(("UNTFS: Corrupt EA set. File 0x%I64x\n",
                                 Frs->QueryFileNumber().GetLargeInteger()));
                break;
            }

            pea = (PPACKED_EA) ((PCHAR) plength + sizeof(ULONG));

            packed_length = sizeof(PACKED_EA) + pea->NameSize +
                            pea->ValueSize[0] + (pea->ValueSize[1]<<8);

            unpacked_length = sizeof(ULONG) + DwordAlign(packed_length);

            packed_total += packed_length;
            unpacked_total += unpacked_length;
            if (pea->Flag & EA_FLAG_NEED) {
                need_ea_count++;
            }

            if (unpacked_total > data_length ||
                pea->Name[pea->NameSize] != 0) {

                tube = TRUE;

                if (unpacked_total > data_length) {
                    Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_TOTAL_EA_SIZE,
                                 "%I64x%x%x",
                                 Frs->QueryFileNumber().GetLargeInteger(),
                                 unpacked_total,
                                 data_length);
                } else {
                    Message->Lock();
                    Message->Set(MSG_CHKLOG_NTFS_INCORRECT_EA_NAME);
                    Message->Log("%I64x%x",
                                 Frs->QueryFileNumber().GetLargeInteger(),
                                 pea->NameSize);
                    Message->DumpDataToLog(pea->Name, pea->NameSize);
                    Message->Unlock();
                }

                DebugPrintTrace(("UNTFS: EA name in set is missing NULL. File 0x%I64x\n",
                                 Frs->QueryFileNumber().GetLargeInteger()));
                break;
            }

            if (*plength != unpacked_length) {

                tube = TRUE;

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_INCORRECT_EA_SIZE);
                Message->Log("%I64x%x%x",
                             Frs->QueryFileNumber().GetLargeInteger(),
                             unpacked_length,
                             *plength);
                Message->DumpDataToLog(plength, min(0x100, unpacked_length));
                Message->Unlock();

                DebugPrintTrace(("UNTFS: Bad unpacked length field in EA set. File 0x%I64x\n",
                                 Frs->QueryFileNumber().GetLargeInteger()));
                break;
            }

            plength = (PULONG) ((PCHAR) plength + unpacked_length);
        }

        if ((packed_total>>(8*sizeof(USHORT))) != 0) {

            tube = TRUE;

            Message->LogMsg(MSG_CHKLOG_NTFS_TOTAL_PACKED_TOO_LARGE,
                         "%I64x%x",
                         Frs->QueryFileNumber().GetLargeInteger(),
                         packed_total);
            DebugPrintTrace(("UNTFS: Total packed length is too large. File 0x%I64x\n",
                             Frs->QueryFileNumber().GetLargeInteger()));
        }
    }

    if (!tube) {

        real_info.PackedEaSize = (USHORT)packed_total;
        real_info.NeedEaCount = (USHORT)need_ea_count;
        real_info.UnpackedEaSize = unpacked_total;

        if (memcmp(&real_info, &disk_info, sizeof(EA_INFORMATION))) {

            Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_EA,
                                "%d", Frs->QueryFileNumber().GetLowPart());

            Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_EA_INFO,
                         "%x%x%x%x%x%x",
                         real_info.PackedEaSize,
                         real_info.NeedEaCount,
                         real_info.UnpackedEaSize,
                         disk_info.PackedEaSize,
                         disk_info.NeedEaCount,
                         disk_info.UnpackedEaSize);

            DebugPrintTrace(("UNTFS: Incorrect EA information.  File 0x%I64x\n",
                      Frs->QueryFileNumber().GetLargeInteger()));

            *Errors = TRUE;
            if (FixLevel != CheckOnly) {

                if (!ea_info.Write(&real_info, 0, sizeof(EA_INFORMATION),
                                   &num_bytes, NULL) ||
                    num_bytes != sizeof(EA_INFORMATION) ||
                    !ea_info.InsertIntoFile(Frs, VolumeBitmap)) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }
        }
    }


    if (tube) {

        Message->DisplayMsg(MSG_CHK_NTFS_DELETING_CORRUPT_EA_SET,
                            "%d", Frs->QueryFileNumber().GetLowPart());
        *Errors = TRUE;

        if (data_present) {
            if (!ea_data.IsResident()) {
                ChkdskReport->BytesUserData -= ea_data.QueryAllocatedLength();
            }
            ea_data.Resize(0, VolumeBitmap);
            Frs->PurgeAttribute($EA_DATA);
        }
        if (info_present) {
            if (!ea_info.IsResident()) {
                ChkdskReport->BytesUserData -= ea_info.QueryAllocatedLength();
            }
            ea_info.Resize(0, VolumeBitmap);
            Frs->PurgeAttribute($EA_INFORMATION);
        }
    }

    if (FixLevel != CheckOnly && !Frs->Flush(VolumeBitmap)) {

        DebugAbort("Can't write it.");
        return FALSE;
    }


    return TRUE;
}


BOOLEAN
ValidateEas(
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT     ChkdskReport,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine validates all of the EAs on the volume.

Arguments:

    ChkdskInfo      - Supplies the current chkdsk information.
    Mft             - Supplies the MFT.
    FixLevel        - Supplies the fix level.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNUMBER_SET                 FilesWithEas;
    NTFS_FILE_RECORD_SEGMENT    frs;
    BIG_INT                     l;
    BOOLEAN                     errors;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;

    DebugPtrAssert(ChkdskInfo);

    FilesWithEas = &(ChkdskInfo->FilesWithEas);
    l = FilesWithEas->QueryCardinality();
    while (l > 0) {

        l -= 1;

        if (!frs.Initialize(FilesWithEas->QueryNumber(0), Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!FilesWithEas->Remove(frs.QueryFileNumber())) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.Read()) {
            DebugAbort("Previously readable now unreadable");
            continue;
        }

        if (!ValidateEa(&frs, ChkdskReport, &errors, Mft->GetVolumeBitmap(), FixLevel, Message)) {
            return FALSE;
        }
        if (errors) {
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}

BOOLEAN
ValidateReparsePoint(
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine validates all of the Reparse Point attributes
    on the volume.  It does not fix up the standard information
    or duplicated information.

Arguments:

    ChkdskInfo      - Supplies the current chkdsk information.
    Mft             - Supplies the MFT.
    FixLevel        - Supplies the fix level.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PNTFS_BITMAP                filesWithReparsePoint;
    BIG_INT                     i, l;
    NTFS_ATTRIBUTE              attribute;
    REPARSE_DATA_BUFFER         reparse_point;
    DSTRING                     null_string;
    NTFS_FILE_RECORD_SEGMENT    frs;
    BOOLEAN                     ErrorInAttribute;
    BIG_INT                     length;
    ULONG                       BytesRead;
    ULONG                       frs_needs_flushing;
    NUMBER_SET                  filesWithBadReparsePoint;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;
    BOOLEAN                     error;

#if defined(TIMING_ANALYSIS)
    LARGE_INTEGER               temp_time, temp_time2;
#endif

    DebugPtrAssert(ChkdskInfo);

#if defined(TIMING_ANALYSIS)
    IFS_SYSTEM::QueryNtfsTime(&temp_time);
#endif

    if (!null_string.Initialize("\"\"") ||
        !filesWithBadReparsePoint.Initialize()) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    filesWithReparsePoint = &(ChkdskInfo->FilesWithReparsePoint);
    l = ChkdskInfo->NumFiles;

    for (i = 0; i < l; i += 1) {

        if (filesWithReparsePoint->IsFree(i, 1))
            continue;

        if (!frs.Initialize(i, Mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.Read()) {
            DebugAbort("Previously readable now unreadable");
            continue;
        }

        if (!frs.QueryAttribute(&attribute,
                                &ErrorInAttribute,
                                $REPARSE_POINT)) {
            //
            // Got to exists otherwise it would not be in the number set
            //
            DebugPrintTrace(("Previously existed reparse point "
                        "attribute disappeared on file 0x%I64x\n",
                        frs.QueryFileNumber().GetLargeInteger()));
            return FALSE;
        }

        length = attribute.QueryValueLength();
        frs_needs_flushing = FALSE;

        DebugAssert(FIELD_OFFSET(_REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer) <=
                    FIELD_OFFSET(_REPARSE_GUID_DATA_BUFFER, GenericReparseBuffer.DataBuffer));

        error = FALSE;

        if (CompareGT(length, MAXIMUM_REPARSE_DATA_BUFFER_SIZE)) {

            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_BAD_REPARSE_POINT);
            Message->Log("%I64x", frs.QueryFileNumber().GetLargeInteger());
            Message->Set(MSG_CHKLOG_NTFS_REPARSE_POINT_LENGTH_TOO_LARGE);
            Message->Log("%I64x%x",
                         length.GetLargeInteger(),
                         MAXIMUM_REPARSE_DATA_BUFFER_SIZE);
            Message->Unlock();

            DebugPrintTrace(("UNTFS: File 0x%I64x has bad reparse point attribute.\n",
                             frs.QueryFileNumber().GetLargeInteger()));
            DebugPrintTrace(("The reparse point length (0x%I64x) has exceeded a maximum of 0x%x.\n",
                             length,
                             MAXIMUM_REPARSE_DATA_BUFFER_SIZE));
            error = TRUE;
        } else if (CompareLT(length, FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                                  GenericReparseBuffer.DataBuffer))) {

            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_BAD_REPARSE_POINT);
            Message->Log("%I64x", frs.QueryFileNumber().GetLargeInteger());
            Message->Set(MSG_CHKLOG_NTFS_REPARSE_POINT_LENGTH_TOO_SMALL);
            Message->Log("%I64x%x",
                         length.GetLargeInteger(),
                         FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                      GenericReparseBuffer.DataBuffer));
            Message->Unlock();

            DebugPrintTrace(("UNTFS: File 0x%I64x has bad reparse point attribute.\n",
                             frs.QueryFileNumber().GetLargeInteger()));
            DebugPrintTrace(("The reparse point length (0x%I64x) is less than a minimum of %x.\n",
                             length.GetLargeInteger(),
                             FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                          GenericReparseBuffer.DataBuffer)));
            error = TRUE;
        } else if (!attribute.Read(&reparse_point,
                                   0,
                                   FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                                GenericReparseBuffer.DataBuffer),
                                   &BytesRead)) {

            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_BAD_REPARSE_POINT);
            Message->Log("%I64x", frs.QueryFileNumber().GetLargeInteger());
            Message->Set(MSG_CHKLOG_NTFS_UNREADABLE_REPARSE_POINT);
            Message->Log();
            Message->Unlock();

            DebugPrintTrace(("UNTFS: File 0x%I64x has bad reparse point attribute.\n",
                             frs.QueryFileNumber().GetLargeInteger()));
            DebugPrintTrace(("Unable to read reparse point data buffer.\n"));

            error = TRUE;
        } else if (BytesRead != FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                             GenericReparseBuffer.DataBuffer)) {
            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_BAD_REPARSE_POINT);
            Message->Log("%I64x", frs.QueryFileNumber().GetLargeInteger());
            Message->Set(MSG_CHKLOG_NTFS_INCORRECT_REPARSE_POINT_SIZE);
            Message->Log("%x%x",
                         BytesRead,
                         FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                      GenericReparseBuffer.DataBuffer));
            Message->Unlock();

            DebugPrintTrace(("UNTFS: File 0x%I64x has bad reparse point attribute.\n",
                             frs.QueryFileNumber().GetLargeInteger()));
            DebugPrintTrace(("Only %d bytes returned from a read of %d bytes of the reparse data buffer.\n",
                             BytesRead,
                             FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                          GenericReparseBuffer.DataBuffer)));
            error = TRUE;
        } else if ((((reparse_point.ReparseDataLength +
                      FIELD_OFFSET(_REPARSE_DATA_BUFFER,
                                    GenericReparseBuffer.DataBuffer)) != length) ||
                    !IsReparseTagMicrosoft(reparse_point.ReparseTag)) &&
                   ((reparse_point.ReparseDataLength +
                     FIELD_OFFSET(_REPARSE_GUID_DATA_BUFFER,
                                  GenericReparseBuffer.DataBuffer)) != length)) {

            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_BAD_REPARSE_POINT);
            Message->Log("%I64x", frs.QueryFileNumber().GetLargeInteger());
            Message->Set(MSG_CHKLOG_NTFS_INCORRECT_REPARSE_DATA_LENGTH);
            Message->Log("%x%I64x",
                         reparse_point.ReparseDataLength,
                         length.GetLargeInteger());
            Message->Unlock();

            DebugPrintTrace(("UNTFS: File 0x%I64x has bad reparse point attribute.\n",
                             frs.QueryFileNumber().GetLargeInteger()));
            DebugPrintTrace(("ReparseDataLength (0x%x) inconsistence with the attribute length (0x%I64x).\n",
                             reparse_point.ReparseDataLength,
                             length.GetLargeInteger()));
            error = TRUE;
        } else if (reparse_point.ReparseTag == IO_REPARSE_TAG_RESERVED_ZERO ||
                   reparse_point.ReparseTag == IO_REPARSE_TAG_RESERVED_ONE) {

            Message->Lock();
            Message->Set(MSG_CHKLOG_NTFS_BAD_REPARSE_POINT);
            Message->Log("%I64x", frs.QueryFileNumber().GetLargeInteger());
            Message->Set(MSG_CHKLOG_NTFS_REPARSE_TAG_IS_RESERVED);
            Message->Log("%x", reparse_point.ReparseTag);
            Message->Unlock();

            DebugPrintTrace(("UNTFS: File 0x%I64x has bad reparse point attribute.\n",
                             frs.QueryFileNumber().GetLargeInteger()));
            DebugPrintTrace(("Reparse Tag (0x%x) is a reserved tag.\n",
                             reparse_point.ReparseTag));
            error = TRUE;
        }

        if (error) {

            frs_needs_flushing = TRUE;
            Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR,
                                "%d%W%d",
                                attribute.QueryTypeCode(),
                                attribute.GetName()->QueryChCount() ?
                                attribute.GetName() : &null_string,
                                frs.QueryFileNumber().GetLowPart());

            if (!filesWithBadReparsePoint.Add(frs.QueryFileNumber())) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!attribute.Resize(0, Mft->GetVolumeBitmap()) ||
                !frs.PurgeAttribute($REPARSE_POINT)) {
                DebugPrintTrace(("Unable to delete reparse point attribute from file 0x%I64x\n",
                                 frs.QueryFileNumber().GetLargeInteger()));
                return FALSE;
            } else
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }

        if (frs.IsAttributePresent($EA_INFORMATION)) {
            frs_needs_flushing = TRUE;

            Message->LogMsg(MSG_CHKLOG_NTFS_EA_INFORMATION_WITH_REPARSE_POINT,
                         "%I64x", frs.QueryFileNumber().GetLargeInteger());

            Message->DisplayMsg(MSG_CHK_NTFS_DELETING_EA_SET,
                                "%d", frs.QueryFileNumber().GetLowPart());
            if (!ChkdskInfo->FilesWithEas.Remove(frs.QueryFileNumber())) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            if (!frs.QueryAttribute(&attribute,
                                    &ErrorInAttribute,
                                    $EA_DATA)) {
                if (ErrorInAttribute) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
                //
                // $EA_DATA simply don't exists but there is an $EA_INFORMATION
                //
                if (!frs.PurgeAttribute($EA_INFORMATION)) {
                    DebugPrintTrace(("Unable to delete EA INFO attribute from file 0x%I64x\n",
                                frs.QueryFileNumber().GetLargeInteger()));
                    return FALSE;
                } else
                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            } else if (!attribute.Resize(0, Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            } else {
                if (!frs.PurgeAttribute($EA_INFORMATION) ||
                    !frs.PurgeAttribute($EA_DATA)) {
                    DebugPrintTrace(("Unable to delete EA INFO/DATA attribute from file 0x%I64x\n",
                                frs.QueryFileNumber().GetLargeInteger()));
                    return FALSE;
                } else
                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            }
        }

        if (frs_needs_flushing && FixLevel != CheckOnly &&
            !frs.Flush(Mft->GetVolumeBitmap())) {
            DebugAbort("Can't write it.");
            return FALSE;
        }
    }

    while (filesWithBadReparsePoint.QueryCardinality() != 0) {
        filesWithReparsePoint->SetFree(filesWithBadReparsePoint.QueryNumber(0), 1);
        filesWithBadReparsePoint.Remove(filesWithBadReparsePoint.QueryNumber(0));
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

#if defined(TIMING_ANALYSIS)
    IFS_SYSTEM::QueryNtfsTime(&temp_time2);
    Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE, "%s%I64d", "ValidateReparsePoint time in ticks: ",
                        temp_time2.QuadPart - temp_time.QuadPart);
#endif

    return TRUE;
}

BOOLEAN
NTFS_SA::CheckAllForData(
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine makes sure that all of the files in the list
    of files that don't have unnamed data attributes either
    get them or aren't supposed to have them anyway.

Arguments:

    ChkdskInfo  - Supplies the current chkdsk information.
    Mft         - Supplies the MFT.
    FixLevel    - Supplies the fix level.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    frs;
    BIG_INT                     i, n;
    NTFS_ATTRIBUTE              data_attribute;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;


    // Compute the number of files to examine.

    n = ChkdskInfo->FilesWhoNeedData.QuerySize();

    // Create an empty unnamed data attribute.

    if (!data_attribute.Initialize(_drive,
                                   QueryClusterFactor(),
                                   NULL,
                                   0,
                                   $DATA)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }


    // Ensure that every file in the list either has a $DATA attribute
    // or is an directory.

    for (i = 0; i < n; i = i + 1) {

        if (ChkdskInfo->FilesWhoNeedData.IsFree(i, 1))
            continue;

        if (!frs.Initialize(i, Mft) ||
            !frs.Read()) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (frs.IsIndexPresent() || frs.IsAttributePresent($DATA)) {
            continue;
        }

        Message->DisplayMsg(MSG_CHK_NTFS_MISSING_DATA_ATTRIBUTE,
                            "%I64d", i);

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        if (!data_attribute.InsertIntoFile(&frs, Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
        }

        if (FixLevel != CheckOnly && !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
        }
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}


BOOLEAN
ResolveCrossLink(
    IN      PCNTFS_CHKDSK_INFO      ChkdskInfo,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PNUMBER_SET             BadClusters,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine resolved the cross-link specified in the
    'ChkdskInfo', if any.  The cross-link is resolved by
    copying if possible.

Arguments:

    ChkdskInfo  - Supplies the cross-link information.
    Mft         - Supplies the master file table.
    BadClusters - Supplies the current list of bad clusters.
    FixLevel    - Supplies the fix-up level.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    frs;
    NTFS_ATTRIBUTE              attr;
    PNTFS_ATTRIBUTE             pattribute;
    BOOLEAN                     error;
    VCN                         vcn;
    LCN                         lcn;
    BIG_INT                     run_length;
    VCN                         hotfix_vcn;
    LCN                         hotfix_lcn, hotfix_last;
    BIG_INT                     hotfix_length;
    PVOID                       hotfix_buffer;
    ULONG                       cluster_size;
    ULONG                       bytes_read, hotfix_bytes;

    if (!ChkdskInfo->CrossLinkYet) {
        return TRUE;
    }

    Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_CROSS_LINK,
                        "%d", ChkdskInfo->CrossLinkedFile);

    if (!frs.Initialize(ChkdskInfo->CrossLinkedFile, Mft) ||
        !frs.Read()) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (ChkdskInfo->CrossLinkedFile == 0 &&
        ChkdskInfo->CrossLinkedAttribute == $DATA &&
        ChkdskInfo->CrossLinkedName.QueryChCount() == 0) {

        pattribute = Mft->GetDataAttribute();

    } else {

        if (!frs.QueryAttribute(&attr, &error,
                                ChkdskInfo->CrossLinkedAttribute,
                                &ChkdskInfo->CrossLinkedName)) {

            if (error) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            // If the attribute is no longer there, that's ok, because
            // it may have been corrupt.

            return TRUE;
        }

        pattribute = &attr;
    }


    // Figure out which VCN's map to the given CrossLinked LCN's
    // and hotfix those VCN's using the hotfix routine.

    for (vcn = 0;
         pattribute->QueryLcnFromVcn(vcn, &lcn, &run_length);
         vcn += run_length) {

        if (lcn == LCN_NOT_PRESENT) {
            continue;
        }

        if (lcn < ChkdskInfo->CrossLinkStart) {
            hotfix_lcn = ChkdskInfo->CrossLinkStart;
        } else {
            hotfix_lcn = lcn;
        }
        if (lcn + run_length > ChkdskInfo->CrossLinkStart +
                               ChkdskInfo->CrossLinkLength) {
            hotfix_last = ChkdskInfo->CrossLinkStart +
                               ChkdskInfo->CrossLinkLength;
        } else {
            hotfix_last = lcn + run_length;
        }

        if (hotfix_last <= hotfix_lcn) {
            continue;
        }

        hotfix_length = hotfix_last - hotfix_lcn;
        hotfix_vcn = vcn + (hotfix_lcn - lcn);
        cluster_size = Mft->QueryClusterFactor()*
                       Mft->GetDataAttribute()->GetDrive()->QuerySectorSize();
        hotfix_bytes = hotfix_length.GetLowPart()*cluster_size;

        // Before hotfixing the cross-linked data, read in the
        // data into a buffer.

        if (!(hotfix_buffer = MALLOC(hotfix_bytes))) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        memset(hotfix_buffer, 0, hotfix_bytes);
        pattribute->Read(hotfix_buffer,
                         hotfix_vcn*cluster_size,
                         hotfix_bytes,
                         &bytes_read);

        if (!pattribute->Hotfix(hotfix_vcn, hotfix_length,
                                Mft->GetVolumeBitmap(),
                                BadClusters)) {

            // Purge the attribute since there isn't enough disk
            // space to save it.

            if (!frs.PurgeAttribute(ChkdskInfo->CrossLinkedAttribute,
                                    &ChkdskInfo->CrossLinkedName)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                FREE(hotfix_buffer);
                return FALSE;
            }

            if (FixLevel != CheckOnly &&
                !frs.Flush(Mft->GetVolumeBitmap())) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                FREE(hotfix_buffer);
                return FALSE;
            }

            FREE(hotfix_buffer);
            return TRUE;
        }

        if (FixLevel != CheckOnly) {
            if (!pattribute->Write(hotfix_buffer,
                                   hotfix_vcn*cluster_size,
                                   hotfix_bytes,
                                   &bytes_read,
                                   NULL) ||
                bytes_read != hotfix_bytes ||
                !pattribute->InsertIntoFile(&frs, Mft->GetVolumeBitmap()) ||
                !frs.Flush(Mft->GetVolumeBitmap())) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                FREE(hotfix_buffer);
                return FALSE;
            }
        }

        FREE(hotfix_buffer);
    }

    return TRUE;
}

#if defined( _SETUP_LOADER_ )

BOOLEAN
RecoverAllUserFiles(
    IN      UCHAR                   VolumeMajorVersion,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PNUMBER_SET             BadClusters,
    IN OUT  PMESSAGE                Message
    )
{
    return TRUE;
}

BOOLEAN
RecoverFreeSpace(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PNUMBER_SET             BadClusters,
    IN OUT  PMESSAGE                Message
    )
{
    return TRUE;
}

#else // _SETUP_LOADER_ not defined

BOOLEAN
RecoverAllUserFiles(
    IN      UCHAR                   VolumeMajorVersion,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PNUMBER_SET             BadClusters,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine traverses all of the files in the MFT and
    verifies its attributes for bad clusters.

Arguments:

    Mft         - Supplies the master file table.
    BadClusters - Supplies the current list of bad clusters.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG                       i, n, percent_done;
    NTFS_FILE_RECORD_SEGMENT    frs;
    ULONG                       num_bad;
    BIG_INT                     bytes_recovered, total_bytes;
    DSTRING                     filename;


    Message->DisplayMsg(MSG_CHK_NTFS_VERIFYING_FILE_DATA, PROGRESS_MESSAGE,
                        NORMAL_VISUAL,
                        "%d%d", 4, 5);

    n = Mft->GetDataAttribute()->QueryValueLength().GetLowPart() / Mft->QueryFrsSize();

    n -= FIRST_USER_FILE_NUMBER;

    percent_done = 0;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

    for (i = 0; i < n; i++) {

        if (Mft->GetMftBitmap()->IsFree(i + FIRST_USER_FILE_NUMBER, 1)) {
            continue;
        }

        if (!frs.Initialize(i + FIRST_USER_FILE_NUMBER, Mft) ||
            !frs.Read()) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.IsBase()) {
            continue;
        }

        if (frs.RecoverFile(Mft->GetVolumeBitmap(),
                            BadClusters,
                            VolumeMajorVersion,
                            &num_bad,
                            &bytes_recovered,
                            &total_bytes)) {

            if (bytes_recovered < total_bytes) {

                frs.Backtrack(&filename);

                Message->DisplayMsg(MSG_CHK_BAD_CLUSTERS_IN_FILE_SUCCESS,
                                    "%d%W", frs.QueryFileNumber().GetLowPart(),
                                    filename.QueryString());
            }
        } else {

            frs.Backtrack(&filename);

            Message->DisplayMsg(MSG_CHK_BAD_CLUSTERS_IN_FILE_FAILURE,
                                "%d%W", frs.QueryFileNumber().GetLowPart(),
                                filename.QueryString());
        }

        if (i*100/n > percent_done) {
            percent_done = i*100/n;
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                return FALSE;
            }
        }
    }

    percent_done = 100;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

    Message->DisplayMsg(MSG_CHK_NTFS_VERIFYING_FILE_DATA_COMPLETED, PROGRESS_MESSAGE);

    return TRUE;
}


BOOLEAN
RecoverFreeSpace(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PNUMBER_SET             BadClusters,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine verifies all of the unused clusters on the disk.
    It adds any that are bad to the given bad cluster list.

Arguments:

    Mft         - Supplies the master file table.
    BadClusters - Supplies the current list of bad clusters.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PLOG_IO_DP_DRIVE    drive;
    PNTFS_BITMAP        bitmap;
    BIG_INT             i, len, max_len;
    ULONG               percent_done;
    BIG_INT             checked, total_to_check;
    NUMBER_SET          bad_sectors;
    ULONG               cluster_factor;
    BIG_INT             start, run_length, next;
    ULONG               j;

    Message->DisplayMsg(MSG_CHK_NTFS_RECOVERING_FREE_SPACE, PROGRESS_MESSAGE,
                        NORMAL_VISUAL,
                        "%d%d", 5, 5);

    drive = Mft->GetDataAttribute()->GetDrive();
    bitmap = Mft->GetVolumeBitmap();
    cluster_factor = Mft->QueryClusterFactor();
    max_len = bitmap->QuerySize()/20 + 1;
    total_to_check = bitmap->QueryFreeClusters();
    checked = 0;

    percent_done = 0;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

    for (i = 0; i < bitmap->QuerySize(); i += 1) {

        for (len = 0; i + len < bitmap->QuerySize() &&
                      bitmap->IsFree(i + len, 1) &&
                      len < max_len; len += 1) {
        }

        if (len > 0) {

            if (!bad_sectors.Initialize() ||
                !drive->Verify(i*cluster_factor,
                               len*cluster_factor,
                               &bad_sectors)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            for (j = 0; j < bad_sectors.QueryNumDisjointRanges(); j++) {

                bad_sectors.QueryDisjointRange(j, &start, &run_length);
                next = start + run_length;

                // Adjust start and next to be on cluster boundaries.
                start = start/cluster_factor;
                next = (next - 1)/cluster_factor + 1;

                // Add the bad clusters to the bad cluster list.
                if (!BadClusters->Add(start, next - start)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                // Mark the bad clusters as allocated in the bitmap.
                bitmap->SetAllocated(start, next - start);
            }

            checked += len;
            i += len - 1;

            if (100*checked/total_to_check > percent_done) {
                percent_done = (100*checked/total_to_check).GetLowPart();
                if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                    return FALSE;
                }
            }
        }
    }

    percent_done = 100;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

    Message->DisplayMsg(MSG_CHK_DONE_RECOVERING_FREE_SPACE, PROGRESS_MESSAGE);

    return TRUE;
}

#endif // _SETUP_LOADER_


BOOLEAN
NTFS_SA::DumpMessagesToFile(
    IN      PCWSTRING                   FileName,
    IN OUT  PNTFS_MFT_FILE              MftFile,
    IN OUT  PMESSAGE                    Message
    )
/*++

Routine Description:

    This function dumps the logged messages remembered by the
    message object into a file in the root directory.

Arguments:

    FileName        --  Supplies the (unqualified) name of the file.
    MftFile         --  Supplies an initialized, active Mft File object
                        for the volume.
    RootIndex       --  Supplies the root index for the volume
    RootIndexFile   --  Supplies the FRS for the root index file.

Return Value:

    TRUE upon successful completion.

--*/
{
    BYTE                        FileNameBuffer[NTFS_MAX_FILE_NAME_LENGTH * sizeof(WCHAR) + sizeof(FILE_NAME)];
    HMEM                        LoggedMessageMem;
    ULONG                       MessageDataLength;
    NTFS_FILE_RECORD_SEGMENT    TargetFrs;
    NTFS_INDEX_TREE             RootIndex;
    NTFS_FILE_RECORD_SEGMENT    RootIndexFrs;
    NTFS_ATTRIBUTE              DataAttribute;
    STANDARD_INFORMATION        StandardInformation;
    MFT_SEGMENT_REFERENCE       FileReference;
    PNTFS_MASTER_FILE_TABLE     Mft = MftFile->GetMasterFileTable();
    PFILE_NAME                  SearchName = (PFILE_NAME)FileNameBuffer;
    VCN                         FileNumber;
    DSTRING                     FileNameIndexName;
    ULONG                       BytesWritten;
    BOOLEAN                     InternalError;

    ULONG                       sys_space_needed;
    ULONG                       data_space_needed;
    BIG_INT                     free_clusters;
    ULONG                       space_remained;
    ULONG                       cluster_size;

    if( Mft == NULL ) {

        return FALSE;
    }

    // Fetch the messages.
    //
    if( !LoggedMessageMem.Initialize() ||
        !Message->QueryPackedLog( &LoggedMessageMem, &MessageDataLength ) ) {

        DebugPrintTrace(("UNTFS: can't collect logged messages.\n"));
        return FALSE;
    }

    // estimate the amount of space needed

    cluster_size = MftFile->GetDrive()->QuerySectorSize() * MftFile->QueryClusterFactor();

    // system space
    sys_space_needed = (Mft->QueryFrsSize() - 1)/cluster_size + 1;
    sys_space_needed += (SMALL_INDEX_BUFFER_SIZE - 1)/cluster_size + 1;

    // data space
    data_space_needed = (MessageDataLength - 1)/cluster_size + 1;

    free_clusters = Mft->GetVolumeBitmap()->QueryFreeClusters();
    if ((sys_space_needed+data_space_needed) > free_clusters) {

        DebugAssert(free_clusters.GetHighPart() == 0);
        space_remained = (free_clusters.GetLowPart() - sys_space_needed) * cluster_size;

        if (sys_space_needed >= free_clusters || MessageDataLength <= space_remained) {
            DebugPrintTrace(("UNTFS: Out of space to write BOOTEX.LOG\n"));
            Message->DisplayMsg(MSG_CHK_OUTPUT_LOG_ERROR);
            return FALSE;
        }

        // clip the output
        MessageDataLength = space_remained;
    }

    // Fetch the volume's root index:
    //
    if( !RootIndexFrs.Initialize( ROOT_FILE_NAME_INDEX_NUMBER, MftFile ) ||
        !RootIndexFrs.Read() ||
        !FileNameIndexName.Initialize( FileNameIndexNameData ) ||
        !RootIndex.Initialize( MftFile->GetDrive(),
                               MftFile->QueryClusterFactor(),
                               Mft->GetVolumeBitmap(),
                               MftFile->GetUpcaseTable(),
                               MftFile->QuerySize()/2,
                               &RootIndexFrs,
                               &FileNameIndexName ) ) {

        return FALSE;
    }

    memset( FileNameBuffer, 0, sizeof(FileNameBuffer) );

    SearchName->ParentDirectory = RootIndexFrs.QuerySegmentReference();
    SearchName->FileNameLength = (UCHAR)FileName->QueryChCount();
    SearchName->Flags = FILE_NAME_NTFS | FILE_NAME_DOS;

    if( !FileName->QueryWSTR( 0, TO_END,
                              NtfsFileNameGetName( SearchName ),
                              NTFS_MAX_FILE_NAME_LENGTH ) ) {

        DebugPrintTrace(("UNTFS: log file name is too long.\n"));
        return FALSE;
    }

    DebugPrintTrace(("UNTFS: Searching for BOOTEX.LOG\n"));

    if( RootIndex.QueryFileReference( NtfsFileNameGetLength( SearchName ),
                                      SearchName,
                                      0,
                                      &FileReference,
                                      &InternalError ) ) {

        DebugPrintTrace(("UNTFS: BOOTEX.LOG found.\n"));

        FileNumber.Set( FileReference.LowPart, (LONG) FileReference.HighPart );

        if( !TargetFrs.Initialize( FileNumber, Mft )    ||
            !TargetFrs.Read()                           ||
            !(FileReference == TargetFrs.QuerySegmentReference()) ||
            !TargetFrs.QueryAttribute( &DataAttribute,
                                       &InternalError,
                                       $DATA ) ) {

            // Either we were unable to initialize and read this FRS,
            // or its segment reference didn't match (ie. the sequence
            // number is wrong) or it didn't have a $DATA attribute
            // (i.e. it's a directory or corrupt).

            return FALSE;
        }

    } else if( InternalError ) {

        DebugPrintTrace(("UNTFS: Error searching for BOOTEX.LOG.\n"));
        return FALSE;

    } else {

        LARGE_INTEGER SystemTime;

        // This file does not exist--create it.
        //
        DebugPrintTrace(("UNTFS: BOOTEX.LOG not found.\n"));

        memset( &StandardInformation, 0, sizeof(StandardInformation) );

        IFS_SYSTEM::QueryNtfsTime( &SystemTime );

        StandardInformation.CreationTime =
            StandardInformation.LastModificationTime =
            StandardInformation.LastChangeTime =
            StandardInformation.LastAccessTime = SystemTime;

        if( !Mft->AllocateFileRecordSegment( &FileNumber, FALSE )   ||
            !TargetFrs.Initialize( FileNumber, Mft )                ||
            !TargetFrs.Create( &StandardInformation )               ||
            !TargetFrs.AddFileNameAttribute( SearchName )           ||
            !TargetFrs.AddSecurityDescriptor( NoAclCannedSd,
                                              Mft->GetVolumeBitmap() )  ||
            !RootIndex.InsertEntry( NtfsFileNameGetLength( SearchName ),
                                    SearchName,
                                    TargetFrs.QuerySegmentReference() ) ) {

            DebugPrintTrace(("UNTFS: Can't create BOOTEX.LOG\n"));
            return FALSE;
        }

        if( !DataAttribute.Initialize( MftFile->GetDrive(),
                                       MftFile->QueryClusterFactor(),
                                       NULL,
                                       0,
                                       $DATA ) ) {

            return FALSE;
        }
    }

    if( !DataAttribute.Write( LoggedMessageMem.GetBuf(),
                              DataAttribute.QueryValueLength(),
                              MessageDataLength,
                              &BytesWritten,
                              Mft->GetVolumeBitmap() ) ) {

        DebugPrintTrace(("UNTFS: Can't write logged message.\n"));
        return FALSE;
    }

    if( !DataAttribute.InsertIntoFile( &TargetFrs, Mft->GetVolumeBitmap() ) ) {

        // Insert failed--if it's resident, make it non-resident and
        // try again.
        //
        if( !DataAttribute.IsResident() ||
            !DataAttribute.MakeNonresident( Mft->GetVolumeBitmap() ) ||
            !DataAttribute.InsertIntoFile( &TargetFrs,
                                           Mft->GetVolumeBitmap() ) ) {

            DebugPrintTrace(("UNTFS: Can't save BOOTEX.LOG's data attribute.\n"));
            return FALSE;
        }
    }

    if( !TargetFrs.Flush( Mft->GetVolumeBitmap(), &RootIndex ) ) {

        DebugPrintTrace(("UNTFS: Can't flush BOOTEX.LOG.\n"));
        return FALSE;
    }

    if( !RootIndex.Save( &RootIndexFrs ) ||
        !RootIndexFrs.Flush( NULL ) ) {

        DebugPrintTrace(("UNTFS: Can't flush root index after logging messages.\n"));
        return FALSE;
    }

    MftFile->Flush();
    return TRUE;
}




BOOLEAN
NTFS_SA::VerifyAndFix(
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message,
    IN      ULONG       Flags,
    IN      ULONG       DesiredLogFileSize,
    IN      USHORT      Algorithm,
    OUT     PULONG      ExitStatus,
    IN      PCWSTRING   DriveLetter
    )
/*++

Routine Description:

    This routine verifies and, if necessary, fixes an NTFS volume.

Arguments:

    FixLevel            - Supplies the level of fixes that may be performed on
                            the disk.
    Message             - Supplies an outlet for messages.
    Flags               - Supplies flags to control behavior of chkdsk
                          (see ulib\inc\ifsentry.hxx for details)
    DesiredLogFileSize  - Supplies the desired logfile size in bytes, or 0 if
                            the logfile is to be resized to the default size.
    Algorithm           - Supplies the algorithm to use for index verification
    ExitStatus          - Returns an indication of how the checking went
    DriveLetter         - For autocheck, the letter for the volume we're checking

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_BITMAP                         mft_bitmap;
    NTFS_BITMAP                         volume_bitmap;
    NTFS_UPCASE_TABLE                   upcase_table;
    NTFS_ATTRIBUTE                      mft_data;
    BIG_INT                             num_frs, num_mft_bits;
    BIG_INT                             volume_clusters;
    NTFS_ATTRIBUTE_COLUMNS              attribute_def_table;
    NTFS_FRS_STRUCTURE                  frsstruc;
    HMEM                                hmem;
    VCN                                 i;
    NUMBER_SET                          bad_clusters;
    NTFS_MASTER_FILE_TABLE              internal_mft;
    NTFS_MFT_FILE                       mft_file;
    NTFS_REFLECTED_MASTER_FILE_TABLE    mft_ref;
    NTFS_ATTRIBUTE_DEFINITION_TABLE     attr_def_file;
    NTFS_BOOT_FILE                      boot_file;
    NTFS_UPCASE_FILE                    upcase_file;
    NTFS_LOG_FILE                       log_file;
    NTFS_BAD_CLUSTER_FILE               bad_clus_file;
    NTFS_FILE_RECORD_SEGMENT            root_file;
    NTFS_INDEX_TREE                     root_index;
    VCN                                 child_file_number;
    NTFS_CHKDSK_REPORT                  chkdsk_report;
    NTFS_CHKDSK_INFO                    chkdsk_info;
    BIG_INT                             disk_size;
    BIG_INT                             free_clusters;
    BIG_INT                             cluster_count;
    ULONG                               cluster_size;
    BIG_INT                             tmp_size;
    DIGRAPH                             directory_digraph;
    BOOLEAN                             corrupt_volume;
    USHORT                              volume_flags;
    BOOLEAN                             volume_is_dirty;
    BOOLEAN                             resize_log_file;
    MFT_SEGMENT_REFERENCE               seg_ref;
    ULONG                               entry_index;
    BOOLEAN                             disk_errors_found = FALSE;
    DSTRING                             index_name;
    UCHAR                               major, minor;
    ULONG                               num_boot_clusters;
    BIG_INT                             LsnResetThreshhold;
    PREAD_CACHE                         read_cache = NULL;
    BOOLEAN                             changes = FALSE;
    BOOLEAN                             RefrainFromResizing = FALSE;
    BOOLEAN                             bitmap_growable;
    ULONG                               errFixedStatus = CHKDSK_EXIT_SUCCESS;
    DSTRING                             label;
    NTFS_CHKDSK_INTERNAL_INFO           chkdsk_internal_info;
    LARGE_INTEGER                       temp_time;
	LCN									mft_ref_first_lcn;

    BOOLEAN       Verbose = (Flags & CHKDSK_VERBOSE) ? TRUE : FALSE;
    BOOLEAN       OnlyIfDirty = (Flags & CHKDSK_CHECK_IF_DIRTY) ? TRUE : FALSE;
//    BOOLEAN       EnableUpgrade = (Flags & CHKDSK_ENABLE_UPGRADE) ? TRUE : FALSE;
//    BOOLEAN       EnableDowngrade = FALSE;
    BOOLEAN       RecoverFree = (Flags & CHKDSK_RECOVER_FREE_SPACE) ? TRUE : FALSE;
    BOOLEAN       RecoverAlloc = (Flags & CHKDSK_RECOVER_ALLOC_SPACE) ? TRUE : FALSE;
    BOOLEAN       ResizeLogFile = (Flags & CHKDSK_RESIZE_LOGFILE) ? TRUE : FALSE;
    BOOLEAN       SkipIndexScan = (Flags & CHKDSK_SKIP_INDEX_SCAN) ? TRUE : FALSE;
    BOOLEAN       SkipCycleScan = (Flags & CHKDSK_SKIP_CYCLE_SCAN) ? TRUE : FALSE;
    BOOLEAN       AlgorithmSpecified = (Flags & CHKDSK_ALGORITHM_SPECIFIED) ? TRUE : FALSE;

#if defined(TIMING_ANALYSIS)
    LARGE_INTEGER                       temp_time2;
#endif

#if !defined(_AUTOCHECK_)
    STATIC LONG   NtfsChkdskIsRunning = 0;
#endif

    //
    // When TRUE is returned, CHKDSK_EXIT_SUCCESS will be the
    // default.  When FALSE is returned, the default will be
    // CHKDSK_EXIT_COULD_NOT_CHK.
    //

    if (NULL == ExitStatus) {
        ExitStatus = &chkdsk_info.ExitStatus;
    }
    *ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
    chkdsk_info.ExitStatus = CHKDSK_EXIT_SUCCESS;

#if !defined(_AUTOCHECK_)
    if (InterlockedCompareExchange(&NtfsChkdskIsRunning, 1, 0) != 0) {
        Message->DisplayMsg(MSG_CHK_NO_MULTI_THREAD);
        return FALSE;
    }
#endif

    memset(&chkdsk_internal_info, 0, sizeof(NTFS_CHKDSK_INTERNAL_INFO));

    IFS_SYSTEM::QueryNtfsTime(&chkdsk_internal_info.ElapsedTotalTime);

    SetNumberOfStages(3 + (RecoverFree ? 1 : 0) + (RecoverAlloc ? 1 : 0));

    if (SetupSpecial == FixLevel) {

        //
        // The "SetupSpecial" fixlevel is used only when the volume
        // is ntfs and the /s flag is passed to autochk.  It means that
        // we should not bother to resize the logfile, since setup
        // doesn't want to reboot the system for that.
        //

        RefrainFromResizing = TRUE;
        FixLevel = TotalFix;
    }

#if 0
    if (EnableDowngrade && EnableUpgrade) {
        EnableDowngrade = EnableUpgrade = FALSE;
    }
#endif

    // Try to enable caching, if there's not enough resources then
    // just run without a cache.  Make the cache 64K.

    if ((read_cache = NEW READ_CACHE) &&
        read_cache->Initialize(_drive, MFT_PRIME_SIZE/_drive->QuerySectorSize())) {

        _drive->SetCache(read_cache);

    } else {
        DELETE(read_cache);
        read_cache = NULL;
    }

    chkdsk_info.Verbose = Verbose;

    volume_flags = QueryVolumeFlagsAndLabel(&corrupt_volume, &major, &minor, &label);
    volume_is_dirty = (volume_flags & VOLUME_DIRTY) ? TRUE : FALSE;
    if (!ResizeLogFile)
        DesiredLogFileSize = 0;
    resize_log_file = (volume_flags & VOLUME_RESIZE_LOG_FILE) || ResizeLogFile;

    if (corrupt_volume) {
        Message->DisplayMsg(MSG_NTFS_CHK_NOT_NTFS);
        return FALSE;
    }

    if (major > 3) {
        Message->DisplayMsg(MSG_CHK_NTFS_WRONG_VERSION);
        return FALSE;
    }

    if ((volume_flags & VOLUME_DELETE_USN_UNDERWAY) && FixLevel == CheckOnly) {
        Message->DisplayMsg(MSG_CHK_NTFS_DELETING_USNJRNL_UNDERWAY);
        return FALSE;
    }

    SetVersionNumber( major, minor );

    if (label.QueryChCount()) {
        Message->DisplayMsg(MSG_CHK_NTFS_VOLUME_LABEL,
                            "%W", &label);
    }

    // If default autochk and the volume is not dirty then
    //    do minimal and return
    // Alternatively, if it's a user requested autochk and
    //    it has been executed previously, do minimal and return

#if defined(USE_CHKDSK_BIT)
    if ((OnlyIfDirty && !volume_is_dirty)
#if defined(_AUTOCHECK_)
        // only autochk should see this flag set
        // if chkdsk sees it, it should clear it
        ||
        (!volume_is_dirty &&
         (volume_flags & VOLUME_CHKDSK_RAN_ONCE) &&
         !Message->IsInSetup())
#endif
        ) {
#else
    if (OnlyIfDirty && !volume_is_dirty) {
#endif
        Message->DisplayMsg(MSG_CHK_VOLUME_CLEAN);

        // If the volume version number is 1.2 or greater, check
        // the log file size.
        //
        if (!RefrainFromResizing &&
            FixLevel != CheckOnly &&
            (major > 1 || (major == 1 && minor >= 2))) {

            if (!ResizeCleanLogFile( Message, ResizeLogFile, DesiredLogFileSize )) {

                Message->DisplayMsg(MSG_CHK_NTFS_RESIZING_LOG_FILE_FAILED);
            }
        }

#if 0
        if (EnableUpgrade && FixLevel != CheckOnly) {
            if (!SetVolumeFlag(VOLUME_UPGRADE_ON_MOUNT, &corrupt_volume) ||
                corrupt_volume) {
                Message->DisplayMsg(MSG_CHKNTFS_NOT_ENABLE_UPGRADE,
                                    "%W", DriveLetter);
            }
        }
#endif

#if defined(USE_CHKDSK_BIT)
        if (volume_flags & VOLUME_CHKDSK_RAN_ONCE) {

            BIG_INT BigZero = 0;

            DebugPrintTrace(("UNTFS: Clearing chkdsk ran once flag\n"));

            if (!ClearVolumeFlag(VOLUME_CHKDSK_RAN_ONCE,
                                 NULL,
                                 FALSE,
                                 BigZero.GetLargeInteger(),
                                 &corrupt_volume,
                                 TRUE) ||
                corrupt_volume) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANNOT_CLEAR_VOLUME_CHKDSK_RAN_ONCE_FLAG);
            }
        }
#endif

        Message->SetLoggingEnabled(FALSE);

        *ExitStatus = CHKDSK_EXIT_SUCCESS;

        return TRUE;
    }

    if (FixLevel == CheckOnly) {
        Message->DisplayMsg(MSG_CHK_NTFS_READ_ONLY_MODE, NORMAL_MESSAGE, TEXT_MESSAGE);
    } else {

        //
        // The volume is not clean, so if we're autochecking we want to
        // make sure that we're printing real messages on the console
        // instead of just dots.
        //

#if defined( _AUTOCHECK_ )

        if (Message->SetDotsOnly(FALSE)) {

            Message->SetLoggingEnabled(FALSE);
            if (NULL != DriveLetter) {

                Message->DisplayMsg(MSG_CHK_RUNNING,
                                    "%W", DriveLetter);
            }

            Message->DisplayMsg(MSG_FILE_SYSTEM_TYPE,
                                "%ws", L"NTFS");

            if (label.QueryChCount()) {
                Message->DisplayMsg(MSG_CHK_NTFS_VOLUME_LABEL,
                                    "%W", &label);
            }
            Message->SetLoggingEnabled();
        }

#endif /* _AUTOCHECK_ */

    }

    if (SkipIndexScan || SkipCycleScan) {
        Message->DisplayMsg(MSG_BLANK_LINE);
        if (SkipIndexScan) {
            Message->DisplayMsg(MSG_CHK_NTFS_SKIP_INDEX_SCAN);
        }
        if (SkipCycleScan) {
            Message->DisplayMsg(MSG_CHK_NTFS_SKIP_CYCLE_SCAN);
        }
        Message->DisplayMsg(MSG_CHK_NTFS_SKIP_SCAN_WARNING );
    }

#if defined( _AUTOCHECK_ )

    if (Message->IsInAutoChk()) { // if in normal autochk

        ULONG   timeout;

        if (!VOL_LIODPDRV::QueryAutochkTimeOut(&timeout)) {
            timeout = AUTOCHK_TIMEOUT;
        }

        if (timeout > MAX_AUTOCHK_TIMEOUT_VALUE)
            timeout = AUTOCHK_TIMEOUT;

        if (timeout != 0) {

            MSGID   msgid;

            // leave logging on so that the user will know if
            // chkdsk invocation is due to dirty drive
            if (volume_is_dirty)
                msgid = MSG_CHK_AUTOCHK_SKIP_WARNING;
            else
                msgid = MSG_CHK_USER_AUTOCHK_SKIP_WARNING;
            Message->DisplayMsg(msgid);
            if (Message->IsKeyPressed(MSG_CHK_ABORT_AUTOCHK, timeout)) {
                Message->SetLoggingEnabled(FALSE);
                Message->DisplayMsg(MSG_CHK_AUTOCHK_ABORTED);
                *ExitStatus = CHKDSK_EXIT_SUCCESS;
                return TRUE;
            } else {
                Message->DisplayMsg(MSG_CHK_AUTOCHK_RESUMED);
            }
        } else if (volume_is_dirty) {
            Message->DisplayMsg(MSG_CHK_VOLUME_IS_DIRTY);
        }
    } else {
        DebugAssert(Message->IsInSetup());
        if (volume_is_dirty) {
            Message->DisplayMsg(MSG_CHK_VOLUME_IS_DIRTY);
        }
    }

#endif  // _AUTOCHECK_

    memset(&chkdsk_report, 0, sizeof(NTFS_CHKDSK_REPORT));


    // Set the 'LargestLsnEncountered' variable to the smallest
    // possible LSN value.

    LargestLsnEncountered.LowPart = 0;
    LargestLsnEncountered.HighPart = MINLONG;


    // Set the 'LargestUsnEncountered' variable to the smallest
    // possible USN value.

    LargestUsnEncountered.LowPart = 0;
    LargestUsnEncountered.HighPart = 0;
    FrsOfLargestUsnEncountered = 0;

    // Fetch the MFT's $DATA attribute.

    if (!FetchMftDataAttribute(Message, &mft_data)) {
        DebugPrintTrace(("Begin Mft reconstruction.\n"));
        if (!RecoverMftDataAttribute(Message, &mft_data)) {
            Message->DisplayMsg(MSG_CHK_NTFS_MFT_RECOVERY_FAILED);
            return FALSE;
        }
        DebugPrintTrace(("Mft reconstruction complete.\n"));
    }



// for testing purposes only
#if 0
    NTFS_ATTRIBUTE  mft_test_data;
    if (!RecoverMftDataAttribute(Message, &mft_test_data)) {
        return FALSE;
    }

    if (mft_test_data == mft_data) {
        DebugPrint("Mft reconstruction successful. Reconstructed MFT is:\n");
    } else {
        DebugPrint("Mft reconstruction failed. Reconstructed MFT is:\n");
    }

    int test_i;
    VCN test_vcn;
    LCN test_lcn;
    BIG_INT test_run_length;
    for (test_i = 0; mft_test_data.GetExtentList()->QueryExtent(test_i, &test_vcn, &test_lcn, &test_run_length); test_i++) {

        if (LCN_NOT_PRESENT == test_lcn) {
            continue;
        }
        DebugPrintTrace(("(vcn, lcn, runlength) : (%I64x,  %I64x, %I64x)\n", test_vcn.GetLargeInteger(), test_lcn.GetLargeInteger(), test_run_length.GetLargeInteger()));

    }

#endif
// end of testing code


    // Now make sure that the first four FRS of the MFT are readable,
    // contiguous, and not too corrupt.

    if (!ValidateCriticalFrs(&mft_data, Message, FixLevel)) {
        return FALSE;
    }


    // Compute the number of file record segments and the number of volume
    // clusters on disk.

    mft_data.QueryValueLength(&num_frs, &num_mft_bits);

    num_frs = num_frs / QueryFrsSize();

    num_mft_bits = num_mft_bits / QueryFrsSize();

    if (num_frs.GetHighPart() != 0) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        Message->LogMsg(MSG_CHKLOG_NTFS_TOO_MANY_FILES,
                     "%I64x", num_frs.GetLargeInteger());
        return FALSE;
    }

    volume_clusters = QueryVolumeSectors()/((ULONG) QueryClusterFactor());

    // Initialize the internal MFT bitmap, volume bitmap, and unreadable
    // file record segments.
    //

    num_boot_clusters = max(1, BYTES_PER_BOOT_SECTOR/
                               (_drive->QuerySectorSize()*
                                QueryClusterFactor()));

#if defined(_AUTOCHECK_)
    SYSTEM_PERFORMANCE_INFORMATION  perf_info;
    NTSTATUS                        status;

    status = NtQuerySystemInformation(SystemPerformanceInformation,
                                      &perf_info,
                                      sizeof(perf_info),
                                      NULL);

    if (!NT_SUCCESS(status)) {
        DebugPrintTrace(("UNTFS: NtQuerySystemInformation(SystemPerformanceInformation) failed (%x)\n", status));
        return FALSE;
    }

    chkdsk_info.AvailablePages = perf_info.AvailablePages;
#endif

    DebugAssert(num_frs.GetHighPart() == 0);
    chkdsk_info.major = major;
    chkdsk_info.minor = minor;
    chkdsk_info.QuotaFileNumber = 0;
    chkdsk_info.ObjectIdFileNumber = 0;
    chkdsk_info.UsnJournalFileNumber = 0;
    chkdsk_info.ReparseFileNumber = 0;
    chkdsk_info.NumFiles = num_frs.GetLowPart();
    chkdsk_info.BaseFrsCount = 0;
    chkdsk_info.TotalNumFileNames = 0;
    chkdsk_info.CrossLinkYet = FALSE;
    chkdsk_info.CrossLinkStart = (volume_clusters/2).GetLowPart();
    chkdsk_info.CrossLinkLength = num_boot_clusters;
    chkdsk_info.CountFilesWithIndices = 0;

    bitmap_growable = /* MJB _drive->QuerySectors() != QueryVolumeSectors() */ FALSE;

    if (!mft_bitmap.Initialize(num_mft_bits, TRUE) ||
        !volume_bitmap.Initialize(volume_clusters, bitmap_growable, _drive,
            QueryClusterFactor()) ||
        !(chkdsk_info.NumFileNames = NEW USHORT[chkdsk_info.NumFiles]) ||
        !(chkdsk_info.ReferenceCount = NEW SHORT[chkdsk_info.NumFiles]) ||
        !chkdsk_info.FilesWithIndices.Initialize(num_frs, TRUE) ||
        !chkdsk_info.FilesWithEas.Initialize() ||
        !chkdsk_info.ChildFrs.Initialize() ||
        !chkdsk_info.BadFiles.Initialize() ||
        !chkdsk_info.FilesWhoNeedData.Initialize(num_frs, FALSE) ||
        !chkdsk_info.FilesWithNoReferences.Initialize() ||
        !chkdsk_info.FilesWithTooManyFileNames.Initialize() ||
        !chkdsk_info.FilesWithObjectId.Initialize() ||
        !chkdsk_info.FilesWithReparsePoint.Initialize(num_frs, FALSE)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    memset(chkdsk_info.NumFileNames, 0, chkdsk_info.NumFiles*sizeof(USHORT));
    memset(chkdsk_info.ReferenceCount, 0, chkdsk_info.NumFiles*sizeof(USHORT));


    // Mark as allocated on the bitmap, the clusters reserved
    // for the boot file.
    //

    volume_bitmap.SetAllocated(0, num_boot_clusters);

    // If the volume size is smaller than the partition size, we figure that
    // the replica boot sector is at the end of the partition.  Otherwise we
    // figure it must be in the middle.
    //

    if (QueryVolumeSectors() == _drive->QuerySectors()) {
        volume_bitmap.SetAllocated(volume_clusters/2, num_boot_clusters);
    }

    // Fetch the attribute definition table.

    if (!FetchAttributeDefinitionTable(&mft_data,
                                       Message,
                                       &attribute_def_table)) {
        return FALSE;
    }

    // Fetch the upcase table.

    if (!FetchUpcaseTable(&mft_data, Message, &upcase_table)) {
        return FALSE;
    }

    if (!hmem.Initialize()) {
        return FALSE;
    }

    // Verify and fix all of the file record segments.

    IFS_SYSTEM::QueryNtfsTime(&temp_time);

    if (!StartProcessingFiles(num_frs,
                              &disk_errors_found,
                              FixLevel,
                              &mft_data,
                              &mft_bitmap,
                              &volume_bitmap,
                              &upcase_table,
                              &attribute_def_table,
                              &chkdsk_report,
                              &chkdsk_info,
                              Message))
        return FALSE;

#if defined(LOCATE_DELETED_FILE)
    return FALSE;
#endif

    IFS_SYSTEM::QueryNtfsTime(&chkdsk_internal_info.ElapsedTimeForFileVerification);
    chkdsk_internal_info.ElapsedTimeForFileVerification.QuadPart -= temp_time.QuadPart;

#if defined(TIMING_ANALYSIS)
    Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE, "%s%I64d", "Stage 1 in ticks: ",
                        chkdsk_internal_info.ElapsedTimeForFileVerification);
#endif

    chkdsk_internal_info.TotalFrsCount = num_frs.GetLowPart();
    chkdsk_internal_info.BaseFrsCount = chkdsk_info.BaseFrsCount;
    chkdsk_internal_info.TotalNumFileNames = chkdsk_info.TotalNumFileNames;
    chkdsk_internal_info.FilesWithObjectId =
        chkdsk_info.FilesWithObjectId.QueryCardinality().GetLowPart();
    chkdsk_internal_info.FilesWithReparsePoint =
        (num_frs - chkdsk_info.FilesWithReparsePoint.QueryFreeClusters()).GetLowPart();

    // Compute the files that have too many file-names.

    for (i = 0; i < chkdsk_info.NumFiles; i += 1) {
        if (chkdsk_info.NumFileNames[i.GetLowPart()] > 500) {
            if (!chkdsk_info.FilesWithTooManyFileNames.Add(i)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            Message->DisplayMsg(MSG_CHK_NTFS_TOO_MANY_FILE_NAMES,
                                "%d", i.GetLowPart());
        }
    }


    // Clean up orphan file record segments.

    while (chkdsk_info.ChildFrs.QueryCardinality() > 0) {

        child_file_number = chkdsk_info.ChildFrs.QueryNumber(0);

        if (mft_bitmap.IsFree(child_file_number, 1)) {

            Message->DisplayMsg(MSG_CHK_NTFS_ORPHAN_FRS,
                                "%d", child_file_number.GetLowPart());

            disk_errors_found = TRUE;

            if (!frsstruc.Initialize(&hmem,
                                     &mft_data,
                                     child_file_number,
                                     QueryClusterFactor(),
                                     QueryVolumeSectors(),
                                     QueryFrsSize(),
                                     &upcase_table)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!frsstruc.Read()) {

                DebugAssert("previously readable frs is now unreadable");
                return FALSE;
            }

            frsstruc.ClearInUse();

            if (FixLevel != CheckOnly && !frsstruc.Write()) {
                Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                    "%d", frsstruc.QueryFileNumber().GetLowPart());
                return FALSE;
            }
        }

        if (!chkdsk_info.ChildFrs.Remove(child_file_number)) {
            DebugAbort("Couldn't remove from the beginning of a num set.");
            return FALSE;
        }
    }

    if (disk_errors_found) {
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    if (disk_errors_found && FixLevel == CheckOnly) {
        Message->DisplayMsg(MSG_CHK_NTFS_ERRORS_FOUND);
        return FALSE;
    }


    mft_bitmap.SetAllocated(0, FIRST_USER_FILE_NUMBER);

    // Now the internal volume bitmap and internal MFT bitmap are in
    // ssync with the state of the disk.  We must insure that the
    // internal MFT data attribute, the internal MFT bitmap, the
    // internal volume bitmap, and the internal attribute definition table
    // are the same as the corresponding disk structures.

    // The first step is to hotfix all of the unreadable FRS in the
    // master file table.  We'll store bad cluster numbers in a
    // number set.

    if (!HotfixMftData(&mft_data, &volume_bitmap, &chkdsk_info.BadFiles,
                       &bad_clusters, FixLevel, Message)) {

        return FALSE;
    }

    if (!internal_mft.Initialize(&mft_data,
                                 &mft_bitmap,
                                 &volume_bitmap,
                                 &upcase_table,
                                 QueryClusterFactor(),
                                 QueryFrsSize(),
                                 _drive->QuerySectorSize(),
                                 QueryVolumeSectors(),
                                 FixLevel == CheckOnly)) {

        DebugAbort("Couldn't initialize the internal MFT.");
        return FALSE;
    }


    // Check to see if there's a file cross-linked with the boot
    // mirror and attempt to fix it by copying the data.

    if (!ResolveCrossLink(&chkdsk_info, &internal_mft, &bad_clusters,
                          FixLevel, Message)) {
        return FALSE;
    }


    // At this point, use the internal MFT to validate all of the
    // OS/2 EAs and NTFS indices.

#if defined(TIMING_ANALYSIS)
    IFS_SYSTEM::QueryNtfsTime(&temp_time);
#endif

    if (!ValidateEas(&chkdsk_info,
                     &chkdsk_report,
                     &internal_mft,
                     FixLevel, Message)) {
        return FALSE;
    }

#if defined(TIMING_ANALYSIS)
    IFS_SYSTEM::QueryNtfsTime(&temp_time2);
    Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE, "%s%I64d", "ValidateEas time in ticks: ",
                        temp_time2.QuadPart - temp_time.QuadPart);
#endif

    // Make sure that all of the system files are marked in use.
    // (They are definitely marked in the MFT bitmap).  If they're
    // not then mark them for orphan recovery.

    if (!EnsureSystemFilesInUse(&chkdsk_info, &internal_mft,
                                FixLevel, Message)) {
        return FALSE;
    }

    //
    // Validate all Reparse Point attribute
    //

    if (!ValidateReparsePoint(&chkdsk_info,
                              &internal_mft,
                              FixLevel, Message)) {
        return FALSE;
    }


    IFS_SYSTEM::QueryNtfsTime(&temp_time);

    if (!ValidateIndices(&chkdsk_info,
                         &directory_digraph,
                         &internal_mft,
                         &attribute_def_table,
                         &chkdsk_report,
                         &bad_clusters,
                         AlgorithmSpecified ? Algorithm : CHKDSK_ALGORITHM_NOT_SPECIFIED,
                         SkipIndexScan,
                         SkipCycleScan,
                         FixLevel, Message,
                         &disk_errors_found)) {

        return FALSE;
    }

    IFS_SYSTEM::QueryNtfsTime(&chkdsk_internal_info.ElapsedTimeForIndexVerification);
    chkdsk_internal_info.ElapsedTimeForIndexVerification.QuadPart -= temp_time.QuadPart;

    if (disk_errors_found && FixLevel == CheckOnly) {
        Message->DisplayMsg(MSG_CHK_NTFS_ERRORS_FOUND);
        return FALSE;
    }


    // Now recover orphans into a nice directory.

    if (!RecoverOrphans(&chkdsk_info,
                        &chkdsk_report,
                        &directory_digraph,
                        &internal_mft,
                        SkipCycleScan,
                        FixLevel, Message)) {

        return FALSE;
    }

    DELETE(chkdsk_info.NumFileNames);
    DELETE(chkdsk_info.ReferenceCount);

    if (major >= 2) {
        if (!CheckExtendSystemFiles(&chkdsk_info, &chkdsk_report,
                                    &internal_mft, FixLevel, Message))
            return FALSE;
    }

    // Make sure that everyone's security descriptor is valid.

    IFS_SYSTEM::QueryNtfsTime(&temp_time);

    if (!ValidateSecurityDescriptors(&chkdsk_info, &chkdsk_report, &internal_mft,
                                     &bad_clusters, SkipIndexScan, FixLevel,
                                     Message)) {
        return FALSE;
    }

    IFS_SYSTEM::QueryNtfsTime(&chkdsk_internal_info.ElapsedTimeForSDVerification);
    chkdsk_internal_info.ElapsedTimeForSDVerification.QuadPart -= temp_time.QuadPart;
    chkdsk_internal_info.TotalNumSID = chkdsk_info.TotalNumSID;

    // Now make sure that everyone who should have an unnamed $DATA
    // attribute has one.

    if (!CheckAllForData(&chkdsk_info, &internal_mft, FixLevel, Message)) {

        return FALSE;
    }

    chkdsk_info.FilesWhoNeedData.~NTFS_BITMAP();

    // Make sure that all records in Usn Journal is valid

    if (major >= 2 &&
        !ValidateUsnJournal(&chkdsk_info, &chkdsk_report, &internal_mft,
                            &bad_clusters, FixLevel, Message)) {
        return FALSE;
    }

    // Verify all user file data if requested.

    IFS_SYSTEM::QueryNtfsTime(&temp_time);

    if (RecoverAlloc && FixLevel != CheckOnly &&
        !RecoverAllUserFiles(major, &internal_mft, &bad_clusters, Message)) {

        return FALSE;
    }

    IFS_SYSTEM::QueryNtfsTime(&chkdsk_internal_info.ElapsedTimeForUserSpaceVerification);
    chkdsk_internal_info.ElapsedTimeForUserSpaceVerification.QuadPart -= temp_time.QuadPart;

    // Verify all free space if requested.

    IFS_SYSTEM::QueryNtfsTime(&temp_time);

    if (RecoverFree &&
        !RecoverFreeSpace(&internal_mft, &bad_clusters, Message)) {

        return FALSE;
    }

    IFS_SYSTEM::QueryNtfsTime(&chkdsk_internal_info.ElapsedTimeForFreeSpaceVerification);
    chkdsk_internal_info.ElapsedTimeForFreeSpaceVerification.QuadPart -= temp_time.QuadPart;

    //
    // Take care of the remaining system files
    //

    if (!root_file.Initialize(ROOT_FILE_NAME_INDEX_NUMBER, &internal_mft) ||
        !root_file.Read() ||
        !index_name.Initialize(FileNameIndexNameData) ||
        !root_index.Initialize(_drive, QueryClusterFactor(),
                               internal_mft.GetVolumeBitmap(),
                               internal_mft.GetUpcaseTable(),
                               root_file.QuerySize()/2,
                               &root_file, &index_name)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }


    // In this space Fix the MFT mirror, attribute definition table,
    // the boot file, the bad cluster file.

    if (!mft_ref.Initialize(&internal_mft)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!mft_ref.Read()) {
        DebugAbort("Can't read in hotfixed MFT reflection file.");
        return FALSE;
    }

    if (!mft_ref.VerifyAndFix(internal_mft.GetDataAttribute(),
                              internal_mft.GetVolumeBitmap(),
                              &bad_clusters,
                              &root_index,
                              &changes,
                              FixLevel,
                              Message)) {
        return FALSE;
    }

	mft_ref_first_lcn = mft_ref.QueryFirstLcn();

	// The above call should not fail on a VerifyAndFix-ed mft_ref
	DebugAssert(mft_ref_first_lcn != 0); 
	
    if ((mft_ref_first_lcn != 0) 
    	&& (mft_ref_first_lcn != QueryMft2StartingLcn())) {

        Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_MFT_MIRROR);
        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_STARTING_LCN,
                     "%I64x%I64x",
                     mft_ref_first_lcn.GetLargeInteger(),
                     QueryMft2StartingLcn().GetLargeInteger());

        DebugPrintTrace(("UNTFS: Bad Mirror LCN in boot sector.\n"));

        _boot_sector->Mft2StartLcn = mft_ref_first_lcn;
        changes = TRUE;
    }

    if (changes)
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

    if (!attr_def_file.Initialize(&internal_mft, major)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!attr_def_file.Read()) {
        DebugAbort("Can't read in hotfixed attribute definition file.");
        return FALSE;
    }

    if (!attr_def_file.VerifyAndFix(&attribute_def_table,
                                    internal_mft.GetVolumeBitmap(),
                                    &bad_clusters,
                                    &root_index,
                                    &changes,
                                    FixLevel,
                                    Message)) {
        return FALSE;
    }
    if (changes)
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

    if (!boot_file.Initialize(&internal_mft)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!boot_file.Read()) {
        DebugAbort("Can't read in hotfixed boot file.");
        return FALSE;
    }

    if (!boot_file.VerifyAndFix(internal_mft.GetVolumeBitmap(),
                                &root_index,
                                &changes,
                                FixLevel,
                                Message)) {
        return FALSE;
    }
    if (changes)
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

    if (!upcase_file.Initialize(&internal_mft)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!upcase_file.Read()) {
        DebugAbort("Can't read in hotfixed upcase file.");
        return FALSE;
    }

    if (!upcase_file.VerifyAndFix(&upcase_table,
                                  internal_mft.GetVolumeBitmap(),
                                  &bad_clusters,
                                  &root_index,
                                  &changes,
                                  FixLevel,
                                  Message)) {
        return FALSE;
    }
    if (changes)
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

    // check out the bad cluster file before the log file
    // as the log file may add bad clusters directly into
    // the bad cluster file

    if (!bad_clus_file.Initialize(&internal_mft)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!bad_clus_file.Read()) {
        DebugAbort("Can't read in hotfixed bad cluster file.");
        return FALSE;
    }

    if (!bad_clus_file.VerifyAndFix(internal_mft.GetVolumeBitmap(),
                                    &root_index,
                                    &changes,
                                    FixLevel,
                                    Message)) {
        return FALSE;
    }
    if (changes)
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

    internal_mft.GetMftBitmap()->SetAllocated(BAD_CLUSTER_FILE_NUMBER, 1);

    if (!log_file.Initialize(&internal_mft)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!log_file.Read()) {
        DebugAbort("Can't read in hotfixed log file.");
        return FALSE;
    }

    if (!log_file.VerifyAndFix(internal_mft.GetVolumeBitmap(),
                               &root_index,
                               &changes,
                               &chkdsk_report,
                               FixLevel,
                               resize_log_file,
                               DesiredLogFileSize,
                               &bad_clusters,
                               Message)) {

        return FALSE;
    }
    if (changes)
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

    if (bad_clusters.QueryCardinality() != 0) {

        Message->DisplayMsg(MSG_CHK_NTFS_ADDING_BAD_CLUSTERS,
                            "%d", bad_clusters.QueryCardinality().GetLowPart());

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        if (bad_clus_file.Add(&bad_clusters)) {

            if (FixLevel != CheckOnly &&
                !bad_clus_file.Flush(internal_mft.GetVolumeBitmap())) {

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_BAD_FILE);
                return FALSE;
            }

        } else {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_ADD_BAD_CLUSTERS);
            chkdsk_info.ExitStatus = CHKDSK_EXIT_ERRS_NOT_FIXED;
        }
    }

    // If the largest LSN on the volume has exceeded the
    // tolerated threshhold, reset all LSN's on the volume
    // and clear the log file.
    //
    LsnResetThreshhold.Set( 0, LsnResetThreshholdHighPart );

    if (FixLevel != CheckOnly &&
        LargestLsnEncountered > LsnResetThreshhold) {

        // The largest LSN on the volume is beyond the tolerated
        // threshhold.  Set all the LSN's on the volume to zero.
        // Since the root index file is in memory, we have to
        // do it separately.
        //

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        if (!ResetLsns(Message, &internal_mft, TRUE)) {
            return FALSE;
        }

        root_file.SetLsn(0);

        if (!root_index.ResetLsns(Message)) {
            return FALSE;
        }

        LargestLsnEncountered.LowPart = 0;
        LargestLsnEncountered.HighPart = 0;

        // Now reset the Log File.  Note that resetting the log
        // file does not change its size, so the Log File FRS
        // won't need to be flushed.
        //
        if (!log_file.Initialize( &internal_mft)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!log_file.Read()) {
            DebugAbort("Can't read in hotfixed log file.");
            return FALSE;
        }

        if (!log_file.Reset(Message)) {
            return FALSE;
        }
    }

    // Mark the volume clean, clearing both the dirty bit,
    // the resize-log-file bit, and the chkdsk-ran-once bit.
    //
    if (FixLevel != CheckOnly &&
        !ClearVolumeFlag(VOLUME_DIRTY | VOLUME_RESIZE_LOG_FILE | VOLUME_CHKDSK_RAN_ONCE |
                         ((major >= 2) ? VOLUME_DELETE_USN_UNDERWAY | VOLUME_REPAIR_OBJECT_ID : 0),
                         &log_file, minor > 0 || major > 1,
                         LargestLsnEncountered, &corrupt_volume)) {

        DebugPrint("Could not set volume clean.\n");

        Message->DisplayMsg(corrupt_volume ? MSG_CHK_NTFS_BAD_MFT :
                                             MSG_CHK_NO_MEMORY);
        return FALSE;
    }

#if 0
    if (EnableUpgrade && FixLevel != CheckOnly) {
        if (!SetVolumeFlag(VOLUME_UPGRADE_ON_MOUNT, &corrupt_volume) ||
            corrupt_volume) {
            Message->DisplayMsg(MSG_CHKNTFS_NOT_ENABLE_UPGRADE,
                                "%W", DriveLetter);
            chkdsk_info.ExitStatus = CHKDSK_EXIT_ERRS_NOT_FIXED;
        }
    }
#endif

    if ((chkdsk_info.ExitStatus || errFixedStatus) &&
        FixLevel != CheckOnly && major >= 2) {

        if (!MarkQuotaOutOfDate(&chkdsk_info, &internal_mft, FixLevel, Message)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANNOT_SET_QUOTA_FLAG_OUT_OF_DATE);
            return FALSE;
        }

        if (!SetVolumeFlag(VOLUME_CHKDSK_RAN, &corrupt_volume) ||
            corrupt_volume) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANNOT_SET_VOLUME_CHKDSK_RAN_FLAG);
            chkdsk_info.ExitStatus = CHKDSK_EXIT_ERRS_NOT_FIXED;
        }
    }

#if 0

    // There is a bug in SynchronizeMft that in CheckOnly mode, it does
    // change the values of internal_mft.  This is undesirable.
    // If we ever do downgrade again, this bug must be fixed.

    if (!SynchronizeMft(&root_index, &internal_mft, &changes,
                        CheckOnly, Message, SuppressMessage)) {
        return FALSE;
    }

    if (EnableDowngrade &&
        !DownGradeNtfs(Message, &internal_mft, &chkdsk_info)) {
        return FALSE;
    }
#endif

    // Now fix the mft (both data, and bitmap), and the volume bitmap.
    // Write everything out to disk.

    if (!SynchronizeMft(&root_index, &internal_mft, &changes,
                        FixLevel, Message, CorrectMessage)) {
        return FALSE;
    }
    if (changes)
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

    // Now flush out the root index that was used in v+f of the critical
    // files.

    if (FixLevel != CheckOnly) {
        if (!root_index.Save(&root_file) ||
            !root_file.Flush(NULL)) {

            DebugPrint("Could not flush root index.\n");

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    // After synchronizing the MFT flush it out so that the MFT mirror
    // gets written.

    if (!mft_file.Initialize(_drive, QueryMftStartingLcn(),
                             QueryClusterFactor(), QueryFrsSize(),
                             QueryVolumeSectors(),
                             internal_mft.GetVolumeBitmap(),
                             internal_mft.GetUpcaseTable())) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (FixLevel != CheckOnly) {
        if (!mft_file.Read() || !mft_file.Flush() || !Write(Message)) {
            DebugAbort("Couldn't IO hotfixed MFT file.");
            return FALSE;
        }
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, &chkdsk_info);
    *ExitStatus = chkdsk_info.ExitStatus;

    switch (*ExitStatus) {
      case CHKDSK_EXIT_SUCCESS:
        Message->DisplayMsg(MSG_CHK_NO_PROBLEM_FOUND);
        break;

      case CHKDSK_EXIT_ERRS_FIXED:
        Message->DisplayMsg((FixLevel != CheckOnly) ? MSG_CHK_ERRORS_FIXED : MSG_CHK_NEED_F_PARAMETER);
        break;

      case CHKDSK_EXIT_COULD_NOT_CHK:
//    case CHKDSK_EXIT_ERRS_NOT_FIXED:
//    case CHKDSK_EXIT_COULD_NOT_FIX:
        Message->DisplayMsg(MSG_CHK_ERRORS_NOT_FIXED);
        break;

    }

#if defined(_AUTOCHECK_)
    if (_cleanup_that_requires_reboot) {
        // if it is not CHKDSK_EXIT_COULD_NOT_FIX then it can only be
        // CHKDSK_EXIT_ERRS_FIXED, CHKDSK_EXIT_SUCCESS, or CHKDSK_EXIT_MINOR_ERRS
        // so overwrite the not so important code with CHKDSK_EXIT_ERRS_FIXED
        if (*ExitStatus != CHKDSK_EXIT_COULD_NOT_FIX)
            *ExitStatus = CHKDSK_EXIT_ERRS_FIXED;   // we want a reboot when called within textmode setup
    }
#endif

    IFS_SYSTEM::QueryNtfsTime(&temp_time);
    chkdsk_internal_info.ElapsedTotalTime.QuadPart = temp_time.QuadPart -
                                                     chkdsk_internal_info.ElapsedTotalTime.QuadPart;

    // Generate the chkdsk report.

    cluster_size = QueryClusterFactor()*_drive->QuerySectorSize();

    disk_size = _drive->QuerySectorSize()*QueryVolumeSectors();


    if (disk_size.GetHighPart() < 0x200)  {   // if >= 2TB
        Message->DisplayMsg(MSG_CHK_NTFS_TOTAL_DISK_SPACE_IN_KB,
                            "%10u", (disk_size/1024).GetLowPart());
    } else {
        Message->DisplayMsg(MSG_CHK_NTFS_TOTAL_DISK_SPACE_IN_MB,
                            "%10u", (disk_size/(1024*1024)).GetLowPart());
    }

    if (chkdsk_report.NumUserFiles != 0) {
        ULONG nfiles;

        nfiles = chkdsk_report.NumUserFiles.GetLowPart();
        if (chkdsk_report.BytesUserData.GetHighPart() < 0x200) {
            ULONG kbytes;

            kbytes = (chkdsk_report.BytesUserData/1024).GetLowPart();

            Message->DisplayMsg(MSG_CHK_NTFS_USER_FILES_IN_KB,
                                "%10u%u", kbytes, nfiles);
        } else {
            ULONG mbytes;

            mbytes = (chkdsk_report.BytesUserData/(1024*1024)).GetLowPart();

            Message->DisplayMsg(MSG_CHK_NTFS_USER_FILES_IN_MB,
                                "%10u%u", mbytes, nfiles);
        }
    }

    if (chkdsk_report.NumIndices != 0) {
        ULONG nindices;

        nindices = chkdsk_report.NumIndices.GetLowPart();

        if (chkdsk_report.BytesInIndices.GetHighPart() < 0x200) {
            ULONG kbytes;

            kbytes = (chkdsk_report.BytesInIndices/1024).GetLowPart();

            Message->DisplayMsg(MSG_CHK_NTFS_INDICES_REPORT_IN_KB,
                                "%10u%u", kbytes, nindices);

        } else {
            ULONG mbytes;

            mbytes = (chkdsk_report.BytesInIndices/(1024*1024)).GetLowPart();

            Message->DisplayMsg(MSG_CHK_NTFS_INDICES_REPORT_IN_MB,
                                "%10u%u", mbytes, nindices);
        }
    }

    tmp_size = bad_clus_file.QueryNumBad() * cluster_size;

    if (tmp_size.GetHighPart() < 0x200) {
        Message->DisplayMsg(MSG_CHK_NTFS_BAD_SECTORS_REPORT_IN_KB,
                            "%10u", (tmp_size/1024).GetLowPart());
    } else {
        Message->DisplayMsg(MSG_CHK_NTFS_BAD_SECTORS_REPORT_IN_MB,
                            "%10u", (tmp_size/(1024*1024)).GetLowPart());
    }

    free_clusters = internal_mft.GetVolumeBitmap()->QueryFreeClusters();

    tmp_size = disk_size - tmp_size -
                  free_clusters*cluster_size - chkdsk_report.BytesUserData -
                  chkdsk_report.BytesInIndices;

    if (tmp_size.GetHighPart() < 0x200) {
        Message->DisplayMsg(MSG_CHK_NTFS_SYSTEM_SPACE_IN_KB,
                            "%10u", (tmp_size/1024).GetLowPart());
    } else {
        Message->DisplayMsg(MSG_CHK_NTFS_SYSTEM_SPACE_IN_MB,
                            "%10u", (tmp_size/(1024*1024)).GetLowPart());
    }

    Message->DisplayMsg(MSG_CHK_NTFS_LOGFILE_SPACE,
                        "%10u", (chkdsk_report.BytesLogFile/1024).GetLowPart());

    tmp_size = free_clusters * cluster_size;

    if (tmp_size.GetHighPart() < 0x200) {
        Message->DisplayMsg(MSG_CHK_NTFS_AVAILABLE_SPACE_IN_KB,
                            "%10u", (tmp_size/1024).GetLowPart());
    } else {
        Message->DisplayMsg(MSG_CHK_NTFS_AVAILABLE_SPACE_IN_MB,
                            "%10u", (tmp_size/(1024*1024)).GetLowPart());
    }

    Message->DisplayMsg(MSG_BYTES_PER_ALLOCATION_UNIT, "%10u", cluster_size);

    Message->DisplayMsg(MSG_TOTAL_ALLOCATION_UNITS,
                        "%10u", volume_clusters.GetLowPart());

    Message->DisplayMsg(MSG_AVAILABLE_ALLOCATION_UNITS,
                        "%10u", free_clusters.GetLowPart());

    //
    // Get the frequency counter so that we know how to scale the delta time.
    // However, this counter is not accurate and sometimes incorrect on some hardware
    // so we just store it and not divide the data with it.  Theoretically, it
    // should be around 10000000 ticks and each tick is 100ns.
    //

    {
        LARGE_INTEGER   perf_count;
        LARGE_INTEGER   perf_freq;

        if (NT_SUCCESS(NtQueryPerformanceCounter(&perf_count, &perf_freq))) {
            chkdsk_internal_info.TimerFrequency = perf_freq;
        }
    }

#if defined( _AUTOCHECK_ )

    //
    // It would be nice if we can dump out the binary info in autochk like we did in chkdsk
    //
    Message->LogMsg(MSG_CHKLOG_NTFS_INTERNAL_INFO);
    Message->DumpDataToLog(&chkdsk_internal_info, sizeof(NTFS_CHKDSK_INTERNAL_INFO));

    // If this is AUTOCHK and we're running on the boot partition then
    // we should reboot so that the cache doesn't stomp on us.

    DSTRING sdrive, canon_sdrive, canon_drive;
    BOOLEAN dump_message_to_file, reboot_the_system;

    dump_message_to_file = Message->IsLoggingEnabled();

    if (Message->IsInSetup()) {
        reboot_the_system = FALSE;
        dump_message_to_file = (*ExitStatus == CHKDSK_EXIT_ERRS_FIXED ||
                                *ExitStatus == CHKDSK_EXIT_COULD_NOT_FIX) &&
                               dump_message_to_file;

    } else {
        // example of canonical name: \Device\HarddiskVolumeX
        reboot_the_system =
            dump_message_to_file &&
            IFS_SYSTEM::QueryNtSystemDriveName(&sdrive) &&
            IFS_SYSTEM::QueryCanonicalNtDriveName(&sdrive, &canon_sdrive) &&
            IFS_SYSTEM::QueryCanonicalNtDriveName(_drive->GetNtDriveName(),
                                                  &canon_drive) &&
            canon_drive.Stricmp(&canon_sdrive) == 0;

        if (reboot_the_system) {

            Message->DisplayMsg(MSG_CHK_BOOT_PARTITION_REBOOT);

#if defined(USE_CHKDSK_BIT)
            // if autochk requested by user and flag is not set
            // set it and leave
            if (!(volume_flags & VOLUME_CHKDSK_RAN_ONCE)) {
                DebugPrintTrace(("UNTFS: Setting chkdsk ran once flag\n"));
                if (!SetVolumeFlag(VOLUME_CHKDSK_RAN_ONCE, &corrupt_volume)) {
                    Message->DisplayMsg(MSG_CHK_NTFS_CANNOT_SET_VOLUME_CHKDSK_RAN_ONCE_FLAG);
                    chkdsk_info.ExitStatus = CHKDSK_EXIT_ERRS_NOT_FIXED;
                }
            }
#endif
        }
    }

    if (dump_message_to_file) {

        FSTRING boot_log_file_name;

        DebugPrintTrace(("UNTFS: Dumping messages into bootex.log\n"));

        boot_log_file_name.Initialize( L"bootex.log" );

        if (!DumpMessagesToFile( &boot_log_file_name,
                                 &mft_file,
                                 Message ) ) {
            DebugPrintTrace(("UNTFS: Error writing messages to BOOTEX.LOG\n"));
        }

    }

    // turn off logging so that we don't
    // dump the message out again
    Message->SetLoggingEnabled(FALSE);

    if (reboot_the_system)
        IFS_SYSTEM::Reboot();

#else

    if (FixLevel != CheckOnly &&
        (*ExitStatus == CHKDSK_EXIT_ERRS_FIXED ||
         *ExitStatus == CHKDSK_EXIT_COULD_NOT_FIX) &&
        Message->IsLoggingEnabled()) {

        HMEM        LoggedMessageMem;
        ULONG       MessageDataLength;
        HANDLE      hEventLog;
        NTSTATUS    ntstatus;
        PWSTR       Strings[1];

        if( !LoggedMessageMem.Initialize() ||
            !Message->QueryPackedLog( &LoggedMessageMem, &MessageDataLength ) ) {

            Message->DisplayMsg(MSG_CHK_NTFS_UNABLE_TO_COLLECT_LOGGED_MESSAGES);

        } else {

            hEventLog = RegisterEventSource(NULL, TEXT("Chkdsk"));

            if (hEventLog == NULL) {
                Message->DisplayMsg(MSG_CHK_NTFS_UNABLE_TO_OBTAIN_EVENTLOG_HANDLE);
            } else {
                Strings[0] = (PWSTR)LoggedMessageMem.GetBuf();
                if (MessageDataLength > 32768) {
                    Strings[0][32768/sizeof(WCHAR)] = 0;
                }
                if (!ReportEvent(hEventLog,
                                 EVENTLOG_INFORMATION_TYPE,
                                 0,
                                 MSG_CHK_NTFS_EVENTLOG,
                                 NULL,
                                 1,
                                 sizeof(NTFS_CHKDSK_INTERNAL_INFO),
                                 (PCWSTR*)Strings,
                                 &chkdsk_internal_info)) {
                    Message->DisplayMsg(MSG_CHK_NTFS_FAILED_TO_CREATE_EVENTLOG,
                                        "%d", GetLastError());
                }
                DeregisterEventSource(hEventLog);
            }
        }
    }

#endif

    return TRUE;
}


BOOLEAN
NTFS_SA::ValidateCriticalFrs(
    IN OUT  PNTFS_ATTRIBUTE MftData,
    IN OUT  PMESSAGE        Message,
    IN      FIX_LEVEL       FixLevel
    )
/*++

Routine Description:

    This routine makes sure that the MFT's first four FRS are contiguous
    and readable.  If they are not contiguous, then this routine will
    print a message stating that this volume is not NTFS.  If they are
    not readable then this routine will read the MFT mirror and if that
    is readable then it will replace the MFT's first four FRS with
    the MFT mirror.

Arguments:

    MftData     - Supplies the MFT's data attribute.
    FixLevel    - Supplies the fix level.
    Message     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_CLUSTER_RUN    clusrun;
    HMEM                hmem, volume_hmem;
    LCN                 lcn;
    BIG_INT             run_length;
    ULONG               cluster_size;
    NTFS_FRS_STRUCTURE  volume_frs;
    BIG_INT             volume_cluster;
    ULONG               volume_cluster_offset;
    PCHAR               p;

    cluster_size = QueryClusterFactor() * _drive->QuerySectorSize();

    if (!MftData->QueryLcnFromVcn(0, &lcn, &run_length)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_QUERY_LCN_FROM_VCN_FOR_MFT, "%x", 0);
        return FALSE;
    }

    if (lcn != QueryMftStartingLcn() ||
        run_length <
         (REFLECTED_MFT_SEGMENTS*QueryFrsSize() + (cluster_size - 1)) /cluster_size ) {

        Message->DisplayMsg(MSG_CHK_NTFS_BAD_MFT);
        return FALSE;
    }

    volume_cluster = lcn-1 + (VOLUME_DASD_NUMBER*QueryFrsSize() +
        (cluster_size - 1)) / cluster_size;

    volume_cluster_offset = (lcn * cluster_size + VOLUME_DASD_NUMBER * QueryFrsSize()
        - volume_cluster * cluster_size).GetLowPart();

    if (!hmem.Initialize() ||
        !clusrun.Initialize(&hmem, _drive, lcn, QueryClusterFactor(),
            (REFLECTED_MFT_SEGMENTS*QueryFrsSize() + (cluster_size - 1))/cluster_size) ||
        !volume_hmem.Initialize() ||
        !volume_frs.Initialize(&volume_hmem, _drive,
           volume_cluster,
           QueryClusterFactor(),
           QueryVolumeSectors(),
           QueryFrsSize(), NULL,
           volume_cluster_offset)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    BOOLEAN     x = FALSE;

    if (!clusrun.Read() || !volume_frs.Read() ||
        (x = !volume_frs.GetAttribute($VOLUME_INFORMATION))) {

        if (x) {
            Message->LogMsg(MSG_CHKLOG_NTFS_VOLUME_INFORMATION_MISSING,
                         "%x", VOLUME_DASD_NUMBER);
        }

        Message->DisplayMsg(MSG_CHK_NTFS_USING_MFT_MIRROR);

        clusrun.Relocate(QueryMft2StartingLcn());

        if (!clusrun.Read()) {
            Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_MFT);
            return FALSE;
        }

        if (!MftData->ReplaceVcns(0, QueryMft2StartingLcn(),
            (REFLECTED_MFT_SEGMENTS*QueryFrsSize() + (cluster_size - 1))/cluster_size)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (FixLevel != CheckOnly) {
            p = (PCHAR)clusrun.GetBuf();
            p[0] = 'B';
            p[1] = 'A';
            p[2] = 'A';
            p[3] = 'D';
            clusrun.Write();    // invalidate mirror MFT to avoid updating of volume bitmap
                                // as the first four frs'es lcn are no longer correct
        }

        _boot_sector->MftStartLcn = QueryMft2StartingLcn();
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::FetchMftDataAttribute(
    IN OUT  PMESSAGE        Message,
    OUT     PNTFS_ATTRIBUTE MftData
    )
/*++

Routine Description:

    This routine weeds through the minimal necessary NTFS disk structures
    in order to establish the location of the MFT's $DATA attribute.

Arguments:

    Message - Supplies an outlet for messages.
    MftData - Returns an extent list for the MFT's $DATA attribute.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FRS_STRUCTURE  frs;
    HMEM                hmem;
    ULONG               bytes_per_frs;
    BIG_INT             rounded_value_length;
    BIG_INT             rounded_alloc_length;
    BIG_INT             rounded_valid_length;

    DebugAssert(Message);
    DebugAssert(MftData);

    bytes_per_frs = QueryFrsSize();

    // Initialize the NTFS_FRS_STRUCTURE object we'll use to manipulate
    // the mft's FRS.  Note that we won't manipulate any named attributes,
    // so we can pass in NULL for the upcase table.

    if (!hmem.Initialize() ||
        !frs.Initialize(&hmem, _drive, QueryMftStartingLcn(),
                        QueryClusterFactor(),
                        QueryVolumeSectors(),
                        QueryFrsSize(), NULL)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!frs.Read() ||
        !frs.SafeQueryAttribute($DATA, MftData, MftData) ||
        MftData->QueryValueLength() < FIRST_USER_FILE_NUMBER*bytes_per_frs ||
        MftData->QueryValidDataLength() < FIRST_USER_FILE_NUMBER*bytes_per_frs) {

        // The first copy of the FRS is unreadable or corrupt
        // so try the second copy.

        if (!hmem.Initialize() ||
            !frs.Initialize(&hmem, _drive, QueryMft2StartingLcn(),
                            QueryClusterFactor(),
                            QueryVolumeSectors(),
                            QueryFrsSize(), NULL)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!frs.Read()) {
            Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_MFT_ATTEMPT_TO_RECOVER);
            return FALSE;
        }

        if (!frs.SafeQueryAttribute($DATA, MftData, MftData)) {
            Message->DisplayMsg(MSG_CHK_NTFS_BAD_MFT_ATTEMPT_TO_RECOVER);
            return FALSE;
        }
    }


    if (MftData->QueryValueLength() < FIRST_USER_FILE_NUMBER*bytes_per_frs ||
        MftData->QueryValidDataLength() < FIRST_USER_FILE_NUMBER*bytes_per_frs) {
        Message->DisplayMsg(MSG_CHK_NTFS_BAD_MFT_ATTEMPT_TO_RECOVER);
        return FALSE;
    }

    // Truncate the MFT to be a whole number of file-records.

    rounded_alloc_length = MftData->QueryAllocatedLength()/bytes_per_frs*
                           bytes_per_frs;
    rounded_value_length = MftData->QueryValueLength()/bytes_per_frs*
                           bytes_per_frs;
    rounded_valid_length = MftData->QueryValidDataLength()/bytes_per_frs*
                           bytes_per_frs;

    if (MftData->QueryValidDataLength() != MftData->QueryValueLength()) {
        MftData->Resize(rounded_valid_length, NULL);
    } else if (rounded_value_length != MftData->QueryValueLength() ||
               rounded_alloc_length != MftData->QueryAllocatedLength()) {
        MftData->Resize(rounded_value_length, NULL);
    }

    return TRUE;
}



BOOLEAN
NTFS_SA::RecoverMftDataAttribute(
    IN OUT  PMESSAGE        Message,
    OUT     PNTFS_ATTRIBUTE MftData
    )
/*++

Routine Description:

    This routine reads through the disk sector by sector and reconstructs
    the MFT's $DATA attribute
    
Arguments:

    Message - Supplies an outlet for messages.
    MftData - Returns an extent list for the MFT's $DATA attribute.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Note:

    This routine should be called only if NTFS_SA::FetchMftDataAttribute fails
    to fetch the MFT's $DATA attribute.

--*/
{
    NTFS_EXTENT_LIST    extents;
    PFILE_RECORD_SEGMENT_HEADER frs_header;
    PUCHAR              buffer;
    PUCHAR              frs;
    ULONG               sectors_per_frs, bytes_per_frs, bytes_per_cluster, i;
    ULONG               run_length;
    BIG_INT             start_sector; 
    BIG_INT             current_sector;
    BIG_INT             frs_number;
    BIG_INT             previous_frs_number;
    BIG_INT             largest_frs_number;
    BIG_INT             first_run_length;
    BIG_INT             mft_size;
    BIG_INT             rounded_value_length;
    BIG_INT             rounded_alloc_length;
    BIG_INT             rounded_valid_length;
    LCN                 start_lcn, first_lcn, mft_starting_lcn;
    VCN                 start_vcn, end_vcn, first_vcn;
    BOOLEAN             within_extent;


    if( !extents.Initialize( 0, 1 ) ) {
        return FALSE;
    }

    bytes_per_frs = QueryFrsSize();
    bytes_per_cluster = _drive->QuerySectorSize() * QueryClusterFactor();
    sectors_per_frs = bytes_per_frs / _drive->QuerySectorSize();
    largest_frs_number = 0;
    
    //
    // Ensure that the buffer is aligned on cluster and frs boundaries
    //
    DebugAssert( !(BLOCK_SIZE % QueryClusterFactor()) ); 
    DebugAssert( !(BLOCK_SIZE % sectors_per_frs) ); 
        
    start_sector = 0;
    if (!(buffer = (PUCHAR)MALLOC(BLOCK_SIZE * _drive->QuerySectorSize()))) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    within_extent = FALSE;
    frs = buffer;
    run_length = 0;
    current_sector = start_sector;

    while (start_sector < QueryVolumeSectors()) {
       
        frs = frs - (run_length * _drive->QuerySectorSize());

        DebugAssert( (frs >= buffer) && ((frs-buffer) == ((current_sector-start_sector).GetLowPart()*_drive->QuerySectorSize())) );

        if ((QueryVolumeSectors() - start_sector) < BLOCK_SIZE) {
            run_length = (QueryVolumeSectors() - start_sector).GetLowPart();
        } else {
            run_length = BLOCK_SIZE;
        }

        if (!_drive->Read(start_sector, run_length, buffer)) {
            DebugPrintTrace(("Read failure at start sector =  %I64x runlength = %x.\n", start_sector.GetLargeInteger(), run_length));
            return FALSE;

        }
        

        while ( current_sector < (start_sector + run_length) ) {



            frs_header = (PFILE_RECORD_SEGMENT_HEADER)frs;
            if (frs_header->MultiSectorHeader.Signature[0] == 'F' &&
                frs_header->MultiSectorHeader.Signature[1] == 'I' &&
                frs_header->MultiSectorHeader.Signature[2] == 'L' &&
                frs_header->MultiSectorHeader.Signature[3] == 'E' &&
                frs_header->MultiSectorHeader.UpdateSequenceArrayOffset >= FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER, UpdateArrayForCreateOnly)) {
                    
                previous_frs_number = frs_number;
                frs_number.Set(frs_header->SegmentNumberLowPart, frs_header->SegmentNumberHighPart);
                if (largest_frs_number < frs_number) {
                    largest_frs_number = frs_number;
                }

                if (within_extent) {
                    if ( frs_number == (previous_frs_number + 1) ) {
                        //
                        // continue the previous extent
                        //
                        end_vcn = (frs_number * sectors_per_frs + sectors_per_frs - 1)
                                        / QueryClusterFactor();
                    } else {
                        //
                        // The break in the continuity of the frs numbers indicates
                        // end of the previous extent and the possible beginning of 
                        // a new extent
                        //
                        if (!ValidateAndAddExtent(start_vcn, start_lcn, end_vcn - start_vcn +1, &extents)) {
                            FREE(buffer);
                            return FALSE;
                        }
                        within_extent = FALSE;
                        //
                        // Start a new extent.
                        //
                        // We have removed the constraint that a new extent must begin at a cluster 
                        // boundary since the first few frs' at the boundary may be corrupt
                        //
                        start_vcn = frs_number * sectors_per_frs / QueryClusterFactor(); 
                        start_lcn = current_sector / QueryClusterFactor();
                        end_vcn   = (frs_number * sectors_per_frs + sectors_per_frs - 1)
                                            / QueryClusterFactor();
                        within_extent = TRUE;

                    }


                } else {
                    //
                    // Start a new extent.
                    //
                    // We have removed the constraint that a new extent must begin at a cluster 
                    // boundary since the first few frs' at the boundary may be corrupt
                    start_vcn = frs_number * sectors_per_frs / QueryClusterFactor(); 
                    start_lcn = current_sector / QueryClusterFactor();
                    end_vcn   = (frs_number * sectors_per_frs + sectors_per_frs - 1)
                                            / QueryClusterFactor();
                    within_extent = TRUE;
    
                }

                // Advance counters by one frs
                current_sector += sectors_per_frs;
                frs +=  bytes_per_frs;


            } else {

                if(within_extent) {
                
                    //
                    // The break in the existence of the frs signatures and numbers indicates
                    // end of the extent
                    //
                    if (!ValidateAndAddExtent(start_vcn, start_lcn, end_vcn - start_vcn +1, &extents)){
                        FREE(buffer);
                        return FALSE;
                    }

                    within_extent = FALSE;

                }

                // Advance counters by one cluster or one frs depending on which is smaller
                if (bytes_per_frs < bytes_per_cluster) {
                    current_sector += sectors_per_frs;
                    frs +=  bytes_per_frs;
                } else {
                    current_sector += QueryClusterFactor();
                    frs +=  bytes_per_cluster;
                }
            }

        } // time to read in more data
        
        
        start_sector += run_length;

    }

    FREE(buffer);



    //
    // if there are any holes from frs 0 to frs 3 then fill them up.
    //
    end_vcn   = ((REFLECTED_MFT_SEGMENTS-1) * sectors_per_frs + sectors_per_frs - 1)
                    / QueryClusterFactor();

    i = 0;
    first_lcn = LCN_NOT_PRESENT;
    while (extents.QueryExtent(i, &first_vcn, &first_lcn, &first_run_length) && (first_lcn == LCN_NOT_PRESENT)) {
        i++;
    }

    if (first_lcn != LCN_NOT_PRESENT) {
        if (first_vcn <= end_vcn) {
            mft_starting_lcn = first_lcn - first_vcn;
            if ((mft_starting_lcn != QueryMftStartingLcn()) 
                    && (mft_starting_lcn != QueryMft2StartingLcn())){
                DebugPrint("Recovered Mft inconsistent with boot sector.\n");
                return FALSE;
            } 
        }
                
        if (!extents.DeleteRange(0, end_vcn + 1) ||
            !extents.AddExtent(0, QueryMftStartingLcn(), end_vcn + 1)) {
            DebugPrint("Failure to add extent corresponding to frs 0 - 3.\n");
            return FALSE;
        }


    
    } else {
        DebugPrint("Recovered Mft has no extents.\n");
        return FALSE;
    }


    if (extents.IsSparse()) {
        DebugPrint("Recovered Mft has holes.\n");
        return FALSE;
    }

    mft_size = (largest_frs_number + 1) * bytes_per_frs;
    
    if (!MftData->Initialize (_drive, QueryClusterFactor(), &extents, mft_size, mft_size, $DATA ) ||
        !MftData->VerifyAndFix(QueryVolumeSectors()) ||
        MftData->QueryValueLength() < FIRST_USER_FILE_NUMBER*bytes_per_frs ||
        MftData->QueryValidDataLength() < FIRST_USER_FILE_NUMBER*bytes_per_frs) {
        return FALSE;
    }

    // Truncate the MFT to be a whole number of file-records.

    rounded_alloc_length = MftData->QueryAllocatedLength()/bytes_per_frs*
                           bytes_per_frs;
    rounded_value_length = MftData->QueryValueLength()/bytes_per_frs*
                           bytes_per_frs;
    rounded_valid_length = MftData->QueryValidDataLength()/bytes_per_frs*
                           bytes_per_frs;

    if (MftData->QueryValidDataLength() != MftData->QueryValueLength()) {
        MftData->Resize(rounded_valid_length, NULL);
    } else if (rounded_value_length != MftData->QueryValueLength() ||
               rounded_alloc_length != MftData->QueryAllocatedLength()) {
        MftData->Resize(rounded_value_length, NULL);
    }

    return TRUE;

}


BOOLEAN
NTFS_SA::ValidateAndAddExtent(
    IN VCN      Vcn,
    IN LCN      Lcn,
    IN BIG_INT  RunLength,
    IN OUT PNTFS_EXTENT_LIST Extents

    )
/*++

Routine Description:

    This method adds an extent, specified by its Virtual Cluster Number,
    Logical Cluster Number, and Run Length, to the extent list Extents.

    In case there is an overlap, this method also performs the necessary 
    validations on the overlapping portion and selects the appropriate
    Lcn

Arguments:

    Vcn         --  Supplies the starting VCN of the extent.
    Lcn         --  Supplies the starting LCN of the extent.
    RunLength   --  Supplies the number of clusters in the extent.
    Extents     --  Supplies the extent list to which the extent is to be added

Return Value:

    TRUE upon successful completion.
    FALSE if the routine cannot guarantee the integrity of the MFT after this

--*/
{
    LCN                 existing_lcn;
    LCN                 mft_starting_lcn;
    VCN                 end_vcn;
    BIG_INT             existing_run_length;
    BOOLEAN             success;
    PFILE_RECORD_SEGMENT_HEADER frs_header;
    PUCHAR              buffer;
    int                 frs_offset;
    ULONG               bytes_per_frs;
    BIG_INT             sectors_per_frs;
    BIG_INT             frs_number;
    BIG_INT             expected_frs_number;
    BIG_INT             overlap_length;
    int                 valid_frs_count;
    int                 existing_valid_frs_count;
    int                 buffer_size;

    

    success = FALSE;

    if (Extents->QueryLcnFromVcn(Vcn, &existing_lcn, &existing_run_length)) {

        if (existing_lcn == LCN_NOT_PRESENT) {
            //
            // There is definitely no overlap from Vcn to Vcn + existing_run_length
            // 

            if (RunLength <= existing_run_length) {
                success = Extents->AddExtent(Vcn, Lcn, RunLength);
            } else {
                success = Extents->AddExtent(Vcn, Lcn, existing_run_length) 
                            && ValidateAndAddExtent(Vcn+existing_run_length, Lcn+existing_run_length, RunLength - existing_run_length, Extents);
            }
        } else {

            overlap_length = min(existing_run_length, RunLength);

            //
            // There is definitely an overlap from Vcn to Vcn + overlap_length
            // 
            if (Lcn == existing_lcn) {
                //
                // Mappings are identical and we have no conflict
                success = TRUE;
            } else {
                //
                // We have a conflict 
                //
                

                // 
                // frs 0 to frs 3 exist at 2 places on the disk: MFT and MFT mirror
                // this code attempts to identify and insert the correct extent 
                // even if only part of the extent exists
                //
                sectors_per_frs = QueryFrsSize() / _drive->QuerySectorSize();
                end_vcn   = ((REFLECTED_MFT_SEGMENTS-1) * sectors_per_frs + sectors_per_frs - 1)
                                / QueryClusterFactor();

                if (Vcn <= end_vcn) {
                    if ((Vcn+overlap_length-1) > end_vcn) {
                        //
                        // The overlap length extends beyond the 4 mirrored MFT segments
                        // which indicates that we cannot guarantee the integrity of the 
                        // MFT extents
                        //
                        success = FALSE;
                    } else {
                        mft_starting_lcn = Lcn - Vcn;
                        // 
                        // Note: We completely trust the boot sector during this process.
                        // So if the MFT start in the boot has been corrupted, it is possible 
                        // that we will reject the correct frs 0.
                        //
                        if (mft_starting_lcn == QueryMftStartingLcn()) {
                            // This is the correct extent frs 0 to frs 3 extent
                            success = Extents->DeleteRange(0, end_vcn + 1) 
                                        && Extents->AddExtent(0, QueryMftStartingLcn(), end_vcn + 1);
                        } else if (mft_starting_lcn == QueryMft2StartingLcn()) {
                            // This is extent frs 0 to frs 3 extent of the MFT Mirror               
                            success = TRUE;
                        } else {
                            // This is a spurious frs 0 to frs 3 extent
                            DebugPrintTrace(("UNTFS: VCN 0 conflict at LCN %I64x.\n", mft_starting_lcn.GetLargeInteger()));
                            success = FALSE;
                        } 
                        
                    }

                } else if (overlap_length == 1) {
                    //
                    // This can be caused because we consider extents that may not start at a cluster 
                    // boundary due to a corrupt frs at the start of a cluster
                    // 

                    valid_frs_count = 0;
                    existing_valid_frs_count = 0;

                    bytes_per_frs = QueryFrsSize();
                    buffer_size = QueryClusterFactor() * _drive->QuerySectorSize();
                    if (!(buffer = (PUCHAR)MALLOC(buffer_size))) {
                        return FALSE;
                    }
                    
                    
                    expected_frs_number = Vcn * buffer_size / bytes_per_frs;
                    _drive->Read(Lcn*QueryClusterFactor(), QueryClusterFactor(), buffer);
                    
                    frs_offset = 0 ;
                    while ( frs_offset < buffer_size ) {

                        frs_header = (PFILE_RECORD_SEGMENT_HEADER)(buffer+frs_offset);
                        if (frs_header->MultiSectorHeader.Signature[0] == 'F' &&
                            frs_header->MultiSectorHeader.Signature[1] == 'I' &&
                            frs_header->MultiSectorHeader.Signature[2] == 'L' &&
                            frs_header->MultiSectorHeader.Signature[3] == 'E' &&
                            frs_header->MultiSectorHeader.UpdateSequenceArrayOffset >= FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER, UpdateArrayForCreateOnly)) {
                    
                            frs_number.Set(frs_header->SegmentNumberLowPart, frs_header->SegmentNumberHighPart);
                            if (expected_frs_number == frs_number) {
                                valid_frs_count += 1 ;
                            }
                        }

                        frs_offset +=  bytes_per_frs;
                        expected_frs_number += 1;
                    }
        

                    expected_frs_number = Vcn * buffer_size / bytes_per_frs;
                    _drive->Read(existing_lcn*QueryClusterFactor(), QueryClusterFactor(), buffer);
                    
                    frs_offset = 0;
                    while ( frs_offset < buffer_size ) {

                        frs_header = (PFILE_RECORD_SEGMENT_HEADER)(buffer+frs_offset);
                        if (frs_header->MultiSectorHeader.Signature[0] == 'F' &&
                            frs_header->MultiSectorHeader.Signature[1] == 'I' &&
                            frs_header->MultiSectorHeader.Signature[2] == 'L' &&
                            frs_header->MultiSectorHeader.Signature[3] == 'E' &&
                            frs_header->MultiSectorHeader.UpdateSequenceArrayOffset >= FIELD_OFFSET(FILE_RECORD_SEGMENT_HEADER, UpdateArrayForCreateOnly)) {
                    
                            frs_number.Set(frs_header->SegmentNumberLowPart, frs_header->SegmentNumberHighPart);
                            if (expected_frs_number == frs_number) {
                                existing_valid_frs_count += 1 ;
                            }
                        }

                        frs_offset +=  bytes_per_frs;
                        expected_frs_number += 1;
                    }

                    FREE(buffer);

                    if (valid_frs_count > existing_valid_frs_count) {
                        success = Extents->DeleteRange(Vcn, overlap_length) 
                                    && Extents->AddExtent(Vcn, Lcn, overlap_length); 
                    } else {
                        success = TRUE;
                    }

                } else {
                    //
                    // Overlap is more than 1 clster and it it not due to the MFT Mirror
                    //
                    // We do not allow cases in which the overlap is more than 1 cluster 
                    // because then there is no way for us to identify the correct frs run
                    // without doubt
                    //
                    DebugPrintTrace(("UNTFS: VCN %I64x conflict at LCN %I64x and %I64x.\n", Vcn.GetLargeInteger(), Lcn.GetLargeInteger(), existing_lcn.GetLargeInteger()));
                    success = FALSE;
                }

            }
            
            if (success && (RunLength > existing_run_length)) {
                success = ValidateAndAddExtent(Vcn+existing_run_length, Lcn+existing_run_length, RunLength - existing_run_length, Extents);
            }
        }

    } else {
        success = Extents->AddExtent(Vcn, Lcn, RunLength);
        if(!success) {
            DebugPrintTrace(("UNTFS: Failure to add extent (vcn, lcn, runlength) : (%I64x, %I64x, %I64x).\n", Vcn.GetLargeInteger(), Lcn.GetLargeInteger(), RunLength.GetLargeInteger()));
        }
    }
    

    return success;
}



BOOLEAN
NTFS_SA::QueryDefaultAttributeDefinitionTable(
    OUT     PNTFS_ATTRIBUTE_COLUMNS AttributeDefinitionTable,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine computes the default attribute definition table as put
    down by format.

Arguments:

    AttributeDefinitionTable    - Returns the default attribute definition
                                    table.
    Message                     - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    UCHAR   major, minor;

    QueryVersionNumber(&major, &minor);

    if (!AttributeDefinitionTable->Initialize(
            (major >= 2) ?
                NumberOfNtfsAttributeDefinitions_2 :
                NumberOfNtfsAttributeDefinitions_1,
            (major >= 2) ?
                NtfsAttributeDefinitions_2 :
                NtfsAttributeDefinitions_1)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::FetchAttributeDefinitionTable(
    IN OUT  PNTFS_ATTRIBUTE         MftData,
    IN OUT  PMESSAGE                Message,
    OUT     PNTFS_ATTRIBUTE_COLUMNS AttributeDefinitionTable
    )
/*++

Routine Description:

    This routine weeds through the minimal necessary NTFS disk structures
    in order to establish an attribute definition table.  This function
    should return the attribute definition table supplied by FORMAT if it
    is unable to retrieve one from disk.

Arguments:

    MftData                     - Supplies the extent list for the MFT's
                                    $DATA attribute.
    Message                     - Supplies an outlet for messages.
    AttributeDefinitionTable    - Returns the volume's attribute definition
                                    table.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return QueryDefaultAttributeDefinitionTable(AttributeDefinitionTable,
                                                Message);

// Comment out this block for future revisions of CHKDSK that will read
// the attribute definition table from the disk.  Version 1.0 and 1.1
// of chkdsk will just get the attribute definition table that FORMAT
// lays out.

#if 0
    NTFS_FRS_STRUCTURE      frs;
    HMEM                    hmem;
    NTFS_ATTRIBUTE          attr_def_table;
    ULONG                   num_columns;
    BIG_INT                 value_length;

    // Initialize an FRS for the attribute definition table file's
    // FRS.  Note that we won't manipulate any named attributes, so
    // we can pass in NULL for the upcase table.

    if (!hmem.Initialize() ||
        !frs.Initialize(&hmem, MftData, ATTRIBUTE_DEF_TABLE_NUMBER,
                        QueryClusterFactor(), QueryFrsSize(),
                        QueryVolumeSectors(), NULL)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!frs.Read()) {

        Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_DEF_TABLE);

        return QueryDefaultAttributeDefinitionTable(AttributeDefinitionTable,
                                                    Message);
    }

    if (!frs.SafeQueryAttribute($DATA, MftData, &attr_def_table)) {

        Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_DEF_TABLE);

        return QueryDefaultAttributeDefinitionTable(AttributeDefinitionTable,
                                                    Message);
    }

    attr_def_table.QueryValueLength(&value_length);

    num_columns = (value_length/sizeof(ATTRIBUTE_DEFINITION_COLUMNS)).GetLowPart();

    if (value_length%sizeof(ATTRIBUTE_DEFINITION_COLUMNS) != 0) {

        Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_DEF_TABLE_LENGTH_NOT_IN_MULTIPLES_OF_ATTR_DEF_COLUMNS,
                     "%I64x%x",
                     value_length.GetLargeInteger(),
                     sizeof(ATTRIBUTE_DEFINITION_COLUMNS));

        Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_DEF_TABLE);

        return QueryDefaultAttributeDefinitionTable(AttributeDefinitionTable,
                                                    Message);
    }

    if (!AttributeDefinitionTable->Initialize(num_columns)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!AttributeDefinitionTable->Read(&attr_def_table) ||
        !AttributeDefinitionTable->Verify()) {

        Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_DEF_TABLE);

        return QueryDefaultAttributeDefinitionTable(AttributeDefinitionTable,
                                                    Message);
    }

    return TRUE;
#endif
}


BOOLEAN
NTFS_SA::FetchUpcaseTable(
    IN OUT  PNTFS_ATTRIBUTE         MftData,
    IN OUT  PMESSAGE                Message,
    OUT     PNTFS_UPCASE_TABLE      UpcaseTable
    )
/*++

Routine Description:

    This routine safely fetches the NTFS upcase table.  It none is
    available on disk then this routine gets the one from the
    operating system.

Arguments:

    MftData     - Supplies the MFT's data attribute.
    Message     - Supplies an outlet for messages.
    UpcaseTable - Returns the upcase table.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // For product 1, always use the system's upcase table.  If this upcase
    // table differs from the upcase table on disk then it will be written
    // to disk at the end of CHKDSK.  CHKDSK will resort indices as
    // needed to reflect any upcase table changes.

    if (!UpcaseTable->Initialize()) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_GET_UPCASE_TABLE);
        return FALSE;
    }

    return TRUE;


#if 0
    NTFS_FRS_STRUCTURE      frs;
    HMEM                    hmem;
    NTFS_ATTRIBUTE          upcase_table;

    // Initialize an FRS for the upcase table file's
    // FRS.  Note that we won't manipulate any named attributes, so
    // we can pass in NULL for the upcase table.

    if (!hmem.Initialize() ||
        !frs.Initialize(&hmem, MftData, UPCASE_TABLE_NUMBER,
                        QueryClusterFactor(), QueryFrsSize(),
                        QueryVolumeSectors(), NULL)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!frs.Read() ||
        !frs.SafeQueryAttribute($DATA, MftData, &upcase_table) ||
        !UpcaseTable->Initialize(&upcase_table) ||
        !UpcaseTable->Verify()) {

        Message->DisplayMsg(MSG_CHK_NTFS_BAD_UPCASE_TABLE);

        if (!UpcaseTable->Initialize()) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_GET_UPCASE_TABLE);
            return FALSE;
        }
    }

    return TRUE;
#endif
}


BOOLEAN
NTFS_SA::VerifyAndFixMultiFrsFile(
    IN OUT  PNTFS_FRS_STRUCTURE         BaseFrs,
    IN OUT  PNTFS_ATTRIBUTE_LIST        AttributeList,
    IN      PNTFS_ATTRIBUTE             MftData,
    IN      PCNTFS_ATTRIBUTE_COLUMNS    AttributeDefTable,
    IN OUT  PNTFS_BITMAP                VolumeBitmap,
    IN OUT  PNTFS_BITMAP                MftBitmap,
    IN OUT  PNTFS_CHKDSK_REPORT         ChkdskReport,
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine verifies, and if necessary fixes, a multi-FRS file.

Arguments:

    BaseFrs             - Supplies the base FRS of the file to validate.
    AttributeList       - Supplies the attribute list of the file to
                            validate.
    MftData             - Supplies the MFT's $DATA attribute.
    AttributeDefTable   - Supplies the attribute definition table.
    VolumeBitmap        - Supplies the volume bitmap.
    MftBitmap           - Supplies the MFT bitmap.
    ChkdskReport        - Supplies the current chkdsk report.
    FixLevel            - Supplies the fix level.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not there have been any
                            disk errors found so far.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NUMBER_SET          child_file_numbers;
    PHMEM*              child_frs_hmem;
    LIST                child_frs_list;
    PITERATOR           iter;
    PNTFS_FRS_STRUCTURE pfrs;
    ULONG               num_child_frs, i;
    BOOLEAN             changes;
    BOOLEAN             need_write;
    ULONG               errFixedStatus = CHKDSK_EXIT_SUCCESS;

    DebugAssert(BaseFrs);
    DebugAssert(AttributeList);
    DebugAssert(MftData);
    DebugAssert(AttributeDefTable);
    DebugAssert(VolumeBitmap);
    DebugAssert(MftBitmap);
    DebugAssert(Message);


    // First get a list of the child FRSs pointed to by the
    // attribube list.

    if (!QueryListOfFrs(BaseFrs, AttributeList, MftData,
                        &child_file_numbers, Message)) {

        return FALSE;
    }


    // Create some HMEMs for the FRS structures.

    num_child_frs = child_file_numbers.QueryCardinality().GetLowPart();

    if (!(child_frs_hmem = NEW PHMEM[num_child_frs])) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }
    memset(child_frs_hmem, 0, num_child_frs*sizeof(PHMEM));


    // Read in all of the child FRS.

    if (!child_frs_list.Initialize() ||
        !VerifyAndFixChildFrs(&child_file_numbers, MftData, AttributeDefTable,
                              BaseFrs->GetUpcaseTable(),
                              child_frs_hmem, &child_frs_list, FixLevel,
                              Message, DiskErrorsFound)) {

        for (i = 0; i < num_child_frs; i++) {
            DELETE(child_frs_hmem[i]);
        }
        DELETE_ARRAY(child_frs_hmem);
        child_frs_list.DeleteAllMembers();
        return FALSE;
    }

    // At this point we have a list of child FRSs that are all readable.
    // This list contains all of the possible children for the parent
    // but are not all necessarily valid children.


    // Now go through the attribute list and make sure that all of the
    // entries in the list correspond to correct attribute records.
    // Additionally, make sure that multi-record attributes are well-linked
    // and that there are no cross-links.

    if (!EnsureWellDefinedAttrList(BaseFrs, AttributeList, &child_frs_list,
                                   VolumeBitmap, ChkdskReport, ChkdskInfo,
                                   FixLevel, Message, DiskErrorsFound)) {

        for (i = 0; i < num_child_frs; i++) {
            DELETE(child_frs_hmem[i]);
        }
        DELETE_ARRAY(child_frs_hmem);
        child_frs_list.DeleteAllMembers();
        return FALSE;
    }


    // Next, we go through all of the attribute records in all of the
    // FRS and make sure that they have a corresponding attribute list
    // entry.

    if (!EnsureSurjectiveAttrList(BaseFrs, AttributeList, &child_frs_list,
                                  FixLevel, Message, DiskErrorsFound)) {

        for (i = 0; i < num_child_frs; i++) {
            DELETE(child_frs_hmem[i]);
        }
        DELETE_ARRAY(child_frs_hmem);
        child_frs_list.DeleteAllMembers();
        return FALSE;
    }

    // Mark all of the child FRS in the MFT bitmap.

    if (!(iter = child_frs_list.QueryIterator())) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);

        for (i = 0; i < num_child_frs; i++) {
            DELETE(child_frs_hmem[i]);
        }
        DELETE_ARRAY(child_frs_hmem);
        child_frs_list.DeleteAllMembers();
        return FALSE;
    }

    while (pfrs = (PNTFS_FRS_STRUCTURE) iter->GetNext()) {
        MftBitmap->SetAllocated(pfrs->QueryFileNumber().GetLowPart(), 1);
    }

    // Check the instance tags on the attribute records in the base
    // frs and in each child frs.

    need_write = FALSE;

    if (!BaseFrs->CheckInstanceTags(FixLevel,
                                    ChkdskInfo->Verbose,
                                    Message,
                                    &changes,
                                    AttributeList)) {
        DELETE(iter);
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);

        for (i = 0; i < num_child_frs; i++) {
            DELETE(child_frs_hmem[i]);
        }
        DELETE_ARRAY(child_frs_hmem);
        child_frs_list.DeleteAllMembers();
        return FALSE;
    }

    need_write |= changes;

    iter->Reset();

    while (pfrs = (PNTFS_FRS_STRUCTURE)iter->GetNext()) {
        if (!pfrs->CheckInstanceTags(FixLevel,
                                     ChkdskInfo->Verbose,
                                     Message,
                                     &changes,
                                     AttributeList)) {
            break;
        }

        need_write |= changes;
    }

    DELETE(iter);

    if (need_write) {
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        if (FixLevel != CheckOnly) {
            AttributeList->WriteList(NULL);
        }
    }

    for (i = 0; i < num_child_frs; i++) {
        DELETE(child_frs_hmem[i]);
    }
    DELETE_ARRAY(child_frs_hmem);
    child_frs_list.DeleteAllMembers();

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}


BOOLEAN
NTFS_SA::QueryListOfFrs(
    IN      PCNTFS_FRS_STRUCTURE    BaseFrs,
    IN      PCNTFS_ATTRIBUTE_LIST   AttributeList,
    IN OUT  PNTFS_ATTRIBUTE         MftData,
    OUT     PNUMBER_SET             ChildFileNumbers,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine computes all of the child file numbers pointed to by
    the given attribute list which is contained in the given FRS.

Arguments:

    BaseFrs             - Supplies the base FRS.
    AttributeList       - Supplies the attribute list for the base FRS.
    MftData             - Supplies the Mft's data attribute.
    ChildFileNumbers    - Return a list of child FRS numbers.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    HMEM                        hmem;
    NTFS_FRS_STRUCTURE          child_frs;
    ATTRIBUTE_TYPE_CODE         attr_code;
    VCN                         lowest_vcn;
    MFT_SEGMENT_REFERENCE       seg_ref;
    DSTRING                     attr_name;
    VCN                         file_number;
    USHORT                      instance;
    ATTR_LIST_CURR_ENTRY        entry;

    DebugAssert(BaseFrs);
    DebugAssert(AttributeList);
    DebugAssert(ChildFileNumbers);
    DebugAssert(Message);

    if (!ChildFileNumbers->Initialize()) {
        return FALSE;
    }

    entry.CurrentEntry = NULL;
    while (AttributeList->QueryNextEntry(&entry,
                                         &attr_code,
                                         &lowest_vcn,
                                         &seg_ref,
                                         &instance,
                                         &attr_name)) {

        file_number.Set(seg_ref.LowPart, (ULONG) seg_ref.HighPart);

        if (file_number != BaseFrs->QueryFileNumber()) {
            if (!ChildFileNumbers->DoesIntersectSet(file_number, 1)) {

                if (!hmem.Initialize() ||
                    !child_frs.Initialize(&hmem, MftData, file_number,
                                          QueryClusterFactor(),
                                          QueryVolumeSectors(),
                                          QueryFrsSize(),
                                          NULL)) {

                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }


                // Only add this FRS to the list of child FRS's
                // if it is readable and points back to the base.

                if (child_frs.Read() &&
                    child_frs.QueryBaseFileRecordSegment() ==
                    BaseFrs->QuerySegmentReference()) {

                    if (!ChildFileNumbers->Add(file_number)) {

                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }
                }
            }
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::VerifyAndFixChildFrs(
    IN      PCNUMBER_SET                ChildFileNumbers,
    IN      PNTFS_ATTRIBUTE             MftData,
    IN      PCNTFS_ATTRIBUTE_COLUMNS    AttributeDefTable,
    IN      PNTFS_UPCASE_TABLE          UpcaseTable,
    OUT     PHMEM*                      ChildFrsHmemList,
    IN OUT  PCONTAINER                  ChildFrsList,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message,
    IN OUT  PBOOLEAN                    DiskErrorsFound
    )
/*++

Routine Description:

    This routine reads in all of the child FRS listed in 'ChildFileNumbers'
    and returns the readable ones into the 'ChildFrsList'.  These FRS will
    be initialized with the HMEM provided in 'ChildFrsHmemList'.

    Then this routine verifies all of these FRS.  Any FRS that are not
    good will not be returned in the list.

Arguments:

    ChildFileNumbers    - Supplies the file numbers of the child FRS.
    MftData             - Supplies the MFT data attribute.
    AttributeDefTable   - Supplies the attribute definition table.
    UpcaseTable         - Supplies the volume upcase table.
    ChildFrsHmemList    - Returns the HMEM for the FRS structures.
    ChildFrsList        - Returns a list of FRS structures corresponding
                            to the readable FRS found in the given list.
    Message             - Supplies an outlet for messages.
    DiskErrorsFound     - Supplies whether or not disk errors have been
                            found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ULONG               i;
    ULONG               num_child_frs;
    PNTFS_FRS_STRUCTURE frs;

    num_child_frs = ChildFileNumbers->QueryCardinality().GetLowPart();

    for (i = 0; i < num_child_frs; i++) {

        frs = NULL;

        if (!(ChildFrsHmemList[i] = NEW HMEM) ||
            !ChildFrsHmemList[i]->Initialize() ||
            !(frs = NEW NTFS_FRS_STRUCTURE) ||
            !frs->Initialize(ChildFrsHmemList[i],
                             MftData,
                             ChildFileNumbers->QueryNumber(i),
                             QueryClusterFactor(),
                             QueryVolumeSectors(),
                             QueryFrsSize(),
                             UpcaseTable)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            DELETE(frs);
            return FALSE;
        }

        if (!frs->Read()) {
            DELETE(frs);
            continue;
        }

        if (!frs->IsInUse()) {
            DELETE(frs);
            continue;
        }

        if (!frs->VerifyAndFix(FixLevel, Message, AttributeDefTable,
                               DiskErrorsFound)) {
            DELETE(frs);
            return FALSE;
        }

        if (!frs->IsInUse()) {
            DELETE(frs);
            continue;
        }


        // Compare the LSN of this FRS with the current largest LSN.

        if (frs->QueryLsn() > LargestLsnEncountered) {
            LargestLsnEncountered = frs->QueryLsn();
        }

        if (!ChildFrsList->Put(frs)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            DELETE(frs);
            return FALSE;
        }
    }

    return TRUE;
}


VOID
DeleteAllAttributes(
    IN  PSEQUENTIAL_CONTAINER   AllAttributes
    )
{
    PITERATOR               alliter;
    PSEQUENTIAL_CONTAINER   attribute;

    if (!(alliter = AllAttributes->QueryIterator())) {
        return;
    }

    while (attribute = (PSEQUENTIAL_CONTAINER) alliter->GetNext()) {
        attribute->DeleteAllMembers();
    }
    DELETE(alliter);

    AllAttributes->DeleteAllMembers();
}


BOOLEAN
NTFS_SA::EnsureWellDefinedAttrList(
    IN      PNTFS_FRS_STRUCTURE     BaseFrs,
    IN OUT  PNTFS_ATTRIBUTE_LIST    AttributeList,
    IN      PCSEQUENTIAL_CONTAINER  ChildFrsList,
    IN OUT  PNTFS_BITMAP            VolumeBitmap,
    IN OUT  PNTFS_CHKDSK_REPORT     ChkdskReport,
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message,
    IN OUT  PBOOLEAN                DiskErrorsFound
    )
/*++

Routine Desciption:

    This routine makes sure that every entry in the attribute list
    points to an FRS with the same segment reference and that the
    attribute record refered to in the entry actually exists in the
    FRS.  Invalid attribute list entries will be deleted.

Arguments:

    BaseFrs         - Supplies the base file record segment.
    AttributeList   - Supplies the attribute list.
    ChildFrsList    - Supplies a list of all of the child FRS.
    VolumeBitmap    - Supplies a volume bitmap.
    ChkdskReport    - Supplies the current chkdsk report.
    FixLevel        - Supplies the fix up level.
    Message         - Supplies an outlet for messages.
    DiskErrorsFound - Supplies whether or not disk errors have been
                        found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    ATTR_LIST_CURR_ENTRY        entry;
    BOOLEAN                     changes;
    PITERATOR                   child_frs_iter;
    PITERATOR                   attribute_iter;
    ATTRIBUTE_TYPE_CODE         attr_code;
    VCN                         lowest_vcn;
    MFT_SEGMENT_REFERENCE       seg_ref;
    MFT_SEGMENT_REFERENCE       base_ref;
    DSTRING                     attr_name, attr_name2;
    PNTFS_FRS_STRUCTURE         frs;
    PVOID                       precord;
    NTFS_ATTRIBUTE_RECORD       attr_record;
    PLIST                       attribute;
    PNTFS_ATTRIBUTE_RECORD      pattr_record;
    BOOLEAN                     errors_found;
    LIST                        all_attributes;
    BOOLEAN                     user_file;
    NTFS_CHKDSK_REPORT          dummy_report;
    USHORT                      instance;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;


    if (!(child_frs_iter = ChildFrsList->QueryIterator())) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!(attribute = NEW LIST) ||
        !attribute->Initialize() ||
        !all_attributes.Initialize()) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }


    // Go through each attribute entry and make sure it's right.
    // If it isn't right then delete it.  Otherwise, check for
    // cross-links and consistency between multi-record attributes.

    changes = FALSE;
    base_ref = BaseFrs->QuerySegmentReference();
    user_file = FALSE;


    entry.CurrentEntry = NULL;
    while (AttributeList->QueryNextEntry(&entry,
                                         &attr_code,
                                         &lowest_vcn,
                                         &seg_ref,
                                         &instance,
                                         &attr_name)) {

        if (attr_code == $DATA ||
            attr_code == $EA_DATA ||
            ((ChkdskInfo->major >= 2) ?
                (attr_code >= $FIRST_USER_DEFINED_ATTRIBUTE_2) :
                (attr_code >= $FIRST_USER_DEFINED_ATTRIBUTE_1)) ) {

            VCN FileNumber = BaseFrs->QueryFileNumber();

            if (FileNumber >= FIRST_USER_FILE_NUMBER) {
                user_file = TRUE;
            }
        }


        // First find which frs this refers to.

        if (seg_ref == base_ref) {

            frs = BaseFrs;

        } else {

            child_frs_iter->Reset();
            while (frs = (PNTFS_FRS_STRUCTURE) child_frs_iter->GetNext()) {

                if (frs->QuerySegmentReference() == seg_ref &&
                    frs->QueryBaseFileRecordSegment() == base_ref) {
                    break;
                }
            }
        }


        // If the frs is present then look for the record.

        if (frs) {

            // Try to locate the exact attribute record.

            precord = NULL;
            while (precord = frs->GetNextAttributeRecord(precord)) {

                if (!attr_record.Initialize(GetDrive(), precord)) {
                    DebugAbort("Couldn't initialize an attribute record.");
                    return FALSE;
                }

                if (attr_record.QueryTypeCode() == attr_code &&
                    attr_record.QueryLowestVcn() == lowest_vcn &&
                    attr_record.QueryInstanceTag() == instance) {

                    if (!attr_record.QueryName(&attr_name2)) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        DELETE(child_frs_iter);
                        return FALSE;
                    }

                    if (!attr_name.Strcmp(&attr_name2)) {
                        break;
                    }
                }
            }

        } else {
            precord = NULL;
        }


        // If we have not found a match then delete the entry.
        // Also, there should be no entries in the attribute list
        // for the attribute list entry itself.  If there is
        // then remove is without hurting anything.

        if (!precord || attr_code == $ATTRIBUTE_LIST) {

            Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_LIST_ENTRY,
                                "%d%d", attr_code,
                                BaseFrs->QueryFileNumber().GetLowPart());

            if (frs == NULL) {

                BIG_INT     file_number;

                file_number.Set(seg_ref.LowPart, seg_ref.HighPart);

                Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_LOCATE_CHILD_FRS,
                             "%I64x%x",
                             file_number.GetLargeInteger(),
                             seg_ref.SequenceNumber);

                DebugPrintTrace(("UNTFS: Unable to find child frs 0x%I64x with sequence number 0x%x\n",
                                 file_number.GetLargeInteger(), seg_ref.SequenceNumber));

            } else if (!precord) {

                Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_LOCATE_ATTR_IN_ATTR_LIST,
                             "%x%I64x%x%I64x",
                             attr_code,
                             lowest_vcn.GetLargeInteger(),
                             instance,
                             frs->QueryFileNumber().GetLargeInteger());

                DebugPrintTrace(("UNTFS: Could not locate attribute of type code 0x%x,\n"
                                 "Lowest Vcn 0x%I64x, and Instance number 0x%x in frs 0x%I64x\n",
                                 attr_code,
                                 lowest_vcn.GetLargeInteger(),
                                 instance,
                                 frs->QueryFileNumber().GetLargeInteger()));
            } else {

                Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_LIST_WITHIN_ATTR_LIST,
                             "%I64x", frs->QueryFileNumber().GetLargeInteger());
            }

            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            AttributeList->DeleteCurrentEntry(&entry);

            attribute->DeleteAllMembers();
            DeleteAllAttributes(&all_attributes);

            if (!attribute->Initialize() ||
                !all_attributes.Initialize()) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);

                DELETE(child_frs_iter);
                DELETE(attribute);
                return FALSE;
            }

            changes = TRUE;
            entry.CurrentEntry = NULL;
            user_file = FALSE;

            continue;
        }


        // If the lowest vcn of this one is zero then package up the
        // previous attribute and start a new container for the
        // next attribute.

        if (attr_record.QueryLowestVcn() == 0 &&
            attribute->QueryMemberCount()) {

            if (!all_attributes.Put(attribute) ||
                !(attribute = NEW LIST) ||
                !attribute->Initialize()) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);

                DELETE(child_frs_iter);
                attribute->DeleteAllMembers();
                DELETE(attribute);
                DeleteAllAttributes(&all_attributes);
                return FALSE;
            }
        }

        if (!(pattr_record = NEW NTFS_ATTRIBUTE_RECORD) ||
            !pattr_record->Initialize(GetDrive(), precord) ||
            !attribute->Put(pattr_record)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);

            DELETE(child_frs_iter);
            DELETE(pattr_record);
            attribute->DeleteAllMembers();
            DELETE(attribute);
            DeleteAllAttributes(&all_attributes);
            return FALSE;
        }

    }

    DELETE(child_frs_iter);

    if (attribute->QueryMemberCount() &&
        !all_attributes.Put(attribute)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);

        attribute->DeleteAllMembers();
        DELETE(attribute);
        DeleteAllAttributes(&all_attributes);
        return FALSE;
    }
    attribute = NULL;

    if (user_file) {
        ChkdskReport->NumUserFiles += 1;
    }


    // Now go through all of the attributes in 'all_attributes' and
    // make sure that every attribute is well-defined and that there
    // are no cross-links.

    if (!(attribute_iter = all_attributes.QueryIterator())) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);

        DeleteAllAttributes(&all_attributes);
        return FALSE;
    }


    while (attribute = (PLIST) attribute_iter->GetNext()) {

        if (!VerifyAndFixAttribute(attribute, AttributeList,
                                   VolumeBitmap, BaseFrs, &errors_found,
                                   user_file ? ChkdskReport : &dummy_report,
                                   ChkdskInfo, Message)) {

            DeleteAllAttributes(&all_attributes);
            DELETE(attribute_iter);
            return FALSE;
        }

        changes = (BOOLEAN) (changes || errors_found);
    }
    DELETE(attribute_iter);

    if (changes && DiskErrorsFound) {
        *DiskErrorsFound = TRUE;
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    if (changes &&
        FixLevel != CheckOnly &&
        !AttributeList->WriteList(VolumeBitmap)) {
        Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                            "%d", BaseFrs->QueryFileNumber().GetLowPart());
        return FALSE;
    }


    DeleteAllAttributes(&all_attributes);

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}


BOOLEAN
NTFS_SA::VerifyAndFixAttribute(
    IN      PCLIST                  Attribute,
    IN OUT  PNTFS_ATTRIBUTE_LIST    AttributeList,
    IN OUT  PNTFS_BITMAP            VolumeBitmap,
    IN      PCNTFS_FRS_STRUCTURE    BaseFrs,
    OUT     PBOOLEAN                ErrorsFound,
    IN OUT  PNTFS_CHKDSK_REPORT     ChkdskReport,
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine verifies a list of attribute records as an attribute.

Arguments:

    Attribute       - Supplies the attribute as a list of attribute
                        records.
    AttributeList   - Supplies the attribute list.
    VolumeBitmap    - Supplies the volume bitmap.
    BaseFrs         - Supplies the base FRS.
    ErrorsFound     - Returns whether or not error were found.
    ChkdskReport    - Supplies the current chkdsk report.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    This thing is speced to take a list because it depends on the
    attribute records to be in the order that they were in the
    attribute list.

--*/
{
    PITERATOR               iter;
    PNTFS_ATTRIBUTE_RECORD  attr_record;
    DSTRING                 name;
    PNTFS_ATTRIBUTE_RECORD  first_record;
    PNTFS_ATTRIBUTE_RECORD  last_record;
    DSTRING                 first_record_name;
    DSTRING                 record_name;
    BIG_INT                 value_length;
    BIG_INT                 alloc_length;
    BIG_INT                 cluster_count;
    BIG_INT                 total_clusters = 0;
    BIG_INT                 total_allocated;
    BOOLEAN                 got_allow_cross_link;
    ULONG                   errFixedStatus = CHKDSK_EXIT_SUCCESS;
    BOOLEAN                 unuse_clusters;

    if (!(iter = Attribute->QueryIterator())) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    *ErrorsFound = FALSE;

    if (!(first_record = (PNTFS_ATTRIBUTE_RECORD) iter->GetNext())) {
        DebugAbort("Attribute has no attribute records");
        return FALSE;
    }

    if (first_record->QueryLowestVcn() != 0) {

        *ErrorsFound = TRUE;

        Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_LOWEST_VCN_IS_NOT_ZERO,
                     "%x%I64x%x%I64x",
                     first_record->QueryTypeCode(),
                     first_record->QueryLowestVcn().GetLargeInteger(),
                     first_record->QueryInstanceTag(),
                     BaseFrs->QueryFileNumber().GetLargeInteger());
    }

    got_allow_cross_link = FALSE;

    if (!first_record->IsResident() &&
        !first_record->UseClusters(VolumeBitmap,
                                   &cluster_count, ChkdskInfo->CrossLinkStart,
                                   ChkdskInfo->CrossLinkYet ? 0 :
                                       ChkdskInfo->CrossLinkLength,
                                   &got_allow_cross_link)) {
        *ErrorsFound = TRUE;

        Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_CLUSTERS_IN_USE,
                     "%x%x%I64x",
                     first_record->QueryTypeCode(),
                     first_record->QueryInstanceTag(),
                     BaseFrs->QueryFileNumber().GetLargeInteger());

        got_allow_cross_link = FALSE;

        //
        // We don't want to free the clusters allocated to this attribute
        // record below, because some of them are cross-linked and the ones
        // that are not have not been allocated in the volume bitmap.
        //

        first_record->DisableUnUse();
    }

    if( first_record->IsResident() ) {

        total_clusters = 0;

    } else {

        total_clusters = cluster_count;
    }

    if (got_allow_cross_link) {
        ChkdskInfo->CrossLinkYet = TRUE;
        ChkdskInfo->CrossLinkedFile = BaseFrs->QueryFileNumber().GetLowPart();
        ChkdskInfo->CrossLinkedAttribute = first_record->QueryTypeCode();
        if (!first_record->QueryName(&ChkdskInfo->CrossLinkedName)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        }
    }

    if (!first_record->QueryName(&first_record_name)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    last_record = first_record;
    while (!(*ErrorsFound) &&
           (attr_record = (PNTFS_ATTRIBUTE_RECORD) iter->GetNext())) {

        if (!attr_record->QueryName(&record_name)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // The filesystem only cares about and maintains the Flags member
        // in the first attribute record of a multi-frs attribute.  So
        // I removed the check below, which used to insure that each set
        // of flags was identical. -mjb.

        // else if (attr_record->QueryFlags() != first_record->QueryFlags()) {

        if (!*ErrorsFound) {

             if (first_record->IsResident()) {

                 Message->LogMsg(MSG_CHKLOG_NTFS_FIRST_ATTR_RECORD_CANNOT_BE_RESIDENT,
                             "%x%x%I64x",
                              first_record->QueryTypeCode(),
                              first_record->QueryInstanceTag(),
                              BaseFrs->QueryFileNumber().GetLargeInteger());

                 *ErrorsFound = TRUE;
             } else if (attr_record->IsResident()) {

                 Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_RECORD_CANNOT_BE_RESIDENT,
                             "%x%x%I64x",
                              attr_record->QueryTypeCode(),
                              attr_record->QueryInstanceTag(),
                              BaseFrs->QueryFileNumber().GetLargeInteger());

                 *ErrorsFound = TRUE;
             } else if (attr_record->QueryTypeCode() != first_record->QueryTypeCode()) {

                 Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_TYPE_CODE_MISMATCH,
                             "%x%x%x%x%I64x",
                              first_record->QueryTypeCode(),
                              first_record->QueryInstanceTag(),
                              attr_record->QueryTypeCode(),
                              attr_record->QueryInstanceTag(),
                              BaseFrs->QueryFileNumber().GetLargeInteger());

                 *ErrorsFound = TRUE;
             } else if (attr_record->QueryLowestVcn() != last_record->QueryNextVcn()) {

                 Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_VCN_NOT_CONTIGUOUS,
                             "%x%x%I64x%x%I64x%I64x",
                              last_record->QueryTypeCode(),
                              last_record->QueryInstanceTag(),
                              last_record->QueryNextVcn().GetLargeInteger(),
                              attr_record->QueryInstanceTag(),
                              attr_record->QueryLowestVcn().GetLargeInteger(),
                              BaseFrs->QueryFileNumber().GetLargeInteger());

                 *ErrorsFound = TRUE;
             } else if (record_name.Strcmp(&first_record_name)) {

                 Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_NAME_MISMATCH,
                             "%x%x%W%x%W%I64x",
                              first_record->QueryTypeCode(),
                              first_record->QueryInstanceTag(),
                              &first_record_name,
                              attr_record->QueryInstanceTag(),
                              &record_name,
                              BaseFrs->QueryFileNumber().GetLargeInteger());

                 *ErrorsFound = TRUE;
             }
        }

        if (!attr_record->UseClusters(VolumeBitmap,
                                      &cluster_count,
                                      ChkdskInfo->CrossLinkStart,
                                      ChkdskInfo->CrossLinkYet ? 0 :
                                          ChkdskInfo->CrossLinkLength,
                                      &got_allow_cross_link)) {
            *ErrorsFound = TRUE;

            Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_CLUSTERS_IN_USE,
                         "%x%x%I64x",
                         attr_record->QueryTypeCode(),
                         attr_record->QueryInstanceTag(),
                         BaseFrs->QueryFileNumber().GetLargeInteger());

            got_allow_cross_link = FALSE;

            //
            // We don't want to free the clusters allocated to this attribute
            // record below, because some of them are cross-linked and the ones
            // that are not have not been allocated in the volume bitmap.
            //

            attr_record->DisableUnUse();
        }

        total_clusters += cluster_count;

        if (got_allow_cross_link) {
            ChkdskInfo->CrossLinkYet = TRUE;
            ChkdskInfo->CrossLinkedFile = BaseFrs->QueryFileNumber().GetLowPart();
            ChkdskInfo->CrossLinkedAttribute = attr_record->QueryTypeCode();
            if (!attr_record->QueryName(&ChkdskInfo->CrossLinkedName)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            }
        }

        last_record = attr_record;
    }

    // Check the allocated length.

    first_record->QueryValueLength(&value_length, &alloc_length, NULL,
        &total_allocated);

    if (!first_record->IsResident()) {

        BIG_INT     temp_length = last_record->QueryNextVcn()*
                                  _drive->QuerySectorSize()*
                                  QueryClusterFactor();

        if (alloc_length != temp_length) {

            *ErrorsFound = TRUE;

            Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_INCORRECT_ALLOCATE_LENGTH,
                         "%x%x%I64x%I64x%I64x",
                         first_record->QueryTypeCode(),
                         first_record->QueryInstanceTag(),
                         alloc_length.GetLargeInteger(),
                         temp_length.GetLargeInteger(),
                         BaseFrs->QueryFileNumber().GetLargeInteger());

        }

#if 0
//
// MJB: deleting the attribute because the total allocated is
//  wrong is considered too severe, so what we really want to do is
//  repair the attribute record.  Unfortunately, I don't see any
//  reasonable way to do that, so we'll let it be.  The filesystem
//  guarantees that nothing terrible will happen if your TotalAllocated
//  field is out-of-whack.
//
        if ((first_record->QueryFlags() & ATTRIBUTE_FLAG_COMPRESSION_MASK)
            != 0) {

            if (total_clusters * _drive->QuerySectorSize() *
                QueryClusterFactor() != total_allocated) {

                DebugPrintTrace(("multi-frs total allocated wrong\n"));

                *ErrorsFound = TRUE;
            }
        }
#endif
    }


    if (*ErrorsFound) {

        // There's a problem so tell the user and tube all of the
        // attribute list entries concerned.

        Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_LIST_ENTRY,
                            "%d%d", first_record->QueryTypeCode(),
                            BaseFrs->QueryFileNumber().GetLowPart());

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        unuse_clusters = FALSE;

        iter->Reset();
        while (attr_record = (PNTFS_ATTRIBUTE_RECORD) iter->GetNext()) {

            // The algorithm above stops calling UseClusters() once it
            // encountered a cross linked attribute.  So, we need to
            // disable UnUseClusters() once we have an attribute that
            // already have the UnUseClusters() disabled.

            if (unuse_clusters)
                attr_record->DisableUnUse();
            else
                unuse_clusters = attr_record->IsUnUseDisabled();

            if (!attr_record->IsResident() &&
                !attr_record->UnUseClusters(VolumeBitmap,
                                            ChkdskInfo->CrossLinkStart,
                                            ChkdskInfo->CrossLinkLength)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);

                DELETE(iter);
                return FALSE;
            }

            if (!attr_record->QueryName(&name) ||
                !AttributeList->DeleteEntry(attr_record->QueryTypeCode(),
                                            attr_record->QueryLowestVcn(),
                                            &name)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);

                DELETE(iter);
                return FALSE;
            }
        }
    } else {

        ChkdskReport->BytesUserData += total_clusters *
                            _drive->QuerySectorSize()*
                            QueryClusterFactor();
    }

    DELETE(iter);

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}


BOOLEAN
NTFS_SA::EnsureSurjectiveAttrList(
    IN OUT  PNTFS_FRS_STRUCTURE     BaseFrs,
    IN      PCNTFS_ATTRIBUTE_LIST   AttributeList,
    IN OUT  PSEQUENTIAL_CONTAINER   ChildFrsList,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message,
    IN OUT  PBOOLEAN                DiskErrorsFound
    )
/*++

Routine Description:

    This routine remove any attribute records that are not present in
    the attribute list.

Arguments:

    BaseFrs         - Supplies the base file record segment.
    AttributeList   - Supplies the attribute list.
    ChildFrsList    - Supplies the list of child FRS.
    FixLevel        - Supplies the fix up level.
    Message         - Supplies an outlet for messages.
    DiskErrorsFound - Supplies whether or not disk errors have been found.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PVOID                   record;
    NTFS_ATTRIBUTE_RECORD   attr_record;
    PNTFS_FRS_STRUCTURE     frs, del_frs;
    PITERATOR               iter;
    DSTRING                 null_string;
    BOOLEAN                 changes;
    DSTRING                 name;
    BOOLEAN                 match_found;
    ATTRIBUTE_TYPE_CODE     attr_code;
    VCN                     lowest_vcn;
    DSTRING                 list_name;

    if (!(iter = ChildFrsList->QueryIterator()) ||
        !null_string.Initialize("\"\"")) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    for (frs = BaseFrs; frs; frs = (PNTFS_FRS_STRUCTURE) iter->GetNext()) {

        changes = FALSE;

        record = NULL;
        while (record = frs->GetNextAttributeRecord(record)) {

            if (!attr_record.Initialize(GetDrive(), record)) {
                DebugAbort("Couldn't initialize an attribute record");
                return FALSE;
            }

            // The attribute list entry is not required to be in the
            // attribute list.

            if (frs == BaseFrs &&
                attr_record.QueryTypeCode() == $ATTRIBUTE_LIST) {

                continue;
            }


            // Find this attribute record in the attribute list.
            // Otherwise, tube this attribute record.

            match_found = AttributeList->QueryEntry(
                                frs->QuerySegmentReference(),
                                attr_record.QueryInstanceTag(),
                                &attr_code, &lowest_vcn, &list_name);

            if (!match_found) {

                if (!attr_record.QueryName(&name)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_NOT_IN_ATTR_LIST,
                             "%x%x%I64x",
                             attr_record.QueryTypeCode(),
                             attr_record.QueryInstanceTag(),
                             frs->QuerySegmentReference());

                Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR,
                                    "%d%W%I64d",
                                    attr_record.QueryTypeCode(),
                                    name.QueryChCount() ? &name : &null_string,
                                    frs->QueryFileNumber().GetLargeInteger());

                frs->DeleteAttributeRecord(record);
                record = NULL;
                changes = TRUE;
            }
        }

        if (frs != BaseFrs && !frs->GetNextAttributeRecord(NULL)) {
            changes = TRUE;
            frs->ClearInUse();
            if (!(del_frs = (PNTFS_FRS_STRUCTURE) ChildFrsList->Remove(iter))) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            iter->GetPrevious();
        } else {
            del_frs = NULL;
        }

        if (changes && DiskErrorsFound) {
            *DiskErrorsFound = TRUE;
        }

        if (changes && FixLevel != CheckOnly && !frs->Write()) {
            Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                "%d", frs->QueryFileNumber().GetLowPart());
            return FALSE;
        }

        DELETE(del_frs);
    }


    DELETE(iter);

    return TRUE;
}

BOOLEAN
NTFS_SA::HotfixMftData(
    IN OUT  PNTFS_ATTRIBUTE MftData,
    IN OUT  PNTFS_BITMAP    VolumeBitmap,
    IN      PNUMBER_SET     BadFrsList,
    OUT     PNUMBER_SET     BadClusterList,
    IN      FIX_LEVEL       FixLevel,
    IN OUT  PMESSAGE        Message
    )
/*++

Routine Description:

    This routine replaces the unreadable FRS in the MFT with readable
    FRS allocated from the volume bitmap.  This routine will fail if
    it cannot hotfix all of the system files.  If there is not
    sufficient disk space to hotfix non-system files then these files
    will be left alone.

    The clusters from the unreadable FRS will be added to the
    unreadable clusters list.  Only those FRS that were successfully
    hotfixed will be added to this list.

Arguments:

    MftData             - Supplies the MFT data attribute.
    VolumeBitmap        - Supplies a valid volume bitmap.
    BadFrsList          - Supplies the list of unreadable FRS.
    BadClusterList      - Returns the list of unreadable clusters.
    FixLevel            - Tells whether the disk should be modified.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    VCN                 unreadable_vcn;
    VCN                 file_number, current_file_number;
    ULONG               i, j;
    HMEM                hmem;
    NTFS_FRS_STRUCTURE  frs;
    LCN                 lcn, previous_lcn;
    NUMBER_SET          last_action;
    ULONG               cluster_size;
    ULONG               clusters_per_frs;
    NUMBER_SET          fixed_frs_list;

    DebugAssert(MftData);
    DebugAssert(VolumeBitmap);
    DebugAssert(BadFrsList);
    DebugAssert(BadClusterList);

    if (!BadClusterList->Initialize() ||
        !fixed_frs_list.Initialize()) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    cluster_size = QueryClusterFactor() * _drive->QuerySectorSize();

    if (QueryFrsSize() > cluster_size) {
        clusters_per_frs = QueryFrsSize() / cluster_size;
    } else {
        clusters_per_frs = 1;
    }

    for (i = 0; i < BadFrsList->QueryCardinality(); i++) {


        if (!last_action.Initialize()) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        file_number = BadFrsList->QueryNumber(i);

        //
        // if this frs has already been fixed - skip it
        // (this is possible only when there are multiple frs'
        // per cluster)
        //
        if ((QueryFrsSize() < cluster_size) && 
            fixed_frs_list.DoesIntersectSet(file_number, 1)) {
            continue;
        }

        unreadable_vcn = (file_number * QueryFrsSize()) / cluster_size;

        // Figure out which clusters go with this frs.  Save away the
        // first one so that we can try to copy its contents later, if
        // necessary.
        //

        if (!MftData->QueryLcnFromVcn(unreadable_vcn, &previous_lcn)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_QUERY_LCN_FROM_VCN_FOR_MFT, "%I64x", unreadable_vcn);
            return FALSE;
        }

        for (j = 0; j < clusters_per_frs; j++) {

            BOOLEAN     error = FALSE;

            if (!MftData->QueryLcnFromVcn(unreadable_vcn + j, &lcn)) {
                Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_QUERY_LCN_FROM_VCN_FOR_MFT, "%I64x", unreadable_vcn+j);
                error = TRUE;
            } else if (lcn == LCN_NOT_PRESENT) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                error = TRUE;
            } else if (!BadClusterList->Add(lcn)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                error = TRUE;
            } else if (!last_action.Add(lcn)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                error = TRUE;
            }
            if (error) {
                return FALSE;
            }
        }

        if (MftData->Hotfix(unreadable_vcn,
                            clusters_per_frs,
                            VolumeBitmap,
                            BadClusterList,
                            FALSE)) {

            // The mft data clusters have been successfully replaced with new
            // clusters.  We want to set the new clusters/frs to indicate that
            // it is not in use.
            //

            if (!hmem.Initialize() ||
                !frs.Initialize(&hmem, MftData, file_number,
                                QueryClusterFactor(),
                                QueryVolumeSectors(),
                                QueryFrsSize(),
                                NULL)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            memset(hmem.GetBuf(), 0, hmem.QuerySize());
            frs.ClearInUse();
            if (FixLevel != CheckOnly) {
                frs.Write();
            }

            //
            // If there were multiple frs in a replaced cluster, we
            // want to copy all those that can be read to the new location.
            // Besides the cluster read may have failed due to just one 
            // bad sector, we may be able to read of a few good frs' from 
            // the good secotrs in the bad cluster
            //
            if (QueryFrsSize() < cluster_size) {

                ULONG sectors_per_frs = QueryFrsSize() / _drive->QuerySectorSize();
                SECRUN secrun;

                if (!MftData->QueryLcnFromVcn(unreadable_vcn, &lcn)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_QUERY_LCN_FROM_VCN_FOR_MFT, "%I64x", unreadable_vcn);
                    return FALSE;
                }

                //
                // file number corresponding to the start of the 
                // unreadable VCN
                //
                current_file_number = unreadable_vcn * cluster_size / QueryFrsSize();

                for (j = 0; j < cluster_size / QueryFrsSize() * sectors_per_frs; j += sectors_per_frs, current_file_number = current_file_number+1) {

                    if (!hmem.Initialize() ||
                        !secrun.Initialize(&hmem, _drive,
                                           previous_lcn * QueryClusterFactor() + j,
                                           sectors_per_frs)) {
                        DebugPrint("Unspecified error in HotfixMftData()");
                        continue;                                           

                    }

                    //
                    // Attempt to read the sectors for this frs
                    //                    
                    if (!secrun.Read()) {

                        //
                        // The sectors for this frs could not be read
                        // So create a new frs and mark it unused
                        //
                        if (!hmem.Initialize() ||
                            !frs.Initialize(&hmem, MftData, current_file_number,
                                            QueryClusterFactor(),
                                            QueryVolumeSectors(),
                                            QueryFrsSize(),
                                            NULL)) {

                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;
                        }

                        memset(hmem.GetBuf(), 0, hmem.QuerySize());
                        frs.ClearInUse();
                        if (FixLevel != CheckOnly) {
                            frs.Write();
                        }
                        
                    } else {

                        //
                        // Copy these sectors to the destination
                        //
                        secrun.Relocate(lcn * QueryClusterFactor() + j);

                        if (FixLevel != CheckOnly) {

                            PreWriteMultiSectorFixup(secrun.GetBuf(), QueryFrsSize());

                            secrun.Write();

                            PostReadMultiSectorFixup(secrun.GetBuf(), QueryFrsSize(), NULL);
                        }

                    }

                    if (file_number != current_file_number) {
                        //
                        // Add this to the list of fixed frs'
                        // so that we do not attempt to fix this 
                        // again
                        //
                        if (!fixed_frs_list.Add(current_file_number)) {
                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            return FALSE;
                        }
                    
                    }

                    
                }
            }

            if (!fixed_frs_list.Add(file_number)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

        } else {

            // We couldn't hot fix it so we don't want it to ever be added
            // to the bad clusters file.

            for (j = 0; j < last_action.QueryCardinality().GetLowPart(); j++) {

                if (!BadClusterList->Remove(last_action.QueryNumber(j))) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }


            // If we couldn't fix one of the system files then scream.

            if (file_number < FIRST_USER_FILE_NUMBER) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_HOTFIX_SYSTEM_FILES,
                                    "%d", file_number.GetLowPart());
                return FALSE;
            } else {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_HOTFIX,
                                    "%d", file_number.GetLowPart());
            }
        }
    }

    if (!BadFrsList->Remove(&fixed_frs_list)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::AreBitmapsEqual(
    IN OUT  PNTFS_ATTRIBUTE BitmapAttribute,
    IN      PCNTFS_BITMAP   Bitmap,
    IN      BIG_INT         MinimumBitmapSize   OPTIONAL,
    IN OUT  PMESSAGE        Message,
    OUT     PBOOLEAN        CompleteFailure,
    OUT     PBOOLEAN        SecondIsSubset
    )
/*++

Routine Description:

    This routine compares these two bitmaps and returns whether
    or not they are equal.

    This routine will return FALSE if it cannot read all of the
    attribute pointed to by 'BitmapAttribute'.

Arguments:

    BitmapAttribute     - Supplies the bitmap attribute to compare.
    Bitmap              - Supplies the in memory bitmap to compare.
    MinimumBitmapSize   - Supplies the minimum number of bits
                            required in the bitmap.  All subsequent
                            bits must be zero.  If this parameter
                            is zero then both bitmaps must be the
                            same size.
    Message             - Supplies an outlet for messages.
    CompleteFailure     - Returns whether or not an unrecoverable
                            error occured while running.
    SecondIsSubset      - Returns TRUE if 'Bitmap' is has a
                            subset of the bits set by 'BitmapAttribute'.

Return Value:

    FALSE   - The bitmaps are not equal.
    TRUE    - The bitmaps are equal.

--*/
{
    CONST   MaxNumBytesToCompare    = 65536;

    ULONG   num_bytes, chomp_length, bytes_read, min_num_bytes, disk_bytes;
    ULONG   bytes_left;
    PUCHAR  attr_ptr, in_mem_ptr;
    PBYTE   p1, p2;
    ULONG   i, j;
    ULONG   debug_output_count = 0;

    *CompleteFailure = FALSE;

    if (SecondIsSubset) {
        *SecondIsSubset = TRUE;
    }

    in_mem_ptr = (PUCHAR) Bitmap->GetBitmapData(&num_bytes);
    disk_bytes = BitmapAttribute->QueryValueLength().GetLowPart();

    // The size of the on-disk bitmap must be a multiple of 8
    // bytes.

    if (disk_bytes % 8 != 0) {
        if (SecondIsSubset) {
            *SecondIsSubset = FALSE;
        }
        return FALSE;
    }

    // Compute the number of bytes that need to be compared.
    // Beyond this point, all bytes must be zero.

    if (MinimumBitmapSize == 0) {
        min_num_bytes = num_bytes;
    } else {
        min_num_bytes = ((MinimumBitmapSize - 1)/8 + 1).GetLowPart();
    }

    // If the minimum bitmap size is not defined or the given
    // value is greater than either of the operands then this
    // means that the bitmaps must really be equal, including
    // their lengths.

    if (MinimumBitmapSize == 0 ||
        min_num_bytes > num_bytes ||
        min_num_bytes > disk_bytes) {

        if (num_bytes != disk_bytes) {
            if (SecondIsSubset) {
                *SecondIsSubset = FALSE;
            }
            return FALSE;
        }

        min_num_bytes = num_bytes;
    }

    if (!(attr_ptr = NEW UCHAR[min(MaxNumBytesToCompare, min_num_bytes)])) {
        *CompleteFailure = TRUE;
        if (SecondIsSubset) {
            *SecondIsSubset = FALSE;
        }

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);

        return FALSE;
    }

    for (i = 0; i < min_num_bytes; i += MaxNumBytesToCompare) {

        chomp_length = min(MaxNumBytesToCompare, min_num_bytes - i);

        // NOTE: these variables are used to avoid an optimization
        // bug in the compiler.  Before removing them, check that code
        // generated for the memcmp below is correct.
        //
        p1 = attr_ptr;
        p2 = &in_mem_ptr[i];

        if (!BitmapAttribute->Read(attr_ptr, i, chomp_length, &bytes_read) ||
            bytes_read != chomp_length) {

            if (SecondIsSubset) {
                *SecondIsSubset = FALSE;
            }

            DELETE_ARRAY(attr_ptr);
            return FALSE;
        }

        if (memcmp(p1, p2, chomp_length)) {

            for (j=0; j<chomp_length; j++) {
                if (p1[j] != p2[j]) {
                    if (debug_output_count++ < 20) {
                        DebugPrintTrace(("UNTFS: Bitmap Offset %x: %02x vs %02x\n", i+j, p1[j], p2[j]));
                    }
                }
            }

            if (SecondIsSubset) {
                for (j = 0; j < chomp_length; j++) {
                    if (~(~in_mem_ptr[i + j] | attr_ptr[j]) != 0) {
                        *SecondIsSubset = FALSE;
                    }
                }
            }

            DELETE_ARRAY(attr_ptr);
            return FALSE;
        }
    }
    if (debug_output_count > 20) {
        DebugPrintTrace(("UNTFS: Too much bitmap differences.  Output clipped.\n"));
    }


    DELETE_ARRAY(attr_ptr);

    // Make sure that everything after 'min_num_bytes' on both
    // bitmaps is zero.

    for (i = min_num_bytes; i < num_bytes; i++) {
        if (in_mem_ptr[i]) {

            if (SecondIsSubset) {
                *SecondIsSubset = FALSE;
            }

            return FALSE;
        }
    }

    // Read in the remainder of the on disk bitmap.

    bytes_left = disk_bytes - min_num_bytes;

    if (!bytes_left) {
        return TRUE;
    }

    if (!(attr_ptr = NEW UCHAR[bytes_left]) ||
        !BitmapAttribute->Read(attr_ptr, min_num_bytes,
                               bytes_left, &bytes_read) ||
        bytes_read != bytes_left) {

        if (SecondIsSubset) {
            *SecondIsSubset = FALSE;
        }

        DELETE_ARRAY(attr_ptr);
        return FALSE;
    }

    for (i = 0; i < bytes_left; i++) {
        if (attr_ptr[i]) {
            if (SecondIsSubset) {
                *SecondIsSubset = FALSE;
            }
            return FALSE;
        }
    }

    DELETE_ARRAY(attr_ptr);

    return TRUE;
}


BOOLEAN
NTFS_SA::SynchronizeMft(
    IN OUT  PNTFS_INDEX_TREE        RootIndex,
    IN      PNTFS_MASTER_FILE_TABLE InternalMft,
       OUT  PBOOLEAN                Errors,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message,
    IN      MessageMode             MsgMode
    )
/*++

Routine Description:

    This routine fixes the MFT file with the internal Mft.

Arguments:

    RootIndex   - Supplies the root index.
    InternalMft - Supplies the internal MFT.
    Errors      - Returns TRUE if errors has been found.
    FixLevel    - Supplies the fix level.
    Message     - Supplies an outlet for messages.
    MsgMode     - Supplies the type of messages that should be displayed.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

Notes:

    Any bad clusters discovered by this routine are marked in the volume
    bitmap but not added to the bad clusters file.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    mft_file;
    NTFS_FILE_RECORD_SEGMENT    bitmap_file;
    NTFS_ATTRIBUTE              disk_mft_data;
    NTFS_ATTRIBUTE              mft_bitmap_attribute;
    NTFS_ATTRIBUTE              volume_bitmap_attribute;
    PNTFS_ATTRIBUTE             mft_data;
    PNTFS_BITMAP                mft_bitmap;
    PNTFS_BITMAP                volume_bitmap;
    BOOLEAN                     replace;
    BOOLEAN                     convergence;
    ULONG                       i;
    NTFS_EXTENT_LIST            extents;
    NUMBER_SET                  bad_clusters;
    BOOLEAN                     complete_failure;
    BOOLEAN                     second_is_subset;
    BOOLEAN                     ErrorInAttribute;
    ULONG                       min_bits_in_mft_bitmap;


    DebugPtrAssert(InternalMft);
    DebugPtrAssert(Message);
    DebugPtrAssert(Errors);

    *Errors = FALSE;

    if (!bad_clusters.Initialize()) {
        DebugAssert("Could not initialize a bad clusters list");
        return FALSE;
    }

    mft_data = InternalMft->GetDataAttribute();
    mft_bitmap = InternalMft->GetMftBitmap();
    volume_bitmap = InternalMft->GetVolumeBitmap();

    DebugAssert(mft_data);
    DebugAssert(mft_bitmap);
    DebugAssert(volume_bitmap);

    if (!mft_file.Initialize(MASTER_FILE_TABLE_NUMBER, InternalMft) ||
        !bitmap_file.Initialize(BIT_MAP_FILE_NUMBER, InternalMft)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!mft_file.Read() || !bitmap_file.Read()) {
        DebugAbort("Previously readable FRS is unreadable");
        return FALSE;
    }

    convergence = FALSE;
    for (i = 0; !convergence; i++) {

        convergence = TRUE;


        // Do the MFT $DATA first.

        if (mft_file.QueryAttribute(&disk_mft_data, &ErrorInAttribute, $DATA)) {

            if (disk_mft_data == *mft_data) {
                replace = FALSE;
            } else {
                replace = TRUE;
            }
        } else if (ErrorInAttribute) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        } else {
            replace = TRUE;
        }

        if (replace) {

            *Errors = TRUE;

            if (FixLevel != CheckOnly) {
                convergence = FALSE;
            }

            // We don't resize the disk MFT to zero because
            // this could clear bits that are now in use
            // by other attributes.

            if (!mft_data->MarkAsAllocated(volume_bitmap)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (i == 0) {
                switch (MsgMode) {
                    case UpdateMessage:
                        Message->DisplayMsg(MSG_CHK_NTFS_UPDATING_MFT_DATA);
                        break;

                    case CorrectMessage:
                        Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_MFT_DATA);
                        break;
                }
            }

            if (!mft_data->InsertIntoFile(&mft_file, volume_bitmap)) {

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_MFT);
                return FALSE;
            }

            if (FixLevel != CheckOnly &&
                !mft_file.Flush(volume_bitmap, RootIndex)) {
                Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                    "%d", ROOT_FILE_NAME_INDEX_NUMBER);
                return FALSE;
            }
        }


        // Do the MFT $BITMAP next.

        if (mft_file.QueryAttribute(&mft_bitmap_attribute,
                                    &ErrorInAttribute, $BITMAP)) {

            min_bits_in_mft_bitmap =
            (mft_data->QueryValueLength()/mft_file.QuerySize()).GetLowPart();

            if (AreBitmapsEqual(&mft_bitmap_attribute, mft_bitmap,
                                min_bits_in_mft_bitmap,
                                Message, &complete_failure,
                                &second_is_subset)) {

                replace = FALSE;

            } else {

                if (complete_failure) {
                    return FALSE;
                }

                replace = TRUE;
            }
        } else if (ErrorInAttribute) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        } else {
            replace = TRUE;
            second_is_subset = FALSE;

            // Create mft_bitmap_attribute.

            if (!extents.Initialize(0, 0) ||
                !mft_bitmap_attribute.Initialize(_drive,
                                                 QueryClusterFactor(),
                                                 &extents,
                                                 0, 0, $BITMAP)) {

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_MFT);
                return FALSE;
            }
        }

        if (replace) {

            *Errors = TRUE;

            if (FixLevel != CheckOnly) {
                convergence = FALSE;
            }

            if (i == 0 || !second_is_subset) {

                switch (MsgMode) {
                    case CorrectMessage:
                        Message->DisplayMsg(second_is_subset ?
                                            MSG_CHK_NTFS_MINOR_MFT_BITMAP_ERROR :
                                            MSG_CHK_NTFS_CORRECTING_MFT_BITMAP);
                        break;

                    case UpdateMessage:
                        Message->DisplayMsg(MSG_CHK_NTFS_UPDATING_MFT_BITMAP);
                        break;
                }
            }

            if (FixLevel != CheckOnly &&
                (!mft_bitmap_attribute.MakeNonresident(volume_bitmap) ||
                 !mft_bitmap->Write(&mft_bitmap_attribute, volume_bitmap))) {

                if (!mft_bitmap_attribute.RecoverAttribute(volume_bitmap,
                                                           &bad_clusters) ||
                    !mft_bitmap->Write(&mft_bitmap_attribute, volume_bitmap)) {

                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_MFT);
                    return FALSE;
                }
            }

            if (mft_bitmap_attribute.IsStorageModified() &&
                !mft_bitmap_attribute.InsertIntoFile(&mft_file,
                                                       volume_bitmap)) {

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_MFT);
                return FALSE;
            }

            if (FixLevel != CheckOnly &&
                !mft_file.Flush(volume_bitmap, RootIndex)) {
                Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                    "%d", ROOT_FILE_NAME_INDEX_NUMBER);
                return FALSE;
            }
        }

        // Do the volume bitmap next.

        if (bitmap_file.QueryAttribute(&volume_bitmap_attribute,
                                     &ErrorInAttribute, $DATA)) {

//            DebugPrintTrace(("Comparing volume bitmap\n"));

            if (AreBitmapsEqual(&volume_bitmap_attribute, volume_bitmap, 0,
                                Message, &complete_failure,
                                &second_is_subset)) {

                replace = FALSE;

            } else {

                if (complete_failure) {
                    return FALSE;
                }

                replace = TRUE;
            }
        } else if (ErrorInAttribute) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        } else {
            replace = TRUE;
            second_is_subset = FALSE;

            // Create mft_bitmap_attribute.

            if (!extents.Initialize(0, 0) ||
                !volume_bitmap_attribute.Initialize(_drive,
                                                    QueryClusterFactor(),
                                                    &extents,
                                                    0, 0, $DATA)) {

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_VOLUME_BITMAP);
                return FALSE;
            }
        }

        if (replace) {

            *Errors = TRUE;

            if (FixLevel != CheckOnly) {
                convergence = FALSE;
            }

            if (i == 0 || !second_is_subset) {

                switch (MsgMode) {
                    case CorrectMessage:
                        Message->DisplayMsg(second_is_subset ?
                                            MSG_CHK_NTFS_MINOR_VOLUME_BITMAP_ERROR :
                                            MSG_CHK_NTFS_CORRECTING_VOLUME_BITMAP);
                        break;

                    case UpdateMessage:
                        Message->DisplayMsg(MSG_CHK_NTFS_UPDATING_VOLUME_BITMAP);
                }
            }

            if (FixLevel != CheckOnly &&
                (!volume_bitmap_attribute.MakeNonresident(volume_bitmap) ||
                 !volume_bitmap->Write(&volume_bitmap_attribute,
                                       volume_bitmap))) {

                if (!volume_bitmap_attribute.RecoverAttribute(volume_bitmap,
                                                              &bad_clusters) ||
                    !volume_bitmap->Write(&volume_bitmap_attribute,
                                          volume_bitmap)) {

                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_VOLUME_BITMAP);
                    return FALSE;
                }
            }

            if (volume_bitmap_attribute.IsStorageModified() &&
                !volume_bitmap_attribute.InsertIntoFile(&bitmap_file,
                                                        volume_bitmap)) {

                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_MFT);
                return FALSE;
            }

            if (FixLevel != CheckOnly &&
                !bitmap_file.Flush(volume_bitmap, RootIndex)) {
                Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                    "%d", ROOT_FILE_NAME_INDEX_NUMBER);
                return FALSE;
            }
        }
    }

    if (FixLevel != CheckOnly) {
        if (!mft_file.Flush(NULL, RootIndex) ||
            !bitmap_file.Flush(NULL, RootIndex)) {
            Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                "%d", ROOT_FILE_NAME_INDEX_NUMBER);
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_SA::ResetLsns(
    IN OUT  PMESSAGE                Message,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      BOOLEAN                 SkipRootIndex
    )
/*++

Routine Description:

    This method sets all the LSN's on the volume to zero.

Arguments:

    Message         --  Supplies an outlet for messages.
    Mft             --  Supplies the volume's Master File Table.
    SkipRootIndex   --  Supplies a flag which indicates, if TRUE,
                        that the root index FRS and index should
                        be skipped.  In that case, the client is
                        responsible for resetting the LSN's on
                        those items.
--*/
{
    NTFS_FILE_RECORD_SEGMENT    frs;
    NTFS_INDEX_TREE             index;
    NTFS_ATTRIBUTE              index_root;
    ULONG                       i, j, n, frs_size, num_frs_per_prime;
    ULONG                       percent_done = 0;
    BOOLEAN                     error_in_attribute;

    Message->DisplayMsg(MSG_CHK_NTFS_RESETTING_LSNS);

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 0)) {
        return FALSE;
    }

    // Compute the number of file records.
    //
    frs_size = Mft->QueryFrsSize();

    n = (Mft->GetDataAttribute()->QueryValueLength()/frs_size).GetLowPart();
    num_frs_per_prime = MFT_PRIME_SIZE/frs_size;

    for (i = 0; i < n; i += 1) {

        if (i*100/n != percent_done) {
            percent_done = (i*100/n);
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                return FALSE;
            }
        }

        if (i % num_frs_per_prime == 0) {
            Mft->GetDataAttribute()->PrimeCache(i*frs_size,
                                                num_frs_per_prime*frs_size);
        }

        // if specified, skip the root file index
        //
        if (SkipRootIndex && i == ROOT_FILE_NAME_INDEX_NUMBER) {

            continue;
        }

        if (!frs.Initialize(i, Mft)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // If the FRS is unreadable or is not in use, skip it.
        //
        if (!frs.Read() || !frs.IsInUse()) {

            continue;
        }

        frs.SetLsn( 0 );
        frs.Write();

        // Iterate through all the indices present in this FRS
        // (if any), resetting LSN's on all of them.
        //
        error_in_attribute = FALSE;

        for (j = 0; frs.QueryAttributeByOrdinal( &index_root,
                                                 &error_in_attribute,
                                                 $INDEX_ROOT,
                                                 j ); j++) {

            if (!index.Initialize(_drive,
                                  QueryClusterFactor(),
                                  Mft->GetVolumeBitmap(),
                                  Mft->GetUpcaseTable(),
                                  frs.QuerySize()/2,
                                  &frs,
                                  index_root.GetName()) ||
                !index.ResetLsns(Message)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
        }

        if (error_in_attribute) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

    }

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100)) {
        return FALSE;
    }

    return TRUE;
}

BOOLEAN
NTFS_SA::FindHighestLsn(
    IN OUT  PMESSAGE                Message,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    OUT     PLSN                    HighestLsn
    )
/*++

Routine Description:

    This function traverses the volume to find the highest LSN
    on the volume.  It is currently unused, but had previously
    been a worker for ResizeCleanLogFile().

Arguments:

    Message     --  Supplies an outlet for messages.
    Mft         --  Supplies the volume Master File Table.
    HighestLsn  --  Receives the highest LSN found on the volume.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    frs;
    NTFS_INDEX_TREE             index;
    NTFS_ATTRIBUTE              index_root;
    LSN                         HighestLsnInIndex;
    ULONG                       i, j, n, frs_size, num_frs_per_prime;
    ULONG                       percent_done = 0;
    BOOLEAN                     error_in_attribute;

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 0)) {
        return FALSE;
    }

    // Compute the number of file records.
    //
    frs_size = Mft->QueryFrsSize();

    n = (Mft->GetDataAttribute()->QueryValueLength()/frs_size).GetLowPart();
    num_frs_per_prime = MFT_PRIME_SIZE/frs_size;

    for (i = 0; i < n; i += 1) {

        if (i*100/n != percent_done) {
            percent_done = (i*100/n);
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                return FALSE;
            }
        }

        if (i % num_frs_per_prime == 0) {
            Mft->GetDataAttribute()->PrimeCache(i*frs_size,
                                                num_frs_per_prime*frs_size);
        }

        if (!frs.Initialize(i, Mft)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // If the FRS is unreadable or is not in use, skip it.
        //
        if (!frs.Read() || !frs.IsInUse()) {

            continue;
        }

        if (frs.QueryLsn() > *HighestLsn) {

            *HighestLsn = frs.QueryLsn();
        }

        // Iterate through all the indices present in this FRS
        // (if any), resetting LSN's on all of them.
        //
        error_in_attribute = FALSE;

        for (j = 0; frs.QueryAttributeByOrdinal( &index_root,
                                                 &error_in_attribute,
                                                 $INDEX_ROOT,
                                                 j ); j++) {

            if (!index.Initialize(_drive,
                                  QueryClusterFactor(),
                                  Mft->GetVolumeBitmap(),
                                  Mft->GetUpcaseTable(),
                                  frs.QuerySize()/2,
                                  &frs,
                                  index_root.GetName()) ||
                !index.FindHighestLsn(Message, &HighestLsnInIndex)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (HighestLsnInIndex > *HighestLsn) {

                *HighestLsn = HighestLsnInIndex;
            }
        }

        if (error_in_attribute) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100)) {
        return FALSE;
    }

    return TRUE;

}


BOOLEAN
NTFS_SA::ResizeCleanLogFile(
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExplicitResize,
    IN      ULONG       DesiredSize
    )
/*++

Routine Description:

    This method resizes the log file to its default size.   It may
    be used only when the volume has been shut down cleanly.

Arguments:

    Message         - Supplies an outlet for messages.
    ExplicitResize  - Tells whether this is just the default check, or
                      if the user explicitly asked for a resize.  If FALSE, the
                      logfile will be resized only if it is wildly out of
                      whack.  If TRUE, the logfile will be resized to
                      the desired size.
    DesiredSize     - Supplies the desired size, or zero if the user just
                      wants to query the current size.

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_BITMAP         VolumeBitmap;
    NTFS_UPCASE_TABLE   UpcaseTable;

    NTFS_UPCASE_FILE    UpcaseFile;
    NTFS_BITMAP_FILE    BitmapFile;
    NTFS_MFT_FILE       MftFile;
    NTFS_LOG_FILE       LogFile;
    NTFS_FILE_RECORD_SEGMENT MftMirror;

    NTFS_ATTRIBUTE      UpcaseAttribute;
    NTFS_ATTRIBUTE      BitmapAttribute;
    NTFS_ATTRIBUTE      MirrorAttribute;

    HMEM                MirrorMem;

    LSN                 HighestLsn;
    BIG_INT             BigZero, TempBigInt;
    BIG_INT             FreeSectorSize;
    ULONG               MirrorSize, BytesTransferred;
    BOOLEAN             error, LogFileGrew, Changed;

    ULONG               current_size;
    NTFS_ATTRIBUTE      attrib;

    ULONG               volume_flags;
    UCHAR               major, minor;
    BOOLEAN             corrupt_volume;
    LSN                 lsn;

    // If we're just doing the usual check and not an explicitly-asked for
    // resize, do a quick check to see if there's anything to do.
    //

    if (!ExplicitResize) {
        if (!LogFileMayNeedResize()) {
            return TRUE;
        } else {
            DesiredSize = NTFS_LOG_FILE::QueryDefaultSize(_drive, QueryVolumeSectors());
        }
    }

    // Initialize the bitmap, fetch the MFT, and read the bitmap
    // and upcase table.
    //

    if (!VolumeBitmap.Initialize( QueryVolumeSectors()/QueryClusterFactor(),
                                  FALSE, _drive, QueryClusterFactor() ) ||
        !MftFile.Initialize( _drive,
                             QueryMftStartingLcn(),
                             QueryClusterFactor(),
                             QueryFrsSize(),
                             QueryVolumeSectors(),
                             &VolumeBitmap,
                             NULL ) ||
        !MftFile.Read() ||
        MftFile.GetMasterFileTable() == NULL ||
        !BitmapFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !BitmapFile.Read() ||
        !BitmapFile.QueryAttribute( &BitmapAttribute, &error, $DATA ) ||
        !VolumeBitmap.Read( &BitmapAttribute ) ||
        !UpcaseFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !UpcaseFile.Read() ||
        !UpcaseFile.QueryAttribute( &UpcaseAttribute, &error, $DATA ) ||
        !UpcaseTable.Initialize( &UpcaseAttribute ) ) {

        return FALSE;
    }

    MftFile.SetUpcaseTable( &UpcaseTable );
    MftFile.GetMasterFileTable()->SetUpcaseTable( &UpcaseTable );

    // Initialize and read the log file.  Make sure the volume
    // was shut down cleanly.
    //

    if (!LogFile.Initialize( MftFile.GetMasterFileTable() ) ||
        !LogFile.Read()) {

        return FALSE;
    }

    if (!LogFile.QueryAttribute( &attrib, &error, $DATA )) {
        return FALSE;
    }

    current_size = attrib.QueryValueLength().GetLowPart();

    if (DesiredSize > current_size) {
        FreeSectorSize = VolumeBitmap.QueryFreeClusters() * QueryClusterFactor();
        if (((DesiredSize-current_size-1)/_drive->QuerySectorSize()+1) > FreeSectorSize) {

            Message->DisplayMsg( ExplicitResize ?
                                    MSG_CHK_NTFS_SPECIFIED_LOGFILE_SIZE_TOO_BIG :
                                    MSG_CHK_NTFS_OUT_OF_SPACE_TO_ENLARGE_LOGFILE_TO_DEFAULT_SIZE );
            return FALSE;
        }
    }

    if (ExplicitResize && 0 == DesiredSize) {

        ULONG default_size;

        // The user just wants to query the current logfile size.  Do
        // that and exit.  Also print the default logfile size for this
        // volume.
        //

        current_size = current_size / 1024;
        default_size = LogFile.QueryDefaultSize( _drive, QueryVolumeSectors() ) / 1024;

        Message->DisplayMsg(MSG_CHK_NTFS_LOGFILE_SIZE,
                            "%d%d", current_size, default_size );

        return TRUE;
    }

    if (ExplicitResize &&
        DesiredSize < LogFile.QueryMinimumSize( _drive, QueryVolumeSectors() )) {

        Message->DisplayMsg(MSG_CHK_NTFS_SPECIFIED_LOGFILE_SIZE_TOO_SMALL);
        return FALSE;
    }

    // Resize the logfile.
    //
    volume_flags = QueryVolumeFlagsAndLabel(&corrupt_volume, &major, &minor);

    if (corrupt_volume ||
        (volume_flags & VOLUME_DIRTY) ||
        !LogFile.EnsureCleanShutdown(&lsn)) {

        DebugPrintTrace(("CorruptFlag %x, VolumeFlag %x\n", corrupt_volume, volume_flags));

        Message->DisplayMsg(MSG_CHK_NTFS_RESIZING_LOGFILE_BUT_DIRTY);
        return FALSE;
    }

    if (!LogFile.Resize( DesiredSize, &VolumeBitmap, FALSE, &Changed,
                         &LogFileGrew, Message )) {

        return FALSE;
    }

    if (!Changed) {

        // The log file was already the correct size.
        //
        return TRUE;
    }

    // If the log file is growing, write the volume bitmap
    // before flushing the log file frs; if it's shrinking, write
    // the bitmap after flushing the log file frs.  That way, if
    // the second operation (either writing the log file FRS or
    // the bitmap) fails, the only bitmap errors will be free
    // space marked as allocated.
    //
    // Since this is a fixed-size, non-resident attribute, writing
    // it doesn't change its  File Record Segment.
    //

    if (LogFileGrew && !VolumeBitmap.Write( &BitmapAttribute, NULL )) {

        return FALSE;
    }

    // Flush the log file.  Since the log file never has
    // external attributes, flushing it won't change the MFT.
    // Note that the index entry for the log file is not updated.
    //

    if (!LogFile.Flush( NULL, NULL )) {

        return FALSE;
    }

    //  If we didn't already, write the volume bitmap.
    //

    if (!LogFileGrew && !VolumeBitmap.Write( &BitmapAttribute, NULL )) {

        return FALSE;
    }

    // Clear the Resize Log File bit in the Volume DASD file.
    // Note that the log file is already marked as Checked.
    //

    BigZero = 0;
    ClearVolumeFlag( VOLUME_RESIZE_LOG_FILE,
                     &LogFile, TRUE, lsn, &corrupt_volume );

    // Update the MFT Mirror.
    //

    MirrorSize = REFLECTED_MFT_SEGMENTS * MftFile.QuerySize();

    if (!MirrorMem.Initialize() ||
        !MirrorMem.Acquire( MirrorSize ) ||
        !MftMirror.Initialize( MASTER_FILE_TABLE2_NUMBER, &MftFile ) ||
        !MftMirror.Read() ||
        !MftMirror.QueryAttribute( &MirrorAttribute, &error, $DATA ) ||
        !MftFile.GetMasterFileTable()->
            GetDataAttribute()->Read( MirrorMem.GetBuf(), 0,
                                        MirrorSize, &BytesTransferred ) ||
        BytesTransferred != MirrorSize ||
        !MirrorAttribute.Write( MirrorMem.GetBuf(), 0, MirrorSize,
                                        &BytesTransferred, NULL ) ||
        BytesTransferred != MirrorSize) {

        DebugPrintTrace(("UNTFS: Error updating MFT Mirror.\n"));
        // but don't return FALSE, since we've changed the log file.
    }


#if defined( _AUTOCHECK_ )

    // If this is AUTOCHK and we're running on the boot partition then
    // we should reboot so that the cache doesn't stomp on us.

    DSTRING sdrive, canon_sdrive, canon_drive;

    FSTRING boot_log_file_name;

    if (IFS_SYSTEM::QueryNtSystemDriveName(&sdrive) &&
        IFS_SYSTEM::QueryCanonicalNtDriveName(&sdrive, &canon_sdrive) &&
        IFS_SYSTEM::QueryCanonicalNtDriveName(_drive->GetNtDriveName(),
                                              &canon_drive) &&
        !canon_drive.Stricmp(&canon_sdrive)) {

        Message->DisplayMsg(MSG_CHK_BOOT_PARTITION_REBOOT);

        boot_log_file_name.Initialize( L"bootex.log" );

        if (Message->IsLoggingEnabled() &&
            !DumpMessagesToFile( &boot_log_file_name,
                                 &MftFile,
                                 Message )) {

            DebugPrintTrace(("UNTFS: Error writing messages to BOOTEX.LOG\n"));
        }

        IFS_SYSTEM::Reboot();
    }

#endif

    return TRUE;
}

BOOLEAN
EnsureValidFileAttributes(
    IN OUT  PNTFS_FILE_RECORD_SEGMENT   Frs,
    IN OUT  PNTFS_INDEX_TREE            ParentIndex,
       OUT  PBOOLEAN                    SaveIndex,
    IN      ULONG                       FileAttributes,
    IN OUT  PNTFS_CHKDSK_INFO           ChkdskInfo,
    IN OUT  PNTFS_MASTER_FILE_TABLE     Mft,
    IN      FIX_LEVEL                   FixLevel,
    IN OUT  PMESSAGE                    Message
    )
/*++

Routine Description:

    This routine makes sure the FileAttributes in the given
    Frs has the hidden and system flags set but not the read-only
    bit.

Arguments:

    Frs          - Supplies the frs to examine
    ParentIndex  - Supplies the parent index of the given Frs
    SaveIndex    - Supplies whether there is a need to save the
                   parent index
    FileAttributes
                 - Supplies extra bits that should be set
    ChkdskInfo   - Supplies the current chkdsk info.
    Mft          - Supplies the MFT.
    FixLevel     - Supplies the fix level.
    Message      - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PSTANDARD_INFORMATION2  pstandard;
    NTFS_ATTRIBUTE          attrib;
    BOOLEAN                 error;
    ULONG                   file_attributes;
    ULONG                   old_file_attributes;
    PINDEX_ENTRY            foundEntry;
    PNTFS_INDEX_BUFFER      containingBuffer;
    ULONG                   num_bytes;
    ULONG                   length;
    PFILE_NAME              pfile_name;
    ULONG                   errFixedStatus = CHKDSK_EXIT_SUCCESS;

    //
    // Check the FileAttributes in $STANDARD_INFORMATION first
    //

    if (!Frs->QueryAttribute(&attrib, &error, $STANDARD_INFORMATION)) {
        DebugPrintTrace(("Unable to locate $STANDARD_INFORMATION attribute of file %d\n",
                    Frs->QueryFileNumber().GetLowPart()));
        return FALSE;
    }

    pstandard = (PSTANDARD_INFORMATION2)attrib.GetResidentValue();
    if (!pstandard) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    file_attributes = pstandard->FileAttributes;
    if (!(file_attributes & FAT_DIRENT_ATTR_HIDDEN) ||
        ((file_attributes & FileAttributes) != FileAttributes) ||
        !(file_attributes & FAT_DIRENT_ATTR_SYSTEM) ||
        (file_attributes & FAT_DIRENT_ATTR_READ_ONLY)) {

        file_attributes &= ~FAT_DIRENT_ATTR_READ_ONLY;
        file_attributes |= FAT_DIRENT_ATTR_HIDDEN |
                          FAT_DIRENT_ATTR_SYSTEM |
                          FileAttributes;

        Message->LogMsg(MSG_CHKLOG_NTFS_INVALID_FILE_ATTR,
                     "%x%x%I64x",
                     pstandard->FileAttributes,
                     file_attributes,
                     Frs->QueryFileNumber().GetLargeInteger());

        pstandard->FileAttributes = file_attributes;

        Message->DisplayMsg(MSG_CHK_NTFS_MINOR_CHANGES_TO_FRS,
                            "%d", Frs->QueryFileNumber().GetLowPart());

        DebugAssert(attrib.QueryValueLength().GetHighPart() == 0);

        if (FixLevel != CheckOnly &&
            (!attrib.Write((PVOID)pstandard,
                           0,
                           attrib.QueryValueLength().GetLowPart(),
                           &num_bytes,
                           Mft->GetVolumeBitmap()) ||
             num_bytes != attrib.QueryValueLength().GetLowPart())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                "%d%d", attrib.QueryTypeCode(),
                                Frs->QueryFileNumber().GetLowPart());
            return FALSE;
        }

        if (FixLevel != CheckOnly && attrib.IsStorageModified() &&
            !attrib.InsertIntoFile(Frs, Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                "%d%d", attrib.QueryTypeCode(),
                                Frs->QueryFileNumber().GetLowPart());
            return FALSE;
        }

        //
        // Now update the FileAttributes in DUPLICATED_INFORMATION in $FILE_NAME
        //

        if (!Frs->QueryAttribute(&attrib, &error, $FILE_NAME)) {
            DebugPrintTrace(("Unable to locate $FILE_NAME attribute of file %d\n",
                        Frs->QueryFileNumber().GetLowPart()));
            return FALSE;
        }

        DebugAssert(attrib.QueryValueLength().GetHighPart() == 0);
        length = attrib.QueryValueLength().GetLowPart();
        if (!(pfile_name = (PFILE_NAME)MALLOC(length))) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (!attrib.Read(pfile_name, 0, length, &num_bytes) ||
            num_bytes != length) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            FREE(pfile_name);
            return FALSE;
        }

        old_file_attributes = pfile_name->Info.FileAttributes;
        pfile_name->Info.FileAttributes = file_attributes;
        if (!attrib.Write(pfile_name, 0, length, &num_bytes,
                          Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                "%d%d", attrib.QueryTypeCode(),
                                Frs->QueryFileNumber().GetLowPart());
            FREE(pfile_name);
            return FALSE;
        }

        //
        // Finally, delete the $FILE_NAME entry in the index
        // so that it will get updated later on
        //

        pfile_name->Info.FileAttributes = old_file_attributes;

        if (ParentIndex->QueryEntry(length,
                                    pfile_name,
                                    0,
                                    &foundEntry,
                                    &containingBuffer,
                                    &error)) {

            if (!ParentIndex->DeleteEntry(length, pfile_name, 0)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                FREE(pfile_name);
                return FALSE;
            }
            *SaveIndex = TRUE;

        } else if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            FREE(pfile_name);
            return FALSE;
        }

        FREE(pfile_name);

        if (FixLevel != CheckOnly && !Frs->Flush(NULL)) {
            if (ChkdskInfo->ObjectIdFileNumber == Frs->QueryFileNumber())
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_OBJID);
            else if (ChkdskInfo->QuotaFileNumber == Frs->QueryFileNumber())
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_QUOTA);
            else if (ChkdskInfo->UsnJournalFileNumber == Frs->QueryFileNumber())
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USNJRNL);
            else if (ChkdskInfo->ReparseFileNumber == Frs->QueryFileNumber())
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_REPARSE);
            else
                DebugAssert(FALSE);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}


BOOLEAN
GetSystemFileName(
    IN      UCHAR       Major,
    IN      VCN         FileNumber,
       OUT  PWSTRING    FileName,
       OUT  PBOOLEAN    NoName
    )
/*++

Routine Description:

    This routine returns the name of the system file corresponding
    to the given FileNumber.

Arguments:

    Major        - Supplies the major volume revision
    FileNumber   - Supplies the system FRS file number
    FileName     - Returns the name of the system file
    NoName       - TRUE if FileNumber is one of the system file number

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BOOLEAN     r;

    *NoName = FALSE;

    if (FileNumber        == MASTER_FILE_TABLE_NUMBER    ) {
        r = FileName->Initialize("$MFT");

    } else if (FileNumber == MASTER_FILE_TABLE2_NUMBER   ) {
        r = FileName->Initialize("$MFTMirr");

    } else if (FileNumber == LOG_FILE_NUMBER             ) {
        r = FileName->Initialize("$LogFile");

    } else if (FileNumber == VOLUME_DASD_NUMBER          ) {
        r = FileName->Initialize("$Volume");

    } else if (FileNumber == ATTRIBUTE_DEF_TABLE_NUMBER  ) {
        r = FileName->Initialize("$AttrDef");

    } else if (FileNumber == ROOT_FILE_NAME_INDEX_NUMBER ) {
        r = FileName->Initialize(".");

    } else if (FileNumber == BIT_MAP_FILE_NUMBER         ) {
        r = FileName->Initialize("$Bitmap");

    } else if (FileNumber == BOOT_FILE_NUMBER            ) {
        r = FileName->Initialize("$Boot");

    } else if (FileNumber == BAD_CLUSTER_FILE_NUMBER     ) {
        r = FileName->Initialize("$BadClus");

    } else if (FileNumber == SECURITY_TABLE_NUMBER && Major >= 2) {
        r = FileName->Initialize("$Secure");

    } else if (FileNumber == QUOTA_TABLE_NUMBER && Major <= 1) {
        r = FileName->Initialize("$Quota");

    } else if (FileNumber == UPCASE_TABLE_NUMBER         ) {
        r = FileName->Initialize("$UpCase");

    } else if (FileNumber == EXTEND_TABLE_NUMBER && Major >= 2) {
        r = FileName->Initialize("$Extend");

    } else {
        r = *NoName = TRUE;

    }
    return r;
}

VOID
QueryFileNameFromIndex(
    IN      PFILE_NAME  P,
       OUT  PWCHAR      Buffer,
    IN      CHNUM       BufferLength
    )
{
    UCHAR           len, i;

    DebugAssert(P);
    DebugAssert(Buffer);
    DebugAssert(P->FileNameLength <= 0xff || BufferLength <= 0x100);
    DebugAssert(P->FileNameLength <= 0xff);

    len = (UCHAR)min(BufferLength-1, P->FileNameLength);
    for (i=0; i < len; i++)
        Buffer[i] = P->FileName[i];
    Buffer[i] = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\rafile.cxx ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    rafile.cxx

Abstract:

    This module implements the read ahead algorithm for the
    file verification stage of chkdsk.

Author:

    Daniel Chan (danielch) 08-Dec-97

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "ntfssa.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "ntfsbit.hxx"
#include "attrcol.hxx"
#include "frsstruc.hxx"
#include "attrib.hxx"
#include "attrrec.hxx"
#include "attrlist.hxx"
#include "list.hxx"
#include "iterator.hxx"
#include "attrdef.hxx"
#include "extents.hxx"
#include "mft.hxx"
#include "mftref.hxx"
#include "bootfile.hxx"
#include "badfile.hxx"
#include "mftfile.hxx"
#include "numset.hxx"
#include "ifssys.hxx"
#include "indxtree.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
#include "frs.hxx"
#include "digraph.hxx"
#include "logfile.hxx"
#include "rcache.hxx"
#include "ifsentry.hxx"
#include "rafile.hxx"

PNTFS_SA                 RA_PROCESS_FILE::_sa;
ULONG64                  RA_PROCESS_FILE::_total_number_of_frs;
PVCN                     RA_PROCESS_FILE::_first_frs_number;
PULONG                   RA_PROCESS_FILE::_number_of_frs_to_read;
PNTFS_FRS_STRUCTURE      RA_PROCESS_FILE::_frsstruc1;
PNTFS_FRS_STRUCTURE      RA_PROCESS_FILE::_frsstruc2;
PHMEM                    RA_PROCESS_FILE::_hmem1;
PHMEM                    RA_PROCESS_FILE::_hmem2;
HANDLE                   RA_PROCESS_FILE::_read_ahead_event;
HANDLE                   RA_PROCESS_FILE::_read_ready_event;
PNTFS_ATTRIBUTE          RA_PROCESS_FILE::_mft_data;
PNTFS_UPCASE_TABLE       RA_PROCESS_FILE::_upcase_table;

DEFINE_EXPORTED_CONSTRUCTOR( RA_PROCESS_FILE, OBJECT, UNTFS_EXPORT );

BOOLEAN
NTFS_SA::StartProcessingFiles(
    IN      BIG_INT                  TotalNumberOfFrs,
    IN OUT  PBOOLEAN                 DiskErrorFound,
    IN      FIX_LEVEL                FixLevel,
    IN OUT  PNTFS_ATTRIBUTE          MftData,
    IN OUT  PNTFS_BITMAP             MftBitmap,
    IN OUT  PNTFS_BITMAP             VolumeBitmap,
    IN OUT  PNTFS_UPCASE_TABLE       UpcaseTable,
    IN OUT  PNTFS_ATTRIBUTE_COLUMNS  AttributeDefTable,
    IN OUT  PNTFS_CHKDSK_REPORT      ChkdskReport,
    IN OUT  PNTFS_CHKDSK_INFO        ChkdskInfo,
    IN OUT  PMESSAGE                 Message
)
/*++

Routine Description:

    This routine initializes all the synchronization objects,
    creates the read-ahead thread, and start the processing
    routine.

Arguments:

    TotalNumberOfFrs - Supplies the total number of file record segment to process.
    DiskErrorFound   - Returns whether or not disk errors have been found.
    FixLevel         - Supplies the fix level.
    MftData          - Supplies the MFT's data attribute.
    MftBitmap        - Supplies the MFT bitmap.
    VolumeBitmap     - Supplies the volume bitmap.
    UpcaseTable      - Supplies the upcase table.
    AttributeDefTable- Supplies the attribute definition table.
    ChkdskReport     - Supplies the current chkdsk report.
    ChkdskInfo       - Supplies the current chkdsk info.
    Message          - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    RA_PROCESS_FILE             ra_process_file;
    HANDLE                      thread_handle;
    NTFS_FRS_STRUCTURE          frsstruc1, frsstruc2;
    HMEM                        hmem1, hmem2;
    HANDLE                      read_ahead_event;
    HANDLE                      read_ready_event;
    VCN                         first_frs_number;
    ULONG                       number_of_frs_to_read;
    BOOLEAN                     status;

    NTSTATUS                    ntstatus;
    LARGE_INTEGER               timeout;
    THREAD_BASIC_INFORMATION    basic_info;
    OBJECT_ATTRIBUTES           objAttr;


    if (TotalNumberOfFrs == 0)
        return TRUE;

    // create the read ahead event which signals when the read ahead thread should start reading

    InitializeObjectAttributes(&objAttr,
                               NULL,
                               0L,
                               NULL,
                               NULL);

    ntstatus = NtCreateEvent(&read_ahead_event,
                             EVENT_ALL_ACCESS,
                             &objAttr,
                             SynchronizationEvent,
                             FALSE                  // initial state
                             );

    if (!NT_SUCCESS(ntstatus)) {

        DebugPrintTrace(("UNTFS: Unable to create read ahead event (%x)\n", ntstatus));

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);

        return FALSE;
    }

    // create the read ready event which signals when the read is completed

    ntstatus = NtCreateEvent(&read_ready_event,
                             EVENT_ALL_ACCESS,
                             &objAttr,
                             SynchronizationEvent,
                             FALSE                  // initial state
                             );

    if (!NT_SUCCESS(ntstatus)) {

        NtClose(read_ahead_event);

        DebugPrintTrace(("UNTFS: Unable to create read ready event (%x)\n", ntstatus));

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);

        return FALSE;
    }

    RA_PROCESS_FILE::Initialize(this,
                                TotalNumberOfFrs,
                                &first_frs_number,
                                &number_of_frs_to_read,
                                &frsstruc1,
                                &frsstruc2,
                                &hmem1,
                                &hmem2,
                                read_ahead_event,
                                read_ready_event,
                                MftData,
                                UpcaseTable);

    // create the read ahead thread


    ntstatus = RtlCreateUserThread(NtCurrentProcess(),
                                   NULL,
                                   FALSE,
                                   0,
                                   0,
                                   0,
                                   RA_PROCESS_FILE::ProcessFilesWrapper,
                                   &ra_process_file,
                                   &thread_handle,
                                   NULL);

    if (!NT_SUCCESS(ntstatus)) {

        NtClose(read_ahead_event);
        NtClose(read_ready_event);

        Message->DisplayMsg(MSG_CHK_UNABLE_TO_CREATE_THREAD, "%d", ntstatus);
        return FALSE;
    }

    status = ProcessFiles(TotalNumberOfFrs,
                          &first_frs_number,
                          &number_of_frs_to_read,
                          DiskErrorFound,
                          &frsstruc1,
                          &frsstruc2,
                          read_ahead_event,
                          read_ready_event,
                          thread_handle,
                          FixLevel,
                          MftData,
                          MftBitmap,
                          VolumeBitmap,
                          UpcaseTable,
                          AttributeDefTable,
                          ChkdskReport,
                          ChkdskInfo,
                          Message);

    //
    // Clean up the read ahead thread if it is still alive
    //
    number_of_frs_to_read = 0;
    ntstatus = NtSetEvent(read_ahead_event, NULL);
    if (!NT_SUCCESS(ntstatus)) {
        DebugPrintTrace(("UNTFS: Unable to set read ahead event (%x)\n", ntstatus));
        NtClose(read_ahead_event);
        NtClose(read_ready_event);
        NtClose(thread_handle);
        return FALSE;
    }

    // wait for the read ahead thread to terminate

    timeout.QuadPart = -2000000000;  // 200 seconds
    ntstatus = NtWaitForSingleObject(thread_handle, FALSE, &timeout);
    if (ntstatus != STATUS_WAIT_0) {
        DebugPrintTrace(("UNTFS: NtWaitForSingleObject failed (%x)\n", ntstatus));
        NtClose(read_ahead_event);
        NtClose(read_ready_event);
        NtClose(thread_handle);
        return FALSE;
    }

    // check the exit code of the read ahead thread

    ntstatus = NtQueryInformationThread(thread_handle,
                                        ThreadBasicInformation,
                                        &basic_info,
                                        sizeof(basic_info),
                                        NULL);

    if (!NT_SUCCESS(ntstatus)) {
        DebugPrintTrace(("UNTFS: NtQueryInformationThread failed (%x)\n", ntstatus));
        NtClose(read_ahead_event);
        NtClose(read_ready_event);
        NtClose(thread_handle);
        return FALSE;
    }

    if (!NT_SUCCESS(basic_info.ExitStatus)) {
        DebugPrintTrace(("Premature termination of files read ahead thread (%x)\n", basic_info.ExitStatus));
        NtClose(read_ahead_event);
        NtClose(read_ready_event);
        NtClose(thread_handle);
        return FALSE;
    }

    NtClose(read_ahead_event);
    NtClose(read_ready_event);
    NtClose(thread_handle);

    return status;
}

UNTFS_EXPORT
RA_PROCESS_FILE::~RA_PROCESS_FILE(
)
{
    Destroy();
}

VOID
RA_PROCESS_FILE::Construct(
)
{
}

VOID
RA_PROCESS_FILE::Destroy(
)
{
}

NTSTATUS
RA_PROCESS_FILE::ProcessFilesWrapper(
    IN OUT PVOID      lpParameter
)
{
    return  RA_PROCESS_FILE::GetSa()->FilesReadAhead(RA_PROCESS_FILE::GetTotalNumberOfFrs(),
                                                     RA_PROCESS_FILE::GetFirstFrsNumber(),
                                                     RA_PROCESS_FILE::GetNumberOfFrsToRead(),
                                                     RA_PROCESS_FILE::GetFrsStruc1(),
                                                     RA_PROCESS_FILE::GetFrsStruc2(),
                                                     RA_PROCESS_FILE::GetHmem1(),
                                                     RA_PROCESS_FILE::GetHmem2(),
                                                     RA_PROCESS_FILE::GetReadAheadEvent(),
                                                     RA_PROCESS_FILE::GetReadReadyEvent(),
                                                     RA_PROCESS_FILE::GetMftData(),
                                                     RA_PROCESS_FILE::GetUpcaseTable());
}

BOOLEAN
RA_PROCESS_FILE::Initialize(
    IN      PNTFS_SA            Sa,
    IN      BIG_INT             TotalNumberOfFrs,
    IN      PVCN                FirstFrsNumber,
    IN      PULONG              NumberOfFrsToRead,
    IN      PNTFS_FRS_STRUCTURE FrsStruc1,
    IN      PNTFS_FRS_STRUCTURE FrsStruc2,
    IN      PHMEM               Hmem1,
    IN      PHMEM               Hmem2,
    IN      HANDLE              ReadAheadEvent,
    IN      HANDLE              ReadReadyEvent,
    IN      PNTFS_ATTRIBUTE     MftData,
    IN      PNTFS_UPCASE_TABLE  UpcaseTable
)
{
    _sa = Sa;
    _total_number_of_frs = TotalNumberOfFrs.GetQuadPart();
    _first_frs_number = FirstFrsNumber;
    _number_of_frs_to_read = NumberOfFrsToRead;
    _frsstruc1 = FrsStruc1;
    _frsstruc2 = FrsStruc2;
    _hmem1 = Hmem1;
    _hmem2 = Hmem2;
    _read_ahead_event = ReadAheadEvent;
    _read_ready_event = ReadReadyEvent;
    _mft_data = MftData;
    _upcase_table = UpcaseTable;

    return TRUE;
}

BOOLEAN
NTFS_SA::ProcessFiles(
    IN      BIG_INT                  TotalNumberOfFrs,
       OUT  PVCN                     FirstFrsNumber,
       OUT  PULONG                   NumberOfFrsToRead,
    IN OUT  PBOOLEAN                 DiskErrorFound,
    IN      PNTFS_FRS_STRUCTURE      FrsStruc1,
    IN      PNTFS_FRS_STRUCTURE      FrsStruc2,
    IN      HANDLE                   ReadAheadEvent,
       OUT  HANDLE                   ReadReadyEvent,
    IN      HANDLE                   ThreadHandle,
    IN      FIX_LEVEL                FixLevel,
    IN OUT  PNTFS_ATTRIBUTE          MftData,
    IN OUT  PNTFS_BITMAP             MftBitmap,
    IN OUT  PNTFS_BITMAP             VolumeBitmap,
    IN OUT  PNTFS_UPCASE_TABLE       UpcaseTable,
    IN OUT  PNTFS_ATTRIBUTE_COLUMNS  AttributeDefTable,
    IN OUT  PNTFS_CHKDSK_REPORT      ChkdskReport,
    IN OUT  PNTFS_CHKDSK_INFO        ChkdskInfo,
    IN OUT  PMESSAGE                 Message
)
/*++

Routine Description:

    This routine controls the read-ahead thread and
    checks each file record segment.

Arguments:

    TotalNumberOfFrs - Supplies the total number of file record segment to process.
    FirstFrsNumber   - Supplies the shared storage location for first frs number to be processed.
    NumberOfFrsToRead- Supplies the shared storage location to how many frs to read at a time.
    DiskErrorFound   - Returns whether or not disk errors have been found.
    FrsStruc1        - Supplies the shared frs object for read-ahead use.
    FrsStruc2        - Supplies the shared frs object for read-ahead use.
    ReadAheadEvent   - Supplies the event to trigger the read ahead thread to read ahead.
    ReadReadyEvent   - Supplies the event to tell this routine that data is ready.
    ThreadHandle     - Supplies the handle to the read-ahead thread.
    FixLevel         - Supplies the fix level.
    MftData          - Supplies the MFT's data attribute.
    MftBitmap        - Supplies the MFT bitmap.
    VolumeBitmap     - Supplies the volume bitmap.
    UpcaseTable      - Supplies the upcase table.
    AttributeDefTable- Supplies the attribute definition table.
    ChkdskReport     - Supplies the current chkdsk report.
    ChkdskInfo       - Supplies the current chkdsk info.
    Message          - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    VCN                                 i;
    BIG_INT                             time_to_read;
    PNTFS_FRS_STRUCTURE                 frsstruc;
    NTFS_ATTRIBUTE_LIST                 attr_list;
    BOOLEAN                             tube;
    NTFS_ATTRIBUTE_RECORD               attr_rec;
    BIG_INT                             cluster_count;
    MFT_SEGMENT_REFERENCE               seg_ref;
    ULONG                               entry_index;
    BOOLEAN                             changes;
    ULONG                               errFixedStatus = CHKDSK_EXIT_SUCCESS;

    ULONG                               num_boot_clusters;
    BIG_INT                             volume_clusters;
    BOOLEAN                             first_read;
    BOOLEAN                             read_status;
    ULONG                               percent_done;

    NTSTATUS                            ntstatus;
    THREAD_BASIC_INFORMATION            basic_info;
    LARGE_INTEGER                       timeout;

    *FirstFrsNumber = 0;
    if (TotalNumberOfFrs >= MFT_READ_CHUNK_SIZE)
        *NumberOfFrsToRead = MFT_READ_CHUNK_SIZE;
    else
        *NumberOfFrsToRead = TotalNumberOfFrs.GetLowPart();

    ntstatus = NtSetEvent(ReadAheadEvent, NULL);
    if (!NT_SUCCESS(ntstatus)) {
        DebugPrintTrace(("UNTFS: Unable to set read ahead event (%x)\n", ntstatus));
        return FALSE;
    }

    volume_clusters = QueryVolumeSectors()/((ULONG)QueryClusterFactor());
    num_boot_clusters = max(1, BYTES_PER_BOOT_SECTOR/
                               (_drive->QuerySectorSize()*
                                QueryClusterFactor()));

    Message->DisplayMsg(MSG_CHK_NTFS_CHECKING_FILES, PROGRESS_MESSAGE,
                        NORMAL_VISUAL,
                        "%d%d", 1, GetNumberOfStages());

    percent_done = 0;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

    frsstruc = FrsStruc2;
    time_to_read = 0;
    timeout.QuadPart = -2000000000;  // 200 seconds

    for (i = 0; i < TotalNumberOfFrs; i += 1) {

        if (i*100/TotalNumberOfFrs != percent_done) {
            percent_done = (i*100/TotalNumberOfFrs).GetLowPart();
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                return FALSE;
            }
        }

        if (i == time_to_read) {

            BIG_INT     remaining_frs;
            ULONG       number_to_read;
            ULONG       exit_code;

            ntstatus = NtWaitForSingleObject(ReadReadyEvent, FALSE, &timeout);
            if (ntstatus != STATUS_WAIT_0) {
                DebugPrintTrace(("UNTFS: NtWaitForSingleObject failed (%x)\n", ntstatus));
                return FALSE;
            }

            //
            // The advancing of frs number needs to keep in sync with that in FilesReadAhead
            //
            time_to_read += *NumberOfFrsToRead;
            *FirstFrsNumber = time_to_read;
            remaining_frs = TotalNumberOfFrs - time_to_read;

            if (remaining_frs.GetLowPart() < MFT_READ_CHUNK_SIZE &&
                remaining_frs.GetHighPart() == 0)
                *NumberOfFrsToRead = remaining_frs.GetLowPart();
            else
                *NumberOfFrsToRead = MFT_READ_CHUNK_SIZE;

            ntstatus = NtQueryInformationThread(ThreadHandle,
                                                ThreadBasicInformation,
                                                &basic_info,
                                                sizeof(basic_info),
                                                NULL);

            if (!NT_SUCCESS(ntstatus)) {
                DebugPrintTrace(("UNTFS: NtQueryInformationThread failed (%x)\n", ntstatus));
                return FALSE;
            }

            if (basic_info.ExitStatus != STATUS_PENDING && !NT_SUCCESS(basic_info.ExitStatus)) {
                DebugPrintTrace(("UNTFS: Premature termination of files read ahead thread (%x)\n",
                                 basic_info.ExitStatus));
                return FALSE;
            }

            ntstatus = NtSetEvent(ReadAheadEvent, NULL);
            if (!NT_SUCCESS(ntstatus)) {
                DebugPrintTrace(("UNTFS: NtSetEvent failed (%x)\n", ntstatus));
                return FALSE;
            }

            if (frsstruc == FrsStruc2)  {
                frsstruc = FrsStruc1;
            } else {
                frsstruc = FrsStruc2;
            }

            first_read = TRUE;
        }

        // Make sure the FRS is readable.  If it isn't then add it to
        // the list of unreadable FRSs.

        if (first_read) {
            first_read = FALSE;
            read_status = frsstruc->ReadAgain(i);
        } else
            read_status = frsstruc->ReadNext(i);

        if (!read_status) {

            *DiskErrorFound = TRUE;

            Message->DisplayMsg(MSG_CHK_NTFS_UNREADABLE_FRS,
                                "%d", i.GetLowPart());

            if (!ChkdskInfo->BadFiles.Add(i)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            continue;
        }

        if (i < FIRST_USER_FILE_NUMBER) {

            if (MASTER_FILE_TABLE_NUMBER + 1 == i) {

                // After verifying FRS 0, make sure that the
                // space for the internal MFT $DATA is allocated in
                // the internal Volume Bitmap.

                if (!MftData->MarkAsAllocated(VolumeBitmap)) {
                    Message->DisplayMsg(MSG_CHK_NTFS_BAD_MFT);
                    return FALSE;
                }

            } else if (BOOT_FILE_NUMBER == i) {

                // boot file $DATA will cover the boot sector as well
                // so mark it as free first
                VolumeBitmap->SetFree(0, num_boot_clusters);

                if (QueryVolumeSectors() == _drive->QuerySectors()) {
                    VolumeBitmap->SetFree(volume_clusters/2, num_boot_clusters);
                }
            } else if (BOOT_FILE_NUMBER + 1 == i) {

                // boot sector should have been marked as in use
                // but do it again
                VolumeBitmap->SetAllocated(0, num_boot_clusters);

                if (QueryVolumeSectors() == _drive->QuerySectors()) {
                    VolumeBitmap->SetAllocated(volume_clusters/2, num_boot_clusters);
                }

            }
        }

        // Ignore FRSs if they are not in use.

        if (!frsstruc->IsInUse()) {
#if defined(LOCATE_DELETED_FILE)
            frsstruc->LocateUnuseFrs(FixLevel,
                                     Message,
                                     AttributeDefTable,
                                     DiskErrorFound);
#endif
            continue;
        }


        // If the FRS is a child then just add it to the list of child
        // FRSs for later orphan detection.  Besides that just ignore
        // Child FRSs since they'll be validated with their parents.

        if (!frsstruc->IsBase()) {

            if (!ChkdskInfo->ChildFrs.Add(i)) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            continue;
        }


        // Verify and fix this base file record segment.

        if (!frsstruc->VerifyAndFix(FixLevel,
                                   Message,
                                   AttributeDefTable,
                                   DiskErrorFound)) {
            return FALSE;
        }

        // If this FRS was in very bad shape then it was marked as
        // not in use and should be ignored.

        if (!frsstruc->IsInUse()) {

            continue;
        }


        // Compare this LSN against the current highest LSN.

        if (frsstruc->QueryLsn() > LargestLsnEncountered) {
            LargestLsnEncountered = frsstruc->QueryLsn();
        }

        // Mark off this FRS in the MFT bitmap.

        MftBitmap->SetAllocated(i, 1);


        if (frsstruc->QueryAttributeList(&attr_list)) {

            // First verify the attribute list.

            if (!attr_list.VerifyAndFix(FixLevel,
                                        VolumeBitmap,
                                        Message,
                                        i,
                                        &tube,
                                        DiskErrorFound)) {
                return FALSE;
            }

            // Make sure that the attribute list has a correct
            // $STANDARD_INFORMATION entry and that the attribute
            // list is not cross-linked.  Otherwise tube it.

            if (!tube) {

                BOOLEAN     x1, x2;

                if (!attr_rec.Initialize(GetDrive(), frsstruc->GetAttributeList()) ||
                    !attr_rec.UseClusters(VolumeBitmap, &cluster_count)) {

                    Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_LIST,
                                        "%I64d", frsstruc->QueryFileNumber().GetLargeInteger());

                    DebugPrintTrace(("UNTFS: Cross-link in attr list.\n"));
                    DebugPrintTrace(("UNTFS: File 0x%I64x\n",
                                     frsstruc->QueryFileNumber().GetLargeInteger()));

                    tube = TRUE;

                } else if ((x1 = !attr_list.QueryExternalReference($STANDARD_INFORMATION,
                                                                   &seg_ref,
                                                                   &entry_index)) ||
                           (x2 = !(seg_ref == frsstruc->QuerySegmentReference()))) {

                    MSGID   msgid;

                    if (x1) {
                        msgid = MSG_CHKLOG_NTFS_STANDARD_INFORMATION_MISSING_FROM_ATTR_LIST;
                    } else {
                        DebugAssert(x2);
                        msgid = MSG_CHKLOG_NTFS_STANDARD_INFORMATION_OUTSIDE_BASE_FRS;
                    }
                    Message->LogMsg(msgid,
                                    "%I64x", frsstruc->QueryFileNumber().GetLargeInteger());

                    Message->DisplayMsg(MSG_CHK_NTFS_BAD_ATTR_LIST,
                                        "%d",
                                        frsstruc->QueryFileNumber().GetLowPart());

                    DebugPrintTrace(("UNTFS: Missing standard info in attr list.\n"));
                    DebugPrintTrace(("UNTFS: File 0x%I64x\n",
                                     frsstruc->QueryFileNumber().GetLargeInteger()));

                    attr_rec.UnUseClusters(VolumeBitmap, 0, 0);

                    tube = TRUE;
                }
            }

            if (tube) {

                // The attribute list needs to be tubed.

                frsstruc->DeleteAttributeRecord(frsstruc->GetAttributeList());

                if (FixLevel != CheckOnly && !frsstruc->Write()) {
                    Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                        "%d", frsstruc->QueryFileNumber().GetLowPart());
                    return FALSE;
                }


                // Then, treat this FRS as though there were no
                // attribute list, since there isn't any.

                if (!frsstruc->LoneFrsAllocationCheck(VolumeBitmap,
                                                     ChkdskReport,
                                                     ChkdskInfo,
                                                     FixLevel,
                                                     Message,
                                                     DiskErrorFound)) {
                    return FALSE;
                }

                if (!UpdateChkdskInfo(frsstruc, ChkdskInfo, Message)) {
                    return FALSE;
                }
                continue;
            }

            // Now, we have a valid attribute list.


            if (!VerifyAndFixMultiFrsFile(frsstruc,
                                          &attr_list,
                                          MftData,
                                          AttributeDefTable,
                                          VolumeBitmap,
                                          MftBitmap,
                                          ChkdskReport,
                                          ChkdskInfo,
                                          FixLevel,
                                          Message,
                                          DiskErrorFound)) {

                return FALSE;
            }


            if (!frsstruc->UpdateAttributeList(&attr_list,
                                              (FixLevel != CheckOnly))) {

                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

        } else {

            // The FRS has no children.  Just check that all
            // of the attribute records start at VCN 0 and
            // that the alloc length is right on non-residents.
            // Additionally, mark off the internal bitmap with
            // the space taken by the non-resident attributes.

            if (!frsstruc->LoneFrsAllocationCheck(VolumeBitmap,
                                                 ChkdskReport,
                                                 ChkdskInfo,
                                                 FixLevel,
                                                 Message,
                                                 DiskErrorFound)) {
                return FALSE;
            }

            if (!frsstruc->CheckInstanceTags(FixLevel, ChkdskInfo->Verbose, Message, &changes)) {
                return FALSE;
            }

            if (changes) {
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            }
        }

        if (!UpdateChkdskInfo(frsstruc, ChkdskInfo, Message)) {
            return FALSE;
        }
    }

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100)) {
        return FALSE;
    }
    Message->DisplayMsg(MSG_CHK_NTFS_FILE_VERIFICATION_COMPLETED, PROGRESS_MESSAGE);

    if (*DiskErrorFound) {
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    }

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}

NTSTATUS
NTFS_SA::FilesReadAhead(
    IN      BIG_INT              TotalNumberOfFrs,
    IN      PVCN                 FirstFrsNumber,
    IN      PULONG               NumberOfFrsToRead,
    IN      PNTFS_FRS_STRUCTURE  FrsStruc1,
    IN      PNTFS_FRS_STRUCTURE  FrsStruc2,
    IN      PHMEM                Hmem1,
    IN      PHMEM                Hmem2,
       OUT  HANDLE               ReadAhead,
    IN      HANDLE               ReadReady,
    IN      PNTFS_ATTRIBUTE      MftData,
    IN      PNTFS_UPCASE_TABLE   UpCaseTable
)
/*++

Routine Description:

    This routine performs the read-ahead action.

Arguments:

    TotalNumberOfFrs - Supplies the total number of file record segment to process.
    FirstFrsNumber   - Supplies the shared storage location for first frs number to be processed.
    NumberOfFrsToRead- Supplies the shared storage location to how many frs to read at a time.
    FrsStruc1        - Supplies the shared frs object for read-ahead use.
    FrsStruc2        - Supplies the shared frs object for read-ahead use.
    Hmem1            - Supplies the storage object for read-ahead use.
    Hmem2            - Supplies the storage object for read-ahead use.
    ReadAhead        - Supplies the event to trigger the read ahead thread to read ahead.
    ReadReady        - Supplies the event to tell this routine that data is ready.
    MftData          - Supplies the MFT's data attribute.
    UpcaseTable      - Supplies the upcase table.

Return Value:

    STATUS_SUCCESS   - Success

Notes:

    The HmemX objects are not shared directly.  They could be locally defined in
    this routine.  However, in the event of premature termination of this thread,
    the existance of these objects may save an AV.

--*/
{
    PNTFS_FRS_STRUCTURE     frsstruc = FrsStruc2;
    PHMEM                   hmem;
    NTSTATUS                ntstatus;

    if (!Hmem1->Initialize() ||
        !Hmem2->Initialize()) {
        DebugPrintTrace(("Out of memory\n"));
        NtTerminateThread(NtCurrentThread(), STATUS_NO_MEMORY);
        return STATUS_NO_MEMORY;
    }

    for(;;) {

        //
        // The advancing of frs number needs to keep in sync with that in ProcessFiles
        //

        ntstatus = NtWaitForSingleObject(ReadAhead, FALSE, NULL) ;
        if (ntstatus != STATUS_WAIT_0) {
            DebugPrintTrace(("UNTFS: NtWaitForSingleObject failed (%x)\n", ntstatus));
            NtTerminateThread(NtCurrentThread(), ntstatus);
            return ntstatus;
        }

        if (*NumberOfFrsToRead == 0)
            break;

        if (frsstruc == FrsStruc2) {
            frsstruc = FrsStruc1;
            hmem = Hmem1;
        } else {
            frsstruc = FrsStruc2;
            hmem = Hmem2;
        }
        if (!frsstruc->Initialize(hmem,
                                  MftData,
                                  *FirstFrsNumber,
                                  *NumberOfFrsToRead,
                                  QueryClusterFactor(),
                                  QueryVolumeSectors(),
                                  QueryFrsSize(),
                                  UpCaseTable)) {
            DebugPrintTrace(("Out of Memory\n"));
            NtTerminateThread(NtCurrentThread(), STATUS_NO_MEMORY);
            return STATUS_NO_MEMORY;
        }

        //
        // ignore the error as the main process will run into it again on ReadAgain()
        //
        frsstruc->ReadNext(*FirstFrsNumber);

#if 0
        LARGE_INTEGER   timeout;

        timeout.QuadPart = -10000;

        for (;;) {
            NtDelayExecution(FALSE, &timeout);
        }
#endif

        ntstatus = NtSetEvent(ReadReady, NULL);
        if (!NT_SUCCESS(ntstatus)) {
            DebugPrintTrace(("UNTFS: NtSetEvent failed (%x)\n", ntstatus));
            NtTerminateThread(NtCurrentThread(), ntstatus);
            return ntstatus;
        }
    }

    NtTerminateThread(NtCurrentThread(), STATUS_SUCCESS);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\ntfsvol.cxx ===
#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "ntfsvol.hxx"

#include "message.hxx"
#include "rtmsg.h"
#include "wstring.hxx"


DEFINE_CONSTRUCTOR( NTFS_VOL, VOL_LIODPDRV );

BOOLEAN
VerifyExtendedSpace(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      BIG_INT                 StartingCluster,
    IN      BIG_INT                 NumberClusters,
    IN OUT  PNUMBER_SET             BadClusters,
    IN OUT  PMESSAGE                Message
    );

VOID
NTFS_VOL::Construct (
    )

/*++

Routine Description:

    Constructor for NTFS_VOL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // unreferenced parameters
    (void)(this);
}


VOID
NTFS_VOL::Destroy(
    )
/*++

Routine Description:

    This routine returns a NTFS_VOL object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // unreferenced parameters
    (void)(this);
}


NTFS_VOL::~NTFS_VOL(
    )
/*++

Routine Description:

    Destructor for NTFS_VOL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

FORMAT_ERROR_CODE
NTFS_VOL::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      BOOLEAN     FormatMedia,
    IN      MEDIA_TYPE  MediaType,
    IN      BOOLEAN     ForceDismount    
    )
/*++

Routine Description:

    This routine initializes a NTFS_VOL object.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not the drive should be
                        opened for exclusive write.
    FormatMedia     - Supplies whether or not to format the media.
    MediaType       - Supplies the type of media to format to.
    ForceDismount   - Supplies whether the volume should be dismounted
                        and locked

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE             msg;
    FORMAT_ERROR_CODE   errcode;

    Destroy();

    errcode = VOL_LIODPDRV::Initialize(NtDriveName, &_ntfssa, Message,
                                       ExclusiveWrite, FormatMedia, MediaType, 
                                       DP_DRIVE::NONE, ForceDismount);

    if (errcode != NoError)
        return errcode;

    if (!Message) {
        Message = &msg;
    }

    if (!_ntfssa.Initialize(this, Message)) {
        return GeneralError;
    }

    if (!FormatMedia && !_ntfssa.Read(Message)) {
        return GeneralError;
    }

    return NoError;
}


PVOL_LIODPDRV
NTFS_VOL::QueryDupVolume(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      BOOLEAN     FormatMedia,
    IN      MEDIA_TYPE  MediaType
    ) CONST
/*++

Routine Description:

    This routine allocates a NTFS_VOL and initializes it to 'NtDriveName'.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not the drive should be
                        opened for exclusive write.
    FormatMedia     - Supplies whether or not to format the media.
    MediaType       - Supplies the type of media to format to.

Return Value:

    A pointer to a newly allocated NTFS volume.

--*/
{
    PNTFS_VOL   vol;

    // unreferenced parameters
    (void)(this);

    if (!(vol = NEW NTFS_VOL)) {
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return NULL;
    }

    if (!vol->Initialize(NtDriveName, Message, ExclusiveWrite,
                         FormatMedia, MediaType)) {
        DELETE(vol);
        return NULL;
    }

    return vol;
}

BOOLEAN
NTFS_VOL::Extend(
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     Verify,
    IN      BIG_INT     nsecOldSize
    )
/*++

Routine Description:

    This routine extends the volume.  Sector zero will already
    have been modified.

    The first thing to do is to write the duplicate boot sector
    at the end of the partition.  Then we'll verify the remaining
    new sectors.  Finally, we'll allocate a larger volume bitmap
    and add any bad clusters that were found to the bad cluster
    file.

Arguments:

    Message         - Supplies an outlet for messages.
    Verify          - Tells whether to verify the space that has been added.
    nsecOldSize     - Supplies the previous size of the volume, in sectors.

Return Value:

    TRUE if successful.

--*/
{
    HMEM                        hmem;
    BIG_INT                     last_sector;
    SECRUN                      secrun;
    NUMBER_SET                  bad_clusters;
    NTFS_MFT_FILE               mft;
    NTFS_UPCASE_TABLE           upcase_table;
    NTFS_ATTRIBUTE              upcase_attr;
    NTFS_ATTRIBUTE              volume_bitmap_attr;
    NTFS_BITMAP                 volume_bitmap;
    NTFS_BITMAP_FILE            bitmap_file;
    NTFS_UPCASE_FILE            upcase_file;
    NTFS_INDEX_TREE             root_index;
    NTFS_FILE_RECORD_SEGMENT    root_frs;
    NTFS_EXTENT_LIST            extents;
    NTFS_BOOT_FILE              boot_file;
    NTFS_ATTRIBUTE              boot_attr;
    DSTRING                     index_name;
    ULONG                       i;
    BIG_INT                     li, old_nclus;
    ULONG                       cluster_size;
    ULONG                       nclus_boot_area;
    BOOLEAN                     error;

    // QueryVolumeSectors will return a volume size one less than
    // the partition size.  Note that we'll be writing past the end of
    // the volume file.
    //

    last_sector = GetNtfsSuperArea()->QueryVolumeSectors();
    cluster_size = GetNtfsSuperArea()->QueryClusterFactor() * QuerySectorSize();
    old_nclus = nsecOldSize / GetNtfsSuperArea()->QueryClusterFactor();

    if (!mft.Initialize(this,
                        GetNtfsSuperArea()->QueryMftStartingLcn(),
                        GetNtfsSuperArea()->QueryClusterFactor(),
                        GetNtfsSuperArea()->QueryFrsSize(),
                        GetNtfsSuperArea()->QueryVolumeSectors(),
                        NULL, NULL) ||
        !mft.Read() ||
        !bitmap_file.Initialize(mft.GetMasterFileTable()) ||
        !bitmap_file.Read() ||
        !bitmap_file.QueryAttribute(&volume_bitmap_attr, &error, $DATA) ||
        !volume_bitmap.Initialize(old_nclus, TRUE) ||
        !bad_clusters.Initialize()) {

        return FALSE;
    }


    if (!volume_bitmap.Read(&volume_bitmap_attr) ||
        !upcase_file.Initialize(mft.GetMasterFileTable()) ||
        !upcase_file.Read() ||
        !upcase_file.QueryAttribute(&upcase_attr, &error, $DATA) ||
        !upcase_table.Initialize(&upcase_attr) ||
        !mft.Initialize(this,
                        GetNtfsSuperArea()->QueryMftStartingLcn(),
                        GetNtfsSuperArea()->QueryClusterFactor(),
                        GetNtfsSuperArea()->QueryFrsSize(),
                        GetNtfsSuperArea()->QueryVolumeSectors(),
                        &volume_bitmap,
                        &upcase_table) ||
        !mft.Read()) {

        return FALSE;
    }

    if (!index_name.Initialize("$I30") ||
        !root_frs.Initialize(ROOT_FILE_NAME_INDEX_NUMBER, &mft) ||
        !root_frs.Read()) {
        return FALSE;
    }

    if (!root_index.Initialize(this, GetNtfsSuperArea()->QueryClusterFactor(),
        &volume_bitmap, &upcase_table, root_frs.QuerySize(), &root_frs, &index_name)) {

        return FALSE;
    }

    //
    // Truncate the boot file to be just the sector 0 boot area.
    //

    nclus_boot_area = (BYTES_IN_BOOT_AREA % cluster_size) ?
                        BYTES_IN_BOOT_AREA / cluster_size + 1 :
                        BYTES_IN_BOOT_AREA / cluster_size;

    if (!boot_file.Initialize(mft.GetMasterFileTable()) ||
        !boot_file.Read() ||
        !boot_file.QueryAttribute(&boot_attr, &error, $DATA) ||
        !boot_attr.Resize(nclus_boot_area * cluster_size, &volume_bitmap) ||
        !boot_attr.InsertIntoFile(&boot_file, &volume_bitmap) ||
        !boot_file.Flush(&volume_bitmap, &root_index)) {

        return FALSE;
    }

    //
    // Grow the bitmap to represent the new volume size.
    //

    if (!volume_bitmap.Resize(GetNtfsSuperArea()->QueryVolumeSectors() /
        GetNtfsSuperArea()->QueryClusterFactor())) {

        return FALSE;
    }

    // The volume bitmap may have set bits at the end, beyond the end of
    // the old volume, because format pads the bitmap that way.  We clear
    // those bits because they don't make sense for the new volume.
    //

    for (li = old_nclus; li < old_nclus + 64; li += 1) {

        volume_bitmap.SetFree(li, 1);
    }

    // We won't want to resize the bitmap again, and the volume bitmap is
    // usually considered non-growable, so make it that way now.  This will
    // have the size-effect of setting the padding bits at the end.
    //

    volume_bitmap.SetGrowable(FALSE);

    //
    // Copy the boot sector to the end of the partition.
    //

    if (!secrun.Initialize(&hmem, this, 0, 1)) {

        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }
    if (!secrun.Read()) {
        //Message->DisplayMsg(MSG_DEVICE_ERROR);
        return FALSE;
    }

    secrun.Relocate(last_sector);

    if (!secrun.Write()) {
        //Message->DisplayMsg(MSG_DEVICE_ERROR);
        return FALSE;
    }

    if (Verify) {

        if (!VerifyExtendedSpace(mft.GetMasterFileTable(),
                                  nsecOldSize - 1,
                                  (last_sector + 1) - nsecOldSize,
                                  &bad_clusters,
                                  Message)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
    }

    if (!volume_bitmap_attr.MakeNonresident(&volume_bitmap) ||
        !volume_bitmap.Write(&volume_bitmap_attr, &volume_bitmap)) {

        if (!volume_bitmap_attr.RecoverAttribute(&volume_bitmap, &bad_clusters) ||
            !volume_bitmap.Write(&volume_bitmap_attr, &volume_bitmap)) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_VOLUME_BITMAP);
            return FALSE;
        }
    }

    if (!volume_bitmap_attr.InsertIntoFile(&bitmap_file, &volume_bitmap) ||
        !bitmap_file.Flush(&volume_bitmap, &root_index)) {

        return FALSE;
    }

    return TRUE;
}

//
// Local support routine
//

BOOLEAN
VerifyExtendedSpace(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN      BIG_INT                 StartingCluster,
    IN      BIG_INT                 NumberClusters,
    IN OUT  PNUMBER_SET             BadClusters,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine verifies all of the unused clusters on the disk.
    It adds any that are bad to the given bad cluster list.

Arguments:

    StartingCluster - Supplies the cluster to start verifying at.
    NumberClusters  - Supplies the number of clusters to verify.
    BadClusters     - Supplies the current list of bad clusters.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    PLOG_IO_DP_DRIVE    drive;
    PNTFS_BITMAP        bitmap;
    BIG_INT             i, len;
    ULONG               percent_done;
    NUMBER_SET          bad_sectors;
    ULONG               cluster_factor;
    BIG_INT             start, run_length, next;
    ULONG               j;

    Message->DisplayMsg(MSG_CHK_RECOVERING_FREE_SPACE, PROGRESS_MESSAGE);

    drive = Mft->GetDataAttribute()->GetDrive();
    bitmap = Mft->GetVolumeBitmap();
    cluster_factor = Mft->QueryClusterFactor();

    percent_done = 0;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

    for (i = 0; i < NumberClusters; ) {

        len = min(NumberClusters - i, 100);

        if (len < 1) {
            break;
        }

        if (!bad_sectors.Initialize() ||
            !drive->Verify((i + StartingCluster) * cluster_factor,
                           len*cluster_factor,
                           &bad_sectors)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        for (j = 0; j < bad_sectors.QueryNumDisjointRanges(); j++) {

            bad_sectors.QueryDisjointRange(j, &start, &run_length);
            next = start + run_length;

            // Adjust start and next to be on cluster boundaries.
            start = start/cluster_factor;
            next = (next - 1)/cluster_factor + 1;

            // Add the bad clusters to the bad cluster list.
            if (!BadClusters->Add(start, next - start)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            // Mark the bad clusters as allocated in the bitmap.
            bitmap->SetAllocated(start, next - start);
        }

        i += len;

        if (100*i/NumberClusters > percent_done) {
            percent_done = (100*i/NumberClusters).GetLowPart();
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                return FALSE;
            }
        }
    }

    percent_done = 100;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
        return FALSE;
    }

    Message->DisplayMsg(MSG_CHK_DONE_RECOVERING_FREE_SPACE, PROGRESS_MESSAGE);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ureg\src\makefile.inc ===
!IF !$(FREEBUILD)

$(O)\ureg.def: ..\def$(TARGET_DIRECTORY).fre ..\def$(TARGET_DIRECTORY).dbg
        copy ..\def$(TARGET_DIRECTORY).fre + ..\def$(TARGET_DIRECTORY).dbg $(O)\ureg.def

!ELSE

$(O)\ureg.def: ..\def$(TARGET_DIRECTORY).fre
        copy ..\def$(TARGET_DIRECTORY).fre $(O)\ureg.def

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\sdchk.cxx ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    sdchk.cxx

Abstract:

    This module implements Security Descriptors Checking.

Author:

    Daniel Chan (danielch) 30-Sept-96

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

//#define TIMING_ANALYSIS     1

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
extern "C" {
    #include <stdio.h>
    #include <time.h>
}
#endif

#include "ulib.hxx"
#include "ntfssa.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "ntfsbit.hxx"
#include "attrcol.hxx"
#include "frsstruc.hxx"
#include "attrib.hxx"
#include "attrrec.hxx"
#include "attrlist.hxx"
#include "list.hxx"
#include "iterator.hxx"
#include "attrdef.hxx"
#include "extents.hxx"
#include "mft.hxx"
#include "mftref.hxx"
#include "bootfile.hxx"
#include "badfile.hxx"
#include "mftfile.hxx"
#include "numset.hxx"
#include "ifssys.hxx"
#include "indxtree.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
#include "frs.hxx"
#include "digraph.hxx"
#include "logfile.hxx"
#include "rcache.hxx"
#include "ifsentry.hxx"
#include "sdchk.hxx"
#include "spaset.hxx"

typedef struct _REPAIR_RECORD {
    ULONG   Offset;
    ULONG   Length;
};

DEFINE_TYPE(_REPAIR_RECORD, REPAIR_RECORD);

ULONG
ComputeDefaultSecurityId(
   PNUMBER_SET  SidSet
);

VOID
ClearSecurityDescriptorEntry(
    IN OUT  PSECURITY_ENTRY Security_entry,
    IN      ULONG           SecurityDescriptorSize
);

BOOLEAN
RecoverSecurityDescriptorsDataStream(
    IN OUT PNTFS_FILE_RECORD_SEGMENT    Frs,
    IN OUT PNTFS_ATTRIBUTE              Attrib,
    IN     ULONG                        AttributeSize,
    IN     PCHAR                        Buffer,
    IN     ULONG                        BufferSize,
    IN     ULONG                        ClusterSize,
    IN OUT PNTFS_BITMAP                 Bitmap,
    OUT    PBOOLEAN                     DiskHasErrors,
    IN OUT PNUMBER_SET                  BadClusters,
    IN OUT PMESSAGE                     Message,
    IN     BOOLEAN                      FixLevel
);

BOOLEAN
RepairSecurityDescriptorsSegment(
    IN OUT  PNTFS_ATTRIBUTE Attrib,
    IN      PCHAR           Buffer,
    IN      ULONG           Offset,
    IN      ULONG           BytesToProcess,
    IN OUT  PREPAIR_RECORD  Record,
    IN OUT  USHORT          *RecordCount,
    IN      ULONG           ClusterSize
);

#if defined( _SETUP_LOADER_ )

BOOLEAN
NTFS_SA::ValidateSecurityDescriptors(
    IN      PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT     ChkdskReport,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PNUMBER_SET             BadClusters,
    IN      BOOLEAN                 SkipEntriesScan,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine ensures that every file on the disk contains
    a valid security descriptor.

Arguments:

    ChkdskInfo  - Supplies the current chkdsk information.
    ChkdskReport- Supplies the current chkdsk report.
    Mft         - Supplies a valid MFT.
    BadClusters - Receives the bad clusters identified by this method.
    FixLevel    - Supplies the fix level.
    Message     - Supplies an outlet for messages

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    // Stub for Setup Loader.

    return TRUE;
}

#else // not _SETUP_LOADER_

BOOLEAN
NTFS_SA::ValidateSecurityDescriptors(
    IN      PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT     ChkdskReport,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PNUMBER_SET             BadClusters,
    IN      BOOLEAN                 SkipEntriesScan,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine ensures that every file on the disk contains
    a valid security descriptor.  If that's not the case, then
    it expects to find the $SDS data stream in $Secure and each
    of those files contain a security id.

Arguments:

    ChkdskInfo  - Supplies the current chkdsk information.
    Mft         - Supplies a valid MFT.
    FixLevel    - Supplies the fix level.
    Message     - Supplies an outlet for messages

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    myfrs;
    PNTFS_FILE_RECORD_SEGMENT   pfrs;
    NTFS_FILE_RECORD_SEGMENT    security_frs;
    ULONG                       i, n;
    ULONG                       percent;
    NTFS_ATTRIBUTE              attrib;
    NTFS_ATTRIBUTE              SDS_attrib;
    NTFS_ATTRIBUTE              SII_attrib;
    BOOLEAN                     error;
    BOOLEAN                     hasErrors = FALSE;
    BOOLEAN                     diskHasErrors;
    BOOLEAN                     chkdskErrCouldNotFix = FALSE;
    BOOLEAN                     chkdskCleanUp = FALSE;
    ULONG                       cleanup_count;
    BOOLEAN                     attribute_need_write = FALSE;
    BOOLEAN                     frs_need_flush = FALSE;
    BOOLEAN                     index_need_save = FALSE;
    BOOLEAN                     attribute_need_resize;
    BOOLEAN                     boundary_problem_found;
    BOOLEAN                     insufficient_security_desctiptor_block_free_space;
    BOOLEAN                     lastblock;
    BOOLEAN                     fixing_mirror;
    ULONG                       length;
    ULONG                       num_bytes;
    BOOLEAN                     securityDescriptorStreamPresent = FALSE;
    BOOLEAN                     alreadyExists;
    BOOLEAN                     new_SII_index = FALSE;
    BOOLEAN                     new_SDH_index = FALSE;
    BOOLEAN                     alloc_present;
    DSTRING                     SII_IndexName;
    DSTRING                     SDH_IndexName;
    DSTRING                     indexName;
    ULONG                       hash, offset;
    ULONG                       bytesWritten;
    BIG_INT                     hashkey;
    NUMBER_SET                  sid_entries, sid_entries2;
    SPARSE_SET                  hashkey_entries;
    NTFS_INDEX_TREE             SII_Index;
    NTFS_INDEX_TREE             SDH_Index;
    ULONG                       count_sid = 0;
    ULONG                       count_hashkey = 0;
    PCINDEX_ENTRY               index_entry;
    ULONG                       depth;
    ULONG                       securityId;
    ULONG                       defaultSecurityId = 0;
    PSECURITY_ENTRY             security_entry = NULL;
    PSECURITY_ENTRY             previous_security_entry;
    PSECURITY_ENTRY             previous_previous_security_entry;
    PSECURITY_ENTRY             initial_security_entry = NULL;
    PSECURITY_ENTRY             endOfBlock;
    ULONG                       lengthUptoPreviousBlock;
    ULONG                       resizeTo;
    ULONG                       remain_length;
    ULONG                       bytesToRead;
    ULONG                       lengthOfBlock;
    ULONG                       align_num_bytes;
    ULONG                       se_offset;
    ULONG                       total_length;
    ULONG                       sdLength;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
    time_t                      time1, time2;
    PCHAR                       timestr;
#endif

    DebugPtrAssert(ChkdskInfo);
    DebugPtrAssert(ChkdskReport);

    Message->DisplayMsg(MSG_CHK_NTFS_CHECKING_SECURITY, PROGRESS_MESSAGE,
                        NORMAL_VISUAL,
                        "%d%d", 3, GetNumberOfStages());

    // Check for existence of $SecurityDescriptorStream in SECURITY_TABLE_NUMBER

    if (!security_frs.Initialize(SECURITY_TABLE_NUMBER, Mft) ||
        !indexName.Initialize(SecurityDescriptorStreamNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    // ??what to do if frs is unreadable or not in use or not a base??

    if (security_frs.Read() && security_frs.IsInUse() && security_frs.IsBase()) {
        securityDescriptorStreamPresent =
            security_frs.QueryAttribute(&SDS_attrib,
                                        &error,
                                        $DATA,
                                        &indexName) &&
            ChkdskInfo->major >= 2;

        if (!error && !securityDescriptorStreamPresent && ChkdskInfo->major >= 2) {
            // delete all $DATA attribute first
            while (security_frs.QueryAttribute(&SDS_attrib, &error, $DATA, 0)) {

                Message->DisplayMsg(MSG_CHKLOG_NTFS_UNKNOWN_SECURITY_DATA_STREAM,
                                    "%W%I64x",
                                    SDS_attrib.GetName(),
                                    security_frs.QueryFileNumber().GetLargeInteger());

                if (!SDS_attrib.Resize(0, Mft->GetVolumeBitmap()) ||
                    !security_frs.PurgeAttribute(SDS_attrib.QueryTypeCode(),
                                                 SDS_attrib.GetName())) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }
            }
            if (error) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            Message->LogMsg(MSG_CHKLOG_NTFS_SECURITY_DATA_STREAM_MISSING,
                         "%I64x", security_frs.QueryFileNumber().GetLargeInteger());

            // now create the $DATA, $SDS stream
            if (!SDS_attrib.Initialize(_drive,
                                       QueryClusterFactor(),
                                       NULL,
                                       0,
                                       $DATA,
                                       &indexName)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            if (!SDS_attrib.InsertIntoFile(&security_frs,
                                           Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
                return FALSE;
            }
            if (FixLevel != CheckOnly &&
                !security_frs.Flush(Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
                return FALSE;
            }
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            hasErrors = TRUE;
            securityDescriptorStreamPresent = TRUE;
        }
        if (!error && securityDescriptorStreamPresent) {

            if (!SII_IndexName.Initialize(SecurityIdIndexNameData) ||
                !SDH_IndexName.Initialize(SecurityDescriptorHashIndexNameData)) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            // make sure the $SII index exists
            // if it does not exists, an empty one will be created

            if (!SII_Index.Initialize(_drive,
                                      QueryClusterFactor(),
                                      Mft->GetVolumeBitmap(),
                                      Mft->GetUpcaseTable(),
                                      security_frs.QuerySize()/2,
                                      &security_frs,
                                      &SII_IndexName)) {
                Message->DisplayMsg(MSG_CHK_NTFS_CREATE_INDEX,
                                    "%W%d", &SII_IndexName, SECURITY_TABLE_NUMBER);
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                hasErrors = TRUE;
                if (!SII_Index.Initialize(0,
                                          _drive,
                                          QueryClusterFactor(),
                                          Mft->GetVolumeBitmap(),
                                          Mft->GetUpcaseTable(),
                                          COLLATION_ULONG,
                                          SMALL_INDEX_BUFFER_SIZE,
                                          security_frs.QuerySize()/2,
                                          &SII_IndexName)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                }

                if (FixLevel != CheckOnly &&
                    (!SII_Index.Save(&security_frs) ||
                     !security_frs.Flush(Mft->GetVolumeBitmap()))) {
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                        "%d%W",
                                        security_frs.QueryFileNumber().GetLowPart(),
                        &SII_IndexName);
                    return FALSE;
                }
                ChkdskReport->NumIndices += 1;
                new_SII_index = TRUE;
            }

            // make sure the $SDH index exists
            // if it does not exists, an empty one will be created

            if (!SDH_Index.Initialize(_drive,
                                      QueryClusterFactor(),
                                      Mft->GetVolumeBitmap(),
                                      Mft->GetUpcaseTable(),
                                      security_frs.QuerySize()/2,
                                      &security_frs,
                                      &SDH_IndexName)) {
                Message->DisplayMsg(MSG_CHK_NTFS_CREATE_INDEX,
                                    "%W%d", &SDH_IndexName, SECURITY_TABLE_NUMBER);
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                hasErrors = TRUE;
                if (!SDH_Index.Initialize(0,
                                          _drive,
                                          QueryClusterFactor(),
                                          Mft->GetVolumeBitmap(),
                                          Mft->GetUpcaseTable(),
                                          COLLATION_SECURITY_HASH,
                                          SMALL_INDEX_BUFFER_SIZE,
                                          security_frs.QuerySize()/2,
                                          &SDH_IndexName)) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY,
                                        "%d%W",
                                        security_frs.QueryFileNumber().GetLowPart(),
                                        &SDH_IndexName);
                    return FALSE;
                }

                if (FixLevel != CheckOnly &&
                    (!SDH_Index.Save(&security_frs) ||
                     !security_frs.Flush(Mft->GetVolumeBitmap()))) {
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                        "%d%W",
                                        security_frs.QueryFileNumber().GetLowPart(),
                                        &SDH_IndexName);
                    return FALSE;
                }
                ChkdskReport->NumIndices += 1;
                new_SDH_index = TRUE;
            }

            // Read in the security descriptor and validate.

            length = SDS_attrib.QueryValueLength().GetLowPart();

            // allocate space for a block of security descriptors

            if (SDS_attrib.QueryValueLength().GetHighPart() != 0 ||
                !(initial_security_entry = (SECURITY_ENTRY*)
                                   MALLOC(SecurityDescriptorsBlockSize))) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }

            if (!RecoverSecurityDescriptorsDataStream(
                    &security_frs,
                    &SDS_attrib,
                    length,
                    (PCHAR)initial_security_entry,
                    SecurityDescriptorsBlockSize,
                    _drive->QuerySectorSize()*QueryClusterFactor(),
                    Mft->GetVolumeBitmap(),
                    &diskHasErrors,
                    BadClusters,
                    Message,
                    FixLevel)) {
                FREE(initial_security_entry);
                return FALSE;
            } else if (diskHasErrors) {
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                hasErrors = TRUE;

                if (FixLevel == CheckOnly) {

                    //
                    //  In case of readonly mode, chkdsk shouldn't continue as it may run into
                    //  the unreadable clusters
                    //

                    FREE(initial_security_entry);
                    Message->DisplayMsg(MSG_CHK_NTFS_SECURITY_VERIFICATION_COMPLETED, PROGRESS_MESSAGE);

                    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

                    if (chkdskErrCouldNotFix)
                        ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
                    else if (chkdskCleanUp) {
                        _cleanup_that_requires_reboot = TRUE;
                        if (ChkdskInfo->ExitStatus == CHKDSK_EXIT_SUCCESS)
                            ChkdskInfo->ExitStatus = CHKDSK_EXIT_MINOR_ERRS;
                    }
                    return TRUE;

                } else if (!security_frs.Flush(Mft->GetVolumeBitmap())) {

                    Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                        "%d", security_frs.QueryFileNumber().GetLowPart());
                    FREE(initial_security_entry);
                    return FALSE;
                }
            }

            // get the actual length of the first copy of security descriptor data

            if (length < SecurityDescriptorsBlockSize) {

                // Resize the whole thing to zero length

                Message->LogMsg(MSG_CHKLOG_NTFS_SECURITY_DATA_STREAM_SIZE_TOO_SMALL,
                             "%x%x",
                             length,
                             SecurityDescriptorsBlockSize);

                attribute_need_resize = TRUE;
                length = 0;
            } else {
                attribute_need_resize = FALSE;
                length -= SecurityDescriptorsBlockSize;
            }

            offset = 0;
            lengthUptoPreviousBlock = 0;
            frs_need_flush = FALSE;
            boundary_problem_found = FALSE;
            resizeTo = 0;
            endOfBlock = (PSECURITY_ENTRY)((PCHAR)initial_security_entry+
                                           SecurityDescriptorsBlockSize);
            remain_length = length;

            if (!sid_entries.Initialize() ||
                !sid_entries2.Initialize() ||
                !hashkey_entries.Initialize()) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                FREE(initial_security_entry);
                return FALSE;
            }

            for (;length > 0;) {
                previous_previous_security_entry = previous_security_entry = NULL;
                attribute_need_write = FALSE;
                bytesToRead = min(SecurityDescriptorsBlockSize, length);
                security_entry = initial_security_entry;
                if (!SDS_attrib.Read(security_entry,
                                     offset,
                                     bytesToRead, &num_bytes) ||
                    num_bytes != bytesToRead) {
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_READ_SECURITY_DATA_STREAM);
                    FREE(initial_security_entry);
                    return FALSE;
                }

                lastblock = length <= SecurityDescriptorsBlockSize;
                lengthOfBlock = 0;

                // Validate each security descriptor record in the data stream

                while (length > 0) {

                    // Check if there is a violation of the guarantee that:
                    // There will be atleast enough space for the
                    // SECURITY_DESCRIPTOR_HEADER at the end of the SD block

                    insufficient_security_desctiptor_block_free_space
                          = ((security_entry != endOfBlock) &&
                             ((PCHAR)security_entry-(PCHAR)initial_security_entry+
                              sizeof(SECURITY_DESCRIPTOR_HEADER) >
                              SecurityDescriptorsBlockSize));


                    // see if there is a need to move to next security descriptor block

                    if ((security_entry == endOfBlock) ||
                        (!insufficient_security_desctiptor_block_free_space &&
                         (security_entry->security_descriptor_header.Length == 0 &&
                          security_entry->security_descriptor_header.HashKey.SecurityId == 0 &&
                          security_entry->security_descriptor_header.HashKey.Hash == 0))) {
                        if (!lastblock &&
                            (remain_length >= (SecurityDescriptorsBlockSize<<1))) {
                            lengthOfBlock = (ULONG)((PCHAR)security_entry-
                                                    (PCHAR)initial_security_entry);
                            if (!RemainingBlockIsZero((PCHAR)security_entry,
                                    (ULONG)((PCHAR)endOfBlock-(PCHAR)security_entry))) {
                                MarkEndOfSecurityDescriptorsBlock(security_entry,
                                    (ULONG)((PCHAR)endOfBlock-(PCHAR)security_entry));

                                Message->LogMsg(MSG_CHKLOG_NTFS_REMAINING_SECURITY_DATA_BLOCK_CONTAINS_NON_ZERO,
                                             "%x%x",
                                             offset+lengthOfBlock,
                                             (ULONG)((PCHAR)endOfBlock-(PCHAR)security_entry));

                                DebugPrint("Clearing till end of the security descriptors block.\n");
                                attribute_need_write = TRUE;
                            }
                            break;
                        } else
                            boundary_problem_found = TRUE;
                    }

                    if (!insufficient_security_desctiptor_block_free_space) {
                        num_bytes = security_entry->security_descriptor_header.Length;
                    }


                    align_num_bytes = (num_bytes + 0xf) & ~0xf;
                    error = FALSE;
                    if (boundary_problem_found) {

                        // loglog
                        error = TRUE;
                    } else if (insufficient_security_desctiptor_block_free_space) {

                        // do we want to log this?
                        // This condition will be detected and the previous SD will be
                        // deleted to fix this condition in the if(error) block
                        error = TRUE;
                    }else if ((PCHAR)security_entry-(PCHAR)initial_security_entry+
                               num_bytes > SecurityDescriptorsBlockSize) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_SDS_ENTRY_CROSSES_PAGE_BOUNDARY,
                                     "%x%x",
                                     offset+((PCHAR)security_entry-(PCHAR)initial_security_entry),
                                     num_bytes
                                     );
                        error = TRUE;
                    } else if (num_bytes < sizeof(SECURITY_ENTRY)) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_SDS_ENTRY_LENGTH_TOO_SMALL,
                                     "%x%x%x",
                                     offset+((PCHAR)security_entry-(PCHAR)initial_security_entry),
                                     num_bytes,
                                     sizeof(SECURITY_ENTRY));
                        error = TRUE;
                    } else if (num_bytes > SecurityDescriptorMaxSize) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_SDS_ENTRY_LENGTH_EXCEEDS_PAGE_BOUNDARY,
                                     "%x%x%x",
                                     offset+((PCHAR)security_entry-(PCHAR)initial_security_entry),
                                     num_bytes,
                                     SecurityDescriptorMaxSize
                                     );
                        error = TRUE;
                    } else if (length < sizeof(SECURITY_ENTRY)) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_SDS_REMAINING_PAGE_LENGTH_TOO_SMALL,
                                     "%x%x%x",
                                     offset+((PCHAR)security_entry-(PCHAR)initial_security_entry),
                                     length,
                                     sizeof(SECURITY_ENTRY));
                        error = TRUE;
                    } else if (length != num_bytes && length < align_num_bytes) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_SDS_REMAINING_PAGE_LENGTH_TOO_SMALL,
                                     "%x%x%x",
                                     offset+((PCHAR)security_entry-(PCHAR)initial_security_entry),
                                     length,
                                     align_num_bytes);
                        error = TRUE;
                    }

                    if (error) {

                        boundary_problem_found = FALSE;
                        if (!lastblock) {
                            if ((PCHAR)security_entry-(PCHAR)initial_security_entry+
                                sizeof(SECURITY_DESCRIPTOR_HEADER) <=
                                SecurityDescriptorsBlockSize) {
                                MarkEndOfSecurityDescriptorsBlock(security_entry,
                                                                  (ULONG)((PCHAR)endOfBlock-
                                                                          (PCHAR)security_entry));
                                if (previous_security_entry)
                                    lengthOfBlock = (ULONG)((PCHAR)previous_security_entry -
                                                            (PCHAR)initial_security_entry) +
                                                            previous_security_entry->security_descriptor_header.Length;
                                else
                                    lengthOfBlock = 0;
                            } else if (previous_security_entry) {
                                sid_entries.Remove(previous_security_entry->
                                    security_descriptor_header.HashKey.SecurityId);
                                hashkey.Set(previous_security_entry->
                                    security_descriptor_header.HashKey.Hash,
                                    previous_security_entry->
                                    security_descriptor_header.HashKey.SecurityId);
                                hashkey_entries.CheckAndRemove(hashkey);

                                // the index entry will automatically be removed at a later stage

                                MarkEndOfSecurityDescriptorsBlock(previous_security_entry,
                                                            (ULONG)((PCHAR)endOfBlock-
                                                                    (PCHAR)previous_security_entry));
                                if (previous_previous_security_entry) {
                                    lengthOfBlock = (ULONG)((PCHAR)previous_previous_security_entry -
                                                            (PCHAR)initial_security_entry) +
                                                            previous_previous_security_entry->
                                                                security_descriptor_header.Length;
                                } else {
                                    lengthOfBlock = 0;
                                }
                            } else {
                                DebugAssert(FALSE);

                                // It doesn't make much sense to get here.
                                // If we don't have a previous_security_entry then
                                // security_entry is at the beginning of the block
                                // and should have enough space to include the EOB
                                // mark.

                            }
                            attribute_need_write = TRUE;
                            DebugPrint("Clearing till end of the security descriptors block.\n");
                        } else { // if lastblock
                            if (previous_security_entry) {
                                DebugAssert(remain_length <= SecurityDescriptorsBlockSize);

                                if (!insufficient_security_desctiptor_block_free_space) {
                                    bytesToRead = remain_length = lengthOfBlock =
                                        (ULONG)((PCHAR)previous_security_entry-
                                                (PCHAR)initial_security_entry+
                                                previous_security_entry->
                                                 security_descriptor_header.Length);
                                } else {
                                    // delete the previous entry as well to ensure that
                                    // there is atleast space for one security descriptor
                                    // header
                                    bytesToRead = remain_length = lengthOfBlock =
                                        (ULONG)((PCHAR)previous_security_entry-
                                                (PCHAR)initial_security_entry);
                                }
                                resizeTo = lengthOfBlock + offset;
                            } else {
                                bytesToRead = remain_length = lengthOfBlock = 0;
                                resizeTo = lengthUptoPreviousBlock;
                                DebugAssert(!attribute_need_write);
                            }
                            attribute_need_resize = TRUE;   // no need to write attribute
                            DebugPrint("Truncating the security descriptors block.\n");
                        }
                        break;
                    }

                    // skip over invalidated entries

                    securityId = security_entry->security_descriptor_header.HashKey.SecurityId;
                    if (securityId == SECURITY_ID_INVALID)
                        goto GetNextSDEntry;

                    sdLength = num_bytes - sizeof(SECURITY_DESCRIPTOR_HEADER);
                    if (!IFS_SYSTEM::CheckValidSecurityDescriptor(
                            sdLength,
                            (PISECURITY_DESCRIPTOR)&(security_entry->security)) ||
                        sdLength < RtlLengthSecurityDescriptor(
                                        &(security_entry->security))) {

                        // the data part is invalid
                        // fill the whole thing with zeros except the length byte in the header

                        Message->LogMsg(MSG_CHKLOG_NTFS_INVALID_SECURITY_DESCRIPTOR_IN_SDS_ENTRY,
                                     "%x%x",
                                     offset+((PCHAR)security_entry-(PCHAR)initial_security_entry),
                                     securityId);

                        ClearSecurityDescriptorEntry(security_entry, sdLength);
                        attribute_need_write = TRUE;
                        DebugPrint("Clearing invalid security descriptor.\n");
                        goto GetNextSDEntry;
                    }

                    // check to see if we encountered this sid before
                    // also build a set with all the sid encountered

                    if (sid_entries.CheckAndAdd(securityId, &alreadyExists)) {
                        if (alreadyExists) {

                            Message->LogMsg(MSG_CHKLOG_NTFS_DUPLICATE_SID_IN_SDS_ENTRY,
                                         "%x%x",
                                         offset+((PCHAR)security_entry-(PCHAR)initial_security_entry),
                                         securityId);

                            ClearSecurityDescriptorEntry(security_entry, sdLength);
                            attribute_need_write = TRUE;
                            DebugPrint("Clearing duplicate security descriptor.\n");
                            goto GetNextSDEntry;
                        }
                    } else {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        FREE(initial_security_entry);
                        return FALSE;
                    }

                    // check to see if the hash value is good

                    hash = ComputeSecurityDescriptorHash(
                                        &(security_entry->security), sdLength);
                    if (security_entry->security_descriptor_header.HashKey.Hash != hash) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_HASH_IN_SDS_ENTRY,
                                     "%x%x%x%x",
                                     offset+((PCHAR)security_entry-(PCHAR)initial_security_entry),
                                     security_entry->security_descriptor_header.HashKey.Hash,
                                     hash,
                                     securityId);

                        security_entry->security_descriptor_header.HashKey.Hash = hash;
                        attribute_need_write = TRUE;
                        DebugPrint("Repairing hash value of a security descriptor header.\n");
                    }

                    // check to see if the offset stored in the security descriptor header is good

                    se_offset = (ULONG)((PCHAR)security_entry -
                                        (PCHAR)initial_security_entry +
                                        offset);
                    if (security_entry->security_descriptor_header.Offset != se_offset) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_OFFSET_IN_SDS_ENTRY,
                                     "%x%I64x%x%x",
                                     offset+((PCHAR)security_entry-(PCHAR)initial_security_entry),
                                     security_entry->security_descriptor_header.Offset,
                                     se_offset,
                                     securityId);

                        security_entry->security_descriptor_header.Offset = se_offset;
                        attribute_need_write = TRUE;
                        DebugPrint("Repairing offset value of a security descriptor header.\n");
                    }

                    // build a set with all the hashkey encountered

                    hashkey.Set(hash, securityId);
                    if (hashkey_entries.CheckAndAdd(hashkey, &alreadyExists)) {
                        DebugAssert(!alreadyExists);   // sid is unique thus hashkey
                    } else {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        FREE(initial_security_entry);
                        return FALSE;
                    }

                    // now we know the entry is unique and good
                    // make sure there is a corresponding entry in
                    // SecurityIdIndex and SecurityDescriptorHashIndex
                    // index streams

                    switch (security_frs.FindSecurityIndexEntryAndValidate(
                            &SII_Index,
                            (PVOID)&securityId,
                            sizeof(securityId),
                            &(security_entry->security_descriptor_header),
                            Mft->GetVolumeBitmap(),
                            FixLevel == CheckOnly)) {
                      case NTFS_SECURITY_INDEX_FOUND:

                        // good, entry already exists in the index

                        break;   // go onto next entry

                      case NTFS_SECURITY_INDEX_FIXED:
                      case NTFS_SECURITY_INDEX_DATA_ERROR:
                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                        hasErrors = TRUE;
                        DebugAssert(sizeof(securityId) == sizeof(ULONG));
                        Message->DisplayMsg(MSG_CHK_NTFS_REPAIRING_INDEX_ENTRY_WITH_ID,
                                            "%d%W%d",
                                            security_frs.QueryFileNumber().GetLowPart(),
                                            &SII_IndexName,
                                            securityId);
                        frs_need_flush = TRUE;
                        break;

                      case NTFS_SECURITY_INDEX_ENTRY_MISSING:
                      case NTFS_SECURITY_INDEX_INSERTED:
                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                        hasErrors = TRUE;
                        DebugAssert(sizeof(securityId) == sizeof(ULONG));
                        Message->DisplayMsg(MSG_CHK_NTFS_INSERTING_INDEX_ENTRY_WITH_ID,
                                            "%d%W%d",
                                            security_frs.QueryFileNumber().GetLowPart(),
                                            &SII_IndexName,
                                            securityId);
                        frs_need_flush = TRUE;
                        break;

                      case NTFS_SECURITY_INSERT_FAILED:
                        chkdskErrCouldNotFix = TRUE;
                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                            "%d%W",
                                            security_frs.QueryFileNumber().GetLowPart(),
                                            &SII_IndexName);
                        break;

                      case NTFS_SECURITY_ERROR:
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        FREE(initial_security_entry);
                        return FALSE;
                    }
                    switch (security_frs.FindSecurityIndexEntryAndValidate(
                            &SDH_Index,
                            (PVOID)&(security_entry->security_descriptor_header.HashKey),
                            sizeof(security_entry->security_descriptor_header.HashKey),
                            &(security_entry->security_descriptor_header),
                            Mft->GetVolumeBitmap(),
                            FixLevel == CheckOnly)) {
                      case NTFS_SECURITY_INDEX_FOUND:

                        // good, entry already exists in the index

                        break;   // go onto next entry

                      case NTFS_SECURITY_INDEX_FIXED:
                      case NTFS_SECURITY_INDEX_DATA_ERROR:

                        //*DiskErrorsFound = TRUE;

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                        hasErrors = TRUE;
                        Message->DisplayMsg(MSG_CHK_NTFS_REPAIRING_INDEX_ENTRY_WITH_ID,
                                            "%d%W%d",
                                            security_frs.QueryFileNumber().GetLowPart(),
                                            &SDH_IndexName,
                                            security_entry->security_descriptor_header.
                                                                        HashKey.SecurityId);
                        frs_need_flush = TRUE;
                        break;

                      case NTFS_SECURITY_INDEX_ENTRY_MISSING:
                      case NTFS_SECURITY_INDEX_INSERTED:

                        //*DiskErrorsFound = TRUE;

                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                        hasErrors = TRUE;
                        Message->DisplayMsg(MSG_CHK_NTFS_INSERTING_INDEX_ENTRY_WITH_ID,
                                            "%d%W%d",
                                            security_frs.QueryFileNumber().GetLowPart(),
                                            &SDH_IndexName,
                                            security_entry->security_descriptor_header.
                                                                        HashKey.SecurityId);

                        frs_need_flush = TRUE;
                        break;

                      case NTFS_SECURITY_INSERT_FAILED:
                        chkdskErrCouldNotFix = TRUE;
                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                            "%d%W",
                                            security_frs.QueryFileNumber().GetLowPart(),
                                            &SDH_IndexName);
                        break;

                      case NTFS_SECURITY_ERROR:
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        FREE(initial_security_entry);
                        return FALSE;
                    }

                GetNextSDEntry:
                    if (length == num_bytes) {
                        lengthOfBlock = (ULONG)((PCHAR)security_entry-
                                                (PCHAR)initial_security_entry+
                                                num_bytes);
                        break; // done, leave the while loop
                    } else {
                        length -= align_num_bytes;
                        previous_previous_security_entry = previous_security_entry;
                        previous_security_entry = security_entry;
                        security_entry = (SECURITY_ENTRY*)((char *)security_entry +
                                         align_num_bytes);
                    }
                } // while
                if (attribute_need_write) {
                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                    hasErrors = TRUE;
                    if (FixLevel != CheckOnly &&
                        (!SDS_attrib.Write(initial_security_entry,
                                           offset,
                                           bytesToRead,
                                           &bytesWritten,
                                           Mft->GetVolumeBitmap()) ||
                         bytesWritten != bytesToRead)) {
                        chkdskErrCouldNotFix = TRUE;
                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY_DATA_STREAM);
                    } else
                        frs_need_flush = TRUE;
                }
                if (lengthOfBlock)
                    lengthUptoPreviousBlock = lengthOfBlock + offset;
                offset += (SecurityDescriptorsBlockSize<<1);
                remain_length -= bytesToRead;
                if (remain_length >= SecurityDescriptorsBlockSize)
                    remain_length -= SecurityDescriptorsBlockSize;
                else
                    remain_length = 0;
                length = remain_length;
            } // for
            if (attribute_need_resize) {
                hasErrors = TRUE;
                errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                if (FixLevel != CheckOnly &&
                    !SDS_attrib.Resize(resizeTo +
                                       SecurityDescriptorsBlockSize,
                                       Mft->GetVolumeBitmap())) {
                    chkdskErrCouldNotFix = TRUE;
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY_DATA_STREAM);
                } else {
                    frs_need_flush = TRUE;

                    if (FixLevel != CheckOnly && SDS_attrib.IsStorageModified() &&
                        !SDS_attrib.InsertIntoFile(&security_frs, Mft->GetVolumeBitmap())) {
                        chkdskErrCouldNotFix = TRUE;
                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY_DATA_STREAM);
                    }
                }
            }
            if (frs_need_flush) {
                Message->DisplayMsg(MSG_CHK_NTFS_REPAIRING_SECURITY_FRS);
                if (FixLevel != CheckOnly &&
                    !security_frs.Flush(Mft->GetVolumeBitmap())) {
                    Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                        "%d", security_frs.QueryFileNumber().GetLowPart());
                    FREE(initial_security_entry);
                    return FALSE;
                }
            }

            ChkdskInfo->TotalNumSID = sid_entries.QueryCardinality().GetLowPart();

            // now make sure each entry in the index has
            // a corresponding entry in the $SDS data stream

            index_need_save = FALSE;
            SII_Index.ResetIterator();
            while (index_entry = SII_Index.GetNext(&depth, &error)) {
                securityId = *(ULONG*)GetIndexEntryValue(index_entry);
                if (!sid_entries.DoesIntersectSet(securityId, 1)) {
                    index_need_save = TRUE;
                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                    hasErrors = TRUE;
                    Message->DisplayMsg(MSG_CHK_NTFS_DELETING_INDEX_ENTRY_WITH_ID,
                                        "%d%W%d",
                                        security_frs.QueryFileNumber().GetLowPart(),
                                        SII_Index.GetName(),
                                        securityId);
                    if (FixLevel != CheckOnly && !SII_Index.DeleteCurrentEntry()) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        FREE(initial_security_entry);
                        return FALSE;
                    }
                } else
                    count_sid++;
            } // while

            if (index_need_save && FixLevel != CheckOnly) {
                if (!SII_Index.Save(&security_frs)) {
                    chkdskErrCouldNotFix = TRUE;
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                        "%d%W", security_frs.QueryFileNumber().GetLowPart(),
                                        SII_Index.GetName());
                }
                if (!security_frs.Flush(Mft->GetVolumeBitmap())) {
                    Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                        "%d", security_frs.QueryFileNumber().GetLowPart());
                    FREE(initial_security_entry);
                    return FALSE;
                }
            }

            index_need_save = FALSE;
            SDH_Index.ResetIterator();
            while (index_entry = SDH_Index.GetNext(&depth, &error)) {
                if (hashkey_entries.CheckAndRemove(
                        *(BIG_INT*)GetIndexEntryValue(index_entry),
                        &alreadyExists)) {
                    if (!alreadyExists) {
                        index_need_save = TRUE;
                        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                        hasErrors = TRUE;
                        Message->DisplayMsg(MSG_CHK_NTFS_DELETING_INDEX_ENTRY_WITH_ID,
                            "%d%W%d",
                            security_frs.QueryFileNumber().GetLowPart(),
                            SDH_Index.GetName(),
                            ((PSECURITY_HASH_KEY)GetIndexEntryValue(index_entry))->SecurityId);
                        if (FixLevel != CheckOnly && !SDH_Index.DeleteCurrentEntry()) {
                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            FREE(initial_security_entry);
                            return FALSE;
                        }
                    } else
                        count_hashkey++;
                } else {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    FREE(initial_security_entry);
                    return FALSE;
                }
            } // while

            if (index_need_save && FixLevel != CheckOnly) {
                if (!SDH_Index.Save(&security_frs)) {
                    chkdskErrCouldNotFix = TRUE;
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                     "%d%W", security_frs.QueryFileNumber().GetLowPart(),
                                     SDH_Index.GetName());
                }
                if (!security_frs.Flush(Mft->GetVolumeBitmap())) {
                    Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                        "%d", security_frs.QueryFileNumber().GetLowPart());
                    FREE(initial_security_entry);
                    return FALSE;
                }
            }

            if (FixLevel != CheckOnly && !chkdskErrCouldNotFix) {
                DebugAssert(count_hashkey == count_sid);
            }
        } else if (error) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        } // if (!error && securityDescriptorStreamPresent)
    } else {
        DebugPrintTrace(("Hotfixed security frs still has problems\n"));
        return FALSE;
    }


    // now each valid entry in SecurityDescriptorStream has a corresponding
    // entry in SecurityIdIndex and SecurityDescriptorHashIndex

    // Compute the number of file records.

    n = Mft->GetDataAttribute()->QueryValueLength().GetLowPart() / Mft->QueryFrsSize();

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
    time(&time1);
    timestr = ctime(&time1);
    timestr[strlen(timestr)-1] = 0;
    Message->DisplayMsg(MSG_CHK_NTFS_MESSAGE, "%s%s", "Before stage 3: ", timestr);
#endif

    if (!StartProcessingSD(n,
                           FixLevel,
                           Mft,
                           ChkdskReport,
                           ChkdskInfo,
                           &security_frs,
                           BadClusters,
                           &errFixedStatus,
                           securityDescriptorStreamPresent,
                           &sid_entries,
                           &sid_entries2,
                           &hasErrors,
                           SkipEntriesScan,
                           &chkdskErrCouldNotFix,
                           Message)) {
        FREE(initial_security_entry);
        return FALSE;
    }

#if defined(TIMING_ANALYSIS) && !defined(_AUTOCHECK_)
    time(&time2);
    Message->Lock();
    Message->Set(MSG_CHK_NTFS_MESSAGE);
    timestr = ctime(&time2);
    timestr[strlen(timestr)-1] = 0;
    Message->Display("%s%s", "After stage 3: ", timestr);
    Message->Display("%s%d", "Elapsed time in seconds: ", (ULONG)difftime(time2, time1));
    Message->Unlock();
#endif

    if (securityDescriptorStreamPresent) {


        // now remove those unused sid in the SecurityIdIndex

        SII_Index.ResetIterator();

        // calculate the set of sid that are not in use

        sid_entries.Remove(&sid_entries2);

        sid_entries2.RemoveAll();

        if (!chkdskErrCouldNotFix &&
            (!hasErrors || (hasErrors && FixLevel != CheckOnly))) {

            cleanup_count = 0;
            DebugAssert(sid_entries.QueryCardinality().GetHighPart() == 0);
            for (i=0; i<sid_entries.QueryCardinality(); i++) {
                securityId = sid_entries.QueryNumber(i).GetLowPart();
                while (index_entry = SII_Index.GetNext(&depth, &error)) {
                    if (*(ULONG*)GetIndexEntryValue(index_entry) == securityId) {
                        cleanup_count++;
                        if (FixLevel != CheckOnly && !SII_Index.DeleteCurrentEntry()) {
                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            FREE(initial_security_entry);
                            return FALSE;
                        }
                        break;
                    }
                } // while
#if DBG
                if (FixLevel != CheckOnly && !chkdskErrCouldNotFix)
                    DebugAssert(index_entry != NULL);
#endif
            }
            chkdskCleanUp = chkdskCleanUp || (cleanup_count != 0);

            if (cleanup_count) {
                if (ChkdskInfo->Verbose || hasErrors) {
                    Message->DisplayMsg(MSG_CHK_NTFS_DELETING_UNUSED_INDEX_ENTRY,
                                        "%d%W%d",
                                        security_frs.QueryFileNumber().GetLowPart(),
                                        SII_Index.GetName(),
                                        cleanup_count);
                } else {
                    Message->LogMsg(MSG_CHKLOG_NTFS_CLEANUP_INDEX_ENTRIES,
                                    "%I64x%W%d",
                                    security_frs.QueryFileNumber().GetLargeInteger(),
                                    SII_Index.GetName(),
                                    cleanup_count);
                }
                if (FixLevel != CheckOnly) {
                    if (!SII_Index.Save(&security_frs)) {
                        chkdskErrCouldNotFix = TRUE;
                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                         "%d%W", security_frs.QueryFileNumber().GetLowPart(),
                                         SII_Index.GetName());
                    }
                    if (!security_frs.Flush(Mft->GetVolumeBitmap())) {
                        Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                            "%d", security_frs.QueryFileNumber().GetLowPart());
                        FREE(initial_security_entry);
                        return FALSE;
                    }
                }
            }

            //
            // if the SII index is newly created, then include its size into
            // chkdsk report
            //

            if (new_SII_index) {
                alloc_present = security_frs.QueryAttribute(&attrib,
                                                            &error,
                                                            $INDEX_ALLOCATION,
                                                            SII_Index.GetName());

                if (!alloc_present && error) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    FREE(initial_security_entry);
                    return FALSE;
                }
                if (alloc_present) {
                   ChkdskReport->BytesInIndices += attrib.QueryAllocatedLength();
                }
            }

            // now removes those unused entries in SecurityDescriptorHashIndex

            if (sid_entries.QueryCardinality().GetLowPart()) {
                cleanup_count = 0;
                SDH_Index.ResetIterator();
                while (index_entry = SDH_Index.GetNext(&depth, &error)) {
                    securityId = ((PSECURITY_HASH_KEY)GetIndexEntryValue(index_entry))
                                    ->SecurityId;
                    if (sid_entries.DoesIntersectSet(securityId, 1)) {
                        cleanup_count++;
                        if (FixLevel != CheckOnly && !SDH_Index.DeleteCurrentEntry()) {
                            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                            FREE(initial_security_entry);
                            return FALSE;
                        }
                    }
                } // while
                chkdskCleanUp = chkdskCleanUp || (cleanup_count != 0);

                if (cleanup_count) {
                    if (ChkdskInfo->Verbose || hasErrors) {
                        Message->DisplayMsg(MSG_CHK_NTFS_DELETING_UNUSED_INDEX_ENTRY,
                                         "%d%W%d",
                                         security_frs.QueryFileNumber().GetLowPart(),
                                         SDH_Index.GetName(),
                                         cleanup_count);
                    } else {
                        Message->LogMsg(MSG_CHKLOG_NTFS_CLEANUP_INDEX_ENTRIES,
                                        "%I64x%W%d",
                                        security_frs.QueryFileNumber().GetLargeInteger(),
                                        SDH_Index.GetName(),
                                        cleanup_count);
                    }
                    if (FixLevel != CheckOnly) {
                        if (!SDH_Index.Save(&security_frs)) {
                            chkdskErrCouldNotFix = TRUE;
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                             "%d%W", security_frs.QueryFileNumber().GetLowPart(),
                                             SDH_Index.GetName());
                        }
                        if (!security_frs.Flush(Mft->GetVolumeBitmap())) {
                            Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                                "%d", security_frs.QueryFileNumber().GetLowPart());
                            FREE(initial_security_entry);
                            return FALSE;
                        }
                    }
                }
            } // if


            //
            // if the SDH index is newly created, then include its size into
            // chkdsk report
            //

            if (new_SDH_index) {
                alloc_present = security_frs.QueryAttribute(&attrib,
                                                            &error,
                                                            $INDEX_ALLOCATION,
                                                            SDH_Index.GetName());

                if (!alloc_present && error) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    FREE(initial_security_entry);
                    return FALSE;
                }
                if (alloc_present) {
                   ChkdskReport->BytesInIndices += attrib.QueryAllocatedLength();
                }
            }

            // now null those unused entries in SecurityDescriptorStream

            if (sid_entries.QueryCardinality().GetLowPart()) {
                cleanup_count = 0;
                length = SDS_attrib.QueryValueLength().GetLowPart();
                length -= SecurityDescriptorsBlockSize;
                offset = 0;
                frs_need_flush = FALSE;
                endOfBlock = (PSECURITY_ENTRY)((PCHAR)initial_security_entry+
                                               SecurityDescriptorsBlockSize);
                remain_length = length;

                for (;length > 0;) {
                    attribute_need_write = FALSE;
                    bytesToRead = min(SecurityDescriptorsBlockSize, length);
                    security_entry = initial_security_entry;
                    if (!SDS_attrib.Read(security_entry,
                                         offset,
                                         bytesToRead, &num_bytes) ||
                        num_bytes != bytesToRead) {
                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_READ_SECURITY_DATA_STREAM);
                        FREE(initial_security_entry);
                        return FALSE;
                    }
                    while (length > 0) {

                        // see if there is a need to move to next security descriptor block

                        if (security_entry == endOfBlock ||
                            (security_entry->security_descriptor_header.Length == 0 &&
                             security_entry->security_descriptor_header.HashKey.SecurityId == 0 &&
                             security_entry->security_descriptor_header.HashKey.Hash == 0)) {
                            break;
                        }

                        num_bytes = security_entry->security_descriptor_header.Length;
                        securityId = security_entry->security_descriptor_header.HashKey.SecurityId;

                        // skip over invalidated entries

                        if (securityId == SECURITY_ID_INVALID)
                            goto GetNextSDEntry2;

                        if (sid_entries.DoesIntersectSet(securityId, 1)) {

                            // fill the whole thing with zeros except the length byte in the header

                            ClearSecurityDescriptorEntry(security_entry,
                                security_entry->security_descriptor_header.Length -
                                sizeof(SECURITY_DESCRIPTOR_HEADER));
                            attribute_need_write = TRUE;
                            cleanup_count++;
                        }

                    GetNextSDEntry2:
                        if (length == num_bytes) {
                            break; // done, leave the while loop
                        } else {
                            align_num_bytes = (num_bytes + 0xf) & ~0xf;
                            DebugAssert(length > align_num_bytes);
                            length -= align_num_bytes;
                            security_entry = (SECURITY_ENTRY*)
                                                ((PCHAR)security_entry + align_num_bytes);
                        }
                    } // while
                    if (attribute_need_write) {
                        DebugAssert(cleanup_count != 0);
                        if (FixLevel != CheckOnly &&
                            (!SDS_attrib.Write(initial_security_entry,
                                               offset,
                                               bytesToRead,
                                               &bytesWritten,
                                               Mft->GetVolumeBitmap()) ||
                             bytesWritten != bytesToRead)) {
                            chkdskErrCouldNotFix = TRUE;
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY_DATA_STREAM);
                        } else
                            frs_need_flush = TRUE;
                    }
                    offset += (SecurityDescriptorsBlockSize<<1);
                    remain_length -= bytesToRead;
                    if (remain_length >= SecurityDescriptorsBlockSize)
                        remain_length -= SecurityDescriptorsBlockSize;
                    else
                        remain_length = 0;
                    length = remain_length;
                } // for
                chkdskCleanUp = chkdskCleanUp || (cleanup_count != 0);

                if (frs_need_flush) {
                    DebugAssert(cleanup_count != 0);
                    if (ChkdskInfo->Verbose || hasErrors) {
                        Message->DisplayMsg(MSG_CHK_NTFS_CLEANUP_UNUSED_SECURITY_DESCRIPTORS,
                                            "%d", cleanup_count);
                    } else {
                        Message->LogMsg(MSG_CHKLOG_NTFS_CLEANUP_UNUSED_SECURITY_DESCRIPTORS,
                                        "%d", cleanup_count);
                    }
                    if (FixLevel != CheckOnly &&
                        !security_frs.Flush(Mft->GetVolumeBitmap())) {
                        Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                            "%d", security_frs.QueryFileNumber().GetLowPart());
                        FREE(initial_security_entry);
                        return FALSE;
                    }
                }
            } // if
        } // if

        // now make sure the first copy of the security descriptors in the data
        // stream matches that in the mirror copy

        FREE(initial_security_entry);

        if (!(initial_security_entry = (PSECURITY_ENTRY)
                MALLOC(SecurityDescriptorsBlockSize<<1))) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        total_length = SDS_attrib.QueryValueLength().GetLowPart();
        length = (SecurityDescriptorsBlockSize<<1);
        fixing_mirror = FALSE;
        for (offset=0; offset < total_length; offset+=length) {
            bytesToRead = min(length, total_length-offset);
            if (!SDS_attrib.Read(initial_security_entry,
                                 offset,
                                 bytesToRead,
                                 &num_bytes) ||
                num_bytes != bytesToRead) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_READ_SECURITY_DATA_STREAM);
                FREE(initial_security_entry);
                return FALSE;
            }
            bytesToRead -= SecurityDescriptorsBlockSize;
            if (memcmp((PVOID)initial_security_entry,
                       (PVOID)((PCHAR)initial_security_entry+
                               SecurityDescriptorsBlockSize),
                       bytesToRead)) {

                if (hasErrors || ChkdskInfo->Verbose || !chkdskCleanUp) {
                    Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_SDS_MIRROR,
                                    "%x", offset);
                }

                if (hasErrors || !chkdskCleanUp)
                    errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
                if (FixLevel != CheckOnly &&
                    (!SDS_attrib.Write(initial_security_entry,
                                       offset+SecurityDescriptorsBlockSize,
                                       bytesToRead,
                                       &bytesWritten,
                                       Mft->GetVolumeBitmap()) ||
                     bytesToRead != bytesWritten)) {
                    chkdskErrCouldNotFix = TRUE;
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY_DATA_STREAM);
                } else
                    fixing_mirror = TRUE;
            }
        } // for
        if (fixing_mirror) {
            if (hasErrors || ChkdskInfo->Verbose || !chkdskCleanUp) {
                Message->DisplayMsg(MSG_CHK_NTFS_FIXING_SECURITY_DATA_STREAM_MIRROR);
            }
            if (FixLevel != CheckOnly &&
                !security_frs.Flush(Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY_DATA_STREAM);
                FREE(initial_security_entry);
                return FALSE;
            }
        }

        FREE(initial_security_entry);
    } // if (securityDescriptorStreamPresent)

    Message->DisplayMsg(MSG_CHK_NTFS_SECURITY_VERIFICATION_COMPLETED, PROGRESS_MESSAGE);

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    if (chkdskErrCouldNotFix)
        ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;
    else if (chkdskCleanUp) {
        _cleanup_that_requires_reboot = TRUE;
        if (ChkdskInfo->ExitStatus == CHKDSK_EXIT_SUCCESS)
            ChkdskInfo->ExitStatus = CHKDSK_EXIT_MINOR_ERRS;
    }

    return TRUE;
}
#endif // _SETUP_LOADER_

ULONG
ComputeSecurityDescriptorHash(
   IN PSECURITY_DESCRIPTOR    SecurityDescriptor,
   IN ULONG                   Length
   )
{
   ULONG    hash = 0;
   ULONG    count = Length / 4;
   PULONG   rover = (PULONG)SecurityDescriptor;

   DebugAssert(rover);
   if (!rover)
      return 0;

   while (count--) {
       hash = ((hash << 3) | (hash >> (32-3))) + *rover++;
   }
   return hash;
}

ULONG
ComputeDefaultSecurityId(
   PNUMBER_SET  SidSet
   )
{
    BIG_INT  start;
    BIG_INT  length;

    if (SidSet->QueryCardinality() == 0)
        return SECURITY_ID_FIRST;

    SidSet->QueryDisjointRange(0, &start, &length);
    if (start > SECURITY_ID_FIRST)
        return SECURITY_ID_FIRST;
    else {
        start += length;
        DebugAssert(start.GetHighPart() == 0);
        return start.GetLowPart();
    }
}

VOID
ClearSecurityDescriptorEntry(
    IN OUT  PSECURITY_ENTRY Security_entry,
    IN      ULONG           SecurityDescriptorSize
    )
{
    Security_entry->security_descriptor_header.Offset =
        Security_entry->security_descriptor_header.HashKey.Hash = 0;
    Security_entry->security_descriptor_header.HashKey.SecurityId =
        SECURITY_ID_INVALID;
    memset(&(Security_entry->security), 0, SecurityDescriptorSize);
}

VOID
MarkEndOfSecurityDescriptorsBlock(
    IN OUT  PSECURITY_ENTRY Security_entry,
    IN      ULONG           LengthOfBlock
    )
{
    // zero the length, hash values, and set invalid SID
    // also zero the rest of the block

    memset(Security_entry, 0, LengthOfBlock);
    DebugAssert(SECURITY_ID_INVALID == 0);
}

BOOLEAN
RemainingBlockIsZero(
    IN OUT  PCHAR   Buffer,
    IN      ULONG   Size
    )
{
    PCHAR   endp;

    endp = Buffer+Size;
    while (Buffer < endp)
        if (*Buffer == 0)
            Buffer++;
        else
            return FALSE;
    return TRUE;
}

BOOLEAN
RecoverSecurityDescriptorsDataStream(
    IN OUT PNTFS_FILE_RECORD_SEGMENT    Frs,
    IN OUT PNTFS_ATTRIBUTE              Attrib,
    IN     ULONG                        AttributeSize,
    IN     PCHAR                        Buffer,
    IN     ULONG                        BufferSize,
    IN     ULONG                        ClusterSize,
    IN OUT PNTFS_BITMAP                 Bitmap,
    OUT    PBOOLEAN                     DiskHasErrors,
    IN OUT PNUMBER_SET                  BadClusters,
    IN OUT PMESSAGE                     Message,
    IN     BOOLEAN                      FixLevel
    )
/*++

Routine Description:

    This method replaces all those unreadable clusters with readable
    one.  It grabs data from the mirror copy of the stream for those
    new clusters.

Arguments:

Return Value:

    TRUE upon successful completion.

--*/
{
    PREPAIR_RECORD  pRecord, temp;
    PREPAIR_RECORD  pFirstRecord;
    USHORT          recordCount = 0;
    ULONG           repair_record_array_size;
    NUMBER_SET      badClusterNumSet;
    BIG_INT         currentBytesRecovered;
    ULONG           bytesToRead;
    ULONG           offset;
    ULONG           length;
    ULONG           num_bytes;
    BOOLEAN         main_stream_has_errors, mirror_stream_has_errors, unused_space_has_errors;
    BOOLEAN         result = TRUE;

    //
    // sanity check
    //
    DebugAssert(BufferSize == SecurityDescriptorsBlockSize);

    *DiskHasErrors = FALSE;
    main_stream_has_errors = FALSE;
    mirror_stream_has_errors = FALSE;
    unused_space_has_errors = FALSE;

    repair_record_array_size = (SecurityDescriptorsBlockSize/
                                     ClusterSize);

    if (!badClusterNumSet.Initialize() ||
        !(pRecord = (PREPAIR_RECORD)MALLOC(repair_record_array_size*sizeof(REPAIR_RECORD)))) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    offset = 0;
    length = AttributeSize;
    if (length < SecurityDescriptorsBlockSize) {

        // doesn't matter as the stream will be zapped

        FREE(pRecord);
        if (FixLevel != CheckOnly) {

            // no need to say disk has errors as its length is invalid anyway

            result = Attrib->RecoverAttribute(Bitmap,
                                              &badClusterNumSet,
                                              &currentBytesRecovered);
        } else {
            FREE(pRecord);
            return TRUE;
        }
    } else {

        length -= SecurityDescriptorsBlockSize;

        while (length > 0) {
            bytesToRead = min(length, BufferSize);

            //
            // check is there are disk errors reading the
            // main SDS stream
            //
            if (!Attrib->Read(Buffer,
                              offset,
                              bytesToRead,
                              &num_bytes)) {
                RepairSecurityDescriptorsSegment(Attrib,
                                                 Buffer,
                                                 offset,
                                                 bytesToRead,
                                                 pRecord,
                                                 &recordCount,
                                                 ClusterSize);
                main_stream_has_errors = TRUE;

                //
                // We need to grow the REPAIR_RECORD array if
                // necessary. Every pass of the while loop
                // can add at most ( clusters per security descriptor
                // block / 2 ) records. This worst case occurs when
                // the good and bad clusters occur alternately in the
                // security descriptor stream x, x+2, x+4 ... and y+1,
                // y+3, y+5, ... are bad clusters where x and y are
                // correcponding VCNs in the main and mirror SDS
                // streams respectively, that is, y = x + 256 Kbytes
                //
                if ((repair_record_array_size - recordCount)
                        < ((SecurityDescriptorsBlockSize / ClusterSize) / 2)) {

                    repair_record_array_size += (SecurityDescriptorsBlockSize / ClusterSize) / 2;
                    if (!(temp = (PREPAIR_RECORD)MALLOC(repair_record_array_size*sizeof(REPAIR_RECORD)))) {
                        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                        return FALSE;
                    }
                    memcpy(temp, pRecord, recordCount*sizeof(REPAIR_RECORD));
                    FREE(pRecord);
                    pRecord = temp;
                }

            }

            //
            // check if there are disk errors reading the
            // unused portion of the main SDS stream
            //
            if ((bytesToRead < SecurityDescriptorsBlockSize) &&
                !Attrib->Read(Buffer,
                              offset+bytesToRead,
                              SecurityDescriptorsBlockSize-bytesToRead,
                              &num_bytes)) {
                unused_space_has_errors = TRUE;
            }

            //
            // check if there are disk errors reading the
            // mirror SDS stream
            //
            if (!Attrib->Read(Buffer,
                              offset+SecurityDescriptorsBlockSize,
                              bytesToRead,
                              &num_bytes)) {
                mirror_stream_has_errors = TRUE;
            }

            offset += (SecurityDescriptorsBlockSize<<1);
            length -= bytesToRead;
            if (length > SecurityDescriptorsBlockSize)
                length -= SecurityDescriptorsBlockSize;
            else
                length = 0;
        }


        //
        // Update the return variable so that the caller knows there
        // were errors
        //
        *DiskHasErrors = main_stream_has_errors || mirror_stream_has_errors || unused_space_has_errors;

        if (*DiskHasErrors) {
            Message->DisplayMsg(MSG_CHK_NTFS_REPAIRING_UNREADABLE_SECURITY_DATA_STREAM);
        } else {
            FREE(pRecord);
            return TRUE;
        }

        //
        // We have already printed a message - if we cannot fix stuff
        // because we are not in fix more, exit now
        //
        if (FixLevel == CheckOnly) {
            FREE(pRecord);
            return TRUE;
        }

        //
        // We do this even if we can read the main SDS stream just fine
        // (main_stream_has_errors == FALSE), because we want to fix any bad
        // clusters in the SDS mirror stream as well
        //
        if (Attrib->RecoverAttribute(Bitmap,
                                     &badClusterNumSet,
                                     &currentBytesRecovered)) {
            if (main_stream_has_errors) {
                //
                // We had found errors reading the main SDS stream, so
                // fix those regions of the main SDS stream with the mirror
                //
                pFirstRecord = pRecord;
                while (recordCount-- > 0) {
                    offset = pFirstRecord->Offset;
                    bytesToRead = pFirstRecord->Length;
                    pFirstRecord++;
                    if (Attrib->Read(Buffer,
                                     offset+SecurityDescriptorsBlockSize,
                                     bytesToRead,
                                     &num_bytes) &&
                        num_bytes == bytesToRead) {
                        if (!Attrib->Write(Buffer,
                                           offset,
                                           bytesToRead,
                                           &num_bytes,
                                           NULL) ||
                            num_bytes != bytesToRead) {
                            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_SECURITY_DATA_STREAM);
                            result = FALSE;
                            break;
                        }
                    } else {
                        Message->DisplayMsg(MSG_CHK_NTFS_CANT_READ_SECURITY_DATA_STREAM);
                        result = FALSE;
                        break;
                    }
                } // while
            }
        } else {
            //
            // Could not recover the attribute
            //
            result = FALSE;
        }
    }

    if (result && Attrib->IsStorageModified() &&
        !Attrib->InsertIntoFile(Frs, Bitmap)) {
        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                            "%d%d", $DATA, Frs->QueryFileNumber().GetLowPart());
        result = FALSE;
    }

    if (!BadClusters->Add(&badClusterNumSet)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        result = FALSE;
    }


    FREE(pRecord);
    return result;
}

BOOLEAN
RepairSecurityDescriptorsSegment(
    IN OUT  PNTFS_ATTRIBUTE Attrib,
    IN      PCHAR           Buffer,
    IN      ULONG           Offset,
    IN      ULONG           BytesToProcess,
    IN OUT  PREPAIR_RECORD  Record,
    IN OUT  USHORT          *RecordCount,
    IN      ULONG           ClusterSize
    )
/*++

Routine Description:

    This method identifies all those records that can be fixed up
    by reading the data out from the mirror copy.

Arguments:

Return Value:

    TRUE if all unreadable records can be recovered with no loss of data.
    FALSE if not all unreadable records can be recovered with no loss of data.

--*/
{
    ULONG   bytesToRead;
    ULONG   num_bytes;
    BOOLEAN completeRecovery = TRUE;

    bytesToRead = BytesToProcess/2;

    if (!Attrib->Read(Buffer,
                      Offset,
                      bytesToRead,
                      &num_bytes) ||
        bytesToRead != num_bytes) {
        if (!Attrib->Read(Buffer,
                          Offset+SecurityDescriptorsBlockSize,
                          bytesToRead,
                          &num_bytes)) {
            if (bytesToRead > ClusterSize) {
                completeRecovery =
                    completeRecovery &&
                    RepairSecurityDescriptorsSegment(Attrib,
                                                     Buffer,
                                                     Offset,
                                                     bytesToRead,
                                                     Record,
                                                     RecordCount,
                                                     ClusterSize);
            } else
                return FALSE;
        } else {
            Record[*RecordCount].Offset = Offset;
            Record[(*RecordCount)++].Length = bytesToRead;
        }
    }

    bytesToRead = BytesToProcess-bytesToRead;

    if (!Attrib->Read(Buffer,
                      Offset+bytesToRead,
                      bytesToRead,
                      &num_bytes) ||
        bytesToRead != num_bytes) {
        if (!Attrib->Read(Buffer,
                          Offset+bytesToRead+SecurityDescriptorsBlockSize,
                          bytesToRead,
                          &num_bytes)) {
            if (bytesToRead > ClusterSize) {
                completeRecovery =
                    completeRecovery &&
                    RepairSecurityDescriptorsSegment(Attrib,
                                                     Buffer,
                                                     Offset+bytesToRead,
                                                     bytesToRead,
                                                     Record,
                                                     RecordCount,
                                                     ClusterSize);
            } else
                return FALSE;
        } else {
            Record[*RecordCount].Offset = Offset + bytesToRead;
            Record[(*RecordCount)++].Length = bytesToRead;
        }
    }
    return completeRecovery;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in $(BASEDIR)\bak\bin\sources.tpl

!ENDIF

TARGETNAME=untfs
TARGETPATH=obj
TARGETTYPE=DYNLINK

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\user32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(PROJECT_LIB_PATH)\patchbc.lib \
           $(PROJECT_ROOT)\fs\utils\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib    \
           $(PROJECT_ROOT)\fs\utils\\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib

USE_MSVCRT=1
DLLENTRY=InitializeUntfs
PRECOMPILED_INCLUDE= ..\pch.cxx
MSC_WARNING_LEVEL=/W3 /WX

SOURCES= ..\attrcol.cxx    \
         ..\attrdef.cxx    \
         ..\attrib.cxx     \
         ..\attrlist.cxx   \
         ..\attrrec.cxx    \
         ..\badfile.cxx    \
         ..\bitfrs.cxx     \
         ..\bootfile.cxx   \
         ..\clusrun.cxx    \
         ..\downgrad.cxx   \
         ..\entry.cxx      \
         ..\extents.cxx    \
         ..\format.cxx     \
         ..\frs.cxx        \
         ..\frsstruc.cxx   \
         ..\hackwc.cxx     \
         ..\indxbuff.cxx   \
         ..\indxchk.cxx    \
         ..\indxroot.cxx   \
         ..\indxtree.cxx   \
         ..\largemcb.c     \
         ..\logfile.cxx    \
         ..\mft.cxx        \
         ..\mftfile.cxx    \
         ..\mftinfo.cxx    \
         ..\mftref.cxx     \
         ..\ntfsbit.cxx    \
         ..\ntfschk.cxx    \
         ..\ntfssa.cxx     \
         ..\ntfsvol.cxx    \
         ..\rafile.cxx     \
         ..\rasd.cxx       \
         ..\sdchk.cxx      \
         ..\untfs.cxx      \
         ..\upcase.cxx     \
         ..\upfile.cxx     \
         ..\usnjrnl.cxx    \
         ..\untfs.rc

INCLUDES=..\.;          \
         ..\..\inc;     \
         $(PROJECT_ROOT)\fs\utils\ulib\inc;     \
         $(PROJECT_ROOT)\fs\utils\ifsutil\inc;  \
         $(DDK_INC_PATH)

C_DEFINES=/DUNICODE=1
!if $(FREEBUILD)
C_DEFINES=$(C_DEFINES) /DDBG=0
!else
C_DEFINES=$(C_DEFINES) /DDBG=1
!IFNDEF NOMEMLEAK
C_DEFINES=$(C_DEFINES) /DMEMLEAK
!ENDIF
!IFDEF STACK_TRACE
C_DEFINES=$(C_DEFINES) /DSTACK_TRACE
!ENDIF
!ENDIF

UMTYPE=console
DLLDEF=..\untfs.def

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\upfile.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    upfile.cxx

Abstract:

    This module contains the declarations for the NTFS_UPCASE_FILE
    class, which models the upcase-table file for an NTFS volume.
    This class' main purpose in life is to encapsulate the creation
    of this file.

Author:

    Bill McJohn (billmc) 04-March-1992

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "ntfsbit.hxx"
#include "drive.hxx"
#include "attrib.hxx"
#include "bitfrs.hxx"
#include "upfile.hxx"
#include "upcase.hxx"
#include "message.hxx"
#include "rtmsg.h"

DEFINE_EXPORTED_CONSTRUCTOR( NTFS_UPCASE_FILE,
                             NTFS_FILE_RECORD_SEGMENT,
                             UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_UPCASE_FILE::~NTFS_UPCASE_FILE(
    )
{
    Destroy();
}


VOID
NTFS_UPCASE_FILE::Construct(
    )
/*++

Routine Description:

    Worker function for the construtor.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


VOID
NTFS_UPCASE_FILE::Destroy(
    )
/*++

Routine Description:

    Clean up an NTFS_UPCASE_FILE object in preparation for
    destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
}



UNTFS_EXPORT
BOOLEAN
NTFS_UPCASE_FILE::Initialize(
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft
    )
/*++

Routine Description:

    This method initializes an Upcase File object.  The only special
    knowledge that it adds to the File Record Segment initialization
    is the location within the Master File Table of the Upcase table
    file.

Arguments:

    Mft             -- Supplies the volume MasterFile Table.
    UpcaseTable     -- Supplies the volume upcase table.

Return Value:

    TRUE upon successful completion

Notes:

    This class is reinitializable.


--*/
{
    Destroy();

    return( NTFS_FILE_RECORD_SEGMENT::Initialize( UPCASE_TABLE_NUMBER,
                                                  Mft ) );
}


BOOLEAN
NTFS_UPCASE_FILE::Create(
    IN      PCSTANDARD_INFORMATION  StandardInformation,
    IN      PNTFS_UPCASE_TABLE      UpcaseTable,
    IN OUT  PNTFS_BITMAP            VolumeBitmap
    )
/*++

Routine Description:

    This method formats an Upcase-File File Record
    Segment in memory (without writing it to disk).

    It creates a DATA attribute to hold the volume's upcase
    table and writes the table to disk through that attribute.

Arguments:

    StandardInformation --  Supplies the standard information for the
                            file record segment.
    UpcaseTable         --  Supplies the volume's upcase table.
    VolumeBitmap        --  Supplies the volume bitmap

Return Value:

    TRUE upon successful completion.

--*/
{
    NTFS_ATTRIBUTE DataAttribute;
    NTFS_EXTENT_LIST Extents;


    // Set this object up as a File Record Segment.

    if( !NTFS_FILE_RECORD_SEGMENT::Create( StandardInformation ) ) {

        return FALSE;
    }

    // Create an unnamed data attribute, write the upcase table out
    // through that attribute, and save the attribute to this file.
    //
    if( !Extents.Initialize( 0, 0 ) ||
        !DataAttribute.Initialize( GetDrive(),
                                   QueryClusterFactor(),
                                   &Extents,
                                   0,
                                   0,
                                   $DATA,
                                   NULL ) ||
        !UpcaseTable->Write( &DataAttribute, VolumeBitmap ) ||
        !DataAttribute.InsertIntoFile( this, VolumeBitmap ) ) {

        return FALSE;
    }

    return TRUE;
}

BOOLEAN
NTFS_UPCASE_FILE::VerifyAndFix(
    IN OUT  PNTFS_UPCASE_TABLE  UpcaseTable,
    IN OUT  PNTFS_BITMAP        VolumeBitmap,
    IN OUT  PNUMBER_SET         BadClusterList,
    IN OUT  PNTFS_INDEX_TREE    RootIndex,
       OUT  PBOOLEAN            Changes,
    IN      FIX_LEVEL           FixLevel,
    IN OUT  PMESSAGE            Message
    )
/*++

Routine Description:

    This routine compares the given attribute definition table with
    the one contained in this file's DATA attribute and ensures
    that both are the same.  The in-memory version will override the
    on-disk version.

Arguments:

    UpcaseTable     - Supplies the in-memory version of the table.
    VolumeBitmap    - Supplies the volume bitmap.
    BadClusterList  - Supplies the list of bad clusters.
    RootIndex       - Supplies the root index.
    Changes         - Returns whether or not changes were made.
    FixLevel        - Supplies the fix up level.
    Message         - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_ATTRIBUTE                  data_attribute;
    BOOLEAN                         errors;
    PCWCHAR                         mem_upcase;
    PWCHAR                          disk_upcase;
    ULONG                           num_char;
    NTFS_EXTENT_LIST                extent_list;
    BOOLEAN                         ErrorInAttribute;
    ULONG                           value_length;
    ULONG                           num_bytes;

    *Changes = FALSE;

    mem_upcase = UpcaseTable->GetUpcaseArray(&num_char);

    if (!(disk_upcase = NEW WCHAR[num_char])) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!QueryAttribute(&data_attribute, &ErrorInAttribute, $DATA)) {

        *Changes = TRUE;

        if (!ErrorInAttribute) {
            Message->LogMsg(MSG_CHKLOG_NTFS_MISSING_DATA_ATTR_IN_UPCASE_FILE);
        }

        if (!extent_list.Initialize(0, 0)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            DELETE_ARRAY(disk_upcase);
            return FALSE;
        }

        if (!data_attribute.Initialize(GetDrive(),
                                       QueryClusterFactor(),
                                       &extent_list,
                                       0,
                                       0,
                                       $DATA)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            DELETE_ARRAY(disk_upcase);
            return FALSE;
        }
    }

    value_length = num_char*sizeof(WCHAR);

    errors = FALSE;
    if (*Changes) {
        errors = TRUE;
    } else if (value_length != data_attribute.QueryValueLength()) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_UPCASE_FILE_LENGTH,
                     "%I64x%x",
                     data_attribute.QueryValueLength().GetLargeInteger(),
                     value_length);
        errors = TRUE;
    } else if (!data_attribute.Read(disk_upcase, 0, value_length, &num_bytes)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_UPCASE_TABLE);

        errors = TRUE;
    } else if (num_bytes != value_length) {

        Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_UPCASE_TABLE);

        errors = TRUE;
    } else if (memcmp(mem_upcase, disk_upcase, value_length)) {

        Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_UPCASE_FILE);
        errors = TRUE;
    }

    if (errors) {

        *Changes = TRUE;

        Message->DisplayMsg(MSG_CHK_NTFS_CORRECTING_UPCASE_FILE);

        if (FixLevel != CheckOnly) {
            if (!data_attribute.MakeNonresident(VolumeBitmap) ||
                !data_attribute.Resize(value_length, VolumeBitmap) ||
                !data_attribute.Write(mem_upcase, 0, value_length, &num_bytes,
                                      VolumeBitmap) ||
                num_bytes != value_length) {

                if (!data_attribute.RecoverAttribute(VolumeBitmap, BadClusterList) ||
                    !data_attribute.Write(mem_upcase, 0, value_length,
                                          &num_bytes, VolumeBitmap) ||
                    num_bytes != value_length) {

                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_UPCASE_FILE);
                    DELETE_ARRAY(disk_upcase);
                    return FALSE;
                }
            }
        }

        if (!data_attribute.InsertIntoFile(this, VolumeBitmap)) {

            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_UPCASE_FILE);
            DELETE_ARRAY(disk_upcase);
            return FALSE;
        }
    }

    if (FixLevel != CheckOnly && !Flush(VolumeBitmap, RootIndex)) {

        Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_UPCASE_FILE);
        DELETE_ARRAY(disk_upcase);
        return FALSE;
    }

    DELETE_ARRAY(disk_upcase);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\untfs.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

        untfs.cxx

Abstract:

        This module contains run-time, global support for the
        NTFS IFS Utilities library (UNTFS).  This support includes:

                - creation of CLASS_DESCRIPTORs
                - Global objects

Author:

        Bill McJohn (billmc) 15-Aug-1991

Environment:

        User Mode

Notes:

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "untfs.hxx"

extern "C" {
    #include <patchbc.h>
    #include "rtmsg.h"
    extern UCHAR NtfsBootCode[8192];
}

#ifdef _AUTOCHECK_

BOOLEAN
SimpleFetchMessageTextInOemCharSet(
    IN  ULONG  MessageId,
    OUT CHAR  *Text,
    IN  ULONG  BufferLen
    );

#endif // _AUTOCHECK_


//      Local prototypes

STATIC
BOOLEAN
DefineClassDescriptors(
        );

STATIC
BOOLEAN
UndefineClassDescriptors(
        );

BOOLEAN
PatchNtfsBootCodeMessages(
    VOID
    );



extern "C"
BOOLEAN
InitializeUntfs (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context
        );

BOOLEAN
InitializeUntfs (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context
        )
/*++

Routine Description:

        Initialize Untfs by constructing and initializing all
        global objects. These include:

                - all CLASS_DESCRIPTORs (class_cd)

Arguments:

        None.

Return Value:

        BOOLEAN - Returns TRUE if all global objects were succesfully constructed
                and initialized.

--*/

{
    UNREFERENCED_PARAMETER( DllHandle );
    UNREFERENCED_PARAMETER( Context );

#ifdef _AUTOCHECK_

    UNREFERENCED_PARAMETER( Reason );

    if(!PatchNtfsBootCodeMessages()) {
        DebugAbort("Internal error: translated messages for boot code are missing or too long!!!\n");
        return(FALSE);
    }

    if (!DefineClassDescriptors()) {
        UndefineClassDescriptors();
        DebugAbort( "Untfs initialization failed!!!\n" );
        return( FALSE );
    }

#if defined(TRACE_UNTFS_MEM_LEAK)
    DebugPrint("UNTFS.DLL got attached.\n");
#endif

#else // _AUTOCHECK_ not defined

    STATIC ULONG    count = 0;

    switch (Reason) {
        case DLL_PROCESS_ATTACH:
            //
            // Get translated boot messages into FAT boot code.
            //
            if(!PatchNtfsBootCodeMessages()) {
                //
                // Internal error only, don't worry about translating it.
                //
                MessageBoxA(
                    NULL,
                    "Internal error: Translated boot messages are too long or missing.",
                    "ULIB.DLL (UNTFS.DLL)",
                    MB_ICONERROR | MB_SYSTEMMODAL | MB_OK
                    );

                DebugAbort("Internal error: translated messages for boot code are missing or too long!!!\n");
                return(FALSE);
            }

            // Success, FALL THROUGH to thread attach case

        case DLL_THREAD_ATTACH:

            if (count > 0) {
                ++count;
#if defined(TRACE_UNTFS_MEM_LEAK)
                DebugPrintTrace(("UNTFS.DLL got attached %d times.\n", count));
#endif
                return TRUE;
            }

            if (!DefineClassDescriptors()) {
                UndefineClassDescriptors();
                DebugAbort( "Untfs initialization failed!!!\n" );
                return( FALSE );
            }

#if defined(TRACE_UNTFS_MEM_LEAK)
            DebugPrint("UNTFS.DLL got attached.\n");
#endif

            count++;
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:

            if (count > 1) {
                --count;
#if defined(TRACE_UNTFS_MEM_LEAK)
                DebugPrintTrace(("UNTFS.DLL got detached.  %d time(s) left.\n", count));
#endif
                return TRUE;
            }
            if (count == 1) {

#if defined(TRACE_UNTFS_MEM_LEAK)
                DebugPrint("UNTFS.DLL got detached.\n");
#endif

                UndefineClassDescriptors();
                count--;
            } else {
#if defined(TRACE_UNTFS_MEM_LEAK)
                DebugPrint("UNTFS.DLL detached more than attached\n");
#endif
            }
            break;
    }
#endif // _AUTOCHECK_

    return TRUE;
}



DECLARE_CLASS( NTFS_ATTRIBUTE );
DECLARE_CLASS( NTFS_ATTRIBUTE_COLUMNS );
DECLARE_CLASS( NTFS_ATTRIBUTE_DEFINITION_TABLE );
DECLARE_CLASS( NTFS_ATTRIBUTE_LIST );
DECLARE_CLASS( NTFS_ATTRIBUTE_RECORD );
DECLARE_CLASS( NTFS_BAD_CLUSTER_FILE );
DECLARE_CLASS( NTFS_BITMAP_FILE );
DECLARE_CLASS( NTFS_BOOT_FILE );
DECLARE_CLASS( NTFS_CLUSTER_RUN );
DECLARE_CLASS( NTFS_EXTENT );
DECLARE_CLASS( NTFS_EXTENT_LIST );
DECLARE_CLASS( NTFS_FILE_RECORD_SEGMENT );
DECLARE_CLASS( NTFS_FRS_STRUCTURE );
DECLARE_CLASS( NTFS_INDEX_BUFFER );
DECLARE_CLASS( NTFS_INDEX_ROOT );
DECLARE_CLASS( NTFS_INDEX_TREE );
DECLARE_CLASS( NTFS_LOG_FILE );
DECLARE_CLASS( NTFS_MASTER_FILE_TABLE );
DECLARE_CLASS( NTFS_MFT_FILE );
DECLARE_CLASS( NTFS_MFT_INFO );
DECLARE_CLASS( NTFS_REFLECTED_MASTER_FILE_TABLE );
DECLARE_CLASS( NTFS_BITMAP );
DECLARE_CLASS( NTFS_UPCASE_FILE );
DECLARE_CLASS( NTFS_UPCASE_TABLE );
DECLARE_CLASS( NTFS_VOL );
DECLARE_CLASS( NTFS_SA );
DECLARE_CLASS( RA_PROCESS_FILE );
DECLARE_CLASS( RA_PROCESS_SD );

STATIC
BOOLEAN
DefineClassDescriptors(
        )
{
        if( DEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE_DEFINITION_TABLE    ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE                     ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE_COLUMNS             ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE_LIST                ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE_RECORD              ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_BAD_CLUSTER_FILE              ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_BITMAP_FILE                   ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_BOOT_FILE                     ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_CLUSTER_RUN                   ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_EXTENT                        ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_EXTENT_LIST                   ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_FILE_RECORD_SEGMENT           ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_FRS_STRUCTURE                 ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_INDEX_BUFFER                  ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_INDEX_ROOT                    ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_INDEX_TREE                    ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_LOG_FILE                      ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_MASTER_FILE_TABLE             ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_MFT_FILE                      ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_MFT_INFO                      ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_REFLECTED_MASTER_FILE_TABLE   ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_UPCASE_FILE                   ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_UPCASE_TABLE                  ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_VOL                           ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_SA                            ) &&
        DEFINE_CLASS_DESCRIPTOR( RA_PROCESS_FILE                    ) &&
        DEFINE_CLASS_DESCRIPTOR( RA_PROCESS_SD                      ) &&
        DEFINE_CLASS_DESCRIPTOR( NTFS_BITMAP                        ) ) {

                return TRUE;

        } else {

                DebugPrint( "Could not initialize class descriptors!");
                return FALSE;
        }
}

STATIC
BOOLEAN
UndefineClassDescriptors(
        )
{
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE_DEFINITION_TABLE    );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE                     );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE_COLUMNS             );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE_LIST                );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_ATTRIBUTE_RECORD              );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_BAD_CLUSTER_FILE              );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_BITMAP_FILE                   );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_BOOT_FILE                     );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_CLUSTER_RUN                   );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_EXTENT                        );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_EXTENT_LIST                   );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_FILE_RECORD_SEGMENT           );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_FRS_STRUCTURE                 );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_INDEX_BUFFER                  );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_INDEX_ROOT                    );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_INDEX_TREE                    );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_LOG_FILE                      );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_MASTER_FILE_TABLE             );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_MFT_FILE                      );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_MFT_INFO                      );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_REFLECTED_MASTER_FILE_TABLE   );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_UPCASE_FILE                   );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_UPCASE_TABLE                  );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_VOL                           );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_SA                            );
    UNDEFINE_CLASS_DESCRIPTOR( RA_PROCESS_FILE                    );
    UNDEFINE_CLASS_DESCRIPTOR( RA_PROCESS_SD                      );
    UNDEFINE_CLASS_DESCRIPTOR( NTFS_BITMAP                        );
    return TRUE;
}


BOOLEAN
PatchNtfsBootCodeMessages(
    VOID
    )
{
    CHAR NtldrMissing[100];
    CHAR NtldrCompressed[100];
    CHAR DiskError[100];
    CHAR PressKey[100];

    //
    // Get message text.
    //
#ifdef _AUTOCHECK_
    //
    // ntlib.lib, messages are in the binary being run.
    //
    {
        BOOLEAN b;

        b = SimpleFetchMessageTextInOemCharSet(
                MSG_BOOT_NTFS_NTLDR_MISSING,
                NtldrMissing,
                sizeof(NtldrMissing)
                );

        if(b) {
            b = SimpleFetchMessageTextInOemCharSet(
                    MSG_BOOT_NTFS_NTLDR_COMPRESSED,
                    NtldrCompressed,
                    sizeof(NtldrCompressed)
                    );

            if(b) {
                b = SimpleFetchMessageTextInOemCharSet(
                        MSG_BOOT_NTFS_IO_ERROR,
                        DiskError,
                        sizeof(DiskError)
                        );

                if(b) {
                    b = SimpleFetchMessageTextInOemCharSet(
                            MSG_BOOT_NTFS_PRESS_KEY,
                            PressKey,
                            sizeof(PressKey)
                            );
                }
            }

            if(!b) {
                return(FALSE);
            }
        }
    }
#else
    //
    // Win32 case, messages are in ulib.dll.
    //
    {
        HINSTANCE h;
        DWORD d;

        h = LoadLibraryEx(TEXT("ULIB"),NULL,LOAD_LIBRARY_AS_DATAFILE);
        if(!h) {
            return(FALSE);
        }

        d = FormatMessageA(
                FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                h,
                MSG_BOOT_NTFS_NTLDR_MISSING,
                0,
                NtldrMissing,
                sizeof(NtldrMissing),
                NULL
                );

        if(d) {

            d = FormatMessageA(
                    FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                    h,
                    MSG_BOOT_NTFS_IO_ERROR,
                    0,
                    DiskError,
                    sizeof(DiskError),
                    NULL
                    );

            if(d) {
                d = FormatMessageA(
                        FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                        h,
                        MSG_BOOT_NTFS_PRESS_KEY,
                        0,
                        PressKey,
                        sizeof(PressKey),
                        NULL
                        );

                if(d) {
                    d = FormatMessageA(
                            FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_HMODULE,
                            h,
                            MSG_BOOT_NTFS_NTLDR_COMPRESSED,
                            0,
                            NtldrCompressed,
                            sizeof(NtldrCompressed),
                            NULL
                            );
                }
            }
        }

        FreeLibrary(h);
        if(!d) {
            return(FALSE);
        }

        CharToOemA(NtldrMissing,NtldrMissing);
        CharToOemA(NtldrCompressed,NtldrCompressed);
        CharToOemA(DiskError,DiskError);
        CharToOemA(PressKey,PressKey);
    }
#endif

    //
    // Call code in patchbc.lib to do the patching now that we've got
    // the translated message text.
    //
    if(!PatchMessagesIntoNtfsBootCode(NtfsBootCode,NtldrMissing,NtldrCompressed,DiskError,PressKey)) {

        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\upcase.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    upcase.cxx

Abstract:

    This module contains the member function definitions for the
    NTFS_UPCASE_TABLE class.  This class models the upcase table
    stored on an NTFS volume, which is used to upper-case characters
    in attribute and file names for comparison.

Author:

    Bill McJohn (billmc) 04-March-92

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_

#include "ulib.hxx"
#include "error.hxx"
#include "untfs.hxx"

#include "attrib.hxx"
#include "ntfsbit.hxx"
#include "upcase.hxx"

extern "C" {
#include <ctype.h>
}


DEFINE_EXPORTED_CONSTRUCTOR( NTFS_UPCASE_TABLE, OBJECT, UNTFS_EXPORT );

UNTFS_EXPORT
NTFS_UPCASE_TABLE::~NTFS_UPCASE_TABLE(
    )
/*++

Routine Description:

    This method is the destructor for the class.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
NTFS_UPCASE_TABLE::Construct(
    )
/*++

routine Description:

    This method is the helper function for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _Data = NULL;
    _Length = 0;
}

VOID
NTFS_UPCASE_TABLE::Destroy(
    )
/*++

Routine Description:

    This method cleans up the object in preparation for destruction
    or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    FREE( _Data );
    _Length = 0;
}



UNTFS_EXPORT
BOOLEAN
NTFS_UPCASE_TABLE::Initialize(
    IN PNTFS_ATTRIBUTE Attribute
    )
/*++

Routine Description:

    This method initializes the object based on the value of
    an NTFS Attribute.

Arguments:

    Attribute   --  Supplies the attribute whose value is the
                    upcase table.


Return Value:

    TRUE upon successful completion.

--*/
{
    ULONG BytesInValue, BytesRead;


    DebugPtrAssert( Attribute );

    Destroy();

    // Perform validity checks on the attribute; it must be
    // small enough that the length fits in a ULONG, and
    // its length must be a multiple of sizeof(WCHAR).

    if( Attribute->QueryValueLength().GetHighPart() != 0 ) {

        DebugAbort( "Upcase table is impossibly large.\n" );
        return FALSE;
    }

    BytesInValue = Attribute->QueryValueLength().GetLowPart();

    if( BytesInValue % sizeof(WCHAR) != 0 )  {

        DebugAbort( "Upcase table is an odd number of bytes.\n" );
        return FALSE;
    }

    // Allocate the buffer for the upcase data and read the attribute
    // value into it.

    if( (_Data = (PWCHAR)MALLOC( BytesInValue )) == NULL ||
        !Attribute->Read( _Data,
                          0,
                          BytesInValue,
                          &BytesRead ) ||
        BytesRead != BytesInValue ) {

        Destroy();
        return FALSE;
    }

    // _Length is the number of WCHAR's in the table.

    _Length = BytesInValue / sizeof(WCHAR);

    return TRUE;
}


BOOLEAN
NTFS_UPCASE_TABLE::Initialize(
    IN PWCHAR   Data,
    IN ULONG    Length
    )
/*++

Routine Description:

    This method initializes the upcase table based on client-supplied
    data.

Arguments:

    Data    --  Supplies the data for the table.
    Length  --  Supplies the number of WCHAR's in the table.

Return Value:

    TRUE upon successful completion.

--*/
{
    Destroy();

    if( (_Data = (PWCHAR)MALLOC( Length * sizeof(WCHAR) )) == NULL ) {

        Destroy();
        return FALSE;
    }

    memcpy( _Data, Data, Length * sizeof(WCHAR) );

    _Length = Length;

    return TRUE;
}



BOOLEAN
NTFS_UPCASE_TABLE::Initialize(
    )
/*++

Routine Description:

    This method initializes the upcase table based on system defaults.

Arguments:

    None.

Return Value:

    TRUE upon successful completion.

--*/
{
    CONST ULONG MaximumChunkLength = 16 * 1024;
    WCHAR w;
    ULONG i, ChunkLength;
    UNICODE_STRING UpcaseMe;
    NTSTATUS Status;

    _Length = QueryDefaultLength();

    if( (_Data = (PWCHAR)MALLOC( _Length * sizeof(WCHAR) )) == NULL ) {

        Destroy();
        return FALSE;
    }

    // First, set the table up as an identity transformation:
    //
    for( i = 0; i < _Length; i++ ) {

        _Data[i] = (WCHAR)i;
    }

    // Now call RtlUpcaseUnicodeString on successive chunks
    // of the buffer.
    //
    ChunkLength = MaximumChunkLength;

    for( i = 0; i < _Length; i += ChunkLength ) {

        if( i + ChunkLength > _Length ) {

            ChunkLength = (ULONG)(_Length - i);
        }

        UpcaseMe.Length        = (USHORT)(sizeof(WCHAR) * ChunkLength);
        UpcaseMe.MaximumLength = (USHORT)(sizeof(WCHAR) * ChunkLength);
        UpcaseMe.Buffer        = _Data + i;

        Status = RtlUpcaseUnicodeString( &UpcaseMe,
                                         &UpcaseMe,
                                         FALSE );

        if( !NT_SUCCESS(Status) ) {

            DebugPrintTrace(( "UNTFS: RtlUpcaseUnicodeString failed - status 0x%x\n", Status ));
            Destroy();
            return FALSE;
        }
    }

    return TRUE;
}


BOOLEAN
NTFS_UPCASE_TABLE::Verify(
    ) CONST
/*++

Routine Description:

    This routine ensures that the first 128 entries of this
    table are compliant with the ANSI character set.

Arguments:

    None.

Return Value:

    FALSE   - This table is not valid.
    TRUE    - This table is valid.

--*/
{
    WCHAR   i;

    if (_Length < 128) {
        return FALSE;
    }

    for (i = 0; i < 128; i++) {
        if (_Data[i] != toupper(i)) {
            return FALSE;
        }
    }

    return TRUE;
}



LONG
UNTFS_EXPORT
NtfsUpcaseCompare(
    IN PCWSTR               LeftName,
    IN ULONG                LeftNameLength,
    IN PCWSTR               RightName,
    IN ULONG                RightNameLength,
    IN PCNTFS_UPCASE_TABLE  UpcaseTable,
    IN BOOLEAN              CaseSensitive
    )
/*++

Routine Description:

    This function compares two NTFS names.

Arguments:

    LeftName        --  Supplies the left-hand operand of the comparison.
    LeftNameLength  --  Supplies the length in characters of LeftName.
    RightName       --  Supplies the Right-hand operand of the comparison.
    RightNameLength --  Supplies the length in characters of RightName.
    UpcaseTable     --  Supplies the volume upcase table.
    CaseSensitive   --  Supplies a flag which, if TRUE, indicates that
                        the comparison is case-sensitive.

Return Value:

    <0 if LeftName is less than RightName.
     0 if the names are equal.
    >0 if LeftName is greater than RightName.

Notes:

    UpcaseTable may be NULL if either or both names are zero-length,
    or if the names are exactly identical.  Otherwise, it must point
    at an initialized Upcase Table object.

    If the comparison is case-sensitive, then the names are first
    compared case-insensitive.  If that comparison evaluates to equality,
    then they are compared case-sensitive.  Attribute names and
    non-DOS, non-NTFS file names are compared case-sensitive.

--*/
{
    ULONG ShorterLength, i;
    LONG Result;

    // First, if both names have zero length, then they're equal.
    //
    if( LeftNameLength == 0 && RightNameLength == 0 ) {

        return 0;
    }

    // At least one has a non-zero-length name.  If the other has
    // a zero-length name, it's the lesser of the two.
    //
    if( LeftNameLength == 0 ) {

        return -1;
    }

    if( RightNameLength == 0 ) {

        return 1;
    }

    // Both have non-zero length names.  If they have the same length,
    // do a quick memcmp to see if they're identical.
    //
    if( LeftNameLength == RightNameLength &&
        memcmp( LeftName, RightName, LeftNameLength * sizeof(WCHAR) ) == 0 ) {

        return 0;
    }

    // Perform case-insensitive comparison.  This requires
    // UpcaseTable to be valid.
    //
    DebugPtrAssert( UpcaseTable );

    ShorterLength = MIN( LeftNameLength, RightNameLength );

    for( i = 0; i < ShorterLength; i++ ) {

        Result =  UpcaseTable->UpperCase( LeftName[i] ) -
                  UpcaseTable->UpperCase( RightName[i] );

        if( Result != 0 ) {

            return Result;
        }
    }

    // The names are case-insensitive equal for the length of
    // the shorter name; if they are of different lengths, the
    // shorter is the lesser.
    //
    Result = LeftNameLength - RightNameLength;

    if( Result != 0 ) {

        return Result;
    }

    // The names are equal except for case.  If this is an
    // case-sensitive comparison, perform a final comparison;
    // otherwise, they're equal.
    //
    if( !CaseSensitive ) {

        return 0;

    } else {

        // We already know they're of the same length.
        //
        for( i = 0; i < LeftNameLength; i++ ) {

            Result = LeftName[i] - RightName[i];

            if( Result != 0 ) {

                return Result;
            }
        }

        return 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ureg\src\registry.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    registry.cxx

Abstract:

    This module contains the methods for the REGISTRY class.

Author:

    Jaime Sasson (jaimes) 26-Aug-1991

Environment:

    Ulib, Regedit, Windows, User Mode

--*/

#include "registry.hxx"


#if defined( _AUTOCHECK_ )

#define KEY_BASIC_SIZE      sizeof(KEY_BASIC_INFORMATION)+MAXIMUM_FILENAME_LENGTH
#define KEY_FULL_SIZE       sizeof(KEY_FULL_INFORMATION)+MAXIMUM_FILENAME_LENGTH
#define VALUE_BASIC_SIZE    sizeof(KEY_VALUE_BASIC_INFORMATION)+MAXIMUM_FILENAME_LENGTH
#define VALUE_FULL_SIZE     sizeof(KEY_VALUE_FULL_INFORMATION)+MAXIMUM_FILENAME_LENGTH

#endif



DEFINE_CONSTRUCTOR( REGISTRY, OBJECT );

DEFINE_CAST_MEMBER_FUNCTION( REGISTRY );


//
//  Initialization of static variable
//

PWSTRING    REGISTRY::_Separator = NULL;




REGISTRY::~REGISTRY(
)
/*++

Routine Description:

    Destroy a REGISTRY object.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
REGISTRY::Construct (
    )
/*++

Routine Description:

    Worker method for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG   Index;

#if !defined( _AUTOCHECK_ )

    for( Index = 0; Index < NUMBER_OF_PREDEFINED_KEYS; Index++ ) {
        _PredefinedKey[ Index ] = 0;
    }

#endif

}



VOID
REGISTRY::Destroy(
    )
/*++

Routine Description:

    Worker method for object destruction.

Arguments:

    None.

Return Value:

    None.

--*/
{
#if !defined( _AUTOCHECK_ )

    ULONG   Index;

    if( _RemoteRegistry ) {
        if( _PredefinedKey[ PREDEFINED_KEY_USERS ] != 0 ) {
            RegCloseKey( _PredefinedKey[ PREDEFINED_KEY_USERS ] );
        }
        if( _PredefinedKey[ PREDEFINED_KEY_LOCAL_MACHINE ] != 0 ) {
            RegCloseKey( _PredefinedKey[ PREDEFINED_KEY_LOCAL_MACHINE ] );
        }
    }
    _RemoteRegistry = FALSE;
    for( Index = 0; Index < NUMBER_OF_PREDEFINED_KEYS; Index++ ) {
        _PredefinedKey[ Index ] = 0;
    }

#endif

}


BOOLEAN
REGISTRY::Initialize(
    IN PCWSTRING MachineName,
    IN PULONG           ErrorCode
    )

/*++

Routine Description:

    Initialize a REGISTRY object.

Arguments:

    MachineName - The name of the machine whose registry we want to access.
                  NULL means the local machine.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.

Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{
    PWSTR       MachineNameString = NULL;
    ULONG       Status;
    DSTRING     TmpName;


    Destroy();

    _RemoteRegistry = FALSE;

    if( _Separator == NULL ) {
        _Separator = ( PWSTRING )NEW( DSTRING );
        if( _Separator == NULL ) {
            DebugPtrAssert( _Separator );

#if !defined( _AUTOCHECK_ )
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            }
#endif
            return( FALSE );
        }
        if( !_Separator->Initialize( "\\" ) ) {
            DebugPrint( "_Separator.Initialize() failed \n" );

#if !defined( _AUTOCHECK_ )
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
            }
#endif

            return( FALSE );
        }
    }


#if !defined( _AUTOCHECK_ )

    if( !InitializeMachineName( MachineName ) ) {
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
            }
        return( FALSE );
    }

    if( !IsRemoteRegistry() ) {
        _PredefinedKey[ PREDEFINED_KEY_CLASSES_ROOT ] = HKEY_CLASSES_ROOT;
        _PredefinedKey[ PREDEFINED_KEY_CURRENT_USER ] = HKEY_CURRENT_USER;
        _PredefinedKey[ PREDEFINED_KEY_LOCAL_MACHINE ] = HKEY_LOCAL_MACHINE;
        _PredefinedKey[ PREDEFINED_KEY_USERS ] = HKEY_USERS;
        _PredefinedKey[ PREDEFINED_KEY_CURRENT_CONFIG ] = HKEY_CURRENT_CONFIG;
    } else {
        if( !TmpName.Initialize( ( LPWSTR )L"\\\\" ) ||
            !TmpName.Strcat( MachineName ) ){
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
            }
            return( FALSE );
        }

        MachineNameString = TmpName.QueryWSTR();
        if( MachineNameString == NULL ) {
            DebugPrint( "TmpName.QueryWSTR() failed" );
            return( FALSE );
        }
        _PredefinedKey[ PREDEFINED_KEY_CLASSES_ROOT ] = 0;
        _PredefinedKey[ PREDEFINED_KEY_CURRENT_USER ] = 0;
        _PredefinedKey[ PREDEFINED_KEY_CURRENT_CONFIG ] = 0;
        Status = RegConnectRegistry( MachineNameString,
                                     HKEY_LOCAL_MACHINE,
                                     &_PredefinedKey[ PREDEFINED_KEY_LOCAL_MACHINE ] );
        if( Status != 0 ) {
            DebugPrintTrace(( "RegConnectRegistry() failed: HKEY_LOCAL_MACHINE, Status = %#x \n",
                       Status ));
            DebugPrint( "RegConnectRegistry() failed: HKEY_LOCAL_MACHINE" );
            FREE( MachineNameString );
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            return( FALSE );
        }
        Status = RegConnectRegistry( MachineNameString,
                                 HKEY_USERS,
                                 &_PredefinedKey[ PREDEFINED_KEY_USERS ] );
        if( Status != 0 ) {
            DebugPrintTrace(( "RegConnectRegistry() failed: HKEY_USERS, Status = %#x \n", Status ));
            DebugPrint( "RegConnectRegistry() failed: HKEY_USERS" );
            FREE( MachineNameString );
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            return( FALSE );
        }
        FREE( MachineNameString );
    }

#endif
    return( TRUE );
}





BOOLEAN
REGISTRY::InitializeMachineName(
    IN PCWSTRING MachineName
    )

/*++

Routine Description:

    Initialize the data member that contains the machine name, and
    the flag that indicate whether the registry is local or remote

Arguments:

    MachineName - Pointer to a WSTRING object that contains the machine
                  name.
                  It can be NULL, or it can be a NUL string, and in this case
                  this REGISTRY object will represent the local machine.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{

#if defined( _AUTOCHECK_ )

    UNREFERENCED_PARAMETER( MachineName );

    return( FALSE );

#else


    WSTR    LocalMachineName[ MAX_COMPUTERNAME_LENGTH + 1];


    ULONG   NameLength;
    DSTRING Name;

#if 0
  PSTR DebugNameString;
#endif

    //
    //  Determine the name of the local machine
    //

    NameLength = sizeof( LocalMachineName ) / sizeof( LocalMachineName[0] );
    if( !GetComputerName( LocalMachineName,
                          &NameLength ) ) {

        DebugPrintTrace(( "GetComputerName() failed, Error = %#x \n", GetLastError() ));
        DebugPrint( "GetComputerName() failed" );
        return( FALSE );
    }
    if( !Name.Initialize( LocalMachineName, NameLength ) ) {
        DebugPrint( "Name.Initialize() failed" );
        return( FALSE );
    }

#if 0
  DebugNameString = Name.QuerySTR();
  DebugPtrAssert( DebugNameString );
  DebugPrintTrace(( "MachineName = %s \n", DebugNameString ));
#endif

    //
    //  Find out if the name received as parameter represents the local
    //  machine.
    //

    if( ( MachineName == NULL ) ||
        ( MachineName->QueryChCount() == 0 )
      ) {
        //
        //  Local machine
        //
        if( !_MachineName.Initialize( &Name ) ) {
            DebugPrint( "_MachineName.Initialize( &Name ) failed" );
            return( FALSE );
        }
        _RemoteRegistry = FALSE;
    } else {
        //
        //  Remote machine
        //
        if( !_MachineName.Initialize( MachineName ) ) {
            DebugPrint( "_MachineName.Initialize( MachineName ) failed" );
            return( FALSE );
        }
        _RemoteRegistry = TRUE;
    }
    return( TRUE );

#endif
}




BOOLEAN
REGISTRY::AddValueEntry(
    IN     PREDEFINED_KEY           PredefinedKey,
    IN     PCWSTRING         ParentName,
    IN     PCWSTRING         KeyName,
    IN     PCREGISTRY_VALUE_ENTRY   Value,
    IN     BOOLEAN                  FailIfExists,
    OUT    PULONG                  ErrorCode
    )

/*++

Routine Description:

    Add a value entry to an existing key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentName - The parent name of the key (can be NULL ).

    KeyName - The name of the key where the Value will be added (cannot be NULL).

    Value - Pointer to the object that contains the information about the
            value to be created.


    FailIfExists - If TRUE, overwrite the existing value.


    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the value entry was added, or FALSE otherwise.


--*/

{

#if defined( _AUTOCHECK_ )

    PWSTRING            CompleteKeyName;
    PWSTR               CompleteKeyNameString;
    PWSTR               ValueNameString;
    UNICODE_STRING      UnicodeKeyName;
    UNICODE_STRING      UnicodeValueName;
    OBJECT_ATTRIBUTES   ObjAttr;
    HANDLE              Handle;
    NTSTATUS            Status;
    PBYTE               Data;
    ULONG               Size;


    if ( !OpenKey( ParentName, KeyName, KEY_SET_VALUE, &Handle, ErrorCode ) ) {
        return FALSE;
    }

    if ( !Value                                                         ||
         !(ValueNameString = Value->GetName()->QueryWSTR() )

       ) {

        FREE( ValueNameString );
        NtClose( Handle );
        return FALSE;
    }


    if( FailIfExists &&
        DoesValueExist( PredefinedKey, ParentName, KeyName, Value->GetName() ) ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = 0;
        }

        FREE( ValueNameString );
        NtClose( Handle );
        return( FALSE );
    }

    RtlInitUnicodeString( &UnicodeValueName, ValueNameString );

    Size = Value->GetData( &Data );

    Status = NtSetValueKey( Handle,
                            &UnicodeValueName,
                            Value->GetTitleIndex(),
                            Value->GetType(),
                            Data,
                            Size );

    FREE( ValueNameString );
    NtClose( Handle );

    if ( !NT_SUCCESS( Status ) ) {
        if ( ErrorCode != NULL ) {
            *ErrorCode = Status;
        }
        return FALSE;
    }

    return TRUE;

#else


    HKEY       Handle;
    PCWSTRING  ValueName;
    PWSTR      ValueNameString;
    DWORD      Status;
    PBYTE      Data;
    ULONG      Size;


    DebugPtrAssert( ParentName );
    DebugPtrAssert( KeyName );
    DebugPtrAssert( Value );



    //
    //  Open the key with KEY_SET_VALUE access so that the key is locked
    //

    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  KEY_SET_VALUE,
                  &Handle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }

    //
    //  Verify whether the value exists
    //
    if( FailIfExists &&
        DoesValueExist( PredefinedKey, ParentName, KeyName, Value->GetName(), ErrorCode ) ) {
        //
        //  If the key is not a predefined key, then we must close the handle
        //
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        return( FALSE );
    }

    //
    //  Set the value:
    //      .Determine the value name
    //      .Get the value data from Value object
    //      .Create the value entry in the key
    //
    ValueName = Value->GetName();
    DebugPtrAssert( ValueName );
    ValueNameString = ValueName->QueryWSTR();
    if( ValueNameString == NULL ) {
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( ValueNameString );
        return( FALSE );
    }
    Size = Value->GetData( (PCBYTE *)&Data );

    Status = RegSetValueEx( Handle,
                            ValueNameString,
                            0,                  // Value->GetTitleIndex(),
                            Value->GetType(),
                            Data,
                            Size );

    FREE( ValueNameString );
    if( Status != 0 ) {
        DebugPrintTrace(( "RegSetValueEx() failed, Status = %#x \n", Status ));
        DebugPrint( "RegSetValueEx() failed" );
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        return( FALSE );
    }
    Status = RegFlushKey( Handle );
    if( Status != 0 ) {
        DebugPrintTrace(( "RegFlushKey() failed, Status = %#x \n", Status ));
        DebugPrint( "RegFlushKey() failed" );
    }
    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }
    return( TRUE );

#endif
}



BOOLEAN
REGISTRY::AddValueEntry(
    IN     PREDEFINED_KEY           PredefinedKey,
    IN OUT PREGISTRY_KEY_INFO       KeyInfo,
    IN     PCREGISTRY_VALUE_ENTRY   Value,
    IN     BOOLEAN                  FailIfExists,
    OUT    PULONG                   ErrorCode
    )

/*++

Routine Description:

    Add a value entry to an existing key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    KeyInfo - Pointer to the object that contains the information about the
              the key where the value will be created. This object will be
              updated to reflect the addition of a new value.

    Value - Pointer to the object that contains the information about the
            value to be created.

    FailIfExists - A flag that indicates if the method should fail if a
                   value entry with the same name already exists.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{

#if defined( _AUTOCHECK_ )

    UNREFERENCED_PARAMETER( PredefinedKey );
    UNREFERENCED_PARAMETER( KeyInfo );
    UNREFERENCED_PARAMETER( Value );
    UNREFERENCED_PARAMETER( FailIfExists );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;


#else

    PCWSTRING   ParentName;
    PCWSTRING   KeyName;


    DebugPtrAssert( KeyInfo );
    DebugPtrAssert( Value );

    ParentName = KeyInfo->GetParentName();
    KeyName = KeyInfo->GetName();

    //
    // Create the new value entry
    //
    if( !AddValueEntry( PredefinedKey,
                        ParentName,
                        KeyName,
                        Value,
                        FailIfExists,
                        ErrorCode ) ) {
        DebugPrint( "CreateValueEntry() failed \n" );
        return( FALSE );
    }

    //
    //  Now that the value entry is created we need to update KeyInfo
    //

    if( !UpdateKeyInfo( PredefinedKey, KeyInfo, ErrorCode ) ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_KEY_INFO_NOT_UPDATED;
        }
        return( FALSE );
    }
    return( TRUE );

#endif
}



#if 0  //  NOT_IMPLEMENTED

BOOLEAN
REGISTRY::CopyKey(
     IN  PREDEFINED_KEY     FromPredefinedKey,
     IN  PCWSTRING   FromParentName,
     IN  PCWSTRING   FromKeyName,
     IN  PREDEFINED_KEY     ToPredefinedKey,
     IN  PCWSTRING   ToParentName,
     OUT PULONG             ErrorCode
    )

/*++

Routine Description:

    Copy a key and all its sub keys, to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromParentName - The parent name of the key to be copied.

    FromKeyName - The name of the key to be copied (name relative to its parent).

    ToPredefinedKey - The root of the tree were the new key will be.

    ToParentName - The parent name of the new key.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{

    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromParentName );
    UNREFERENCED_PARAMETER( FromKeyName );
    UNREFERENCED_PARAMETER( ToPredefinedKey );
    UNREFERENCED_PARAMETER( ToParentName );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;

}

#endif  // NOT_IMPLEMENTED


#if 0  // NOT_IMPLEMENTED

BOOLEAN
REGISTRY::CopyKey(
    IN      PREDEFINED_KEY      FromPredefinedKey,
    IN      PCWSTRING    FromParentName,
    IN      PCWSTRING    FromKeyName,
    IN      PREDEFINED_KEY      ToPredefinedKey,
    IN  OUT PREGISTRY_KEY_INFO  ToParentName,
    OUT     PULONG             ErrorCode
    )

/*++

Routine Description:

    Copy a key and all its sub keys, to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromParentName - The parent name of the key to be copied.

    FromKeyName - The name of the key to be copied (name relative to its parent).

    ToPredefinedKey - The root of the tree were the new key will be.

    ToParentKeyInfo - Pointer to the object that contains the information about
                      the parent key of the new key. The information in this
                      object will be updated to reflect the addition of a new
                      subkey.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{
    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromParentName );
    UNREFERENCED_PARAMETER( FromKeyName );
    UNREFERENCED_PARAMETER( ToPredefinedKey);
    UNREFERENCED_PARAMETER( ToParentName );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;
}
#endif // NOT_IMPLEMENTED



#if 0 // NOT_IMPLEMENTED

BOOLEAN
REGISTRY::CopyAllValueEntries(
    IN  PREDEFINED_KEY      FromPredefinedKey,
    IN  PCWSTRING    FromParentName,
    IN  PCWSTRING    FromKeyName,
    IN  PREDEFINED_KEY      ToPredefinedKey,
    IN  PCWSTRING    ToParentName,
    IN  PCWSTRING    ToKeyName,
    OUT PULONG             ErrorCode
    )

/*++

Routine Description:

    Copy all value entries from a key to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromParentName - The parent name of the source key.

    FromKeyName - The name of the source key.

    ToPredefinedKey - The root of the tree where the destination key is.

    ToParentName - The parent name of the destination key.

    ToKeyName - The name of the destination key.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{

    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromParentName );
    UNREFERENCED_PARAMETER( FromKeyName    );
    UNREFERENCED_PARAMETER( ToPredefinedKey);
    UNREFERENCED_PARAMETER( ToParentName   );
    UNREFERENCED_PARAMETER( ToKeyName      );
    UNREFERENCED_PARAMETER( ErrorCode      );

    return FALSE;
}
#endif  // NOT_IMPLEMENTED


#if 0  // NOT_IMPLEMENTED

BOOLEAN
REGISTRY::CopyAllValueEntries(
    IN      PREDEFINED_KEY      FromPredefinedKey,
    IN      PCWSTRING    FromParentName,
    IN      PCWSTRING    FromKeyName,
    IN      PREDEFINED_KEY      ToPredefinedKey,
    IN  OUT PREGISTRY_KEY_INFO  ToKeyInfo,
    OUT     PULONG             ErrorCode
    )

/*++

Routine Description:

    Copy all value entries from a key to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromParentName - The parent name of the source key.

    FromKeyName - The name of the source key.

    ToPredefinedKey - The root of the tree where the destination key is.

    ToKeyInfo - Pointer to the object that contains the information about
                the destination key. This object will be updated to reflect
                the addition of the new values.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{
    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromParentName );
    UNREFERENCED_PARAMETER( FromKeyName );
    UNREFERENCED_PARAMETER( ToPredefinedKey );
    UNREFERENCED_PARAMETER( ToKeyInfo );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;
}

#endif // NOT_IMPLEMENTED



#if 0 // NOT_IMPLEMENTED

BOOLEAN
REGISTRY::CopyOneValueEntry(
    IN  PREDEFINED_KEY      FromPredefinedKey,
    IN  PCWSTRING    FromParentName,
    IN  PCWSTRING    FromKeyName,
    IN  PCWSTRING    FromValueName,
    IN  PREDEFINED_KEY      ToPredefinedKey,
    IN  PCWSTRING    ToParentName,
    IN  PCWSTRING    ToKeyName,
    OUT PULONG             ErrorCode
    )

/*++

Routine Description:

    Copy one value entry from a key to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromParentKeyName - The parent name of the source key.

    FromKeyName - The name of the source key.

    FromValueName - The name of the value to be copied (cannot be NULL).

    ToPredefinedKey - The root of the tree where the destination key is.

    ToParentName - The parent name of the destination key.

    ToKeyName - The name of the destination key.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{
    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromParentName );
    UNREFERENCED_PARAMETER( FromKeyName );
    UNREFERENCED_PARAMETER( FromValueName );
    UNREFERENCED_PARAMETER( ToPredefinedKey );
    UNREFERENCED_PARAMETER( ToParentName );
    UNREFERENCED_PARAMETER( ToKeyName );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;
}

#endif // NOT_IMPLEMENTED


#if 0 // NOT_IMPLEMENTED

BOOLEAN
REGISTRY::CopyOneValueEntry(
    IN      PREDEFINED_KEY      FromPredefinedKey,
    IN      PCWSTRING    FromParentName,
    IN      PCWSTRING    FromKeyName,
    IN      PCWSTRING    FromValueName,
    IN      PREDEFINED_KEY      ToPredefinedKey,
    IN  OUT PREGISTRY_KEY_INFO  ToKeyInfo,
    OUT     PULONG             ErrorCode
    )

/*++

Routine Description:

    Copy one value entry from a key to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromParentKeyName - The parent name of the source key.

    FromKeyName - The name of the source key.

    FromValueName - The name of the value to be copied (can be NULL).

    ToPredefinedKey - The root of the tree where the destination key is.

    ToKeyInfo - Pointer to the object that contains the information about
                the destination key. This object will be updated to reflect
                the addition of the new values.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{
    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromParentName );
    UNREFERENCED_PARAMETER( FromKeyName );
    UNREFERENCED_PARAMETER( FromValueName );
    UNREFERENCED_PARAMETER( ToPredefinedKey );
    UNREFERENCED_PARAMETER( ToKeyInfo );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;
}

#endif  // NOT_IMPLEMENTED


BOOLEAN
REGISTRY::CreateKey(
    IN OUT PREGISTRY_KEY_INFO   NewSubKeyInfo,
    IN     PREDEFINED_KEY       PredefinedKey,
    OUT    PULONG               ErrorCode,
    IN     BOOLEAN              Volatile
    )

/*++

Routine Description:

    Add a subkey to an existing key, and update NewSubkeyInfo to reflect the
    creation of the new key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    NewSubKeyInfo - Pointer to the object that contains the information about
                    the subkey to be created. This object will be updated to
                    reflect the new information about the subkey created.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.

    Volatile    - Volatile flag.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{


#if defined( _AUTOCHECK_ )


    PWSTRING                CompleteKeyName;
    PWSTR                   CompleteKeyNameString;
    PWSTR                   ClassString;
    UNICODE_STRING          UnicodeKeyName;
    UNICODE_STRING          UnicodeClass;
    OBJECT_ATTRIBUTES       ObjAttr;
    HANDLE                  Handle;
    ULONG                   Length;
    NTSTATUS                Status;
    BYTE                    KeyInfo[ KEY_BASIC_SIZE ];



    if ( !NewSubKeyInfo ) {
        return FALSE;
    }
    if ( !NewSubKeyInfo                                                         ||
         !(CompleteKeyName = BuildCompleteName( NewSubKeyInfo->GetParentName(), NewSubKeyInfo->GetName() ) ) ||
         !(CompleteKeyNameString = CompleteKeyName->QueryWSTR() )                ||
         !(ClassString = NewSubKeyInfo->GetClass()->QueryWSTR() )
       ) {

        DELETE( CompleteKeyName );
        FREE( CompleteKeyNameString );
        FREE( ClassString );

        return FALSE;
    }



    //
    // Initialize the OBJECT_ATTRIBUTES structure
    //
    RtlInitUnicodeString( &UnicodeKeyName, CompleteKeyNameString );
    RtlInitUnicodeString( &UnicodeClass,  ClassString );

    InitializeObjectAttributes( &ObjAttr,
                                &UnicodeKeyName,
                                OBJ_CASE_INSENSITIVE,
                                0,
                                0 );


    Status = NtCreateKey( &Handle,
                          KEY_READ,
                          &ObjAttr,
                          NewSubKeyInfo->GetTitleIndex(),
                          &UnicodeClass,
                          Volatile ? REG_OPTION_VOLATILE : REG_OPTION_NON_VOLATILE,
                          NULL );


    DELETE( CompleteKeyName );
    FREE( CompleteKeyNameString );
    FREE( ClassString );


    if ( !NT_SUCCESS( Status ) ) {
        if ( ErrorCode ) {
            *ErrorCode = Status;
        }

        return FALSE;
    }


    Status = NtQueryKey( Handle,
                         KeyBasicInformation,
                         &KeyInfo,
                         KEY_BASIC_SIZE,
                         &Length );

    NtClose( Handle );

    if ( !NT_SUCCESS( Status ) ) {
        if ( ErrorCode ) {
            *ErrorCode = Status;
        }

        return FALSE;
    }


    NewSubKeyInfo->SetNumberOfSubKeys( 0 );
    NewSubKeyInfo->SetNumberOfValues( 0 );
    NewSubKeyInfo->SetLastWriteTime( ((PKEY_BASIC_INFORMATION)KeyInfo)->LastWriteTime );

    return TRUE;



#else

    DWORD       Status;
    HKEY        ParentHandle;
    HKEY        SubKeyHandle;
    PCWSTRING   ParentName;
    PCWSTRING   SubKeyName;
    PWSTR       SubKeyNameString;
    PCWSTRING   Class;
    PWSTR       ClassString;
    TIMEINFO    LastWriteTime;

    PWSTR       lpClass;
    DWORD       cbClass;

    DWORD       cSubKeys;
    DWORD       cbMaxSubKeyLen;
    DWORD       cbMaxClassLen;
    DWORD       cValues;
    DWORD       cbMaxValueNameLen;
    DWORD       cbMaxValueLen;
    DWORD       cbSecurityDescriptor;
    FILETIME    ftLastWriteTime;
    DSTRING     NullString;




    DebugPtrAssert( NewSubKeyInfo );

    //
    //  Open a handle to the parent key
    //
    if( !NullString.Initialize( "" ) ) {
        DebugPrint( "NullString.Initialize() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
        }
        return( FALSE );
    }
    ParentName = NewSubKeyInfo->GetParentName();
    DebugPtrAssert( ParentName );

    if( !OpenKey( PredefinedKey,
                  ParentName,
                  &NullString,
                  KEY_CREATE_SUB_KEY,
                  &ParentHandle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }

    //
    //  To Create the subkey, we need to:
    //
    //      .Get its name
    //      .Get its class
    //      .Call the API to create the subkey
    //

    SubKeyName = ( PWSTRING )NewSubKeyInfo->GetName();
    DebugPtrAssert( SubKeyName );
    SubKeyNameString = SubKeyName->QueryWSTR();

    if( SubKeyNameString == NULL ) {
        if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( ParentHandle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( SubKeyNameString );
        return( FALSE );
    }

    Class = NewSubKeyInfo->GetClass();
    DebugPtrAssert( Class );
    ClassString = Class->QueryWSTR();
    if( ClassString == NULL ) {
        if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( ParentHandle );
        }
        FREE( SubKeyNameString );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( SubKeyNameString );
        return( FALSE );
    }

    Status = RegCreateKeyEx( ParentHandle,
                             SubKeyNameString,
                             0,                 // NewSubKeyInfo->GetTitleIndex(),
                             ClassString,
                             Volatile ? REG_OPTION_VOLATILE : REG_OPTION_NON_VOLATILE,
                             KEY_READ,
                             ( PSECURITY_ATTRIBUTES )NewSubKeyInfo->GetSecurityAttributes(),
                             &SubKeyHandle,
                             NULL );
    FREE( ClassString );
    FREE( SubKeyNameString );
    if( Status != 0 ) {
        DebugPrint( "RegCreateKey() failed" );
        DebugPrintTrace(( "RegCreateKeyEx() returned Status = %#x", Status ));
        if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( ParentHandle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        return( FALSE );
    }
    Status = RegFlushKey( ParentHandle );
    if( Status != 0 ) {
        DebugPrintTrace(( "RegFlushKey() failed, Status = %#x \n", Status ));
        DebugPrint( "RegFlushKey() failed" );
    }


    //
    //  Update NewSubKeyInfo:
    //
    //      .Call RegQueryInfoKey to retrieve the LastWriteTime
    //
    //

    cbClass = ( Class->QueryChCount() + 1 );
    lpClass = ( PWSTR ) MALLOC( ( size_t )( cbClass*sizeof( WCHAR ) ) );
    if( lpClass == NULL ) {
        if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( ParentHandle );
        }
        RegCloseKey( SubKeyHandle );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( lpClass );
        return( FALSE );
    }

    Status = RegQueryInfoKey( SubKeyHandle,
                              ( LPWSTR )lpClass,
                              &cbClass,
                              NULL,
                              &cSubKeys,
                              &cbMaxSubKeyLen,
                              &cbMaxClassLen,
                              &cValues,
                              &cbMaxValueNameLen,
                              &cbMaxValueLen,
                              &cbSecurityDescriptor,
                              &ftLastWriteTime );

    RegCloseKey( SubKeyHandle );
    FREE( lpClass );
    if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( ParentHandle );
    }
    if( Status != 0 ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_KEY_INFO_NOT_UPDATED;
        }
        return( FALSE );
    }

    if( !LastWriteTime.Initialize( &ftLastWriteTime ) ) {
        DebugPrint( "LastWriteTime.Initialize( &ftLastWriteTime ) failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_KEY_INFO_NOT_UPDATED;
        }
    }

    NewSubKeyInfo->SetNumberOfSubKeys( 0 );
    NewSubKeyInfo->SetNumberOfValues( 0 );
    NewSubKeyInfo->PutLastWriteTime( &LastWriteTime );
    NewSubKeyInfo->SetKeyInitializedFlag( TRUE );
    return( TRUE );

#endif

}



BOOLEAN
REGISTRY::CreateKey(
    IN     PREDEFINED_KEY       PredefinedKey,
    IN OUT PREGISTRY_KEY_INFO   KeyInfo,
    IN OUT PREGISTRY_KEY_INFO   NewSubKeyInfo,
    OUT    PULONG               ErrorCode,
    IN     BOOLEAN              Volatile
    )

/*++

Routine Description:

    Add a subkey to an existing key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    KeyInfo - Pointer to the object that contains the information about the
              the key where the subkey will be created. This object will be
              updated to reflect the addition of a new subkey.

    NewSubKeyInfo - Pointer to the object that contains the information about
                    the subkey to be created. This object will be updated to
                    reflect the new information about the subkey created.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


    Volatile  - Volatile flag

Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{

#if defined( _AUTOCHECK_ )

    UNREFERENCED_PARAMETER( PredefinedKey );
    UNREFERENCED_PARAMETER( KeyInfo );
    UNREFERENCED_PARAMETER( NewSubKeyInfo );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;

#else


    PCTIMEINFO   NewLastWriteTime;

    DebugPtrAssert( KeyInfo );
    DebugPtrAssert( NewSubKeyInfo );


    if( !CreateKey( NewSubKeyInfo,
                    PredefinedKey,
                    ErrorCode,
                    Volatile ) ) {

            DebugPrint( "CreateSubKey() failed" );
            return( FALSE );
    }

    NewLastWriteTime = NewSubKeyInfo->GetLastWriteTime();
    DebugPtrAssert( NewLastWriteTime );

    ( KeyInfo->_LastWriteTime ).Initialize( NewLastWriteTime );
    KeyInfo->SetNumberOfSubKeys( KeyInfo->GetNumberOfSubKeys() + 1 );
    return( TRUE );

#endif
}



BOOLEAN
REGISTRY::DeleteKey(
    IN     PREDEFINED_KEY       PredefinedKey,
    IN     PCWSTRING     ParentKeyName,
    IN     PCWSTRING     KeyName,
    OUT    PULONG              ErrorCode
    )

/*++

Routine Description:

    Delete a key and all its subkeys.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentKeyName - The parent name of the key. It can be NULL, and in this
                    case the key to be deleted is a subkey of a predefined
                    key.

    KeyName - The name of the key to be deleted (cannot be NULL). This name
              is relative to its parent.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{
#if defined( _AUTOCHECK_ )

    UNREFERENCED_PARAMETER( PredefinedKey );
    UNREFERENCED_PARAMETER( ParentKeyName );
    UNREFERENCED_PARAMETER( KeyName );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;

#else

    PWSTR   KeyNameWSTR;
    HKEY    ParentHandle;
    HKEY    KeyHandle;
    DWORD   Status;
    DSTRING NullString;


    DebugPtrAssert( ParentKeyName );
    DebugPtrAssert( KeyName );


    //
    //  Open a handle to the parent key
    //

    if( !NullString.Initialize( "" ) ) {
        DebugPrint( "NullString.Initialize() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
        }
        return( FALSE );
    }
    if( !OpenKey( PredefinedKey,
                  ParentKeyName,
                  &NullString,
                  KEY_READ,
                  &ParentHandle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }

    //
    //  We also need a handle to the key to be deleted
    //


    if( !OpenKey( PredefinedKey,
                  ParentKeyName,
                  KeyName,
                  READ_CONTROL | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, // MAXIMUM_ALLOWED,
                  &KeyHandle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey() failed" );
        if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( ParentHandle );
        }
        return( FALSE );
    }


    //
    //  Delete the children
    //
    Status = DeleteTree( KeyHandle );
    if( Status != 0 ) {
        DebugPrintTrace(( "DeleteTree() failed, Status = %#x \n", Status ));
        DebugPrintTrace(( "DeleteTree() failed" ));
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );

        }
        if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( ParentHandle );
        }
        RegFlushKey( KeyHandle );
        RegCloseKey( KeyHandle );
        return( FALSE );
    }
    RegCloseKey( KeyHandle );

    //
    //  Delete the key
    //
    KeyNameWSTR = KeyName->QueryWSTR();
    if( KeyNameWSTR == NULL ) {
        DebugPrint( "KeyName->QueryWSTR() failed" );
        DebugPtrAssert( KeyNameWSTR );
        if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( ParentHandle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        return( FALSE );
    }

    Status = RegDeleteKey( ParentHandle, KeyNameWSTR );
    FREE( KeyNameWSTR );
    if( Status != 0 ) {
        DebugPrintTrace(( "RegDeleteKey() failed, Status = %#x \n", Status ));
        DebugPrint( "RegDeleteKey() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( ParentHandle );
        }
        return( FALSE );
    }
    Status = RegFlushKey( ParentHandle );
    if( Status != 0 ) {
        DebugPrintTrace(( "RegFlushKey() failed, Status = %#x \n", Status ));
        DebugPrint( "RegFlushKey() failed" );
    }
    if( ParentHandle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( ParentHandle );
    }
    return( TRUE );

#endif
}



BOOLEAN
REGISTRY::DeleteKey(
    IN     PREDEFINED_KEY       PredefinedKey,
    IN OUT PREGISTRY_KEY_INFO   ParentKeyInfo,
    IN     PCWSTRING     KeyName,
    OUT    PULONG              ErrorCode
    )

/*++

Routine Description:

    Delete a key and all its subkeys, and update ParentKeyInfo.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    KeyInfo - Pointer to the object that contains the information about the
              the key that contains the subkey to be deleted. This object
              will be updated to reflect the deletion of a subkey.

    KeyName - Name of the key to be deleted (cannot be NULL )

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{
#if defined( _AUTOCHECK_ )

    UNREFERENCED_PARAMETER( PredefinedKey );
    UNREFERENCED_PARAMETER( ParentKeyInfo );
    UNREFERENCED_PARAMETER( KeyName );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;

#else

    PWSTRING    ParentName;
    PCWSTRING   TmpName;
    PCWSTRING   TmpName1;

    DebugPtrAssert( ParentKeyInfo );
    DebugPtrAssert( KeyName );

    TmpName = ParentKeyInfo->GetParentName();
    DebugPtrAssert( TmpName );
    TmpName1 = ParentKeyInfo->GetName();
    DebugPtrAssert( TmpName1 );

    ParentName = BuildCompleteName( TmpName, TmpName1 );
    if( ParentName == NULL ) {
        DebugPrint( "BuildCompleteName() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
        }
        return( FALSE );
    }

    if( !DeleteKey( PredefinedKey, ParentName, KeyName, ErrorCode ) ) {
        DebugPrint( "DeleteKey() failed" );
        DELETE( ParentName );
        return( FALSE );
    }
    DELETE( ParentName );

    //
    //  Update KeyInfo
    //

    if( !UpdateKeyInfo( PredefinedKey, ParentKeyInfo, ErrorCode ) ) {
        DebugPrint( "UpdateKeyInfo() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_KEY_INFO_NOT_UPDATED;
        }
        return( FALSE );
    }
    return( TRUE );

#endif
}



BOOLEAN
REGISTRY::DeleteValueEntry(
    IN  PREDEFINED_KEY      PredefinedKey,
    IN  PCWSTRING    ParentKeyName,
    IN  PCWSTRING    KeyName,
    IN  PCWSTRING    ValueName,
    OUT PULONG             ErrorCode
    )

/*++

Routine Description:

    Delete a value entry from a key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentKeyName - The parent name of the key (can be NULL ).

    KeyName - The name of that contains the Value (cannot be NULL).

    ValueName - The name of the value to be deleted.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{

#if defined( _AUTOCHECK_ )

    PWSTR               ValueNameString = NULL;
    UNICODE_STRING      UnicodeValueName;
    HANDLE              Handle;
    NTSTATUS            Status;
    BOOLEAN             Done = FALSE;


    if ( !OpenKey( ParentKeyName, KeyName, KEY_SET_VALUE, &Handle, ErrorCode ) ) {
        return FALSE;
    }


    if ( ValueName &&
         (ValueNameString = ValueName->QueryWSTR() )
       ) {

        RtlInitUnicodeString( &UnicodeValueName, ValueNameString );

        //
        //  Delete the value
        //
        Status = NtDeleteValueKey( Handle, &UnicodeValueName );


        if ( NT_SUCCESS( Status ) ) {

            Done = TRUE;

        } else {

            if ( ErrorCode != NULL ) {
                *ErrorCode = Status;
            }
        }
    }

    NtClose( Handle );
    FREE( ValueNameString );

    return Done;


#else


    PWSTR       ValueNameString;
    DWORD       Status;
    HKEY        Handle;


    DebugPtrAssert( ValueName );

    if( !OpenKey( PredefinedKey,
                  ParentKeyName,
                  KeyName,
                  KEY_SET_VALUE,
                  &Handle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }

    //
    //  Get the value name
    //

    ValueNameString = ValueName->QueryWSTR();
    if( ValueNameString == NULL ) {
        DebugPrint( "ValueName->QueryWSTR() failed" );
        DebugPtrAssert( ValueNameString );
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        return( FALSE );
    }

    //
    // Delete the value
    //

    Status = RegDeleteValue( Handle, ValueNameString );
    if( Status != 0 ) {
        DebugPrint( "RegDeleteValue() failed" );
        DebugPrintTrace(( "RegDeleteValue() failed, Status = %#x \n", Status ));
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        FREE( ValueNameString );
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        return( FALSE );
    }
    Status = RegFlushKey( Handle );
    if( Status != 0 ) {
        DebugPrintTrace(( "RegFlushKey() failed, Status = %#x \n" ));
        DebugPrint( "RegFlushKey() failed" );
    }
    FREE( ValueNameString );
    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }
    return( TRUE );

#endif
}



BOOLEAN
REGISTRY::DeleteValueEntry(
    IN     PREDEFINED_KEY      PredefinedKey,
    IN OUT PREGISTRY_KEY_INFO  KeyInfo,
    IN     PCWSTRING    Value,
    OUT    PULONG             ErrorCode
    )

/*++

Routine Description:

    Delete a value entry from a key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    KeyInfo - Pointer to the object that contains the information about the
              the key that has the value to be deleted.. This object will be
              updated to reflect the deletion of a new value.

    Value - Name of the value to be deleted.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{
#if defined( _AUTOCHECK_ )

    UNREFERENCED_PARAMETER( PredefinedKey );
    UNREFERENCED_PARAMETER( KeyInfo );
    UNREFERENCED_PARAMETER( Value );
    UNREFERENCED_PARAMETER( ErrorCode);

    return FALSE;

#else

    DebugPtrAssert( KeyInfo );
    DebugPtrAssert( Value );


    PCWSTRING   TmpString;
    PCWSTRING   TmpString1;

    TmpString = KeyInfo->GetParentName();
    DebugPtrAssert( TmpString );
    TmpString1 = KeyInfo->GetName();
    DebugPtrAssert( TmpString1 );

    if( !DeleteValueEntry( PredefinedKey, TmpString, TmpString1, Value, ErrorCode ) ) {
        DebugPrint( "DeleteKey() failed" );
        return( FALSE );
    }
    if( !UpdateKeyInfo( PredefinedKey, KeyInfo, ErrorCode ) ) {
        if( ( ErrorCode != NULL ) && ( *ErrorCode != REGISTRY_ERROR_OUTOFMEMORY ) ) {
            *ErrorCode = REGISTRY_ERROR_KEY_INFO_NOT_UPDATED;
        }
        return( FALSE );
    }
    return( TRUE );

#endif
}


BOOLEAN
REGISTRY::DoesKeyExist(
    IN  PREDEFINED_KEY      PredefinedKey,
    IN  PCWSTRING    ParentName,
    IN  PCWSTRING    KeyName,
    OUT PULONG             ErrorCode
    )

/*++

Routine Description:

    Determine whether a value entry exists.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentName - The parent name of the key we want to check the existence.

    KeyName - The name of the key we want to check the existence.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{

#if defined ( _AUTOCHECK_ )

    HANDLE  Handle;


    if ( !OpenKey( ParentName, KeyName, KEY_QUERY_VALUE, &Handle, ErrorCode ) ) {
        return FALSE;
    }

    NtClose( Handle );

    return TRUE;


#else


    HKEY     Handle;
    ULONG    Status;

    DebugPtrAssert( ParentName );
    DebugPtrAssert( KeyName );

    //
    //  Try to open the key, if it doesn't fail, or if it fails due to
    //  lack of permission, then the key exists
    //
    if( OpenKey( PredefinedKey,
                 ParentName,
                 KeyName,
                 KEY_READ, // MAXIMUM_ALLOWED,
                 &Handle,
                 &Status ) ) {
        RegCloseKey( Handle );
        return( TRUE );
    } else if( Status != REGISTRY_ERROR_ACCESS_DENIED ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = Status;
        }
        return( FALSE );
    } else {
        return( TRUE );
    }
#endif

}




BOOLEAN
REGISTRY::DoesValueExist(
    IN  PREDEFINED_KEY      PredefinedKey,
    IN  PCWSTRING    ParentName,
    IN  PCWSTRING    KeyName,
    IN  PCWSTRING    ValueName,
    OUT PULONG             ErrorCode
    )

/*++

Routine Description:

    Determine whether a value entry exists.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentName - The the parent name of the key that might contain the value.

    KeyName - The name of the key that might contain the value.

    ValueName - Name of the value we want to check the existence.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{

#if defined( _AUTOCHECK_ )


    PWSTR               ValueNameString = NULL;
    UNICODE_STRING      UnicodeValueName;
    HANDLE              Handle;
    NTSTATUS            Status;
    ULONG               Length;
    BOOLEAN             Done = FALSE;
    BYTE                ValueInfo[ VALUE_BASIC_SIZE ];



    if ( !OpenKey( ParentName, KeyName, KEY_QUERY_VALUE, &Handle, ErrorCode ) ) {
        return FALSE;
    }

    if ( ValueName  &&
         (ValueNameString = ValueName->QueryWSTR() )
       ) {

        RtlInitUnicodeString( &UnicodeValueName, ValueNameString );

        //
        //  At this point we have the handle to the key.
        //  Let's check the existence of the value
        //
        Status = NtQueryValueKey( Handle,
                                  &UnicodeValueName,
                                  KeyValueBasicInformation,
                                  &ValueInfo,
                                  VALUE_BASIC_SIZE,
                                  &Length );

        if ( NT_SUCCESS( Status ) ) {

            Done = TRUE;

        } else {

            if ( ErrorCode != NULL ) {
                *ErrorCode = Status;
            }
        }
    }

    NtClose( Handle );
    FREE( ValueNameString );

    return Done;


#else

    HKEY     Handle;
    PWSTR    ValueNameString;
    DWORD    Status;

    DebugPtrAssert( ParentName );
    DebugPtrAssert( KeyName );
    DebugPtrAssert( ValueName );


    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  KEY_QUERY_VALUE,
                  &Handle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey failed" );
        return( FALSE );
    }

    //
    //  Check the existence of the value on the key
    //
    ValueNameString = ValueName->QueryWSTR();
    if( ValueNameString == NULL ) {
        DebugPrint( "ValueName->QueryWSTR() failed" );
        DebugPtrAssert( ValueNameString );
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        return( FALSE );
    }

    Status = RegQueryValueEx( Handle,
                              ValueNameString,
                              NULL,
                              NULL,
                              NULL,
                              NULL );
    FREE( ValueNameString );
    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }
    //
    //  If we can successfully query the key, then it exists.
    //  Otherwise, we have to examine the status code returned by the
    //  API to determine if the value doesn't exist, or if another error
    //  has occurred
    //
    if( Status != 0 ) {
        if( ErrorCode != NULL ) {
            if( Status == ERROR_PATH_NOT_FOUND ) {
                *ErrorCode = REGISTRY_ERROR_VALUE_DOESNT_EXIST;
            } else {
//                DebugPrintTrace(( "RegQueryValueEx() failed, Status = %#x \n", Status ));
//                DebugPrint( "RegQueryValueEx() failed" );
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
        }
        return( FALSE );
    }
    return( TRUE );

#endif
}



#if 0  // NOT_IMPLEMENTED
BOOLEAN
REGISTRY::MoveKey(
     IN  PREDEFINED_KEY     FromPredefinedKey,
     IN  PCWSTRING   FromParentName,
     IN  PCWSTRING   FromKeyName,
     IN  PREDEFINED_KEY     ToPredefinedKey,
     IN  PCWSTRING   ToParentName,
     OUT PULONG            ErrorCode
    )

/*++

Routine Description:

    Move a key and all its sub keys, to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromParentName - The parent name of the key to be moved.

    FromKeyName - The name of the key to be moved (name relative to its parent).

    ToPredefinedKey - The root of the tree were the new key will be.

    ToParentName - The parent name of the new key.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{
    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromParentName );
    UNREFERENCED_PARAMETER( FromKeyName );
    UNREFERENCED_PARAMETER( ToPredefinedKey );
    UNREFERENCED_PARAMETER( ToParentName );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;
}

#endif  // NOT_IMPLEMENTED


#if 0   // NOT_IMPLEMENTED

BOOLEAN
REGISTRY::MoveKey(
    IN      PREDEFINED_KEY      FromPredefinedKey,
    IN  OUT PREGISTRY_KEY_INFO  FromParentKeyInfo,
    IN      PCWSTRING    FromKeyName,
    IN      PREDEFINED_KEY      ToPredefinedKey,
    IN  OUT PREGISTRY_KEY_INFO  ToParentName,
    OUT     PULONG             ErrorCode
    )

/*++

Routine Description:

    Move a key and all its sub keys, to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromParentKeyInfo - Pointer to the object that contains information about
                        the key that holds the subkey to be moved.
                        The information in this object will be updated to reflect
                        the removal of a subkey.

    FromKeyName - The name of the key to be copied (name relative to its parent).

    ToPredefinedKey - The root of the tree were the new key will be.

    ToParentKeyInfo - Pointer to the object that contains the information about
                      the parent key of the new key. The information in this
                      object will be updated to reflect the addition of a new
                      subkey.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{
    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromParentKeyInfo );
    UNREFERENCED_PARAMETER( FromKeyName );
    UNREFERENCED_PARAMETER( ToPredefinedKey );
    UNREFERENCED_PARAMETER( ToParentName );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;
}

#endif // NOT_IMPLEMENTED


#if 0  // NOT_IMPLEMENTED

BOOLEAN
REGISTRY::MoveAllValueEntries(
    IN  PREDEFINED_KEY      FromPredefinedKey,
    IN  PCWSTRING    FromParentName,
    IN  PCWSTRING    FromKeyName,
    IN  PREDEFINED_KEY      ToPredefinedKey,
    IN  PCWSTRING    ToParentName,
    IN  PCWSTRING    ToKeyName,
    OUT PULONG             ErrorCode
    )

/*++

Routine Description:

    Copy one or all value entries from a key to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromParentName - The parent name of the source key (can be NULL ).

    FromKeyName - The name of the source key (cannot be NULL).

    ToPredefinedKey - The root of the tree where the destination key is.

    ToParentName - The parent name of the destination key (can be NULL ).

    ToKeyName - The name of the destination key (cannot be NULL )

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{

    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromParentName );
    UNREFERENCED_PARAMETER( FromKeyName );
    UNREFERENCED_PARAMETER( ToPredefinedKey );
    UNREFERENCED_PARAMETER( ToParentName );
    UNREFERENCED_PARAMETER( ToKeyName );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;
}

#endif


#if 0  // NOT_IMPLEMENTED

BOOLEAN
REGISTRY::MoveAllValueEntries(
    IN      PREDEFINED_KEY      FromPredefinedKey,
    IN  OUT PREGISTRY_KEY_INFO  FromKeyInfo,
    IN      PREDEFINED_KEY      ToPredefinedKey,
    IN  OUT PREGISTRY_KEY_INFO  ToKeyInfo,
    OUT     PULONG             ErrorCode
    )

/*++

Routine Description:

    Move one or all value entries from a key to another key.

Arguments:


    FromPredefinedKey - The root of the tree where the source key is.

    FromKeyInfo - Pointer to the object that contains the information about
                  the source key. The information in this object will be
                  updated to reflect the deletion of values.

    ToPredefinedKey - The root of the tree where the destination key is.

    ToKeyInfo - Pointer to the object that contains the information about
                the destination key. This object will be updated to reflect
                the addition of the new values.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{
    UNREFERENCED_PARAMETER( FromPredefinedKey );
    UNREFERENCED_PARAMETER( FromKeyInfo );
    UNREFERENCED_PARAMETER( ToPredefinedKey );
    UNREFERENCED_PARAMETER( ToKeyInfo );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;
}

#endif // NOT_IMPLEMENTED


BOOLEAN
REGISTRY::QueryKeyInfo(
    IN      PREDEFINED_KEY      PredefinedKey,
    IN      PCWSTRING           ParentName,
    IN      PCWSTRING           KeyName,
    OUT     PREGISTRY_KEY_INFO  KeyInfo,
    OUT     PULONG              ErrorCode
    )

/*++

Routine Description:

    Retrieve the information of a key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentName - Name of the parent key (can be NULL).

    KeyName - Name of the key to be queried (cannot be NULL).

    KeyInfo - Pointer to a NON-INITIALIZED object that will contain the
              information about the key to be queried.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.



--*/


{
#if defined( _AUTOCHECK_ )


    NTSTATUS            Status;
    HANDLE              Handle;
    DSTRING             Class;
    ULONG               Length;
    BYTE                KeyBuf[ KEY_FULL_SIZE ];


    if ( !KeyInfo   ||
         !OpenKey( ParentName, KeyName, KEY_READ, &Handle, ErrorCode ) ) {
        return FALSE;
    }

    Status = NtQueryKey( Handle,
                         KeyFullInformation,
                         &KeyBuf,
                         KEY_FULL_SIZE,
                         &Length );

    NtClose( Handle );

    if ( !NT_SUCCESS( Status ) ) {
        if ( ErrorCode ) {
            *ErrorCode = Status;
        }
    }


    if ( !Class.Initialize( (PWSTR)((PKEY_FULL_INFORMATION)KeyBuf)->Class ) ||
         !KeyInfo->Initialize( KeyName,
                               ParentName,
                               ((PKEY_FULL_INFORMATION)KeyBuf)->TitleIndex,
                               &Class,
                               NULL )

       ) {

        return FALSE;
    }


    KeyInfo->SetLastWriteTime( ((PKEY_FULL_INFORMATION)KeyBuf)->LastWriteTime );
    KeyInfo->SetNumberOfSubKeys( ((PKEY_FULL_INFORMATION)KeyBuf)->SubKeys );
    KeyInfo->SetNumberOfValues( ((PKEY_FULL_INFORMATION)KeyBuf)->Values );

    return TRUE;

#else

    DSTRING     TmpClass;
    TIMEINFO    TmpLastWriteTime;


    DWORD       Status;
    HKEY        Handle;


    //
    // Variables used in QueryKeyInfo()
    //
    LPWSTR      lpClass;
    WSTR        DummyVariable;
    DWORD       cbClass;

    DWORD       cSubKeys;
    DWORD       cbMaxSubKeyLen;
    DWORD       cbMaxClassLen;
    DWORD       cValues;
    DWORD       cbMaxValueNameLen;
    DWORD       cbMaxValueLen;
    DWORD       cbSecurityDescriptor;
    FILETIME    ftLastWriteTime;



    DebugPtrAssert( KeyInfo );
    DebugPtrAssert( ParentName );
    DebugPtrAssert( KeyName );


    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  KEY_READ,
                  &Handle,
                  ErrorCode ) ) {
//        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }


    //
    //  Query the key to find out the size of the buffer needed to hold
    //  the class
    //
    cbClass = 0;
    lpClass = &DummyVariable;
    Status = RegQueryInfoKey( Handle,
                              ( LPWSTR )lpClass,
                              &cbClass,
                              NULL,
                              &cSubKeys,
                              &cbMaxSubKeyLen,
                              &cbMaxClassLen,
                              &cValues,
                              &cbMaxValueNameLen,
                              &cbMaxValueLen,
                              &cbSecurityDescriptor,
                              &ftLastWriteTime );

    if( ( Status != 0 ) && ( Status != ERROR_INVALID_PARAMETER ) && ( Status != ERROR_INSUFFICIENT_BUFFER ) ) {
        DebugPrintTrace(( "RegQueryInfoKey() failed. Error code = %#x \n", Status ));
        DebugPrint( "RegQueryInfoKey() failed." );
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        return( FALSE );
    }

    //
    //  If the value in cbClass is not zero, then allocate a buffer big
    //  enough to hold the class, and query the key again to obtain its
    //  class.
    //
    if( cbClass != 0 ) {
        cbClass++;
        lpClass = ( PWSTR )MALLOC( ( size_t )( cbClass*sizeof( WCHAR ) ) );
        if (lpClass == NULL) {
            DebugPrint( "Unable to allocate memory" );
            DebugPtrAssert( lpClass );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            }
            return( FALSE );
        }
        Status = RegQueryInfoKey( Handle,
                                  ( LPWSTR )lpClass,
                                  &cbClass,
                                  NULL,
                                  &cSubKeys,
                                  &cbMaxSubKeyLen,
                                  &cbMaxClassLen,
                                  &cValues,
                                  &cbMaxValueNameLen,
                                  &cbMaxValueLen,
                                  &cbSecurityDescriptor,
                                  &ftLastWriteTime );

        if( Status != 0 ) {
            DebugPrintTrace(( "RegQueryInfoKey() failed. Error code = %#x \n", Status ));
            DebugPrint( "RegQueryInfoKey() failed." );
            FREE( lpClass );
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            return( FALSE );
        }
    }

    //
    //  At this point there is no need to keep the handle opened.
    //  So, we close the handle.
    //
    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }

    //
    //  Initialize a WSTRING object that contains the class
    //
    if( cbClass != 0 ) {
        //
        //  Initialize TmpClass using the class size. It is not safe to assume
        //  that the class is NULL terminated
        //
        if( !TmpClass.Initialize( ( LPWSTR )lpClass, cbClass ) ) {
            DebugPrint( "TmpClass.Initialize( lpClass ) failed" );
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
            }
        }
        FREE( lpClass );
    } else {
        if( !TmpClass.Initialize( "" ) ) {
            DebugPrint( "TmpClass.Initialize() failed" );
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
            }
        }
    }

    //
    //  Initialize TIMEINFO that contains the last write time
    //
    if( !TmpLastWriteTime.Initialize( &ftLastWriteTime ) ) {
        DebugPrint( "TmpLastWriteTime.Initialize( &ftLastWriteTime ) failed" );
        if( ErrorCode != NULL )  {
            *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
        }
        return( FALSE );
    }

    //
    //  Update KeyInfo
    //

    //
    // Security attributes is currently set to NULL since the API
    // to retrive it is not yet implemented
    //
    SECURITY_ATTRIBUTES     BugSecAttrib;
    PSECURITY_DESCRIPTOR    BugSecDesc;

    BugSecDesc =( PSECURITY_DESCRIPTOR )MALLOC( (size_t) SECURITY_DESCRIPTOR_MIN_LENGTH );
    if (BugSecDesc == NULL) {
        DebugPrint( "Unable to allocate memory" );
        DebugPtrAssert( BugSecDesc );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        return( FALSE );
    }
    InitializeSecurityDescriptor( BugSecDesc, 1 );
    BugSecAttrib.nLength = sizeof( SECURITY_ATTRIBUTES );
    BugSecAttrib.lpSecurityDescriptor = BugSecDesc;
    BugSecAttrib.bInheritHandle = FALSE;


    //
    //  Initialize the REGISTRY_KEY_INFO object
    //
    if( !KeyInfo->Initialize( KeyName,
                              ParentName,
                              0,               // TitleIndex,
                              &TmpClass,
                              &BugSecAttrib ) ) {
        DebugPrint( "KeyInfo->Initialize() failed" );
        DebugPrint( "KeyInfo->Initialize() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
        }
        FREE( BugSecDesc );
        return( FALSE );
    }

    FREE( BugSecDesc );
    KeyInfo->PutLastWriteTime( &TmpLastWriteTime );
    KeyInfo->SetNumberOfSubKeys( cSubKeys );
    KeyInfo->SetNumberOfValues( cValues );
    KeyInfo->SetKeyInitializedFlag( TRUE );
    return( TRUE );

#endif
}


BOOLEAN
REGISTRY::QueryKeySecurity(
    IN  PREDEFINED_KEY          PredefinedKey,
    IN  PCREGISTRY_KEY_INFO     KeyInfo,
    IN  SECURITY_INFORMATION    SecurityInformation,
    IN  PSECURITY_DESCRIPTOR*   SecurityDescriptor,
    IN  PULONG                  ErrorCode
    )

/*++

Routine Description:

    Retrieve security information of a particular key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    KeyInfo - Pointer to a REGISTRY_KEY_INFO object that describes the key
              whose security information is to be retrieved.

    SecurityInformation - Specifies the type of descriptor to retrieve.

    SecurityDescriptor - Address of the variable that will contain the pointer
                         to the security descriptor.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{
#if defined ( _AUTOCHECK_ )

    return FALSE;

#else

    PCWSTRING   ParentName;
    PCWSTRING   KeyName;
    HKEY        Handle;
    DWORD       DummyVariable;
    DWORD       Size;
    PBYTE       Pointer;
    DWORD       Status;
    REGSAM      samDesired;

#if DBG
    PSID    DebugOwnerSid;
    PSID    DebugGroupSid;
    PACL    DebugDacl;
    PACL    DebugSacl;
    BOOL    DebugFlag;
    BOOL    DebugDaclPresent;
    BOOL    DebugSaclPresent;
#endif

    DebugPtrAssert( KeyInfo );
    DebugPtrAssert( SecurityDescriptor );


    ParentName = KeyInfo->GetParentName();
    DebugPtrAssert( ParentName );
    KeyName = KeyInfo->GetName();
    DebugPtrAssert( KeyName );


    //
    //  Open the key.
    //  Need to use ACCESS_SYSTEM_SECURITY to retrieve SACL
    //

    samDesired = ( SecurityInformation & SACL_SECURITY_INFORMATION )?
                   ACCESS_SYSTEM_SECURITY | READ_CONTROL : READ_CONTROL;


    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  samDesired,
                  &Handle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }

    //
    //  Find out the size of the security descriptor
    //
    Size = 0;
    Status = RegGetKeySecurity( Handle,
                                SecurityInformation,
                                &DummyVariable,
                                &Size );

    if( ( Status != 0 ) && ( Status != ERROR_INVALID_PARAMETER ) && ( Status != ERROR_INSUFFICIENT_BUFFER ) ) {
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        DebugPrintTrace(( "RegGetKeySecurity() failed, Status = %#x \n", Status ));
        DebugPrint( "RegGetKeySecurity() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        return( FALSE );
    }

    //
    //  Read the security descriptor
    //
    Pointer = ( PBYTE ) MALLOC( ( size_t )Size );
    if( Pointer == NULL ) {
        DebugPrint( "Unable to allocate memory" );
        DebugPtrAssert( Pointer );
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        return( FALSE );
    }

    Status = RegGetKeySecurity( Handle,
                                SecurityInformation,
                                ( PSECURITY_DESCRIPTOR )Pointer,
                                &Size );
    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }
    if( Status != 0 ) {
        DebugPrintTrace(( "RegGetKeySecurity() failed, Status = %#x \n", Status ));
        DebugPrint( "RegGetKeySecurity() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );;
        }
        FREE( Pointer );
        return( FALSE );
    }

    *SecurityDescriptor = Pointer;

        //
#if DBG // Security Descriptor Validation
        //
    if( IsValidSecurityDescriptor( *SecurityDescriptor ) ) {
//        DebugPrintTrace(( "Security Descriptor is valid \n" ));
    } else {
        DebugPrint( "IsValidSecurityDescriptor() failed" );
        DebugPrintTrace(( "Security Descriptor is NOT valid, Error = %#d \n", GetLastError() ));
    }

    if( !GetSecurityDescriptorOwner( Pointer, &DebugOwnerSid, &DebugFlag ) ) {
        DebugPrint( "GetSecurityDescriptorOwner() failed" );
        DebugPrintTrace(( "Unable to get Sid Owner, Error = %d \n", GetLastError() ));
    } else {
        if( IsValidSid( DebugOwnerSid ) ) {
//            DebugPrintTrace(( "Owner Sid is valid\n" ));
        } else {
            DebugPrint( "IsValidSid() failed" );
            DebugPrintTrace(( "Owner Sid is NOT valid, Error = %#d \n", GetLastError() ));
        }
    }
    if( !GetSecurityDescriptorGroup( Pointer, &DebugGroupSid, &DebugFlag ) ) {
        DebugPrint( "GetSecurityDescriptorGroup() failed" );
        DebugPrintTrace(( "Unable to get Sid Group, Error = %d \n", GetLastError() ));
    } else {
        if( IsValidSid( DebugGroupSid ) ) {
//            DebugPrintTrace(( "Group Sid is valid\n" ));
        } else {
            DebugPrint( "IsValidSid() failed" );
            DebugPrintTrace(( "Group Sid is NOT valid, Error = %#d \n", GetLastError() ));
        }
    }

    if( ( SecurityInformation & DACL_SECURITY_INFORMATION ) != 0 ) {
        if( !GetSecurityDescriptorDacl( Pointer, &DebugDaclPresent, &DebugDacl, &DebugFlag ) ) {
            DebugPrint( "GetSecurityDescriptorDacl() failed" );
            DebugPrintTrace(( "Unable to get DACL, Error = %d \n", GetLastError() ));
        } else {
            if( DebugDaclPresent ) {
                if( IsValidAcl( DebugDacl ) ) {
//                  DebugPrintTrace(( "DACL is valid\n" ));
                } else {
                    DebugPrint( "IsValidAcl() failed" );
                    DebugPrintTrace(( "DACL is NOT valid, Error = %#d \n", GetLastError() ));
                }
            } else {
                DebugPrint( "GetSecurityDescriptorDacl() succeeded but DACL is not present" );
            }
        }
    }

    if( ( SecurityInformation & SACL_SECURITY_INFORMATION ) != 0 ) {
        if( !GetSecurityDescriptorSacl( Pointer, &DebugSaclPresent, &DebugSacl, &DebugFlag ) ) {
            DebugPrint( "GetSecurityDescriptorDacl() failed" );
            DebugPrintTrace(( "Unable to get DACL, Error = %d \n", GetLastError() ));
        } else {
            if( DebugSaclPresent ) {
                if( IsValidAcl( DebugSacl ) ) {
//                  DebugPrintTrace(( "SACL is valid\n" ));
                } else {
                    DebugPrint( "IsValidAcl() failed" );
                    DebugPrintTrace(( "SACL is NOT valid, Error = %#d \n", GetLastError() ));
                }
            } else {
                DebugPrint( "GetSecurityDescriptorSacl() succeeded but SACL is not present" );
            }
        }
    }
#endif //
       // Security Descriptor Validation
       //

    return( TRUE );

#endif
}





BOOLEAN
REGISTRY::QuerySubKeysInfo(
    IN      PREDEFINED_KEY      PredefinedKey,
    IN      PCWSTRING    ParentKey,
    IN      PCWSTRING    KeyName,
    OUT     PARRAY              SubKeysInfo,
    OUT     PULONG             ErrorCode
    )

/*++

Routine Description:

    Return an array of PREGISTRY_KEY_INFO objects, each object containing
    the information of a subkey.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentKey - Name of the parent key.

    KeyName - Name of the key that contains the subkeys to be queried.

    SubKeysInfo - Pointer to an initialized array that will contain the
                  information (PREGISTRY_KEY_INFO) about the subkeys queried.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{


#if defined( _AUTOCHECK_ )

    UNREFERENCED_PARAMETER( PredefinedKey );
    UNREFERENCED_PARAMETER( ParentKey );
    UNREFERENCED_PARAMETER( KeyName );
    UNREFERENCED_PARAMETER( SubKeysInfo );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;

#else

    PWSTRING            CompleteName;
    DSTRING             SubKeyName;


    PREGISTRY_KEY_INFO  TmpInfoKey;
    ULONG               Index;

    DWORD               Status;
    HKEY                Handle;


    //
    // Variables used in RegQueryInfoKey() and RegEnumKeyEx()
    //
    WCHAR       lpName[ MAX_PATH + 1 ];
    DWORD       cbName;
    LPWSTR      lpClass;
    WSTR        DummyVariable;
    DWORD       cbClass;

    DWORD       cSubKeys;
    DWORD       cbMaxSubKeyLen;
    DWORD       cbMaxClassLen;
    DWORD       cValues;
    DWORD       cbMaxValueNameLen;
    DWORD       cbMaxValueLen;
    DWORD       cbSecurityDescriptor;
    FILETIME    ftLastWriteTime;



    DebugPtrAssert( SubKeysInfo );
    DebugPtrAssert( ParentKey );
    DebugPtrAssert( KeyName );


    //
    //  Open a handle to the key, and find out the number of subkeys it has
    //

    if( !OpenKey( PredefinedKey,
                  ParentKey,
                  KeyName,
                  KEY_READ,
                  &Handle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey failed" );
        return( FALSE );
    }


    //
    //  Query the key to find out the number of subkeys it has
    //
    cbClass = 0;
    lpClass = &DummyVariable;
    Status = RegQueryInfoKey( Handle,
                              lpClass,
                              &cbClass,
                              NULL,
                              &cSubKeys,
                              &cbMaxSubKeyLen,
                              &cbMaxClassLen,
                              &cValues,
                              &cbMaxValueNameLen,
                              &cbMaxValueLen,
                              &cbSecurityDescriptor,
                              &ftLastWriteTime );


    if( ( Status != 0 ) && ( Status != ERROR_INVALID_PARAMETER ) && ( Status != ERROR_INSUFFICIENT_BUFFER ) ){
        DebugPrintTrace(( "RegQueryInfoKey() failed, Status = %#x \n", Status ));
        DebugPrint( "RegQueryInfoKey() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        return( FALSE );
    }

    if( cbClass != 0 ) {
        //
        //  If the key has a Class, then we need to allocate a buffer and
        //  read the class, even though we don't need it. If it is not
        //  safe to assume that the other information returned by the
        //  API are correct.
        //
        cbClass++;
        lpClass = ( PWSTR )MALLOC( ( size_t )( cbClass*sizeof( WCHAR ) ) );
        if( lpClass == NULL ) {
            DebugPrint( "Unable to allocate memory" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            }
            DebugPtrAssert( lpClass );
            return( FALSE );
        }
        Status = RegQueryInfoKey( Handle,
                                  lpClass,
                                  &cbClass,
                                  NULL,
                                  &cSubKeys,
                                  &cbMaxSubKeyLen,
                                  &cbMaxClassLen,
                                  &cValues,
                                  &cbMaxValueNameLen,
                                  &cbMaxValueLen,
                                  &cbSecurityDescriptor,
                                  &ftLastWriteTime );

        FREE( lpClass );
        if( Status != 0 ) {
            DebugPrintTrace(( "RegQueryInfoKey() failed, Status = %#x \n", Status ));
            DebugPrint( "RegQueryInfoKey() failed" );
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            return( FALSE );
        }
    }

    //
    //  Get the complete key name. It is the parent name of each
    //  subkey that we are goint to read.
    //

    CompleteName = BuildCompleteName( ParentKey, KeyName );
    if( CompleteName == NULL ) {
        DebugPrint( "BuildCompleteName() failed" );
        DebugPrint( "BuildCompleteName() failed" );
        DebugPtrAssert( CompleteName );
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
        }
        return( FALSE );
    }

    //
    //  Get the name of each subkey, build a REGISTRY_INFO_KEY for
    //  each of them, and put them in the array.
    //

    for( Index = 0; Index < cSubKeys; Index++ ) {

        cbName = sizeof( lpName ) / sizeof (WCHAR);
        Status = RegEnumKeyEx( Handle,
                               Index,
                               ( LPWSTR )lpName,
                               &cbName,
                               NULL,
                               NULL,
                               NULL,
                               &ftLastWriteTime );
        if( Status != 0 ) {
            DebugPrintTrace(( "RegEnumKeyEx() failed, Status = %#x \n", Status ));
            DebugPrint( "RegEnumKeyEx() failed" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            DELETE( CompleteName );
            return( FALSE );
        }
        //
        //  Initialize SubKeyName using the subkey name length. It is not
        //  safe to assume that the name is NULL terminated.
        //
        if( ( cbName != 0 ) &&
            ( lpName[ cbName - 1 ] == ( WCHAR )'\0' ) ) {
            cbName--;
        }

        if( !SubKeyName.Initialize( ( LPWSTR )lpName ) )  {
            DebugPrint( "SubKeyName.Initialize( ( LPWSTR )lpName ) failed" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
            }
            DELETE( CompleteName );
            return( FALSE );
        }
        TmpInfoKey = ( PREGISTRY_KEY_INFO )NEW( REGISTRY_KEY_INFO );
        if( TmpInfoKey == NULL ) {
            DebugPrint( "Unable to allocate memory" );
            DELETE( CompleteName );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            }
            DebugPtrAssert( TmpInfoKey );
            return( FALSE );
        }


        if( !QueryKeyInfo( PredefinedKey,
                           CompleteName,
                           &SubKeyName,
                           TmpInfoKey,
                           ErrorCode ) ) {
            //
            // We have to know why it failed. If it is because we don't have
            // the right permission, we should continue to query the other
            // subkeys.
            //
//            if( ( ErrorCode != NULL ) ) { // && ( *ErrorCode == REGISTRY_ERROR_ACCESS_DENIED ) ) {
                //
                //  If it failed because we don't have permission to access the key
                //  initialize key info with the parent name and key name only.
                //  Notice that Class and LastWriteTime won't be initialized.ext file
                //
                TmpInfoKey->SetKeyInitializedFlag( FALSE );
                if( !TmpInfoKey->PutParentName( CompleteName ) ||
                    !TmpInfoKey->PutName( &SubKeyName ) ) {
                    DebugPrint( "Initialization failure" );
                    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                        RegCloseKey( Handle );
                    }
                    if( ErrorCode != NULL ) {
                        *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
                    }
                    DELETE( CompleteName );
                    DELETE( TmpInfoKey );
                    return( FALSE );
                }

//            } else {
//                DebugPrint( "QueryKeyInfo failed" );
//                if( Handle != _PredefinedKey[ PredefinedKey ] ) {
//                    RegCloseKey( Handle );
//                }
//                DELETE( CompleteName );
//                DELETE( TmpInfoKey );
//                return( FALSE );
//            }
        }


        SubKeysInfo->Put( TmpInfoKey );
    }

    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }
    DELETE( CompleteName );
    return( TRUE );

#endif
}


BOOLEAN
REGISTRY::QueryValue(
    IN      PREDEFINED_KEY           PredefinedKey,
    IN      PCWSTRING         ParentName,
    IN      PCWSTRING         KeyName,
    IN      PCWSTRING         ValueName,
    OUT     PREGISTRY_VALUE_ENTRY    Value,
    OUT     PULONG                  ErrorCode
    )

/*++

Routine Description:

    Return  PREGISTRY_VALUE_ENTRY object, that contains the information
    of a particular value entry in a key.


Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentName - Name of the parent key.

    KeyName - Name of the key that contains the value to be
              queried.

    ValueName - The name of the desired value.

    Value - Pointer to a non initialized REGISTRY_VLUE_ENTRY object
            that will contain the information about the desired value.


    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{

#if defined( _AUTOCHECK_ )

    UNREFERENCED_PARAMETER( PredefinedKey );
    UNREFERENCED_PARAMETER( ParentName );
    UNREFERENCED_PARAMETER( KeyName );
    UNREFERENCED_PARAMETER( ValueName );
    UNREFERENCED_PARAMETER( Value );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;

#else

    PWSTR               ValueNameString;


    DWORD               Status;
    HKEY                Handle;


    //
    // Variables used in RegQueryValueEx()
    //

    DWORD       Type;
    PBYTE       Data;
    DWORD       cbData;
    DWORD       DummyVariable;

    DebugPtrAssert( Value );
    DebugPtrAssert( ValueName );
    DebugPtrAssert( ParentName );
    DebugPtrAssert( KeyName );


    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  KEY_QUERY_VALUE,
                  &Handle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey failed" );
        return( FALSE );
    }

    //
    // Get the value information
    //

    ValueNameString = ValueName->QueryWSTR();
    if( ValueNameString == NULL ) {
        DebugPrint( "ValueName->QueryWSTR()" );
        DebugPtrAssert( ValueNameString );
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        return( FALSE );
    }

    Data = ( PBYTE )&DummyVariable;
    cbData = 0;
    Status = RegQueryValueEx( Handle,
                              ValueNameString,
                              NULL,
                              &Type,
                              Data,
                              &cbData );
    if( ( Status != 0 ) && ( Status != ERROR_INVALID_PARAMETER ) && ( Status != ERROR_INSUFFICIENT_BUFFER ) ) {
        DebugPrintTrace(( "RegQueryValueEx() failed, Status = %#x \n", Status ));
        DebugPrint( "RegQueryValue() failed" );
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        FREE( ValueNameString );
        return( FALSE );
    }


    if( cbData != 0 ) {
        //
        //  If the value entry has data, then read it
        //
        Data = ( PBYTE )MALLOC( ( size_t )cbData );
        if( Data == NULL ) {
            DebugPrint( "Unable to allocate memory" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            FREE( ValueNameString );
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            }
            DebugPtrAssert( Data );
            return( FALSE );
        }

        Status = RegQueryValueEx( Handle,
                                  ValueNameString,
                                  NULL,
                                  &Type,
                                  Data,
                                  &cbData );

        if( Status != 0 ) {
            DebugPrintTrace(( "RegQueryValueEx() failed, Status = %#x \n", Status ));
            DebugPrint( "RegQueryValue() failed" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            FREE( ValueNameString );
            return( FALSE );
        }
    }

    FREE( ValueNameString );
    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }
    if( Status != 0 ) {
        DebugPrintTrace(( "RegQueryValueEx() failed, Status = %#x \n", Status ));
        DebugPrint( "RegQueryValue() failed" );

        //
        //  If the value entry has data, the free the buffer that
        //  contains the data.
        //
        if( Data != ( PBYTE )&DummyVariable ) {
            FREE( Data );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        return( FALSE );
    }

    if( !Value->Initialize( ValueName,
                            0,                    // TitleIndex,
                            ( REG_TYPE )Type,
                            Data,
                            cbData ) ) {
        DebugPrint( "Value->Initialize() failed" );
        if( Data != ( PBYTE )&DummyVariable ) {
            FREE( Data );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
        }
        return( FALSE );
    }
    if( Data != ( PBYTE )&DummyVariable ) {
        FREE( Data );
    }

    return( TRUE );

#endif
}




BOOLEAN
REGISTRY::QueryValues(
    IN      PREDEFINED_KEY      PredefinedKey,
    IN      PCWSTRING    ParentName,
    IN      PCWSTRING    KeyName,
    OUT     PARRAY              Values,
    OUT     PULONG             ErrorCode
    )

/*++

Routine Description:

    Return an array of PREGISTRY_VALUE_ENTRY objects, each object containing
    the information of a value in a key..

Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentName - Name of the parent key.

    KeyName - Name of the key that contains the values to be
              queried.

    Values - Pointer to an initialized array that will contain the
             information (PREGISTRY_VALUE_ENTRY) of each value in the key.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/


{

#if defined( _AUTOCHECK_ )

    BYTE                        KeyBuf[ KEY_FULL_SIZE ];
    PKEY_VALUE_FULL_INFORMATION ValueBuf = NULL;
    ULONG                       ValueBufSize = 1;
    ULONG                       Length;
    ULONG                       Index;
    PREGISTRY_VALUE_ENTRY       RegValue;
    DSTRING                     ValueName;
    PBYTE                       Data;
    NTSTATUS                    Status;
    HANDLE                      Handle;


    if ( !OpenKey( ParentName, KeyName, KEY_READ, &Handle, ErrorCode ) ) {
        return FALSE;
    }


    //
    //  Query the key to find out the number of values it has
    //
    Status = NtQueryKey( Handle,
                         KeyFullInformation,
                         &KeyBuf,
                         KEY_FULL_SIZE,
                         &Length );

    if ( !NT_SUCCESS( Status ) ) {
        if ( ErrorCode != NULL ) {
            *ErrorCode = Status;
        }
        NtClose( Handle );
        return FALSE;
    }


    ValueBufSize = ((PKEY_FULL_INFORMATION)KeyBuf)->MaxValueDataLen;

    if ( !Values                                                        ||
         !(ValueBuf = (PKEY_VALUE_FULL_INFORMATION)MALLOC( ValueBufSize ) )
       ) {

        NtClose( Handle );
        return FALSE;
    }


    //
    //  Get each value, build a REGISTRY_VALUE_ENTRY for
    //  each of them, and put them in the array.
    //
    Values->Initialize( ((PKEY_FULL_INFORMATION)KeyBuf)->Values );

    for ( Index = 0; Index < ((PKEY_FULL_INFORMATION)KeyBuf)->Values; Index++ ) {


        Status = NtEnumerateValueKey( Handle,
                                      Index,
                                      KeyValueFullInformation,
                                      ValueBuf,
                                      ValueBufSize,
                                      &Length );

        if ( !NT_SUCCESS( Status ) ) {

            //
            //  If overflow, grow the bufer and try again.
            //
            if ( Status == STATUS_BUFFER_OVERFLOW ) {

                if ( !(ValueBuf = (PKEY_VALUE_FULL_INFORMATION)REALLOC( ValueBuf, Length ) ) ) {
                    *ErrorCode = 0;
                    NtClose( Handle );
                    FREE( ValueBuf );
                    return FALSE;
                }

                ValueBufSize = Length;

                Status = NtEnumerateValueKey( Handle,
                                              Index,
                                              KeyValueFullInformation,
                                              ValueBuf,
                                              ValueBufSize,
                                              &Length );

            }

            if ( !NT_SUCCESS( Status ) ) {
                if ( ErrorCode ) {
                    *ErrorCode = Status;
                    NtClose( Handle );
                    FREE( ValueBuf );
                    return FALSE;
                }
            }
        }


        //
        //  Initialize the REGISTRY_VALUE_ENTRY object and put it in the array
        //
        Data = (PBYTE)ValueBuf +  ((PKEY_VALUE_FULL_INFORMATION)ValueBuf)->DataOffset;

        if ( !(RegValue = NEW REGISTRY_VALUE_ENTRY )                                        ||
             !ValueName.Initialize( (PSTR)((PKEY_VALUE_FULL_INFORMATION)ValueBuf->Name) )   ||
             !RegValue->Initialize( &ValueName,
                                    (ULONG)ValueBuf->TitleIndex,
                                    (REG_TYPE)ValueBuf->Type,
                                    (PCBYTE)Data,
                                    (ULONG)ValueBuf->DataLength )      ||
             !Values->Put( RegValue )

           ) {

            NtClose( Handle );
            FREE( ValueBuf );
            DELETE( RegValue );
            return FALSE;
        }
    }

    NtClose( Handle );

    FREE( ValueBuf );

    return TRUE;

#else

    DSTRING                ValueNameString;

    PREGISTRY_VALUE_ENTRY  TmpValueEntry;
    ULONG                  Index;

    DWORD                  Status;
    HKEY                   Handle;



    //
    // Variables used in RegQueryInfoKey() and RegEnumKeyEx()
    //
    LPWSTR      lpClass;
    DWORD       cbClass;
    WSTR        DummyVariable;

    DWORD       cSubKeys;
    DWORD       cbMaxSubKeyLen;
    DWORD       cbMaxClassLen;
    DWORD       cValues;
    DWORD       cbMaxValueNameLen;
    DWORD       cbMaxValueLen;
    FILETIME    ftLastWriteTime;

    PWCHAR      ValueName;
    DWORD       cbValueName;
    DWORD       cbSecurityDescriptor;
    DWORD       Type;
    PBYTE       Data;
    DWORD       cbData;

    DebugPtrAssert( Values );
    DebugPtrAssert( ParentName );
    DebugPtrAssert( KeyName );


    //
    //  Open the key
    //

    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  KEY_READ,
                  &Handle,
                  ErrorCode ) ) {

        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }


    //
    //  Query the key to find out the number of values it has
    //
    lpClass = &DummyVariable;
    cbClass = 0;
    Status = RegQueryInfoKey( Handle,
                              ( LPWSTR )lpClass,
                              &cbClass,
                              NULL,
                              &cSubKeys,
                              &cbMaxSubKeyLen,
                              &cbMaxClassLen,
                              &cValues,
                              &cbMaxValueNameLen,
                              &cbMaxValueLen,
                              &cbSecurityDescriptor,
                              &ftLastWriteTime );


    if( ( Status != 0 ) && ( Status != ERROR_INVALID_PARAMETER ) && ( Status != ERROR_INSUFFICIENT_BUFFER ) ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        return( FALSE );
    }
    //
    //  If the key has a Class, then we have to query it again, to retrieve
    //  its class, becase we cannot assume that the other information that the
    //  API returned is correct
    //
    if( cbClass != 0 ) {
        cbClass++;
        lpClass = ( PWSTR )MALLOC( ( size_t )( cbClass*sizeof( WCHAR ) ) );
        if( lpClass == NULL ) {
            DebugPrint( "Unable to allocate memory" );
            DebugPtrAssert( lpClass );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            }
            return( FALSE );
        }

        Status = RegQueryInfoKey( Handle,
                                  ( LPWSTR )lpClass,
                                  &cbClass,
                                  NULL,
                                  &cSubKeys,
                                  &cbMaxSubKeyLen,
                                  &cbMaxClassLen,
                                  &cValues,
                                  &cbMaxValueNameLen,
                                  &cbMaxValueLen,
                                  &cbSecurityDescriptor,
                                  &ftLastWriteTime );

        FREE( lpClass );
        if( Status != 0 ) {
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            return( FALSE );
        }
    }
    //
    //  Get each value, build a REGISTRY_VALUE_ENTRY for
    //  each of them, and put them in the array.
    //
    cbMaxValueNameLen++;
    ValueName = ( PWCHAR )MALLOC( (size_t)( cbMaxValueNameLen*sizeof( WCHAR ) ) );
    Data = ( PBYTE )MALLOC( ( size_t )cbMaxValueLen );
    if( ( Data == NULL ) || ( ValueName == NULL ) ) {
        DebugPrint( "Unable to allocate memory" );
        DebugPtrAssert( Data );
        DebugPtrAssert( ValueName );
        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        FREE( ValueName );
        FREE( Data );
        return( FALSE );
    }
    for( Index = 0; Index < cValues; Index++ ) {
        cbData = cbMaxValueLen;
        cbValueName = cbMaxValueNameLen;
        Status = RegEnumValue( Handle,
                               Index,
                               ( LPWSTR )ValueName,
                               &cbValueName,
                               NULL,
                               &Type,
                               Data,
                               &cbData );
        if( Status != 0 ) {
            DebugPrintTrace(( "RegEnumValue() failed, Status = %#x, cbValueName = %d \n", Status, cbValueName ));
            DebugPrint( "RegEnumValue() failed" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            FREE( Data );
            FREE( ValueName );
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            return( FALSE );
        }
        if( ( cbValueName != 0 ) &&
            ( ValueName[ cbValueName  - 1 ] == ( WCHAR )'\0' ) ) {
            cbValueName--;
        }
        if( !ValueNameString.Initialize( ( LPWSTR )ValueName ) ) {
            DebugPrint( "ValueNameString.Initialize( ( LPWSTR )ValueName ) failed" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            FREE( Data );
            FREE( ValueName );
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
            }
            return( FALSE );
        }

        TmpValueEntry = ( PREGISTRY_VALUE_ENTRY )NEW( REGISTRY_VALUE_ENTRY );
        if( TmpValueEntry == NULL ) {
            DebugPtrAssert( TmpValueEntry );
            DebugPrint( "Unable to allocate memory" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            }
            FREE( ValueName );
            FREE( Data );
            return( FALSE );
        }
        if( !TmpValueEntry->Initialize( &ValueNameString,
                                        0,                    // TitleIndex,
                                        (REG_TYPE)Type ) ) {
            DebugPrint( "TmpValueEntry->Initialize( ) failed" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            FREE( TmpValueEntry);
            FREE( Data );
            FREE( ValueName );
            return( FALSE );
        }
        if (!TmpValueEntry->PutData( Data, cbData )) {
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            }
            FREE( TmpValueEntry);
            FREE( ValueName );
            FREE( Data );
            return( FALSE );
        }
        Values->Put( TmpValueEntry );
    }
    FREE( Data );
    FREE( ValueName );
    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }
    return( TRUE );

#endif
}



BOOLEAN
REGISTRY::SetKeySecurity(
    IN     PREDEFINED_KEY         PredefinedKey,
    IN OUT PREGISTRY_KEY_INFO     KeyInfo,
    IN     SECURITY_INFORMATION   SecurityInformation,
    IN     PSECURITY_DESCRIPTOR   SecurityDescriptor,
    IN     PULONG                 ErrorCode,
    IN     BOOLEAN                Recurse
    )

/*++

Routine Description:

    Set security information of a particular key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    KeyInfo - Pointer to a REGISTRY_KEY_INFO object that describes the key
              whose security information is to be set.

    SecurityInformation - Specifies the type of descriptor to set.

    SecurityDescriptor - Pointer to the scurity descriptor.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.

    Recurse - Indicates whether the security of the subkeys should also be
              set.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{
#if defined ( _AUTOCHECK_ )

    return FALSE;

#else

    PCWSTRING   ParentName;
    PCWSTRING   KeyName;
    HKEY        Handle;
    DWORD       Status;
    REGSAM      samDesired;


    DebugPtrAssert( KeyInfo );
    DebugPtrAssert( SecurityDescriptor );

    ParentName = KeyInfo->GetParentName();
    DebugPtrAssert( ParentName );

    KeyName = KeyInfo->GetName();
    DebugPtrAssert( KeyName );

    samDesired = MAXIMUM_ALLOWED;
    if( SecurityInformation & SACL_SECURITY_INFORMATION ) {
        samDesired |= ACCESS_SYSTEM_SECURITY;
    } else if( SecurityInformation & DACL_SECURITY_INFORMATION ) {
        samDesired |= WRITE_DAC;
    } else if( SecurityInformation & OWNER_SECURITY_INFORMATION ) {
        samDesired |= WRITE_OWNER;
    } else {
        DebugPrint( "ERROR: SecurityInformation is invalid" );
        DebugPrintTrace(( "SecurityInformation is invalid, SecurityInformation = %# \n",
                   SecurityInformation ));
    }


    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  samDesired,
                  &Handle,
                  ErrorCode ) ) {
        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }


    if( Recurse ) {

        if( !SetSubKeysSecurity( Handle,
                                 SecurityInformation,
                                 SecurityDescriptor,
                                 ErrorCode ) ) {

            DebugPrintTrace(( "SetSubKeysSecurity failed, ErrorCode = %#x \n", *ErrorCode ));
            DebugPrint( "SetSubKeysSecurity failed" );
            RegFlushKey( Handle );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( *ErrorCode );
            }
            return( FALSE );
        }
    } else {


        Status = RegSetKeySecurity( Handle,
                                    SecurityInformation,
                                    SecurityDescriptor );
        if( Status != 0 ) {
            DebugPrintTrace(( "RegSetKeySecurity() failed, Status = %#x \n", Status ));
            DebugPrint( "RegSetKeySecurity() failed" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            return( FALSE );
        }
    }

    Status = RegFlushKey( Handle );
    if( Status != 0 ) {
        DebugPrintTrace(( "RegFlushKey() failed, Status = %#x \n" ));
        DebugPrint( "RegFlushKey() failed" );
    }

    //
    //  Close the handle even if it is a predefined handle.
    //  This is necessary so that the predfined handle will contain the new
    //  security, next time it is accesed.
    //
    RegCloseKey( Handle );

    return( TRUE );

#endif
}







BOOLEAN
REGISTRY::UpdateKeyInfo(
    IN      PREDEFINED_KEY      PredefinedKey,
    IN OUT  PREGISTRY_KEY_INFO  KeyInfo,
    OUT     PULONG             ErrorCode
    )

/*++

Routine Description:

    Update _LastWriteTime, _NumberOfSubKeys and _NumberOfValues of
    a REGISTRY_KEY_INFO object.
    This method is used by methods that create key or value entry.


Arguments:


    PredefinedKey - The root of the tree where the key is.

    KeyInfo - Pointer to the object that contains the information about the
              key to be updated.

    ErrorCode - An optional pointer to a variable that will contain an error
                code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the opeartion succeeds.


--*/

{

#if defined( _AUTOCHECK_ )

    UNREFERENCED_PARAMETER( PredefinedKey );
    UNREFERENCED_PARAMETER( KeyInfo );
    UNREFERENCED_PARAMETER( ErrorCode );

    return FALSE;

#else

    PCWSTRING   ParentName;
    PCWSTRING   KeyName;

    DWORD       Status;
    HKEY        Handle;

    // PTIMEINFO   LastWriteTime;

    //
    // Variables used in QueryKeyInfo()
    //
    LPWSTR      lpClass;
    WSTR        DummyVariable;
    DWORD       cbClass;

    DWORD       cSubKeys;
    DWORD       cbMaxSubKeyLen;
    DWORD       cbMaxClassLen;
    DWORD       cValues;
    DWORD       cbMaxValueNameLen;
    DWORD       cbMaxValueLen;
    DWORD       cbSecurityDescriptor;
    FILETIME    ftLastWriteTime;


    DebugPtrAssert( KeyInfo );

    ParentName = KeyInfo->GetParentName();
    DebugPtrAssert( ParentName );

    KeyName = KeyInfo->GetName();
    DebugPtrAssert( KeyName );

    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  KEY_READ,
                  &Handle,
                  ErrorCode  ) ) {
//        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }

    //
    //  Query the key to update _LastWriteTime, _NumberOfSubKeys and _NumberOfValues in KeyInfo
    //
    lpClass = &DummyVariable;
    cbClass = 0;
    Status = RegQueryInfoKey( Handle,
                              ( LPWSTR )lpClass,
                              &cbClass,
                              NULL,
                              &cSubKeys,
                              &cbMaxSubKeyLen,
                              &cbMaxClassLen,
                              &cValues,
                              &cbMaxValueNameLen,
                              &cbMaxValueLen,
                              &cbSecurityDescriptor,
                              &ftLastWriteTime );

    if( ( Status != 0 ) && ( Status != ERROR_INVALID_PARAMETER ) && ( Status != ERROR_INSUFFICIENT_BUFFER ) ) {
        DebugPrintTrace(( "RegQueryInfoKey() failed, Status = %#x \n" ));
        DebugPrint( "RegQueryInfoKey() failed" );

        if( Handle != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Handle );
        }
    }

    //
    //  If the key has a Class, then we need to query the key again to
    //  retrieve its class. This is to make sure that all the information
    //  returned by  API is correct
    //

    if( cbClass != 0 ) {
        cbClass++;
        lpClass = ( LPWSTR )MALLOC( ( size_t )( cbClass*sizeof( WCHAR ) ) );
        if( lpClass == NULL ) {
            DebugPrint( "Unable to allocate memory" );
            DebugPtrAssert( lpClass );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            }
            KeyInfo->SetKeyInitializedFlag( FALSE );
            return( FALSE );
        }
        Status = RegQueryInfoKey( Handle,
                                  ( LPWSTR )lpClass,
                                  &cbClass,
                                  NULL,
                                  &cSubKeys,
                                  &cbMaxSubKeyLen,
                                  &cbMaxClassLen,
                                  &cValues,
                                  &cbMaxValueNameLen,
                                  &cbMaxValueLen,
                                  &cbSecurityDescriptor,
                                  &ftLastWriteTime );

        FREE( lpClass );

        if( Status != 0 ) {
            DebugPrintTrace(( "RegQueryInfoKey() failed, Status = %#x \n" ));
            DebugPrint( "RegQueryInfoKey() failed" );
            if( Handle != _PredefinedKey[ PredefinedKey ] ) {
                RegCloseKey( Handle );
            }
            if( ErrorCode != NULL ) {
                *ErrorCode = MapWin32RegApiToRegistryError( Status );
            }
            KeyInfo->SetKeyInitializedFlag( FALSE );
            return( FALSE );
        }
    }

    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }



    //
    //  Update _LastWriteTime in KeyInfo
    //
    if( !( ( KeyInfo->_LastWriteTime ).Initialize( &ftLastWriteTime ) ) ) {
        DebugPrint( "( KeyInfo->_LastWriteTime )->Initialize( &ftLastWriteTime ) failed" );
        KeyInfo->SetKeyInitializedFlag( FALSE );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_INITIALIZATION_FAILURE;
        }
    }

    //
    //  Update NumberOfSubKeys and NumberOfValues in KeyInfo
    //
    KeyInfo->SetNumberOfSubKeys( cSubKeys );
    KeyInfo->SetNumberOfValues( cValues );
    KeyInfo->SetKeyInitializedFlag( TRUE );
    return( TRUE );

#endif
}



PWSTRING
REGISTRY::BuildCompleteName(
    IN  PCWSTRING    ParentName,
    IN  PCWSTRING    KeyName
    )

/*++

Routine Description:

    Build a complete key name based on its parent name and its name

Arguments:


    ParentName - The name of a key relative to a predefined key (root of a tree).

    KeyName - The name of a key relative to its parent.


Return Value:

    PWSTRING - Returns a WSTRING that contains the complete key name, or
               NULL if an error occurs..


--*/

{

#if defined( _AUTOCHECK_ )


    PWSTRING    CompleteName;

    if ( !(CompleteName = NEW DSTRING )                                 ||
         !CompleteName->Initialize( ParentName )                        ||
         !CompleteName->Strcat( _Separator )                            ||
         !CompleteName->Strcat( KeyName )

       ) {

        DELETE( CompleteName );
        CompleteName = NULL;
    }

    return CompleteName;

#else

    PWSTRING    CompleteName;


    DebugPtrAssert( ParentName );
    DebugPtrAssert( KeyName );

    CompleteName = ( PWSTRING )NEW( DSTRING );
    if( CompleteName == NULL ) {
        DebugPtrAssert( CompleteName );
        return( NULL );
    }

    if( ( ParentName->QueryChCount() == 0 ) &&
        ( KeyName->QueryChCount() == 0 ) ) {
        //
        //  The key is a predefined key
        //
        if( !CompleteName->Initialize( "" ) ) {
            DebugPrint( "CompleteName->Initialize() failed \n" );
            DELETE( CompleteName );
            return( NULL );
        }
    } else if( ParentName->QueryChCount() == 0 ) {
        //
        // The key is a subkey of a predefined key
        //
        if( !CompleteName->Initialize( KeyName ) ) {
            DebugPrint( "CompleteName->Initialize( KeyName ) failed" );
            FREE( CompleteName );
            return( NULL );
        }
    } else {
        if( !CompleteName->Initialize( ParentName ) ) {
            DebugPrint( "CompleteName->Initialize( ParentName ) failed" );
            FREE( CompleteName );
            return( NULL );
        }
        if( KeyName->QueryChCount() != 0 ) {
            CompleteName->Strcat( _Separator );
            CompleteName->Strcat( KeyName );
        }
    }
    return( CompleteName );

#endif
}




#if !defined( _AUTOCHECK_ )
ULONG
REGISTRY::MapWin32RegApiToRegistryError(
    IN ULONG    Status
    ) CONST

/*++

Routine Description:

    Maps status codes returned by Win32 Registry APIs to REGISTRY error codes.

Arguments:

    Status  - Supplies a Win32 status code.

Return Value:

    LONG    - Returns a Registry error code.


        - REGISTRY_ERROR_BADDB
        - REGISTRY_ERROR_CANTOPEN
        - REGISTRY_ERROR_CANTREAD
        - REGISTRY_ERROR_ACCESS_DENIED
        - REGISTRY_ERROR_INVALID_PARAMETER
        - REGISTRY_ERROR_OUTOFMEMORY

--*/

{

    //
    // Map the Win 32 code to a Registry error code.
    //

    switch( Status ) {

    case ERROR_BADDB:

        return REGISTRY_ERROR_BADDB;

    case ERROR_ACCESS_DENIED:

        return REGISTRY_ERROR_ACCESS_DENIED;

    case ERROR_CANTOPEN:

        return REGISTRY_ERROR_CANTOPEN;

    case ERROR_CANTREAD:

        return REGISTRY_ERROR_CANTREAD;

    case ERROR_INVALID_PARAMETER:

        return REGISTRY_ERROR_INVALID_PARAMETER;

    case ERROR_OUTOFMEMORY:

        return REGISTRY_ERROR_OUTOFMEMORY;

    case ERROR_PRIVILEGE_NOT_HELD:

        return REGISTRY_ERROR_PRIVILEGE_NOT_HELD;

    case RPC_S_SERVER_UNAVAILABLE:
    case RPC_S_CALL_FAILED:

        return REGISTRY_RPC_S_SERVER_UNAVAILABLE;

    case ERROR_KEY_DELETED:

        return REGISTRY_ERROR_KEY_DELETED;

    case ERROR_FILE_NOT_FOUND:

        return REGISTRY_ERROR_KEY_NOT_FOUND;

    case ERROR_CHILD_MUST_BE_VOLATILE:

        return REGISTRY_ERROR_CHILD_MUST_BE_VOLATILE;

    default:

//        DebugPrintTrace(( "REGEDIT: Unknown Registry error %#x \n", Status ));
//        DebugPrint( "REGEDIT: Unknown Registry error" );
        return REGISTRY_ERROR_UNKNOWN_ERROR;
    }
}
#endif  // _AUTOCHECK



#if defined( _AUTOCHECK_ )

BOOLEAN
REGISTRY::OpenKey(
    IN  PCWSTRING    ParentKeyName,
    IN  PCWSTRING    KeyName,
    IN  ULONG               Flags,
    OUT PHANDLE             Handle,
    OUT PULONG              ErrorCode
    )
/*++

Routine Description:


    Opens a key and obtains a handle to it

Arguments:


    ParentName  - Supplies the name of a key relative to a predefined key (root of a tree).

    KeyName     - Supplies the name of a key relative to its parent.

    Handle      - Returns the handle to the key

    Status      - Returns the NT status in case of error


Return Value:

    BOOLEAN - TRUE if key opened

--*/
{
    PWSTRING            CompleteKeyName         = NULL;
    PWSTR               CompleteKeyNameString   = NULL;
    UNICODE_STRING      UnicodeKeyName;
    OBJECT_ATTRIBUTES   ObjAttr;
    NTSTATUS            Status;
    BOOLEAN             Opened = FALSE;

    if ( ParentKeyName                                                     &&
         KeyName                                                           &&
         (CompleteKeyName = BuildCompleteName( ParentKeyName, KeyName ) )  &&
         (CompleteKeyNameString = CompleteKeyName->QueryWSTR() )
       ) {

        RtlInitUnicodeString( &UnicodeKeyName, CompleteKeyNameString );

        InitializeObjectAttributes( &ObjAttr,
                                    &UnicodeKeyName,
                                    OBJ_CASE_INSENSITIVE,
                                    0,
                                    0 );

        //
        //  Open the key
        //
        Status = NtOpenKey( Handle, Flags, &ObjAttr );

        if ( NT_SUCCESS( Status ) ) {

            Opened = TRUE;

        } else {

            if ( ErrorCode != NULL ) {
                *ErrorCode = Status;
            }
        }
    }

    DELETE( CompleteKeyName );
    FREE( CompleteKeyNameString );


    return Opened;
}

#endif



#if !defined( _AUTOCHECK_ )

BOOLEAN
REGISTRY::OpenKey(
    IN  PREDEFINED_KEY      PredefinedKey,
    IN  PCWSTRING    ParentName,
    IN  PCWSTRING    KeyName,
    IN  DWORD               Permission,
    OUT PHKEY               Key,
    OUT PULONG              ErrorCode
    )
/*++

Routine Description:


    Opens a handle to a key.

Arguments:


    PredefinedKey - The root of the tree where the key is.

    ParentName  - Supplies the name of a key relative to a predefined key (root of a tree).

    KeyName     - Supplies the name of a key relative to its parent.

    Permission  - Type of access to the key

    Handle      - Returns the handle to the key

    Status      - Returns an error code if the operation fails.


Return Value:

    BOOLEAN - TRUE if key opened

--*/
{

    PWSTRING    CompleteName;
    PWSTR       CompleteNameString;
    ULONG       Status;

#if 0 // DBG
    PSTR        DebugKeyName;
#endif


    DebugPtrAssert( ParentName );
    DebugPtrAssert( KeyName );
    DebugPtrAssert( Key );


    //
    //  Get the complete key name
    //
    CompleteName = BuildCompleteName( ParentName, KeyName );
    if( CompleteName == NULL ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( CompleteName );
        return( FALSE );
    }
    //
    //  Open a handle to the key
    //
    if( CompleteName->QueryChCount() == 0 ) {
        //
        //  This is a predefined key
        //
        if( !IsRemoteRegistry() ||
            ( IsRemoteRegistry() &&
              ( ( Permission & ACCESS_SYSTEM_SECURITY ) == 0 )
            )
          ) {
            *Key = _PredefinedKey[ PredefinedKey ];
            DELETE( CompleteName );
            return( TRUE );
        }
    }

    //
    //  Find out the complete name of the key
    //
    CompleteNameString = CompleteName->QueryWSTR();
#if 0 // DBG
    DebugKeyName = CompleteName->QuerySTR();
#endif
    DELETE( CompleteName );
    if( CompleteNameString == NULL ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( CompleteName );
        return( FALSE );
    }
    //
    //  Open handle to the key
    //
    Status = RegOpenKeyEx( _PredefinedKey[ PredefinedKey ],
                           CompleteNameString,
                           0,
                           Permission,
                           Key );

    if( Status != 0 ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
#if 0 // DBG
        DebugPrintTrace(( "RegOpenKeyEx() failed, KeyName = %s, Permission = %#x, Status = %#x \n"),
                   DebugKeyName, Permission, Status );
#endif
//      DebugPrint( "RegOpenKeyEx() failed" );
        FREE( CompleteNameString );
#if 0 // DBG
        FREE( DebugKeyName );
#endif
        return( FALSE );
    }
    FREE( CompleteNameString );
#if 0 // DBG
    FREE( DebugKeyName );
#endif
    return( TRUE );
}

#endif


#if !defined( _AUTOCHECK_ )

ULONG
REGISTRY::DeleteTree(
    IN HKEY KeyHandle
    )

/*++

Routine Description:


    Delete the subkeys of the key whose handle was passed as argument.
    The deletion process is recusive, that is, the children of the
    subkeys are also deleted.


Arguments:


    KeyHandle - Handle to the key whose subkeys are to be deleted.


Return Value:

    ULONG - Returns 0 if all subkeys were deleted or a Win32 error code
            if something went wrong.


--*/
{

    ULONG       Error;
    DWORD       Index;
    HKEY        ChildHandle;


    WCHAR       KeyName[ MAX_PATH + 1 ];  // +1 counts for the NULL
    DWORD       KeyNameLength;
    PWSTR       ClassName;
    DWORD       ClassNameLength;
    WSTR        DummyVariable;

    DWORD       NumberOfSubKeys;
    DWORD       MaxSubKeyLength;
    DWORD       MaxClassLength;
    DWORD       NumberOfValues;
    DWORD       MaxValueNameLength;
    DWORD       MaxValueDataLength;
    DWORD       SecurityDescriptorLength;
    FILETIME    LastWriteTime;
    ULONG       Status;


    //
    //  Find out the total number of subkeys
    //


    ClassNameLength = 0;

    Error = RegQueryInfoKey(
                KeyHandle,
                &DummyVariable,
                &ClassNameLength,
                NULL,
                &NumberOfSubKeys,
                &MaxSubKeyLength,
                &MaxClassLength,
                &NumberOfValues,
                &MaxValueNameLength,
                &MaxValueDataLength,
                &SecurityDescriptorLength,
                &LastWriteTime
                );
    if( ( Error != 0 ) && ( Error != ERROR_INVALID_PARAMETER ) && ( Error != ERROR_INSUFFICIENT_BUFFER ) ) {
        DebugPrintTrace(( "RegQueryInfoKey() failed, Error = %#x \n", Error ));
        DebugPrint( "RegQueryInfoKey() failed" );
        return( Error );
    }

    if( ClassNameLength != 0 ) {
        ClassNameLength++;
        ClassName = ( PWSTR )MALLOC( ( size_t )( ClassNameLength*sizeof( WCHAR ) ) );
        if( ClassName == NULL ) {
            DebugPrint( "UnableToAllocateMemory" );
            return( ERROR_OUTOFMEMORY );
        }
        Error = RegQueryInfoKey(
                    KeyHandle,
                    ClassName,
                    &ClassNameLength,
                    NULL,
                    &NumberOfSubKeys,
                    &MaxSubKeyLength,
                    &MaxClassLength,
                    &NumberOfValues,
                    &MaxValueNameLength,
                    &MaxValueDataLength,
                    &SecurityDescriptorLength,
                    &LastWriteTime
                    );
        FREE( ClassName );
        if( Error != 0 ) {
            DebugPrintTrace(( "RegQueryInfoKey() failed, Error = %#x \n", Error ));
            DebugPrint( "RegQueryInfoKey() failed" );
            return( Error );
        }
    }
    //
    //  Start de deletion from the last child, instead of the first child.
    //  In this way, it is guaranteed that RegEnumKey() will return
    //  the correct subkey while we are deleting them.
    //
    Status = 0;
    for( Index = NumberOfSubKeys; Index > 0; Index-- ) {

        //  If the key has subkeys, then for each subkey, do:
        //
        //
        //  - Determine the subkey name
        //
        KeyNameLength = sizeof( KeyName ) / sizeof( WCHAR );

        Error = RegEnumKey(
                    KeyHandle,
                    Index-1,
                    KeyName,
                    KeyNameLength
                    );

        if( Error != 0 ) {
            DebugPrintTrace(( "RegQueryInfoKey() failed, Error = %#x \n", Error ));
            DebugPrint( "RegQueryInfoKey() failed" );
            return( Error );
        }

        //
        //  - Open a handle to the subkey
        //

        Error = RegOpenKeyEx(
                    KeyHandle,
                    KeyName,
                    REG_OPTION_RESERVED,
                    READ_CONTROL | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, // MAXIMUM_ALLOWED,
                    &ChildHandle
                    );

        if( Error != 0 ) {
            DebugPrintTrace(( "RegOpenKeyEx() failed, Error = %#x \n", Error ));
            DebugPrint( "RegOpenKey() failed" );
            //
            // We want to delete the maximum number of subkeys.
            //
            Status = Error;
            continue;
        }

        //
        //  - Delete the child's subkeys
        //

        Error = DeleteTree( ChildHandle );
        if( Error != 0 ) {
            Status = Error;
        }
        Error = RegCloseKey(
                    ChildHandle
                    );

        if( Error != 0 ) {
            DebugPrintTrace(( "CloseKeyx() failed, Error = %#x \n", Error ));
            DebugPrint( "RegCloseKey() failed" );
        }

        //
        //  -Delete the subkey
        //

        Error = RegDeleteKey(
                    KeyHandle,
                    KeyName
                    );

        if( Error != 0 ) {
            DebugPrintTrace(( "RegDeletKey() failed, Error = %#x \n", Error ));
            DebugPrint( "RegDeleteKey() failed" );

        }
    }
    return Status;
}

#endif




#if !defined( _AUTOCHECK_ )

BOOLEAN
REGISTRY::EnableRootNotification(
    IN PREDEFINED_KEY   PredefinedKey,
    IN HANDLE           Event,
    IN DWORD            NotifyFilter,
    IN BOOLEAN          WatchSubTree
    )

/*++

Routine Description:


    Enable notification in the prdefined key of a registry.


Arguments:

    PredefinedKey - Indicates which Predefined Key should be monitored.

    Event - Handle to the event object to be signaled when the predefined
            key changes.

    NotifyFilter - Flags that specify in what condition the event should
                   be signaled.

    WatchTree - If TRUE, indicates that the root and all its decsendants
                should be monitored.



Return Value:

    ULONG - Returns 0 if all subkeys were deleted or a Win32 error code
            if something went wrong.


--*/
{
    DWORD   Status;

//    DebugPrintTrace(( "Calling RegNotifyChangeKeyValue() PredefinedKey = %d \n"),
//              PredefinedKey );

//    DebugPrintTrace(( "Calling RegNotifyChangeKeyValue(), PredefinedKey =%d \n", PredefinedKey ));
    Status = RegNotifyChangeKeyValue( _PredefinedKey[ PredefinedKey ],
                                      WatchSubTree,
                                      NotifyFilter,
                                      Event,
                                      TRUE );

    if( Status != 0 ) {

        DebugPrintTrace(( "RegNotifyChangeKeyValue() failed, PredefinedKey = %d, Status = %#x \n",
                   PredefinedKey,
                   Status  ));
        DebugPrint( "RegNotifyChangeKeyValue() failed" );
        return( FALSE );
    }


    return( TRUE );

}

#endif


#if !defined( _AUTOCHECK_ )

BOOLEAN
REGISTRY::
SetSubKeysSecurity(
    IN HKEY                   KeyHandle,
    IN SECURITY_INFORMATION   SecurityInformation,
    IN PSECURITY_DESCRIPTOR   SecurityDescriptor,
    IN PULONG                 ErrorCode
    )

/*++

Routine Description:


    Set the security of the key whose handle was passed as argument,
    and all its subkeys.


Arguments:


    KeyHandle - Handle to the key that contains the subkeys whose security
                is to be set.

    SecurityInformation -

    SecurityDescriptor - Security descriptor to be set in the key.

    ErrorCode - Contains a win32 error code if the call fails.


Return Value:

    BOOLEAN - Returns TRUE if if security was set successfully, or FALSE
              otherwise. If it fails, ErrorCode will contain a win32 error
              code.



--*/
{

    ULONG       Error;
    DWORD       Index;
    HKEY        ChildHandle;


    WCHAR       SubKeyName[ MAX_PATH ];
    DWORD       SubKeyNameLength;
    DWORD       ClassNameLength;
    WSTR        DummyVariable;

    DWORD       NumberOfSubKeys;
    DWORD       MaxSubKeyLength;
    DWORD       MaxClassLength;
    DWORD       NumberOfValues;
    DWORD       MaxValueNameLength;
    DWORD       MaxValueDataLength;
    DWORD       SecurityDescriptorLength;
    FILETIME    LastWriteTime;
    REGSAM      samDesired;
    BOOLEAN     Status;

    HKEY        NewHandle;
    ULONG       Error1;
    DSTRING     ChildKeyName;


    //
    //  -Change the security of the current key
    //

    Error1 = RegSetKeySecurity( KeyHandle,
                                SecurityInformation,
                                SecurityDescriptor );


    //
    //  Find out the total number of subkeys
    //

    Status = TRUE;
    ClassNameLength = 0;

    Error = RegQueryInfoKey(
                KeyHandle,
                &DummyVariable,
                &ClassNameLength,
                NULL,
                &NumberOfSubKeys,
                &MaxSubKeyLength,
                &MaxClassLength,
                &NumberOfValues,
                &MaxValueNameLength,
                &MaxValueDataLength,
                &SecurityDescriptorLength,
                &LastWriteTime
                );
    if( ( Error != 0 ) &&
        ( Error != ERROR_ACCESS_DENIED ) &&
        ( Error != ERROR_INVALID_PARAMETER ) &&
        ( Error != ERROR_INSUFFICIENT_BUFFER ) &&
        ( Error != ERROR_MORE_DATA ) ) {
        DebugPrintTrace(( "RegQueryInfoKey() failed, Error = %#x \n", Error ));
        DebugPrint( "RegQueryInfoKey() failed" );
        *ErrorCode = Error;
        return( FALSE );
    }

    if( Error == ERROR_ACCESS_DENIED ) {
        //
        //  Handle doesn't allow KEY_QUERY_VALUE or READ_CONTROL access.
        //  Open a new handle with these accesses.
        //
        samDesired = KEY_QUERY_VALUE | READ_CONTROL; // MAXIMUM_ALLOWED | READ_CONTROL;
        if( SecurityInformation & SACL_SECURITY_INFORMATION ) {
            samDesired |= ACCESS_SYSTEM_SECURITY;
        } else if( SecurityInformation & DACL_SECURITY_INFORMATION ) {
            samDesired |= WRITE_DAC;
        } else if( SecurityInformation & OWNER_SECURITY_INFORMATION ) {
            samDesired |= WRITE_OWNER;
        } else {
            DebugPrint( "ERROR: SecurityInformation is invalid" );
            DebugPrintTrace(( "SecurityInformation is invalid, SecurityInformation = %# \n",
                       SecurityInformation ));
        }

        Error = RegOpenKeyEx( KeyHandle,
                              NULL,
                              REG_OPTION_RESERVED,
                              samDesired,
                              &NewHandle
                            );

        if( Error != 0 ) {
            DebugPrintTrace(( "RegOpenKeyEx() failed, Error = %#x \n", Error ));
            DebugPrint( "RegOpenKey() failed" );
            *ErrorCode = Error;
            return( FALSE );
        }

        Error = RegQueryInfoKey(
                    NewHandle,
                    &DummyVariable,
                    &ClassNameLength,
                    NULL,
                    &NumberOfSubKeys,
                    &MaxSubKeyLength,
                    &MaxClassLength,
                    &NumberOfValues,
                    &MaxValueNameLength,
                    &MaxValueDataLength,
                    &SecurityDescriptorLength,
                    &LastWriteTime
                    );

        if( ( Error != 0 ) &&
            ( Error != ERROR_INVALID_PARAMETER ) &&
            ( Error != ERROR_INSUFFICIENT_BUFFER ) &&
            ( Error != ERROR_MORE_DATA ) ) {
            DebugPrintTrace(( "RegQueryInfoKey() failed, Error = %#x \n", Error ));
            DebugPrint( "RegQueryInfoKey() failed" );
            *ErrorCode = Error;
            RegCloseKey( NewHandle );
            return( FALSE );
        }
        RegCloseKey( NewHandle );
    }

    if( NumberOfSubKeys == 0 ) {
        //
        //  If the key doesn't have any subkey, return TRUE or FALSE
        //  depending on whether RegSetKeySecurity() succeeded.
        //
        if( Error1 != ERROR_SUCCESS ) {
            *ErrorCode = Error1;
            return( FALSE );
        }
        return( TRUE );
    }

    //
    //  The key has subkeys.
    //  Find out if we are able to enumerate the key using the handle
    //  passed as argument.
    //
    SubKeyNameLength = MAX_PATH;

    Error = RegEnumKey( KeyHandle,
                        0,
                        SubKeyName,
                        SubKeyNameLength
                      );


    if( Error == ERROR_ACCESS_DENIED ) {
        //
        //  Handle doesn't allow 'enumerate' access.
        //  Open a new handle with KEY_ENUMERATE_SUB_KEYS access.
        //
#if 0
        samDesired = MAXIMUM_ALLOWED | KEY_ENUMERATE_SUB_KEYS;
        if( SecurityInformation & SACL_SECURITY_INFORMATION ) {
            samDesired |= ACCESS_SYSTEM_SECURITY;
        } else if( SecurityInformation & DACL_SECURITY_INFORMATION ) {
            samDesired |= WRITE_DAC;
        } else if( SecurityInformation & OWNER_SECURITY_INFORMATION ) {
            samDesired |= WRITE_OWNER;
        } else {
            DebugPrint( "ERROR: SecurityInformation is invalid" );
            DebugPrintTrace(( "SecurityInformation is invalid, SecurityInformation = %# \n"),
                       SecurityInformation );
        }
#endif

        Error = RegOpenKeyEx( KeyHandle,
                              NULL,
                              REG_OPTION_RESERVED,
                              KEY_ENUMERATE_SUB_KEYS, // samDesired,
                              &NewHandle
                            );

        if( Error != 0 ) {
            DebugPrintTrace(( "RegOpenKeyEx() failed, Error = %#x \n", Error ));
            DebugPrint( "RegOpenKey() failed" );
            *ErrorCode = Error;
            return( FALSE );
        }

    } else {
        NewHandle = KeyHandle;
    }




    for( Index = 0; Index < NumberOfSubKeys; Index++ ) {

        //  If the key has subkeys, then for each subkey, do:
        //
        //
        //  - Determine the subkey name
        //
        SubKeyNameLength = MAX_PATH;

        Error = RegEnumKey( NewHandle,
                            Index,
                            SubKeyName,
                            SubKeyNameLength
                          );


        if( Error != ERROR_SUCCESS ) {
            DebugPrintTrace(( "RegQueryInfoKey() failed, Error = %#x \n", Error ));
            DebugPrint( "RegQueryInfoKey() failed" );
            *ErrorCode = Error;
            if( NewHandle != KeyHandle ){
                RegCloseKey( NewHandle );
            }
            return( FALSE );
        }

        if( !ChildKeyName.Initialize( SubKeyName ) ) {
            DebugPrint( "ChildKeyName.Initialize() failed" );
            *ErrorCode = ERROR_OUTOFMEMORY;
            if( NewHandle != KeyHandle ){
                RegCloseKey( NewHandle );
            }
            return( FALSE );
        }


        //
        //  - Open a handle to the subkey
        //

        samDesired = MAXIMUM_ALLOWED;
        if( SecurityInformation & SACL_SECURITY_INFORMATION ) {
            samDesired |= ACCESS_SYSTEM_SECURITY;
        } else if( SecurityInformation & DACL_SECURITY_INFORMATION ) {
            samDesired |= WRITE_DAC;
        } else if( SecurityInformation & OWNER_SECURITY_INFORMATION ) {
            samDesired |= WRITE_OWNER;
        } else {
            DebugPrint( "ERROR: SecurityInformation is invalid" );
            DebugPrintTrace(( "SecurityInformation is invalid, SecurityInformation = %# \n",
                       SecurityInformation ));
        }

        Error = RegOpenKeyEx( NewHandle,
                              ( LPWSTR )( ChildKeyName.GetWSTR() ),
                              REG_OPTION_RESERVED,
                              samDesired,
                              &ChildHandle
                            );


        if( Error == ERROR_SUCCESS ) {

            //
            //  - Set the security of the child's subkeys
            //

            if( !SetSubKeysSecurity( ChildHandle,
                                     SecurityInformation,
                                     SecurityDescriptor,
                                     ErrorCode ) ) {
                Status = FALSE;
            }

            Error = RegCloseKey( ChildHandle );
            if( Error != 0 ) {
                DebugPrintTrace(( "CloseKey() failed, Error = %#x \n", Error ));
                DebugPrint( "RegCloseKey() failed" );
            }

        } else {
            DebugPrintTrace(( "RegOpenKeyEx() failed, Error = %#x \n", Error ));
            DebugPrint( "RegOpenKey() failed" );
            *ErrorCode = Error;
            Status = FALSE;
        }

    }

    if( KeyHandle != NewHandle ) {
        RegCloseKey( NewHandle );
    }

    if( Error1 != ERROR_SUCCESS ) {
        *ErrorCode = Error1;
        return( FALSE );
    }
    return Status;
}

#endif



#if !defined( _AUTOCHECK_ )

BOOLEAN
REGISTRY::LoadHive(
    IN    PREDEFINED_KEY        PredefinedKey,
    IN    PREGISTRY_KEY_INFO    KeyInfo,
    IN    PCWSTRING             FileName,
    OUT   PULONG                ErrorCode
    )

/*++

Routine Description:


    Load a file that conmtains a hive in a particular key in the
    registry.


Arguments:


    PredefinedKey

    KeyInfo

    FileName

    ErrorCode


Return Value:

    BOOLEAN - Returns TRUE if the hive was loaded.

--*/
{
    LONG        Status;
    PCWSTRING   ParentName;
    PCWSTRING   KeyName;
    PWSTRING    CompleteName;

    PWSTR       String;
    PWSTR       String1;


    DebugPtrAssert( KeyInfo );
    DebugPtrAssert( FileName );


    ParentName = KeyInfo->GetParentName();
    KeyName = KeyInfo->GetName();

    if( ( ParentName == NULL ) ||
        ( KeyName == NULL ) ) {
        if( ErrorCode  != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            return( FALSE );
        }
    }

    //
    //  Get the complete key name
    //
    CompleteName = BuildCompleteName( ParentName, KeyName );
    if( CompleteName == NULL ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( CompleteName );
        return( FALSE );
    }


    String = CompleteName->QueryWSTR();
    String1 = FileName->QueryWSTR();

    DELETE( CompleteName );

    if( ( String == NULL  ) ||
        ( String1 == NULL ) ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( String );
        DebugPtrAssert( String1 );
        return( FALSE );
    }

    Status = RegLoadKey( _PredefinedKey[ PredefinedKey ],
                           String,
                           String1 );

    FREE( String );
    FREE( String1 );
    if( Status != 0 ) {
        DebugPrint( "RegLoadKey() failed" );
        DebugPrintTrace(( "RegLoadKey() failed, Status = %d \n", Status ));
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        return( FALSE );
    }

    Status = RegFlushKey( _PredefinedKey[ PredefinedKey ] );
    if( Status != 0 ) {
        DebugPrintTrace(( "RegFlushKey() failed, Status = %d \n", Status ));
        DebugPrint( "RegFlushKey() failed" );
    }


    if( !UpdateKeyInfo( PredefinedKey, KeyInfo, ErrorCode ) ) {
        DebugPrint( "UpdateKeyInfo() failed" );
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_KEY_INFO_NOT_UPDATED;
        }
        return( FALSE );
    }

    return( TRUE );
}

#endif




#if !defined( _AUTOCHECK_ )

BOOLEAN
REGISTRY::UnLoadHive(
    IN    PREDEFINED_KEY        PredefinedKey,
    IN    PREGISTRY_KEY_INFO    KeyInfo,
    OUT   PULONG                ErrorCode
    )

/*++

Routine Description:


    Unload a the key from the registry.


Arguments:


    PredefinedKey

    KeyInfo

    ErrorCode


Return Value:

    BOOLEAN - Returns TRUE if the hive was loaded.

--*/
{
    LONG        Status;
    PCWSTRING   ParentName;
    PCWSTRING   KeyName;
    PWSTRING    CompleteName;

    PWSTR       Name;


    ParentName = KeyInfo->GetParentName();
    KeyName = KeyInfo->GetName();

    if( ( ParentName == NULL ) ||
        ( KeyName == NULL ) ) {
        if( ErrorCode  != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            return( FALSE );
        }
    }

    //
    //  Get the complete key name
    //
    CompleteName = BuildCompleteName( ParentName, KeyName );
    if( CompleteName == NULL ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( CompleteName );
        return( FALSE );
    }


    Name = CompleteName->QueryWSTR();
    DELETE( CompleteName );

    if( Name == NULL ) {
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        DebugPtrAssert( Name );
        return( FALSE );
    }

    Status = RegUnLoadKey( _PredefinedKey[ PredefinedKey ],
                           Name );

    FREE( Name );
    if( Status != 0 ) {
        DebugPrint( "RegUnLoadKey() failed" );
        DebugPrintTrace(( "RegUnLoadKey() failed, Status = %d \n", Status ));
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        return( FALSE );
    }
    Status = RegFlushKey( _PredefinedKey[ PredefinedKey ] );
    if( Status != 0 ) {
        DebugPrintTrace(( "RegFlushKey() failed, Status = %d \n", Status ));
        DebugPrint( "RegFlushKey() failed" );
    }
    return( TRUE );
}

#endif





BOOLEAN
REGISTRY::SaveKeyToFile(
    IN    PREDEFINED_KEY        PredefinedKey,
    IN    PREGISTRY_KEY_INFO    KeyInfo,
    IN    PCWSTRING             FileName,
    OUT   PULONG                ErrorCode
    )

/*++

Routine Description:


    Save a key and all uts subkeys to a file..


Arguments:


    KeyInfo

    FileName

    ErrorCode


Return Value:

    BOOLEAN - Returns TRUE if the key was saved.

--*/
{
    LONG        Status;
    PCWSTRING   ParentName;
    PCWSTRING   KeyName;
    HKEY        Key;
    PWSTR       Name;


    ParentName = KeyInfo->GetParentName();
    KeyName = KeyInfo->GetName();

    if( ( ParentName == NULL ) ||
        ( KeyName == NULL ) ) {
        if( ErrorCode  != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            return( FALSE );
        }
    }


    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  KEY_READ,
                  &Key,
                  ErrorCode ) ) {

        DebugPrint( "OpenKey() failed" );
        DebugPrintTrace(( "OpenKey() failed, ErrorCode = %d \n", *ErrorCode ));
        return( FALSE );
    }


    Name = FileName->QueryWSTR();

    if( Name == NULL ) {
        if( Key != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Key );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        return( FALSE );
    }

    Status = RegSaveKey( Key,
                         Name,
                         NULL );
    FREE( Name );

    if( Key != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Key );
    }
    if( Status != 0 ) {
        DebugPrint( "RegSaveKey() failed" );
        DebugPrintTrace(( "RegSaveKey() failed, Status = %d \n", Status ));
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        return( FALSE );
    }
    return( TRUE );
}



BOOLEAN
REGISTRY::RestoreKeyFromFile(
    IN    PREDEFINED_KEY        PredefinedKey,
    IN    PREGISTRY_KEY_INFO    KeyInfo,
    IN    PCWSTRING             FileName,
    IN    BOOLEAN               Volatile,
    OUT   PULONG                ErrorCode
    )

/*++

Routine Description:


    Save a key and all uts subkeys to a file..


Arguments:


    KeyInfo - Pointer to the object that describes the key where the
              contents of the file is to be restored.

    FileName - Name of the file that contains the information to be
               restored.

    Volatile - Indicates whether the information should be restore as
               volatile or non-volatile.

    ErrorCode - Contains an error code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the key was restored.

--*/
{
    LONG        Status;
    LONG        Error;
    PCWSTRING   ParentName;
    PCWSTRING   KeyName;
    HKEY        Key;
    PWSTR       Name;


    ParentName = KeyInfo->GetParentName();
    KeyName = KeyInfo->GetName();

    if( ( ParentName == NULL ) ||
        ( KeyName == NULL ) ) {
        if( ErrorCode  != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
            return( FALSE );
        }
    }


    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  KEY_WRITE,
                  &Key,
                  ErrorCode ) ) {

        DebugPrint( "OpenKey() failed" );
        DebugPrintTrace(( "OpenKey() failed, ErrorCode = %d \n", *ErrorCode ));
        return( FALSE );
    }


    Name = FileName->QueryWSTR();

    if( Name == NULL ) {
        if( Key != _PredefinedKey[ PredefinedKey ] ) {
            RegCloseKey( Key );
        }
        if( ErrorCode != NULL ) {
            *ErrorCode = REGISTRY_ERROR_OUTOFMEMORY;
        }
        return( FALSE );
    }

    Status = RegRestoreKey( Key,
                            Name,
                            (Volatile)? REG_WHOLE_HIVE_VOLATILE : 0 );
    FREE( Name );




    if( Status == 0 ) {
        Error = RegFlushKey( Key );
        if( Error != 0 ) {
            DebugPrintTrace(( "RegFlushKey() failed, Error = %d \n", Error ));
            DebugPrint( "RegFlushKey() failed" );
        }
    }
    if( Key != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Key );
    }
    if( Status != 0 ) {
        DebugPrint( "RegRestoreKey() failed" );
        DebugPrintTrace(( "RegRestoreKey() failed, Status = %d \n", Status ));
        if( ErrorCode != NULL ) {
            *ErrorCode = MapWin32RegApiToRegistryError( Status );
        }
        return( FALSE );
    }

    return( TRUE );
}



BOOLEAN
REGISTRY::IsAccessAllowed(
    IN    PREDEFINED_KEY        PredefinedKey,
    IN    PREGISTRY_KEY_INFO    KeyInfo,
    IN    REGSAM                SamDesired,
    OUT   PULONG                ErrorCode
    )

/*++

Routine Description:


    Determine if a key allows a particular access.

Arguments:


    PredefinedKey -

    KeyInfo - Pointer to the object that describes the key.

    SamDesired - Access to be verified.

    ErrorCode - Contains an error code if the operation fails.


Return Value:

    BOOLEAN - Returns TRUE if the key allows the access, or FALSE otherwise

--*/
{
    PCWSTRING   ParentName;
    PCWSTRING   KeyName;

    HKEY        Handle;



    DebugPtrAssert( KeyInfo );

    ParentName = KeyInfo->GetParentName();
    DebugPtrAssert( ParentName );

    KeyName = KeyInfo->GetName();
    DebugPtrAssert( KeyName );

    if( !OpenKey( PredefinedKey,
                  ParentName,
                  KeyName,
                  SamDesired,
                  &Handle,
                  ErrorCode  ) ) {
        DebugPrint( "OpenKey() failed" );
        return( FALSE );
    }
    if( Handle != _PredefinedKey[ PredefinedKey ] ) {
        RegCloseKey( Handle );
    }
    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\untfs\src\usnjrnl.cxx ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    usnjrnl.cxx

Abstract:

    This module implements the Usn Journal Checking

Author:

    Daniel Chan (danielch) 05-Mar-97

--*/

#include <pch.cxx>

#define _NTAPI_ULIB_
#define _UNTFS_MEMBER_


#include "ulib.hxx"
#include "ntfssa.hxx"
#include "message.hxx"
#include "rtmsg.h"
#include "ntfsbit.hxx"
#include "attrcol.hxx"
#include "frsstruc.hxx"
#include "attrib.hxx"
#include "attrrec.hxx"
#include "attrlist.hxx"
#include "list.hxx"
#include "iterator.hxx"
#include "attrdef.hxx"
#include "extents.hxx"
#include "mft.hxx"
#include "mftref.hxx"
#include "bootfile.hxx"
#include "badfile.hxx"
#include "mftfile.hxx"
#include "numset.hxx"
#include "ifssys.hxx"
#include "indxtree.hxx"
#include "upcase.hxx"
#include "upfile.hxx"
#include "frs.hxx"
#include "digraph.hxx"
#include "logfile.hxx"
#include "rcache.hxx"
#include "ifsentry.hxx"
#include "sdchk.hxx"


VOID
MarkEndOfUsnBlock(
    IN OUT  PUSN_REC        UsnEntry,
    IN      ULONG           LengthOfBlock
);

BOOLEAN
NTFS_SA::ValidateUsnJournal(
    IN      PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN OUT  PNTFS_CHKDSK_REPORT     ChkdskReport,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft,
    IN OUT  PNUMBER_SET             BadClusters,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message
    )
/*++

Routine Description:

    This routine ensures that the two data streams in the USN Journal
    file is in good shape.  For the $MAX data stream, it makes sure
    its value is within a resonable range.  For the $J data stream,
    it make sures its file size agree with the largest Usn found on
    the volume.  It also make sures each record is consistent.


Arguments:

    ChkdskInfo  - Supplies the current chkdsk information.
    ChkdskReport- Supplies the current chkdsk report.
    Mft         - Supplies a valid MFT.
    BadClusters - Receives the bad clusters identified by this method.
    FixLevel    - Supplies the fix level.
    Message     - Supplies an outlet for messages

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    NTFS_FILE_RECORD_SEGMENT    frs;
    NTFS_ATTRIBUTE              attrib;
    BOOLEAN                     chkdskErrCouldNotFix = FALSE;
    BOOLEAN                     attribute_need_write;
    BOOLEAN                     empty_usn_journal;
    BOOLEAN                     frs_need_flush;
    BOOLEAN                     lastblock;
    BOOLEAN                     error;
    BOOLEAN                     rst;
//    ULONG                       new_percent_done;
//    ULONG                       percent_done = 0;
    ULONG                       num_bytes;
    ULONG                       remain_length;
    ULONG                       remain_block_length;
    ULONG                       bytesWritten;
    ULONG                       bytesToRead;
    ULONG                       depth;
//    ULONG                       initial_length;
    ULONG                       length;
    ULONG                       record_size;
    BIG_INT                     offset;
    BIG_INT                     total_length;
    BIG_INT                     usnJournalMaxSize;
    CREATE_USN_JOURNAL_DATA     usnJournalMax;
    PCINDEX_ENTRY               index_entry;
    PUSN_REC                    usn_entry = NULL;
    PUSN_REC                    previous_usn_entry;
    PUSN_REC                    initial_usn_entry = NULL;
    PUSN_REC                    endOfBlock;
    DSTRING                     attributeName;
    ULONG                       errFixedStatus = CHKDSK_EXIT_SUCCESS;
    USHORT                      volume_flags;
    BOOLEAN                     is_corrupt;
    UCHAR                       major, minor;
    BIG_INT                     location;

    DebugPtrAssert(ChkdskInfo);
    DebugPtrAssert(ChkdskReport);

    if (ChkdskInfo->UsnJournalFileNumber.GetLowPart() == 0 &&
        ChkdskInfo->UsnJournalFileNumber.GetHighPart() == 0) {

        // assume the Usn Journal feature has not been enabled
        // all Usn should be zeroed

        if (LargestUsnEncountered == 0) {
            return TRUE;
        }

        // some Usn are non-zeros, so zero them out.

        return ResetUsns(ChkdskInfo, FixLevel, Message, Mft);
    }

    Message->DisplayMsg(MSG_CHK_NTFS_CHECKING_USNJRNL, PROGRESS_MESSAGE);

    if (!frs.Initialize(ChkdskInfo->UsnJournalFileNumber, Mft) ||
        !attributeName.Initialize(UsnJournalMaxNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!frs.Read()) {
        DebugAbort("Previously readable FRS is no longer readable");
        return FALSE;
    }

    volume_flags = QueryVolumeFlagsAndLabel(&is_corrupt, &major, &minor);
    if (volume_flags & VOLUME_DELETE_USN_UNDERWAY && FixLevel != CheckOnly) {

        NTFS_FILE_RECORD_SEGMENT    extend_frs;
        NTFS_INDEX_TREE             index;

        Message->DisplayMsg(MSG_CHK_NTFS_DELETING_USNJRNL);

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        if (!attributeName.Initialize(UsnJournalNameData)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        if (frs.QueryAttribute(&attrib,
                               &error,
                               $DATA,
                               &attributeName)) {

            BIG_INT     total_user_bytes;

            total_user_bytes = attrib.QueryClustersAllocated() * QueryClusterFactor() *
                               _drive->QuerySectorSize();

            // un-account user data previously accounted for

            ChkdskReport->BytesUserData -= total_user_bytes;
            ChkdskReport->NumUserFiles -= 1;
        } else {
            if (error) {
                DebugPrintTrace(("UNTFS: Unable to query Usn Journal $DATA, %s attribute.\n",
                                 UsnJournalNameData));
            }
            // not fatal yet as we are going to delete it anyway
        }

        if (!frs.Delete(Mft->GetVolumeBitmap())) {
            DebugPrintTrace(("Error in deleting the USN Journal file.\n"));
            return FALSE;
        }

        if (!extend_frs.Initialize(EXTEND_TABLE_NUMBER, Mft) ||
            !attributeName.Initialize(FileNameIndexNameData)) {
             Message->DisplayMsg(MSG_CHK_NO_MEMORY);
             return FALSE;
        }

        if (!extend_frs.Read()) {
            DebugPrintTrace(("Previously readable FRS is no longer readable\n"));
            return FALSE;
        }

        if (!index.Initialize(_drive,
                              QueryClusterFactor(),
                              Mft->GetVolumeBitmap(),
                              Mft->GetUpcaseTable(),
                              extend_frs.QuerySize()/2,
                              &extend_frs,
                              &attributeName)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        index.ResetIterator();

        while (index_entry = index.GetNext(&depth, &error)) {
            if ((index_entry->FileReference.LowPart ==
                 ChkdskInfo->UsnJournalFileNumber.GetLowPart()) &&
                (index_entry->FileReference.HighPart ==
                 ChkdskInfo->UsnJournalFileNumber.GetHighPart())) {
                ChkdskInfo->UsnJournalFileNumber = 0;
                if (!index.DeleteCurrentEntry()) {
                    Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                    return FALSE;
                } else if (!index.Save(&extend_frs) ||
                           !extend_frs.Flush(Mft->GetVolumeBitmap())) {
                    Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_INDEX,
                                        "%d%W",
                                        EXTEND_TABLE_NUMBER,
                                        index.GetName());
                    return FALSE;
                } else {
                    rst = ResetUsns(ChkdskInfo, FixLevel, Message, Mft);
                    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);
                    return rst;
                }
            }
        }
        DebugPrintTrace(("Unable to locate the USN journal index entry\n"));
        return FALSE;
    }

    //
    // now check the named $DATA, $Max attribute of Usn Journal
    //

    if (!frs.QueryAttribute(&attrib,
                            &error,
                            $DATA,
                            &attributeName)) {
        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_USNJRNL_DATA,
                            "%W", &attributeName);
        if (!attrib.Initialize(_drive,
                               QueryClusterFactor(),
                               NULL,
                               0,
                               $DATA,
                               &attributeName)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // use zeros so that ntfs will use its own default

        usnJournalMax.MaximumSize = 0;
        usnJournalMax.AllocationDelta = 0;

        if (!attrib.Write(&usnJournalMax,
                          0,
                          sizeof(usnJournalMax),
                          &bytesWritten,
                          Mft->GetVolumeBitmap()) ||
            bytesWritten != sizeof(usnJournalMax)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USN_DATA_STREAM,
                                "%W", &attributeName);
            return FALSE;
        }

        if (!attrib.InsertIntoFile(&frs,
                                   Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
            return FALSE;
        }

        if (FixLevel != CheckOnly &&
            !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
            return FALSE;
        }
        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
    } else {

        if (!attrib.RecoverAttribute(Mft->GetVolumeBitmap(),
                                     BadClusters)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USN_DATA_STREAM,
                                "%W", &attributeName);
            return FALSE;
        }

        // don't be strict on size of attribute value

        error = FALSE;
        if (attrib.QueryValueLength() < sizeof(usnJournalMax)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_ATTR_LENGTH_TOO_SMALL_FOR_FILE,
                         "%x%W%I64x%x%I64x",
                         attrib.QueryTypeCode(),
                         &attributeName,
                         attrib.QueryValueLength().GetLargeInteger(),
                         sizeof(usnJournalMax),
                         ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

            error = TRUE;
        } else if (!attrib.Read(&usnJournalMax,
                                0,
                                sizeof(usnJournalMax),
                                &bytesToRead)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_USN_JRNL_ATTR,
                         "%x%W%I64x",
                         attrib.QueryTypeCode(),
                         &attributeName,
                         ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

            error = TRUE;
        } else if (bytesToRead != sizeof(usnJournalMax)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_UNABLE_TO_READ_USN_JRNL_ATTR,
                         "%x%W%I64x",
                         attrib.QueryTypeCode(),
                         &attributeName,
                         ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

            error = TRUE;
        }

        if (error) {

            Message->DisplayMsg(MSG_CHK_NTFS_REPAIR_USN_DATA_STREAM,
                                "%W", &attributeName);

            usnJournalMax.MaximumSize = 0;
            usnJournalMax.AllocationDelta = 0;

            if (!attrib.Write(&usnJournalMax,
                              0,
                              sizeof(usnJournalMax),
                              &bytesWritten,
                              Mft->GetVolumeBitmap()) ||
                bytesWritten != sizeof(usnJournalMax)) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USN_DATA_STREAM,
                                    "%W", &attributeName);
                return FALSE;
            }
            if (!attrib.InsertIntoFile(&frs,
                                       Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
                return FALSE;
            }

            if (FixLevel != CheckOnly &&
                !frs.Flush(Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
                return FALSE;
            }
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
        }
    }

    //
    // now check the named $DATA, $J attribute of Usn Journal
    //

    if (!attributeName.Initialize(UsnJournalNameData)) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    if (!frs.QueryAttribute(&attrib,
                            &error,
                            $DATA,
                            &attributeName)) {

        Message->DisplayMsg(MSG_CHK_NTFS_CREATE_USNJRNL_DATA,
                            "%W", &attributeName);

        if (!attrib.Initialize(_drive,
                               QueryClusterFactor(),
                               NULL,
                               0,
                               $DATA,
                               &attributeName,
                               ATTRIBUTE_FLAG_SPARSE)) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        //
        // Align to max cluster size (64K) boundary
        //

        total_length = LargestUsnEncountered+8;
        total_length = total_length + 0xffff;
        total_length.Set(total_length.GetLowPart() & ~0xFFFF,
                          total_length.GetHighPart());

        if (total_length.GetQuadPart() > USN_JRNL_MAX_FILE_SIZE) {
            total_length = 0;
        }

        if (!attrib.SetSparse(total_length, Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }
        if (!attrib.InsertIntoFile(&frs,
                                   Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
            return FALSE;
        }
        if (FixLevel != CheckOnly &&
            !frs.Flush(Mft->GetVolumeBitmap())) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
            return FALSE;
        }

        errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

        if (total_length == 0)
            rst = ResetUsns(ChkdskInfo, FixLevel, Message, Mft);
        else
            rst = TRUE;

        Message->DisplayMsg(MSG_CHK_NTFS_USNJRNL_VERIFICATION_COMPLETED, PROGRESS_MESSAGE);

        UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

        return rst;    // done

    } else {

        BIG_INT     total_user_bytes;

        total_user_bytes = attrib.QueryClustersAllocated() * QueryClusterFactor() *
                           _drive->QuerySectorSize();

        // un-account user data previously accounted for

        ChkdskReport->BytesUserData -= total_user_bytes;
        ChkdskReport->NumUserFiles -= 1;

        if (!attrib.RecoverAttribute(Mft->GetVolumeBitmap(),
                                     BadClusters)) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USN_DATA_STREAM,
                                "%W", &attributeName);
            return FALSE;
        }

        attribute_need_write = FALSE;
        empty_usn_journal = FALSE;

        if (!(attrib.QueryFlags() & ATTRIBUTE_FLAG_SPARSE)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_SPARSE_FLAG_NOT_SET_FOR_ATTR,
                         "%x%W%I64x",
                         attrib.QueryTypeCode(),
                         &attributeName,
                         ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());


            attrib.SetFlags(ATTRIBUTE_FLAG_SPARSE);
            attribute_need_write = TRUE;
            DebugPrintTrace(("UNTFS: The sparse flag for $J attribute is not set\n"));
        }

        total_length = attrib.QueryValueLength();

        offset = 0;
        usnJournalMaxSize = -1;

        if (!attrib.GetNextAllocationOffset(&offset, &usnJournalMaxSize)) {
            return FALSE;
        }

        if (offset > total_length) {
            DebugAbort("The offset is larger than the length of the attribute");
            return FALSE;
        }

        if (offset.GetLowPart() & (USN_PAGE_SIZE-1)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_OFFSET_NOT_AT_PAGE_BOUNDARY,
                         "%I64x%I64x",
                         offset.GetLargeInteger(),
                         ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

            DebugPrintTrace(("UNTFS: USN allocation offset of 0x%I64x not at USN page boundary\n",
                             offset.GetLargeInteger()));
            //
            // Start at page boundary
            //
            offset = (offset + (USN_PAGE_SIZE-1));
            offset.Set(offset.GetLowPart() & ~(USN_PAGE_SIZE-1),
                       offset.GetHighPart());
        }

        error = FALSE;
        if ((!(total_length == 0 && LargestUsnEncountered == 0)) &&
            total_length < (LargestUsnEncountered+8)) {

            Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_LENGTH_LESS_THAN_LARGEST_USN_ENCOUNTERED,
                         "%I64x%I64x%I64x%I64x",
                         total_length.GetLargeInteger(),
                         LargestUsnEncountered,
                         *((PLARGE_INTEGER)&FrsOfLargestUsnEncountered),
                         ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

            DebugPrintTrace(("UNTFS: Usn journal length 0x%I64x\n"
                             "and largest Usn encountered 0x%I64x.\n",
                             total_length,
                             LargestUsnEncountered));
            DebugPrintTrace(("UNTFS: Largest Usn encountered at frs 0x%I64x\n",
                             FrsOfLargestUsnEncountered));
            error = TRUE;
        } else if (total_length.GetQuadPart() > USN_JRNL_MAX_FILE_SIZE) {

            Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_LENGTH_TOO_LARGE,
                         "%I64x%I64x%I64x",
                         total_length.GetLargeInteger(),
                         USN_JRNL_MAX_FILE_SIZE,
                         ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

            error = TRUE;
        } else if (offset > total_length) {

            Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_LENGTH_LESS_THAN_OFFSET,
                         "%I64x%I64x%I64x",
                         total_length.GetLargeInteger(),
                         offset.GetLargeInteger(),
                         ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

            error = TRUE;
        }

        if (error) {

            // Align to max cluster size (64K) boundary

            total_length = LargestUsnEncountered+8;
            total_length = total_length + 0xffff;
            total_length.Set(total_length.GetLowPart() & ~0xFFFF,
                             total_length.GetHighPart());

            if (total_length.GetQuadPart() > USN_JRNL_MAX_FILE_SIZE) {
                DebugPrintTrace(("UNTFS: Resetting USN journal size as it exceeded maximum.\n"));
                total_length = 0;
            }

            if (!attrib.SetSparse(total_length,
                                  Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
                return FALSE;
            }
            attribute_need_write = TRUE;
            empty_usn_journal = TRUE;

        }

        if (attribute_need_write) {

            Message->DisplayMsg(MSG_CHK_NTFS_REPAIR_USN_DATA_STREAM,
                                "%W", &attributeName);

            if (!attrib.InsertIntoFile(&frs,
                                       Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
                return FALSE;
            }
            if (FixLevel != CheckOnly &&
                !frs.Flush(Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_PUT_DATA_ATTRIBUTE);
                return FALSE;
            }

            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;

            if (empty_usn_journal) {
                if (total_length == 0)
                    rst = ResetUsns(ChkdskInfo, FixLevel, Message, Mft);
                else
                    rst = TRUE;

                Message->DisplayMsg(MSG_CHK_NTFS_USNJRNL_VERIFICATION_COMPLETED, PROGRESS_MESSAGE);

                UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

                return rst;
            }
        }
    }

    // Read in the $DATA, $J attribute and validate.

    // allocate space for a page of usn journal records

    if ((initial_usn_entry = (PUSN_REC)MALLOC(USN_PAGE_SIZE)) == NULL) {
        Message->DisplayMsg(MSG_CHK_NO_MEMORY);
        return FALSE;
    }

    frs_need_flush = FALSE;
    endOfBlock = (PUSN_REC)((PCHAR)initial_usn_entry+USN_PAGE_SIZE);
    total_length = total_length - offset;
    DebugAssert(total_length.GetHighPart() == 0);
    remain_length = total_length.GetLowPart();

#if 0   // disable progress bar as it may be needed in the future
    initial_length = remain_length;
    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 0)) {
        return FALSE;
    }
#endif

    for(; remain_length > 0;) {

#if 0   // disable progress bar as it may be needed in the future
        new_percent_done = 100*(initial_length - remain_length)/initial_length;
        if (new_percent_done != percent_done) {
            percent_done = new_percent_done;
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                return FALSE;
            }
        }
#endif

        previous_usn_entry = NULL;
        attribute_need_write = FALSE;
        bytesToRead = min(USN_PAGE_SIZE, remain_length);
        usn_entry = initial_usn_entry;

        if (!attrib.Read(usn_entry,
                         offset,
                         bytesToRead,
                         &num_bytes) ||
            num_bytes != bytesToRead) {
            Message->DisplayMsg(MSG_CHK_NTFS_CANT_READ_USN_DATA_STREAM,
                                "%W", &attributeName);
            FREE(initial_usn_entry);
            return FALSE;
        }

        lastblock = remain_length <= USN_PAGE_SIZE;
        length = bytesToRead;

        while (length > 0) {
            if (usn_entry == endOfBlock) {
                break;
            }
            if (usn_entry->RecordLength == 0) {
                DebugAssert((LONG)bytesToRead >= ((PCHAR)usn_entry-(PCHAR)initial_usn_entry));
                if (lastblock) {
                    DebugAssert(bytesToRead == remain_length);
                    if (bytesToRead < USN_PAGE_SIZE) {

                        Message->LogMsg(MSG_CHKLOG_NTFS_INCOMPLETE_LAST_USN_JRNL_PAGE,
                                     "%I64x%I64x",
                                     (offset+(ULONG)(((PCHAR)usn_entry-(PCHAR)initial_usn_entry))).GetLargeInteger(),
                                     ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                        attribute_need_write = TRUE;
                    }
                    remain_block_length = USN_PAGE_SIZE -
                                          (ULONG)((PCHAR)usn_entry-(PCHAR)initial_usn_entry);
                    bytesToRead = remain_length = USN_PAGE_SIZE;
                } else {
                    remain_block_length = bytesToRead -
                                          (ULONG)((PCHAR)usn_entry-(PCHAR)initial_usn_entry);
                    DebugAssert(remain_block_length == length);
                }
                if (!RemainingBlockIsZero((PCHAR)usn_entry, remain_block_length)) {

                    location = offset + (ULONG)((PCHAR)usn_entry - (PCHAR)initial_usn_entry);

                    Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_REMAINING_OF_A_PAGE_CONTAINS_NON_ZERO,
                                 "%I64x%I64x",
                                 location.GetLargeInteger(),
                                 ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                    DebugPrintTrace(("UNTFS: USN remaining block starting at 0x%I64x non-zero\n",
                                     location.GetLargeInteger()));
                    MarkEndOfUsnBlock(usn_entry, remain_block_length);
                    attribute_need_write = TRUE;
                }
                break;
            }

            num_bytes = usn_entry->RecordLength;
            error = FALSE;

            location = offset + (ULONG)((PCHAR)usn_entry - (PCHAR)initial_usn_entry);

            if ((PCHAR)usn_entry - (PCHAR)initial_usn_entry + num_bytes > USN_PAGE_SIZE) {

                Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_ENTRY_CROSSES_PAGE_BOUNDARY,
                             "%I64x%x%I64x",
                             location.GetLargeInteger(),
                             num_bytes,
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("USN entry end crosses USN page boundary.\n"));

                error = TRUE;
            } else if (length < num_bytes) {

                Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_ENTRY_LENGTH_EXCEEDS_REMAINING_PAGE_LENGTH,
                             "%I64x%x%x%I64x",
                             location.GetLargeInteger(),
                             num_bytes,
                             length,
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("USN entry length of %d exceeds remaining page length of %x.\n",
                                 num_bytes, length));
                error = TRUE;
            } else if (num_bytes >= USN_PAGE_SIZE) {

                Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_ENTRY_LENGTH_EXCEEDS_PAGE_BOUNDARY,
                             "%I64x%x%x%I64x",
                             location.GetLargeInteger(),
                             num_bytes,
                             USN_PAGE_SIZE,
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("USN entry length of %d exceeds USN page boundary.\n", num_bytes));
                error = TRUE;
            } else if (num_bytes != QuadAlign(num_bytes)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_ENTRY_LENGTH_MISALIGNED,
                             "%I64x%x%I64x",
                             location.GetLargeInteger(),
                             num_bytes,
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("USN entry length of %d not quad aligned.\n", num_bytes));
                error = TRUE;
            } else if ((usn_entry->MajorVersion != 1 && usn_entry->MajorVersion != 2) ||
                       (usn_entry->MinorVersion != 0)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_UNKNOWN_USN_JRNL_ENTRY_VERSION,
                             "%I64x%x%x%I64x",
                             location.GetLargeInteger(),
                             usn_entry->MajorVersion,
                             usn_entry->MinorVersion,
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("USN entry version mark %d.%d not recognized.\n",
                                 usn_entry->MajorVersion,
                                 usn_entry->MinorVersion));
                error = TRUE;
            } else if (!(record_size = ((usn_entry->MajorVersion == 1) ?
                                        SIZE_OF_USN_REC_V1 : SIZE_OF_USN_REC_V2)) ||
                        (num_bytes < record_size)) {

                Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_ENTRY_LENGTH_TOO_SMALL,
                             "%I64x%x%x%I64x",
                             location.GetLargeInteger(),
                             num_bytes,
                             record_size,
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("USN entry length of %d less than the minimum record size of %d\n",
                                 num_bytes, record_size));
                error = TRUE;
            } else if (length < record_size) {

                Message->LogMsg(MSG_CHKLOG_NTFS_USN_JRNL_REMAINING_PAGE_LENGTH_TOO_SMALL,
                             "%I64x%x%x%I64x",
                             location.GetLargeInteger(),
                             length,
                             record_size,
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("USN remaining page length of %d less than the minimum record size of %d.\n",
                                 length, record_size));
                error = TRUE;
            } else if (usn_entry->MajorVersion == 1 &&
                       !(usn_entry->version.u1.Usn == location.GetQuadPart())) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_USN_JRNL_ENTRY_OFFSET,
                             "%I64x%I64x%I64x",
                             usn_entry->version.u1.Usn,
                             location.GetLargeInteger(),
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("USN entry offset 0x%I64x is invalid.\n",
                                 usn_entry->version.u1.Usn));
                error = TRUE;
            } else if (usn_entry->MajorVersion == 1 &&
                       ((ULONG)usn_entry->version.u1.FileNameLength +
                        (ULONG)FIELD_OFFSET(USN_REC, version.u1.FileName)) >
                       num_bytes) {

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_INCONSISTENCE_USN_JRNL_ENTRY);
                Message->Log("%I64x%x%x%I64x",
                             location.GetLargeInteger(),
                             usn_entry->version.u1.FileNameLength,
                             num_bytes,
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());
                Message->DumpDataToLog(usn_entry, min(num_bytes, 0x100));
                Message->Unlock();

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("Usn entry length being inconsistent.\n"));
                error = TRUE;
            } else if (usn_entry->MajorVersion == 2 &&
                       !(usn_entry->version.u2.Usn == location.GetQuadPart())) {

                Message->LogMsg(MSG_CHKLOG_NTFS_INCORRECT_USN_JRNL_ENTRY_OFFSET,
                             "%I64x%I64x%I64x",
                             usn_entry->version.u2.Usn,
                             location.GetLargeInteger(),
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("USN entry offset 0x%I64x is invalid.\n",
                                 usn_entry->version.u2.Usn));
                error = TRUE;
            } else if (usn_entry->MajorVersion == 2 &&
                       ((ULONG)usn_entry->version.u2.FileNameLength +
                        (ULONG)FIELD_OFFSET(USN_REC, version.u2.FileName)) >
                       num_bytes) {

                Message->Lock();
                Message->Set(MSG_CHKLOG_NTFS_INCONSISTENCE_USN_JRNL_ENTRY);
                Message->Log("%I64x%x%x%I64x",
                             location.GetLargeInteger(),
                             usn_entry->version.u2.FileNameLength,
                             num_bytes,
                             ChkdskInfo->UsnJournalFileNumber.GetLargeInteger());
                Message->DumpDataToLog(usn_entry, min(num_bytes, 0x100));
                Message->Unlock();

                DebugPrintTrace(("UNTFS: USN entry at offset 0x%I64x is bad.\n",
                                 location.GetLargeInteger()));
                DebugPrintTrace(("Usn entry length being inconsistent.\n"));
                error = TRUE;
            }

            if (error) {

                if (lastblock) {
                    DebugAssert(bytesToRead == remain_length);
                    bytesToRead = remain_length = USN_PAGE_SIZE;
                }

                if ((PCHAR)usn_entry - (PCHAR)initial_usn_entry +
                    sizeof(usn_entry->RecordLength) <= USN_PAGE_SIZE) {
                    // if enough space to fit a zero
                    // RecordLength in this block
                    MarkEndOfUsnBlock(usn_entry,
                                      (ULONG)((PCHAR)endOfBlock-(PCHAR)usn_entry));
                } else if (previous_usn_entry) {
                    // not enough space to fit a zero RecordLength in this
                    // block so eat into the previous record to make space
                    // for a zero RecordLength
                    MarkEndOfUsnBlock(previous_usn_entry,
                                      (ULONG)((PCHAR)endOfBlock-(PCHAR)previous_usn_entry));
                } else  {
                    DebugAssert(FALSE);

                    // It doesn't make much sense to get here.
                    // If we don't have a previous_usn_entry then
                    // usn_entry is at the beginning of the block
                    // and should have enough space to include the
                    // EOB mark.

                    return FALSE;
                }
                attribute_need_write = TRUE;
                break;
            } else {
                if (length == num_bytes) {
                    break;
                } else {
                    length -= num_bytes;
                    previous_usn_entry = usn_entry;
                    usn_entry = (PUSN_REC)(num_bytes + (PCHAR)usn_entry);
                }
            }
        } // while
        if (attribute_need_write) {
            errFixedStatus = CHKDSK_EXIT_ERRS_FIXED;
            if (FixLevel != CheckOnly &&
                (!attrib.Write(initial_usn_entry,
                               offset,
                               bytesToRead,
                               &bytesWritten,
                               Mft->GetVolumeBitmap()) ||
                 bytesWritten != bytesToRead)) {
                chkdskErrCouldNotFix = TRUE;
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USN_DATA_STREAM,
                                    "%W", &attributeName);
            } else
                frs_need_flush = TRUE;
        }
        offset += USN_PAGE_SIZE;
        remain_length -= bytesToRead;
    } // for
    if (frs_need_flush) {
        Message->DisplayMsg(MSG_CHK_NTFS_REPAIRING_USN_FRS);
        if (FixLevel != CheckOnly) {
            if (attrib.IsStorageModified() &&
                !attrib.InsertIntoFile(&frs, Mft->GetVolumeBitmap())) {
                chkdskErrCouldNotFix = TRUE;
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_USN_DATA_STREAM,
                                    "%W", &attributeName);
            }
            if (!frs.Flush(Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                    "%d", frs.QueryFileNumber());
                FREE(initial_usn_entry);
                return FALSE;
            }
        }
    }

    Message->DisplayMsg(MSG_CHK_NTFS_USNJRNL_VERIFICATION_COMPLETED, PROGRESS_MESSAGE);

    FREE(initial_usn_entry);

    if (chkdskErrCouldNotFix)
        ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;

    UPDATE_EXIT_STATUS_FIXED(errFixedStatus, ChkdskInfo);

    return TRUE;
}

VOID
MarkEndOfUsnBlock(
    IN OUT  PUSN_REC        UsnEntry,
    IN      ULONG           LengthOfBlock
    )
{
    // zero the length and
    // also the rest of the block

    memset(UsnEntry, 0, LengthOfBlock);
}


BOOLEAN
NTFS_SA::ResetUsns(
    IN OUT  PNTFS_CHKDSK_INFO       ChkdskInfo,
    IN      FIX_LEVEL               FixLevel,
    IN OUT  PMESSAGE                Message,
    IN OUT  PNTFS_MASTER_FILE_TABLE Mft
    )
/*++

Routine Description:

    This method sets all the USN's on the volume to zero.

Arguments:

    ChkdskInfo      --  Supplies the current chkdsk information.
    Message         --  Supplies an outlet for messages.
    Mft             --  Supplies the volume's Master File Table.
--*/
{
    NTFS_FILE_RECORD_SEGMENT    frs;
    ULONG                       i, n, frs_size, num_frs_per_prime;
    ULONG                       percent_done = 0;
    ULONG                       new_percent_done;
    BOOLEAN                     error;
    BOOLEAN                     chkdskErrCouldNotFix = FALSE;
    NTFS_ATTRIBUTE              attrib;
    PSTANDARD_INFORMATION2      standard_information2;
    ULONG                       bytesWritten;


    Message->DisplayMsg(MSG_CHK_NTFS_RESETTING_USNS);

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 0)) {
        return FALSE;
    }

    // Compute the number of file records.
    //
    frs_size = Mft->QueryFrsSize();

    n = (Mft->GetDataAttribute()->QueryValueLength()/frs_size).GetLowPart();
    num_frs_per_prime = MFT_PRIME_SIZE/frs_size;

    for (i = 0; i < n; i += 1) {

        new_percent_done = i*100/n;
        if (new_percent_done != percent_done) {
            percent_done = new_percent_done;
            if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", percent_done)) {
                return FALSE;
            }
        }

        if (i % num_frs_per_prime == 0) {
            Mft->GetDataAttribute()->PrimeCache(i*frs_size,
                                                num_frs_per_prime*frs_size);
        }

        if (!frs.Initialize(i, Mft)) {

            Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            return FALSE;
        }

        // If the FRS is unreadable or is not in use, skip it.
        //
        if (!frs.Read() || !frs.IsInUse() || !frs.IsBase()) {

            continue;
        }

        if (!frs.QueryAttribute(&attrib,
                                &error,
                                $STANDARD_INFORMATION)) {
            if (error) {
                Message->DisplayMsg(MSG_CHK_NO_MEMORY);
            } else {
                DebugPrint("Standard Information Missing\n");
            }
            return FALSE;
        }

        if (attrib.QueryValueLength() == sizeof(STANDARD_INFORMATION2)) {
            standard_information2 = (PSTANDARD_INFORMATION2)attrib.GetResidentValue();
            if (standard_information2->Usn == 0) {
                continue;
            }
            standard_information2->Usn.LowPart = 0;
            standard_information2->Usn.HighPart = 0;
            if (!attrib.Write((PVOID)standard_information2,
                              0,
                              sizeof(STANDARD_INFORMATION2),
                              &bytesWritten,
                              Mft->GetVolumeBitmap()) ||
                bytesWritten != sizeof(STANDARD_INFORMATION2)) {
                chkdskErrCouldNotFix = TRUE;
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                    "%d%d", attrib.QueryTypeCode(), i);
                continue;
            }
            if (attrib.IsStorageModified() &&
                !attrib.InsertIntoFile(&frs, Mft->GetVolumeBitmap())) {
                chkdskErrCouldNotFix = TRUE;
                Message->DisplayMsg(MSG_CHK_NTFS_CANT_FIX_ATTRIBUTE,
                                    "%d%d", attrib.QueryTypeCode(), i);
                continue;
            }
            if (FixLevel != CheckOnly &&
                !frs.Flush(Mft->GetVolumeBitmap())) {
                Message->DisplayMsg(MSG_CHK_READABLE_FRS_UNWRITEABLE,
                                    "%d", frs.QueryFileNumber());
                return FALSE;
            }
        }

    }

    if (!Message->DisplayMsg(MSG_PERCENT_COMPLETE, "%d", 100)) {
        return FALSE;
    }

    if (chkdskErrCouldNotFix)
        ChkdskInfo->ExitStatus = CHKDSK_EXIT_COULD_NOT_FIX;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ureg\src\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ureg\src\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

TARGETNAME=ureg
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib    \
           $(SDK_LIB_PATH)\advapi32.lib    \
           ..\..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib

DLLENTRY=InitializeUreg

USE_MSVCRT=1

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\regvalue.cxx \
        ..\regkey.cxx   \
        ..\registry.cxx \
        ..\ureg.cxx     \
        ..\ureg.rc


INCLUDES=..\..\inc;..\..\..\ulib\inc

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE  # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF # NTDEBUG

UMLIBS=$(O)\ureg.lib

UMTYPE=console

UMRES=$(O)\ureg.res
DLLDEF=$(O)\ureg.def
NTTARGETFILES=

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ureg\src\regkey.cxx ===
/*++

Copyright (c) 1992-2000  Microsoft Corporation

Module Name:

    regkey.cxx

Abstract:

    This module contains the member function definitions for REGISTRY_KEY_INFO
    class.
    REGISTRY_KEY_INFO is class that contains all the information of a
    registry key, such as:

        -Key Name
        -Title Index
        -Class
        -Security Attributes
        -Last Write Time
        -Number of Sub-keys
        -Number of Value Entries

    A REGISTRY_KEY_INFO object is reinitializable.

Author:

    Jaime Sasson (jaimes) 01-Mar-1992


Environment:

    Ulib, User Mode


--*/


#include "regkey.hxx"


DEFINE_CONSTRUCTOR( REGISTRY_KEY_INFO, OBJECT );



REGISTRY_KEY_INFO::~REGISTRY_KEY_INFO(

)
/*++

Routine Description:

    Destroy a REGISTRY_KEY_INFO object.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}



VOID
REGISTRY_KEY_INFO::Construct (
    )
/*++

Routine Description:

    Worker method for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _TitleIndex = 0;
    _NumberOfSubKeys = 0;
    _NumberOfValues = 0;

#if !defined( _AUTOCHECK_ )
    _SecurityAttributes.nLength = 0;
    _SecurityAttributes.lpSecurityDescriptor = NULL;
    _SecurityAttributes.bInheritHandle = FALSE;
#endif
}



VOID
REGISTRY_KEY_INFO::Destroy(
    )
/*++

Routine Description:

    Worker method for object destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _NumberOfSubKeys = 0;
    _NumberOfValues = 0;
    _TitleIndex = 0;
    _KeyIsCompletelyInitialized = FALSE;

#if !defined( _AUTOCHECK_ )
    FREE( _SecurityAttributes.lpSecurityDescriptor );
    _SecurityAttributes.nLength = 0;
    _SecurityAttributes.lpSecurityDescriptor = NULL;
    _SecurityAttributes.bInheritHandle = FALSE;
#endif
}



BOOLEAN
REGISTRY_KEY_INFO::Initialize(
    )
/*++

Routine Description:

    Initialize or re-initialize a REGISTRY_KEY_INFO object.

Arguments:

    None.

Return Value:

    BOOLEAN - Returns always TRUE.

--*/

{
    Destroy();
    if( !_ParentName.Initialize( "" ) ) {
        DebugPrint( "_ParentName.Initialize() failed" );
        return( FALSE );
    }
    if( !_Name.Initialize( "" ) ) {
        DebugPrint( "_Name.Initialize() failed" );
        return( FALSE );
    }
    return( TRUE );
}



BOOLEAN
REGISTRY_KEY_INFO::Initialize(
    IN PCWSTRING     KeyName,
    IN PCWSTRING     ParentName,
    IN ULONG                TitleIndex,
    IN PCWSTRING     Class,
    IN PSECURITY_ATTRIBUTES SecurityAttributes
    )

/*++

Routine Description:

    Initialize or re-initialize a REGISTRY_KEY_INFO object.

Arguments:

    KeyName - Pointer to a WSTRING object that contains the key name.

    ParentName - Pointer to a WSTRING object that contains the parent's
                 name.

    TitleIndex - The title index associated to the key.

    Class - Pointer to a WSTRING object that contains the key class.

    SecurityAttributes - Pointer to an initialized security attribute object.


Return Value:

    BOOLEAN - Returns TRUE if the operation succeeds.

--*/

{
    //
    //  Check for NULL pointers
    //
    DebugPtrAssert( Class );
//    DebugPtrAssert( SecurityAttributes );
    DebugAssert( !( ( ParentName != NULL ) && ( KeyName == NULL ) ) ||
               !( ( ParentName != NULL ) && ( ParentName->QueryChCount() != 0 ) &&
                  ( KeyName != NULL ) && ( KeyName->QueryChCount() == 0 ) ) );



    Destroy();


    if( ( ( KeyName == NULL ) && ( ParentName == NULL ) ) ||
        ( ( KeyName != NULL ) && ( KeyName->QueryChCount() == 0 ) &&
          ( ParentName != NULL ) && ( ParentName->QueryChCount() == 0 ) ) ) {
        //
        // This REGISTRY_KEY_INFO represents a predefined key.
        //
        if( !_ParentName.Initialize( "" ) ) {
            DebugPrint( "_ParentName.Initialize() failed" );
            return( FALSE );
        }
        if( !_Name.Initialize( "" ) ) {
            DebugPrint( "_Name.Initialize() failed" );
            return( FALSE );
        }

    } else {
        //
        //  This REGISTRY_KEY_INFO does not represent a predefined key,
        //  so it has a name.
        //  Make sure that the name is relative to its parent
        //
        if( KeyName && KeyName->Strrchr( ( WCHAR )'\\' ) != INVALID_CHNUM ) {
            DebugPrint( "KeyName is not a valid one" );
        }

        //
        // Initialize _ParentName
        //
        if( ( ParentName == NULL ) || ( ParentName->QueryChCount() == 0 ) ) {
            //
            //  This REGISTRY_KEY_INFO represents the subkey of a
            //  predefined key
            //
            if( !_ParentName.Initialize( "" ) ) {
                DebugPrint( "_ParentName.Initialize() failed" );
                return( FALSE );
            }
        } else {
            if( !_ParentName.Initialize( ParentName ) ) {
                DebugPrint( "_ParentName.Initialize( ParentName )" );
                return( FALSE );
            }
        }

        //
        // Initialize _Name
        //
        if( !_Name.Initialize( KeyName ) ) {
            DebugPrint( "_Name.Initialize( KeyName )" );
            return( FALSE );
        }
    }


    _TitleIndex = TitleIndex;

    if( !_Class.Initialize( Class ) ) {
        DebugPrint( "_Class.Initialize( Class )" );
        return( FALSE );
    }

#if !defined( _AUTOCHECK_ )
    if (!PutSecurityAttributes( SecurityAttributes )) {
        DebugPrint( "PutSecurityAttributes( SecurityAttributes )");
        return( FALSE );
    }
#endif
    _KeyIsCompletelyInitialized = FALSE;
    return( TRUE );
}

#if !defined( _AUTOCHECK_ )

BOOLEAN
REGISTRY_KEY_INFO::PutSecurityAttributes(
    IN PSECURITY_ATTRIBUTES    SecurityAttributes
    )

/*++

Routine Description:

    Initialize the variable _SecurityAttributes.


Arguments:

    SecurityAttributes - Pointer to the security attribute


Return Value:

    None.


--*/

{
    ULONG   Length;
    PBYTE   Pointer;


    if( SecurityAttributes != NULL ) {

        Length = GetSecurityDescriptorLength( SecurityAttributes->lpSecurityDescriptor );

        FREE( _SecurityAttributes.lpSecurityDescriptor );

        Pointer = ( PBYTE )MALLOC( ( size_t )Length );
        if (Pointer == NULL) {
            DebugPtrAssert( Pointer );
            return FALSE;
        }
        memcpy( Pointer, SecurityAttributes->lpSecurityDescriptor, ( size_t )Length );

       _SecurityAttributes.nLength = SecurityAttributes->nLength;
       _SecurityAttributes.lpSecurityDescriptor = Pointer;
       _SecurityAttributes.bInheritHandle = SecurityAttributes->bInheritHandle;
    } else {
        Pointer = ( PBYTE )MALLOC( ( size_t )SECURITY_DESCRIPTOR_MIN_LENGTH );
        if (Pointer == NULL) {
            DebugPtrAssert( Pointer );
            return FALSE;
        }
        InitializeSecurityDescriptor( Pointer, 1 );
        _SecurityAttributes.nLength = sizeof( SECURITY_ATTRIBUTES );
        _SecurityAttributes.lpSecurityDescriptor = Pointer;
        _SecurityAttributes.bInheritHandle = FALSE;
    }
    return TRUE;
}
#endif


#if DBG

VOID
REGISTRY_KEY_INFO::DbgPrintKeyInfo(
    )

/*++

Routine Description:

    Print the contents of a REGISTRY_INFO_KEY.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PSTR    Pointer;
    PSTR    StrDate;
    PSTR    StrTime;

    DSTRING Date;
    DSTRING Time;

    DebugPrintTrace(( "====Dumping a REGISTRY_KEY_INFO object ====\n \n" ));
    Pointer = _ParentName.QuerySTR();
    DebugPtrAssert( Pointer );
    DebugPrintTrace(( "    ParentName = %s \n", Pointer ));
    FREE( Pointer );

    Pointer = _Name.QuerySTR();
    DebugPtrAssert( Pointer );
    DebugPrintTrace(( "    Name = %s \n", Pointer ));
    FREE( Pointer );

    Pointer = _Class.QuerySTR();
    DebugPtrAssert( Pointer );
    DebugPrintTrace(( "    Class = %s \n", Pointer ));
    FREE( Pointer );

    DebugPrintTrace(( "    Title Index = %d \n", _TitleIndex ));

    if( !_LastWriteTime.QueryDate( &Date ) ||
        !_LastWriteTime.QueryTime( &Time ) ) {
        DebugPrint( "Can't get date or time" );
    } else {
        StrDate = Date.QuerySTR();
        DebugPtrAssert( StrDate );
        StrTime = Time.QuerySTR();
        DebugPtrAssert( StrTime );
        DebugPrintTrace(( "    LastWriteTime = %s  %s \n", StrDate, StrTime ));
        FREE( StrDate );
        FREE( StrTime );
    }

    DebugPrintTrace(( "    SecurityAttributes.nLength = %d \n", _SecurityAttributes.nLength ));
    DebugPrintTrace(( "    SecurityAttributes.lpSecurityDescriptor = %08x \n",
               _SecurityAttributes.lpSecurityDescriptor ));

    if( _SecurityAttributes.bInheritHandle ) {
        DebugPrintTrace(( "    SecurityAttributes.bInheritHandle = TRUE \n" ));
    } else {
        DebugPrintTrace(( "    SecurityAttributes.bInheritHandle = FALSE \n" ));
    }

    DebugPrintTrace(( "    NumberOfSubKeys = %d \n", _NumberOfSubKeys ));
    DebugPrintTrace(( "    NumberOfValues = %d \n", _NumberOfValues ));
    DebugPrintTrace(( "\n\n" ));
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ureg\src\ureg.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

        ureg.cxx

Abstract:

        This module contains run-time, global support for the
        Registry Utilities library (UREG).       This support includes:

                - creation of CLASS_DESCRIPTORs
                - Global objects

Author:

        JAIME SASSON (JAIMES) 02-Dez-1992

Environment:

        User Mode

Notes:

--*/

#include "ulib.hxx"

//      Local prototypes

STATIC
BOOLEAN
DefineClassDescriptors (
        );

STATIC
BOOLEAN
UndefineClassDescriptors (
        );

extern "C" BOOLEAN
InitializeUreg (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        );

BOOLEAN
InitializeUreg (
    PVOID DllHandle,
    ULONG Reason,
    PCONTEXT Context
        )
/*++

Routine Description:

        Initialize Ureg by constructing and initializing all
        global objects. These include:

                - all CLASS_DESCRIPTORs (class_cd)

Arguments:

        None.

Return Value:

        BOOLEAN - Returns TRUE if all global objects were succesfully constructed
                and initialized.

--*/

{

    STATIC ULONG    count = 0;

    switch (Reason) {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:

            if (count > 0) {
                ++count;
                return TRUE;
            }

            if (!DefineClassDescriptors()) {
                UndefineClassDescriptors();
                DebugAbort( "UREG initialization failed!!!\n" );
                return FALSE;
            }

            count++;
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:

            if (count > 1) {
                --count;
                return TRUE;
            }

            if (count == 1) {
                UndefineClassDescriptors();

                count--;
            } else {
                DebugPrint("UREG detached more than attached\n");
            }
            break;
    }

    return TRUE;
}



DECLARE_CLASS(  REGISTRY_VALUE_ENTRY  );
DECLARE_CLASS(  REGISTRY_KEY_INFO     );
DECLARE_CLASS(  REGISTRY              );


STATIC
BOOLEAN
DefineClassDescriptors(
        )
/*++

Routine Description:

    Defines all the class descriptors used by UREG

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if all class descriptors were succesfully
              constructed and initialized.

--*/
{
    if( DEFINE_CLASS_DESCRIPTOR( REGISTRY_VALUE_ENTRY ) &&
        DEFINE_CLASS_DESCRIPTOR( REGISTRY_KEY_INFO    ) &&
        DEFINE_CLASS_DESCRIPTOR( REGISTRY             )
    ) {

            return TRUE;

    } else {

            DebugPrint( "UREG: Could not initialize class descriptors!");
            return FALSE;
    }
}


STATIC
BOOLEAN
UndefineClassDescriptors (
    )

/*++

Routine Description:

    Undefines all the class descriptors used by UREG.

Arguments:

    None.

Return Value:

    BOOLEAN - Returns TRUE if all class descriptors were succesfully
              undefined.

--*/

{
    UNDEFINE_CLASS_DESCRIPTOR( REGISTRY_VALUE_ENTRY );
    UNDEFINE_CLASS_DESCRIPTOR( REGISTRY_KEY_INFO    );
    UNDEFINE_CLASS_DESCRIPTOR( REGISTRY             );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\ureg\src\regvalue.cxx ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    value.cxx

Abstract:

    This module contains the methods for the REGISTRY_VALUE_ENTRY class.

Author:

    Jaime Sasson (jaimes) 26-Aug-1991

Environment:

    Ulib, Regedit, Windows, User Mode

--*/

#include "regvalue.hxx"


DEFINE_CONSTRUCTOR( REGISTRY_VALUE_ENTRY, OBJECT );

DEFINE_CAST_MEMBER_FUNCTION( REGISTRY_VALUE_ENTRY );



REGISTRY_VALUE_ENTRY::~REGISTRY_VALUE_ENTRY(

)
/*++

Routine Description:

    Destroy a REGISTRY_VALUE_ENTRY object.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


VOID
REGISTRY_VALUE_ENTRY::Construct (
    )
/*++

Routine Description:

    Worker method for object construction.

Arguments:

    None.

Return Value:

    None.

--*/
{
    _TitleIndex = 0;
    _Type = TYPE_UNKNOWN;
    _Size = 0;
    _Data = NULL;
}


VOID
REGISTRY_VALUE_ENTRY::Destroy(
    )
/*++

Routine Description:

    Worker method for object destruction or reinitialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DELETE( _Data );
    _Data = NULL;
    _TitleIndex = 0;
    _Type = TYPE_UNKNOWN;
    _Size = 0;
}


BOOLEAN
REGISTRY_VALUE_ENTRY::Initialize(
    )

/*++

Routine Description:

    Initialize or re-initialize a REGISTRY_VALUE_ENTRY object.

Arguments:

    None.

Return Value:

    BOOLEAN - Returns always TRUE


--*/


{
    Destroy();
    return( TRUE );
}


BOOLEAN
REGISTRY_VALUE_ENTRY::Initialize(
    IN PCWSTRING ValueName,
    IN ULONG            TitleIndex,
    IN REG_TYPE         Type,
    IN PCBYTE           Data,
    IN ULONG            Size
    )

/*++

Routine Description:

    Initialize or re-initialize a REGISTRY_VALUE_ENTRY object.

Arguments:


    ValueName - Pointer to a WSTRING that contains the value name.

    TitleIndex - The title index associated with the value name.

    Type - The type of value stored in this object.

    Data - Buffer that contains the value to be stored.

    Size - Number of bytes in the buffer.



Return Value:

    BOOLEAN - Returns always TRUE


--*/


{
    DebugPtrAssert( ValueName );
    DebugAssert( ( Size == 0 ) || ( Data != NULL ) );

    Destroy();
    if( !_Name.Initialize( ValueName ) ) {
        return( FALSE );
    }
    _TitleIndex = TitleIndex;
    _Type = Type;
    if( Size == 0 ) {
        _Data = NULL;
        _Size = 0;
    } else {
        return PutData( Data, Size );
    }
    return( TRUE );
}



BOOLEAN
REGISTRY_VALUE_ENTRY::PutData(
    IN PCBYTE   Data,
    IN ULONG    Size
    )

/*++

Routine Description:

    Set the data stored in this object.


Arguments:

    Data - Pointer to the buffer that contains the data.

    Size - Number of valid bytes in the buffer (data size).


Return Value:

    None.


--*/


{
    DebugAssert( ( Size == 0 ) || ( Data != NULL ) );

    if( _Data != NULL ) {
        FREE( _Data );
    }
    if( Size == 0 ) {
        _Data = NULL;
        _Size = 0;
    } else {
        _Data = ( PBYTE )MALLOC( ( size_t )( Size + 2 ) );
        if (_Data == NULL) {
            DebugPtrAssert( _Data );
            DebugPrint("UREG: Out of memory\n");
            return FALSE;
        }
        _Size = Size;
        memcpy( _Data, Data, ( size_t )Size );
        *( _Data + Size ) = '\0';
        *( _Data + Size + 1 ) = '\0';
    }

    return TRUE;
}




#if DBG

VOID
REGISTRY_VALUE_ENTRY::DbgPrintValueEntry(
    )

/*++

Routine Description:

    Display the contents of a value entry object

Arguments:

    None.

Return Value:

    None.


--*/


{
    PSTR    Pointer;

    DebugPrintTrace(( "======== Dumping a REGISTRY_VALUE_ENTRY object ==== \n\n" ));
    Pointer = _Name.QuerySTR();
    DebugPrintTrace(( "    _Name = %s \n", Pointer ));
    FREE( Pointer );

    DebugPrintTrace(( "    _TitleIndex = %d \n", _TitleIndex ));

    switch( _Type ) {

        case TYPE_REG_NONE:
            DebugPrintTrace(( "    _Type = TYPE_REG_NONE \n" ));
            DebugPrintTrace(( "    _Size = %d \n", _Size ));
            break;

        case TYPE_REG_SZ:
            DebugPrintTrace(( "    _Type = TYPE_REG_SZ \n" ));
            DebugPrintTrace(( "    _Size = %d \n", _Size ));
            if( _Size == 0 ) {
                DebugPrintTrace(( "    There is no data to display in this value entry \n" ));
            } else {
                DebugPrintTrace(( "    _Data = %s \n", _Data ));
            }
            break;

        case TYPE_REG_BINARY:
            DebugPrintTrace(( "    _Type = TYPE_REG_BINARY \n" ));
            DebugPrintTrace(( "    _Size = %d \n", _Size ));

            if( _Size == 0 ) {
                DebugPrintTrace(( "    There is no data to display in this value entry \n" ));
            } else {
                DebugPrintTrace(( "    Don't know how to print binary data \n" ));
            }
            break;

        case TYPE_REG_DWORD:
            DebugPrintTrace(( "    _Type = TYPE_REG_DWORD \n" ));
            if( _Size == sizeof( DWORD ) ) {
                DebugPrintTrace(( "    _Data = %08x \n", *( ( LPDWORD ) _Data ) ));
            } else {
                DebugPrintTrace(( "    ERROR: Data has incorrect size, Size = %d \n", _Size ));
            }
            break;

        case TYPE_REG_RESOURCE_LIST:
            DebugPrintTrace(( "    _Type = TYPE_REG_RESOURCE_LIST \n" ));
            DebugPrintTrace(( "    _Size = %d \n", _Size ));

            if( _Size == 0 ) {
                DebugPrintTrace(( "    There is no data to display in this value entry \n" ));
            } else {
                DebugPrintTrace(( "    Don't know how to print resource list \n" ));
            }
            break;

        case TYPE_REG_FULL_RESOURCE_DESCRIPTOR:
            DebugPrintTrace(( "    _Type = TYPE_REG_FULL_RESOURCE_DESCRIPTOR \n" ));
            DebugPrintTrace(( "    _Size = %d \n", _Size ));

            if( _Size == 0 ) {
                DebugPrintTrace(( "    There is no data to display in this value entry \n" ));
            } else {
                DebugPrintTrace(( "    Don't know how to print a full resource descriptor \n" ));
            }
            break;

        case TYPE_REG_RESOURCE_REQUIREMENTS_LIST:
            DebugPrintTrace(( "    _Type = TYPE_REG_RESOURCE_REQUIREMENTS_LIST \n" ));
            DebugPrintTrace(( "    _Size = %d \n", _Size ));

            if( _Size == 0 ) {
                DebugPrintTrace(( "    There is no data to display in this value entry \n" ));
            } else {
                DebugPrintTrace(( "    Don't know how to print a requirements list \n" ));
            }
            break;

        case TYPE_UNKNOWN:
        default:
            DebugPrintTrace(( "    _Type = UNKNOWN \n" ));
            DebugPrintTrace(( "    _Size = %d \n", _Size ));
            break;
    }

}

#endif   // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\uudf\src\checkfilestruct.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    CheckFileStruct.cxx

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"

#include "UdfLVol.hxx"
#include "ScanFIDs.hxx"

#include "crc.hxx"
#include "unicode.hxx"

BOOL
UDF_LVOL::CheckFileStructure()
{
    BOOL Result = FALSE;

    USHORT      TagIdentifier = DESTAG_ID_NOTSPEC;

    UINT        TotalFiles = 0;
    UINT        TotalDirs = 0;
    ULONGLONG   RootICBBlockOffset = 0;
    UINT        RootICBBlockSize =  0;

    DSTRING FileSetID;
    UncompressDString( (LPBYTE) _FileSetDescriptor->FileSetID, sizeof( _FileSetDescriptor->FileSetID ), &FileSetID );

    _Message->Set( MSG_UDF_FILE_SYSTEM_INFO );
    _Message->Display( "%W", &FileSetID );

    if (ReadIcbDirectEntry( &_FileSetDescriptor->IcbRoot, &TagIdentifier, &_RootIcbFileEntry, &RootICBBlockOffset, &RootICBBlockSize, 0 )) {

        //  Mark the ICB of the Root directory as used.
        //

        Result = MarkBlocksUsed( RootICBBlockOffset, RootICBBlockSize );

        if (ExpandDirectoryHierarchy( _RootIcbFileEntry, FALSE, &TotalFiles, &TotalDirs, 0 )) {

            DebugPrintTrace(( "ExpandDirectoryHierarchy() results:\n" ));
            DebugPrintTrace(( "\tTotalFiles: %d\n", TotalFiles ));
            DebugPrintTrace(( "\tTotalDirs:  %d\n", TotalDirs ));

        }

    }

    USHORT UdfVersion = ((PUDF_SUFFIX_UDF) &_LogicalVolumeDescriptor->DomainID.Suffix)->UdfRevision;
    if (UdfVersion >= UDF_VERSION_200) {

        UINT        TotalStreamFiles = 0;
        UINT        TotalStreamDirs = 0;
        PICBFILE    RootStreamIcbFileEntry = NULL;
        ULONGLONG   RootStreamICBBlockOffset = 0;
        UINT        RootStreamICBBlockSize =  0;

        if (ReadIcbDirectEntry( &_FileSetDescriptor->StreamDirectoryIcb, &TagIdentifier,
            &RootStreamIcbFileEntry, &RootStreamICBBlockOffset, &RootStreamICBBlockSize, 0 )) {

            //  Mark the ICB of the Root directory as used.
            //

            Result = MarkBlocksUsed( RootStreamICBBlockOffset, RootStreamICBBlockSize );

            if (ExpandDirectoryHierarchy( RootStreamIcbFileEntry, FALSE, &TotalStreamFiles, &TotalStreamDirs, 0 )) {

                DebugPrintTrace(( "ExpandDirectoryHierarchy() results:\n" ));
                DebugPrintTrace(( "Total Stream Files: %d\n", TotalStreamFiles ));
                DebugPrintTrace(( "Total Stream Dirs:  %d\n", TotalStreamDirs ));

            }

        } else {

            _Message->DisplayMsg( MSG_UDF_INVALID_SYSTEM_STREAM );

        }

    }

    if (!VerifySBDAllocation( _SpaceBitmapDescriptor, _NewSpaceBitmapDescriptor )) {

        return FALSE;

    }

    return TRUE;
}

BOOL
UDF_LVOL::ReadIcbDirectEntry
(
    LONGAD*         pIcb,
    USHORT*         pTagIdentifier,
    PICBFILE*       NewIcbFile,
    OUT PULONGLONG  BlockNum,
    OUT PUINT       BlockSize,
    UINT            readIcbDirectRecursionCount
)
{
    BOOL Result = FALSE;

    *pTagIdentifier = DESTAG_ID_NOTSPEC;

    LPBYTE IcbFileBuffer = (LPBYTE) malloc( pIcb->Length.Length );
    if (IcbFileBuffer != NULL) {

        Result = Read( pIcb->Start.Lbn, 1, IcbFileBuffer );
        if (!Result) {

            DebugPrintTrace(( "ReadIcbDirectEntry error: Error reading physical block %u\n",
                pIcb->Start.Lbn ));

        } else {

            /* Node context in node and mc must be set for context verification.
             * In case of an error, at least the descriptor tag will be swapped !!
             */
            Result = VerifyDescriptor( IcbFileBuffer, QuerySectorSize(), DESTAG_ID_NOTSPEC, pTagIdentifier );
            if (!Result) {

                DebugPrintTrace(( "ICB Direct Entry error\n" ));

            } else {
            
                if ((*pTagIdentifier) != DESTAG_ID_NSR_FILE && (*pTagIdentifier) != DESTAG_ID_NSR_EXT_FILE) {

                    DebugPrintTrace(( "Unexpected descriptor: %x\n", *pTagIdentifier ));

                } else {

                    if (((PICBFILE) IcbFileBuffer)->Icbtag.StratType != 4) {
        
                        DebugPrintTrace((  "Error: Illegal ICB Strategy Type: %u\n",
                            ((PICBFILE) IcbFileBuffer)->Icbtag.StratType ));


                    } else {

                        Result = TRUE;

                    }

                }

            }

        }
    }

    if (!Result) {

        free( IcbFileBuffer );

    } else {

        *NewIcbFile = (PICBFILE) IcbFileBuffer;
        *BlockNum = pIcb->Start.Lbn;
        *BlockSize = 1;

    }

    return Result;
}

BOOL
UDF_LVOL::ExpandFID
(
    PNSR_FID    NsrFid,
    BOOL        isStreamDir,
    PUINT       TotalFiles,
    PUINT       TotalDirs,
    UINT        ExpandDirRecursionCount
)
{
    BOOL Result = TRUE;

    ULONG FidSize = ISONsrFidSize( NsrFid );

#if DEBUG_DUMP_FIDS
    WCHAR FileAttributes[ 6 ];
    FileAttributes[ 0 ] = (NsrFid->Flags & NSR_FID_F_HIDDEN)    ? L'h' : L'.';
    FileAttributes[ 1 ] = (NsrFid->Flags & NSR_FID_F_DIRECTORY) ? L'd' : L'.';
    FileAttributes[ 2 ] = (NsrFid->Flags & NSR_FID_F_DELETED)   ? L'x' : L'.';
    FileAttributes[ 3 ] = (NsrFid->Flags & NSR_FID_F_PARENT)    ? L'p' : L'.';
    FileAttributes[ 4 ] = (NsrFid->Flags & NSR_FID_F_META)      ? L'm' : L'.';
    FileAttributes[ 5 ] = L'\0';

    DSTRING FileID;
    Result = UncompressUnicode( NsrFid->FileIDLen, LPBYTE( NsrFid ) + ISONsrFidConstantSize + NsrFid->ImpUseLen, &FileID );
    if (Result) {
        DebugPrintTrace(( "%S %S\n", FileAttributes, FileID.GetWSTR() ));
    }
#endif DEBUG_DUMP_FIDS

    if (NsrFid->Flags & NSR_FID_F_DIRECTORY) {

        if ((NsrFid->Flags & NSR_FID_F_PARENT) == 0) {

            PICBFILE    SubDirectoryICBEntry = NULL;
            ULONGLONG   ICBBlockOffset = 0;
            UINT        ICBBlockSize =  0;
            USHORT      TagIdentifier;

            Result = ReadIcbDirectEntry( &NsrFid->Icb, &TagIdentifier, &SubDirectoryICBEntry, &ICBBlockOffset, &ICBBlockSize, 0 );
            if (Result) {

                Result = MarkBlocksUsed( ICBBlockOffset, ICBBlockSize );

                *TotalDirs += 1;

                Result = ExpandDirectoryHierarchy( SubDirectoryICBEntry, FALSE, TotalFiles, TotalDirs, ExpandDirRecursionCount );

                free( SubDirectoryICBEntry );

            }

        }

    } else {

        PICBFILE    SubDirectoryICBEntry = NULL;
        ULONGLONG   ICBBlockOffset = 0;
        UINT        ICBBlockSize =  0;
        USHORT      TagIdentifier;

        Result = ReadIcbDirectEntry( &NsrFid->Icb, &TagIdentifier, &SubDirectoryICBEntry, &ICBBlockOffset, &ICBBlockSize, 0 );
        if (Result) {

            ULONGLONG                   ComputedFileSize = 0;
            SCAN_ALLOCTION_DESCRIPTORS  ReadInfo;

            Result = MarkBlocksUsed( ICBBlockOffset, ICBBlockSize );

            if ((SubDirectoryICBEntry->Icbtag.Flags & ICBTAG_F_ALLOC_MASK) == ICBTAG_F_ALLOC_IMMEDIATE) {

                ComputedFileSize = SubDirectoryICBEntry->InfoLength;

            } else {

                Result = ReadInfo.Initialize( this, SubDirectoryICBEntry );
                if (Result) {

                    ULONG   StartBlockNum;
                    ULONG   Length;
                    SHORT   Type;

                    while (ReadInfo.Next(&StartBlockNum, &Length, &Type)) {

                        if (Length == 0) {

                            //  UNDONE, CBiks, 8/3/2000
                            //      UDF 2.01/2.3.11 says that the unused bytes after the last AD should be zero.  Maybe
                            //      we should verify this.

                            break;

                        } else {

                            //  UNDONE, CBiks, 8/3/2000
                            //      What do we do when the AD contains a bad start or length?

                            if (Type == NSRLENGTH_TYPE_RECORDED) {

                                //  Mark the sectors as used and add the size to the computed file size.
                                //

                                ComputedFileSize += Length;

                                Result = MarkBlocksUsed( StartBlockNum, RoundUp( Length, QuerySectorSize() ) );

                            } else if (Type == NSRLENGTH_TYPE_UNRECORDED) {

                                //  Mark the sectors as used, but don't add the unrecorded size to the file size.
                                //

                                Result = MarkBlocksUsed( StartBlockNum, RoundUp( Length, QuerySectorSize() ) );

                            } else {

                                DebugPrintTrace(( "Unsupported NSRLENGTH.Type: %x\n",
                                    Type ));
                                ASSERT( 0 );

                            }

                        }

                    }

                }

            }

            //  UNDONE, CBiks, 8/3/2000
            //      What do we do when the computed size does not match the size in the ICB?
            //

            ASSERT( ComputedFileSize == SubDirectoryICBEntry->InfoLength );

        }

        *TotalFiles += 1;

    }

    return Result;
}

BOOL
UDF_LVOL::ExpandDirectoryHierarchy
(
    PICBFILE    FileIcbEntry,
    BOOL        isStreamDir,
    PUINT       TotalFiles,
    PUINT       TotalDirs,
    UINT        ExpandDirRecursionCount
)
{
    BOOL    result = TRUE;

    ULONG   CalculatedInfoLength = 0;

    UCHAR   feAdType = FileIcbEntry->Icbtag.Flags & ICBTAG_F_ALLOC_MASK;

    if (feAdType == ICBTAG_F_ALLOC_IMMEDIATE) {

        LPBYTE  AllocationDescriptors = (LPBYTE)( FileIcbEntry ) + FeEasFieldOffset( FileIcbEntry ) + FeEaLength( FileIcbEntry );
        ULONG   AllocationDescriptorLength = FeAllocLength( FileIcbEntry );
        ULONG   AllocDescOffset = 0;

        while (result && (AllocDescOffset < AllocationDescriptorLength)) {

            PNSR_FID NsrFid = (PNSR_FID)( FeEas( FileIcbEntry ) + FeEaLength( FileIcbEntry ) + AllocDescOffset );

            result = VerifyDescriptor( (LPBYTE) NsrFid, FeAllocLength( FileIcbEntry ) - AllocDescOffset, DESTAG_ID_NSR_FID, NULL );
            if (result) {

                result = ExpandFID( NsrFid, isStreamDir, TotalFiles, TotalDirs, ExpandDirRecursionCount );

                AllocDescOffset += ISONsrFidSize( NsrFid );

            }

        }

    } else if (feAdType == ICBTAG_F_ALLOC_SHORT) {

        SCAN_FIDS ReadInfo;

        result = ReadInfo.Initialize( this, FileIcbEntry );
        if (result) {

            PNSR_FID NsrFid = NULL;
            while (ReadInfo.Next( &NsrFid )) {

                result = ExpandFID( NsrFid, isStreamDir, TotalFiles, TotalDirs, ExpandDirRecursionCount );

            }

        }

    } else {

        DebugPrintTrace(( "Unsupported ICB Allocation Type: %x\n",
            feAdType ));
        ASSERT( 0 );
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\uudf\src\crc.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    crc.cxx

Author:

    Centis Biks (cbiks) 12-Jun-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"

static USHORT crc_table[256] = {
    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
    0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
    0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
    0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
    0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
    0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
    0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
    0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
    0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
    0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
    0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
    0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
    0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
    0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
    0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
    0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
    0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
    0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
    0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
    0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
    0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
    0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
    0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
    0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
    0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
    0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
    0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
    0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
    0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
    0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
    0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
    0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
};

USHORT
CalculateCrc
(
    LPBYTE      p,
    ULONGLONG   size
)
{
    USHORT CRC = 0;

    while ( size-- > 0 ) {

        CRC = (USHORT)( crc_table[(CRC >> 8 ^ *p++) & 0xff] ^ (CRC << 8) );

    }

    return CRC;
}

UCHAR
CalculateTagChecksum
(
    DESTAG* gt
)
{
    LPBYTE  b;
    UCHAR   sum = 0;
    UCHAR   counter;

    b = (LPBYTE) gt;
    for(counter = 0; counter <= 3; counter++)
        sum = (UCHAR) ((sum + b[counter]) % 256);
    for(counter = 5; counter <= 15; counter++)
        sum = (UCHAR) ((sum + b[counter]) % 256);
    return sum;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\uudf\src\entry.cxx ===
/*++

Copyright (c) 1990-2000 Microsoft Corporation

Module Name:

    entry.cxx

Abstract:

    This module contains the entry points for UUDF.DLL.  These
    include:

        Chkdsk
        ChkdskEx
        Format
        FormatEx
        Recover

Author:

    Centis Biks (cbiks) 05-05-2000

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#include "ulib.hxx"
#include "error.hxx"
#include "path.hxx"
#include "ifssys.hxx"
#include "rcache.hxx"
#include "ifsserv.hxx"

extern "C" {
    #include "nturtl.h"
    #include "udf.h"
}

#include "message.hxx"
#include "rtmsg.h"


BOOLEAN
FAR APIENTRY
Chkdsk(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     Fix,
    IN      BOOLEAN     Verbose,
    IN      BOOLEAN     OnlyIfDirty,
    IN      BOOLEAN     Recover,
    IN      PPATH       PathToCheck,
    IN      BOOLEAN     Extend,
    IN      BOOLEAN     ResizeLogFile,
    IN      ULONG       DesiredLogFileSize,
    OUT     PULONG      ExitStatus
    )
/*++

Routine Description:

    Check an Universal Data Format (UDF) volume.

Arguments:

    NtDrivName          supplies the name of the drive to check
    Message             supplies an outlet for messages
    Fix                 TRUE if Chkdsk should fix errors
    Verbose             TRUE if Chkdsk should list every file it finds
    OnlyIfDirty         TRUE if the drive should be checked only if
                            it is dirty
    Recover             TRUE if the drive is to be completely checked
                            for bad sectors.
    PathToCheck         supplies a path to files Chkdsk should check
                            for contiguity
    Extend              Unused (should always be FALSE)
    ResizeLogfile       Unused (should always be FALSE)
    DesiredLogfileSize  Unused (should always be 0)
    ExitStatus          Returns information about whether the chkdsk failed


Return Value:

    TRUE if successful.

--*/
{
    UDF_VOL         UDFVol;
    BOOLEAN         RecoverFree, RecoverAlloc;
    DWORD           oldErrorMode;
    ULONG           flags;

    //  Only NTFS implements extend, so we can just error out if we see it.
    //
    if (Extend || ResizeLogFile || (DesiredLogFileSize != 0)) {

        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;

    }

    RecoverFree = RecoverAlloc = Recover;

   
    // disable popups while we initialize the volume
    oldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    if (!UDFVol.Initialize(NtDriveName, Message)) {
        SetErrorMode ( oldErrorMode );
        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;
    }

    // Re-enable hardware popups
    SetErrorMode ( oldErrorMode );

    flags = (Verbose ? CHKDSK_VERBOSE : 0);
    flags |= (OnlyIfDirty ? CHKDSK_CHECK_IF_DIRTY : 0);
    flags |= (RecoverFree ? CHKDSK_RECOVER_FREE_SPACE : 0);
    flags |= (RecoverAlloc ? CHKDSK_RECOVER_ALLOC_SPACE : 0);

    if (Fix) {
        
        if (!UDFVol.Lock()) {

            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;

        }

    }

    return UDFVol.ChkDsk( Fix ? TotalFix : CheckOnly,
                           Message,
                           flags,
                           0,
                           0,
                           ExitStatus );
}


BOOLEAN
FAR APIENTRY
ChkdskEx(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      BOOLEAN             Fix,
    IN      PCHKDSKEX_FN_PARAM  Param,
    OUT     PULONG              ExitStatus
    )
/*++

Routine Description:

    Check an NTFS volume.

Arguments:

    NtDrivName          supplies the name of the drive to check
    Message             supplies an outlet for messages
    Fix                 TRUE if Chkdsk should fix errors
    Param               supplies the chkdsk parameter block
    ExitStatus          Returns information about whether the chkdsk failed


Return Value:

    TRUE if successful.

--*/
{
    UDF_VOL         UDFVol;
    BOOLEAN         RecoverFree, RecoverAlloc;
    DWORD           oldErrorMode;

    //  Make sure the data sturcture is a version we recognize.
    //
    if (Param->Major != 1 || (Param->Minor != 0 && Param->Minor != 1)) {

        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;

    }

    //  Only NTFS implements extend and resize, so we can just error out if we see either of these.
    //
    if ((Param->Flags & CHKDSK_EXTEND) || (Param->Flags & CHKDSK_RESIZE_LOGFILE)) {

        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;

    }

    RecoverFree = RecoverAlloc = (BOOLEAN)(Param->Flags & CHKDSK_RECOVER);

    // disable popups while we initialize the volume
    oldErrorMode = SetErrorMode( SEM_FAILCRITICALERRORS );

    if (!UDFVol.Initialize(NtDriveName, Message)) {
        SetErrorMode ( oldErrorMode );
        *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
        return FALSE;
    }

    // Re-enable hardware popups
    SetErrorMode ( oldErrorMode );

    if (Fix) {
        
        if (!UDFVol.Lock()) {

            *ExitStatus = CHKDSK_EXIT_COULD_NOT_CHK;
            return FALSE;

        }

    }

    return UDFVol.ChkDsk( Fix ? TotalFix : CheckOnly,
                           Message,
                           Param->Flags,
                           0,
                           0,
                           ExitStatus,
                           NtDriveName );
}


BOOLEAN
FAR APIENTRY
Format(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     Quick,
    IN      BOOLEAN     BackwardCompatible,
    IN      MEDIA_TYPE  MediaType,
    IN      PCWSTRING   LabelString,
    IN      ULONG       ClusterSize
    )
/*++

Routine Description:

    Format an NTFS volume.

Arguments:

    NtDriveName     -- supplies the name (in NT API form) of the volume
    Message         -- supplies an outlet for messages
    Quick           -- supplies a flag to indicate whether to do Quick Format
    BackwardCompatible
                    -- supplies a flag to indicate if formatting to previous
                       version of file system (e.g. FAT32->FAT16, NTFS 5.0->NTFS 4.0)
    MediaType       -- supplies the volume's Media Type
    LabelString     -- supplies the volume's label
    ClusterSize     -- supplies the cluster size for the volume.

--*/
{
    DP_DRIVE            DpDrive;
    UDF_VOL             UDFVol;
    FORMAT_ERROR_CODE   errcode;
    ULONG               flags;

    if (ClusterSize && ClusterSize > 64*1024) {
        Message->DisplayMsg(MSG_FMT_ALLOCATION_SIZE_EXCEEDED);
        return FALSE;
    }

    if (!DpDrive.Initialize( NtDriveName, Message )) {

        return FALSE;
    }

    if (DpDrive.IsFloppy()) {

        Message->DisplayMsg(MSG_NTFS_FORMAT_NO_FLOPPIES);
        return FALSE;
    }

    errcode = UDFVol.Initialize( NtDriveName,
                                  Message,
                                  FALSE,
                                  MediaType );

    if (errcode == NoError) {
        flags = (BackwardCompatible ? FORMAT_BACKWARD_COMPATIBLE : 0);
        errcode = UDFVol.Format( LabelString, Message, flags, ClusterSize );
    }

    if (errcode == LockError) {
        Message->DisplayMsg(MSG_CANT_LOCK_THE_DRIVE);
        return FALSE;
    } else
        return (errcode == NoError);
}


BOOLEAN
FAR APIENTRY
FormatEx(
    IN      PCWSTRING           NtDriveName,
    IN OUT  PMESSAGE            Message,
    IN      PFORMATEX_FN_PARAM  Param,
    IN      MEDIA_TYPE          MediaType
    )
/*++

Routine Description:

    Format an UDFS volume.

Arguments:

    NtDriveName     -- supplies the name (in NT API form) of the volume
    Message         -- supplies an outlet for messages
    Param           -- supplies the format parameter block
    MediaType       -- supplies the volume's Media Type

--*/
{
    DP_DRIVE            DpDrive;
    UDF_VOL             UDFVol;
    FORMAT_ERROR_CODE   errcode;

    if (Param->Major != 1 || Param->Minor != 0) {
        return FALSE;
    }

    if (!DpDrive.Initialize( NtDriveName, Message )) {

        return FALSE;
    }

    if (DpDrive.IsFloppy()) {

        Message->DisplayMsg(MSG_NTFS_FORMAT_NO_FLOPPIES);
        return FALSE;
    }

    errcode = UDFVol.Initialize( NtDriveName,
                                  Message,
                                  FALSE,
                                  (Param->Flags & FORMAT_UDF_200) ? UDF_VERSION_200 : UDF_VERSION_201 );

    if (errcode == NoError) {
        errcode = UDFVol.Format( Param->LabelString,
                                  Message,
                                  Param->Flags,
                                  Param->ClusterSize );
    }

    if (errcode == LockError) {

        if (!(Param->Flags & FORMAT_FORCE)) {
            Message->DisplayMsg(MSG_FMT_FORCE_DISMOUNT_PROMPT);

            if (Message->IsYesResponse(FALSE) &&
                IFS_SYSTEM::DismountVolume(NtDriveName)) {
                Message->DisplayMsg(MSG_VOLUME_DISMOUNTED);
            }
        } else if (IFS_SYSTEM::DismountVolume(NtDriveName)) {
            Message->DisplayMsg(MSG_VOLUME_DISMOUNTED);
        }

        errcode = UDFVol.Initialize( NtDriveName,
                                      Message,
                                      FALSE,
                                      MediaType );

        if (errcode == NoError) {
            errcode = UDFVol.Format( Param->LabelString,
                                      Message,
                                      Param->Flags,
                                      Param->ClusterSize );
        }

        if (errcode == LockError) {
            Message->DisplayMsg(MSG_CANT_LOCK_THE_DRIVE);
            return FALSE;
        } else
            return (errcode == NoError);
    } else
        return (errcode == NoError);
}


BOOLEAN
FAR APIENTRY
Recover(
    IN      PPATH       RecFilePath,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    Recover a file on an NTFS disk.

Arguments:

    RecFilePath --  supplies the path to the file to recover
    Message     --  supplies a channel for messages

Return Value:

    TRUE if successful.

--*/
{
    UDF_VOL    UDFVol;
    PWSTRING    FullPath;
    PWSTRING    DosDriveName;
    DSTRING     NtDriveName;
    BOOLEAN     Result;

    FullPath = RecFilePath->QueryDirsAndName();
    DosDriveName = RecFilePath->QueryDevice();

    if ( DosDriveName == NULL ||
         !IFS_SYSTEM::DosDriveNameToNtDriveName(DosDriveName,
                                                &NtDriveName) ||
         FullPath == NULL ) {

        DELETE(DosDriveName);
        DELETE(FullPath);
        return FALSE;
    }

    Message->DisplayMsg(MSG_RECOV_BEGIN,
                     "%W", DosDriveName);
    Message->WaitForUserSignal();

    Result = ( UDFVol.Initialize( &NtDriveName, Message ) &&
               UDFVol.Recover( FullPath, Message ) );

    DELETE(DosDriveName);
    DELETE(FullPath);
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\uudf\src\format.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

   format.cxx

Abstract:

    This module contains the definition of UDF_SA::Create,
    which performs FORMAT for an UDF volume.

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#include <ntddcdrm.h>
extern "C" {
#include <sptlib.h>
}
#include "crc.hxx"
#include "unicode.hxx"

//  UNDONE, CBiks, 08/18/2000
//      We should find a way to get this from Udfdata.c
//
CHAR UdfCS0IdentifierArray[] = { 'O', 'S', 'T', 'A', ' ',
                                 'C', 'o', 'm', 'p', 'r', 'e', 's', 's', 'e', 'd', ' ',
                                 'U', 'n', 'i', 'c', 'o', 'd', 'e' };

CHAR UdfDomainIdentifierArray[] = { '*', 'O', 'S', 'T', 'A', ' ',
                                    'U', 'D', 'F', ' ',
                                    'C', 'o', 'm', 'p', 'l', 'i', 'a', 'n', 't' };

CHAR UdfImplementationName[] = { '*', 'M', 'i', 'c', 'r', 'o', 's', 'o', 'f', 't' };


BOOL
MarkBlocksUsed
(
    IN  PNSR_SBD    SpaceBitmap,
    IN  ULONGLONG   StartingSector,
    IN  SECTORCOUNT NumberOfSectors
)
{
    BOOL Result = TRUE;

    for ( ULONGLONG BlockNum = StartingSector; BlockNum < (StartingSector + NumberOfSectors); BlockNum++ ) {

        ASSERTMSG( "Cross linked clusters detected",
            (SpaceBitmap->Bits[ (BlockNum / CHAR_BIT) ] & (1 << (BlockNum % CHAR_BIT))) != 0 );

        SpaceBitmap->Bits[ (BlockNum / CHAR_BIT) ] &= ~(1 << (BlockNum % CHAR_BIT));

    }

    return Result;
}

VOID
GetSystemTimeStamp
(
    PTIMESTAMP TimeStamp
)
{
    TIME_ZONE_INFORMATION TimeZoneInfo;
    DWORD TimeZoneResult = GetTimeZoneInformation( &TimeZoneInfo );

    SYSTEMTIME SystemTime;
    GetSystemTime( &SystemTime );

    TimeStamp->Type = TIMESTAMP_T_LOCAL;
    if (TimeZoneResult == TIME_ZONE_ID_UNKNOWN) {

        TimeStamp->Zone = TIMESTAMP_Z_NONE;

    } else {

        TimeStamp->Zone = TimeZoneInfo.Bias;

    }

    TimeStamp->Year =           SystemTime.wYear;
    TimeStamp->Month =          (UCHAR) SystemTime.wMonth;
    TimeStamp->Day =            (UCHAR) SystemTime.wDay;
    TimeStamp->Hour =           (UCHAR) SystemTime.wHour;
    TimeStamp->Minute =         (UCHAR) SystemTime.wMinute;
    TimeStamp->Second =         (UCHAR) SystemTime.wSecond;
    TimeStamp->CentiSecond =    0;
    TimeStamp->Usec100 =        0;
    TimeStamp->Usec =           0;
}

VOID
InitializeREGID
(
    PREGID  RegId,
    PCHAR   Identifier,
    USHORT  IdentifierSize
)
{
    memset( RegId, '\0', sizeof( REGID ) );
    memcpy( RegId->Identifier, Identifier, IdentifierSize );
}

VOID
ComputeTagCRCs
(
    LPBYTE  Descriptor
)
{
    PDESTAG Destag = (PDESTAG) Descriptor;

    //
    //  Generate and store the CRC of the descriptor section.
    //

    if (Destag->CRCLen != 0) {

        Destag->CRC = CalculateCrc( Descriptor + sizeof( DESTAG ), Destag->CRCLen );

    } else {

        Destag->CRC = 0;

    }

    //
    //  Finally, generate and store the checksum of the DESTAG.
    //

    Destag->Checksum = CalculateTagChecksum( Destag );
}

VOID    
RelocateDescriptorTag
(
    LPBYTE  Descriptor,
    ULONG   Lbn
)
{
    PDESTAG Destag = (PDESTAG) Descriptor;

    Destag->Lbn = Lbn;

    ComputeTagCRCs( Descriptor );
}

VOID
InitializeDescriptorTag
(
    LPBYTE  Descriptor,
    ULONG   DescriptorSize,
    USHORT  Ident,
    ULONG   Lbn,
    USHORT  Serial
)
{
    PDESTAG Destag = (PDESTAG) Descriptor;

    //
    //  Initialize the DESTAG portion of the descriptor.
    //

    Destag->Lbn = Lbn;
    Destag->Ident = Ident;
    Destag->Version = DESTAG_VER_NSR03;
    Destag->Res5 = 0;
    Destag->Serial = Serial;

    if (DescriptorSize < MAXUSHORT) {

        Destag->CRCLen = (USHORT)( DescriptorSize ) - sizeof( DESTAG );

    } else {

        Destag->CRCLen = 0;

    }

    ComputeTagCRCs( Descriptor );

    ASSERTMSG( "InitializeDescriptorTag(): The descriptor created is not valid.",
        VerifyDescriptor( Descriptor, DescriptorSize, Ident, NULL ) );
}

VOID
InitializeLogicalVolumeDescriptor
(
    PNSR_LVOL   LogicalVolumeDescriptor,
    ULONG       VolDescSeqNum,
    USHORT      UdfRevision,
    PCWSTRING   Label,
    USHORT      VolumeSetSequence,
    USHORT      PartitionNumber,
    ULONG       FileSetSequenceLBN,
    ULONG       FileSetSequenceSize,
    ULONG       IntegritySequenceLSN,
    ULONG       IntegritySequenceLen,
    USHORT      PrimaryPartitionRefNum,
    ULONG       SectorLen
)
{
    LogicalVolumeDescriptor->VolDescSeqNum = VolDescSeqNum;

    LogicalVolumeDescriptor->Charset.Type = CHARSPEC_T_CS0;
    memcpy( LogicalVolumeDescriptor->Charset.Info, UdfCS0IdentifierArray, sizeof( UdfCS0IdentifierArray ) );

    //
    //  If the user supplied a volume lable, copy it in.  Otherwise just null out the field.
    //
    
    if (Label != NULL) {
        
        CompressDString( 8, Label->GetWSTR(), (UCHAR) Label->QueryChCount(), LogicalVolumeDescriptor->VolumeID,
            sizeof( LogicalVolumeDescriptor->VolumeID ) );
        
    } else {
    
        ZeroMemory( LogicalVolumeDescriptor->VolumeID, sizeof( LogicalVolumeDescriptor->VolumeID ) );
        
    }

    LogicalVolumeDescriptor->BlockSize = SectorLen;

    InitializeREGID( &LogicalVolumeDescriptor->DomainID, UdfDomainIdentifierArray, sizeof( UdfDomainIdentifierArray ) );
    PUDF_SUFFIX_DOMAIN UdfSuffixDomain = (PUDF_SUFFIX_DOMAIN) &LogicalVolumeDescriptor->DomainID.Suffix;
    UdfSuffixDomain->UdfRevision = UdfRevision;
    UdfSuffixDomain->Flags = 0;
    ZeroMemory( UdfSuffixDomain->Reserved, sizeof( UdfSuffixDomain->Reserved ) );

    LogicalVolumeDescriptor->FSD.Length.Type = NSRLENGTH_TYPE_RECORDED;
    LogicalVolumeDescriptor->FSD.Length.Length = FileSetSequenceSize * SectorLen;
    LogicalVolumeDescriptor->FSD.Start.Lbn = FileSetSequenceLBN;
    LogicalVolumeDescriptor->FSD.Start.Partition = PrimaryPartitionRefNum;
    memset( LogicalVolumeDescriptor->FSD.ImpUse, '\0', sizeof( LogicalVolumeDescriptor->FSD.ImpUse ) );

    InitializeREGID( &LogicalVolumeDescriptor->ImpUseID, UdfImplementationName, sizeof( UdfImplementationName ) );
    PUDF_SUFFIX_IMPLEMENTATION UdfSuffixImplementation = (PUDF_SUFFIX_IMPLEMENTATION) &LogicalVolumeDescriptor->ImpUseID.Suffix;
    UdfSuffixImplementation->OSClass = OSCLASS_WINNT;
    UdfSuffixImplementation->OSIdentifier = OSIDENTIFIED_WINNT_WINNT;

    memset( LogicalVolumeDescriptor->ImpUse, '\0', sizeof( LogicalVolumeDescriptor->ImpUse ) );

    LogicalVolumeDescriptor->Integrity.Len = IntegritySequenceLen * SectorLen;
    LogicalVolumeDescriptor->Integrity.Lsn = IntegritySequenceLSN;

    PPARTMAP_PHYSICAL MapTable = (PPARTMAP_PHYSICAL) ((LPBYTE)( LogicalVolumeDescriptor ) + sizeof( NSR_LVOL ) + LogicalVolumeDescriptor->MapTableLength);

    MapTable->Type = PARTMAP_TYPE_PHYSICAL;
    MapTable->Length = sizeof( PARTMAP_PHYSICAL );
    MapTable->VolSetSeq = VolumeSetSequence;
    MapTable->Partition = PartitionNumber;

    LogicalVolumeDescriptor->MapTableCount += 1;
    LogicalVolumeDescriptor->MapTableLength = LogicalVolumeDescriptor->MapTableCount * sizeof( PARTMAP_PHYSICAL );
}

VOID
InitializePrimaryVolumeDescriptor
(
    PNSR_PVD    NsrPVD,
    ULONG       VolDescSeqNum,
    PCWSTR      VolumeID,
    PCWSTR      VolumeSetID
)
{
    //  Main Volume Descriptor Sequence (16 sectors min)
    //
    //  19          DESTAG_ID_NSR_PVD
    NsrPVD->VolDescSeqNum = VolDescSeqNum;
    NsrPVD->Number =        0;

    CompressDString( 8, VolumeID, (UCHAR) wcslen( VolumeID ), NsrPVD->VolumeID, sizeof( NsrPVD->VolumeID ) );

    //
    //  The Volume Set Sequence fields indicates how many volumes form the volume set and what number this volume is in that
    //  sequence.  We are a level 2 implementation, meaning that the volumes we read consist of a single volume. See ECMA 3/8.8.
    //

    NsrPVD->VolSetSeq = 1;
    NsrPVD->VolSetSeqMax = 1;
    NsrPVD->Level = 2;
    NsrPVD->LevelMax = 2;

    //
    //  Set bit zero in the CharSetList masks to indicate we support only CS0 per UDF 2.2.2.3 & 2.2.2.4,
    //
    NsrPVD->CharSetList = UDF_CHARSETLIST;
    NsrPVD->CharSetListMax = UDF_CHARSETLIST;

    CompressDString( 8, VolumeSetID, (UCHAR) wcslen( VolumeSetID ), NsrPVD->VolSetID, sizeof( NsrPVD->VolSetID ) );

    NsrPVD->CharsetDesc.Type = CHARSPEC_T_CS0;
    memcpy( NsrPVD->CharsetDesc.Info, UdfCS0IdentifierArray, sizeof( UdfCS0IdentifierArray ) );

    NsrPVD->CharsetExplan.Type = CHARSPEC_T_CS0;
    memcpy( NsrPVD->CharsetExplan.Info, UdfCS0IdentifierArray, sizeof( UdfCS0IdentifierArray ) );

    NsrPVD->Abstract.Len = 0;
    NsrPVD->Abstract.Lsn = 0;

    NsrPVD->Copyright.Len = 0;
    NsrPVD->Copyright.Lsn = 0;

    memset( &NsrPVD->Application, '\0', sizeof( NsrPVD->Application ) );

    GetSystemTimeStamp( &NsrPVD->RecordTime );

    memset( &NsrPVD->ImpUseID, '\0', sizeof( NsrPVD->ImpUseID ) );
    memset( &NsrPVD->ImpUse, '\0', sizeof( NsrPVD->ImpUse ) );

    NsrPVD->Predecessor = 0;
    NsrPVD->Flags = 0;
}

VOID
InitializePartitionDescriptor
(
    PNSR_PART   PartitionDescriptor,
    USHORT      PartitionNumber,
    ULONG       Sector,
    ULONG       VolDescSeqNum,
    ULONG       Start,
    ULONG       Length,
    ULONG       SpaceBitmapLBN,
    ULONG       SpaceBitmapLen,
    ULONG       SectorLen,
    USHORT      Serial
)
{
    PartitionDescriptor->VolDescSeqNum = VolDescSeqNum;

    PartitionDescriptor->Flags = NSR_PART_F_ALLOCATION;

    PartitionDescriptor->Number = PartitionNumber;

    InitializeREGID( &PartitionDescriptor->ContentsID, NSR_PART_CONTID_NSR03, sizeof( NSR_PART_CONTID_NSR03 ) );

    //
    //
    //

    PNSR_PART_H PartitionHeader = (PNSR_PART_H) &PartitionDescriptor->ContentsUse;

    ZeroMemory( &PartitionHeader->UASTable, sizeof( PartitionHeader->UASTable ) );

    PartitionHeader->UASBitmap.Start = SpaceBitmapLBN;
    PartitionHeader->UASBitmap.Length.Type = NSRLENGTH_TYPE_RECORDED;
    PartitionHeader->UASBitmap.Length.Length = SpaceBitmapLen * SectorLen;


    ZeroMemory( &PartitionHeader->IntegTable, sizeof( PartitionHeader->IntegTable ) );
    ZeroMemory( &PartitionHeader->FreedTable, sizeof( PartitionHeader->FreedTable ) );
    ZeroMemory( &PartitionHeader->FreedBitmap, sizeof( PartitionHeader->FreedBitmap ) );

    ZeroMemory( &PartitionHeader->Res40, sizeof( PartitionHeader->Res40 ) );

    //
    //
    //

    PartitionDescriptor->AccessType = NSR_PART_ACCESS_RW_OVER;

    PartitionDescriptor->Start = Start;
    PartitionDescriptor->Length = Length;

    InitializeREGID( &PartitionDescriptor->ImpUseID, UdfImplementationName, sizeof( UdfImplementationName ) );

    memset( PartitionDescriptor->ImpUse, '\0', sizeof( PartitionDescriptor->ImpUse ) );
    memset( PartitionDescriptor->Res356, '\0', sizeof( PartitionDescriptor->Res356 ) );

    InitializeDescriptorTag( (LPBYTE) PartitionDescriptor, sizeof( NSR_PART ), DESTAG_ID_NSR_PART,
        Sector, Serial );
}

VOID
InitializeIntegrityDescriptor
(
    PNSR_INTEG  IntegrityDescriptor,
    ULONG       IntegritySequenceLSN,
    ULONG       PartitionFreeSpace,
    ULONG       PartitionLen,
    USHORT      Serial,
    USHORT      UdfRevision
)
{
    PLVID_IMP_USE ImpUse;

    ZeroMemory( IntegrityDescriptor, sizeof( IntegrityDescriptor) );
    
    GetSystemTimeStamp( &IntegrityDescriptor->Time );

    //  UNDONE, CBiks, 08/21/2000
    //      Maybe the integrity descriptor should be opened until we are finished writing the disk and then
    //      we rewrite it closed...
    //
    IntegrityDescriptor->Type = NSR_INTEG_T_CLOSE;

    IntegrityDescriptor->Next.Len = 0;
    IntegrityDescriptor->Next.Lsn = 0;

    *((ULONGLONG*) &IntegrityDescriptor->LVHD.UniqueID) = 16;

    IntegrityDescriptor->PartitionCount = 1;

    NsrLvidFreeTable( IntegrityDescriptor)[ 0 ] = PartitionFreeSpace;
    NsrLvidSizeTable( IntegrityDescriptor)[ 0 ] = PartitionLen;

    //
    //  Init the UDF specific part of the LVID
    //

    IntegrityDescriptor->ImpUseLength = sizeof( LVID_IMP_USE);

    ImpUse = Add2Ptr( IntegrityDescriptor, 
                      NsrLvidImpUseOffset( IntegrityDescriptor),
                      PLVID_IMP_USE);

    ImpUse->NumDirs = 1;

    ImpUse->UdfMinRead = 
    ImpUse->UdfMaxWrite = 
    ImpUse->UdfMinWrite = UdfRevision;

    InitializeDescriptorTag( (LPBYTE) IntegrityDescriptor, 
                             NsrLvidSize( IntegrityDescriptor), 
                             DESTAG_ID_NSR_LVINTEG,
                             IntegritySequenceLSN, 
                             Serial );
}

VOID
InitializeFileSet
(
    PNSR_FSD    FileSet,
    ULONG       FileSetSequenceLBN,
    PCWSTRING   Label,
    PCWSTR      VolumeSetIdentifier,
    USHORT      UdfRevision,
    ULONG       RootDirectoryLBN,
    ULONG       RootDirectoryLen,
    USHORT      PrimaryPartitionRefNum,
    ULONG       SectorLen,
    USHORT      Serial
)
{
    GetSystemTimeStamp( &FileSet->Time );

    //
    //  UDF 2.3.2.1 & 2.3.2.2 specify the interchange level must be 3.
    //

    FileSet->Level = 3;
    FileSet->LevelMax = 3;

    FileSet->CharSetList = UDF_CHARSETLIST;
    FileSet->CharSetListMax = UDF_CHARSETLIST;

    FileSet->FileSet = 1;
    FileSet->FileSetDesc = 1;

    FileSet->CharspecVolID.Type = CHARSPEC_T_CS0;
    memcpy( FileSet->CharspecVolID.Info, UdfCS0IdentifierArray, sizeof( UdfCS0IdentifierArray ) );

    //
    //  If the user supplied a volume lable, copy it in.  Otherwise just null out the field.
    //
    
    if (Label != NULL) {
        
        CompressDString( 8, Label->GetWSTR(), (UCHAR) Label->QueryChCount(), FileSet->VolID,
            sizeof( FileSet->VolID ) );
        
    } else {
    
        ZeroMemory( FileSet->VolID, sizeof( FileSet->VolID ) );
        
    }

    FileSet->CharspecFileSet.Type = CHARSPEC_T_CS0;
    memcpy( FileSet->CharspecFileSet.Info, UdfCS0IdentifierArray, sizeof( UdfCS0IdentifierArray ) );

    CompressDString( 8, VolumeSetIdentifier, (UCHAR) wcslen( VolumeSetIdentifier ),
        FileSet->FileSetID, sizeof( FileSet->FileSetID ) );

    ZeroMemory( FileSet->Copyright, sizeof( FileSet->Copyright ) );
    ZeroMemory( FileSet->Abstract, sizeof( FileSet->Abstract ) );

    FileSet->IcbRoot.Start.Lbn = RootDirectoryLBN;
    FileSet->IcbRoot.Start.Partition = PrimaryPartitionRefNum;
    FileSet->IcbRoot.Length.Type = NSRLENGTH_TYPE_RECORDED;
    FileSet->IcbRoot.Length.Length = RootDirectoryLen * SectorLen;
    ZeroMemory( FileSet->IcbRoot.ImpUse, sizeof( FileSet->IcbRoot.ImpUse ) );

    InitializeREGID( &FileSet->DomainID, UdfDomainIdentifierArray, sizeof( UdfDomainIdentifierArray ) );
    PUDF_SUFFIX_DOMAIN UdfSuffixDomain = (PUDF_SUFFIX_DOMAIN) &FileSet->DomainID.Suffix;
    UdfSuffixDomain->UdfRevision = UdfRevision;
    UdfSuffixDomain->Flags = 0;
    ZeroMemory( UdfSuffixDomain->Reserved, sizeof( UdfSuffixDomain->Reserved ) );

    ZeroMemory( &FileSet->NextExtent, sizeof( FileSet->NextExtent ) );

    ZeroMemory( &FileSet->StreamDirectoryIcb, sizeof( FileSet->StreamDirectoryIcb ) );

    ZeroMemory( FileSet->Res464, sizeof( FileSet->Res464 ) );

    InitializeDescriptorTag( (LPBYTE) FileSet, sizeof( NSR_FSD ), DESTAG_ID_NSR_FSD,
        FileSetSequenceLBN, Serial );
}

VOID
InitializeSpaceBitmap
(
    PNSR_SBD    SpaceBitmap,
    ULONG       SpaceBitmapLBN,
    PNSR_PART   NsrPart,
    USHORT      Serial
)
{
    SpaceBitmap->BitCount = NsrPart->Length;
    SpaceBitmap->ByteCount = RoundUp( SpaceBitmap->BitCount, CHAR_BIT );

    FillMemory( &SpaceBitmap->Bits, SpaceBitmap->ByteCount, 0xff );

    InitializeDescriptorTag( (LPBYTE) SpaceBitmap, 
                             sizeof( NSR_SBD ),
                             DESTAG_ID_NSR_SBP, 
                             SpaceBitmapLBN, 
                             Serial );
}

VOID
InitializeRootDirICB
(
    PICBEXTFILE ICBExtFile,
    USHORT      PartitionRefNum,
    ULONG       RootDirectoryLBN,
    ULONG       RootDirectoryLen,
    ULONG       SectorLen,
    USHORT      Serial
)
{
    ICBExtFile->Icbtag.PriorDirectCount = 0;
    ICBExtFile->Icbtag.StratType = ICBTAG_STRAT_DIRECT;
    ICBExtFile->Icbtag.StratParm = 0;
    ICBExtFile->Icbtag.MaxEntries = 1;
    ICBExtFile->Icbtag.Res10 = 0;
    ICBExtFile->Icbtag.FileType = ICBTAG_FILE_T_DIRECTORY;
    ICBExtFile->Icbtag.IcbParent.Lbn = 0;
    ICBExtFile->Icbtag.IcbParent.Partition = 0;
    ICBExtFile->Icbtag.Flags = ICBTAG_F_ALLOC_IMMEDIATE;

    ICBExtFile->UID = 0xffffffff;
    ICBExtFile->GID = 0xffffffff;

    ICBExtFile->Permissions = (ICBFILE_PERM_OWN_A | ICBFILE_PERM_OWN_R) |
        (ICBFILE_PERM_OWN_W | ICBFILE_PERM_OWN_X | ICBFILE_PERM_GRP_A) |
        (ICBFILE_PERM_GRP_R | ICBFILE_PERM_GRP_W | ICBFILE_PERM_GRP_X) |
        (ICBFILE_PERM_OTH_A | ICBFILE_PERM_OTH_R | ICBFILE_PERM_OTH_W | ICBFILE_PERM_OTH_X);

    ICBExtFile->LinkCount = 1;

    ICBExtFile->RecordFormat = 0;
    ICBExtFile->RecordDisplay = 0;
    ICBExtFile->RecordLength = 0;

    //
    //
    //

    ICBExtFile->AllocLength = LongAlign( sizeof( NSR_FID));

    PNSR_FID ParentDirFID = (PNSR_FID)( (LPBYTE)( ICBExtFile ) + sizeof( ICBEXTFILE) );

    ParentDirFID->Version = 1;
    ParentDirFID->Flags = NSR_FID_F_PARENT | NSR_FID_F_DIRECTORY;
    ParentDirFID->FileIDLen = 0;
    ParentDirFID->Icb.Start.Partition = PartitionRefNum;
    ParentDirFID->Icb.Start.Lbn = RootDirectoryLBN;
    ParentDirFID->Icb.Length.Type = NSRLENGTH_TYPE_RECORDED;
    ParentDirFID->Icb.Length.Length = RootDirectoryLen * SectorLen;

    InitializeDescriptorTag( (LPBYTE) ParentDirFID, ISONsrFidSize( ParentDirFID ), DESTAG_ID_NSR_FID,
        RootDirectoryLBN, Serial );

    //
    //
    //

    ICBExtFile->InfoLength = ICBExtFile->AllocLength;
    ICBExtFile->ObjectSize = ICBExtFile->InfoLength;

    ICBExtFile->BlocksRecorded = 0;

    GetSystemTimeStamp( &ICBExtFile->AccessTime );
    GetSystemTimeStamp( &ICBExtFile->ModifyTime );
    GetSystemTimeStamp( &ICBExtFile->CreationTime );
    GetSystemTimeStamp( &ICBExtFile->AttributeTime );
   
    ICBExtFile->Checkpoint = 1;

    ICBExtFile->Reserved = 0;

    ZeroMemory( &ICBExtFile->IcbEA, sizeof( ICBExtFile->IcbEA ) );
    ZeroMemory( &ICBExtFile->IcbStream, sizeof( ICBExtFile->IcbStream ) );

    InitializeREGID( &ICBExtFile->ImpUseID, UdfImplementationName, sizeof( UdfImplementationName ) );
    PUDF_SUFFIX_IMPLEMENTATION UdfSuffixImplementation = (PUDF_SUFFIX_IMPLEMENTATION) &ICBExtFile->ImpUseID.Suffix;
    UdfSuffixImplementation->OSClass = OSCLASS_WINNT;
    UdfSuffixImplementation->OSIdentifier = OSIDENTIFIED_WINNT_WINNT;

    ICBExtFile->UniqueID = 0;

    ICBExtFile->EALength = 0;

    InitializeDescriptorTag( (LPBYTE) ICBExtFile, sizeof( ICBEXTFILE) + ICBExtFile->AllocLength, DESTAG_ID_NSR_EXT_FILE,
        RootDirectoryLBN, Serial );
}


BOOLEAN
UDF_SA::FormatVolumeRecognitionSequence()
{
    BOOLEAN Result = TRUE;

    //  Volume Recognition Sequence.  
    //
    //  NOTE: These structures are 2048 bytes in length,  regardless of sector size.
    //        n = 2048 / sectorsize.  We must also cope with sector sizes > 2048 when
    //        calulating the length of the run in sectors.
    //
    //
    //  16          BEA01
    //  16+n        NSR03
    //  16+2n       TEA01

    ULONG   SectorLen = _drive->QuerySectorSize();

    HMEM    VolumeRecognitionSequenceMem;
    SECRUN  VolumeRecognitionSequenceSecrun;

    ULONG   VolumeRecognitionSequenceStart = 0;
    ULONG   VolumeRecognitionSequenceSectors = (((3 * sizeof( VSD_GENERIC)) + VRA_BOUNDARY_LOCATION) + (SectorLen - 1)) / SectorLen;

    Result = VolumeRecognitionSequenceMem.Initialize();
    if (Result) {

        Result = VolumeRecognitionSequenceSecrun.Initialize( &VolumeRecognitionSequenceMem, _drive,
            VolumeRecognitionSequenceStart, VolumeRecognitionSequenceSectors );
            
        if (Result) {

            LPBYTE VRSBuffer = (LPBYTE) VolumeRecognitionSequenceSecrun.GetBuf();

            //
            //  We zero from and including sector zero to clear out any data at
            //  the beginning of the volume (e.g. BPB) that might decoy other file systems
            //  (i.e. FAT) into trying to mount it and getting in a mess.
            //
    
            memset( VRSBuffer, 0, VolumeRecognitionSequenceSectors * SectorLen);
            VRSBuffer += VRA_BOUNDARY_LOCATION;

            PVSD_BEA01 BEA01 = (PVSD_BEA01) VRSBuffer;
            PVSD_NSR02 NSR =   (PVSD_NSR02) (VRSBuffer + sizeof( VSD_GENERIC));
            PVSD_TEA01 TEA01 = (PVSD_TEA01) (VRSBuffer + 2 * sizeof( VSD_GENERIC));

            BEA01->Type = VSD_NSR02_TYPE_0;
            BEA01->Version = VSD_NSR02_VER;
            memcpy( BEA01->Ident, VSD_IDENT_BEA01, VSD_LENGTH_IDENT );

            //
            //

            NSR->Type = VSD_NSR02_TYPE_0;
            NSR->Version = VSD_NSR02_VER;
            memcpy( NSR->Ident, VSD_IDENT_NSR03, VSD_LENGTH_IDENT );

            //
            //

            TEA01->Type = VSD_NSR02_TYPE_0;
            TEA01->Version = VSD_NSR02_VER;
            memcpy( TEA01->Ident, VSD_IDENT_TEA01, VSD_LENGTH_IDENT );

            Result = VolumeRecognitionSequenceSecrun.Write();
            
            if (!Result) {

                DebugPrint( "UUDF: Unable to write Volume Recognition Sequence.\n" );
            }

        }
    }

    return Result;
}

BOOLEAN
FormatAnchorVolumeDescriptorPtr
(
    PNSR_ANCHOR NsrAnchor,
    ULONG       Sector,
    ULONG       MainVolumeSequenceLSN,
    ULONG       BackupVolumeSequenceLSN,
    SECTORCOUNT VolumeSequenceLen,
    ULONG       SectorLen,
    USHORT      Serial
)
{
    BOOLEAN Result = TRUE;

    //
    //  ECMA 3/8.4.4 requires any space in the sector after the descriptor to be zeroed, so
    //  we start out by zeroing the entire sector.
    //

    ZeroMemory( NsrAnchor, SectorLen );

    //
    //  Save the Volume Descriptor Sequence pointers.
    //

    NsrAnchor->Main.Lsn = MainVolumeSequenceLSN;
    NsrAnchor->Main.Len = VolumeSequenceLen * SectorLen;

    NsrAnchor->Reserve.Lsn = BackupVolumeSequenceLSN;
    NsrAnchor->Reserve.Len = VolumeSequenceLen * SectorLen;

    InitializeDescriptorTag( (LPBYTE) NsrAnchor, sizeof( NSR_ANCHOR ), DESTAG_ID_NSR_ANCHOR, Sector, Serial );

    return Result;
}

BOOLEAN
UDF_SA::Create(
    IN      PCNUMBER_SET    BadSectors,
    IN OUT  PMESSAGE        Message,
    IN      PCWSTRING       Label,
    IN      ULONG           Flags,
    IN      ULONG           ClusterSize,
    IN      ULONG           VirtualSectors
    )
/*++

Routine Description:

    This routine creates a new UDF volume on disk based on defaults.

Arguments:

    BadSectors  - Supplies a list of the bad sectors on the disk.
    Message     - Supplies an outlet for messages.
    Label       - Supplies an optional volume label (may be NULL).
    ClusterSize - Supplies the desired size of a cluster in bytes.
    BackwardCompatible
                - TRUE if volume is not suppose to be upgraded;
                  FALSE if volume is suppose to be upgraded on mount.


Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    BOOLEAN Result = TRUE;

    UNREFERENCED_PARAMETER( VirtualSectors );

    if ((ClusterSize != 0) && (ClusterSize != _drive->QuerySectorSize())) {

        Message->DisplayMsg(MSG_FMT_ALLOCATION_SIZE_EXCEEDED);
        Result = FALSE;

    } else {

        ULONG   SectorLen = _drive->QuerySectorSize();
//        ULONG   BlockLen = _drive->QueryWriteBlockSize();

        //
        //  The initial layout of the disk is explained below (for 2k/sector media - for 
        //  other sector sizes the end block of the VRS changes moving everything following).  
        //
        //  In this example assume the Last LSN is 0x129800, standard
        //  2.6GB/side media.
        //
        //      000000-00000F   The first 32k of the disk is reseved by IDF.
        //      000010-000010   Volume Recognition Sequence
        //             +01800b      BEA01
        //                          NSR02/NSR03
        //                          TEA01
        //      000013-000022   Volume Descriptor Sequence in next 16 sectors of the disk.
        //                          DESTAG_ID_NSR_PVD
        //                          DESTAG_ID_NSR_PART
        //                          DESTAG_ID_NSR_LVOL
        //                          DESTAG_ID_NSR_UASD
        //                          DESTAG_ID_NSR_TERM
        //      000023-000024   Logical Volume Integrity Descriptor Sequence
        //                          DESTAG_ID_NSR_LVINTEG
        //                          DESTAG_ID_NSR_TERM
        //      000025-0000FF   Unallocated space referenced by the Unallocated Space Descriptor.
        //      000100-000100   Anchor Volume Descriptor Pointer - Must be at sector 256.
        //
        // TODO: Should make sure that the partition start is aligned with ECC blocks start if applicable
        //      000120-1297E9   Actual UDF Partition <ECC Block aligned>
        //      000101-000101       DESTAG_ID_NSR_FSD       File Set Descriptor
        //      000102-000102       DESTAG_ID_NSR_TERM      Terminating Descriptor
        //      000103-00014D       DESTAG_ID_NSR_SBP       Space Bitmap Descriptor
        //      00014E-00014E       DESTAG_ID_NSR_EXT_FILE  Root Directory
        //      00014F-1297E8   End of UDF Partition <ECC Block aligned>
        //
        //      << For DVD-+RW / CD-RW media the sparing table / area will be allocated here >>
        //
        //      1297E9-1297FE   Backup Volume Descriptor Sequence in 16 sectors at the end of the disk.
        //      1297FF-1297FF   Backup Anchor Volume Descriptor Pointer - Must be at the last sector of the disk.
        //

        //  UNDONE, CBiks, 08/22/2000
        //      Use SECTORCOUNT, LSN and LBN where appropriate instead of ULONG.
        //

        SECTORCOUNT LastLSN =               _drive->QuerySectors().GetLowPart();
                                            
        ULONG VolumeRecognitionStart =      VRA_BOUNDARY_LOCATION / SectorLen;
        ULONG VolumeRecognitionLength =     ((3 * sizeof( VSD_GENERIC)) + (SectorLen - 1)) / SectorLen;
                                            
        ULONG MainVolumeSequenceStart =     VolumeRecognitionStart + VolumeRecognitionLength;
        ULONG VolumeSequenceLength =        16;
                                            
        ULONG PVDAbsoluteSector =           MainVolumeSequenceStart;
        ULONG PartitionAbsoluteSector =     PVDAbsoluteSector + 1;
        ULONG LVolAbsoluteSector =          PartitionAbsoluteSector + 1;
        ULONG UasdAbsoluteSector =          LVolAbsoluteSector + 1;
        ULONG TermAbsoluteSector =          UasdAbsoluteSector + 1;
                                        
        ULONG IntegritySequenceLSN =        MainVolumeSequenceStart + VolumeSequenceLength;
        
        // UDF 2.2.4.6 - LVID extent must be 8k minimum length?!
        ULONG IntegritySequenceLen =		8*1024 / SectorLen; 
                                        
        ULONG MainAnchorVolumePointer =     0x100;

        ULONG UnallocatedSpaceStart =       IntegritySequenceLSN + IntegritySequenceLen;
        ULONG UnallocatedSpaceLength =      MainAnchorVolumePointer - UnallocatedSpaceStart;
                                            
        ULONG BackupAnchorVolumePointer =   LastLSN - 1;
        ULONG BackupVolumeSequenceLSN =     BackupAnchorVolumePointer - VolumeSequenceLength;
                                            
        ULONG LastSectorInPartition =       BackupVolumeSequenceLSN - 1;
                                        
        USHORT  PrimaryPartitionNumber =    0x2000;
        USHORT  PrimaryPartitionRefNum =    0;

        ULONG   FirstSectorInPartition =    MainAnchorVolumePointer + 1;
        ULONG   PartitionLength =           LastSectorInPartition - FirstSectorInPartition;

        ULONG   FileSetSequenceLBN =        0;
        ULONG   FileSetSequenceLSN =        FirstSectorInPartition;
        ULONG   FileSetSequenceLen =        2;

        ULONG   SpaceBitmapLBN =            FileSetSequenceLBN + FileSetSequenceLen;
        ULONG   SpaceBitmapLSN =            FirstSectorInPartition + SpaceBitmapLBN;
        ULONG   SpaceBitmapLen =            RoundUp( offsetof( NSR_SBD, Bits ) + RoundUp(PartitionLength, CHAR_BIT), SectorLen );
                                        
        ULONG   RootDirectoryLBN =          SpaceBitmapLBN + SpaceBitmapLen;
        ULONG   RootDirectoryLSN =          FirstSectorInPartition + RootDirectoryLBN;
        ULONG   RootDirectoryLen =          1;

        //                              
        //
        //

        PCWSTR VolumeSetIdentifier = L"UDF Volume Set";

        //
        //
        //

        HMEM    MainVolumeSequenceSecrunMem;
        SECRUN  MainVolumeSequenceSecrun;

        HMEM    IntegritySequenceSecrunMem;
        SECRUN  IntegritySequenceSecrun;

        HMEM    PartitionSecrunMem;
        SECRUN  PartitionSecrun;

        HMEM    AnchorVolumePtrSecrunMem;
        SECRUN  AnchorVolumePtrSecrun;

        //
        //  If this looks like C/DVD-RW media,  then we may need to physically
        //  format it
        //
        //  See (in udfsrw branch) nt\base\fs\udfsrw\cdd\cdd.c and associated word doc.
        //

        Result = AnchorVolumePtrSecrunMem.Initialize();
        if (Result) {

            Result = AnchorVolumePtrSecrun.Initialize( &AnchorVolumePtrSecrunMem, _drive, MainAnchorVolumePointer, 1 );

            Result = AnchorVolumePtrSecrun.Read();

            if (Result) {

                USHORT Id;

                //
                //  TEJ 11.1.00 - Extract and increment the tagserial from this
                //                AVDP if it looks valid.
                //

                if (VerifyDescriptor( (LPBYTE)(AnchorVolumePtrSecrun.GetBuf()), 
                                      SectorLen, 
                                      DESTAG_ID_NSR_ANCHOR, 
                                      &Id))  {

                    _NsrAnchor = *(PNSR_ANCHOR)(AnchorVolumePtrSecrun.GetBuf());
                    _NsrAnchor.Destag.Serial += 1;
                }
                else {
                    
                    _NsrAnchor.Destag.Serial = 0;
                }
            }
        }

        Result = MainVolumeSequenceSecrunMem.Initialize();
        if (Result) {

            Result = MainVolumeSequenceSecrun.Initialize( &MainVolumeSequenceSecrunMem, _drive, MainVolumeSequenceStart,
                VolumeSequenceLength );
            if (Result) {

                memset( MainVolumeSequenceSecrun.GetBuf(), '\0', MainVolumeSequenceSecrun.QueryLength() * SectorLen );

            }

        }

        Result = IntegritySequenceSecrunMem.Initialize();
        if (Result) {

            Result = IntegritySequenceSecrun.Initialize( &IntegritySequenceSecrunMem, _drive, IntegritySequenceLSN,
                IntegritySequenceLen );
            if (Result) {

                memset( IntegritySequenceSecrun.GetBuf(), '\0', IntegritySequenceSecrun.QueryLength() * SectorLen );

            }

        }

        if (Result) {

            Result = PartitionSecrunMem.Initialize();
            if (Result) {

                ULONG PartitionLen = FileSetSequenceLen + SpaceBitmapLen + RootDirectoryLen;

                Result = PartitionSecrun.Initialize( &PartitionSecrunMem, _drive, FileSetSequenceLSN, PartitionLen );
                if (Result) {

                    memset( PartitionSecrun.GetBuf(), '\0', PartitionSecrun.QueryLength() * SectorLen );

                }

            }

        }

        if (Result) {

            //
            //
            //

            ULONG VolDescSeqNum = 1;

            //
            //
            //

            LPBYTE VDSSecrunBuffer =   (LPBYTE) MainVolumeSequenceSecrun.GetBuf();

            PNSR_PVD NsrPVD = (PNSR_PVD)( VDSSecrunBuffer );
            VDSSecrunBuffer += SectorLen;

            PNSR_PART NsrPart = (PNSR_PART)( VDSSecrunBuffer );
            VDSSecrunBuffer += SectorLen;

            PNSR_LVOL NsrLvol = (PNSR_LVOL)( VDSSecrunBuffer );
            VDSSecrunBuffer += SectorLen;

            PNSR_UASD NsrUasd = (PNSR_UASD)( VDSSecrunBuffer );
            VDSSecrunBuffer += SectorLen;

            PNSR_TERM NsrTerm = (PNSR_TERM)( VDSSecrunBuffer );
            VDSSecrunBuffer += SectorLen;

            //
            //
            //

            LPBYTE IntegritySequenceBuffer = (LPBYTE) IntegritySequenceSecrun.GetBuf();

            PNSR_INTEG NsrInteg = (PNSR_INTEG)( IntegritySequenceBuffer );
            IntegritySequenceBuffer += SectorLen;

            PNSR_TERM NsrIntegTerm = (PNSR_TERM)( IntegritySequenceBuffer );
            IntegritySequenceBuffer += SectorLen;

            //
            //
            //

            LPBYTE PartitionSecrunBuffer = (LPBYTE) PartitionSecrun.GetBuf();

            PNSR_FSD FileSet = (PNSR_FSD) PartitionSecrunBuffer;
            PartitionSecrunBuffer += SectorLen;

            PNSR_TERM FileSetTerm = (PNSR_TERM)( PartitionSecrunBuffer );
            PartitionSecrunBuffer += SectorLen;

            PNSR_SBD SpaceBitmap = (PNSR_SBD)( PartitionSecrunBuffer );
            PartitionSecrunBuffer += SpaceBitmapLen * SectorLen;

            PICBEXTFILE RootDirectoryIcb = (PICBEXTFILE)( PartitionSecrunBuffer );
            PartitionSecrunBuffer += SectorLen;

            //
            //  The first entry in the VDS will be the Primary Volume Descriptor.
            //

            InitializePrimaryVolumeDescriptor( NsrPVD, VolDescSeqNum, L"UDF Volume", VolumeSetIdentifier );
            InitializeDescriptorTag( (LPBYTE) NsrPVD, sizeof( NSR_PVD ), DESTAG_ID_NSR_PVD, PVDAbsoluteSector, 
                                    _NsrAnchor.Destag.Serial);

            //
            //
            //

            InitializePartitionDescriptor( NsrPart, PrimaryPartitionNumber, PartitionAbsoluteSector, VolDescSeqNum,
                FirstSectorInPartition, PartitionLength, SpaceBitmapLBN, SpaceBitmapLen, SectorLen ,
                _NsrAnchor.Destag.Serial);

            //
            //
            //

            InitializeLogicalVolumeDescriptor( NsrLvol, VolDescSeqNum, _FormatUDFRevision, Label, NsrPVD->VolSetSeq, NsrPart->Number,
                FileSetSequenceLBN, FileSetSequenceLen,
                IntegritySequenceLSN, IntegritySequenceLen,
                PrimaryPartitionRefNum, SectorLen );

            InitializeDescriptorTag( (LPBYTE) NsrLvol, sizeof( NSR_LVOL ) + NsrLvol->MapTableLength,
                DESTAG_ID_NSR_LVOL, LVolAbsoluteSector, _NsrAnchor.Destag.Serial );

            //
            //
            //

            NsrUasd->VolDescSeqNum = VolDescSeqNum;

            NsrUasd->ExtentCount = 1;

            PEXTENTAD Extents = (PEXTENTAD) NsrUasd->Extents;
            Extents->Len = UnallocatedSpaceLength * SectorLen;
            Extents->Lsn = UnallocatedSpaceStart;

            InitializeDescriptorTag( (LPBYTE) NsrUasd, sizeof( NSR_UASD ) + (NsrUasd->ExtentCount * sizeof( EXTENTAD )),
                DESTAG_ID_NSR_UASD, UasdAbsoluteSector, _NsrAnchor.Destag.Serial );

            //
            //
            //

            InitializeDescriptorTag( (LPBYTE) NsrTerm, sizeof( NSR_TERM ), DESTAG_ID_NSR_TERM, TermAbsoluteSector, 
                                      _NsrAnchor.Destag.Serial );

            //
            //
            //

            InitializeFileSet( FileSet, FileSetSequenceLBN, Label, VolumeSetIdentifier, _FormatUDFRevision,
                RootDirectoryLBN, RootDirectoryLen, PrimaryPartitionRefNum, SectorLen, _NsrAnchor.Destag.Serial );

            InitializeDescriptorTag( (LPBYTE) FileSetTerm, sizeof( NSR_TERM ), DESTAG_ID_NSR_TERM,
                FileSetSequenceLBN + 1, _NsrAnchor.Destag.Serial );

            //  259 - 333   DESTAG_ID_NSR_SBP
            //BITVECTOR SpaceBitmap;
            InitializeSpaceBitmap( SpaceBitmap, SpaceBitmapLBN, NsrPart, _NsrAnchor.Destag.Serial );

            //  334         DESTAG_ID_NSR_EXT_FILE  (RootDirectory)
            InitializeRootDirICB( RootDirectoryIcb, PrimaryPartitionRefNum, RootDirectoryLBN, RootDirectoryLen, SectorLen,
                                  _NsrAnchor.Destag.Serial);

            MarkBlocksUsed( SpaceBitmap, FileSetSequenceLBN, FileSetSequenceLen );
            MarkBlocksUsed( SpaceBitmap, SpaceBitmapLBN, SpaceBitmapLen );
            MarkBlocksUsed( SpaceBitmap, RootDirectoryLBN, RootDirectoryLen );

            //  UNDONE, CBiks, 08/21/2000
            //      Fill in the real partition size and free space below.
            //

            InitializeIntegrityDescriptor( NsrInteg, 
                                           IntegritySequenceLSN, 
                                           (NsrPart->Length - FileSetSequenceLen - SpaceBitmapLen - RootDirectoryLen), 
                                           NsrPart->Length, 
                                          _NsrAnchor.Destag.Serial, 
                                          _FormatUDFRevision );

            InitializeDescriptorTag( (LPBYTE) NsrIntegTerm, sizeof( NSR_TERM ), DESTAG_ID_NSR_TERM,
                IntegritySequenceLSN + 1, _NsrAnchor.Destag.Serial );

            if (Result) {

                Result = MainVolumeSequenceSecrun.Write();
                if (Result) {

                    MainVolumeSequenceSecrun.Relocate( BackupVolumeSequenceLSN );
                    RelocateDescriptorTag( (LPBYTE) NsrPVD,  BackupVolumeSequenceLSN );
                    RelocateDescriptorTag( (LPBYTE) NsrPart, BackupVolumeSequenceLSN + 1 );
                    RelocateDescriptorTag( (LPBYTE) NsrLvol, BackupVolumeSequenceLSN + 2 );
                    RelocateDescriptorTag( (LPBYTE) NsrUasd, BackupVolumeSequenceLSN + 3 );
                    RelocateDescriptorTag( (LPBYTE) NsrTerm, BackupVolumeSequenceLSN + 4 );

                    Result = MainVolumeSequenceSecrun.Write();
                    if (Result) {

                        Result = IntegritySequenceSecrun.Write();
                        if (Result) {

                            Result = PartitionSecrun.Write();
                            if (Result) {

                                //
                                //  Write the primary Anchor Volume Descriptor pointer.
                                //

                                PNSR_ANCHOR NsrAnchor = (PNSR_ANCHOR) AnchorVolumePtrSecrun.GetBuf();

                                Result = FormatAnchorVolumeDescriptorPtr( NsrAnchor, MainAnchorVolumePointer, MainVolumeSequenceStart,
                                    BackupVolumeSequenceLSN, VolumeSequenceLength, SectorLen, _NsrAnchor.Destag.Serial );

                                if (Result) {

                                    Result = AnchorVolumePtrSecrun.Write();
                                    if (Result) {

                                        AnchorVolumePtrSecrun.Relocate( BackupAnchorVolumePointer );
                                        RelocateDescriptorTag( (LPBYTE) NsrAnchor,  BackupAnchorVolumePointer );

                                        Result = AnchorVolumePtrSecrun.Write();

                                    }

                                    if (!Result) {

                                        DebugPrint( "UUDF: Unable to write Anchor Volume Descriptor Pointer.\n" );

                                    }
                                }
                            }

                        }

                    }

                }

            }

            //
            //  Write the Volume Recognition Sequence last because the disk is unrecognizable without it, which is what we
            //  want if something goes wrong.
            //

            if (Result) {

                Result = FormatVolumeRecognitionSequence();
                if (!Result) {

                    //  UNDONE, CBiks, 08/17/2000
                    //      Use a real error message.
                    //
                    Message->Set( MSG_FORMAT_FAILED );
                    Message->Display( "" );

                }

            }

        }

    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\uudf\src\pch.cxx ===
/*++

Copyright (c) 1994-2000 Microsoft Corporation

Module Name:

    pch.cxx

Abstract:

    Pre-compiled header for untfs.

Author:

    Matthew Bradburn (mattbr)  26-Apr-1994

--*/

#define _UUDF_MEMBER_

#include "ulib.hxx"

#include <stddef.h>
#include <limits.h>

#pragma warning( disable: 4200 )

inline size_t RoundUp( size_t BlockSize, size_t ElementSize ) {

    return (BlockSize + ElementSize - 1) / ElementSize;

}

//  UNDONE, CBiks, 7/31/2000
//      Iso13346 depends on the alignment macros in udfprocs, which is lame.  These macros should be moved to iso13346.h.
//      
#define LongAlign(Ptr) ((((ULONG)(Ptr)) + 3) & 0xfffffffc)

#define Add2Ptr(PTR,INC,CAST) ((CAST)((ULONG_PTR)(PTR) + (INC)))

#include "udf.h"

#include "uudf.hxx"
#include "udfvol.hxx"
#include "udfsa.hxx"

#include "ifssys.hxx"

#include "chkmsg.hxx"
#include "rtmsg.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\uudf\src\scanads.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    ScanADs.cxx

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"

#include "UdfLVol.hxx"

DEFINE_CONSTRUCTOR( SCAN_ALLOCTION_DESCRIPTORS, OBJECT );

BOOL
SCAN_ALLOCTION_DESCRIPTORS::Initialize
(
    PUDF_LVOL   UdfLVol,
    PICBFILE    FileIcbEntry
)
{
    BOOL Result = TRUE;

    _AdType = 0;
    _AllocationDescriptors = NULL;
    _AllocationDescriptorLength = 0;
    _AllocDescOffset = 0;
    _ReadBuffer = NULL;
    _SectorSize = 0;
    _UdfLVol = NULL;

    ASSERTMSG( "Unimplemented AD Type.\n",
        (FileIcbEntry->Icbtag.Flags & ICBTAG_F_ALLOC_MASK) == ICBTAG_F_ALLOC_SHORT );

    _AdType = FileIcbEntry->Icbtag.Flags & ICBTAG_F_ALLOC_MASK;

    _AllocationDescriptors = (LPBYTE)( FileIcbEntry ) + FeEasFieldOffset( FileIcbEntry ) + FeEaLength( FileIcbEntry );
    _AllocationDescriptorLength = FeAllocLength( FileIcbEntry );

    _UdfLVol = UdfLVol;
    _SectorSize = _UdfLVol->QuerySectorSize();

    _ReadBuffer = (LPBYTE) malloc( _SectorSize );

    return TRUE;
}

BOOL
SCAN_ALLOCTION_DESCRIPTORS::Next
(
    PULONG  StartBlockNum,
    PULONG  Length,
    PSHORT  Type
)
{
    BOOL Result = FALSE;

    if (_AllocDescOffset < _AllocationDescriptorLength) {

        PSHORTAD ShortAd = (PSHORTAD)( _AllocationDescriptors + _AllocDescOffset );

        *StartBlockNum = ShortAd->Start;
        *Length = ShortAd->Length.Length;
        *Type = ShortAd->Length.Type;

        if (*Length != 0) {

            if (*Type == NSRLENGTH_TYPE_CONTINUATION) {

                if (RoundUp( *Length, _SectorSize ) != 1) {

                    //  UDF 2.01/2.3.11 - The length of an extent of Allocation Descriptors shall not exceed
                    //      the logical block size.
                    //

                    Result = FALSE;

                } else {

                    Result = _UdfLVol->Read( *StartBlockNum, 1, _ReadBuffer );
                    if (Result) {

                        Result = _UdfLVol->MarkBlocksUsed( *StartBlockNum, 1 );

                        Result = VerifyDescriptor( _ReadBuffer, _SectorSize, DESTAG_ID_NSR_ALLOC, NULL );
                        if (Result) {

                            PNSR_ALLOC NsrAlloc = (PNSR_ALLOC) _ReadBuffer;

                            _AllocationDescriptors = _ReadBuffer + sizeof( NSR_ALLOC );
                            _AllocDescOffset = 0;
                            _AllocationDescriptorLength = NsrAlloc->AllocLen;
                
                            ShortAd = (PSHORTAD)( _AllocationDescriptors + _AllocDescOffset );

                            *StartBlockNum = ShortAd->Start;
                            *Length = ShortAd->Length.Length;
                            *Type = ShortAd->Length.Type;

                            _AllocDescOffset += sizeof( SHORTAD );

                        }

                    }

                }

            } else {

                _AllocDescOffset += sizeof( SHORTAD );

            }

        }

        Result = TRUE;

    }

    if (*Length == 0) {

        //  UNDONE, CBiks, 8/3/2000
        //      This code assumes a zero length means the end of the ADs.  Is that ok???
        //
        //  Try to catch the case where we reach the end of the AD's, but there are more blocks
        //  allocated that we have not read or marked as allocated.  For example, this code detects the
        //  end of the AD's because a length is zero, but the _AllocationDescriptorLength says there
        //  are more blocks allocated to this AD chain.  This should not happen because UDF says
        //  the AD's must all fit on one page...
        //

        ASSERTMSG( "End of AD's reached, but more blocks are allocated.",
            _AllocationDescriptorLength < _SectorSize );

    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\uudf\src\readvol.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    ReadVRS.cxx

Author:

    Centis Biks (cbiks) 12-Jun-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"
#include "message.hxx"

#include "crc.hxx"

BOOL
GetLengthOfDescriptor
(
    LPBYTE  d,
    PUINT   dLen
)
{
    BOOL Result = TRUE;
    USHORT TagId = ((DESTAG*) d)->Ident;

    switch( TagId ) {

        case DESTAG_ID_NSR_PVD:
            ASSERT( sizeof( NSR_PVD ) == 512);
            *dLen = sizeof( NSR_PVD );
            break;

        case DESTAG_ID_NSR_ANCHOR:
            ASSERT( sizeof( NSR_ANCHOR ) == 512);
            *dLen = sizeof( NSR_ANCHOR );
            break;

        case DESTAG_ID_NSR_VDP:
            ASSERT( sizeof( NSR_VDP ) == 512 );
            *dLen = sizeof( NSR_VDP );
            break;

        case DESTAG_ID_NSR_IMPUSE:
            ASSERT( sizeof( NSR_IMPUSE ) == 512 );
            *dLen = sizeof( NSR_IMPUSE );
            break;

        case DESTAG_ID_NSR_PART:
            ASSERT( sizeof( NSR_PART ) == 512);
            *dLen = sizeof( NSR_PART );
            break;

        case DESTAG_ID_NSR_LVOL: {

            UINT TableLen = ((PNSR_LVOL) d)->MapTableLength;
            ASSERT( offsetof( NSR_LVOL, MapTable ) == 440 );
            *dLen = offsetof( NSR_LVOL, MapTable ) + TableLen;
            break;
        }

        case DESTAG_ID_NSR_UASD: {

            UINT NmbAD = ((PNSR_UASD) d)->ExtentCount;
            ASSERT( offsetof( NSR_UASD, Extents ) == 24 );
            *dLen = offsetof( NSR_UASD, Extents ) + NmbAD * sizeof( EXTENTAD );
            break;
        }

        case DESTAG_ID_NSR_TERM:
            ASSERT( sizeof( NSR_TERM) == 512 );
            *dLen = sizeof( NSR_TERM );
            break;

        case DESTAG_ID_NSR_LVINTEG: {

            *dLen = NsrLvidSize( ((PNSR_INTEG)d));
            break;

        }

        case DESTAG_ID_NSR_FSD:
            ASSERT( sizeof( NSR_FSD ) == 512);
            *dLen = sizeof( NSR_FSD );
            break;

        case DESTAG_ID_NSR_FID: {

            ASSERT( sizeof( NSR_FID) == 38 );
            *dLen = 4 * RoundUp( sizeof( NSR_FID) + ((NSR_FID*) d)->FileIDLen + ((NSR_FID*) d)->ImpUseLen, 4 );
            break;

        }

        case DESTAG_ID_NSR_ALLOC: {

            UINT LenAD = ((PNSR_ALLOC) d)->AllocLen;
            ASSERT( sizeof( NSR_ALLOC ) == 24);
            *dLen = sizeof( NSR_ALLOC ) + LenAD;
            break;

        }

        case DESTAG_ID_NSR_ICBIND:
            ASSERT( sizeof( ICBIND ) == 52);
            *dLen = sizeof( ICBIND );
            break;

        case DESTAG_ID_NSR_ICBTRM:
            ASSERT( sizeof( ICBTRM ) == 36 );
            *dLen = sizeof( ICBTRM );
            break;

        case DESTAG_ID_NSR_FILE: {

            PICBFILE fe = (PICBFILE) d;
            ASSERT( sizeof( ICBFILE) == 176 );
            *dLen = sizeof( ICBFILE) + fe->EALength + fe->AllocLength;
            break;

        }

        case DESTAG_ID_NSR_EXT_FILE: {

            PICBEXTFILE efe = (PICBEXTFILE) d;
            ASSERT( FeEasFieldOffset( efe ) == 216 );

            *dLen = FeEasFieldOffset( efe ) + efe->EALength + efe->AllocLength;
            break;

        }

        case DESTAG_ID_NSR_EA:
            ASSERT( sizeof( NSR_EAH ) == 24 );
            *dLen = sizeof( NSR_EAH );
            break;

        case DESTAG_ID_NSR_UASE: {

            UINT LenAD = ((PICBUASE) d)->AllocLen;
            ASSERT( sizeof( ICBUASE ) == 40);
            *dLen = sizeof( ICBUASE ) + LenAD;
            break;

        }

        case DESTAG_ID_NSR_SBP: {

//            UINT NmbBytes = ((NSR_SBD*) d)->ByteCount;
            ASSERT( offsetof( NSR_SBD, Bits ) == 24);
            *dLen = offsetof( NSR_SBD, Bits ); // + NmbBytes;
            break;

        }

        default: {

            DbgPrint( "GetLengthOfDescriptor: Error: Unknown descriptor tagIdentifier: %u\n", TagId);
            Result = FALSE;
            break;
        }
    }

    return Result;
}

BOOL
VerifyDescriptorTag
(
    LPBYTE  buffer,
    UINT    bufferLength,
    USHORT  expectedTagId,
    PUSHORT pExportTagId
)
{
    DESTAG* DescriptorTag = (DESTAG*) buffer;
    USHORT  TagId;
    BOOL    Result = TRUE;

    //  Clear optional return arguments, if they're there.
    //
    if (pExportTagId != NULL) {
        *pExportTagId = DESTAG_ID_NOTSPEC;
    }

    if (bufferLength < sizeof( DESTAG )) {

        DbgPrint("inspectDescriptor error: buffer length: %lu, less than tag size, please report.\n",
            bufferLength );
        return FALSE;

    }

    TagId = DescriptorTag->Ident;

    if (expectedTagId == DESTAG_ID_NOTSPEC) {

        //  If the caller doesn't expect any specail Tag in return, make sure the one we found makes sense.
        //
        if (TagId < DESTAG_ID_MINIMUM_PART3 ||
            (TagId > DESTAG_ID_MAXIMUM_PART3 && TagId < DESTAG_ID_MINIMUM_PART4) ||
            TagId > DESTAG_ID_MAXIMUM_PART4_NSR03 ||
            TagId == DESTAG_ID_NSR_PINTEG) {

            DbgPrint( "Error: Unknown descriptor tag identifier: %u\n", TagId);
            return FALSE;

        }

    } else if (expectedTagId != TagId) {

        //  The Tag we found is not the Tag the caller expected.
        //
        DbgPrint( "Error: Unexpected descriptor tag id: %x expected: %x\n",
            TagId, expectedTagId );
        return FALSE;

    }

    UCHAR TagChecksum = CalculateTagChecksum( DescriptorTag );
    if ( DescriptorTag->Checksum != TagChecksum )
    {
        DbgPrint( "Tag Checksum Error: %u, expected: %u",
            DescriptorTag->Checksum, TagChecksum );
        return FALSE;
    }

    //  It looks like the descriptor is valid, so send the Tag ID back to the caller.
    //

    if ( pExportTagId != NULL ) {
        *pExportTagId = TagId;
    }

    return TRUE;
}

BOOL
VerifyDescriptor
(
    LPBYTE  buffer,
    UINT    numberOfBytesRead,
    USHORT  expectedTagId,
    USHORT* pExportTagId
)
{
    BOOL Result = VerifyDescriptorTag( buffer, numberOfBytesRead, expectedTagId, pExportTagId );
    if (Result) {

        DESTAG* DescriptorTag = (DESTAG*) buffer;
        USHORT tagId = DescriptorTag->Ident;

        UINT DescriptorLength;
        Result = GetLengthOfDescriptor( buffer, &DescriptorLength );
        if (Result) {

            if (numberOfBytesRead < DescriptorLength) {

                DbgPrint( "\tDescriptor length error: %lu, expected: %lu\n",
                    numberOfBytesRead, DescriptorLength );
                Result = FALSE;

            } else {

                USHORT ExpectedCRC = CalculateCrc( buffer + sizeof( DESTAG ), DescriptorTag->CRCLen );
                if (DescriptorTag->CRC != ExpectedCRC) {

                    DbgPrint( "\tDescriptor CRC error: %u, expected: %u\n",
                        DescriptorTag->CRC, ExpectedCRC );
                    Result = FALSE;

                }

            }

        }

    }

    return Result;
}

BOOL
UDF_SA::ReadAnchorVolumeDescriptorPointer
(
    UINT        Sector,
    PNSR_ANCHOR NsrAnchorFound
)
{
    BOOL Result = FALSE;

    HMEM SecrunMemory;
    if (!SecrunMemory.Initialize()) {
        
        return FALSE;

    }

    SECRUN Secrun;
    if (!Secrun.Initialize( &SecrunMemory, _drive, Sector, 1 )) {

        return FALSE;

    }

    if (Secrun.Read()) {

        PNSR_ANCHOR NsrAnchorInSecRun = (PNSR_ANCHOR) Secrun.GetBuf();

        if (!VerifyDescriptor( (LPBYTE) NsrAnchorInSecRun, QuerySectorSize(), DESTAG_ID_NSR_ANCHOR, NULL )) {

            DbgPrint( "\tNo correct AVDP found here\n" );

        } else {

            *NsrAnchorFound = *NsrAnchorInSecRun;
            Result = TRUE;

        }
    }

    return Result;
}

static BOOL
CompareAnchorVolumeDescriptorPointers
(
    PNSR_ANCHOR NsrAnchor1,
    PNSR_ANCHOR NsrAnchor2
)
{
    BOOL Result = FALSE;

    if ( memcmp( &NsrAnchor1->Main, &NsrAnchor2->Main, sizeof( EXTENTAD ) ) == 0 &&
        memcmp( &NsrAnchor1->Reserve, &NsrAnchor2->Reserve, sizeof( EXTENTAD ) ) == 0 ) {

        Result = TRUE;

    } else {

        DbgPrint( "\tAVDP error: Volume Descriptor Sequence Extent not equal to\n"
            "-\t\t    the one read in first AVDP\n"
            "-\t\t       Main VDSE: %3lu, %-5lu expected:  %3lu, %-5lu\n"
            "-\t\t    Reverve VDSE: %3lu, %-5lu expected:  %3lu, %-5lu\n"
            "-\tUsing first AVDP\n",
            NsrAnchor1->Main.Len, NsrAnchor1->Main.Lsn,
            NsrAnchor2->Main.Len, NsrAnchor2->Main.Lsn,
            NsrAnchor1->Reserve.Len, NsrAnchor1->Reserve.Lsn,
            NsrAnchor2->Reserve.Len, NsrAnchor2->Reserve.Lsn );

    }

    return Result;
}

BOOL
UDF_SA::GetAnchorVolumeDescriptorPointer
(
    PNSR_ANCHOR         pavdp
)
{
    BOOL Result = TRUE;
    INT MismatchCount = 0;
    INT AnchorCount = 0;

    NSR_ANCHOR NsrAnchor1;
    BOOL FoundNsrAnchor1 = FALSE;
    if (ReadAnchorVolumeDescriptorPointer( 256, &NsrAnchor1 ))
    {
        FoundNsrAnchor1 = TRUE;
        AnchorCount++;

        *pavdp = NsrAnchor1;
    }

    UINT LastSector = _drive->QuerySectors().GetLowPart();

    NSR_ANCHOR NsrAnchor2;
    BOOL FoundNsrAnchor2 = FALSE;
    if (ReadAnchorVolumeDescriptorPointer( LastSector - 256, &NsrAnchor2 ))
    {
        if (FoundNsrAnchor1)
        {
            if (!CompareAnchorVolumeDescriptorPointers( &NsrAnchor1, &NsrAnchor2 ))
            {
                MismatchCount++;
            }
        }

        FoundNsrAnchor2 = TRUE;
        AnchorCount++;
    }

    NSR_ANCHOR NsrAnchor3;
    if (ReadAnchorVolumeDescriptorPointer( LastSector, &NsrAnchor3 ))
    {
        if (FoundNsrAnchor1) {

            if (!CompareAnchorVolumeDescriptorPointers( &NsrAnchor1, &NsrAnchor3 )) {
                MismatchCount++;
            }

        } else if (FoundNsrAnchor2) {

            if (!CompareAnchorVolumeDescriptorPointers( &NsrAnchor2, &NsrAnchor3 )) {
                MismatchCount++;
            }

        }

        AnchorCount++;
    }

    //  If we found at least one of the anchors, or we found more and they are the same, then the
    //  anchors are ok.
    //
    if ((AnchorCount > 0) && (MismatchCount == 0)) {

        Result = TRUE;

    }

    //  UNDONE, CBiks, 06/08/2000
    //      Make sure these cases are handled properly.
    //
    ASSERT( (FoundNsrAnchor1 == TRUE) && (Result == TRUE) );

    DbgPrint( "Read Main VDS extent: %7lu, length: %6lu\n",
        _NsrAnchor.Main.Lsn, _NsrAnchor.Main.Len );

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\uudf\src\udfchk.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    udfsa.cxx

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"

#include "UdfLVol.hxx"
#include "message.hxx"
#include "unicode.hxx"

#include "stdio.h"

BOOLEAN
UDF_SA::VerifyAndFix(
    IN      FIX_LEVEL   FixLevel,
    IN OUT  PMESSAGE    Message,
    IN      ULONG       Flags,
    IN      ULONG       DesiredLogFileSize,
    IN      USHORT      Algorithm,
    OUT     PULONG      ExitStatus,
    IN      PCWSTRING   DriveLetter
    )
/*++

Routine Description:

    This routine verifies and, if necessary, fixes a UDF volume.

Arguments:

    FixLevel            - Supplies the level of fixes that may be performed on
                            the disk.
    Message             - Supplies an outlet for messages.
    Flags               - Supplies flags to control behavior of chkdsk
                          (see ulib\inc\ifsentry.hxx for details)
    DesiredLogFileSize  - Supplies the desired logfile size in bytes, or 0 if
                            the logfile is to be resized to the default size.
    Algorithm           - Supplies the algorithm to use for index verification
    ExitStatus          - Returns an indication of how the checking went
    DriveLetter         - For autocheck, the letter for the volume we're checking

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    if (!ReadVolumeRecognitionSequence()) {

        DbgPrint( "\tUDF_SA::VerifyAndFix() : ReadVolumeRecognitionSequence() failed\n\n" );

    }

    if (!GetAnchorVolumeDescriptorPointer( &_NsrAnchor )) {

        return FALSE;

    }

    PNSR_PVD PrimaryVolumeDescriptor;
    FindVolumeDescriptor( DESTAG_ID_NSR_PVD, (LPBYTE*) &PrimaryVolumeDescriptor );

    if ((PrimaryVolumeDescriptor->VolSetSeq == 1) && (PrimaryVolumeDescriptor->VolSetSeqMax == 1)) {

        PNSR_PART PartitionDescriptor;
        FindVolumeDescriptor( DESTAG_ID_NSR_PART, (LPBYTE*) &PartitionDescriptor );

        PNSR_LVOL LogicalVolumeDescriptor;
        FindVolumeDescriptor( DESTAG_ID_NSR_LVOL, (LPBYTE*) &LogicalVolumeDescriptor );

        USHORT UdfVersion = ((PUDF_SUFFIX_UDF) &LogicalVolumeDescriptor->DomainID.Suffix)->UdfRevision;

        if ((UdfVersion ==UDF_VERSION_100) || (UdfVersion == UDF_VERSION_101) || (UdfVersion == UDF_VERSION_102) ||
            (UdfVersion == UDF_VERSION_150) || (UDF_VERSION_200 == UdfVersion) || (UdfVersion == UDF_VERSION_201)) {

            DSTRING VolumeID;
            UncompressDString( (LPBYTE) LogicalVolumeDescriptor->VolumeID, sizeof( LogicalVolumeDescriptor->VolumeID ), &VolumeID );

            WCHAR PrintableVersion[ 32 ];
            wsprintf( PrintableVersion, L"%d.%02d", HIBYTE( UdfVersion ), LOBYTE( UdfVersion ) );

            Message->Set( MSG_UDF_VOLUME_INFO );
            Message->Display( "%W%ws", &VolumeID, PrintableVersion );


            //  UNDONE, CBiks, 7/15/2000
            //      Read the reserve VDS and make sure it's the same as the main.
            //

            //
            //
            //

            UDF_LVOL UdfLVol;

            UdfLVol.Initialize( this, Message, LogicalVolumeDescriptor, PartitionDescriptor );

            if (!UdfLVol.CheckFileStructure()) {

                DbgPrint( " checkVolume error: checkFileStructure fails\n" );
                return FALSE;

            }

        } else {

            Message->Set( MSG_UDF_VERSION_UNSUPPORTED );
            Message->Display( "%W", DriveLetter );

        }

        free( LogicalVolumeDescriptor );
        LogicalVolumeDescriptor = NULL;

        free( PartitionDescriptor );
        PartitionDescriptor = NULL;

    }

    free( PrimaryVolumeDescriptor );
    PrimaryVolumeDescriptor = NULL;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\uudf\src\readvrs.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    ReadVRS.cxx

Author:

    Centis Biks (cbiks) 12-Jun-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"

#include "message.hxx"

typedef struct      /* ECMA 2/9.1 etc. */
{
    VSD_IDENT   type;
    PCSTR       string;    /* \0 terminated StandardIdentifier string */
} VsdTable;

static VsdTable vsdTable[] =
{
    { VsdIdentBEA01, VSD_IDENT_BEA01 },
    { VsdIdentBOOT2, VSD_IDENT_BOOT2 },
    { VsdIdentCD001, VSD_IDENT_CD001 },
    { VsdIdentCDW02, VSD_IDENT_CDW02 },
    { VsdIdentNSR02, VSD_IDENT_NSR02 },
    { VsdIdentNSR03, VSD_IDENT_NSR03 },
    { VsdIdentTEA01, VSD_IDENT_TEA01 }
};

static VSD_IDENT
VerifyVolRecVSD
(
    PVSD_GENERIC vsd
)
{
    VSD_IDENT  type = VsdIdentBad;
    int      i;
    char    *dInfo = "Volume Structure Descriptor. ECMA 2/9. or 3/9.1";
    char    *typeStr = "";

    for( i = 0; i < (sizeof( vsdTable ) / sizeof( VsdTable )); i++ )
    {
        if( memcmp( vsd->Ident, vsdTable[i].string, 5 ) == 0)
        {
            type = vsdTable[i].type;
            typeStr = (char*)vsdTable[i].string;
            DbgPrint( "\t%s\n", typeStr);
            if(    type != VsdIdentCD001    /* no further test for VsdIdentCD001 */
                && type != VsdIdentCDW02 )                  /* and VsdIdentCDW02 */
            {
                if( vsd->Type != 0 )
                {
                    DbgPrint( "\tError: Type   : %lu, expected 0\n"
                        "-\t       in %s %s\n", vsd->Type, typeStr, dInfo );
                }

                if( vsd->Version != 1 )
                {
                    DbgPrint( "\tError: Version: %lu, expected 1\n"
                        "-\t       in %s %s\n", vsd->Version, typeStr, dInfo );
                }
            }
            break;      /* type found */
        }
    }
    return type;
}

BOOL
UDF_SA::ReadVolumeRecognitionSequence()
{
    LPBYTE      readbuffer;
    BOOL        ready, result;
    VSD_IDENT   vsdType;
    VSD_IDENT   prevVsdType;
    int         BEA_TEA_balance;
    int         cntTotal;
    int         cntBEA01;
    int         cntTEA01;
    int         cntNSR02;
    int         cntNSR03;
    UINT        blocksPerVSD;

    DbgPrint( "\tRead Volume Recognition Sequence\n" );

    ASSERT( sizeof( VSD_GENERIC ) == 2048 );

    blocksPerVSD = RoundUp( sizeof( VSD_GENERIC ), QuerySectorSize() );

    UINT sectNumb = 16;

    readbuffer = (LPBYTE) malloc( blocksPerVSD * QuerySectorSize() );
    if( readbuffer == NULL ) {
        return FALSE;
    }

    vsdType = VsdIdentBad;
    cntTotal = cntBEA01 = cntTEA01 = cntNSR02 = cntNSR03 = 0;

    for( ready = FALSE; ready == FALSE; sectNumb += blocksPerVSD )
    {
        prevVsdType = vsdType;
        if( !Read( sectNumb, blocksPerVSD, readbuffer ) )
        {
            vsdType = VsdIdentBad;  /* read error */
        }
        else
        {
            vsdType = VerifyVolRecVSD( (PVSD_GENERIC) readbuffer );
        }
        if( vsdType != VsdIdentBad )
        {
            cntTotal++;
        }
        switch( vsdType )
        {
        case VsdIdentBad:       /* read error or unknown descriptor */
            ready = TRUE;
            break;
        case VsdIdentBEA01:
            if( cntBEA01 == 0 )     /* first BEA01 */
            {
                if( cntTEA01 != 0 )
                {
                    DbgPrint( "\tWarning: %lu times %s before first %s\n",
                        cntTEA01, VSD_IDENT_TEA01, VSD_IDENT_BEA01);
                }
                if( cntTotal != 1 )
                {
                    DbgPrint( "\t%lu Volume Structure Descriptors found before first %s\n",
                        cntTotal - 1, VSD_IDENT_BEA01 );
                }
                DbgPrint( "\tStart of Extended Area\n");
                BEA_TEA_balance = 0;
            }
            else                    /* not first BEA01 */
            {
                if( prevVsdType != VsdIdentTEA01 )
                {
                    DbgPrint( "\tWarning: %s not preceded by %s\n",
                                    VSD_IDENT_BEA01, VSD_IDENT_TEA01);
                }
            }

            if( BEA_TEA_balance != 0 )
            {
                DbgPrint( "\tWarning: %s / %s unbalance\n",
                                    VSD_IDENT_BEA01, VSD_IDENT_TEA01);
            }
            BEA_TEA_balance = 1;
            cntBEA01++;
            break;
        case VsdIdentTEA01:
            if(    cntBEA01 != 0            /* within Extended Area */
                && BEA_TEA_balance != 1
              )
            {
                DbgPrint( "\tWarning: %s / %s unbalance\n",
                                    VSD_IDENT_BEA01, VSD_IDENT_TEA01);
            }
            BEA_TEA_balance = 0;
            cntTEA01++;
            break;
        case VsdIdentNSR02:
            cntNSR02++;
            break;
        case VsdIdentNSR03:
            cntNSR03++;
            break;
        }
    }       /* endfor */

    if( cntBEA01 != 0 )
    {
        DbgPrint( "\tEnd of Extended Area\n");
    }
    DbgPrint(    "\tEnd of Volume Recognition Sequence\n\n");

    result = TRUE;          /* check results */


    if( cntBEA01 == 0 )     /* no Extended Area */
    {
        DbgPrint( "\tError: %s Volume Recognition Sequence\n",
                        (cntTotal==0) ? "Empty" : "No Extended Area in");
        result = FALSE;
    }
    else if( prevVsdType != VsdIdentTEA01 ) /* last valid descriptor read */
    {
        DbgPrint( 
             "\tError: End of Extended Area was no %s\n"
            "-\t       Volume Recognition Sequence not properly closed\n",
                                            VSD_IDENT_TEA01);
        result = FALSE;
    }

    /* test NSR descriptors
     */
    if( cntNSR02 != 0 && cntNSR03 != 0 )
    {
        DbgPrint( "\tError: %lu %s and %lu %s descriptors found\n",
                            cntNSR02, VSD_IDENT_NSR02, cntNSR03, VSD_IDENT_NSR03);
        result = FALSE;
    }
    else if( cntNSR02 + cntNSR03 == 0 )
    {
        DbgPrint( "\tError: NSR descriptor missing\n");
        result = FALSE;
    }

    free( readbuffer );

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\uudf\src\scanfids.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    ScanFIDs.cxx

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"

#include "UdfLVol.hxx"
#include "ScanFIDs.hxx"

DEFINE_CONSTRUCTOR( SCAN_FIDS, OBJECT );

BOOL
SCAN_FIDS::Initialize
(
    PUDF_LVOL   UdfLVol,
    PICBFILE    FileIcbEntry
)
{
    BOOL Result = TRUE;

    _BytesRemainingInExtent = 0;
    _ReadBufferSize = 0;
    _ReadBuffer = NULL;
    _LogicalBlockNum = 0;
    _BufferOffset = 0;
    _BytesRemainingInBuffer = 0;

    _PreviousReadSize = 0;

    _SectorSize = 0;
    _UdfLVol = NULL;

    Result = _AllocationDescriptors.Initialize( UdfLVol, FileIcbEntry );
    if (Result) {

        _UdfLVol = UdfLVol;
        _SectorSize = _UdfLVol->QuerySectorSize();

        _ReadBufferSize = _SectorSize * 2;
        _ReadBuffer = (LPBYTE) malloc( _ReadBufferSize );

        ULONG   StartBlockNum;
        ULONG   Length;
        SHORT   Type;

        if (_AllocationDescriptors.Next( &StartBlockNum, &Length, &Type)) {

            if (Length > 0) {

                _BytesRemainingInExtent = Length;
                _LogicalBlockNum = StartBlockNum;

                UINT NumberOfBlocks = __min( 2, (_BytesRemainingInExtent + _SectorSize - 1) / _SectorSize );

                BOOL result = _UdfLVol->Read( StartBlockNum, NumberOfBlocks, _ReadBuffer );
                if (result) {

                    Result = _UdfLVol->MarkBlocksUsed( StartBlockNum, NumberOfBlocks );

                    _LogicalBlockNum += NumberOfBlocks;
                    _BufferOffset = 0;
                    _BytesRemainingInBuffer = __min( _ReadBufferSize, _BytesRemainingInExtent );

                }

            }

        }

    }

    return Result;
}

LPBYTE
SCAN_FIDS::ProbeRead
(
    ULONG ReadSize
)
{
    LPBYTE BufferPtr = NULL;

    if (ReadSize > _BytesRemainingInBuffer) {

        if (ReadSize > _BytesRemainingInExtent) {

            ULONG   StartBlockNum;
            ULONG   Length;
            SHORT   Type;

            if (_AllocationDescriptors.Next( &StartBlockNum, &Length, &Type)) {

                if (Length > 0) {

                    if (Type == NSRLENGTH_TYPE_RECORDED) {

                        _LogicalBlockNum = StartBlockNum;
                        _BytesRemainingInExtent += Length;

                    } else if (Type == NSRLENGTH_TYPE_UNRECORDED) {

                        BOOL result = _UdfLVol->MarkBlocksUsed( StartBlockNum, RoundUp( Length, _SectorSize ) );

                    } else {

                        ASSERTMSG( "Unsupported length type",
                            0 );

                    }

                }

            }

        }

        if (ReadSize < _BytesRemainingInExtent) {

            memmove( _ReadBuffer, _ReadBuffer + _SectorSize, _SectorSize );

            BOOL result = _UdfLVol->Read( _LogicalBlockNum, 1, _ReadBuffer + _SectorSize );

            if (result) {

                result = _UdfLVol->MarkBlocksUsed( _LogicalBlockNum, 1 );

                _LogicalBlockNum += 1;

                _BufferOffset -= _SectorSize;
                _BytesRemainingInBuffer = __min( _BytesRemainingInBuffer + _SectorSize, _BytesRemainingInExtent );

                BufferPtr = _ReadBuffer + _BufferOffset;

            }

        }

    }

    if (ReadSize <= _BytesRemainingInBuffer) {

        BufferPtr = _ReadBuffer + _BufferOffset;

    }

    return BufferPtr;
}

BOOL
SCAN_FIDS::Next
(
    PNSR_FID* NsrFid
)
{
    BOOL Result = FALSE;

    if (_PreviousReadSize != 0) {

        LPBYTE BufferPtr = ProbeRead( _PreviousReadSize );
        if (BufferPtr != NULL) {

            _BufferOffset += _PreviousReadSize;
            _BytesRemainingInBuffer -= _PreviousReadSize;
            _BytesRemainingInExtent -= _PreviousReadSize;
            _PreviousReadSize = 0;

        }

    }

    LPBYTE BufferPtr = ProbeRead( sizeof( DESTAG ) );
    if (BufferPtr != NULL) {

        Result = VerifyDescriptorTag( BufferPtr, sizeof( DESTAG ), DESTAG_ID_NSR_FID, NULL );
        if (Result) {

            BufferPtr = ProbeRead( sizeof( NSR_FID) );
            if (BufferPtr != NULL) {

                BufferPtr = ProbeRead( ISONsrFidSize( PNSR_FID( BufferPtr ) ) );

                Result = VerifyDescriptor( BufferPtr, ISONsrFidSize( PNSR_FID( BufferPtr ) ), DESTAG_ID_NSR_FID, NULL );
                if (Result) {

                    _PreviousReadSize = ISONsrFidSize( PNSR_FID( BufferPtr ) );
                    *NsrFid = PNSR_FID( BufferPtr );

                }

            }

        }

    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\uudf\src\sources.inc ===
!IF 0

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in $(BASEDIR)\bak\bin\sources.tpl

!ENDIF

TARGETNAME=uudf
TARGETPATH=obj
TARGETTYPE=DYNLINK

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\user32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(PROJECT_LIB_PATH)\patchbc.lib \
           $(PROJECT_ROOT)\fs\utils\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib    \
           $(PROJECT_ROOT)\fs\utils\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib

USE_MSVCRT=1
DLLENTRY=InitializeUUDF
PRECOMPILED_INCLUDE= ..\pch.cxx
MSC_WARNING_LEVEL=/W3 /WX

SOURCES= ..\CheckFileStruct.cxx \
         ..\crc.cxx \
         ..\entry.cxx \
         ..\format.cxx \
         ..\ReadVol.cxx \
         ..\ReadVRS.cxx \
         ..\ScanADs.cxx \
         ..\ScanFIDs.cxx \
         ..\udfchk.cxx \
         ..\UdfLVol.cxx \
         ..\udfsa.cxx \
         ..\udfvol.cxx \
         ..\unicode.cxx \
         ..\uudf.cxx \
         ..\uudf.rc \
         ..\VerifySBDAllocation.cxx

INCLUDES=..\.;			\
	 ..\..\inc;		\
	 $(PROJECT_ROOT)\fs\utils\ulib\inc;	\
         $(PROJECT_ROOT)\fs\utils\ifsutil\inc;	\
	 $(PROJECT_ROOT)\fs\udfsrw;		\
	 $(DDK_INC_PATH)

C_DEFINES=/DUNICODE=1
!if $(FREEBUILD)
C_DEFINES=$(C_DEFINES) /DDBG=0
!else
C_DEFINES=$(C_DEFINES) /DDBG=1
!IFNDEF NOMEMLEAK
C_DEFINES=$(C_DEFINES) /DMEMLEAK
!ENDIF
!IFDEF STACK_TRACE
C_DEFINES=$(C_DEFINES) /DSTACK_TRACE
!ENDIF
!ENDIF

UMTYPE=console
DLLDEF=..\uudf.def

W32_SB=1
SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\uudf\src\udflvol.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    UdfLVol.cxx

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"

#include "UdfLVol.hxx"
#include "ScanFIDs.hxx"
#include "unicode.hxx"

DEFINE_CONSTRUCTOR( UDF_LVOL, OBJECT );

VOID
UDF_LVOL::Construct (
    )
/*++

Routine Description:

    This routine sets a UDF_LVOL to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}

VOID
UDF_LVOL::Destroy(
    )
/*++

Routine Description:

    This routine returns an UDF_LVOL to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


UUDF_EXPORT
UDF_LVOL::~UDF_LVOL(
    )
/*++

Routine Description:

    Destructor for UDF_LVOL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

BOOLEAN
UDF_LVOL::Initialize
(
    IN      PUDF_SA     UdfSA,
    IN OUT  PMESSAGE    Message,
    IN      PNSR_LVOL   LogicalVolumeDescriptor,
    IN      PNSR_PART   PartitionDescriptor
)
{
    BOOLEAN Result = FALSE;

    _UdfSA = UdfSA;
    _Message = Message;
    _LogicalVolumeDescriptor = LogicalVolumeDescriptor;
    _PartitionDescriptor = PartitionDescriptor;

    UINT BlocksRead = 0;
    USHORT TagID = DESTAG_ID_NOTSPEC;
    if (!_UdfSA->ReadDescriptor( _LogicalVolumeDescriptor->Integrity.Lsn, &BlocksRead, DESTAG_ID_NSR_LVINTEG, &TagID,
        (LPBYTE*)( &_LogicalVolumeIntegrityDescriptor ) )) {

        return FALSE;

    }

    ASSERTMSG( "Only a single LVID should be present.\n",
        _LogicalVolumeIntegrityDescriptor->Next.Len == 0 );

    if (_LogicalVolumeIntegrityDescriptor->Type != 1) {

        Message->DisplayMsg( MSG_UDF_VOLUME_NOT_CLOSED );

    }

    _LogicalVolumeIntegrityDescriptor->Type = 1;

    //Write( 


    //  As we run we build up a new allocation bitmap so we can see if the one on the disk is ok.
    //

    ULONG NewSpaceBitmapDescriptorByteCount = RoundUp( PartitionDescriptor->Length, CHAR_BIT );
    ULONG NewSpaceBitmapDescriptorSize = sizeof( NSR_SBD ) +  NewSpaceBitmapDescriptorByteCount;

    _NewSpaceBitmapDescriptor = (PNSR_SBD) malloc( NewSpaceBitmapDescriptorSize );
    if (_NewSpaceBitmapDescriptor == NULL) {

        //  UNDONE, CBiks, 8/4/2000
        //      Not enough memory for the bitmap - what should we really do?

        return FALSE;

    } else {

        memset( &_NewSpaceBitmapDescriptor->Destag, '\0', sizeof( DESTAG ) );
        _NewSpaceBitmapDescriptor->BitCount = PartitionDescriptor->Length;
        _NewSpaceBitmapDescriptor->ByteCount = NewSpaceBitmapDescriptorByteCount;

        for ( ULONG i = 0; i < _NewSpaceBitmapDescriptor->ByteCount; i++ ) {

            _NewSpaceBitmapDescriptor->Bits[ i ] = (UCHAR) 0xff;

        }

    }

    //
    //
    //

    if (!ReadSpaceBitmapDescriptor()) {

        return FALSE;

    }

    if (!ReadFileSetDescriptor()) {

        return FALSE;

    }

    return Result;
}

ULONG
UDF_LVOL::QuerySectorSize() CONST
{
    return _UdfSA->QuerySectorSize();
}

BOOL
UDF_LVOL::Read
(
    IN  ULONG       StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
)
{
    ULONGLONG AbsoluteSectorNum = TranslateBlockNum( StartingSector, 0 );
    return _UdfSA->Read( AbsoluteSectorNum, NumberOfSectors, Buffer );
}

BOOL
UDF_LVOL::Write
(
    IN  ULONG       StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
)
{
    ULONGLONG AbsoluteSectorNum = TranslateBlockNum( StartingSector, 0 );
    return _UdfSA->Write( AbsoluteSectorNum, NumberOfSectors, Buffer );
}

ULONGLONG
UDF_LVOL::TranslateBlockNum
(
    ULONG       Lbn,
    USHORT      Partition
)
{
    UINT PhysicalBlockAddress = Lbn;

    PPARTMAP_GENERIC CurrentPartMapHeader = (PPARTMAP_GENERIC)( &_LogicalVolumeDescriptor->MapTable );
    ULONG CurrentPartMapNum = 0;

    while ( CurrentPartMapNum < _LogicalVolumeDescriptor->MapTableCount ) {

        if ( CurrentPartMapNum == Partition ) {

            if ( CurrentPartMapHeader->Type == PARTMAP_TYPE_PHYSICAL ) {

                PPARTMAP_PHYSICAL PartMapPhysical = (PPARTMAP_PHYSICAL) CurrentPartMapHeader;

                if ( _PartitionDescriptor->Number == PartMapPhysical->Partition ) {

                    PhysicalBlockAddress += _PartitionDescriptor->Start;
                    break;
                }

            }

        }

        CurrentPartMapNum++;
        CurrentPartMapHeader = (PPARTMAP_GENERIC)( (LPBYTE)( CurrentPartMapHeader ) + CurrentPartMapHeader->Length );

    }

    return PhysicalBlockAddress;
}

BOOL
UDF_LVOL::ReadFileSetDescriptor()
{
    BOOL result = TRUE;

    PLONGAD FSDExtent = &_LogicalVolumeDescriptor->FSD;
    ULONG   BlocksToRead = RoundUp( FSDExtent->Length.Length, QuerySectorSize() );

    ULONGLONG ExtentPosition = TranslateBlockNum( FSDExtent->Start.Lbn, FSDExtent->Start.Partition  );

    SECTORCOUNT FSDBlockSize = 0;

    while (result && (FSDBlockSize < BlocksToRead)) {

        UINT    BlocksInThisDescriptor = 0;
        LPBYTE  Descriptor = NULL;
        USHORT  tagId = 0;

        result = _UdfSA->ReadDescriptor( ExtentPosition, &BlocksInThisDescriptor, DESTAG_ID_NOTSPEC, &tagId, &Descriptor );
        if (result) {

            switch (tagId) {

                case DESTAG_ID_NSR_FSD: {

                    _FileSetDescriptor = (PNSR_FSD) Descriptor;

                    FSDBlockSize += BlocksInThisDescriptor;
                    ExtentPosition += BlocksInThisDescriptor;

                    ASSERTMSG( "Only a single FSD should be present.",
                        (_FileSetDescriptor)->NextExtent.Length.Length == 0 );
                    break;

                }

                case DESTAG_ID_NSR_TERM: {

                    free( Descriptor );

                    FSDBlockSize += BlocksInThisDescriptor;
                    ExtentPosition += BlocksInThisDescriptor;
                    break;

                 }

                default: {

                    result = false;
                    break;

                }

            }

        }

    }

    if (result) {

        if (_FileSetDescriptor != NULL) {

            //  The File Set Descriptor is in the partition, so if it's ok, mark the space as used.
            //
            result = MarkBlocksUsed( FSDExtent->Start.Lbn, FSDBlockSize );

        } else {

            result = FALSE;

        }

    } else {

        if ((_FileSetDescriptor) != NULL) {
    
            free( _FileSetDescriptor );
            _FileSetDescriptor = NULL;

        }

    }

    return result;
}

BOOL
UDF_LVOL::ReadSpaceBitmapDescriptor()
{
    BOOL Result = TRUE;

    NSR_PART_H* phd = (NSR_PART_H*) &_PartitionDescriptor->ContentsUse;

    ASSERTMSG( "Unallocated Space Table unsupported", phd->UASTable.Length.Length == 0 );
    ASSERTMSG( "Freed Space Table unsupported", phd->FreedTable.Length.Length == 0 );
    ASSERTMSG( "Freed Bitmap unsupported", phd->FreedBitmap.Length.Length == 0 );

    if (phd->UASBitmap.Length.Length != 0) {

        ULONGLONG   ExtentPosition = TranslateBlockNum( phd->UASBitmap.Start, 0 );
        UINT        BlocksRead = 0;
        USHORT      TagId;

        Result = _UdfSA->ReadDescriptor( ExtentPosition, &BlocksRead, DESTAG_ID_NSR_SBP, &TagId, (LPBYTE*) &_SpaceBitmapDescriptor );
        if (Result) {

            if (_SpaceBitmapDescriptor->BitCount != _PartitionDescriptor->Length) {

                DbgPrint( "Space Bitmap Descriptor Error: Inconsistent Space Bitmap NumberOfBits and partition size: %lu, %lu.\n",
                    _SpaceBitmapDescriptor->BitCount, _PartitionDescriptor->Length );

                Result = FALSE;

            }

            if (Result) {

                //  The Space Bitmap Descriptor is in the partition, so if it's ok, mark the space as used.
                //
                Result = MarkBlocksUsed( phd->UASBitmap.Start, BlocksRead );

            } else {

                free( _SpaceBitmapDescriptor );
                _SpaceBitmapDescriptor = NULL;

            }

        }

    }

    return Result;
}

BOOL
UDF_LVOL::MarkBlocksUsed
(
    IN  ULONGLONG   StartingSector,
    IN  SECTORCOUNT NumberOfSectors
)
{
    BOOL Result = TRUE;

#if DBG
    static int  BreakOnSector = 0;
    static BOOL BreakOnSectorEnabled = FALSE;

    if (BreakOnSectorEnabled) {

        if ((BreakOnSector >= StartingSector) && (BreakOnSector < (StartingSector + NumberOfSectors)) ) {

            DebugBreak();

        }
    }
#endif DBG

    for ( ULONGLONG BlockNum = StartingSector; BlockNum < (StartingSector + NumberOfSectors); BlockNum++ ) {

        ASSERTMSG( "Cross linked clusters detected",
            (_NewSpaceBitmapDescriptor->Bits[ (BlockNum / CHAR_BIT) ] & (1 << (BlockNum % CHAR_BIT))) != 0 );

        _NewSpaceBitmapDescriptor->Bits[ (BlockNum / CHAR_BIT) ] &= ~(1 << (BlockNum % CHAR_BIT));

    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\uudf\src\uudf.cxx ===
/*++

Copyright (c) 1991-2000 Microsoft Corporation

Module Name:

        uudf.cxx

Abstract:

        This module contains run-time, global support for the
        UDF IFS Utilities library (UUDF).  This support includes:

                - creation of CLASS_DESCRIPTORs
                - Global objects

Author:

        Centis Biks (cbiks) 08-May-2000
        
Environment:

        User Mode

Notes:

--*/

#include <pch.cxx>

STATIC
BOOLEAN
DefineClassDescriptors(
    )
{
    return TRUE;
}

STATIC
BOOLEAN
UndefineClassDescriptors(
        )
{
    return TRUE;
}

extern "C"
BOOLEAN
InitializeUUDF (
    IN PVOID DllHandle,
    IN ULONG Reason,
    IN PCONTEXT Context
        )
/*++

Routine Description:

        Initialize Uudf by constructing and initializing all
        global objects. These include:

                - all CLASS_DESCRIPTORs (class_cd)

Arguments:

        None.

Return Value:

        BOOLEAN - Returns TRUE if all global objects were succesfully constructed
                and initialized.

--*/

{
    UNREFERENCED_PARAMETER( DllHandle );
    UNREFERENCED_PARAMETER( Context );

#ifdef _AUTOCHECK_

    UNREFERENCED_PARAMETER( Reason );

    if (!DefineClassDescriptors()) {
        UndefineClassDescriptors();
        DebugAbort( "UUDF initialization failed!!!\n" );
        return( FALSE );
    }

#if defined(TRACE_UUDF_MEM_LEAK)
    DebugPrint("UUDF.DLL got attached.\n");
#endif

#else // _AUTOCHECK_ not defined

    STATIC ULONG    count = 0;

    switch (Reason) {
        case DLL_PROCESS_ATTACH:
#if 0
            //
            // Get translated boot messages into FAT boot code.
            //
            if(!PatchNtfsBootCodeMessages()) {
                //
                // Internal error only, don't worry about translating it.
                //
                MessageBoxA(
                    NULL,
                    "Internal error: Translated boot messages are too long or missing.",
                    "ULIB.DLL (UNTFS.DLL)",
                    MB_ICONERROR | MB_SYSTEMMODAL | MB_OK
                    );

                DebugAbort("Internal error: translated messages for boot code are missing or too long!!!\n");
                return(FALSE);
            }
            #endif

            // Success, FALL THROUGH to thread attach case

        case DLL_THREAD_ATTACH:

            if (count > 0) {
                ++count;
#if defined(TRACE_UNTFS_MEM_LEAK)
                DebugPrintTrace(("UNTFS.DLL got attached %d times.\n", count));
#endif
                return TRUE;
            }

            if (!DefineClassDescriptors()) {
                UndefineClassDescriptors();
                DebugAbort( "Untfs initialization failed!!!\n" );
                return( FALSE );
            }

#if defined(TRACE_UNTFS_MEM_LEAK)
            DebugPrint("UNTFS.DLL got attached.\n");
#endif

            count++;
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:

            if (count > 1) {
                --count;
#if defined(TRACE_UNTFS_MEM_LEAK)
                DebugPrintTrace(("UNTFS.DLL got detached.  %d time(s) left.\n", count));
#endif
                return TRUE;
            }
            if (count == 1) {

#if defined(TRACE_UNTFS_MEM_LEAK)
                DebugPrint("UNTFS.DLL got detached.\n");
#endif

                UndefineClassDescriptors();
                count--;
            } else {
#if defined(TRACE_UNTFS_MEM_LEAK)
                DebugPrint("UNTFS.DLL detached more than attached\n");
#endif
            }
            break;
    }
#endif // _AUTOCHECK_

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\uudf\src\udfvol.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    udfvol.cxx

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>

#include "message.hxx"
#include "rtmsg.h"
#include "wstring.hxx"


DEFINE_CONSTRUCTOR( UDF_VOL, VOL_LIODPDRV );

VOID
UDF_VOL::Construct (
    )

/*++

Routine Description:

    Constructor for UDF_VOL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // unreferenced parameters
    (void)(this);
}

VOID
UDF_VOL::Destroy(
    )
/*++

Routine Description:

    This routine returns a NTFS_VOL object to its initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
    // unreferenced parameters
    (void)(this);
}

UUDF_EXPORT
UDF_VOL::~UDF_VOL(
    )
/*++

Routine Description:

    Destructor for UDF_VOL.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}


UUDF_EXPORT
FORMAT_ERROR_CODE
UDF_VOL::Initialize(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      USHORT      FormatUDFRevision
    )
/*++

Routine Description:

    This routine initializes a UDF_VOL object.

Arguments:

    NtDriveName         - Supplies the drive path for the volume.
    Message             - Supplies an outlet for messages.
    ExclusiveWrite      - Supplies whether or not the drive should be
                          opened for exclusive write.
    FormatUDFVersion    - Version of UDF to format this disk with.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    MESSAGE             msg;
    FORMAT_ERROR_CODE   errcode;

    Destroy();

    errcode = VOL_LIODPDRV::Initialize(NtDriveName, &_UdfSa, Message,
                                       ExclusiveWrite, FALSE,
                                       RemovableMedia);

    if (errcode != NoError) {
        Destroy();
        return errcode;
    }


    if (!Message) {
        Message = &msg;
    }


    if (!_UdfSa.Initialize(this, Message, FormatUDFRevision)) {
        Destroy();
        Message->Set(MSG_CHK_NO_MEMORY);
        Message->Display("");
        return GeneralError;
    }

    return NoError;
}

PVOL_LIODPDRV
UDF_VOL::QueryDupVolume(
    IN      PCWSTRING   NtDriveName,
    IN OUT  PMESSAGE    Message,
    IN      BOOLEAN     ExclusiveWrite,
    IN      BOOLEAN     FormatMedia,
    IN      MEDIA_TYPE  MediaType
    ) CONST
/*++

Routine Description:

    This routine allocates a UDF_VOL and initializes it to 'NtDriveName'.

Arguments:

    NtDriveName     - Supplies the drive path for the volume.
    Message         - Supplies an outlet for messages.
    ExclusiveWrite  - Supplies whether or not the drive should be
                        opened for exclusive write.
    FormatMedia     - Supplies whether or not to format the media.
    MediaType       - Supplies the type of media to format to.

Return Value:

    A pointer to a newly allocated NTFS volume.

--*/
{
    PUDF_VOL   vol;

    // unreferenced parameters
    (void)(this);

    if (!(vol = NEW UDF_VOL)) {
        Message ? Message->DisplayMsg(MSG_FMT_NO_MEMORY) : 1;
        return NULL;
    }

    if (!vol->Initialize(NtDriveName, Message, ExclusiveWrite,
                         MediaType)) {
        DELETE(vol);
        return NULL;
    }

    return vol;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\uudf\src\udfsa.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    udfsa.cxx

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include <pch.cxx>


DEFINE_EXPORTED_CONSTRUCTOR( UDF_SA, SUPERAREA, UUDF_EXPORT );

VOID
UDF_SA::Construct (
    )
/*++

Routine Description:

    This routine sets a UDF_SA to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}

VOID
UDF_SA::Destroy(
    )
/*++

Routine Description:

    This routine returns an UDF_SA to a default initial state.

Arguments:

    None.

Return Value:

    None.

--*/
{
}


UUDF_EXPORT
UDF_SA::~UDF_SA(
    )
/*++

Routine Description:

    Destructor for UDF_SA.

Arguments:

    None.

Return Value:

    None.

--*/
{
    Destroy();
}

UUDF_EXPORT
BOOLEAN
UDF_SA::Initialize(
    IN OUT  PLOG_IO_DP_DRIVE    Drive,
    IN OUT  PMESSAGE            Message,
    IN      USHORT              FormatUDFRevision
    )
/*++

Routine Description:

    This routine returns an UDF_SA to a default initial state.

    If the caller needs to format this volume, then this method should
    be called with the Formatted parameter set to FALSE.

Arguments:

    None.

        Drive       - Supplies the drive where the super area resides.
        Message     - Supplies an outlet for messages
        Formatted   - Supplies a boolean which indicates whether or not
                      the volume is formatted.

Return Value:

    None.

--*/
{
    Destroy();

    DebugAssert(Drive);
    DebugAssert(Message);

    _FormatUDFRevision = FormatUDFRevision;

    return SUPERAREA::Initialize( &_hmem, Drive, 1, Message );
}

PARTITION_SYSTEM_ID
UDF_SA::QuerySystemId(
    ) CONST
/*++

Routine Description:

    This routine computes the system ID for the volume.

Arguments:

    None.

Return Value:

    The system ID for the volume.

--*/
{
        //  Unreferenced parameters
        (void)(this);

        return SYSID_IFS;
}

BOOLEAN
UDF_SA::RecoverFile(
    IN      PCWSTRING   FullPathFileName,
    IN OUT  PMESSAGE    Message
    )
/*++

Routine Description:

    This routine recovers a file on the disk.

Arguments:

    FullPathFileName    - Supplies the file name of the file to recover.
    Message             - Supplies an outlet for messages.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    return FALSE;
}

ULONG
UDF_SA::QuerySectorSize() CONST
{
    return _drive->QuerySectorSize();
}

BOOL
UDF_SA::Read
(
    IN  ULONGLONG   StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
)
{
    return _drive->Read( StartingSector, NumberOfSectors, Buffer );
}

BOOL
UDF_SA::Write
(
    IN  ULONGLONG   StartingSector,
    IN  SECTORCOUNT NumberOfSectors,
    OUT PVOID       Buffer
)
{
    return _drive->Write( StartingSector, NumberOfSectors, Buffer );
}

BOOL
UDF_SA::ReadDescriptor
(
    ULONGLONG   blockNr,
    UINT*       pNrBlocksRead,
    USHORT      expectedTagId,
    USHORT*     pTagId,
    LPBYTE*     pMem
)
{
    *pTagId = DESTAG_ID_NOTSPEC;
    *pMem   = NULL;
    *pNrBlocksRead = 0;


    LPBYTE readbuffer = (LPBYTE) malloc( QuerySectorSize() );
    if ( readbuffer == NULL ) {

        return FALSE;

    }

    if (!Read( blockNr, 1, readbuffer )) {

        DbgPrint( "ReadDescriptor(): Error reading logical block %lu\n", blockNr);
        free( readbuffer );
        return FALSE;

    }

    *pNrBlocksRead = 1;

    /* Check unswapped head of descriptor for recognition and
     * determination of descriptor length.
     */
    if (!VerifyDescriptorTag( readbuffer, QuerySectorSize(), expectedTagId, pTagId )) {

        DbgPrint( "\tReadDescriptor: inspect descriptor error\n");
        free(readbuffer);
        return FALSE;

    }

    //  Get the length of the descriptor.
    //
    UINT DescriptorLength;
    if (!GetLengthOfDescriptor( readbuffer, &DescriptorLength )) {

        return FALSE;

    }

    UINT blocksToRead = RoundUp( DescriptorLength, QuerySectorSize() );

    if (blocksToRead != 1) {

        *pMem = readbuffer;     /* save for reallocation */

        readbuffer = (LPBYTE) realloc( readbuffer, blocksToRead * QuerySectorSize() );
        if ( readbuffer == NULL ) {

            free( *pMem );
            *pMem = NULL;
            return FALSE;

        }

        if (!Read( blockNr + 1, blocksToRead - 1, readbuffer + QuerySectorSize() )) {

            DbgPrint( "ReadDescriptor(): Error reading logical block %lu ...\n", blockNr+1);
            free( readbuffer );
            return FALSE;

        }

        *pNrBlocksRead = blocksToRead;
    }

    if (!VerifyDescriptor( readbuffer, blocksToRead * QuerySectorSize(), expectedTagId, pTagId )) {

        DbgPrint( "\tDescriptor error\n");
        free(readbuffer);
        return FALSE;

    }

    *pMem = readbuffer;
    return TRUE;
}

BOOL
UDF_SA::FindVolumeDescriptor
(
    USHORT      TagID,
    LPBYTE*     DescriptorFound
)
{
    return FindVolumeDescriptor( TagID, _NsrAnchor.Main.Lsn, _NsrAnchor.Main.Len, DescriptorFound );
}

BOOL
UDF_SA::FindVolumeDescriptor
(
    USHORT      TagID,
    ULONGLONG   ExtentStart,
    UINT        ExtentLength,
    LPBYTE*     DescriptorFound
)
{
    BOOL Result = FALSE;

    *DescriptorFound = NULL;

    LPBYTE ReadBuffer = (LPBYTE) malloc( QuerySectorSize() );
    if (ReadBuffer != NULL) {

        ULONGLONG CurrentBlock = ExtentStart;
        while ((CurrentBlock < (ExtentStart + ExtentLength)) && (*DescriptorFound == NULL)) {

            Result = Read( CurrentBlock, 1, ReadBuffer );
            if (Result) {

                USHORT TagIDRead;
                Result = VerifyDescriptor( ReadBuffer, QuerySectorSize(), DESTAG_ID_NOTSPEC, &TagIDRead );
                if (Result) {

                    UINT BytesToRead;
                    Result = GetLengthOfDescriptor( ReadBuffer, &BytesToRead );
                    if (Result) {

                        UINT BlocksToRead = RoundUp( BytesToRead, QuerySectorSize() );
                        if (TagIDRead == TagID) {

                            if (BlocksToRead > 1) {

                                ReadBuffer = (LPBYTE) realloc( ReadBuffer, QuerySectorSize() * BlocksToRead );
                                if (ReadBuffer != NULL) {

                                    Result = Read( CurrentBlock, BlocksToRead, ReadBuffer );

                                }

                            }

                            if (Result) {

                                *DescriptorFound = ReadBuffer;

                            }

                        } else {

                            if (TagIDRead == DESTAG_ID_NSR_VDP) {

                                PNSR_VDP VolumeDescriptorPointer = (PNSR_VDP) ReadBuffer;

                                DbgPrint( "Next VDS extent: %7lu, length: %6lu\n",
                                    VolumeDescriptorPointer->Next.Lsn, VolumeDescriptorPointer->Next.Len );

                                Result = FindVolumeDescriptor( TagID, VolumeDescriptorPointer->Next.Lsn, VolumeDescriptorPointer->Next.Len,
                                    DescriptorFound );

                            }

                            CurrentBlock += BlocksToRead;

                        }

                    }

                }

            }

        }

    }

    return Result;
}


VOID
UDF_SA::PrintFormatReport (
    IN OUT PMESSAGE                             Message,
    IN     PFILE_FS_SIZE_INFORMATION            FsSizeInfo,
    IN     PFILE_FS_VOLUME_INFORMATION          FsVolInfo
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\uudf\src\verifysbdallocation.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    VerifySBDAllocation.cxx

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"

#include "UdfLVol.hxx"

#include "unicode.hxx"
#include "crc.hxx"

//  UNDONE, CBiks, 08/15/2000
//      Put this in udf.h with a more sensible name.
//

const UCHAR DeveloperID[] = { 'M', 'i', 'c', 'r', 'o', 's', 'o', 'f', 't', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' };

BOOL
UDF_LVOL::FindAvailableSector
(
	PNSR_SBD    SBDOriginal,
	PNSR_SBD    SBDNew,
    PULONG      SectorAvailable
)
{
	BOOL    Result = FALSE;

    ULONG   Offset = 0;
    UCHAR   BitNum = 0x01;
    ULONG   Sector = 0;
    while (Sector < SBDNew->BitCount) {

        if (((SBDOriginal->Bits[ Offset ] & BitNum) != 0) && ((SBDNew->Bits[ Offset ] & BitNum) != 0)) {

            SBDNew->Bits[ Offset ] |= BitNum;
            *SectorAvailable = Sector;
            Result = TRUE;
            break;

        }

        BitNum <<= 1;
        if (BitNum == 0) {

            Offset += 1;
            BitNum = 1;

        }

        Sector += 1;

    }

    return Result;
}

BOOL
UDF_LVOL::CreateFID
(
    PICBFILE    IcbDirectoryParent,
    PICBEXTFILE IcbFile,
    PCWSTR      FileName,
    PNSR_FID*   NewNsrFID,
    ULONG       StartLbn,
    USHORT      StartPartition,
    ULONG       Length
)
{
	BOOL Result = TRUE;
    UCHAR AdType = IcbDirectoryParent->Icbtag.Flags & ICBTAG_F_ALLOC_MASK;

    //  The size of the FID is the actual constant size + one for the Compression ID of the file name
    //  plus the size of the file name in bytes rounded to the nearest 4 byte boundary.
    //
    ULONG FIDSize = LongAlign( sizeof( NSR_FID) + sizeof( UCHAR ) + (wcslen( FileName ) * sizeof( WCHAR )) );

    //  Sanity check the calculated length.
    //
    ASSERT( LOWORD( FIDSize ) == FIDSize );

    switch (AdType) {

        case ICBTAG_F_ALLOC_SHORT: {

            ASSERTMSG( "UNDONE, CBiks, 8/14/2000: Unimplemented FindAvailableFID() - ICBTAG_F_ALLOC_SHORT", 0 );
            break;

        }

        case ICBTAG_F_ALLOC_LONG: {

            ASSERTMSG( "UNDONE, CBiks, 8/14/2000: Unimplemented FindAvailableFID() - ICBTAG_F_ALLOC_LONG", 0 );
            break;

        }

        case ICBTAG_F_ALLOC_EXTENDED: {

            ASSERTMSG( "UNDONE, CBiks, 8/14/2000: Unimplemented FindAvailableFID() - ICBTAG_F_ALLOC_EXTENDED", 0 );
            break;

        }

        case ICBTAG_F_ALLOC_IMMEDIATE: {

            ULONG       AllocDescOffset = FeEasFieldOffset( IcbDirectoryParent ) + FeEaLength( IcbDirectoryParent );
            ULONG       AllocationDescriptorEnd = AllocDescOffset + FeAllocLength( IcbDirectoryParent );
            //PNSR_FID    NsrFid = (PNSR_FID)( (LPBYTE)( IcbDirectoryParent ) + AllocDescOffset );

            BOOL        FIDFound = FALSE;

            PNSR_FID    FreeNsrFid = NULL;
            ULONG       FreeFIDSector = 0;
            ULONG       FreeFIDOffset = 0;

            while (Result && (AllocDescOffset < AllocationDescriptorEnd)) {

                PNSR_FID NsrFid = (PNSR_FID)( (LPBYTE)( IcbDirectoryParent ) + AllocDescOffset );
                
                ASSERTMSG( "CreateFID(): Bogus FID in the FE.",
                    VerifyDescriptor( (LPBYTE) NsrFid, AllocationDescriptorEnd - AllocDescOffset, DESTAG_ID_NSR_FID, NULL ) );
                
                if (NsrFid->Flags & NSR_FID_F_DELETED) {

                    if (Result && (ISONsrFidSize( NsrFid ) >= FIDSize)) {

                        FreeNsrFid = NsrFid;
                        FreeFIDSector = IcbDirectoryParent->Destag.Lbn;
                        FreeFIDOffset = AllocDescOffset;

                        FIDFound = TRUE;
                        break;


                    }

                }

                AllocDescOffset += ISONsrFidSize( NsrFid );

            }

            if (!FIDFound) {

                if ((AllocDescOffset + FIDSize) < QuerySectorSize()) {

                    FreeNsrFid = (PNSR_FID)( (LPBYTE)( IcbDirectoryParent ) + AllocDescOffset );
                    FreeFIDSector = IcbDirectoryParent->Destag.Lbn;
                    FreeFIDOffset = AllocDescOffset;

                    FIDFound = TRUE;

                }

            }

            if (FIDFound) {

                FreeNsrFid->Destag.Ident = DESTAG_ID_NSR_FID;
                FreeNsrFid->Destag.Version = DESTAG_VER_NSR03;
                FreeNsrFid->Destag.Res5 = 0;
                FreeNsrFid->Destag.Serial = 0;
                FreeNsrFid->Destag.Lbn = FreeFIDSector;

                FreeNsrFid->Version = 1;
                FreeNsrFid->Flags = 0;

                FreeNsrFid->Icb.Length.Length =   Length;
                FreeNsrFid->Icb.Length.Type =     NSRLENGTH_TYPE_RECORDED;
                FreeNsrFid->Icb.Start.Lbn =       StartLbn;
                FreeNsrFid->Icb.Start.Partition = StartPartition;
                
                FreeNsrFid->Icb.ImpUse[6];
                FreeNsrFid->ImpUseLen = 0;

                //
                //  Put the unicode file name in the FID.  The name follows NSR_FID data structure after the implementation
                //  use bytes.
                //
                
                FreeNsrFid->FileIDLen = (UCHAR) CompressUnicode( FileName, wcslen( FileName ),
                    ((LPBYTE) FreeNsrFid) + sizeof( NSR_FID) + FreeNsrFid->ImpUseLen );

                ASSERTMSG( "CreateFID(): FID size calculation is wrong.\n",
                    FIDSize == LongAlign( sizeof( NSR_FID)  + FreeNsrFid->FileIDLen ) );

                //  Generate and store the CRC of the FID section.
                //
                FreeNsrFid->Destag.CRCLen = (USHORT)( FIDSize ) - sizeof( DESTAG );
                FreeNsrFid->Destag.CRC = CalculateCrc( (LPBYTE)( FreeNsrFid ) + sizeof( DESTAG ), FreeNsrFid->Destag.CRCLen );

                //  Finally, generate and store the checksum of the DESTAG.
                //
                FreeNsrFid->Destag.Checksum = CalculateTagChecksum( &FreeNsrFid->Destag );

#if DBG
                //
                //  Do some sanity checking on the FID to make sure it's ok.
                //
                
                UINT DebugDescriptorLength;
                BOOL DebugResult = GetLengthOfDescriptor( (LPBYTE) FreeNsrFid, &DebugDescriptorLength );
                ASSERTMSG( "Bad FID descriptor length calculation",
                     DebugResult && (DebugDescriptorLength == FIDSize) );

                ASSERTMSG( "CreateFID(): The NSR_FID created is not valid.",
                    VerifyDescriptor( (LPBYTE) FreeNsrFid, FIDSize, DESTAG_ID_NSR_FID, NULL ) );
#endif
                
                *NewNsrFID = FreeNsrFid;

                //
                //  Add the size of the new FID to the ICB's allocation descriptor length.
                //
                
                FeAllocLength( IcbDirectoryParent ) = FeAllocLength( IcbDirectoryParent ) + ISONsrFidSize( FreeNsrFid );

#if DBG
                //
                //  Do some debug sanity checking if the Root Directories FileEntry, just to make sure we get everything
                //  right.
                //
                
                DebugResult = GetLengthOfDescriptor( (LPBYTE) IcbDirectoryParent, &DebugDescriptorLength );

                ASSERTMSG( "GetLengthOfDescriptor() on updated Root Directory FileEntry failed.",
                     DebugResult );
                
                ASSERTMSG( "Updated FileEntry descriptor body length does not make sense.",
                    IcbDirectoryParent->Destag.CRCLen + ISONsrFidSize( FreeNsrFid ) == DebugDescriptorLength - sizeof( DESTAG ) );
#endif

                //
                //  Update the file size.  In the case of a directory this the size of the FIDs.
                //
                
                IcbDirectoryParent->InfoLength += (USHORT)( ISONsrFidSize( FreeNsrFid ) );

                //
                //  Extended File Entries also track the size of all streams, so we have to update that too.
                //
                
                if (FeIsExtended( IcbDirectoryParent )) {
                    ((PICBEXTFILE) IcbDirectoryParent)->ObjectSize += (USHORT)( ISONsrFidSize( FreeNsrFid ) );
                }
                
                //
                //  We're done updating the the parent directories (Extended) File Entry, so we can now update the CRC vaules.
                //

                IcbDirectoryParent->Destag.CRCLen += (USHORT)( ISONsrFidSize( FreeNsrFid ) );
                IcbDirectoryParent->Destag.CRC = CalculateCrc( (LPBYTE)( IcbDirectoryParent ) + sizeof( DESTAG ),
                    IcbDirectoryParent->Destag.CRCLen );
                IcbDirectoryParent->Destag.Checksum = CalculateTagChecksum( &IcbDirectoryParent->Destag );

#if DBG
                //
                //  Do some sanity checks on the update root directory Fille Entry.
                //
                
                ASSERTMSG( "CreateFID(): The File Entry updated is not valid.",
                    VerifyDescriptor( (LPBYTE) IcbDirectoryParent, QuerySectorSize(), IcbDirectoryParent->Destag.Ident, NULL ) );
#endif

                Result = Write( IcbDirectoryParent->Destag.Lbn, 1, (LPBYTE) IcbDirectoryParent );

            } else {

                ASSERTMSG( "UNDONE, CBiks, 8/14/2000: Implement code to convert ICBTAG_F_ALLOC_IMMEDIATE into ICBTAG_F_ALLOC_SHORT\n", 0 );

            }


            break;
        }

        default: {

            ASSERTMSG( "Invalid Allocation Descriptor Type", 0 );
            break;

        }

    }

    return Result;
}

BOOL
UDF_LVOL::CreateICBFileEntry
(
    PICBEXTFILE*    NewICBCheckFile,
    ULONG           StartSector,
    ULONG           EndSector,
	PNSR_SBD        SBDOriginal,
	PNSR_SBD        SBDNew
)
{
	BOOL Result = TRUE;

    USHORT ICBCheckFileSize = sizeof( ICBEXTFILE) + sizeof( SHORTAD );
    PICBEXTFILE ICBCheckFile = (PICBEXTFILE) calloc( 1, QuerySectorSize() );
    if (ICBCheckFile != NULL) {

        ULONG ICBSector;
        Result = FindAvailableSector( SBDOriginal, SBDNew, &ICBSector );
        if (Result) {

            ICBCheckFile->Destag.Ident =                DESTAG_ID_NSR_EXT_FILE;
            ICBCheckFile->Destag.Version =              DESTAG_VER_NSR03;
            ICBCheckFile->Destag.Res5 =                 0;
            ICBCheckFile->Destag.Serial =               0;
            ICBCheckFile->Destag.Lbn =                  ICBSector;

            //  Setup the ICBTag for Strategy 4 and SHORTAD's.
            //
            ICBCheckFile->Icbtag.StratType =            ICBTAG_STRAT_DIRECT;
            ICBCheckFile->Icbtag.FileType =             ICBTAG_FILE_T_FILE;
            ICBCheckFile->Icbtag.Flags =                ICBTAG_F_ALLOC_SHORT;
            ICBCheckFile->Icbtag.MaxEntries =           1;
            ICBCheckFile->Icbtag.PriorDirectCount =     0;
            ICBCheckFile->Icbtag.StratParm =            0;
            ICBCheckFile->Icbtag.Res10 =                0;
            ICBCheckFile->Icbtag.IcbParent.Lbn =        0;
            ICBCheckFile->Icbtag.IcbParent.Partition =  0;

            //  UDF 14.9.3 says OS's that do not have User/Group ID's should use arbitrary non-zero numbers.  Most of the disks I've seen have
            //  0xffffffff in these fields, so that's good enough for me.
            //
            ICBCheckFile->UID =                         0xffffffff;
            ICBCheckFile->GID =                         0xffffffff;

            //  Allow everyone to Read, Write, Set Attributes and Delete the .CHK file.
            //
            ICBCheckFile->Permissions = (ICBFILE_PERM_OTH_W | ICBFILE_PERM_OTH_R | ICBFILE_PERM_OTH_A | ICBFILE_PERM_OTH_D) |
                                        (ICBFILE_PERM_GRP_W | ICBFILE_PERM_GRP_R | ICBFILE_PERM_GRP_A | ICBFILE_PERM_GRP_D) |
                                        (ICBFILE_PERM_OWN_W | ICBFILE_PERM_OWN_R | ICBFILE_PERM_OWN_A | ICBFILE_PERM_OWN_D);

            //  There will only be a single FID attached to this File Entry.
            //
            ICBCheckFile->LinkCount =                   1;


            //  UDF 2.3.6 says these should all be zero.
            //
            ICBCheckFile->RecordFormat =                0;
            ICBCheckFile->RecordDisplay =               0;
            ICBCheckFile->RecordLength =                0;
            ICBCheckFile->BlocksRecorded =              0;

            //  Set the size if the file, and the size of all streams.
            //
            ICBCheckFile->InfoLength =                  (EndSector - StartSector) * QuerySectorSize();
            ICBCheckFile->ObjectSize =                  ICBCheckFile->InfoLength;

            //  ICBCheckFile->AccessTime;                TIMESTAMP   Last-Accessed Time
            //  ICBCheckFile->ModifyTime;                TIMESTAMP   Last-Modification Time
            //  ICBCheckFile->CreationTime;              TIMESTAMP   Creation Time
            //  ICBCheckFile->AttributeTime;             TIMESTAMP   Last-Attribute-Change Time

            //  UDF 14.9.15 This field shall contain 1 for the first instance of a file...
            //
            ICBCheckFile->Checkpoint =                  1;

            //  Set the unused field to zero to be nice.
            //
            ICBCheckFile->Reserved =                    0;

            //  No Extended attributes.
            //
            memset( &ICBCheckFile->IcbEA, '\0', sizeof( LONGAD ) );


            //  No Streams.
            //
            memset( &ICBCheckFile->IcbStream, '\0', sizeof( LONGAD ) );

            //
            PREGID RegID = &ICBCheckFile->ImpUseID;
            RegID->Flags = 0;

            ASSERT( sizeof( DeveloperID ) == sizeof( RegID->Identifier ) );
            memcpy( RegID->Identifier, DeveloperID, sizeof( RegID->Identifier ) );

            PUDF_SUFFIX_IMPLEMENTATION SuffixImplementation = (PUDF_SUFFIX_IMPLEMENTATION) &RegID->Suffix;
            SuffixImplementation->OSClass = OSCLASS_WINNT;
            SuffixImplementation->OSIdentifier = OSIDENTIFIED_WINNT_WINNT;
            memset( &SuffixImplementation->ImplementationUse, '\0', sizeof( SuffixImplementation->ImplementationUse ) );

            //  UNDONE, CBiks, 08/15/2000
            //      Set the Unique ID according to UDF 3.2.1.1 for Mac OS support.
            //
            ICBCheckFile->UniqueID = 0;

            //  No extended attributes for this file.
            //
            ICBCheckFile->EALength = 0;

            //  Create the single Allocation Descriptor pointing to the lost clusters.
            //
            ICBCheckFile->AllocLength = sizeof( SHORTAD );

            PSHORTAD AllocationDescriptors = (PSHORTAD)( (LPBYTE)( ICBCheckFile ) + sizeof( ICBEXTFILE) );
            AllocationDescriptors->Start = StartSector;
            AllocationDescriptors->Length.Length = ICBCheckFile->InfoLength;
            AllocationDescriptors->Length.Type = NSRLENGTH_TYPE_RECORDED;

            //  Generate and store the CRC of the Extended File Entry section.
            //
            ICBCheckFile->Destag.CRCLen = ICBCheckFileSize - sizeof( DESTAG );
            ICBCheckFile->Destag.CRC = CalculateCrc( (LPBYTE)( ICBCheckFile ) + sizeof( DESTAG ), ICBCheckFile->Destag.CRCLen );

            //
            //  Finally, generate and store the checksum of the DESTAG.
            //
            
            ICBCheckFile->Destag.Checksum = CalculateTagChecksum( &ICBCheckFile->Destag );

#if DBG
            UINT DebugDescriptorLength;
            BOOL DebugResult = GetLengthOfDescriptor( (LPBYTE) ICBCheckFile, &DebugDescriptorLength );
            ASSERTMSG( "Bad descriptor length calculation",
                 DebugResult && (DebugDescriptorLength == ICBCheckFileSize) );

            ASSERTMSG( "CreateLostClusterFile(): The ICBEXTFILE created is not valid.",
                VerifyDescriptor( (LPBYTE) ICBCheckFile, ICBCheckFileSize, DESTAG_ID_NSR_EXT_FILE, NULL ) );
#endif

            *NewICBCheckFile = ICBCheckFile;

        }

    } else {

        Result = FALSE;

    }

    return Result;
}

BOOL
UDF_LVOL::CreateLostClusterFile
(
    ULONG       StartSector,
    ULONG       EndSector,
	PNSR_SBD    SBDOriginal,
	PNSR_SBD    SBDNew
)
{
	BOOL Result = TRUE;

    static ULONG CheckFileNum = 0;

    WCHAR FileName[ MAX_PATH ];
    wsprintf( FileName, L"FILE%04d.CHK", CheckFileNum );

    DbgPrint( "Creating file %S for lost clusters: Partition sector = %i thru %i, Physical sector = %I64i thru %I64i\n",
        FileName,
        StartSector, EndSector,
        TranslateBlockNum( StartSector, 0 ), TranslateBlockNum( EndSector, 0 ) );

    PICBEXTFILE ICBCheckFile;
    Result = CreateICBFileEntry( &ICBCheckFile, StartSector, EndSector, SBDOriginal, SBDNew );
    if (Result) {

        Result = Write( ICBCheckFile->Destag.Lbn, 1, (LPBYTE) ICBCheckFile );
        if (Result) {
            PNSR_FID NsrFID;
            Result = CreateFID( _RootIcbFileEntry, ICBCheckFile, FileName, &NsrFID,
                ICBCheckFile->Destag.Lbn, 0, QuerySectorSize() );
            if (Result) {

            }

        }

    }

    CheckFileNum++;

    return Result;
}

BOOL
UDF_LVOL::VerifySBDAllocation
(
	PNSR_SBD    SBDOriginal,
	PNSR_SBD    SBDNew
)
{
	BOOL Result = TRUE;

    DbgPrint( "VerifySBDAllocation(): entry\n" );

    if (SBDOriginal->ByteCount != SBDNew->ByteCount) {

        DbgPrint( "\tByte counts don't match: Original = %x, New = %x\n",
            SBDOriginal->ByteCount, SBDNew->ByteCount );

    } else if (SBDOriginal->BitCount!= SBDNew->BitCount) {

        DbgPrint( "\tBit counts don't match: Original = %x, New = %x\n",
            SBDOriginal->BitCount, SBDNew->BitCount );

    } else {

        ULONG   Offset = 0;
        UCHAR   BitNum = 0x01;
        ULONG   Sector = 0;

        while (Sector < SBDNew->BitCount) {

            //  If the sectors were allocated in the original SB and not in the new one then we try to create
            //  FILE????.CHK entries for the lost clusters.
            //

            if (((SBDOriginal->Bits[ Offset ] & BitNum) == 0) && ((SBDNew->Bits[ Offset ] & BitNum) != 0)) {

                ULONG StartSector = Sector;
                ULONG EndSector = Sector;
                while (Sector < SBDNew->BitCount) {

                    if (((SBDOriginal->Bits[ Offset ] & BitNum) == 0) && ((SBDNew->Bits[ Offset ] & BitNum) != 0)) {

                        EndSector = Sector;

                    } else {

                        break;

                    }

                    BitNum <<= 1;
                    if (BitNum == 0) {

                        Offset += 1;
                        BitNum = 1;

                    }

                    Sector += 1;
                }

                Result = CreateLostClusterFile( StartSector, EndSector, SBDOriginal, SBDNew );

            }


            BitNum <<= 1;
            if (BitNum == 0) {

                Offset += 1;
                BitNum = 1;

            }

            Sector += 1;

        }

    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\wintools\clb\clb.c ===
/*++

Copyright (c) 1993-2000  Microsoft Corporation

Module Name:

    Clb.c

Abstract:

    This file contains support for the ColumnListBox (clb.dll) custom control.

Author:

    David J. Gilman (davegi) 05-Feb-1993

Environment:

    User Mode

--*/

#include "clb.h"

#include <commctrl.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>          // _tcstok routines...

#include <strsafe.h>

//
// Clb's module handle.
//

HINSTANCE
_hModule;

//
// Child IDs for the header and listbox controls.
//

#define ID_HEADER           ( 0x1234 )
#define ID_LISTBOX          ( 0xABCD )


//
// Separator used to parse headings.
//

#define HEADING_SEPARATOR   L";"

//
// Valid styles for each part of the Clb.
//

#define CLBS_CLB                (                                           \
                                      0                                     \
                                    | CLBS_BORDER                           \
                                    | LBS_OWNERDRAWFIXED                    \
                                    | WS_VISIBLE                            \
                                    | WS_DISABLED                           \
                                    | WS_GROUP                              \
                                    | WS_TABSTOP                            \
                                    | WS_CHILD                              \
                                )

#define CLBS_HEADER             (                                           \
                                      0                                     \
                                    | WS_VISIBLE                            \
                                    | CLBS_POPOUT_HEADINGS                  \
                                    | CLBS_SPRINGY_COLUMNS                  \
                                )

#define CLBS_LIST_BOX           (                                           \
                                      0                                     \
                                    | WS_VISIBLE                            \
                                    | CLBS_NOTIFY                           \
                                    | CLBS_SORT                             \
                                    | CLBS_DISABLENOSCROLL                  \
                                    | CLBS_VSCROLL                          \
                                )




//
// Window procedure for the CLB.
//

LRESULT
ClbWndProc(
          IN HWND hWnd,
          IN UINT message,
          IN WPARAM wParam,
          IN LPARAM lParam
          );

//
// Per CLB window information.
//
//      hWndHeader      - hWnd for header control.
//      hWndListBox     - hWnd for listbox control.
//      hFontListBox    - hFont for the list box control.
//      HeaderHeight    - height of the header window.
//      Columns         - number of columns in CLB.
//      Headings        - raw (semi-colon separated) column headings.
//      Right           - array of right edge coordinates.
//

typedef
struct
    _CLB_INFO {

    DECLARE_SIGNATURE

    HWND        hWndHeader;
    HWND        hWndListBox;

    HFONT       hFontListBox;
    DWORD       HeaderHeight;
    DWORD       Columns;
    WCHAR       Headings[ MAX_PATH ];
    LPLONG      Right;

}   CLB_INFO, *LPCLB_INFO;


//
// Helper macros to save and restore per Clb window information.
//

#define SaveClbInfo( p )                                                    \
    SetWindowLongPtr( hWnd, 0, ( LONG_PTR )( p ))

#define RestoreClbInfo( h )                                                 \
    ( LPCLB_INFO ) GetWindowLongPtr(( h ), 0 )

//
// Structures to support drawing and ersaing the drag line.
//

typedef
struct
    _LINE_POINTS {

    POINT   Src;
    POINT   Dst;

}   LINE_POINT, *LPLINE_POINT;

typedef
struct
    _DRAW_ERASE_LINE {

    LINE_POINT   Erase;
    LINE_POINT   Draw;

}   DRAW_ERASE_LINE, *LPDRAW_ERASE_LINE;

BOOL
DrawLine(
        IN HDC hDC,
        IN LPDRAW_ERASE_LINE DrawEraseLine
        )

/*++

Routine Description:

    DrawLine draws the Draw line in the supplied DrawEraseLine structure
    and then sets up that line so that EraseLine will erase it.

Arguments:

    hDC             - Supplies a handle to the DC where the line should be
                      drawn.
    DrawEraseLine   - Supplies a pointer to a DRAW_ERASE_LINE structure that
                      conatins the coordinates for the line to be drawn.

Return Value:

    BOOL - Returns TRUE if the line was succesfully drawn.

--*/

{
    BOOL    Success;

    DbgHandleAssert( hDC );
    DbgPointerAssert( DrawEraseLine );

    Success = Polyline( hDC, ( CONST LPPOINT ) &DrawEraseLine->Draw, 2 );
    DbgAssert( Success );

    DrawEraseLine->Erase = DrawEraseLine->Draw;

    return Success;
}

BOOL
EraseLine(
         IN HDC hDC,
         IN LPDRAW_ERASE_LINE DrawEraseLine
         )


/*++

Routine Description:

    EraseLine erasess the Erase line in the supplied DrawEraseLine structure.
    The EraseLine is set by the DrawLine routine.

Arguments:

    hDC             - Supplies a handle to the DC where the line should
                      be erased.
    DrawEraseLine   - Supplies a pointer to a DRAW_ERASE_LINE structure that
                      conatins the coordinates for the line to be erased.

Return Value:

    BOOL            - Returns TRUE if the line was succesfully erased.

--*/

{
    BOOL    Success;

    DbgHandleAssert( hDC );
    DbgPointerAssert( DrawEraseLine );

    Success = Polyline( hDC, ( CONST LPPOINT ) &DrawEraseLine->Erase, 2 );
    DbgAssert( Success );

    return Success;
}

BOOL
RedrawVerticalLine(
                  IN HDC hDC,
                  IN LONG x,
                  IN LPDRAW_ERASE_LINE DrawEraseLine
                  )

/*++

Routine Description:

    RedrawVerticalLine erases the old line and redraws a new one at the
    supplied x position. It is merely a warpper for DrawLine and EraseLine.

Arguments:

    hDC             - Supplies a handle to the DC where the line should
                      be erased.
    x               - Supplies the new x coordinate where the line should
                      be drawn.
    DrawEraseLine   - Supplies a pointer to a DRAW_ERASE_LINE structure that
                      conatins the coordinates for the line to be erased.

Return Value:

    BOOL            - Returns TRUE if the line was succesfully erased.

--*/

{
    BOOL    Success;

    DbgHandleAssert( hDC );
    DbgPointerAssert( DrawEraseLine );


    DrawEraseLine->Draw.Src.x = x;
    DrawEraseLine->Draw.Dst.x = x;

    Success = EraseLine( hDC, DrawEraseLine );
    DbgAssert( Success );

    Success = DrawLine( hDC, DrawEraseLine );
    DbgAssert( Success );

    return Success;
}

BOOL
ClbEntryPoint(
             IN HINSTANCE hInstanceDll,
             IN DWORD Reason,
             IN LPVOID Reserved
             )

/*++

Routine Description:

    This function registers the ColumnListBox class as a global class for
    any process that attaches to clb.dll.

Arguments:

    Standard DLL entry parameters.

Return Value:

    BOOL    - Returns TRUE if the class was succesfully registered.

--*/

{
    BOOL    Success;
    static
    DWORD   AttachedProcesses = 0;

    switch ( Reason ) {

        case DLL_PROCESS_ATTACH:
            {

                WNDCLASS    Wc;

                //
                // If this is the first process attaching to Clb, register the
                // window class.
                //

                if ( AttachedProcesses == 0 ) {

                    //
                    // Remember the module handle.
                    //

                    _hModule = hInstanceDll;


                    //
                    // Make sure that the Common Controls (comctl32.dll) Dll
                    // is loaded.
                    //

                    InitCommonControls( );

                    Wc.style            = CS_GLOBALCLASS | CS_OWNDC;
                    Wc.lpfnWndProc      = ClbWndProc;
                    Wc.cbClsExtra       = 0;
                    Wc.cbWndExtra       = sizeof( LPCLB_INFO );
                    Wc.hInstance        = hInstanceDll;
                    Wc.hIcon            = NULL;
                    Wc.hCursor          = LoadCursor( NULL, IDC_ARROW );
                    Wc.hbrBackground    = NULL;
                    Wc.lpszMenuName     = NULL;
                    Wc.lpszClassName    = CLB_CLASS_NAME;

                    //
                    // If the class couldn't be registered, fail the linkage.
                    //

                    if (!RegisterClass(&Wc))
                    {
                        return FALSE;
                    }
                }

                //
                // Either the class was just succesfully registered or it was
                // registered by a prior process attachment, eother way increment
                // the count of attached processes.
                //

                AttachedProcesses++;

                return TRUE;
            }

        case DLL_PROCESS_DETACH:
            {

                DbgAssert( AttachedProcesses > 0 );

                AttachedProcesses--;

                if ( AttachedProcesses == 0 ) {

                    Success = UnregisterClass( CLB_CLASS_NAME, hInstanceDll );
                    DbgAssert( Success );

                }
                break;
            }
    }

    return TRUE;
}

BOOL
ClbAddData(
          IN HWND hWnd,
          IN int ControlId,
          IN LPCLB_ROW ClbRow
          )

/*++

Routine Description:

    ClbAddData adds a new row of data to the Clb control's List Box.

Arguments:

    hWnd        - Supplies the window handle for the parent window.
    ControlId   - Supplies the control id for this Clb for the supplied hWnd.
    ClbRow      - Supplies a pointer to a CLB_ROW object which contains user
                  define per row data along with an array of CLB_STRINGs.

Return Value:

    BOOL        - Returns TRUE if the data was successfully added.


--*/

{
    LPCLB_INFO      ClbInfo;
    LRESULT         LbErr;
    DWORD           i;
    HWND            hWndClb;
    LPCLB_ROW       TempRow;

    //
    // Validate arguments.
    //

    DbgHandleAssert( hWnd );
    DbgPointerAssert( ClbRow );

    //
    // Retrieve information for this ColumnListBox.
    //

    hWndClb = GetDlgItem( hWnd, ControlId );
    DbgHandleAssert( hWndClb );
    if (hWndClb == NULL)
        return FALSE;
    ClbInfo = RestoreClbInfo( hWndClb );
    DbgPointerAssert( ClbInfo );
    if (ClbInfo == NULL)
        return FALSE;
    DbgAssert( CheckSignature( ClbInfo ));

    //
    // Validate the count of strings.
    //

    DbgAssert( ClbRow->Count == ClbInfo->Columns );

    //
    // Capture the CLB_ROW object.
    //

    TempRow = AllocateObject( CLB_ROW, 1 );
    DbgPointerAssert( TempRow );
    if (TempRow == NULL)
        return FALSE;

    DbgAssert(sizeof(*TempRow) == sizeof(*ClbRow));
    CopyMemory( TempRow, ClbRow, sizeof(CLB_ROW) );

    //
    // Capture the strings.
    //

    TempRow->Strings = AllocateObject( CLB_STRING, ClbInfo->Columns );
    DbgPointerAssert( TempRow->Strings );
    if (TempRow->Strings == NULL)
        return FALSE;

    for ( i = 0; i < ClbInfo->Columns; i++ ) 
    {

        //
        // Copy the header.
        //

        CopyMemory(
                  &TempRow->Strings[ i ],
                  &ClbRow->Strings[ i ],
                  sizeof( CLB_STRING )
                  );

        //
        // Copy the string.
        //

        TempRow->Strings[ i ].String = _wcsdup( ClbRow->Strings[ i ].String );
    }

    //
    // Store the CLB_ROW object in the listbox.
    //

    LbErr = SendMessage(
                       ClbInfo->hWndListBox,
                       LB_ADDSTRING,
                       0,
                       ( LPARAM ) TempRow
                       );
    DbgAssert(( LbErr != LB_ERR ) && ( LbErr != LB_ERRSPACE ));

    return TRUE;
}


BOOL
GetCharMetrics(
    IN HDC hDC,
    IN LPLONG CharWidth,
    IN LPLONG CharHeight
    )

/*++

Routine Description:

    Return the width and height of a character.

Arguments:

    hDC         - Supplies a handle to the DC where the characters are to be
                  displayed.
    CharWidth   - Supplies a pointer where the character width is returned.
    CharHeight  - Supplies a pointer where the character height is returned.

Return Value:

    BOOL        - Returns TRUE if the character height and width are returned.

--*/

{
    BOOL        Success;
    TEXTMETRICW TextMetric;

    DbgHandleAssert( hDC );
    DbgPointerAssert( CharWidth );
    DbgPointerAssert( CharHeight );

    //
    // Attempt to retrieve the text metrics for the supplied DC.
    //

    Success = GetTextMetricsW( hDC, &TextMetric );
    DbgAssert( Success );
    if( Success ) {

        //
        // Compute the character width and height.
        //

        *CharWidth  = TextMetric.tmAveCharWidth;
        *CharHeight = TextMetric.tmHeight
                      + TextMetric.tmExternalLeading;
    }

    return Success;
}

BOOL
ClbSetColumnWidths(
                  IN HWND hWnd,
                  IN int ControlId,
                  IN LPDWORD Widths
                  )

/*++

Routine Description:

    ClbSetColumnWidths sets the width of each column based on the supplied
    widths in characters. Note that the column on the far right extends to
    the edge of the Clb.

Arguments:

    hWnd        - Supplies the window handle for the parent window.
    ControlId   - Supplies the control id for this Clb for the supplied hWnd.
    Widths      - Supplies an array of widths, one less then the number of
                  columns, in characters.

Return Value:

    BOOL        - Returns TRUE if the widths were successfully adjusted.


--*/

{
    BOOL        Success;
    DWORD       Columns;
    LPCLB_INFO  ClbInfo;
    HWND        hWndClb;
    LONG        CharWidth;
    LONG        CharHeight;
    DWORD       i;
    LPLONG      WidthsInPixels;
    LONG        TotalPixels;
    HDC         hDCClientHeader;
    HD_ITEM     hdi;
    UINT        iRight;

    //
    // Validate arguments.
    //

    DbgHandleAssert( hWnd );
    DbgPointerAssert( Widths );

    //
    // Retrieve information for this ColumnListBox.
    //

    hWndClb = GetDlgItem( hWnd, ControlId );
    DbgHandleAssert( hWndClb );
    if (hWndClb == NULL)
        return FALSE;
    ClbInfo = RestoreClbInfo( hWndClb );
    DbgPointerAssert( ClbInfo );
    if (ClbInfo == NULL)
        return FALSE;
    DbgAssert( CheckSignature( ClbInfo ));

    //
    // Get thd HDC for the header.
    //

    hDCClientHeader = GetDC( ClbInfo->hWndHeader );
    DbgHandleAssert( hDCClientHeader );
    if (hDCClientHeader == NULL)
        return FALSE;

    //
    // Get the width of a character.
    //

    Success = GetCharMetrics( hDCClientHeader, &CharWidth, &CharHeight );
    DbgAssert( Success );

    //
    // Release the DC for the header.
    //

    Success = ReleaseDC( ClbInfo->hWndHeader, hDCClientHeader );
    DbgAssert( Success );

    //
    // Allocate an array of pixel widths, one for each column.
    //

    WidthsInPixels = AllocateObject( LONG, ClbInfo->Columns );
    DbgPointerAssert( WidthsInPixels );
    if (WidthsInPixels == NULL)
        return FALSE;

    //
    // Compute the width of each column (not including the rightmost) in pixels,
    // and the total number of pixels used by these columns.
    //

    TotalPixels = 0;
    for ( i = 0; i < ClbInfo->Columns - 1; i++ ) 
    {
        WidthsInPixels[ i ] = Widths[ i ] * CharWidth;
        TotalPixels += WidthsInPixels[ i ];
    }

    //
    // The caller did not specify the width of the rightmost column.
    //

    if ( Widths[ i ] == -1 ) {

        RECT    Rect;

        //
        // Set the width of the rightmost column to the remainder of the width
        // of the header window.
        //

        Success = GetClientRect(
                               ClbInfo->hWndHeader,
                               &Rect
                               );
        DbgAssert( Success );

        WidthsInPixels[ i ] = ( Rect.right - Rect.left ) - TotalPixels;

    } else {

        //
        // Set the width of the rightmost column to the value supplied
        // by the caller.
        //

        WidthsInPixels[ i ] = Widths[ i ] * CharWidth;
    }

    //
    // Tell the header window the width of each column.
    //

    hdi.mask = HDI_WIDTH;

    for ( i = 0; i < ClbInfo->Columns - 1; i++ ) {

        hdi.cxy = WidthsInPixels[i];
        Success = Header_SetItem(ClbInfo->hWndHeader, i, &hdi);

        DbgAssert( Success );
    }

    //
    // Calc the array of right edges.
    //

    iRight = 0;

    for ( i = 0; i < ClbInfo->Columns - 1; i++ ) {
        iRight += WidthsInPixels[i];
        ClbInfo->Right[i] = iRight;
    }

    //
    // Free the array of pixel widths.
    //

    Success = FreeObject( WidthsInPixels );
    DbgAssert( Success );

    return TRUE;
}

BOOL
AdjustClbHeadings(
                 IN HWND hWnd,
                 IN LPCLB_INFO ClbInfo,
                 IN LPCWSTR Headings OPTIONAL
                 )

/*++

Routine Description:

    AdjustClbHeadings adjust the number of columns, the widths an header text
    bbased on the optional Headings parameter. If Headings is NULL then the
    column widths are adjusted based on the old headings and the current size
    of the Clb. If Headings are supplied then they consist of ';' separated
    strings, each of which is a column heading. The number of columns and their
    widths is then computed based on these new headings.

Arguments:

    hWnd        - Supplies a window handle for this Clb.
    ClbInfo     - Supplies a pointer the CLB_INFO structure for this Clb.
    Headings    - Supplies an optional pointer to a ';' separated series of
                  column header strings.

Return Value:

    BOOL        - Returns TRUE if the adjustment was succesfully made.

--*/

{
    BOOL    Success;
    DWORD   Columns;
    DWORD   ColumnWidth;
    DWORD   i;
    TCHAR   Buffer[ MAX_PATH ];
    LPCWSTR Heading;
    RECT    ClientRectHeader;
    HD_ITEM hdi;
    UINT    iCount, j, iRight;


    DbgPointerAssert( ClbInfo );
    DbgAssert( ! (( ClbInfo->Columns == 0 ) && ( Headings == NULL )));


    //
    // If the user supplied headings, compute the new number of columns.
    //

    if ( ARGUMENT_PRESENT( Headings )) {

        //
        // Initialize the column counter.
        //

        Columns = 0;

        //
        // Make a copy of the new headings in the Clb object.
        //

        StringCchCopyW(ClbInfo->Headings, ARRAYSIZE(ClbInfo->Headings), Headings);

        //
        // Make a copy of the heading string so that it can be tokenized.
        // i.e. wcstok destroys the string.
        //

        StringCchCopy(Buffer, ARRAYSIZE(Buffer), Headings);

        //
        // Grab the first token (heading).
        //

        Heading = _tcstok( Buffer, HEADING_SEPARATOR );

        //
        // For each heading...
        //

        while ( Heading != NULL ) {

            //
            // Increment the number of columns.
            //

            Columns++;

            //
            // Get the next heading.
            //

            Heading = _tcstok( NULL, HEADING_SEPARATOR );
        }
    } else {

        //
        // Same number of Columns as before.
        //

        Columns = ClbInfo->Columns;
    }

    //
    // If the number of columns in the Clb is zero (i.e. this is the first
    // time it is being initialized) allocate the right edge array. Otherwise
    // reallocate the existing array if the number of columns has changed.
    //

    if ( ClbInfo->Columns == 0 ) 
    {
        ClbInfo->Right = AllocateObject( LONG, Columns );
        DbgPointerAssert( ClbInfo->Right );

    } 
    else if ( Columns != ClbInfo->Columns ) 
    {
        //
        // If ReallocateObject, i.e, LocalReAlloc fails, it keeps ClbInfo->Right
        // as it is, and returns NULL. Ensure that this memory is freed properly,
        // in case of failure...
        //
        LONG * plTemp = ReallocateObject( LONG, ClbInfo->Right, Columns );
        DbgPointerAssert(plTemp);

        if (!plTemp)
        {
            FreeObject(ClbInfo->Right);
        }
        ClbInfo->Right = plTemp;
    }

    if (ClbInfo->Right == NULL)
        return FALSE;

    //
    // Update the number of columns in the Clb (note this may be the same
    // number as before).
    //

    ClbInfo->Columns = Columns;

    //
    // Compute the default column width by dividing the available space by the
    // number of columns.
    //

    Success = GetClientRect( ClbInfo->hWndHeader, &ClientRectHeader );
    DbgAssert( Success );

    ColumnWidth =   ( ClientRectHeader.right - ClientRectHeader.left )
                    / ClbInfo->Columns;


    //
    // Initialize the array of right edges to the width of each column.
    //

    for ( i = 0; i < ClbInfo->Columns; i++ ) {

        ClbInfo->Right[ i ] = ColumnWidth;
    }

    //
    // Update the existing header items
    //

    iCount = Header_GetItemCount(ClbInfo->hWndHeader);

    j = 0;
    hdi.mask = HDI_WIDTH;

    while ((j < iCount) && (j < Columns)) {

        hdi.cxy = ClbInfo->Right[j];
        Header_SetItem (ClbInfo->hWndHeader, j, &hdi);
        j++;
    }

    //
    // Add new header items if necessary.
    //

    hdi.mask = HDI_WIDTH;
    for (; j < Columns; j++) {
        hdi.cxy = ClbInfo->Right[j];
        Header_InsertItem (ClbInfo->hWndHeader, j, &hdi);
    }


    //
    // Query the header for the array of right edges.
    //

    iRight = 0;

    for ( i = 0; i < ClbInfo->Columns - 1; i++ ) {
        iRight += ClbInfo->Right[i];
        ClbInfo->Right[i] = iRight;
    }

    ClbInfo->Right[i] = ClientRectHeader.right;

    //
    // Copy and parse the headings so that each column's heading
    // can be set. These can be new or old headings.
    //

    StringCchCopy(Buffer, ARRAYSIZE(Buffer), ClbInfo->Headings);

    Heading = _tcstok( Buffer, HEADING_SEPARATOR );

    hdi.mask = HDI_TEXT | HDI_FORMAT;
    hdi.fmt  = HDF_STRING;
    for ( i = 0; i < ClbInfo->Columns; i++ ) {

        hdi.pszText = (LPTSTR)Heading;
        Header_SetItem (ClbInfo->hWndHeader, i, &hdi);
        Heading = _tcstok( NULL, HEADING_SEPARATOR );
    }

    return TRUE;
}

BOOL
CreateHeader(
            IN HWND hWnd,
            IN LPCLB_INFO ClbInfo,
            IN LPCREATESTRUCT lpcs
            )

/*++

Routine Description:

    Create the header portion of the Clb.

Arguments:

    hWnd        - Supplies a window handle for the parent (i.e. Clb) window.
    ClbInfo     - Supplies a pointer the CLB_INFO structure for this Clb.
    lpcs        - Supplies a pointer to a CREATESTRUCT structure.

Return Value:

    BOOL        - Returns TRUE if the header portion of the Clb was
                  succesfully created.

--*/

{
    BOOL      Success;
    RECT      WindowRectHeader, rcParent;
    HD_LAYOUT hdl;
    WINDOWPOS wp;


    DbgHandleAssert( hWnd );
    DbgPointerAssert( ClbInfo );
    DbgPointerAssert( lpcs );

    //
    // Create the header window using the appropriate supplied styles,
    // augmented by additional styles needed by Clb, relative to the upper
    // left corner of the Clb and with a default height.
    // The width is adjusted in the WM_SIZE message handler.
    //

    ClbInfo->hWndHeader = CreateWindow(
                                      WC_HEADER,
                                      NULL,
                                      (lpcs->style & CLBS_HEADER) | WS_CHILD,
                                      0,
                                      0,
                                      0,
                                      CW_USEDEFAULT,
                                      hWnd,
                                      ( HMENU ) ID_HEADER,
                                      NULL,
                                      NULL
                                      );
    DbgHandleAssert( ClbInfo->hWndHeader );
    if (ClbInfo->hWndHeader == NULL)
        return FALSE;

    //
    // Compute and save the height of the header window. This is used to
    // position the list box.
    //

    GetClientRect(hWnd, &rcParent);

    hdl.prc = &rcParent;
    hdl.pwpos = &wp;

    SendMessage(ClbInfo->hWndHeader, HDM_LAYOUT, 0, (LPARAM)&hdl);

    SetWindowPos(ClbInfo->hWndHeader, wp.hwndInsertAfter, wp.x, wp.y, wp.cx, wp.cy, wp.flags);

    ClbInfo->HeaderHeight = wp.cy;

    return TRUE;
}

BOOL
CreateListBox(
             IN HWND hWnd,
             IN LPCLB_INFO ClbInfo,
             IN LPCREATESTRUCT lpcs
             )

/*++

Routine Description:

    Create the list box portion of the Clb.

Arguments:

    hWnd        - Supplies a window handle for the parent (i.e. Clb) window.
    ClbInfo     - Supplies a pointer the CLB_INFO structure for this Clb.
    lpcs        - Supplies a pointer to a CREATESTRUCT structure.

Return Value:

    BOOL        - Returns TRUE if the list box portion of the Clb was
                  succesfully created.

--*/

{
    BOOL    Success;
    LOGFONT LogFont;
    HDC     hDCClientListBox;
    CHARSETINFO csi;
    DWORD dw = GetACP();

    if (!TranslateCharsetInfo(&dw, &csi, TCI_SRCCODEPAGE))
        csi.ciCharset = ANSI_CHARSET;

    DbgHandleAssert( hWnd );
    DbgPointerAssert( ClbInfo );
    DbgPointerAssert( lpcs );

    //
    //
    // Create the list box using the appropriate supplied styles,
    // augmented by additional styles needed by Clb, relative to the lower left
    // corner of the header window plus one. This additional row is reserved so
    // that a border can be drawn between the header and the list box. The size
    // is adjusted in the WM_SIZE message handler.
    //

    ClbInfo->hWndListBox = CreateWindow(
                                       L"LISTBOX",
                                       NULL,
                                       (lpcs->style & CLBS_LIST_BOX) | LBS_NOINTEGRALHEIGHT | LBS_OWNERDRAWFIXED | WS_CHILD,
                                       0,
                                       ClbInfo->HeaderHeight + 3,
                                       0,
                                       0,
                                       hWnd,
                                       ( HMENU ) ID_LISTBOX,
                                       NULL,
                                       NULL
                                       );
    DbgHandleAssert( ClbInfo->hWndListBox );
    if (ClbInfo->hWndListBox == NULL)
        return FALSE;

    //
    // Get thd HDC for the list box.
    //

    hDCClientListBox = GetDC( ClbInfo->hWndListBox );
    DbgHandleAssert( hDCClientListBox );
    if (hDCClientListBox == NULL)
        return FALSE;

    //
    // Set the default font for the list box to MS Shell Dlg.
    //

    LogFont.lfHeight            = MulDiv(
                                        -9,
                                        GetDeviceCaps(
                                                     hDCClientListBox,
                                                     LOGPIXELSY
                                                     )
                                        ,72
                                        );
    LogFont.lfWidth             = 0;
    LogFont.lfEscapement        = 0;
    LogFont.lfOrientation       = 0;
    LogFont.lfWeight            = FW_NORMAL;
    LogFont.lfItalic            = FALSE;
    LogFont.lfUnderline         = FALSE;
    LogFont.lfStrikeOut         = FALSE;
    LogFont.lfCharSet           = (BYTE)csi.ciCharset;
    LogFont.lfOutPrecision      = OUT_DEFAULT_PRECIS;
    LogFont.lfClipPrecision     = CLIP_DEFAULT_PRECIS;
    LogFont.lfQuality           = DEFAULT_QUALITY;
    LogFont.lfPitchAndFamily    = DEFAULT_PITCH | FF_DONTCARE;

    StringCchCopy(LogFont.lfFaceName, ARRAYSIZE(LogFont.lfFaceName), TEXT("MS Shell Dlg"));

    ClbInfo->hFontListBox = CreateFontIndirect( &LogFont );
    DbgHandleAssert( ClbInfo->hFontListBox );
    if (ClbInfo->hFontListBox == NULL)
        return FALSE;

    SendMessage(
               ClbInfo->hWndListBox,
               WM_SETFONT,
               ( WPARAM ) ClbInfo->hFontListBox,
               MAKELPARAM( FALSE, 0 )
               );

    //
    // Release the DC for the list box.
    //

    Success = ReleaseDC( ClbInfo->hWndListBox, hDCClientListBox );
    DbgAssert( Success );

    return TRUE;
}

LRESULT
ClbWndProc(
          IN HWND hWnd,
          IN UINT message,
          IN WPARAM wParam,
          IN LPARAM lParam
          )

/*++

Routine Description:

    This function is the window procedure for the Clb custom control.

Arguments:

    Standard window procedure parameters.

Return Value:

    LRESULT - dependent on the supplied message.

--*/

{
    BOOL            Success;
    LPCLB_INFO      ClbInfo;

    if ( message == WM_NCCREATE ) {

        LONG    Long;

        //
        // Save the original styles.
        //

        Long = SetWindowLong(hWnd, GWLP_USERDATA,(( LPCREATESTRUCT ) lParam )->style);
        DbgAssert( Long == 0 );


        //
        // Get rid of any styles that are uninteresting to the Clb.
        //

        SetWindowLong(
                     hWnd,
                     GWL_STYLE,
                     (( LPCREATESTRUCT ) lParam )->style
                     & CLBS_CLB
                     );

        return TRUE;
    }


    if ( message == WM_CREATE ) {

        //
        // Assert that there is no prior per window information associated
        // with this Clb.
        //

        DbgAssert( RestoreClbInfo( hWnd ) == NULL );

        //
        // Restore the original styles.
        //

        (( LPCREATESTRUCT ) lParam )->style = GetWindowLong(
                                                           hWnd,
                                                           GWLP_USERDATA
                                                           );


        //
        // Allocate a CLB_INFO object for this Clb and initialize the Clb
        // relevant fields.
        //

        ClbInfo = AllocateObject( CLB_INFO, 1 );
        DbgPointerAssert( ClbInfo );
        if (ClbInfo == NULL)
            return FALSE;

        //
        // Set the number of columns to zero so that remainder of creation
        // understands the state of the Clb.
        //

        ClbInfo->Columns = 0;

        //
        // Create the header portion of the Clb.
        //

        Success = CreateHeader( hWnd, ClbInfo, ( LPCREATESTRUCT ) lParam );
        DbgAssert( Success );

        //
        // Create the list box portion of the Clb.
        //

        Success = CreateListBox( hWnd, ClbInfo, ( LPCREATESTRUCT ) lParam );
        DbgAssert( Success );

        //
        // Adjust the column number, widths based on the heading text.
        //

        Success = AdjustClbHeadings( hWnd, ClbInfo, (( LPCREATESTRUCT ) lParam )->lpszName );
        DbgAssert( Success );

        //
        // Everything was succesfully created so set the Clb's signature
        // and save it away as part of the per window data.
        //

        SetSignature( ClbInfo );

        SaveClbInfo( ClbInfo );

        return 0;
    }

    //
    // Get the ClbInfo object for this Clb and make sure that its already
    // been created i.e. WM_CREATE was already executed and thereby initialized
    // and saved a ClbInfo object.
    //

    ClbInfo = RestoreClbInfo( hWnd );

    if ( ClbInfo != NULL ) {

        //
        // Validate that this really is a ClbInfo object.
        //

        DbgAssert( CheckSignature( ClbInfo ));

        switch ( message ) {

            case WM_DESTROY:
                {
                    //
                    // Delete the font used in the list box.
                    //

                    Success = DeleteObject( ClbInfo->hFontListBox );
                    DbgAssert( Success );

                    //
                    // Delete the array of right habd edges.
                    //

                    Success = FreeObject( ClbInfo->Right );
                    DbgAssert( Success );

                    //
                    // Delete the CLB_INFO object for this window.
                    //

                    Success = FreeObject( ClbInfo );
                    DbgAssert( Success );

                    SaveClbInfo ( ClbInfo );
                    return 0;
                }

            case WM_PAINT:
                {
                    PAINTSTRUCT     ps;
                    RECT            Rect;
                    POINT           Points[ 2 ];
                    HDC             hDC;
                    HPEN            hPen;

                    hDC = BeginPaint( hWnd, &ps );
                    DbgAssert( hDC == ps.hdc );

                    Success = GetClientRect( hWnd, &Rect );
                    DbgAssert( Success );

                    Points[ 0 ].x = 0;
                    Points[ 0 ].y = ClbInfo->HeaderHeight + 1;
                    Points[ 1 ].x = Rect.right - Rect.left;
                    Points[ 1 ].y = ClbInfo->HeaderHeight + 1;

                    hPen = GetStockObject( BLACK_PEN );
                    DbgHandleAssert( hPen );

                    hPen = SelectObject( hDC, hPen );

                    Success = Polyline( hDC, Points, NumberOfEntries( Points ));
                    DbgAssert( Success );

                    hPen = SelectObject( hDC, hPen );

                    if (hPen) {
                        Success = DeleteObject( hPen );
                        DbgAssert( Success );
                    }

                    Success = EndPaint( hWnd, &ps );
                    DbgAssert( Success );

                    return 0;
                }

            case WM_COMMAND:

                switch ( LOWORD( wParam )) {

                    case ID_LISTBOX:

                        switch ( HIWORD( wParam )) {

                            case LBN_DBLCLK:
                            case LBN_KILLFOCUS:
                            case LBN_SELCHANGE:
                                {
                                    //
                                    // These messages come to ClbWndProc because it is the parent
                                    // of the list box, but they are really intended for the parent
                                    // of the Clb.
                                    //

                                    HWND    hWndParent;

                                    //
                                    // Forward the message to the Clb's parent if it has a parent.
                                    //

                                    hWndParent = GetParent( hWnd );
                                    DbgHandleAssert( hWndParent );

                                    if ( hWndParent != NULL ) {

                                        //
                                        // Replace the control id and handle with the Clb's.
                                        //

                                        *((WORD *)(&wParam)) = (WORD)GetDlgCtrlID( hWnd );

                                        DbgAssert( LOWORD( wParam ) != 0 );

                                        lParam = ( LPARAM ) hWnd;

                                        //
                                        // Forward the message...
                                        //

                                        return SendMessage( hWndParent, message, wParam, lParam );
                                    }
                                }
                        }
                        break;

                }
                break;

                //
                // Forward to listbox.
                //

            case LB_GETCURSEL:
            case LB_SETCURSEL:
            case LB_FINDSTRING:
            case LB_GETITEMDATA:
            case LB_RESETCONTENT:
            case WM_CHAR:
            case WM_GETDLGCODE:
            case WM_KILLFOCUS:

                return SendMessage( ClbInfo->hWndListBox, message, wParam, lParam );

            case WM_SETFOCUS:
                {
                    SetFocus( ClbInfo->hWndListBox );
                    return 0;
                }

            case WM_COMPAREITEM:
                {
                    //
                    // This message comes to ClbWndProc because it is the parent
                    // of the list box, but is really intended for the parent
                    // of the Clb.
                    //

                    HWND    hWndParent;

                    //
                    // Forward the message to the Clb's parent if it has a parent.
                    //

                    hWndParent = GetParent( hWnd );
                    DbgHandleAssert( hWndParent );

                    if ( hWndParent != NULL ) {

                        int                     ControlId;
                        LPCOMPAREITEMSTRUCT     lpcis;

                        lpcis = ( LPCOMPAREITEMSTRUCT ) lParam;

                        ControlId = GetDlgCtrlID( hWnd );
                        DbgAssert( ControlId != 0 );

                        //
                        // Modify the COMPAREITEMSTRUCT so that it refers to the Clb.
                        //

                        lpcis->CtlID    = ControlId;
                        lpcis->hwndItem = hWnd;

                        //
                        // Forward the message...
                        //

                        return SendMessage( hWndParent, message, ( WPARAM ) ControlId, lParam );
                    }

                    break;
                }

            case WM_DELETEITEM:
                {
                    LPDELETEITEMSTRUCT  lpditms;
                    LPCLB_ROW           ClbRow;
                    DWORD               i;


                    DbgAssert( wParam == ID_LISTBOX );

                    //
                    // Retrieve the pointer to the DELETEITEMSTRUCT.
                    //

                    lpditms = ( LPDELETEITEMSTRUCT ) lParam;
                    DbgAssert(( lpditms->CtlType == ODT_LISTBOX )
                              &&( lpditms->CtlID == ID_LISTBOX ));

                    //
                    // If there is no data, just return.
                    //

                    if ( lpditms->itemData == 0 ) {

                        return TRUE;
                    }

                    //
                    // Retrieve the CLB_ROW object for this row.
                    //

                    ClbRow = ( LPCLB_ROW ) lpditms->itemData;

                    //
                    // For each column delete the string.
                    //

                    for ( i = 0; i < ClbInfo->Columns; i++ ) {

                        //
                        // Strings were copied with _tcsdup so they must be
                        // freed with free( ).
                        //

                        free( ClbRow->Strings[ i ].String );
                    }

                    //
                    // Free the CLB_STRING object.
                    //

                    Success = FreeObject( ClbRow->Strings );
                    DbgAssert( Success );

                    //
                    // Free the CLB_ROW object.
                    //

                    Success = FreeObject( ClbRow );
                    DbgAssert( Success );

                    return TRUE;
                }

            case WM_DRAWITEM:
                {
                    LPDRAWITEMSTRUCT    lpdis;
                    BOOL                DrawFocus;

                    DbgAssert( wParam == ID_LISTBOX );

                    //
                    // Retrieve the pointer to the DRAWITEMSTRUCT.
                    //

                    lpdis = ( LPDRAWITEMSTRUCT ) lParam;
                    DbgAssert(( lpdis->CtlType == ODT_LISTBOX )
                              &&( lpdis->CtlID == ID_LISTBOX ));

                    //
                    // If there is no data, just return.
                    //

                    if ( lpdis->itemData == 0 ) {

                        return TRUE;
                    }

                    if ( lpdis->itemAction & ( ODA_DRAWENTIRE | ODA_SELECT )) {

                        DWORD               i;
                        LPCLB_ROW           ClbRow;
                        COLORREF            TextColor;
                        COLORREF            BkColor;

                        //
                        // Retrieve the CLB_ROW object for this row.
                        //

                        ClbRow = ( LPCLB_ROW ) lpdis->itemData;

                        //
                        // If the item is selected, set the selection colors.
                        //

                        if ( lpdis->itemState & ODS_SELECTED ) {

                            BkColor     = COLOR_HIGHLIGHT;
                            TextColor   = COLOR_HIGHLIGHTTEXT;

                        } else {

                            BkColor     = COLOR_WINDOW;
                            TextColor   = COLOR_WINDOWTEXT;
                        }

                        BkColor = GetSysColor( BkColor );
                        TextColor = GetSysColor( TextColor );

                        BkColor = SetBkColor( lpdis->hDC, BkColor );
                        DbgAssert( BkColor != CLR_INVALID );

                        TextColor = SetTextColor( lpdis->hDC, TextColor );
                        DbgAssert( TextColor != CLR_INVALID );


                        //
                        // For each column display the text.
                        //

                        for ( i = 0; i < ClbInfo->Columns; i++ ) {

                            RECT    ClipOpaqueRect;
                            int     x;
                            int     Left;
                            UINT    GdiErr;

                            //
                            // Depending on the format, adjust the alignment reference
                            // point (x) and the clipping rectangles left edge so that
                            // there are five pixels between each column.
                            //

                            switch ( ClbRow->Strings[ i ].Format ) {

                                case CLB_LEFT:

                                    if ( i == 0 ) {

                                        x = 2;

                                    } else {

                                        x = ClbInfo->Right[ i - 1 ] + 2;
                                    }

                                    Left = x - 2;

                                    break;

                                case CLB_RIGHT:

                                    if ( i == 0 ) {

                                        Left = 0;

                                    } else {

                                        Left = ClbInfo->Right[ i - 1 ];
                                    }

                                    x = ClbInfo->Right[ i ] - 3;

                                    break;

                                default:

                                    DbgAssert( FALSE );
                            }


                            //
                            // Set the format for this column.
                            //

                            GdiErr = SetTextAlign( lpdis->hDC, ClbRow->Strings[ i ].Format | TA_TOP );
                            DbgAssert( GdiErr != GDI_ERROR );

                            //
                            // Clip each string to its column width less two pixels
                            // (for asthetics).
                            //

                            Success = SetRect(
                                             &ClipOpaqueRect,
                                             Left,
                                             lpdis->rcItem.top,
                                             ClbInfo->Right[ i ],
                                             lpdis->rcItem.bottom
                                             );
                            DbgAssert( Success );

                            Success = ExtTextOut(
                                                lpdis->hDC,
                                                x,
                                                lpdis->rcItem.top,
                                                ETO_CLIPPED
                                                | ETO_OPAQUE,
                                                &ClipOpaqueRect,
                                                ClbRow->Strings[ i ].String,
                                                ClbRow->Strings[ i ].Length,
                                                NULL
                                                );
                            DbgAssert( Success );

                            //
                            // If the item has the focus, draw the focus rectangle.
                            //

                            DrawFocus = lpdis->itemState & ODS_FOCUS;
                        }

                    } else {

                        //
                        // If the Clb has the focus, display a focus rectangle
                        // around the selected item.
                        //

                        DrawFocus = lpdis->itemAction & ODA_FOCUS;
                    }

                    //
                    // If needed, toggle the focus rectangle.
                    //

                    if ( DrawFocus ) {

                        Success = DrawFocusRect( lpdis->hDC, &lpdis->rcItem );
                        DbgAssert( Success );
                    }

                    return TRUE;
                }

            case WM_NOTIFY:
                {
                    HD_NOTIFY * lpNot;
                    HD_ITEM   *pHDI;

                    lpNot = (HD_NOTIFY *)lParam;
                    pHDI = lpNot->pitem;

                    switch ( lpNot->hdr.code) {

                        static
                        DRAW_ERASE_LINE DrawEraseLine;

                        static
                        HPEN            hPen;

                        static
                        HDC             hDCClientListBox;
                        HD_ITEM         hdi;
                        UINT            iRight;
                        UINT            i;
                        RECT            ClientRectHeader;


                        case HDN_BEGINTRACK:
                            {

                                RECT    ClientRectListBox;

                                //
                                // Get thd HDC for the list box.
                                //

                                hDCClientListBox = GetDC( ClbInfo->hWndListBox );
                                DbgHandleAssert( hDCClientListBox );
                                if (hDCClientListBox == NULL)
                                    return FALSE;

                                //
                                // Create the pen used to display the drag position and
                                // select it into the in list box client area DC. Also set
                                // the ROP2 code so that drawing with the pen twice in the
                                // same place will erase it. This is what allows the
                                // line to drag.
                                //

                                hPen = CreatePen( PS_DOT, 1, RGB( 255, 255, 255 ));
                                DbgHandleAssert( hPen );

                                hPen = SelectObject( hDCClientListBox, hPen );
                                SetROP2( hDCClientListBox, R2_XORPEN );

                                //
                                // Set up the DRAW_ERASE_LINE structure so that the drag line is
                                // drawn from the top to the bottom of the list box at the
                                // current drag position.
                                //

                                Success = GetClientRect(
                                                       ClbInfo->hWndListBox,
                                                       &ClientRectListBox
                                                       );
                                DbgAssert( Success );

                                //
                                // Draw the initial drag line from the top to the bottom
                                // of the list box equivalent with the header edge grabbed
                                // by the user.
                                //

                                DrawEraseLine.Draw.Src.x = ClbInfo->Right[ pHDI->cxy ];
                                DrawEraseLine.Draw.Src.y = 0;
                                DrawEraseLine.Draw.Dst.x = ClbInfo->Right[ pHDI->cxy ];
                                DrawEraseLine.Draw.Dst.y =   ClientRectListBox.bottom
                                                             - ClientRectListBox.top;

                                Success = DrawLine( hDCClientListBox, &DrawEraseLine );
                                DbgAssert( Success );

                                return 0;
                            }

                        case HDN_TRACK:
                            {

                                //DWORD           Columns;

                                //
                                // Get new drag position.
                                //

                                iRight = 0;
                                hdi.mask = HDI_WIDTH;

                                for ( i = 0; i < ClbInfo->Columns - 1; i++ ) {
                                    if (i != (UINT)lpNot->iItem) {
                                        Header_GetItem(ClbInfo->hWndHeader, i, &hdi);
                                    } else {
                                        hdi.cxy = pHDI->cxy;
                                    }
                                    iRight += hdi.cxy;
                                    ClbInfo->Right[i] = iRight;
                                }

                                GetClientRect( ClbInfo->hWndHeader, &ClientRectHeader );
                                ClbInfo->Right[i] = ClientRectHeader.right;

                                //
                                // Erase the old line and draw the new one at the new
                                // drag position.
                                //

                                Success = RedrawVerticalLine(
                                                            hDCClientListBox,
                                                            ClbInfo->Right[lpNot->iItem],
                                                            &DrawEraseLine
                                                            );
                                DbgAssert( Success );

                                return 0;
                            }

                        case HDN_ENDTRACK:

                            //
                            // Replace the old pen and delete the one created
                            // during HBN_BEGINDRAG.
                            //

                            hPen = SelectObject( hDCClientListBox, hPen );

                            if (hPen) {
                                Success = DeleteObject( hPen );
                                DbgAssert( Success );
                            }

                            //
                            // Release the DC for the list box.
                            //

                            Success = ReleaseDC( ClbInfo->hWndListBox, hDCClientListBox );
                            DbgAssert( Success );

                            Success = RedrawWindow(
                                                  hWnd,
                                                  NULL,
                                                  NULL,
                                                  RDW_ERASE
                                                  | RDW_INVALIDATE
                                                  | RDW_UPDATENOW
                                                  | RDW_ALLCHILDREN
                                                  );
                            DbgAssert( Success );

                            return 0;
                    }

                    break;
                }

            case WM_SETTEXT:

                //
                // Adjust the column number and widths based on the heading text.
                //

                Success = AdjustClbHeadings( hWnd, ClbInfo, ( LPCWSTR ) lParam );
                DbgAssert( Success );

                return Success;

            case WM_SIZE:
                {
                    HDWP    hDWP;
                    LONG    Width;
                    LONG    Height;
                    LONG    Style;
                    LONG    VScrollWidth;

                    Width   = LOWORD( lParam );
                    Height  = HIWORD( lParam );

                    hDWP = BeginDeferWindowPos( 2 );
                    DbgHandleAssert( hDWP );
                    if (hDWP == NULL)
                        return FALSE;

                    //
                    // Retrieve the list box's styles.
                    //

                    Style = GetWindowLong( ClbInfo->hWndListBox, GWL_STYLE );

                    //
                    // If the list box has a vertical scroll bar compute its
                    // width so that the header window's width can be adjusted
                    // appropriately.
                    //

                    VScrollWidth =   ( Style & WS_VSCROLL )
                                     ?   GetSystemMetrics( SM_CXVSCROLL )
                                     + ( GetSystemMetrics( SM_CXBORDER ) * 2 )
                                     : 0;

                    //
                    // Size the header window to the width of the Clb and its
                    // default / original height.
                    //

                    hDWP = DeferWindowPos(
                                         hDWP,
                                         ClbInfo->hWndHeader,
                                         NULL,
                                         0,
                                         0,
                                         Width - VScrollWidth,
                                         ClbInfo->HeaderHeight,
                                         SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER
                                         );
                    DbgHandleAssert( hDWP );
                    if (hDWP == NULL)
                        return FALSE;

                    //
                    // If the list box has a vertical scroll bar, bump the width
                    // and height by two so that its border overwrites the Clb
                    // border. This eliminates a double border (and a gap) between
                    // the right and bottom edges of the scroll bar and the Clb.
                    //

                    if ( Style & WS_VSCROLL ) {

                        Height += 2;
                        Width += 2;
                    }

                    //
                    // Size the list box so that it is the size of the Clb less
                    // the height of the header window less the height of the
                    // border.
                    //

                    hDWP = DeferWindowPos(
                                         hDWP,
                                         ClbInfo->hWndListBox,
                                         NULL,
                                         0,
                                         0,
                                         Width,
                                         Height - ClbInfo->HeaderHeight - 3,
                                         SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER
                                         );
                    DbgHandleAssert( hDWP );
                    if (hDWP == NULL)
                        return FALSE;

                    Success = EndDeferWindowPos( hDWP );
                    DbgAssert( Success );

                    break;
                }

        }
    }

    return DefWindowProc( hWnd, message, wParam, lParam );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\wintools\clb\clb.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Clb.h

Abstract:


Author:

    David J. Gilman (davegi) 05-Feb-1993

Environment:

    User Mode

--*/

#if ! defined( _CLB_ )

#define _CLB_

#ifndef _REGEDT32_
#include "wintools.h"
#endif  // _REGEDT32_

#include <commctrl.h>

//
// Class name for the CLB.
//

#define CLB_CLASS_NAME          TEXT( "ColumnListBox" )

//
// Clb Styles.
//

#define CLBS_NOTIFY             LBS_NOTIFY
#define CLBS_SORT               LBS_SORT
#define CLBS_DISABLENOSCROLL    LBS_DISABLENOSCROLL
#define CLBS_VSCROLL            WS_VSCROLL
#define CLBS_BORDER             WS_BORDER
#define CLBS_POPOUT_HEADINGS    SBT_POPOUT
#define CLBS_SPRINGY_COLUMNS    0
                                
#define CLBS_STANDARD           (                                           \
                                      0                                     \
                                    | CLBS_NOTIFY                           \
                                    | CLBS_SORT                             \
                                    | CLBS_VSCROLL                          \
                                    | CLBS_BORDER                           \
                                )

//
// Clb string formats.
//

typedef
enum
_CLB_FORMAT {

    CLB_LEFT    = TA_LEFT,
    CLB_RIGHT   = TA_RIGHT

}   CLB_FORMAT;

//
// Clb string object.
//

typedef
struct
_CLB_STRING {

    LPTSTR          String;
    DWORD           Length;
    CLB_FORMAT      Format;
    LPVOID          Data;

}   CLB_STRING, *LPCLB_STRING;

//
// Clb row object.
//

typedef
struct
_CLB_ROW {

    DWORD           Count;
    LPCLB_STRING    Strings;
    LPVOID          Data;

}   CLB_ROW, *LPCLB_ROW;

BOOL
ClbAddData(
    IN HWND hWnd,
    IN int ControlId,
    IN LPCLB_ROW ClbRow
    );

BOOL
ClbSetColumnWidths(
    IN HWND hWnd,
    IN int ControlId,
    IN LPDWORD Widths
    );

#endif // _CLB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\uudf\src\unicode.cxx ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

    unicode.cxx

Author:

    Centis Biks (cbiks) 05-May-2000

Environment:

    ULIB, User Mode

--*/

#include "pch.cxx"

int
UncompressUnicode
(
    int         UDFCompressedBytes,
    LPBYTE      UDFCompressed,
    PWSTRING    UnicodeString
)
{
    int Result = -1;

    /* Use UDFCompressed to store current byte being read. */
    UCHAR CompressionID = UDFCompressed[0];

    /* First check for valid CompressionID. */
    if ((CompressionID) == 8 || (CompressionID == 16)) {

        if (CompressionID == 8) {

            UnicodeString->Resize( UDFCompressedBytes - 1 );

        } else {

            ASSERTMSG( "Unicode string length should be a multiple of two.\n",
                (UDFCompressedBytes % 2) == 1 );

            UnicodeString->Resize( (UDFCompressedBytes - 1) / sizeof( short ) );

        }

        int UnicodeLength = 0;
        int ByteIndex = 1;

        /* Loop through all the bytes. */
        while (ByteIndex < UDFCompressedBytes) {

            if (CompressionID == 16) {

                //  UNDONE, CBiks, 8/2/2000
                //      Test this code....
                //

                ASSERT( 0 );
                UnicodeString->SetChAt( (WCHAR) (UDFCompressed[ ByteIndex++ ] << 8) | UDFCompressed[ ByteIndex++ ], UnicodeLength );

            } else {

                UnicodeString->SetChAt( UDFCompressed[ ByteIndex ], UnicodeLength );
                ByteIndex++;

            }

            UnicodeLength++;

        }

        Result = UnicodeLength;

    }

    return Result;
}


/***********************************************************************
* DESCRIPTION:
* Takes a string of unicode wide characters and returns an OSTA CS0
* compressed unicode string. The unicode MUST be in the byte order of
* the compiler in order to obtain correct results.  Returns an error
* if the compression ID is invalid.
*
* NOTE: This routine assumes the implementation already knows, by
* the local environment, how many bits are appropriate and
* therefore does no checking to test if the input characters fit
* into that number of bits or not.
*
* RETURN VALUE
*
*    The total number of bytes in the compressed OSTA CS0 string,
*    including the compression ID.
*    A -1 is returned if the compression ID is invalid.
*/
int
CompressUnicode
(
    PCWCH       UnicodeString,
    size_t      UnicodeStringSize,
    LPBYTE      UDFCompressed
)
{
    UDFCompressed[0] = 16;

    int ByteIndex = 1;
    size_t UnicodeLength = 0;
    while (UnicodeLength < UnicodeStringSize) {

        UDFCompressed[ByteIndex++] = (UCHAR)( (UnicodeString[UnicodeLength] & 0xFF00) >> 8 );
        UDFCompressed[ByteIndex++] = (UCHAR)(  UnicodeString[UnicodeLength] & 0x00FF );

        UnicodeLength++;
    }

    return ByteIndex;
}

BOOL
UncompressDString
(
    LPBYTE      DString,
    size_t      DStringSize,
    PWSTRING    UnicodeString
)
{
    int Len = UncompressUnicode( DString[ DStringSize - 1 ], DString, UnicodeString );
    return (Len >= 0);
}

VOID
CompressDString
(
    UCHAR   CompressionID,
    PCWCH   UnicodeString,
    size_t  UnicodeStringSize,
    LPBYTE  UDFCompressed,
    size_t  UDFCompressedSize
)
{
    ASSERTMSG( "Unsupported compression ID",
        (CompressionID == 8 || CompressionID == 16) );

    ASSERT( UnicodeStringSize < UDFCompressedSize );

    UDFCompressed[0] = CompressionID;

    int byteIndex = 1;
    size_t unicodeIndex = 0;
    while (unicodeIndex < UnicodeStringSize) {

        if (CompressionID == 16) {

            UDFCompressed[byteIndex++] = (BYTE) ((UnicodeString[unicodeIndex] & 0xFF00) >> 8);

        }

        UDFCompressed[byteIndex++] = (BYTE) (UnicodeString[unicodeIndex] & 0x00FF);
        unicodeIndex++;

    }

    UDFCompressed[UDFCompressedSize - 1] = (BYTE) UnicodeStringSize + 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\wintools\clb\dialogs.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Dialogs.h

Abstract:


Author:

    David J. Gilman (davegi) 18-Feb-1993

Environment:

    User Mode

--*/

#define IDD_CLB                     1700
#define IDC_CHECK_VISIBLE           1701
#define IDC_CHECK_DISABLED          1702
#define IDC_CHECK_GROUP             1703
#define IDC_CHECK_TABSTOP           1704
#define IDC_CHECK_SORT              1705
#define IDC_CHECK_NOTIFY            1706
#define IDC_CHECK_VSCROLL           1707
#define IDC_CHECK_STANDARD          1710
#define IDC_CHECK_BORDER            1713
#define IDC_CHECK_POPOUT_HEADINGS   1714
#define IDC_CHECK_SPRINGY_COLUMNS   1715
#define IDC_CHECK_DISABLENOSCROLL   1708
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\wintools\clb\debug.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Debug.c

Abstract:

    This module contains debugging support.


Author:

    David J. Gilman (davegi) 30-Jul-1992

Environment:

    User Mode

--*/

//
// Global flag bits.
//

struct
DEBUG_FLAGS {

    int DebuggerAttached:1;

}   WintoolsGlobalFlags;

#if DBG

#include <stdarg.h>
#include <stdio.h>

#include "wintools.h"

//
// Internal function prototypes.
//

LPCWSTR
DebugFormatStringW(
    IN DWORD Flags,
    IN LPCWSTR Format,
    IN va_list* Args
    );

VOID
DebugAssertW(
    IN LPCWSTR Expression,
    IN LPCSTR File,
    IN DWORD LineNumber
    )

/*++

Routine Description:

    Display an assertion failure message box which gives the user a choice
    as to whether the process should be aborted, the assertion ignored or
    a break exception generated.

Arguments:

    Expression  - Supplies a string representation of the failed assertion.
    File        - Supplies a pointer to the file name where the assertion
                  failed.
    LineNumber  - Supplies the line number in the file where the assertion
                  failed.

Return Value:

    None.

--*/

{
    LPCWSTR    Buffer;
    DWORD_PTR  Args[ ] = {

        ( DWORD_PTR ) Expression,
        ( DWORD_PTR ) GetLastError( ),
        ( DWORD_PTR ) File,
        ( DWORD_PTR ) LineNumber
    };

    DbgPointerAssert( Expression );
    DbgPointerAssert( File );

    //
    // Format the assertion string that describes the failure.
    //

    Buffer = DebugFormatStringW(
        FORMAT_MESSAGE_ARGUMENT_ARRAY,
        L"Assertion Failed : %1!s! (%2!d!)\nin file %3!hs! at line %4!d!\n",
        ( va_list* ) Args
        );

    //
    // If the debugger is attached flag is set, display the string on the
    // debugger and break. If not generate a pop-up and leave the choice
    // to the user.
    //

    if( WintoolsGlobalFlags.DebuggerAttached ) {

        OutputDebugString( Buffer );
        DebugBreak( );

    } else {

        int     Response;
        WCHAR   ModuleBuffer[ MAX_PATH ];
        DWORD   Length;

        //
        // Get the asserting module's file name.
        //

        Length = GetModuleFileName(
                        NULL,
                        ModuleBuffer,
                        ARRAYSIZE(ModuleBuffer)
                        );

        //
        // Display the assertin message and gives the user the choice of:
        //  Abort:  - kills the process.
        //  Retry:  - generates a breakpoint exception.
        //  Ignore: - continues the process.
        //

        Response = MessageBox(
                        NULL,
                        Buffer,
                        ( Length != 0 ) ? ModuleBuffer : L"Assertion Failure",
                        MB_ABORTRETRYIGNORE | MB_ICONHAND | MB_SETFOREGROUND | MB_TASKMODAL
                        );

        switch( Response ) {

        //
        // Terminate the process.
        //

        case IDABORT:
            {
                ExitProcess( (UINT) -1 );
                break;
            }

        //
        // Ignore the failed assertion.
        //

        case IDIGNORE:
            {
                break;
            }

        //
        // Break into a debugger.
        //

        case IDRETRY:
            {
                DebugBreak( );
                break;
            }

        //
        // Break into a debugger because of a catastrophic failure.
        //

        default:
            {
                DebugBreak( );
                break;
            }
        }
    }
}

LPCWSTR
DebugFormatStringW(
    IN DWORD Flags,
    IN LPCWSTR Format,
    IN va_list* Args
    )

/*++

Routine Description:

    Formats a string using the FormatMessage API.

Arguments:

    Flags    - Supplies flags which are used to control the FormatMessage API.
    Format   - Supplies a printf style format string.
    Args     - Supplies a list of arguments whose format is depndent on the
               flags valuse.

Return Value:

    LPCWSTR  - Returns a pointer to the formatted string.

--*/

{
    static
    WCHAR    Buffer[ MAX_CHARS ];

    DWORD    Count;

    DbgPointerAssert( Format );

    //
    // Format the string.
    //

    Count = FormatMessageW(
                Flags | FORMAT_MESSAGE_FROM_STRING & ~FORMAT_MESSAGE_FROM_HMODULE,
                ( LPVOID ) Format,
                0,
                0,
                Buffer,
                ARRAYSIZE( Buffer ),
                Args
                );
    DbgAssert( Count != 0 );

    //
    // Return the formatted string.
    //

    return Buffer;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\xcopy\support.cxx ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

	Support

Abstract:

	Miscelaneous support functions for the XCopy directory copy
	utility.  All functions that are not involved directly in the
	copy process go here.

Author:

	Ramon Juan San Andres (ramonsa) 02-May-1991

Revision History:

--*/



#include "ulib.hxx"
#include "system.hxx"
#include "xcopy.hxx"





VOID
XCOPY::DisplayMessageAndExit (
	IN	MSGID		MsgId,
	IN	PWSTRING	String,
	IN	ULONG		ExitCode
	)

/*++

Routine Description:

	Displays a message and exits the program with the supplied error code.
	We support a maximum of one string parameter for the message.

Arguments:

	MsgId		-	Supplies the Id of the message to display.
	String		-	Supplies a string parameter for the message.
	ExitCode	-	Supplies the exit code with which to exit.

Return Value:

    None.

Notes:

--*/

{
	//
	//	XCopy first displays the error message (if any) and then
	//	displays the number of files copied.
	//
	if ( MsgId != 0 ) {
		if ( String ) {
			DisplayMessage( MsgId, ERROR_MESSAGE, "%W", String );
		} else {
			DisplayMessage( MsgId, ERROR_MESSAGE );
		}
	}

    if ( _DontCopySwitch ) {
        DisplayMessage( XCOPY_MESSAGE_FILES, NORMAL_MESSAGE, "%d", _FilesCopied );
    } else if ( !_StructureOnlySwitch ) {
        DisplayMessage( XCOPY_MESSAGE_FILES_COPIED, NORMAL_MESSAGE, "%d", _FilesCopied );
    }
	ExitProgram( ExitCode );

}

PWSTRING
XCOPY::QueryMessageString (
	IN MSGID	MsgId
	)
/*++

Routine Description:

	Obtains a string object initialized to the contents of some message

Arguments:

	MsgId	-	Supplies ID of the message

Return Value:

	PWSTRING	-	Pointer to initialized string object

Notes:

--*/

{

	PWSTRING	String;

    if ( ((String = NEW DSTRING) == NULL )  ||
		 !(SYSTEM::QueryResourceString( String, MsgId, "" )) ) {

		DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
	}

	return String;

}

VOID
XCOPY::ExitWithError(
	IN	DWORD		ErrorCode
	)

/*++

Routine Description:

	Displays a message based on a WIN32 error code, and exits.

Arguments:

	ErrorCode	-	Supplies Windows error code

Return Value:

	none

--*/

{
	MSGID	ReadWriteMsgId = 0;

	switch ( ErrorCode ) {

	case ERROR_DISK_FULL:
		ReadWriteMsgId = XCOPY_ERROR_DISK_FULL;
		break;

	case ERROR_WRITE_PROTECT:
		ReadWriteMsgId = XCOPY_ERROR_WRITE_PROTECT;
		break;

	case ERROR_ACCESS_DENIED:
		ReadWriteMsgId =  XCOPY_ERROR_ACCESS_DENIED;
		break;

	case ERROR_SHARING_VIOLATION:
		ReadWriteMsgId =  XCOPY_ERROR_SHARING_VIOLATION;
		break;

	case ERROR_TOO_MANY_OPEN_FILES:
		ReadWriteMsgId =  XCOPY_ERROR_TOO_MANY_OPEN_FILES;
		break;

	case ERROR_LOCK_VIOLATION:
		ReadWriteMsgId =  XCOPY_ERROR_LOCK_VIOLATION;
		break;

	case ERROR_CANNOT_MAKE:
		ReadWriteMsgId =  XCOPY_ERROR_CANNOT_MAKE;
		break;

	default:
		break;
	}

	if ( ReadWriteMsgId != 0 ) {
		DisplayMessageAndExit(	ReadWriteMsgId, NULL, EXIT_READWRITE_ERROR );
	}

	Fatal(	EXIT_MISC_ERROR, XCOPY_ERROR_EXTENDED, "%d", ErrorCode );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\xcopy\sources.inc ===
!IF 0

Copyright (c) 1989-2001 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=utils
MINORCOMP=xcopy

TARGETNAME=xcopy
TARGETPATH=obj
TARGETTYPE=PROGRAM

LINKER_STACKCOMMITSIZE=16384

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\argument.cxx    \
        ..\support.cxx     \
        ..\xcopy.cxx \
        ..\xcopy.rc

INCLUDES=..\.;..\..\ulib\inc;..\..\ifsutil\inc;$(DDK_INC_PATH)

!IF "$(NTDEBUG)" == "cvp" || "$(NTDEBUG)" == "ntsd"
!IFDEF NOMEMLEAK
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DUNICODE=1
!ELSE
!IFDEF STACK_TRACE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DSTACK_TRACE -DUNICODE=1
!ELSE
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=1 -DMEMLEAK -DUNICODE=1
!ENDIF
!ENDIF
!ELSE   # NTDEBUG
C_DEFINES=-DCONDITION_HANDLING=1 -DDBG=0 -DUNICODE=1
!ENDIF  # NTDEBUG

TARGETLIBS= \
    ..\..\ulib\src\$(ALT_PROJECT)\$(O)\ulib.lib \
    ..\..\ifsutil\src\$(ALT_PROJECT)\$(O)\ifsutil.lib \
    $(SDK_LIB_PATH)\ntdll.lib

UMTYPE=console

W32_SB=1
SOURCES_USED=..\sources.inc
USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\wintools\clb\wintools.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Wintools.h

Abstract:

    This is the master headerfile for the Wintools library.


Author:

    David J. Gilman  (davegi) 28-Oct-1992
    Gregg R. Acheson (GreggA) 28-Feb-1994

Environment:

    User Mode

--*/

#if ! defined( _WINTOOLS_ )

#define _WINTOOLS_

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

//
//*** Debug Information Support.
//

extern
struct
DEBUG_FLAGS
WintoolsGlobalFlags;

#if DBG

VOID
DebugAssertW(
    IN LPCWSTR Expression,
    IN LPCSTR File,
    IN DWORD LineNumber
    );

#define DbgAssert( exp )                                                    \
    (( exp )                                                                \
    ? ( VOID ) 0                                                            \
    : ( VOID ) DebugAssertW(                                                \
        TEXT( #exp ),                                                       \
        __FILE__,                                                           \
        __LINE__                                                            \
        ));

#define DbgHandleAssert( h )                                                \
    DbgAssert((( h ) != NULL ) && (( h ) != INVALID_HANDLE_VALUE ))

#define DbgPointerAssert( p )                                               \
    DbgAssert(( p ) != NULL )

#else // ! DBG

#define DbgAssert( exp )

#define DbgHandleAssert( h )

#define DbgPointerAssert( p )

#endif // DBG

//
//*** Object Signature Support.
//

#if SIGNATURE

#define DECLARE_SIGNATURE                                                   \
    DWORD_PTR Signature;

#define SetSignature( p )                                                   \
    (( p )->Signature = ( DWORD_PTR ) &(( p )->Signature ))

#define CheckSignature( p )                                                 \
    (( p )->Signature == ( DWORD_PTR ) &(( p )->Signature ))

#else // ! SIGNATURE

#define DECLARE_SIGNATURE

#define SetSignature( p )

#define CheckSignature( p )

#endif // SIGNATURE

//
//*** Miscellaneous Macros.
//

#ifndef ARGUMENT_PRESENT
#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )
#endif    

#define NumberOfEntries( x )                                                \
    ( sizeof(( x )) / sizeof(( x )[ 0 ]))

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)                    (sizeof(x)/sizeof(x[0]))
#endif

//
//*** Global constants.
//

//
// Maximum number of characters in a string.
//

#define MAX_CHARS               ( 2048 )

//
//*** Memory Management Support
//

#define AllocateMemory( t, s )                                              \
    (( LP##t ) LocalAlloc( LPTR, ( s )))

#define AllocateObject( t, c )                                              \
    ( AllocateMemory( t, sizeof( t ) * ( c )))

#define ReallocateMemory( t, p, s )                                         \
    (( LP##t ) LocalReAlloc(( HLOCAL )( p ), ( s ), LMEM_MOVEABLE ))

#define ReallocateObject( t, p, c )                                         \
    ( ReallocateMemory( t, ( p ), sizeof( t ) * ( c )))

#define FreeMemory( p )                                                     \
    ((( p ) == NULL )                                                       \
    ?  TRUE                                                                 \
    : (((p)=( LPVOID ) LocalFree(( HLOCAL )( p ))) == NULL ))


#define FreeObject( p )                                                     \
    FreeMemory(( p ))

//
//*** Function Prototypes.
//

BOOL
GetCharMetrics(
    IN HDC hDC,
    IN LPLONG CharWidth,
    IN LPLONG CharHeight
    );

#ifdef __cplusplus
}       // extern C
#endif

#endif // _WINTOOLS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\xcopy\argument.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

    Argument

Abstract:

    Argument processing for the XCopy directory copy utility

Author:

    Ramon Juan San Andres (ramonsa) 01-May-1991

Notes:

    The arguments accepted  by the XCopy utility are:

    Source directory.-  Source path.

    Dest. directory.-   Destination path.

    Archive switch.-    Copy files that have their archive bit set

    Date.-              Copy files modified on or after the specifiec
                        date.

    Empty switch.-      Copy directories even if empty. Subdir switch
                        must also be set.

    Modify switch.-     Same as Archive switch, but turns off archive
                        bit in the source file after copying.

    Prompt switch.-     Prompts before copying each file.

    Subdir switch.-     Copies also subdirectories, unless they are empty.
                        (Empty directories are copied if the Empty switch
                        is set).

    Verify switch.-     Verifies each copy.

    Wait switch.-       Wait before starting to copy the files.

    Owner switch. -     Copy ownership and permissions

    Audit switch. -     Copy auditing information.

Revision History:


--*/


#include "ulib.hxx"
#include "arg.hxx"
#include "arrayit.hxx"
#include "dir.hxx"
#include "xcopy.hxx"
#include "stringar.hxx"
#include "file.hxx"
#include "filestrm.hxx"

//
// Switch characters. Used for maintaining DOS5 compatibility when
// displaying error messages
//
#define SWITCH_CHARACTERS  "dDaAeEmMpPsSvVwW?"

//
// Static variables
//

PARRAY              LexArray;
PPATH_ARGUMENT      FirstPathArgument       =   NULL;
PPATH_ARGUMENT      FirstQuotedPathArgument =   NULL;
PPATH_ARGUMENT      SecondPathArgument      =   NULL;
PPATH_ARGUMENT      SecondQuotedPathArgument =  NULL;
PFLAG_ARGUMENT      ArchiveArgument         =   NULL;
PTIMEINFO_ARGUMENT  DateArgument            =   NULL;
PFLAG_ARGUMENT      DecryptArgument         =   NULL;
PFLAG_ARGUMENT      EmptyArgument           =   NULL;
PFLAG_ARGUMENT      ModifyArgument          =   NULL;
PFLAG_ARGUMENT      PromptArgument          =   NULL;
PFLAG_ARGUMENT      OverWriteArgument       =   NULL;
PFLAG_ARGUMENT      NotOverWriteArgument    =   NULL;
PFLAG_ARGUMENT      SubdirArgument          =   NULL;
PFLAG_ARGUMENT      VerifyArgument          =   NULL;
PFLAG_ARGUMENT      WaitArgument            =   NULL;
PFLAG_ARGUMENT      HelpArgument            =   NULL;
PFLAG_ARGUMENT      ContinueArgument        =   NULL;

PFLAG_ARGUMENT      IntelligentArgument     =   NULL;
PFLAG_ARGUMENT      VerboseArgument         =   NULL;
PFLAG_ARGUMENT      OldArgument             =   NULL;
PFLAG_ARGUMENT      HiddenArgument          =   NULL;
PFLAG_ARGUMENT      ReadOnlyArgument        =   NULL;
PFLAG_ARGUMENT      SilentArgument          =   NULL;
PFLAG_ARGUMENT      NoCopyArgument          =   NULL;
PFLAG_ARGUMENT      StructureArgument       =   NULL;
PFLAG_ARGUMENT      UpdateArgument          =   NULL;
PFLAG_ARGUMENT      CopyAttrArgument        =   NULL;
PFLAG_ARGUMENT      UseShortArgument        =   NULL;
PFLAG_ARGUMENT      RestartableArgument     =   NULL;
PFLAG_ARGUMENT      OwnerArgument           =   NULL;
PFLAG_ARGUMENT      AuditArgument           =   NULL;

PSTRING_ARGUMENT    ExclusionListArgument   =   NULL;

PSTRING_ARGUMENT    InvalidSwitchArgument   =   NULL;


BOOLEAN        HelpSwitch;

//
// Prototypes
//


VOID
XCOPY::SetArguments(
    )

/*++

Routine Description:

    Obtains the arguments for the XCopy utility

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{

    PATH_ARGUMENT       LocalFirstPathArgument;
    PATH_ARGUMENT       LocalFirstQuotedPathArgument;
    PATH_ARGUMENT       LocalSecondPathArgument;
    PATH_ARGUMENT       LocalSecondQuotedPathArgument;
    FLAG_ARGUMENT       LocalArchiveArgument;
    TIMEINFO_ARGUMENT   LocalDateArgument;
    FLAG_ARGUMENT       LocalOldArgument;
    FLAG_ARGUMENT       LocalDecryptArgument;
    FLAG_ARGUMENT       LocalEmptyArgument;
    FLAG_ARGUMENT       LocalModifyArgument;
    FLAG_ARGUMENT       LocalPromptArgument;
    FLAG_ARGUMENT       LocalOverWriteArgument;
    FLAG_ARGUMENT       LocalNotOverWriteArgument;
    FLAG_ARGUMENT       LocalSubdirArgument;
    FLAG_ARGUMENT       LocalVerifyArgument;
    FLAG_ARGUMENT       LocalWaitArgument;
    FLAG_ARGUMENT       LocalHelpArgument;
    FLAG_ARGUMENT       LocalContinueArgument;
    FLAG_ARGUMENT       LocalIntelligentArgument;
    FLAG_ARGUMENT       LocalVerboseArgument;
    FLAG_ARGUMENT       LocalHiddenArgument;
    FLAG_ARGUMENT       LocalReadOnlyArgument;
    FLAG_ARGUMENT       LocalSilentArgument;
    FLAG_ARGUMENT       LocalNoCopyArgument;
    FLAG_ARGUMENT       LocalStructureArgument;
    FLAG_ARGUMENT       LocalUpdateArgument;
    FLAG_ARGUMENT       LocalCopyAttrArgument;
    FLAG_ARGUMENT       LocalUseShortArgument;
    FLAG_ARGUMENT       LocalRestartableArgument;
    FLAG_ARGUMENT       LocalOwnerArgument;
    FLAG_ARGUMENT       LocalAuditArgument;
    STRING_ARGUMENT     LocalExclusionListArgument;


    STRING_ARGUMENT     LocalInvalidSwitchArgument;
    ARRAY               LocalLexArray;

    //
    // Set the static global pointers
    //
    FirstPathArgument         = &LocalFirstPathArgument;
    FirstQuotedPathArgument   = &LocalFirstQuotedPathArgument;
    SecondPathArgument        = &LocalSecondPathArgument;
    SecondQuotedPathArgument  = &LocalSecondQuotedPathArgument;
    ArchiveArgument           = &LocalArchiveArgument;
    DateArgument              = &LocalDateArgument;
    OldArgument               = &LocalOldArgument;
    DecryptArgument           = &LocalDecryptArgument;
    EmptyArgument             = &LocalEmptyArgument;
    ModifyArgument            = &LocalModifyArgument;
    PromptArgument            = &LocalPromptArgument;
    OverWriteArgument         = &LocalOverWriteArgument;
    NotOverWriteArgument      = &LocalNotOverWriteArgument;
    SubdirArgument            = &LocalSubdirArgument;
    VerifyArgument            = &LocalVerifyArgument;
    WaitArgument              = &LocalWaitArgument;
    HelpArgument              = &LocalHelpArgument;
    ContinueArgument          = &LocalContinueArgument;
    IntelligentArgument       = &LocalIntelligentArgument;
    VerboseArgument           = &LocalVerboseArgument;
    HiddenArgument            = &LocalHiddenArgument;
    ReadOnlyArgument          = &LocalReadOnlyArgument;
    SilentArgument            = &LocalSilentArgument;
    NoCopyArgument            = &LocalNoCopyArgument;
    StructureArgument         = &LocalStructureArgument;
    UpdateArgument            = &LocalUpdateArgument;
    CopyAttrArgument          = &LocalCopyAttrArgument;
    UseShortArgument          = &LocalUseShortArgument;
    ExclusionListArgument     = &LocalExclusionListArgument;
    InvalidSwitchArgument     = &LocalInvalidSwitchArgument;
    LexArray                  = &LocalLexArray;
    RestartableArgument       = &LocalRestartableArgument;
    OwnerArgument             = &LocalOwnerArgument;
    AuditArgument             = &LocalAuditArgument;

    //
    // Parse the arguments
    //
    GetArgumentsCmd();

    //
    // Verify the arguments
    //
    CheckArgumentConsistency();

    LocalLexArray.DeleteAllMembers();
}


VOID
GetSourceAndDestinationPath(
    IN OUT  PPATH_ARGUMENT      FirstPathArgument,
    IN OUT  PPATH_ARGUMENT      FirstQuotedPathArgument,
    IN OUT  PPATH_ARGUMENT      SecondPathArgument,
    IN OUT  PPATH_ARGUMENT      SecondQuotedPathArgument,
    IN OUT  PARGUMENT_LEXEMIZER ArgLex,
    OUT     PPATH*              SourcePath,
    OUT     PPATH*              DestinationPath
    )
/*++

Routine Description:

    This routine computes the Source and Destination path from
    the given list of arguments.

Arguments:

    FirstPathArgument           - Supplies the first unquoted path argument.
    FirstQuotedPathArgument     - Supplies the first quoted path argument.
    SecondPathArgument          - Supplies the second unquoted path argument.
    SecondQuotedPathArgument    - Supplies the second quoted path argument.
    ArgLex                      - Supplies the argument lexemizer.
    SourcePath                  - Returns the source path.
    DestinationPath             - Returns the destination path.

Return Value:

    None.

--*/
{
    BOOLEAN         f, qf, s, qs;
    PPATH_ARGUMENT  source, destination;
    ULONG           i;
    PWSTRING        string, qstring;

    f = FirstPathArgument->IsValueSet();
    qf = FirstQuotedPathArgument->IsValueSet();
    s = SecondPathArgument->IsValueSet();
    qs = SecondQuotedPathArgument->IsValueSet();
    source = NULL;
    destination = NULL;
    *SourcePath = NULL;
    *DestinationPath = NULL;

    if (f && !qf && s && !qs) {

        source = FirstPathArgument;
        destination = SecondPathArgument;

    } else if (!f && qf && !s && qs) {

        source = FirstQuotedPathArgument;
        destination = SecondQuotedPathArgument;

    } else if (f && qf && !s && !qs) {

        string = FirstPathArgument->GetLexeme();
        qstring = FirstQuotedPathArgument->GetLexeme();

        for (i = 0; i < ArgLex->QueryLexemeCount(); i++) {
            if (!ArgLex->GetLexemeAt(i)->Strcmp(string)) {
                source = FirstPathArgument;
                destination = FirstQuotedPathArgument;
                break;
            }

            if (!ArgLex->GetLexemeAt(i)->Strcmp(qstring)) {
                source = FirstQuotedPathArgument;
                destination = FirstPathArgument;
                break;
            }
        }
    } else if (f && !qf && !s && !qs) {
        source = FirstPathArgument;
    } else if (!f && qf && !s && !qs) {
        source = FirstQuotedPathArgument;
    }

    if (source) {
        if (!(*SourcePath = NEW PATH) ||
            !(*SourcePath)->Initialize(source->GetPath(),
                                       VerboseArgument->IsValueSet())) {

            *SourcePath = NULL;
        }
    }

    if (destination) {
        if (!(*DestinationPath = NEW PATH) ||
            !(*DestinationPath)->Initialize(destination->GetPath(),
                                            VerboseArgument->IsValueSet())) {

            *DestinationPath = NULL;
        }
    }
}



VOID
XCOPY::GetArgumentsCmd(
   )

/*++

Routine Description:

    Obtains the arguments from the Command line

Arguments:

    None.

Return Value:

    None.

--*/

{

    ARRAY               ArgArray;
    PATH_ARGUMENT       ProgramNameArgument;
    DSTRING             CmdLine;
    DSTRING             InvalidParms;
    WCHAR               Ch;
    PWSTRING            InvalidSwitch;
    PARGUMENT_LEXEMIZER ArgLex;

    //
    // Prepare for parsing
    //
    if (//
        // Initialize the arguments
        //
        !(CmdLine.Initialize( GetCommandLine() ))                   ||
        !(ArgArray.Initialize( 15, 15 ))                            ||
        !(ProgramNameArgument.Initialize( "*" ))                    ||
        !(FirstPathArgument->Initialize( "*",  FALSE ))             ||
        !(FirstQuotedPathArgument->Initialize( "\"*\"", FALSE ))    ||
        !(SecondPathArgument->Initialize( "*", FALSE))              ||
        !(SecondQuotedPathArgument->Initialize( "\"*\"", FALSE))    ||
        !(ArchiveArgument->Initialize( "/A" ))                      ||
        !(DateArgument->Initialize( "/D:*" ))                       ||
        !(OldArgument->Initialize( "/D" ))                          ||
        !(DecryptArgument->Initialize( "/G" ))                      ||
        !(EmptyArgument->Initialize( "/E" ))                        ||
        !(ModifyArgument->Initialize( "/M" ))                       ||
        !(PromptArgument->Initialize( "/P" ))                       ||
        !(OverWriteArgument->Initialize( "/Y" ))                    ||
        !(NotOverWriteArgument->Initialize( "/-Y" ))                ||
        !(SubdirArgument->Initialize( "/S" ))                       ||
        !(VerifyArgument->Initialize( "/V" ))                       ||
        !(WaitArgument->Initialize( "/W" ))                         ||
        !(HelpArgument->Initialize( "/?" ))                         ||
        !(ContinueArgument->Initialize( "/C" ))                     ||
        !(IntelligentArgument->Initialize( "/I" ))                  ||
        !(VerboseArgument->Initialize( "/F" ))                      ||
        !(HiddenArgument->Initialize( "/H" ))                       ||
        !(ReadOnlyArgument->Initialize( "/R" ))                     ||
        !(SilentArgument->Initialize( "/Q" ))                       ||
        !(NoCopyArgument->Initialize( "/L" ))                       ||
        !(StructureArgument->Initialize( "/T" ))                    ||
        !(UpdateArgument->Initialize( "/U" ))                       ||
        !(CopyAttrArgument->Initialize( "/K" ))                     ||
        !(UseShortArgument->Initialize( "/N" ))                     ||
        !(RestartableArgument->Initialize( "/Z" ))                  ||
        !(OwnerArgument->Initialize( "/O" ))                        ||
        !(AuditArgument->Initialize( "/X" ))                        ||
        !(ExclusionListArgument->Initialize("/EXCLUDE:*"))          ||
        !(InvalidSwitchArgument->Initialize( "/*" ))                ||
        //
        // Put the arguments in the argument array
        //
        !(ArgArray.Put( &ProgramNameArgument ))                     ||
        !(ArgArray.Put( ArchiveArgument ))                          ||
        !(ArgArray.Put( DateArgument ))                             ||
        !(ArgArray.Put( OldArgument ))                              ||
        !(ArgArray.Put( DecryptArgument ))                          ||
        !(ArgArray.Put( EmptyArgument ))                            ||
        !(ArgArray.Put( ModifyArgument ))                           ||
        !(ArgArray.Put( PromptArgument ))                           ||
        !(ArgArray.Put( OverWriteArgument ))                        ||
        !(ArgArray.Put( NotOverWriteArgument ))                     ||
        !(ArgArray.Put( SubdirArgument ))                           ||
        !(ArgArray.Put( VerifyArgument ))                           ||
        !(ArgArray.Put( WaitArgument ))                             ||
        !(ArgArray.Put( HelpArgument ))                             ||
        !(ArgArray.Put( ContinueArgument ))                         ||
        !(ArgArray.Put( IntelligentArgument ))                      ||
        !(ArgArray.Put( VerboseArgument ))                          ||
        !(ArgArray.Put( HiddenArgument ))                           ||
        !(ArgArray.Put( ReadOnlyArgument ))                         ||
        !(ArgArray.Put( SilentArgument ))                           ||
        !(ArgArray.Put( RestartableArgument ))                      ||
        !(ArgArray.Put( OwnerArgument ))                            ||
        !(ArgArray.Put( AuditArgument ))                            ||
        !(ArgArray.Put( NoCopyArgument ))                           ||
        !(ArgArray.Put( StructureArgument ))                        ||
        !(ArgArray.Put( UpdateArgument ))                           ||
        !(ArgArray.Put( CopyAttrArgument ))                         ||
        !(ArgArray.Put( UseShortArgument ))                         ||
        !(ArgArray.Put( ExclusionListArgument ))                    ||
        !(ArgArray.Put( InvalidSwitchArgument ))                    ||
        !(ArgArray.Put( FirstQuotedPathArgument ))                  ||
        !(ArgArray.Put( SecondQuotedPathArgument ))                 ||
        !(ArgArray.Put( FirstPathArgument ))                        ||
        !(ArgArray.Put( SecondPathArgument ))
        )  {

        DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR);
    }

    //
    // Parse the arguments
    //
    ArgLex = ParseArguments( &CmdLine, &ArgArray );

    if ( InvalidSwitchArgument->IsValueSet() ) {

        InvalidSwitch = InvalidSwitchArgument->GetString();

        InvalidParms.Initialize( SWITCH_CHARACTERS );

        Ch = InvalidSwitch->QueryChAt(0);

        if ( Ch == 'd' || Ch == 'D' ) {
            Ch = InvalidSwitch->QueryChAt(1);
            if ( Ch == INVALID_CHAR ) {
                DisplayMessageAndExit( XCOPY_ERROR_INVALID_NUMBER_PARAMETERS,
                                       NULL,
                                       EXIT_MISC_ERROR );
            } else if ( Ch != ':' || InvalidSwitch->QueryChCount() == 2 ) {
                DisplayMessageAndExit( XCOPY_ERROR_INVALID_SWITCH_SWITCH,
                                       InvalidSwitchArgument->GetLexeme(),
                                       EXIT_MISC_ERROR );
            }
        } else if ( Ch == '/' ) {
            Ch = InvalidSwitch->QueryChAt(1);
            if ( Ch == ':' && InvalidSwitchArgument->GetString()->QueryChAt(2) == INVALID_CHAR ) {
                InvalidSwitchArgument->GetLexeme()->Truncate(1);
            }
        }

        Ch = InvalidSwitch->QueryChAt(0);

        if ( InvalidParms.Strchr( Ch ) != INVALID_CHNUM ) {
            DisplayMessageAndExit( XCOPY_ERROR_INVALID_PARAMETER,
                                   InvalidSwitchArgument->GetLexeme(),
                                   EXIT_MISC_ERROR );
        } else {
            DisplayMessageAndExit( XCOPY_ERROR_INVALID_SWITCH_SWITCH,
                                   InvalidSwitchArgument->GetLexeme(),
                                   EXIT_MISC_ERROR );
        }
    }

    //
    // Set the switches
    //
    _EmptySwitch    =   EmptyArgument->QueryFlag();
    _ModifySwitch   =   ModifyArgument->QueryFlag();

    //
    // ModifySwitch implies ArchiveSwitch
    //
    if ( _ModifySwitch ) {
        _ArchiveSwitch = TRUE;
    } else {
        _ArchiveSwitch =  ArchiveArgument->QueryFlag();
    }

    //
    //  Set the switches
    //
    _PromptSwitch       =   PromptArgument->QueryFlag();
    _OverWriteSwitch    =   QueryOverWriteSwitch();
    _SubdirSwitch       =   SubdirArgument->QueryFlag();
    _VerifySwitch       =   VerifyArgument->QueryFlag();
    _WaitSwitch         =   WaitArgument->QueryFlag();
    _ContinueSwitch     =   ContinueArgument->QueryFlag();
    _IntelligentSwitch  =   IntelligentArgument->QueryFlag();
    _CopyIfOldSwitch    =   OldArgument->QueryFlag();
    _DecryptSwitch      =   DecryptArgument->QueryFlag();
    _VerboseSwitch      =   VerboseArgument->QueryFlag();
    _HiddenSwitch       =   HiddenArgument->QueryFlag();
    _ReadOnlySwitch     =   ReadOnlyArgument->QueryFlag();
    _SilentSwitch       =   SilentArgument->QueryFlag();
    _DontCopySwitch     =   NoCopyArgument->QueryFlag();
    _StructureOnlySwitch=   StructureArgument->QueryFlag();
    _UpdateSwitch       =   UpdateArgument->QueryFlag();
    _CopyAttrSwitch     =   CopyAttrArgument->QueryFlag();
    _UseShortSwitch     =   UseShortArgument->QueryFlag();
    _RestartableSwitch  =   RestartableArgument->QueryFlag();
    _OwnerSwitch        =   OwnerArgument->QueryFlag();
    _AuditSwitch        =   AuditArgument->QueryFlag();
    HelpSwitch          =   HelpArgument->QueryFlag();


    //
    // Set the source and destination paths.  Argument checking is
    // done somewhere else, so it is ok. to set the source path to
    // NULL here.
    //
    GetSourceAndDestinationPath(FirstPathArgument,
                                FirstQuotedPathArgument,
                                SecondPathArgument,
                                SecondQuotedPathArgument,
                                ArgLex,
                                &_SourcePath,
                                &_DestinationPath);

    DELETE(ArgLex);

    //
    // Set the date argument
    //

    if ( DateArgument->IsValueSet() ) {

        if ((_Date = NEW TIMEINFO) == NULL ) {

            DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
        }

        _Date->Initialize( DateArgument->GetTimeInfo() );

        //
        //  The command-line date argument is specified in local time so
        //  that it corresponds to the output of 'dir'.  We want to compare
        //  it to file timestamps that we query from the file system, so
        //  convert the argument from local to universal time.
        //

        _Date->ConvertToUTC();

    } else {

        _Date = NULL;
    }

    if( ExclusionListArgument->IsValueSet() ) {

        InitializeExclusionList( ExclusionListArgument->GetString() );
    }
}

PARGUMENT_LEXEMIZER
XCOPY::ParseArguments(
    IN PWSTRING CmdLine,
    OUT PARRAY     ArgArray
    )

/*++

Routine Description:

    Parses a group of arguments

Arguments:

    CmdLine  -  Supplies pointer to a command line to parse
    ArgArray -  Supplies pointer to array of arguments

Return Value:

    Returns the argument lexemizer used which then needs to be freed
    by the client.

Notes:

--*/

{
    PARGUMENT_LEXEMIZER  ArgLex;

    //
    // Initialize lexeme array and the lexemizer.
    //
    if ( !(ArgLex = NEW ARGUMENT_LEXEMIZER) ||
         !(LexArray->Initialize( 9, 9 )) ||
         !(ArgLex->Initialize( LexArray )) ) {

        DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY,
                               NULL,
                               EXIT_MISC_ERROR );
    }

    //
    // Set our parsing preferences
    //
    ArgLex->PutMultipleSwitch( "/?ABMDPSEVWCIFHRQLKTUNZOXY" );
    ArgLex->PutSwitches( "/" );
    ArgLex->SetCaseSensitive( FALSE );
    ArgLex->PutSeparators( " \t" );
    ArgLex->PutStartQuotes( "\"" );
    ArgLex->PutEndQuotes( "\"" );
    ArgLex->SetAllowSwitchGlomming( TRUE );
    ArgLex->SetNoSpcBetweenDstAndSwitch( TRUE );

    //
    // Parse the arguments
    //
    if ( !(ArgLex->PrepareToParse( CmdLine ))) {

        DisplayMessageAndExit( XCOPY_ERROR_PARSE,
                               NULL,
                               EXIT_MISC_ERROR );

    }

    if ( !ArgLex->DoParsing( ArgArray ) ) {

        DisplayMessageAndExit( XCOPY_ERROR_INVALID_NUMBER_PARAMETERS,
                               NULL,
                               EXIT_MISC_ERROR );
    }

    return ArgLex;
}

VOID
XCOPY::CheckArgumentConsistency (
    )

/*++

Routine Description:

   Checks the consistency of the arguments

Arguments:

   none

Return Value:

   none

Notes:

--*/

{
    PFSN_DIRECTORY      DirSrc = NULL;
    PFSN_DIRECTORY      DirDst = NULL;
    PWSTRING            DevSrc = NULL;
    PWSTRING            DevDst = NULL;
    PATH                PathSrc, PathSrc1;
    PATH                PathDst, PathDst1;
    DSTRING             Slash;

    if ( HelpSwitch ) {
        //
        // Help requested
        //
        Usage();
        DisplayMessageAndExit( 0,
                               NULL,
                               EXIT_NORMAL );
    }


    //
    // Make sure that we have a source path
    //
    if ( _SourcePath == NULL ) {

        DisplayMessageAndExit( XCOPY_ERROR_INVALID_NUMBER_PARAMETERS,
                               NULL,
                               EXIT_MISC_ERROR );
    }

    //
    //  The empty switch implies Subdir switch (note that DOS
    //  requires Subdir switch explicitly).
    //
    //
    if ( _EmptySwitch ) {
        _SubdirSwitch = TRUE;
    }


    //
    //  The StructureOnly switch imples the subdir switch
    //
    if ( _StructureOnlySwitch ) {
        _SubdirSwitch = TRUE;
    }

    //
    //  Copying audit info implies copying the rest of the security
    //  info.
    //

    _OwnerSwitch = _OwnerSwitch || _AuditSwitch;

    //
    //  Restartable copy is not available with security because
    //  secure copy uses BackupRead/Write instead of CopyFileEx.
    //

    if (_OwnerSwitch && _RestartableSwitch) {

        DisplayMessageAndExit( XCOPY_ERROR_Z_X_CONFLICT, NULL, EXIT_MISC_ERROR );
    }

    //
    // If destination path is null, then the destination path is the
    // current directory
    //
    if ( _DestinationPath == NULL ) {

        if ( ((_DestinationPath = NEW PATH) == NULL ) ||
            !_DestinationPath->Initialize( (LPWSTR)L".", TRUE ) ) {

            DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
        }
    }

    _DestinationPath->TruncateNameAtColon();

    if ( !PathSrc1.Initialize( _SourcePath, TRUE )      ||
         !PathDst1.Initialize( _DestinationPath, TRUE ) ||
         !(DevSrc = PathSrc1.QueryDevice())             ||
         !(DevDst = PathDst1.QueryDevice())             ||
         !PathSrc.Initialize( DevSrc )                  ||
         !PathDst.Initialize( DevDst )                  ||
         !Slash.Initialize( "\\" )                      ||
         !PathSrc.AppendBase( &Slash )                  ||
         !PathDst.AppendBase( &Slash )                  ||
         !(DirSrc = SYSTEM::QueryDirectory( &PathSrc )) ||
         !(DirDst = SYSTEM::QueryDirectory( &PathDst )) ) {
        DisplayMessageAndExit( XCOPY_ERROR_INVALID_DRIVE, NULL, EXIT_MISC_ERROR );
    }
    DELETE( DevSrc );
    DELETE( DevDst );
    DELETE( DirSrc );
    DELETE( DirDst );
}

BOOLEAN
XCOPY::AddToExclusionList(
    IN  PWSTRING   ExclusionListFileName
    )
/*++

Routine Description:

    This method adds the contents of the specified file to
    the exclusion list.

Arguments:

    ExclusionListFileName   --  Supplies the name of a file which
                                contains the exclusion list.

Return Value:

    TRUE upon successful completion.

--*/
{
    PATH            ExclusionPath;
    PDSTRING        String;
    PFSN_FILE       File;
    PFILE_STREAM    Stream;
    CHNUM           Position;

    DebugPtrAssert( ExclusionListFileName );

    if( !ExclusionPath.Initialize( ExclusionListFileName ) ||
        (File = SYSTEM::QueryFile( &ExclusionPath )) == NULL ||
        (Stream = File->QueryStream( READ_ACCESS )) == NULL ) {

        DisplayMessageAndExit( MSG_COMP_UNABLE_TO_READ,
                               ExclusionListFileName,
                               EXIT_MISC_ERROR );
    }

    while( !Stream->IsAtEnd() &&
           (String = NEW DSTRING) != NULL &&
           Stream->ReadLine ( String ) ) {

        if( String->QueryChCount() == 0 ) {

            continue;
        }

        // Convert the string to upper-case and remove
        // trailing whitespace (blanks and tabs).
        //
        String->Strupr();
        Position = String->QueryChCount() - 1;

        while( Position != 0 &&
               (String->QueryChAt( Position ) == ' ' ||
                String->QueryChAt( Position ) == '\t') ) {

            Position -= 1;
        }

        if( String->QueryChAt( Position ) != ' ' &&
            String->QueryChAt( Position ) != '\t' ) {

            Position++;
        }

        if( Position != String->QueryChCount() ) {

            String->Truncate( Position );
        }

        if( String->QueryChCount() != 0 && !_ExclusionList->Put( String ) ) {

            DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY,
                                   NULL,
                                   EXIT_MISC_ERROR );
        }
    }

    DELETE( Stream );
    DELETE( File );
    return TRUE;
}

BOOLEAN
XCOPY::InitializeExclusionList(
    IN  PWSTRING   ListOfFiles
    )
/*++

Routine Description:

    This method reads the exclusion list and initializes the
    exclusion list array.

Arguments:

    ListOfFiles --  Supplies a string containing a list of file
                    names, separated by '+' (e.g. file1+file2+file3)

Return Value:

    TRUE upon successful completion.

--*/
{
    DSTRING CurrentName;
    CHNUM   LastPosition, Position;

    DebugPtrAssert( ListOfFiles );

    if( (_ExclusionList = NEW STRING_ARRAY) == NULL ||
        !_ExclusionList->Initialize() ||
        (_Iterator = _ExclusionList->QueryIterator()) == NULL ) {

        DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
    }

    LastPosition = 0;

    while( LastPosition != ListOfFiles->QueryChCount() ) {

        Position = ListOfFiles->Strchr( '+', LastPosition );

        if( Position == INVALID_CHNUM ) {

            Position = ListOfFiles->QueryChCount();
        }

        if( Position != LastPosition ) {

            if( !CurrentName.Initialize( ListOfFiles,
                                         LastPosition,
                                         Position - LastPosition ) ) {

                DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY,
                                       NULL,
                                       EXIT_MISC_ERROR );
            }

            AddToExclusionList( &CurrentName );
        }

        // Advance past any separators.
        //
        while( Position < ListOfFiles->QueryChCount() &&
               ListOfFiles->QueryChAt( Position ) == '+' ) {

            Position += 1;
        }

        LastPosition = Position;
    }

    return TRUE;
}

BOOLEAN
XCOPY::QueryOverWriteSwitch(
    )
{
    PCHAR       env;
    DSTRING     env_str;

    if (OverWriteArgument->IsValueSet() && NotOverWriteArgument->IsValueSet()) {
        return (OverWriteArgument->QueryArgPos() > NotOverWriteArgument->QueryArgPos());
    } else if (OverWriteArgument->IsValueSet())
        return OverWriteArgument->QueryFlag();
    else if (NotOverWriteArgument->IsValueSet())
        return !NotOverWriteArgument->QueryFlag();
    else {
        env = getenv("COPYCMD");
        if (env == NULL)
            return FALSE;   // use default
        else {
            if (!env_str.Initialize(env))
                return FALSE;   // to be on the safe side
            if (env_str.Stricmp(OverWriteArgument->GetPattern()) == 0)
                return TRUE;
            return FALSE;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\wintools\clb\dlgedit.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    Dlgedit.c

Abstract:

    This file contains the intrfaces necessary to use the ColumnListBox
    (clb.dll) custom control with the Dialog Editor (dlgedit.exe).

Author:

    David J. Gilman (davegi) 05-Feb-1993

Environment:

    User Mode

--*/

#include "clb.h"
#include "dialogs.h"

#include <custcntl.h>

#include <strsafe.h>

typedef struct _ID_STYLE_MAP 
{
    UINT    Id;
    UINT    Style;

}
ID_STYLE_MAP, *LPID_STYLE_MAP;

//
// Module handle for Clb.dll.
//

extern
HINSTANCE   _hModule;

//
// Default values.
//

#define CLB_DESCRIPTION     L"ColumnListBox"
#define CLB_DEFAULT_TEXT    L"Column1;Column2;Column3"
#define CLB_DEFAULT_WIDTH   ( 96 )
#define CLB_DEFAULT_HEIGHT  ( 80 )

//
// Macro to initialize CCSTYLEFLAGW structure.
//

#define MakeStyle( s, m )                                                   \
    {( s ), ( m ), L#s }

//
// Table of supported styles.
//

CCSTYLEFLAGW
Styles[ ] = {

    MakeStyle( CLBS_NOTIFY,             0 ),
    MakeStyle( CLBS_SORT,               0 ),
    MakeStyle( CLBS_DISABLENOSCROLL,    0 ),
    MakeStyle( CLBS_VSCROLL,            0 ),
    MakeStyle( CLBS_BORDER,             0 ),
    MakeStyle( CLBS_POPOUT_HEADINGS,    0 ),
    MakeStyle( CLBS_SPRINGY_COLUMNS,    0 ),
    MakeStyle( LBS_OWNERDRAWFIXED,      0 )
};

//
// Table of check box ids and their represented styles.
//

ID_STYLE_MAP
StyleCheckBox[ ] = {

    IDC_CHECK_NOTIFY,                   CLBS_NOTIFY,
    IDC_CHECK_SORT,                     CLBS_SORT,
    IDC_CHECK_DISABLENOSCROLL,          CLBS_DISABLENOSCROLL,
    IDC_CHECK_VSCROLL,                  CLBS_VSCROLL,
    IDC_CHECK_BORDER,                   CLBS_BORDER,
    IDC_CHECK_POPOUT_HEADINGS,          CLBS_POPOUT_HEADINGS,
    IDC_CHECK_SPRINGY_COLUMNS,          CLBS_SPRINGY_COLUMNS,
    IDC_CHECK_VISIBLE,                  WS_VISIBLE,
    IDC_CHECK_DISABLED,                 WS_DISABLED,
    IDC_CHECK_GROUP,                    WS_GROUP,
    IDC_CHECK_TABSTOP,                  WS_TABSTOP
};

//
// Table of check box ids and their represented standard styles.
//

ID_STYLE_MAP
StandardStyleCheckBox[ ] = {

    IDC_CHECK_NOTIFY,                   CLBS_NOTIFY,
    IDC_CHECK_SORT,                     CLBS_SORT,
    IDC_CHECK_VSCROLL,                  CLBS_VSCROLL,
    IDC_CHECK_BORDER,                   CLBS_BORDER
};

BOOL
ClbStyleW(
         IN HWND hwndParent,
         IN LPCCSTYLEW pccs
         );

INT_PTR
ClbStylesDlgProc(
                IN HWND hWnd,
                IN UINT message,
                IN WPARAM wParam,
                IN LPARAM lParam
                )

/*++

Routine Description:

    ClbStylesDlgProc is the dialog procedure for the styles dialog. It lets
    a user select what styles should be applied to the Clb when it is created.

Arguments:

    Standard dialog procedure parameters.

Return Value:

    BOOL - dependent on the supplied message.

--*/

{
    BOOL        Success;

    static
    LPCCSTYLEW  pccs;

    switch ( message ) {

        case WM_INITDIALOG:
            {
                DWORD   i;

                //
                // Save the pointer to the Custom Control Style structure.
                //

                pccs = ( LPCCSTYLEW ) lParam;

                //
                // For each style bit, if the style bit is set, check
                // the associated button.
                //

                for ( i = 0; i < NumberOfEntries( StyleCheckBox ); i++ ) {

                    if ( pccs->flStyle & StyleCheckBox[ i ].Style ) {

                        Success = CheckDlgButton( hWnd, StyleCheckBox[ i ].Id, ( UINT ) ~0 );
                        DbgAssert( Success );
                    }
                }

                //
                // If all of the styles making up the standard are checked, check
                // the standard button as well.
                //

                Success = CheckDlgButton(
                                        hWnd,
                                        IDC_CHECK_STANDARD,
                                        IsDlgButtonChecked( hWnd, IDC_CHECK_NOTIFY    )
                                        & IsDlgButtonChecked( hWnd, IDC_CHECK_SORT      )
                                        & IsDlgButtonChecked( hWnd, IDC_CHECK_VSCROLL   )
                                        & IsDlgButtonChecked( hWnd, IDC_CHECK_BORDER    )
                                        );
                DbgAssert( Success );

                return TRUE;
            }

        case WM_COMMAND:

            switch ( LOWORD( wParam )) {

                //
                // Update standard style checkboxes as soon as the standard style check
                // box is clicked.
                //

                case IDC_CHECK_STANDARD:
                    {
                        switch ( HIWORD( wParam )) {

                            case BN_CLICKED:
                                {
                                    UINT    Check;
                                    DWORD   i;

                                    //
                                    // If the standard style check box is checked, check all
                                    // of the standard styles checkboxes, otherwise clear
                                    // (uncheck) them.
                                    //

                                    Check =   ( IsDlgButtonChecked( hWnd, LOWORD(wParam )))
                                              ? ( UINT ) ~0
                                              : ( UINT ) 0;

                                    for ( i = 0; i < NumberOfEntries( StandardStyleCheckBox ); i++ ) {

                                        Success = CheckDlgButton(
                                                                hWnd,
                                                                StandardStyleCheckBox[ i ].Id,
                                                                Check
                                                                );
                                        DbgAssert( Success );
                                    }

                                    return TRUE;
                                }
                        }
                        break;
                    }
                    break;

                case IDC_CHECK_NOTIFY:
                case IDC_CHECK_SORT:
                case IDC_CHECK_VSCROLL:
                case IDC_CHECK_BORDER:
                    {
                        switch ( HIWORD( wParam )) {

                            case BN_CLICKED:
                                {
                                    //
                                    // If all of the styles making up the standard are checked, check
                                    // the standard button as well.
                                    //

                                    Success = CheckDlgButton(
                                                            hWnd,
                                                            IDC_CHECK_STANDARD,
                                                            IsDlgButtonChecked( hWnd, IDC_CHECK_NOTIFY    )
                                                            & IsDlgButtonChecked( hWnd, IDC_CHECK_SORT      )
                                                            & IsDlgButtonChecked( hWnd, IDC_CHECK_VSCROLL   )
                                                            & IsDlgButtonChecked( hWnd, IDC_CHECK_BORDER    )
                                                            );
                                    DbgAssert( Success );


                                    return TRUE;
                                }
                        }
                        break;
                    }
                    break;

                case IDOK:
                    {
                        DWORD   i;

                        //
                        // For each possible style, if the user checked the button, set
                        // the associated style bit.
                        //

                        for ( i = 0; i < NumberOfEntries( StyleCheckBox ); i++ ) {

                            switch ( IsDlgButtonChecked( hWnd, StyleCheckBox[ i ].Id )) {

                                case 0:

                                    //
                                    // Button was unchecked, disable the style.
                                    //

                                    pccs->flStyle &= ~StyleCheckBox[ i ].Style;

                                    break;

                                case 1:

                                    //
                                    // Button was checked, enable the style.
                                    //

                                    pccs->flStyle |= StyleCheckBox[ i ].Style;

                                    break;

                                default:

                                    DbgAssert( FALSE );

                                    break;
                            }
                        }

                        //
                        // Return TRUE via EndDialog which will cause Dlgedit
                        // to apply the style changes.
                        //

                        return EndDialog( hWnd, ( int ) TRUE );
                    }

                case IDCANCEL:

                    //
                    // Return FALSE via EndDialog which will cause Dlgedit
                    // to ignore the style changes.
                    //

                    return EndDialog( hWnd, ( int ) FALSE );

            }
            break;
    }

    return FALSE;
}

UINT
CustomControlInfoW(
                  IN LPCCINFOW CcInfo OPTIONAL
                  )

/*++

Routine Description:

    CustomControlInfoW is called by Dlgedit to query (a) the number of
    custom controls supported by this Dll and (b) characteristics about each of
    those controls.

Arguments:

    CcInfo  - Supplies an optional pointer to an array of CCINFOW structures.
              If the pointer is NULL CustomControlInfoW returns the number of
              controls supported by this Dll. Otherwise each member of the
              array is initialized.

Return Value:

    BOOL    - Returns TRUE if the file names were succesfully added.

--*/

{
    if ( CcInfo != NULL ) {

        //
        // Clb's class name.
        //

        StringCchCopyW(CcInfo->szClass, ARRAYSIZE(CcInfo->szClass), CLB_CLASS_NAME);

        //
        // No options (i.e. text is allowed).
        //

        CcInfo->flOptions = 0;

        //
        // Quick and dirty description of Clb.
        //

        StringCchCopyW(CcInfo->szDesc, ARRAYSIZE(CcInfo->szDesc), CLB_DESCRIPTION);

        //
        // Clb's default width.
        //

        CcInfo->cxDefault = CLB_DEFAULT_WIDTH;

        //
        // Clb's default height.
        //

        CcInfo->cyDefault = CLB_DEFAULT_HEIGHT;

        //
        // Clb's default styles. LBS_OWNERDRAWFIXED is needed in order to make
        // certain messages work properly (e.g. LB_FINDSTRING).
        //

        CcInfo->flStyleDefault =   CLBS_STANDARD
                                   | LBS_OWNERDRAWFIXED
                                   | WS_VISIBLE
                                   | WS_TABSTOP
                                   | WS_CHILD;

        //
        // No extended styles.
        //

        CcInfo->flExtStyleDefault = 0;

        //
        // No control specific styles.
        //

        CcInfo->flCtrlTypeMask = 0;

        //
        // Clb's default text (column headings).
        //

        StringCchCopyW(CcInfo->szTextDefault, ARRAYSIZE(CcInfo->szTextDefault), CLB_DEFAULT_TEXT);

        //
        // Number of styles supported by Clb.
        //

        CcInfo->cStyleFlags = NumberOfEntries( Styles );

        //
        // Clb's array of styles (CCSTYLEGLAGW)
        //

        CcInfo->aStyleFlags = Styles;

        //
        // Clb's styles dialog function.
        //

        CcInfo->lpfnStyle = ClbStyleW;

        //
        // No SizeToText function.
        //

        CcInfo->lpfnSizeToText = NULL;

        //
        // Reserved, must be zero.
        //

        CcInfo->dwReserved1 = 0;
        CcInfo->dwReserved2 = 0;
    }

    //
    // Tell Dlgedit that clb.dll only supports 1 control.
    //

    return 1;
}

BOOL
ClbStyleW(
         IN HWND hWndParent,
         IN LPCCSTYLEW pccs
         )

/*++

Routine Description:

    ClbStyleW is the function that is exported to, and used by, Dlgedit so that
    Clb's styles can be editted.

Arguments:

    hWndParent  - Supplies ahandle to the dialog's parent (i.e. Dlgedit).
    pccs        - Supplies a pointer to the Custom Control Style structure.

Return Value:

    BOOL        - Returns the results of the styles dialog.

--*/

{
    return ( BOOL ) DialogBoxParam(
                                  _hModule,
                                  MAKEINTRESOURCE( IDD_CLB ),
                                  hWndParent,
                                  ClbStylesDlgProc,
                                  ( LPARAM ) pccs
                                  );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fs\utils\xcopy\xcopy.cxx ===
/*++

Copyright (c) 1990-2001 Microsoft Corporation

Module Name:

        XCopy.cxx

Abstract:

        Xcopy is a DOS5-Compatible directory copy utility

Author:

        Ramon Juan San Andres (ramonsa) 01-May-1991

Revision History:

--*/

#define _NTAPI_ULIB_

#include "ulib.hxx"
#include "array.hxx"
#include "arrayit.hxx"
#include "dir.hxx"
#include "file.hxx"
#include "filter.hxx"
#include "stream.hxx"
#include "system.hxx"
#include "xcopy.hxx"
#include "bigint.hxx"
#include "ifssys.hxx"
#include "stringar.hxx"
#include "arrayit.hxx"

extern "C" {
   #include <ctype.h>
   #include "winbasep.h"
}


#define CTRL_C          (WCHAR)3



int __cdecl
main (
        )

/*++

Routine Description:

        Main function of the XCopy utility

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
    //
    //  Initialize stuff
    //
    DEFINE_CLASS_DESCRIPTOR( XCOPY );

    //
    //  Now do the copy
    //
    {
        __try {

            XCOPY XCopy;

            //
            //  Initialize the XCOPY object.
            //
            if ( XCopy.Initialize() ) {

                __try {
                //
                //  Do the copy
                //

                    XCopy.DoCopy();

                } __except ((_exception_code() == STATUS_STACK_OVERFLOW) ?
                            EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {

                    // display may not work due to out of stack space

                    XCopy.DisplayMessageAndExit(XCOPY_ERROR_STACK_SPACE, NULL, EXIT_MISC_ERROR);

                }
            }

        } __except ((_exception_code() == STATUS_STACK_OVERFLOW) ?
                    EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {

            // may not be able to display anything if initialization failed
            // in additional to out of stack space
            // so just send a message to the debug port

            DebugPrintTrace(("XCOPY: Out of stack space\n"));
            return EXIT_MISC_ERROR;

        }
    }

    return EXIT_NORMAL;
}



DEFINE_CONSTRUCTOR( XCOPY,      PROGRAM );

VOID
XCOPY::Construct (
    )
{
    _Keyboard           = NULL;
    _TargetPath         = NULL;
    _SourcePath         = NULL;
    _DestinationPath    = NULL;
    _Date               = NULL;
    _FileNamePattern    = NULL;
    _ExclusionList      = NULL;
    _Iterator           = NULL;
}




BOOLEAN
XCOPY::Initialize (
        )

/*++

Routine Description:

        Initializes the XCOPY object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
        //
        //      Initialize program object
        //
        if( !PROGRAM::Initialize( XCOPY_MESSAGE_USAGE ) ) {

            return FALSE;
        }

        //
        //      Allocate resources
        //
        InitializeThings();

        //
        //      Parse the arguments
        //
        SetArguments();


        return TRUE;
}

XCOPY::~XCOPY (
        )

/*++

Routine Description:

        Destructs an XCopy object

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
        //
        //      Deallocate the global structures previously allocated
        //
        DeallocateThings();

        //
        //      Exit without error
        //
        if( _Standard_Input  != NULL &&
            _Standard_Output != NULL ) {

            DisplayMessageAndExit( 0, NULL, EXIT_NORMAL );
        }

}

VOID
XCOPY::InitializeThings (
        )

/*++

Routine Description:

        Initializes the global variables that need initialization

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{

        //
        //      Get a keyboard, because we will need to switch back and
        //      forth between raw and cooked mode and because we need
        //      to enable ctrl-c handling (so that we can exit with
        //      the right level if the program is interrupted).
        //
        if ( !( _Keyboard = KEYBOARD::Cast(GetStandardInput()) )) {
                //
                //      Not reading from standard input, we will get
                //      the real keyboard.
                //
                _Keyboard = NEW KEYBOARD;

                if( !_Keyboard ) {

                    exit(4);
                }

                _Keyboard->Initialize();

        }

        //
        //      Set Ctrl-C handler
        //
        _Keyboard->EnableBreakHandling();

        //
        //      Initialize our internal data
        //
        _FilesCopied                = 0;
        _CanRemoveEmptyDirectories  = TRUE;
        _TargetIsFile               = FALSE;
        _TargetPath                 = NULL;
        _SourcePath                 = NULL;
        _DestinationPath            = NULL;
        _Date                       = NULL;
        _FileNamePattern            = NULL;
        _ExclusionList              = NULL;
        _Iterator                   = NULL;

        // The following switches are being used by DisplayMessageAndExit
        // before any of those boolean _*Switch is being initialized

        _DontCopySwitch             = FALSE;
        _StructureOnlySwitch        = TRUE;
}

VOID
XCOPY::DeallocateThings (
        )

/*++

Routine Description:

        Deallocates the stuff that was initialized in InitializeThings()

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
        //
        //      Deallocate local data
        //
        DELETE( _TargetPath );
        DELETE( _SourcePath );
        DELETE( _DestinationPath );
        DELETE( _Date );
        DELETE( _FileNamePattern );
        DELETE( _Iterator );

        if( _ExclusionList ) {

            _ExclusionList->DeleteAllMembers();
        }

        DELETE( _ExclusionList );

        //
        //      Reset Ctrl-C handleing
        //
        _Keyboard->DisableBreakHandling();

        //
        //      If standard input is not the keyboard, we get rid of
        //      the keyboard object.
        //
        if ( !(_Keyboard == KEYBOARD::Cast(GetStandardInput()) )) {
                DELETE( _Keyboard );
        }
}


STATIC BOOLEAN
GetTokenHandle(
    IN OUT PHANDLE TokenHandle
    )
/*++

Routine Description:

    This routine opens the current process object and returns a
    handle to its token.

Arguments:


Return Value:

    FALSE           - Failure.
    TRUE            - Success.

--*/
{
    HANDLE ProcessHandle;
    BOOL Result;

    ProcessHandle = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE,
        GetCurrentProcessId());

    if (ProcessHandle == NULL)
        return(FALSE);


    Result = OpenProcessToken(ProcessHandle,
        TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, TokenHandle);

    CloseHandle(ProcessHandle);

    return Result != FALSE;
}

STATIC BOOLEAN
SetPrivs(
    IN HANDLE TokenHandle,
    IN LPTSTR lpszPriv
)
/*++

Routine Description:

    This routine enables the given privilege in the given token.

Arguments:



Return Value:

    FALSE                       - Failure.
    TRUE                        - Success.

--*/
{
    LUID SetPrivilegeValue;
    TOKEN_PRIVILEGES TokenPrivileges;


    //
    // First, find out the value of the privilege
    //

    if (!LookupPrivilegeValue(NULL, lpszPriv, &SetPrivilegeValue)) {
        return FALSE;
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0].Luid = SetPrivilegeValue;
    TokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(TokenHandle, FALSE, &TokenPrivileges,
        sizeof(TOKEN_PRIVILEGES), NULL, NULL)) {

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
XCOPY::DoCopy (
        )

/*++

Routine Description:

        This is the function that performs the XCopy.

Arguments:

    None.

Return Value:

    None.

Notes:

--*/

{
    PFSN_DIRECTORY      SourceDirectory         = NULL;
    PFSN_DIRECTORY      DestinationDirectory    = NULL;
    PFSN_DIRECTORY      PartialDirectory        = NULL;
    PATH                PathToDelete;
    WCHAR               Char;
    CHNUM               CharsInPartialDirectoryPath;
    BOOLEAN             DirDeleted;
    BOOLEAN             CopyingManyFiles;
    PATH                TmpPath;
    PFSN_FILTER         FileFilter              = NULL;
    PFSN_FILTER         DirectoryFilter         = NULL;
    WIN32_FIND_DATA     FindData;
    PWSTRING Device                  = NULL;
    HANDLE              FindHandle;

    //
    //      Make sure that we won't try to copy to ourselves
    //
    if ( _SubdirSwitch && IsCyclicalCopy( _SourcePath, _DestinationPath ) ) {

        DisplayMessageAndExit( XCOPY_ERROR_CYCLE, NULL, EXIT_MISC_ERROR );
    }

    AbortIfCtrlC();

    //
    //  Get the source directory object and the filename that we will be
    //  matching.
    //
    GetDirectoryAndFilters( _SourcePath, &SourceDirectory, &FileFilter, &DirectoryFilter, &CopyingManyFiles );

    //
    //      Make sure that we won't try to copy to ourselves
    //
    if ( _SubdirSwitch && IsCyclicalCopy( (PPATH)SourceDirectory->GetPath(), _DestinationPath ) ) {

        DisplayMessageAndExit( XCOPY_ERROR_CYCLE, NULL, EXIT_MISC_ERROR );
    }

    DebugPtrAssert( SourceDirectory );
    DebugPtrAssert( FileFilter );
    DebugPtrAssert( DirectoryFilter );

    if ( _WaitSwitch ) {

        //      Pause before we start copying.
        //
        DisplayMessage( XCOPY_MESSAGE_WAIT );

        AbortIfCtrlC();

        //
        //      All input is in raw mode.
        //
        _Keyboard->DisableLineMode();
        if( GetStandardInput()->IsAtEnd() ) {
            // Insufficient input--treat as CONTROL-C.
            //
            Char = ' ';
        } else {
            GetStandardInput()->ReadChar( &Char );
        }
        _Keyboard->EnableLineMode();

        if ( Char == CTRL_C ) {
            exit ( EXIT_TERMINATED );
        } else {
            GetStandardOutput()->WriteChar( Char );
            GetStandardOutput()->WriteChar( (WCHAR)'\r');
            GetStandardOutput()->WriteChar( (WCHAR)'\n');
        }
    }

    //
    //  Get the destination directory and the file pattern.
    //
    GetDirectoryAndFilePattern( _DestinationPath, CopyingManyFiles, &_TargetPath, &_FileNamePattern );

    DebugPtrAssert( _TargetPath );
    DebugPtrAssert( _FileNamePattern );

    //
    //      Get as much of the destination directory as possible.
    //
    if ( !_DontCopySwitch ) {
        PartialDirectory = SYSTEM::QueryDirectory( _TargetPath, TRUE );

        if (PartialDirectory == NULL ) {

            DisplayMessageAndExit( XCOPY_ERROR_CREATE_DIRECTORY, NULL, EXIT_MISC_ERROR );

        }

        //
        //  All the directories up to the parent of the target have to exist. If
        //  they don't, we have to create them.
        //
        if ( *(PartialDirectory->GetPath()->GetPathString()) ==
             *(_TargetPath->GetPathString()) ) {

            DestinationDirectory = PartialDirectory;

        } else {

            TmpPath.Initialize( _TargetPath );
            if( !_TargetIsFile ) {
                TmpPath.TruncateBase();
            }
            DestinationDirectory = PartialDirectory->CreateDirectoryPath( &TmpPath );
        }

        if( !DestinationDirectory ) {

            DisplayMessageAndExit( XCOPY_ERROR_INVALID_PATH, NULL, EXIT_MISC_ERROR );
        }


        //
        //  Determine if destination if floppy
        //
        Device = _TargetPath->QueryDevice();
        if ( Device ) {
            _DisketteCopy = (SYSTEM::QueryDriveType( Device ) == RemovableDrive);
            DELETE( Device );
        }
    }

    if (_OwnerSwitch) {

        HANDLE hToken;

        // Enable the privileges necessary to copy security information.

        if (!GetTokenHandle(&hToken)) {
            DisplayMessageAndExit(XCOPY_ERROR_NO_MEMORY,
                NULL, EXIT_MISC_ERROR );
        }
        SetPrivs(hToken, TEXT("SeBackupPrivilege"));
        SetPrivs(hToken, TEXT("SeRestorePrivilege"));
        SetPrivs(hToken, TEXT("SeSecurityPrivilege"));
        SetPrivs(hToken, TEXT("SeTakeOwnershipPrivilege"));
    }

    //
    //      Now traverse the source directory.
    //
    TmpPath.Initialize( _TargetPath );


    if (!_UpdateSwitch) {


        Traverse( SourceDirectory,
                  &TmpPath,
                  FileFilter,
                  DirectoryFilter,
                  !SourceDirectory->GetPath()->GetPathString()->Strcmp(
                      _SourcePath->GetPathString()));

    } else {

        PATH DestDirectoryPath;
        PFSN_DIRECTORY DestDirectory;

        DestDirectoryPath.Initialize(&TmpPath);
        DestDirectory = SYSTEM::QueryDirectory(&DestDirectoryPath);

        TmpPath.Initialize(SourceDirectory->GetPath());

        UpdateTraverse( DestDirectory,
                        &TmpPath,
                        FileFilter,
                        DirectoryFilter,
                        !SourceDirectory->GetPath()->GetPathString()->Strcmp(
                            _SourcePath->GetPathString()));

        DELETE(DestDirectory);
    }

    DELETE( _TargetPath);

    if (( _FilesCopied == 0 ) && _CanRemoveEmptyDirectories && !_DontCopySwitch ) {

        //
        //  Delete any directories that we created
        //
        if ( PartialDirectory != DestinationDirectory ) {

            if (!PathToDelete.Initialize( DestinationDirectory->GetPath() )) {
                    DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
            }

            CharsInPartialDirectoryPath = PartialDirectory->GetPath()->GetPathString()->QueryChCount();

            while ( PathToDelete.GetPathString()->QueryChCount() >
                            CharsInPartialDirectoryPath ) {

                    DirDeleted = DestinationDirectory->DeleteDirectory();

                    DebugAssert( DirDeleted );

                    DELETE( DestinationDirectory );

                    PathToDelete.TruncateBase();
                    DestinationDirectory = SYSTEM::QueryDirectory( &PathToDelete );
                    DebugPtrAssert( DestinationDirectory );
            }
        }

        //
        //  We display the "File not found" message only if there are no
        //  files that match our pattern, regardless of other factors such
        //  as attributes etc. This is just to maintain DOS5 compatibility.
        //
        TmpPath.Initialize( SourceDirectory->GetPath() );
        TmpPath.AppendBase( FileFilter->GetFileName() );
        if ((FindHandle = FindFirstFile( &TmpPath, &FindData )) == INVALID_HANDLE_VALUE ) {
                DisplayMessage( XCOPY_ERROR_FILE_NOT_FOUND, ERROR_MESSAGE, "%W", FileFilter->GetFileName() );
        }
        FindClose(FindHandle);

    }

    DELETE( SourceDirectory );
    if ( PartialDirectory != DestinationDirectory ) {
        DELETE( PartialDirectory );
    }
    DELETE( DestinationDirectory );
    DELETE( FileFilter );
    DELETE( DirectoryFilter );

    return TRUE;
}

BOOLEAN
XCOPY::Traverse (
    IN      PFSN_DIRECTORY  Directory,
    IN OUT  PPATH           DestinationPath,
    IN      PFSN_FILTER     FileFilter,
    IN      PFSN_FILTER     DirectoryFilter,
    IN      BOOLEAN         CopyDirectoryStreams
    )

/*++

Routine Description:

    Traverses a directory, calling the callback function for each node
    (directory of file) visited.  The traversal may be finished
    prematurely when the callback function returnes FALSE.

    The destination path is modified to reflect the directory structure
    being traversed.

Arguments:

    Directory               - Supplies pointer to directory to traverse

    DestinationPath         - Supplies pointer to path to be used with the
                                callback function.

    FileFilter              - Supplies a pointer to the file filter.

    DirectoryFilter         - Supplies a pointer to the directory filter.

    CopyDirectoryStreams    - Specifies to copy directory streams when
                                copying directories.

Return Value:

    BOOLEAN - TRUE if everything traversed
              FALSE otherwise.

--*/


{

    PFSN_DIRECTORY    TargetDirectory = NULL;
    PWSTRING          CurrentPathStr;
    PWSTRING          TargetPathStr;
    BOOLEAN           MemoryOk;
    PFSN_FILE         File;
    PFSN_DIRECTORY    Dir;
    PWSTRING          Name;
    BOOLEAN           Created = FALSE;
    PCPATH            TemplatePath = NULL;
    HANDLE            h;
    PWSTRING          CurrentFileName, PrevFileName;
    DWORD             GetNextError = ERROR_SUCCESS;

    DebugPtrAssert( Directory );
    DebugPtrAssert( DestinationPath );
    DebugPtrAssert( FileFilter );
    DebugPtrAssert( DirectoryFilter );


    //
    //  We only traverse this directory if it is not empty (unless the
    //  empty switch is set).
    //
    if ( _EmptySwitch || !Directory->IsEmpty() ) {

        //
        //      Create the target directory (if we are not copying to a file).
        //
        if ( !_TargetIsFile && !_DontCopySwitch ) {

            //
            //  The target directory may not exist, create the
            //  directory and remember that we might delete it if
            //  no files or subdirectories were created.
            //  Even if the directory exists, it may not have
            //  all the streams/ACLs in it.

            if (CopyDirectoryStreams) {
                TemplatePath = Directory->GetPath();
            }

            if (TemplatePath == NULL) {
                TargetDirectory = SYSTEM::QueryDirectory( DestinationPath );
            }

            if (!TargetDirectory) {
                TargetDirectory = MakeDirectory( DestinationPath, TemplatePath );

                if (TargetDirectory && !_CopyAttrSwitch) {
                    DWORD  dwError;
                    // always set the archive bit so that it gets backup
                    TargetDirectory->MakeArchived(&dwError);
                }
                Created = TRUE;
            }

            if ( !TargetDirectory ) {
                //
                //  If the Continue Switch is set, we just display an error message and
                //  continue, otherwise we exit with error.
                //
                if ( _ContinueSwitch ) {

                    DisplayMessage( XCOPY_ERROR_CREATE_DIRECTORY1, ERROR_MESSAGE, "%W", DestinationPath->GetPathString() );
                    return TRUE;

                } else {

                    DisplayMessageAndExit( XCOPY_ERROR_CREATE_DIRECTORY1,
                                           (PWSTRING)DestinationPath->GetPathString(),
                                            EXIT_MISC_ERROR );

                }
            }

            if( !_CopyAttrSwitch ) {

                TargetDirectory->ResetReadOnlyAttribute();
            }
        }

        //
        //      Iterate through all files and copy them as needed
        //

        MemoryOk = TRUE;
        h = NULL;
        CurrentFileName = PrevFileName = NULL;

        while ( MemoryOk &&
                (( File = (PFSN_FILE)Directory->GetNext( &h, &GetNextError )) != NULL )) {

            //
            // Don't know how expensive it is to check for infinite loop below
            //
            if (PrevFileName) {
                CurrentFileName = File->QueryName();

                if (PrevFileName && CurrentFileName) {
                    if (CurrentFileName->Strcmp(PrevFileName) == 0) {

                        // something went wrong
                        // GetNext should not return two files of the same name

                        DELETE(File);
                        DELETE(PrevFileName);
                        DELETE(CurrentFileName);

                        if (_ContinueSwitch) {
                            DisplayMessage( XCOPY_ERROR_INCOMPLETE_COPY, ERROR_MESSAGE );
                            break;
                        } else {
                            DisplayMessageAndExit( XCOPY_ERROR_INCOMPLETE_COPY, NULL, EXIT_MISC_ERROR );
                        }
                    }
                } else
                    MemoryOk = FALSE;

                DELETE(PrevFileName);
                PrevFileName = CurrentFileName;
                CurrentFileName = NULL;

                if (!MemoryOk)
                    break;

            } else
                PrevFileName = File->QueryName();

            if ( !FileFilter->DoesNodeMatch( (PFSNODE)File ) ) {
                DELETE(File);
                continue;
            }

            DebugAssert( !File->IsDirectory() );

            // If we're supposed to use the short name then convert fsnode.

            if (_UseShortSwitch && !File->UseAlternateName()) {
                DELETE(File);
                MemoryOk = FALSE;
                continue;
            }

            //
            //  Append the name portion of the node to the destination path.
            //
            Name = File->QueryName();
            DebugPtrAssert( Name );

            if ( Name ) {

                MemoryOk = DestinationPath->AppendBase( Name );
                DebugAssert( MemoryOk );

                DELETE( Name );

                if ( MemoryOk ) {
                    //
                    //  Copy the file
                    //
                    if ( !Copier( File, DestinationPath ) ) {
                        DELETE(File);
                        ExitProgram( EXIT_MISC_ERROR );
                    }

                    //
                    //  Restore the destination path
                    //
                    DestinationPath->TruncateBase();
                }

            } else {

                MemoryOk = FALSE;

            }

            DELETE(File);
        }

        DELETE(PrevFileName);
        DELETE(CurrentFileName);

        if ( MemoryOk && (_ContinueSwitch || (ERROR_SUCCESS == GetNextError) ||
                          (ERROR_NO_MORE_FILES == GetNextError))) {
            //
            //  If recursing, Traverse all the subdirectories
            //
            if ( _SubdirSwitch ) {

                MemoryOk = TRUE;
                h = NULL;

                if (Created) {
                    TargetPathStr = TargetDirectory->GetPath()->QueryFullPathString();
                    MemoryOk = (TargetPathStr != NULL);
                } else
                    TargetPathStr = NULL;

                CurrentFileName = PrevFileName = NULL;

                //
                //  Recurse thru all the subdirectories
                //
                while ( MemoryOk &&
                        (( Dir = (PFSN_DIRECTORY)Directory->GetNext( &h, &GetNextError )) != NULL )) {

                    //
                    // Don't know how expensive it is to check for infinite loop below
                    //
                    if (PrevFileName) {
                        CurrentFileName = Dir->QueryName();

                        if (PrevFileName && CurrentFileName) {
                            if (CurrentFileName->Strcmp(PrevFileName) == 0) {

                                // something went wrong
                                // GetNext should not return two files of the same name

                                DELETE(Dir);
                                DELETE(PrevFileName);
                                DELETE(CurrentFileName);

                                if (_ContinueSwitch) {
                                    DisplayMessage( XCOPY_ERROR_INCOMPLETE_COPY, ERROR_MESSAGE );
                                    break;
                                } else {
                                    DisplayMessageAndExit( XCOPY_ERROR_INCOMPLETE_COPY, NULL, EXIT_MISC_ERROR );
                                }
                            }
                        } else
                            MemoryOk = FALSE;

                        DELETE(PrevFileName);
                        PrevFileName = CurrentFileName;
                        CurrentFileName = NULL;

                        if (!MemoryOk)
                            break;

                    } else
                        PrevFileName = Dir->QueryName();

                    if ( !DirectoryFilter->DoesNodeMatch( (PFSNODE)Dir ) ) {
                        DELETE(Dir);
                        continue;
                    }

                    if (_ExclusionList != NULL &&
                        IsExcluded( Dir->GetPath() ) ) {
                        DELETE(Dir);
                        continue;
                    }

                    if (Created) {
                        CurrentPathStr = Dir->GetPath()->QueryFullPathString();
                        if (CurrentPathStr == NULL) {
                            DELETE(Dir);
                            MemoryOk = FALSE;
                            continue;
                        }
                        if (TargetPathStr->Stricmp(CurrentPathStr) == 0) {
                            DELETE(CurrentPathStr);
                            DELETE(Dir);
                            continue;
                        }
                        DELETE(CurrentPathStr);
                    }

                    DebugAssert( Dir->IsDirectory() );

                    // If we're using short names then convert this fsnode.

                    if (_UseShortSwitch && !Dir->UseAlternateName()) {
                        DELETE(Dir);
                        MemoryOk = FALSE;
                        continue;
                    }

                    //
                    //  Append the name portion of the node to the destination path.
                    //
                    Name = Dir->QueryName();
                    DebugPtrAssert( Name );

                    if ( Name ) {
                        MemoryOk = DestinationPath->AppendBase( Name );
                        DebugAssert( MemoryOk );

                        DELETE( Name );

                        _CanRemoveEmptyDirectories = (BOOLEAN)!_EmptySwitch;

                        if ( MemoryOk ) {

                            //
                            //  Recurse
                            //
                            Traverse( Dir,
                                      DestinationPath, FileFilter,
                                      DirectoryFilter, TRUE );

                            //
                            //  Restore the destination path
                            //
                            DestinationPath->TruncateBase();
                        }
                    } else {
                        MemoryOk = FALSE;
                    }
                    DELETE(Dir);
                }

                DELETE(PrevFileName);
                DELETE(CurrentFileName);

                if (TargetPathStr)
                    DELETE(TargetPathStr);
            }
        }

        if ( !MemoryOk ) {
            DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
        }

        //
        //  If we created this directory but did not copy anything to it, we
        //  have to remove it.
        //

        if ( Created && TargetDirectory->IsEmpty() && !_EmptySwitch && !_StructureOnlySwitch) {

             SYSTEM::RemoveNode( (PFSNODE *)&TargetDirectory, TRUE );

        } else {

             DELETE( TargetDirectory );

        }

        if ((ERROR_NO_MORE_FILES != GetNextError) && (ERROR_SUCCESS != GetNextError))  {

            //
            //  Some other error when traversing a directory.  We will already have
            //  exited whatever loop we were inside due to the NULL file return.
            //

            SYSTEM::DisplaySystemError( GetNextError, !_ContinueSwitch);
        }
    }

    return TRUE;
}

BOOLEAN
XCOPY::UpdateTraverse (
    IN      PFSN_DIRECTORY  DestDirectory,
    IN OUT  PPATH           SourcePath,
    IN      PFSN_FILTER     FileFilter,
    IN      PFSN_FILTER     DirectoryFilter,
    IN      BOOLEAN         CopyDirectoryStreams
    )

/*++

Routine Description:

    Traverse routine for update.

    Like XCOPY::Traverse, except we traverse the *destination*
    directory, possibly updating files we find there.  The theory
    being that there will be fewer files in the destination than
    the source, so we can save time this way.

    The callback function is invoked on each node
    (directory or file) visited.  The traversal may be finished
    prematurely when the callback function returns FALSE.

Arguments:

    DestDirectory           - Supplies pointer to destination directory

    SourcePath              - Supplies pointer to path to be used with the
                                callback function.

    FileFilter              - Supplies a pointer to the file filter.

    DirectoryFilter         - Supplies a pointer to the directory filter.

    CopyDirectoryStreams    - Specifies to copy directory streams when
                                copying directories.

Return Value:

    BOOLEAN - TRUE if everything traversed
              FALSE otherwise.

--*/

{

    BOOLEAN             MemoryOk;
    PFSN_FILE           File;
    PFSN_DIRECTORY      Dir;
    PWSTRING            Name;
    BOOLEAN             Created = FALSE;
    PCPATH              TemplatePath = NULL;
    HANDLE              h;
    PWSTRING            CurrentFileName, PrevFileName;
    DWORD               GetNextError = ERROR_SUCCESS;

    DebugPtrAssert( SourcePath );
    DebugPtrAssert( FileFilter );
    DebugPtrAssert( DirectoryFilter );

    // Don't bother to traverse if
    // destination directory is null

    if (!DestDirectory)
        return TRUE;

    //
    //  We only traverse this directory if it is not empty (unless the
    //  empty switch is set).
    //
    if ( _EmptySwitch || !DestDirectory->IsEmpty() ) {

        //
        //      Iterate through all files and copy them as needed
        //

        MemoryOk = TRUE;
        h = NULL;
        CurrentFileName = PrevFileName = NULL;

        while (MemoryOk &&
               ((File = (PFSN_FILE)DestDirectory->GetNext( &h, &GetNextError )) != NULL)) {

            //
            // Don't know how expensive it is to check for infinite loop below
            //
            if (PrevFileName) {
                CurrentFileName = File->QueryName();

                if (PrevFileName && CurrentFileName) {
                    if (CurrentFileName->Strcmp(PrevFileName) == 0) {

                        // something went wrong
                        // GetNext should not return two files of the same name

                        DELETE(File);
                        DELETE(PrevFileName);
                        DELETE(CurrentFileName);

                        if (_ContinueSwitch) {
                            DisplayMessage( XCOPY_ERROR_INCOMPLETE_COPY, ERROR_MESSAGE );
                            break;
                        } else {
                            DisplayMessageAndExit( XCOPY_ERROR_INCOMPLETE_COPY, NULL, EXIT_MISC_ERROR );
                        }
                    }
                } else
                    MemoryOk = FALSE;

                DELETE(PrevFileName);
                PrevFileName = CurrentFileName;
                CurrentFileName = NULL;

                if (!MemoryOk)
                    break;

            } else
                PrevFileName = File->QueryName();

            if ( !FileFilter->DoesNodeMatch( (PFSNODE)File ) ) {
                DELETE(File);
                continue;
            }

            DebugAssert( !File->IsDirectory() );

            // If we're supposed to use the short name then convert fsnode.

            if (_UseShortSwitch && !File->UseAlternateName()) {
                DELETE(File);
                MemoryOk = FALSE;
                continue;
            }

            //
            //  Append the name portion of the node to the destination path.
            //
            Name = File->QueryName();
            DebugPtrAssert( Name );

            if ( Name ) {
                PFSN_FILE SourceFile;
                PATH DestinationPath;
                PATH TmpPath;

                TmpPath.Initialize(SourcePath);
                TmpPath.AppendBase(Name);

                SourceFile = SYSTEM::QueryFile(&TmpPath);

                DestinationPath.Initialize(DestDirectory->GetPath());

                MemoryOk = DestinationPath.AppendBase( Name );
                DebugAssert( MemoryOk );

                DELETE( Name );

                if ( MemoryOk && NULL != SourceFile ) {
                    //
                    //  Copy the file
                    //

                    if ( !Copier( SourceFile, &DestinationPath ) ) {
                        DELETE(SourceFile);
                        DELETE(File);
                        ExitProgram( EXIT_MISC_ERROR );
                    }
                }

                DELETE(SourceFile);

            } else {

                MemoryOk = FALSE;

            }
            DELETE(File);
        }

        DELETE(PrevFileName);
        DELETE(CurrentFileName);

        if ( MemoryOk && (_ContinueSwitch || (ERROR_SUCCESS == GetNextError) ||
                          (ERROR_NO_MORE_FILES == GetNextError))) {
            //
            //  If recursing, Traverse all the subdirectories
            //
            if ( _SubdirSwitch ) {

                MemoryOk = TRUE;
                h = NULL;
                CurrentFileName = PrevFileName = NULL;

                //
                //  Recurse thru all the subdirectories
                //
                while (MemoryOk &&
                       ((Dir = (PFSN_DIRECTORY)DestDirectory->GetNext( &h, &GetNextError )) != NULL)) {

                    //
                    // Don't know how expensive it is to check for infinite loop below
                    //
                    if (PrevFileName) {
                        CurrentFileName = Dir->QueryName();

                        if (PrevFileName && CurrentFileName) {
                            if (CurrentFileName->Strcmp(PrevFileName) == 0) {

                                // something went wrong
                                // GetNext should not return two files of the same name

                                DELETE(Dir);
                                DELETE(PrevFileName);
                                DELETE(CurrentFileName);

                                if (_ContinueSwitch) {
                                    DisplayMessage( XCOPY_ERROR_INCOMPLETE_COPY, ERROR_MESSAGE );
                                    break;
                                } else {
                                    DisplayMessageAndExit( XCOPY_ERROR_INCOMPLETE_COPY, NULL, EXIT_MISC_ERROR );
                                }
                            }
                        } else
                            MemoryOk = FALSE;

                        DELETE(PrevFileName);
                        PrevFileName = CurrentFileName;
                        CurrentFileName = NULL;

                        if (!MemoryOk)
                            break;

                    } else
                        PrevFileName = Dir->QueryName();

                    if ( !DirectoryFilter->DoesNodeMatch( (PFSNODE)Dir ) ) {
                        DELETE(Dir);
                        continue;
                    }

                    DebugAssert( Dir->IsDirectory() );

                    // If we're using short names then convert this fsnode.

                    if (_UseShortSwitch && !Dir->UseAlternateName()) {
                        DELETE(Dir);
                        MemoryOk = FALSE;
                        continue;
                    }

                    //
                    //  Append the name portion of the node to the destination
                    //  path.
                    //
                    Name = Dir->QueryName();
                    DebugPtrAssert( Name );

                    if ( Name ) {
                        MemoryOk = SourcePath->AppendBase( Name );
                        DebugAssert( MemoryOk );

                        DELETE( Name );

                        _CanRemoveEmptyDirectories = (BOOLEAN)!_EmptySwitch;

                        if ( MemoryOk ) {

                            if( _ExclusionList != NULL &&
                                IsExcluded( SourcePath ) ) {
                                SourcePath->TruncateBase();
                                DELETE(Dir);
                                continue;
                            }

                            //
                            //  Recurse
                            //

                            UpdateTraverse( Dir, SourcePath,
                                            FileFilter, DirectoryFilter, TRUE );

                        }

                        SourcePath->TruncateBase();

                    } else {
                        MemoryOk = FALSE;
                    }
                    DELETE(Dir);
                }
                DELETE(PrevFileName);
                DELETE(CurrentFileName);
            }
        }

        if ( !MemoryOk ) {
            DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
        }
        else if ((ERROR_NO_MORE_FILES != GetNextError) && (ERROR_SUCCESS != GetNextError))  {

            //
            //  Some other error when traversing a directory.
            //

            SYSTEM::DisplaySystemError( GetNextError, !_ContinueSwitch);
        }
    }

    return TRUE;
}


XCOPY::ProgressCallBack(
    LARGE_INTEGER TotalFileSize,
    LARGE_INTEGER TotalBytesTransferred,
    LARGE_INTEGER StreamSize,
    LARGE_INTEGER StreamBytesTransferred,
    DWORD dwStreamNumber,
    DWORD dwCallbackReason,
    HANDLE hSourceFile,
    HANDLE hDestinationFile,
    LPVOID lpData OPTIONAL
    )

/*++

Routine Description:

    Callback routine passed to CopyFileEx.

    Check to see if the user hit Ctrl-C and return appropriate
    value to CopyFileEx.

Arguments:

    TotalFileSize           - Total size of the file in bytes.

    TotalBytesTransferred   - Total number of bytes transferred.

    StreamSize              - Size of the stream being copied in bytes.

    StreamBytesTransferred  - Number of bytes in current stream transferred.

    dwStreamNumber          - Stream number of the current stream.

    dwCallBackReason        - CALLBACK_CHUNK_FINISHED if a block was transferred,
                              CALLBACK_STREAM_SWITCH if a stream completed copying.

    hSourceFile             - Handle to the source file.

    hDestinationFile        - Handle to the destination file.

    lpData                  - Pointer to opaque data that was passed to CopyFileEx.  Used
                              in this instance to pass the "this" pointer to an XCOPY object.

Return Value:

    DWORD                   - PROGRESS_STOP if a Ctrl-C was hit and the copy was restartable,
                              PROGESS_CANCEL otherwise.

--*/

{
    FILETIME LastWriteTime;

    //
    //  If the file was just created then roll back LastWriteTime a little so a subsequent
    //  xcopy /d /z
    //  will work if the copy was interrupted.
    //
    if ( dwStreamNumber == 1 && dwCallbackReason == CALLBACK_STREAM_SWITCH )
    {
        if ( GetFileTime(hSourceFile, NULL, NULL, &LastWriteTime) )
        {
            LastWriteTime.dwLowDateTime -= 1000;
            SetFileTime(hDestinationFile, NULL, NULL, &LastWriteTime);
        }
    }

    switch (dwCallbackReason) {
        case PRIVCALLBACK_STREAMS_NOT_SUPPORTED:
        case PRIVCALLBACK_COMPRESSION_NOT_SUPPORTED:
        case PRIVCALLBACK_ENCRYPTION_NOT_SUPPORTED:
        case PRIVCALLBACK_EAS_NOT_SUPPORTED:
        case PRIVCALLBACK_SPARSE_NOT_SUPPORTED:
            return PROGRESS_CONTINUE;

        case PRIVCALLBACK_ENCRYPTION_FAILED:
            // GetLastError will return ERROR_NOT_SUPPORTED if PROGRESS_STOP is
            // returned.  The message is misleading so display our own error
            // message and return PROGRESS_CANCEL.
            ((XCOPY *)lpData)->DisplayMessage(XCOPY_ERROR_ENCRYPTION_FAILED);
            return PROGRESS_CANCEL;

        case PRIVCALLBACK_COMPRESSION_FAILED:
        case PRIVCALLBACK_SPARSE_FAILED:
        case PRIVCALLBACK_DACL_ACCESS_DENIED:
        case PRIVCALLBACK_SACL_ACCESS_DENIED:
        case PRIVCALLBACK_OWNER_GROUP_ACCESS_DENIED:
        case PRIVCALLBACK_OWNER_GROUP_FAILED:
            // display whatever GetLastError() contains
            return PROGRESS_STOP;

        case PRIVCALLBACK_SECURITY_INFORMATION_NOT_SUPPORTED:
            // GetLastError will return ERROR_NOT_SUPPORTED if PROGRESS_STOP is
            // returned.  The message is misleading so display our own error
            // message and return PROGRESS_CANCEL.
            ((XCOPY *)lpData)->DisplayMessage(XCOPY_ERROR_SECURITY_INFO_NOT_SUPPORTED);
            return PROGRESS_CANCEL;
    }

    // GetPFlagBreak returns a pointer to the flag indicating whether a Ctrl-C was hit
    if ( *((( XCOPY *) lpData)->_Keyboard->GetPFlagBreak()) )
        return ((XCOPY *) lpData)->_RestartableSwitch ? PROGRESS_STOP : PROGRESS_CANCEL;

    return PROGRESS_CONTINUE;
}

BOOLEAN
XCOPY::Copier (
        IN OUT  PFSN_FILE       File,
        IN      PPATH           DestinationPath
        )
/*++

Routine Description:

        This is the heart of XCopy. This is the guy who actually does
        the copying.

Arguments:

        File            -       Supplies pointer to the source File.
        DestinationPath -       Supplies path of the desired destination.

Return Value:

        BOOLEAN -       TRUE if copy successful.
                                FALSE otherwise

Notes:

--*/

{
    PATH                PathToCopy;
    PCWSTRING           Name;
    COPY_ERROR          CopyError;
    PFSN_FILE           TargetFile = NULL;
    BOOLEAN             Proceed;
    DWORD               Attempts;
    WCHAR               PathBuffer[MAX_PATH + 3];
    FSTRING             WriteBuffer;
    FSTRING             EndOfLine;
    DSTRING             ErrorMessage;
    PATH                CanonSourcePath;
    BOOLEAN             badCopy;
    ULONG               flags;
    PTIMEINFO           SourceFileTime, TargetFileTime;
    BOOLEAN             TargetFileEncrypted, TargetFileExist;


    EndOfLine.Initialize((PWSTR) L"\r\n");
    PathBuffer[0] = 0;
    WriteBuffer.Initialize(PathBuffer, MAX_PATH+3);


    //
    //  Maximum number of attempts to copy a file
    //
    #define MAX_ATTEMPTS    3

    AbortIfCtrlC();

    _CanRemoveEmptyDirectories = FALSE;

    if( _ExclusionList != NULL && IsExcluded( File->GetPath() ) ) {

        return TRUE;
    }

    if ( _TargetIsFile ) {

        //
        //  We replace the entire path
        //
        PathToCopy.Initialize( _TargetPath->GetPathString() );
        PathToCopy.AppendBase( _FileNamePattern );

    } else {

        //
        //  Set the correct target file name.
        //
        PathToCopy.Initialize( DestinationPath );
        if (!PathToCopy.ModifyName( _FileNamePattern )) {

            _Message.Set(MSG_COMP_UNABLE_TO_EXPAND);
            _Message.Display("%W%W", PathToCopy.QueryName(),
                                     _FileNamePattern);
            return FALSE;
        }
    }

    //
    //  If in Update or CopyIfOld mode, determine if the target file
    //  already exists and if it is older than the source file.
    //

    TargetFile = SYSTEM::QueryFile( &PathToCopy );
    if (TargetFile) {
        TargetFileEncrypted = TargetFile->IsEncrypted();
        TargetFileExist = TRUE;
    } else
        TargetFileEncrypted = TargetFileExist = FALSE;

    if ( _CopyIfOldSwitch || _UpdateSwitch ) {

        if ( TargetFile ) {

            //
            //  Target exists. If in CopyIfOld mode, copy only if target
            //  is older. If in Update mode, copy always.
            //
            if ( _CopyIfOldSwitch ) {
                SourceFileTime = File->QueryTimeInfo();
                TargetFileTime = TargetFile->QueryTimeInfo();
                if (SourceFileTime && TargetFileTime)
                    Proceed = (*SourceFileTime > *TargetFileTime);
                else {
                    DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
                }
                DELETE(SourceFileTime);
                DELETE(TargetFileTime);
            } else {
                Proceed = TRUE;
            }

            if ( !Proceed ) {
                DELETE( TargetFile );
                return TRUE;
            }
        } else if ( _UpdateSwitch ) {
            //
            //  In update mode but target does not exist. We do not
            //  copy.
            //
            return TRUE;
        }
    }

    DELETE(TargetFile);

    //
    //      If the target is a file, we use that file path. Otherwise
    //      we figure out the correct path for the destination. Then
    //      we do the copy.
    //
    Name = File->GetPath()->GetPathString();

    //
    //      Make sure that we are not copying to ourselves
    //
    CanonSourcePath.Initialize(Name, TRUE);
    badCopy = (*(CanonSourcePath.GetPathString()) == *(PathToCopy.GetPathString()));

    if ( (!_PromptSwitch ||
          UserConfirmedCopy( File->GetPath()->GetPathString(),
                             _VerboseSwitch ? PathToCopy.GetPathString() : NULL )) &&
         (badCopy ||
          _OverWriteSwitch ||
          !TargetFileExist ||
          UserConfirmedOverWrite( &PathToCopy )) ) {

        //
        //  If we are not prompting, we display the file name (unless we
        //  are in silent mode ).
        //
        if ( !_PromptSwitch && !_SilentSwitch && !_StructureOnlySwitch ) {
            if ( _VerboseSwitch ) {

                DisplayMessage( XCOPY_MESSAGE_VERBOSE_COPY, NORMAL_MESSAGE, "%W%W", Name, PathToCopy.GetPathString() );

            } else {
                WriteBuffer.Resize(0);
                if (WriteBuffer.Strcat(Name) &&
                    WriteBuffer.Strcat(&EndOfLine)) {

                    GetStandardOutput()->WriteString(&WriteBuffer);

                } else {
                    DisplayMessage( XCOPY_ERROR_PATH_TOO_LONG, ERROR_MESSAGE );
                }
            }
        }

        //
        //      Make sure that we are not copying to ourselves
        //
        if (badCopy) {
            DisplayMessageAndExit( XCOPY_ERROR_SELF_COPY, NULL, EXIT_MISC_ERROR );
        }

        //
        //  Copy file (unless we are in display-only mode)
        //
        if ( _DontCopySwitch || _StructureOnlySwitch ) {

            _FilesCopied++;

        } else {

            Attempts  = 0;

            while ( TRUE ) {
                LPPROGRESS_ROUTINE Progress = NULL;
                PBOOL PCancelFlag = NULL;
                BOOLEAN bSuccess;
                //
                //  If copying to floppy, we must determine if there is
                //  enough disk space for the file, and if not then we
                //  must ask for another disk and create all the directory
                //  structure up to the parent directory.
                //
                if ( _DisketteCopy ) {

                    if (!CheckTargetSpace( File, &PathToCopy ))
                        return FALSE;
                }

                Progress = (LPPROGRESS_ROUTINE) ProgressCallBack;
                PCancelFlag = _Keyboard->GetPFlagBreak();

                flags = (_ReadOnlySwitch ? FSN_FILE_COPY_OVERWRITE_READ_ONLY : 0);
                flags |= (!_CopyAttrSwitch ? FSN_FILE_COPY_RESET_READ_ONLY : 0);
                flags |= (_RestartableSwitch ? FSN_FILE_COPY_RESTARTABLE : 0);
                flags |= (_OwnerSwitch ? FSN_FILE_COPY_COPY_OWNER : 0);
                flags |= (_AuditSwitch ? FSN_FILE_COPY_COPY_ACL : 0);
                flags |= (_DecryptSwitch ? FSN_FILE_COPY_ALLOW_DECRYPTED_DESTINATION : 0);

                bSuccess = File->Copy(&PathToCopy, &CopyError, flags,
                                      Progress, (VOID *)this,
                                      PCancelFlag);

                if (bSuccess) {

                    if (!_CopyAttrSwitch && (TargetFile = SYSTEM::QueryFile( &PathToCopy )) ) {
                        DWORD dwError;
                        TargetFile->MakeArchived(&dwError);
                        DELETE(TargetFile);
                    }

                    if ( _ModifySwitch ) {
                        File->ResetArchivedAttribute();
                    }

                    if( _VerifySwitch ) {

                        // Check that the new file is the same length as
                        // the old file.
                        //
                        if( (TargetFile = SYSTEM::QueryFile( &PathToCopy )) == NULL ||
                            TargetFile->QuerySize() != File->QuerySize() ) {

                            DELETE( TargetFile );

                            DisplayMessage( XCOPY_ERROR_VERIFY_FAILED, ERROR_MESSAGE );
                            if ( !_ContinueSwitch ) {
                                return FALSE;
                            }

                            break;
                        }

                        DELETE( TargetFile );
                    }

                    _FilesCopied++;

                    break;

                } else {

                    //
                    //  If the copy was cancelled mid-stream, exit.
                    //
                    AbortIfCtrlC();

                    if (CopyError == COPY_ERROR_REQUEST_ABORTED)
                        return FALSE;

                    if (CopyError == COPY_ERROR_ACCESS_DENIED &&
                        TargetFileExist && TargetFileEncrypted) {
                        Attempts = MAX_ATTEMPTS;
                    }

                    //
                    //  In case of error, wait for a little while and try
                    //  again, otherwise display the error.
                    //
                    if ( Attempts++ < MAX_ATTEMPTS ) {

                        Sleep( 100 );

                    } else {

                        switch ( CopyError ) {

                        case COPY_ERROR_ACCESS_DENIED:
                            DisplayMessage( XCOPY_ERROR_ACCESS_DENIED, ERROR_MESSAGE);
                            break;

                        case COPY_ERROR_SHARE_VIOLATION:
                            DisplayMessage( XCOPY_ERROR_SHARING_VIOLATION, ERROR_MESSAGE);
                            break;

                        default:

                            //
                            //  At this point we don't know if the copy left a
                            //  bogus file on disk. If the target file exist,
                            //  we assume that it is bogus so we delete it.
                            //
                            if ((TargetFile = SYSTEM::QueryFile( &PathToCopy )) &&
                                !_RestartableSwitch) {

                                TargetFile->DeleteFromDisk( TRUE );

                                DELETE( TargetFile );
                            }

                            switch ( CopyError ) {
                              case COPY_ERROR_DISK_FULL:
                                DisplayMessageAndExit( XCOPY_ERROR_DISK_FULL, NULL, EXIT_MISC_ERROR );
                                break;

                              default:
                                if (SYSTEM::QueryWindowsErrorMessage(CopyError, &ErrorMessage)) {
                                    DisplayMessage( XCOPY_ERROR_CANNOT_MAKE, ERROR_MESSAGE, "%W", &ErrorMessage );
                                }
                                break;
                            }

                            break;
                        }

                        if ( !_ContinueSwitch ) {
                            return FALSE;
                        }

                        break;
                    }
                }
            }
        }
    }

    DELETE( TargetFile );

    return TRUE;
}

PFSN_DIRECTORY
XCOPY::MakeDirectory (
        IN      PPATH           DestinationPath,
        IN      PCPATH          TemplatePath
        )
/*++

Routine Description:

        This is the heart of XCopy. This is the guy who actually does
        the copying.

Arguments:

        DestinationPath -       Supplies path of the desired directory
        TemplatePath    -       Supplies path of the source directory

Return Value:

        BOOLEAN -       TRUE if copy successful.  FALSE otherwise.

Notes:

--*/

{
    ULONG           flags;
    BOOLEAN         bSuccess;
    PFSN_DIRECTORY  rtn;
    DSTRING         ErrorMessage;
    COPY_ERROR      CopyError;


    flags  = (_RestartableSwitch ? FSN_FILE_COPY_RESTARTABLE : 0);
    flags |= (_OwnerSwitch ? FSN_FILE_COPY_COPY_OWNER : 0);
    flags |= (_AuditSwitch ? FSN_FILE_COPY_COPY_ACL : 0);
    flags |= (_DecryptSwitch ? FSN_FILE_COPY_ALLOW_DECRYPTED_DESTINATION : 0);

    rtn = SYSTEM::MakeDirectory( DestinationPath,
                                 TemplatePath,
                                 &CopyError,
                                 (LPPROGRESS_ROUTINE)ProgressCallBack,
                                 (VOID *)this,
                                 _Keyboard->GetPFlagBreak(),
                                 flags );

    if (rtn == NULL) {
        //
        //  If the copy was cancelled mid-stream, exit.
        //
        AbortIfCtrlC();

        switch ( CopyError ) {
          case COPY_ERROR_SUCCESS:
            DisplayMessage( XCOPY_ERROR_UNKNOWN, ERROR_MESSAGE);
            break;

          case COPY_ERROR_REQUEST_ABORTED:
            break;

          case COPY_ERROR_ACCESS_DENIED:
            DisplayMessage( XCOPY_ERROR_ACCESS_DENIED, ERROR_MESSAGE);
            break;

          case COPY_ERROR_SHARE_VIOLATION:
            DisplayMessage( XCOPY_ERROR_SHARING_VIOLATION, ERROR_MESSAGE);
            break;

          case COPY_ERROR_DISK_FULL:
            DisplayMessageAndExit( XCOPY_ERROR_DISK_FULL, NULL, EXIT_MISC_ERROR );
            break;

          default:
            if (SYSTEM::QueryWindowsErrorMessage(CopyError, &ErrorMessage))
                DisplayMessage( XCOPY_ERROR_CANNOT_MAKE, ERROR_MESSAGE, "%W", &ErrorMessage );
            break;
        }
    }

    return rtn;
}


BOOLEAN
XCOPY::CheckTargetSpace (
    IN OUT  PFSN_FILE   File,
    IN      PPATH       DestinationPath
    )
/*++

Routine Description:

    Makes sure that there is enought disk space in the target disk.
    Asks the user to change the disk if necessary.

Arguments:

    File            -   Supplies pointer to the source File.
    DestinationPath -   Supplies path of the desired destination.

Return Value:

    BOOLEAN -   TRUE if OK
                FALSE otherwise

--*/
{

    PFSN_FILE           TargetFile = NULL;
    BIG_INT             TargetSize;
    PWSTRING            TargetDrive;
    WCHAR               Resp;
    DSTRING             TargetRoot;
    DSTRING             Slash;
    PATH                TmpPath;
    PATH                TmpPath1;
    PFSN_DIRECTORY      PartialDirectory        = NULL;
    PFSN_DIRECTORY      DestinationDirectory    = NULL;
    BOOLEAN             DirDeleted              = NULL;
    PATH                PathToDelete;
    CHNUM               CharsInPartialDirectoryPath;
    BIG_INT             FreeSpace;
    BIG_INT             FileSize;

    if ( TargetFile = SYSTEM::QueryFile( DestinationPath ) ) {

        TargetSize = TargetFile->QuerySize();

        DELETE( TargetFile );

    } else {

        TargetSize = 0;
    }

    TargetDrive = DestinationPath->QueryDevice();

    FileSize = File->QuerySize();

    if ( TargetDrive ) {

        TargetRoot.Initialize( TargetDrive );

        if ( TargetRoot.QueryChAt( TargetRoot.QueryChCount()-1) != (WCHAR)'\\' ) {
            Slash.Initialize( "\\" );
            TargetRoot.Strcat( &Slash );
        }


        while ( TRUE ) {

            if ( IFS_SYSTEM::QueryFreeDiskSpace( &TargetRoot, &FreeSpace ) ) {

                FreeSpace = FreeSpace + TargetSize;

                // DebugPrintTrace(( "Disk Space: %d Needed: %d\n", FreeSpace.GetLowPart(), FileSize.GetLowPart() ));

                if ( FreeSpace < FileSize ) {

                    //
                    //  Not enough free space, ask for another
                    //  disk and create the directory structure.
                    //
                    DisplayMessage( XCOPY_MESSAGE_CHANGE_DISK, NORMAL_MESSAGE );
                    AbortIfCtrlC();

                    _Keyboard->DisableLineMode();
                    if ( GetStandardInput()->IsAtEnd() ) {
                        // Insufficient input--treat as CONTROL-C.
                        //
                        Resp = CTRL_C;
                    } else {
                        GetStandardInput()->ReadChar( &Resp );
                    }
                    _Keyboard->EnableLineMode();

                    if ( Resp == CTRL_C ) {
                        exit( EXIT_TERMINATED );
                    } else {
                        GetStandardOutput()->WriteChar( Resp );
                        GetStandardOutput()->WriteChar( '\r' );
                        GetStandardOutput()->WriteChar( '\n' );
                    }

                    //
                    //  Create directory structure in target
                    //
                    TmpPath.Initialize( DestinationPath );
                    TmpPath.TruncateBase();

                    PartialDirectory = SYSTEM::QueryDirectory( &TmpPath, TRUE );

                    if (PartialDirectory == NULL ) {
                        if (GetLastError() == COPY_ERROR_REQUEST_ABORTED) {
                            DELETE( TargetDrive );
                            return FALSE;
                        }
                        continue;
                    } else {

                        if ( *(PartialDirectory->GetPath()->GetPathString()) !=
                             *(TmpPath.GetPathString()) ) {

                            TmpPath1.Initialize( &TmpPath );
                            DestinationDirectory = PartialDirectory->CreateDirectoryPath( &TmpPath1 );
                            if ( !DestinationDirectory ) {
                                DisplayMessageAndExit( XCOPY_ERROR_CREATE_DIRECTORY, NULL, EXIT_MISC_ERROR );
                            }
                        } else {
                            DestinationDirectory = PartialDirectory;
                        }
                    }

                    //
                    //  If still not enough disk space, remove the directories
                    //  that we created and try again
                    //
                    IFS_SYSTEM::QueryFreeDiskSpace( TargetDrive, &FreeSpace );
                    FreeSpace = FreeSpace + TargetSize;

                    if ( FreeSpace < FileSize ) {

                        if ( PartialDirectory != DestinationDirectory ) {

                            if (!PathToDelete.Initialize( DestinationDirectory->GetPath() )) {
                                DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
                            }

                            CharsInPartialDirectoryPath = PartialDirectory->GetPath()->GetPathString()->QueryChCount();

                            while ( PathToDelete.GetPathString()->QueryChCount() >
                                    CharsInPartialDirectoryPath ) {

                                DirDeleted = DestinationDirectory->DeleteDirectory();

                                DebugAssert( DirDeleted );

                                DELETE( DestinationDirectory );
                                DestinationDirectory = NULL;

                                PathToDelete.TruncateBase();
                                DestinationDirectory = SYSTEM::QueryDirectory( &PathToDelete );
                                DebugPtrAssert( DestinationDirectory );
                            }
                        }
                    }

                    if ( PartialDirectory != DestinationDirectory ) {
                        DELETE( PartialDirectory );
                        DELETE( DestinationDirectory );
                    } else {
                        DELETE( PartialDirectory );
                    }

                } else {
                    break;
                }

            } else {

                //
                //  Cannot determine free disk space!
                //
                if (GetLastError() == COPY_ERROR_REQUEST_ABORTED) {
                    DELETE( TargetDrive );
                    return FALSE;
                }
                break;
            }
        }

        DELETE( TargetDrive );
    }

    return TRUE;
}




VOID
XCOPY::GetDirectoryAndFilters (
    IN  PPATH           Path,
    OUT PFSN_DIRECTORY  *OutDirectory,
    OUT PFSN_FILTER     *FileFilter,
    OUT PFSN_FILTER     *DirectoryFilter,
    OUT PBOOLEAN        CopyingManyFiles
        )

/*++

Routine Description:

    Obtains a directory object and the filename to match

Arguments:

    Path                -   Supplies pointer to the path
    OutDirectory        -   Supplies pointer to pointer to directory
    FileFilter          -   Supplies filter for files
    DirectoryFilter     -   Supplies filter for directories
    CopyingManyFiles    -   Supplies pointer to flag which if TRUE means that
                            we are copying many files

Return Value:

    None.

Notes:

--*/

{

   PFSN_DIRECTORY    Directory;
   PFSN_FILE         File;
   PWSTRING          Prefix   =   NULL;
   PWSTRING          FileName =   NULL;
   PATH              PrefixPath;
   PATH              TmpPath;
   FSN_ATTRIBUTE     All   =  (FSN_ATTRIBUTE)0;
   FSN_ATTRIBUTE     Any   =  (FSN_ATTRIBUTE)0;
   FSN_ATTRIBUTE     None  =  (FSN_ATTRIBUTE)0;
   PFSN_FILTER       FilFilter;
   PFSN_FILTER       DirFilter;
   DSTRING           Name;



    //
    //      Create filters
    //
    if ( ( (FilFilter = NEW FSN_FILTER) == NULL ) ||
         ( (DirFilter = NEW FSN_FILTER) == NULL ) ||
         !FilFilter->Initialize()                 ||
         !DirFilter->Initialize() ) {
        DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
    }

    if (( Directory = SYSTEM::QueryDirectory( Path )) != NULL ) {

        //
        //  Copying a directory. We will want everything in the directory
        //
        FilFilter->SetFileName( "*.*" );
        *CopyingManyFiles = TRUE;

    } else {

        //
        //  The path is not a directory. Get the prefix part (which SHOULD
        //  be a directory, and try to make a directory from it
        //
        *CopyingManyFiles = Path->HasWildCard();

        if ( !*CopyingManyFiles ) {

            //
            //  If the path is not a file, then this is an error
            //
            if ( !(File = SYSTEM::QueryFile( Path )) ) {

                if ((FileName = Path->QueryName()) == NULL ||
                    !Name.Initialize( FileName )) {
                    DisplayMessageAndExit( XCOPY_ERROR_INVALID_PATH, NULL, EXIT_MISC_ERROR );
                }
                DisplayMessageAndExit( XCOPY_ERROR_FILE_NOT_FOUND,
                                       &Name,
                                       EXIT_MISC_ERROR );

            }

            DELETE( File );
        }

        Prefix = Path->QueryPrefix();

        if ( !Prefix ) {

            //
            //  No prefix, use the drive part.
            //
            TmpPath.Initialize( Path, TRUE );

            Prefix = TmpPath.QueryDevice();

            if (Prefix == NULL) {
                DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
                return;
            }
        }

        if ( !PrefixPath.Initialize( Prefix, FALSE ) ) {
            DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
        }

        if (( Directory = SYSTEM::QueryDirectory( &PrefixPath )) != NULL ) {

            //
            //  Directory is ok, set the filter's filename criteria
            //  with the file (pattern) specified.
            //
            if ((FileName = Path->QueryName()) == NULL ) {
                DisplayMessageAndExit( XCOPY_ERROR_INVALID_PATH, NULL, EXIT_MISC_ERROR );
            }

            FilFilter->SetFileName( FileName );

        } else {

            //
            //  Something went wrong...
            //
            if ((FileName = Path->QueryName()) == NULL ||
                !Name.Initialize( FileName )) {
                DisplayMessageAndExit( XCOPY_ERROR_INVALID_PATH, NULL, EXIT_MISC_ERROR );
            }
            DisplayMessageAndExit( XCOPY_ERROR_FILE_NOT_FOUND,
                                   &Name,
                                   EXIT_MISC_ERROR );
        }

        DELETE( Prefix );
        DELETE( FileName );

    }

    //
    //  Ok, we have the directory object and the filefilter's path set.
    //

    //
    //  Set the file filter attribute criteria
    //
    None = (FSN_ATTRIBUTE)(None | FSN_ATTRIBUTE_DIRECTORY );
    if ( !_HiddenSwitch ) {
        None = (FSN_ATTRIBUTE)(None | FSN_ATTRIBUTE_HIDDEN | FSN_ATTRIBUTE_SYSTEM );
    }

    if (_ArchiveSwitch) {
        All = (FSN_ATTRIBUTE)(All | FSN_ATTRIBUTE_ARCHIVE);
    }

    FilFilter->SetAttributes( All, Any, None );

    //
    //  Set the file filter's time criteria
    //
    if ( _Date != NULL ) {
        FilFilter->SetTimeInfo( _Date,
                                FSN_TIME_MODIFIED,
                                (TIME_AT | TIME_AFTER) );
    }

    //
    //  Set the directory filter attribute criteria.
    //
    All     =   (FSN_ATTRIBUTE)0;
    Any     =   (FSN_ATTRIBUTE)0;
    None    =   (FSN_ATTRIBUTE)0;

    if ( !_HiddenSwitch ) {
        None = (FSN_ATTRIBUTE)(None | FSN_ATTRIBUTE_HIDDEN | FSN_ATTRIBUTE_SYSTEM );
    }

    if (_SubdirSwitch) {
            All = (FSN_ATTRIBUTE)(All | FSN_ATTRIBUTE_DIRECTORY);
    } else {
            None = (FSN_ATTRIBUTE)(None | FSN_ATTRIBUTE_DIRECTORY);
    }

    DirFilter->SetAttributes( All, Any, None );


    *FileFilter         =   FilFilter;
    *DirectoryFilter    =   DirFilter;
    *OutDirectory       =   Directory;

}

VOID
XCOPY::GetDirectoryAndFilePattern(
    IN  PPATH           Path,
    IN  BOOLEAN         CopyingManyFiles,
        OUT PPATH                       *OutDirectory,
    OUT PWSTRING        *OutFilePattern
        )

/*++

Routine Description:

        Gets the path of the destination directory and the pattern that
        will be used for filename conversion.

Arguments:

    Path                -   Supplies pointer to the path
    CopyingManyFiles    -   Supplies flag which if true means that we are copying many
                            files.
    OutDirectory        -   Supplies pointer to pointer to directory path
    OutFilePattern      -   Supplies pointer to pointer to file name
    IsDir   `           -   Supplies pointer to isdir flag

Return Value:

    None.

Notes:

--*/

{
    PPATH           Directory;
    PWSTRING        FileName;
    PWSTRING        Prefix = NULL;
    PWSTRING        Name = NULL;
    BOOLEAN         DeletePath = FALSE;
    PFSN_DIRECTORY  TmpDir;
    PATH            TmpPath;
    DSTRING         Slash;
    DSTRING         TmpPath1Str;
    PATH            TmpPath1;

    if ( !Path ) {

        //
        //      There is no path, we invent our own
        //
        if ( ((Path = NEW PATH) == NULL ) ||
             !Path->Initialize( (LPWSTR)L"*.*", FALSE)) {

            DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
        }
        DeletePath = TRUE;
    }

    TmpDir = SYSTEM::QueryDirectory( Path );

    if ( !TmpDir && (Path->HasWildCard() || IsFileName( Path, CopyingManyFiles ))) {

        //
        //      The path is not a directory, so we use the prefix as a
        //      directory path and the filename becomes the pattern.
        //
        if ( !TmpPath.Initialize( Path, TRUE )                          ||
             ((Prefix = TmpPath.QueryPrefix()) == NULL)                 ||
             !Slash.Initialize( "\\" )                                  ||
             !TmpPath1Str.Initialize( Prefix )                          ||
             !TmpPath1.Initialize( &TmpPath1Str, FALSE )                ||
             ((Name = TmpPath.QueryName())  == NULL)                    ||
             ((Directory = NEW PATH) == NULL)                           ||
             !Directory->Initialize( &TmpPath1, TRUE )                  ||
             ((FileName = NEW DSTRING) == NULL )                        ||
             !FileName->Initialize( Name ) ) {

            DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );

        }

        DELETE( Prefix );
        DELETE( Name );

    } else {

        //
        //      The path specifies a directory, so we use all of it and the
        //      pattern is "*.*"
        //
        if ( ((Directory = NEW PATH) == NULL )      ||
             !Directory->Initialize( Path,TRUE )    ||
             ((FileName = NEW DSTRING) == NULL )    ||
             !FileName->Initialize( "*.*" ) ) {

            DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );

        }
        DELETE( TmpDir );

    }

    *OutDirectory   = Directory;
    *OutFilePattern = FileName;

    //
    //      If we created the path, we have to delete it
    //
    if ( DeletePath ) {
        DELETE( Path );
    }
}

BOOL
XCOPY::IsCyclicalCopy(
        IN PPATH         PathSrc,
        IN PPATH         PathTrg
        )

/*++

Routine Description:

        Determines if there is a cycle between two paths

Arguments:

        PathSrc -       Supplies pointer to first path
        PathTrg -       Supplies pointer to second path

Return Value:

        TRUE if there is a cycle,
        FALSE otherwise

--*/

{
   PATH           SrcPath;
   PATH           TrgPath;
   PARRAY            ArraySrc, ArrayTrg;
   PARRAY_ITERATOR   IteratorSrc, IteratorTrg;
    PWSTRING     ComponentSrc, ComponentTrg;
   BOOLEAN        IsCyclical  =  FALSE;

        DebugAssert( PathSrc != NULL );

        if ( PathTrg != NULL ) {

                //
                //      Get canonicalized paths for both source and target
                //
                SrcPath.Initialize(PathSrc, TRUE );
                TrgPath.Initialize(PathTrg, TRUE );

                //
                //      Split the paths into their components
                //
                ArraySrc = SrcPath.QueryComponentArray();
                ArrayTrg = TrgPath.QueryComponentArray();

                DebugPtrAssert( ArraySrc );
                DebugPtrAssert( ArrayTrg );

                if ( !ArraySrc || !ArrayTrg ) {
                        DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
                }

                //
                //      Get iterators for the components
                //
                IteratorSrc = ( PARRAY_ITERATOR )ArraySrc->QueryIterator();
                IteratorTrg = ( PARRAY_ITERATOR )ArrayTrg->QueryIterator();

                DebugPtrAssert( IteratorSrc );
                DebugPtrAssert( IteratorTrg );

                if ( !IteratorSrc || !IteratorTrg ) {
                        DisplayMessageAndExit( XCOPY_ERROR_NO_MEMORY, NULL, EXIT_MISC_ERROR );
                }

                //
                //      There is a cycle if all of the source is along the target.
                //
                while ( TRUE )  {

            ComponentSrc = (PWSTRING)IteratorSrc->GetNext();

                        if ( !ComponentSrc ) {

                                //
                                //      The source path is along the target path. This is a
                                //      cycle.
                                //
                                IsCyclical = TRUE;
                                break;

                        }

            ComponentTrg = (PWSTRING)IteratorTrg->GetNext();

                        if ( !ComponentTrg ) {

                                //
                                //      The target path is along the source path. This is no
                                //      cycle.
                                //
                                break;

                        }

                        if ( *ComponentSrc != *ComponentTrg ) {

                                //
                                //      One path is not along the other. There is no cycle.
                                //
                                break;
                        }
                }

                DELETE( IteratorSrc );
                DELETE( IteratorTrg );

                ArraySrc->DeleteAllMembers();
                ArrayTrg->DeleteAllMembers();

                DELETE( ArraySrc );
                DELETE( ArrayTrg );

        }

        return IsCyclical;
}

BOOL
XCOPY::IsFileName(
    IN PPATH     Path,
    IN BOOLEAN   CopyingManyFiles
        )

/*++

Routine Description:

        Figures out if a name refers to a directory or a file.

Arguments:

    Path                -   Supplies pointer to the path
    CopyingManyFiles    -   Supplies flag which if TRUE means that we are
                            copying many files.

Return Value:

        BOOLEAN -       TRUE if name refers to file,
                                FALSE otherwise

Notes:

--*/

{

    PFSN_DIRECTORY  FsnDirectory;
    PFSN_FILE               FsnFile;
    WCHAR                   Resp;
    PWSTRING                DirMsg;
    PWSTRING                FilMsg;

    //
    //      If the path is an existing directory, then this is obviously
    //      not a file.
    //
    //
    if ((FsnDirectory = SYSTEM::QueryDirectory( Path )) != NULL ) {

            DELETE( FsnDirectory );
            return FALSE;
    }

    //
    //      If the path ends with a delimiter, then it is a directory.
    //      We remove the delimiter.
    //
    if ( Path->EndsWithDelimiter() ) {
            ((PWSTRING) Path->GetPathString())->Truncate( Path->GetPathString()->QueryChCount() - 1 );
            Path->Initialize( Path->GetPathString() );
            return FALSE;
    }

    //
    //      If the path is an existing file, then it is a file.
    //
    if ((FsnFile = SYSTEM::QueryFile( Path )) != NULL ) {

            DELETE( FsnFile );
            return _TargetIsFile = TRUE;
    }

    DirMsg = QueryMessageString(XCOPY_RESPONSE_DIRECTORY);
    FilMsg = QueryMessageString(XCOPY_RESPONSE_FILE);

    DebugPtrAssert( DirMsg );
    DebugPtrAssert( FilMsg );

    //
    //  If the path does not exist, we are copying many files, and we are intelligent,
    //  then the target is obviously a directory.
    //
    //  Otherwise we simply ask the user.
    //
    if ( _IntelligentSwitch && CopyingManyFiles ) {

        _TargetIsFile = FALSE;

    } else {

        while ( TRUE ) {

            DisplayMessage( XCOPY_MESSAGE_FILE_OR_DIRECTORY, NORMAL_MESSAGE, "%W", Path->GetPathString() );

            AbortIfCtrlC();

            _Keyboard->DisableLineMode();
            if( GetStandardInput()->IsAtEnd() ) {
                // Insufficient input--treat as CONTROL-C.
                //
                Resp = CTRL_C;
            } else {
                GetStandardInput()->ReadChar( &Resp );
            }
            _Keyboard->EnableLineMode();

            if ( Resp == CTRL_C ) {
                exit( EXIT_TERMINATED );
            } else {
                GetStandardOutput()->WriteChar( Resp );
                GetStandardOutput()->WriteChar( '\r' );
                GetStandardOutput()->WriteChar( '\n' );
            }

            Resp = (WCHAR)towupper( (wchar_t)Resp );

            if ( FilMsg->QueryChAt(0) == Resp ) {
                _TargetIsFile = TRUE;
                break;
            } else if ( DirMsg->QueryChAt(0) == Resp ) {
                _TargetIsFile = FALSE;
                break;
            }
        }
    }

        DELETE( DirMsg );
        DELETE( FilMsg );

        return _TargetIsFile;

}

BOOLEAN
XCOPY::UserConfirmedCopy (
        IN      PCWSTRING        SourcePath,
        IN      PCWSTRING        DestinationPath
        )

/*++

Routine Description:

        Gets confirmation from the user about a file to be copied

Arguments:

        SourcePath      -       Supplies the path to the file to be copied
        DestinationPath -       Supplies the destination path of the file to be created

Return Value:

        BOOLEAN -       TRUE if the user confirmed the copy
                        FALSE otherwise

--*/

{
    PWSTRING        YesMsg;
    PWSTRING        NoMsg;
    WCHAR           Resp;
    BOOLEAN         Confirmed = FALSE;


    YesMsg = QueryMessageString(XCOPY_RESPONSE_YES);
    NoMsg = QueryMessageString(XCOPY_RESPONSE_NO);

    DebugPtrAssert( YesMsg );
    DebugPtrAssert( NoMsg );

    while ( TRUE ) {

        if (DestinationPath) {
            DisplayMessage( XCOPY_MESSAGE_CONFIRM3, NORMAL_MESSAGE, "%W%W",
                            SourcePath, DestinationPath );
        } else {
            DisplayMessage( XCOPY_MESSAGE_CONFIRM, NORMAL_MESSAGE, "%W", SourcePath );
        }

        AbortIfCtrlC();

        _Keyboard->DisableLineMode();

        if( GetStandardInput()->IsAtEnd() ) {
            // Insufficient input--treat as CONTROL-C.
            //
            Resp = NoMsg->QueryChAt( 0 );
            break;
        } else {
            GetStandardInput()->ReadChar( &Resp );
        }
        _Keyboard->EnableLineMode();

        if ( Resp == CTRL_C ) {
            exit( EXIT_TERMINATED );
        } else {
            GetStandardOutput()->WriteChar( Resp );
            GetStandardOutput()->WriteChar( '\r' );
            GetStandardOutput()->WriteChar( '\n' );
        }

        Resp = (WCHAR)towupper( (wchar_t)Resp );

        if ( YesMsg->QueryChAt( 0 ) == Resp ) {
            Confirmed = TRUE;
            break;
        }
        else if ( NoMsg->QueryChAt( 0 ) == Resp ) {
            Confirmed = FALSE;
            break;
        }
    }

    DELETE( YesMsg );
    DELETE( NoMsg );

    return Confirmed;


}

BOOLEAN
XCOPY::UserConfirmedOverWrite (
        IN      PPATH       DestinationFile
        )

/*++

Routine Description:

        Gets confirmation from the user about the overwriting of an existing file

Arguments:

        FsNode  -       Supplies pointer to FSNODE of file to be
                          copied

Return Value:

        BOOLEAN -       TRUE if the user confirmed the overwrite
                          FALSE otherwise

--*/

{
    PWSTRING        YesMsg;
    PWSTRING        NoMsg;
    PWSTRING        AllMsg;
    WCHAR           Resp;
    BOOLEAN         Confirmed;


    YesMsg = QueryMessageString(XCOPY_RESPONSE_YES);
    NoMsg = QueryMessageString(XCOPY_RESPONSE_NO);
    AllMsg = QueryMessageString(XCOPY_RESPONSE_ALL);

    DebugPtrAssert( YesMsg );
    DebugPtrAssert( NoMsg );
    DebugPtrAssert( AllMsg );

    while ( TRUE ) {

        DisplayMessage( XCOPY_MESSAGE_CONFIRM2, NORMAL_MESSAGE, "%W", DestinationFile->GetPathString() );

        AbortIfCtrlC();

        _Keyboard->DisableLineMode();

        if( GetStandardInput()->IsAtEnd() ) {
            // Insufficient input--treat as CONTROL-C.
            //
            exit( EXIT_TERMINATED );
            break;
        } else {
            GetStandardInput()->ReadChar( &Resp );
        }
        _Keyboard->EnableLineMode();

        if ( Resp == CTRL_C ) {
            exit( EXIT_TERMINATED );
        } else {
            GetStandardOutput()->WriteChar( Resp );
            GetStandardOutput()->WriteChar( '\r' );
            GetStandardOutput()->WriteChar( '\n' );
        }

        Resp = (WCHAR)towupper( (wchar_t)Resp );

        if ( YesMsg->QueryChAt( 0 ) == Resp ) {
            Confirmed = TRUE;
            break;
        }
        else if ( NoMsg->QueryChAt( 0 ) == Resp ) {
            Confirmed = FALSE;
            break;
        } else if ( AllMsg->QueryChAt(0) == Resp ) {
            Confirmed = _OverWriteSwitch = TRUE;
            break;
        }
    }

    DELETE( YesMsg );
    DELETE( NoMsg );
    DELETE( AllMsg );

    return Confirmed;


}

BOOLEAN
XCOPY::IsExcluded(
    IN PCPATH   Path
    )
/*++

Routine Description:

    This method determines whether the specified path should be
    excluded from the XCOPY.

Arguments:

    Path    --  Supplies the path of the file in question.

Return Value:

    TRUE if this file should be excluded, i.e. if any element of
    the exclusion list array appears as a substring of this path.

--*/
{
    PWSTRING    CurrentString;
    DSTRING     UpcasedPath;
    DSTRING     BackSlash;

    if( _ExclusionList == NULL ) {

        return FALSE;
    }

    if (!UpcasedPath.Initialize(Path->GetPathString()) ||
        !BackSlash.Initialize(L"\\")) {
        DebugPrint("XCOPY: Out of memory \n");
        return FALSE;
    }

    UpcasedPath.Strupr( );

    if (!Path-> EndsWithDelimiter() &&
        !UpcasedPath.Strcat(&BackSlash)) {
        DebugPrint("XCOPY: Out of memory \n");
        return FALSE;
    }

    _Iterator->Reset();

    while ((CurrentString = (PWSTRING)_Iterator->GetNext()) != NULL) {

        if (UpcasedPath.Strstr(CurrentString) != INVALID_CHNUM) {

            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fsrec\fat_rec.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fat_rec.c

Abstract:

    This module contains the mini-file system recognizer for FAT.

Author:

    Darryl E. Havens (darrylh) 8-dec-1992

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "fs_rec.h"
#include "fat_rec.h"

//
//  The local debug trace level
//

#define Dbg                              (FSREC_DEBUG_LEVEL_FAT)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,FatRecFsControl)
#pragma alloc_text(PAGE,IsFatVolume)
#pragma alloc_text(PAGE,UnpackBiosParameterBlock)
#endif // ALLOC_PRAGMA


NTSTATUS
FatRecFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function performs the mount and driver reload functions for this mini-
    file system recognizer driver.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet (IRP) representing the function to
        be performed.

Return Value:

    The function value is the final status of the operation.


--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT targetDevice;
    PPACKED_BOOT_SECTOR buffer;
    LARGE_INTEGER byteOffset;
    UNICODE_STRING driverName;
    ULONG bytesPerSector;
    BOOLEAN isDeviceFailure = FALSE;

    PAGED_CODE();

    //
    // Begin by determining what function that is to be performed.
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    switch ( irpSp->MinorFunction ) {

    case IRP_MN_MOUNT_VOLUME:

        //
        // Attempt to mount a volume:  Determine whether or not the volume in
        // question is a FAT volume and, if so, let the I/O system know that it
        // is by returning a special status code so that this driver can get
        // called back to load the FAT file system.
        //

        status = STATUS_UNRECOGNIZED_VOLUME;

        //
        // Attempt to determine whether or not the target volume being mounted
        // is a FAT volume.  Note that if an error occurs, and this is a floppy
        // drive, and the error occurred on the actual read from the device,
        // then the FAT file system will actually be loaded to handle the
        // problem since this driver is a place holder and does not need to
        // know all of the protocols for handling floppy errors.
        //

        targetDevice = irpSp->Parameters.MountVolume.DeviceObject;

        //
        //  First retrieve the sector size for this media.
        //

        if (FsRecGetDeviceSectorSize( targetDevice,
                                      &bytesPerSector )) {

            byteOffset.QuadPart = 0;
            buffer = NULL;

            if (FsRecReadBlock( targetDevice,
                                &byteOffset,
                                512,
                                bytesPerSector,
                                &buffer,
                                &isDeviceFailure ) &&
                IsFatVolume( buffer )) {
                    
                status = STATUS_FS_DRIVER_REQUIRED;
                
            }

            if (buffer != NULL) {
                ExFreePool( buffer );
            }
            
         } else {

             //
             //  Devices that can't get us this much ...
             //

             isDeviceFailure = TRUE;
         }
            
         //
         //  See if we should make the real filesystem take a shot at a wacky floppy.
         //
         
         if (isDeviceFailure) {
             if (targetDevice->Characteristics & FILE_FLOPPY_DISKETTE) {
                 status = STATUS_FS_DRIVER_REQUIRED;
             }
         }

         break;

    case IRP_MN_LOAD_FILE_SYSTEM:

        status = FsRecLoadFileSystem( DeviceObject,
                                      L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Fastfat" );
        break;

    default:
        status = STATUS_INVALID_DEVICE_REQUEST;

    }

    //
    // Finally, complete the request and return the same status code to the
    // caller.
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}


BOOLEAN
IsFatVolume(
    IN PPACKED_BOOT_SECTOR Buffer
    )

/*++

Routine Description:

    This routine looks at the buffer passed in which contains the FAT boot
    sector and determines whether or not it represents an actual FAT boot
    sector.

Arguments:

    Buffer - Pointer to buffer containing potential boot block.

Return Value:

    The function returns TRUE if the buffer contains a recognizable FAT boot
    sector, otherwise it returns FALSE.

--*/

{
    BIOS_PARAMETER_BLOCK bios;
    BOOLEAN result;

    PAGED_CODE();

    //
    // Begin by unpacking the Bios Parameter Block that is packed in the boot
    // sector so that it can be examined without incurring alignment faults.
    //

    UnpackBiosParameterBlock( &Buffer->PackedBpb, &bios );

    //
    // Assume that the sector represents a FAT boot block and then determine
    // whether or not it really does.
    //

    result = TRUE;

    if (bios.Sectors) {
        bios.LargeSectors = 0;
    }

    // FMR Jul.11.1994 NaokiM - Fujitsu -
    // FMR boot sector has 'IPL1' string at the beginnig.

    if (Buffer->Jump[0] != 0x49 && /* FMR */
        Buffer->Jump[0] != 0xe9 &&
        Buffer->Jump[0] != 0xeb) {

        result = FALSE;


    // FMR Jul.11.1994 NaokiM - Fujitsu -
    // Sector size of FMR partition is 2048.

    } else if (bios.BytesPerSector !=  128 &&
               bios.BytesPerSector !=  256 &&
               bios.BytesPerSector !=  512 &&
               bios.BytesPerSector != 1024 &&
               bios.BytesPerSector != 2048 && /* FMR */
               bios.BytesPerSector != 4096) {

        result = FALSE;

    } else if (bios.SectorsPerCluster !=  1 &&
               bios.SectorsPerCluster !=  2 &&
               bios.SectorsPerCluster !=  4 &&
               bios.SectorsPerCluster !=  8 &&
               bios.SectorsPerCluster != 16 &&
               bios.SectorsPerCluster != 32 &&
               bios.SectorsPerCluster != 64 &&
               bios.SectorsPerCluster != 128) {

        result = FALSE;

    } else if (!bios.ReservedSectors) {

        result = FALSE;

    } else if (!bios.Fats) {

        result = FALSE;

    //
    // Prior to DOS 3.2 might contains value in both of Sectors and
    // Sectors Large.
    //
    } else if (!bios.Sectors && !bios.LargeSectors) {

        result = FALSE;

    // FMR Jul.11.1994 NaokiM - Fujitsu -
    // 1. Media descriptor of FMR partitions is 0xfa.
    // 2. Media descriptor of partitions formated by FMR OS/2 is 0x00.
    // 3. Media descriptor of floppy disks formated by FMR DOS is 0x01.

    } else if (bios.Media != 0x00 && /* FMR */
               bios.Media != 0x01 && /* FMR */
               bios.Media != 0xf0 &&
               bios.Media != 0xf8 &&
               bios.Media != 0xf9 &&
               bios.Media != 0xfa && /* FMR */
               bios.Media != 0xfb &&
               bios.Media != 0xfc &&
               bios.Media != 0xfd &&
               bios.Media != 0xfe &&
               bios.Media != 0xff) {

        result = FALSE;

    } else if (bios.SectorsPerFat != 0 && bios.RootEntries == 0) {

        result = FALSE;
    }

    return result;
}


VOID
UnpackBiosParameterBlock(
    IN PPACKED_BIOS_PARAMETER_BLOCK Bios,
    OUT PBIOS_PARAMETER_BLOCK UnpackedBios
    )

/*++

Routine Description:

    This routine copies a packed Bios Parameter Block to an unpacked Bios
    Parameter Block.

Arguments:

    Bios - Pointer to the packed Bios Parameter Block.

    UnpackedBios - Pointer to the unpacked Bios Parameter Block.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    //
    // Unpack the Bios Parameter Block.
    //

    CopyUchar2( &UnpackedBios->BytesPerSector, &Bios->BytesPerSector[0] );
    CopyUchar2( &UnpackedBios->BytesPerSector, &Bios->BytesPerSector[0] );
    CopyUchar1( &UnpackedBios->SectorsPerCluster, &Bios->SectorsPerCluster[0] );
    CopyUchar2( &UnpackedBios->ReservedSectors, &Bios->ReservedSectors[0] );
    CopyUchar1( &UnpackedBios->Fats, &Bios->Fats[0] );
    CopyUchar2( &UnpackedBios->RootEntries, &Bios->RootEntries[0] );
    CopyUchar2( &UnpackedBios->Sectors, &Bios->Sectors[0] );
    CopyUchar1( &UnpackedBios->Media, &Bios->Media[0] );
    CopyUchar2( &UnpackedBios->SectorsPerFat, &Bios->SectorsPerFat[0] );
    CopyUchar2( &UnpackedBios->SectorsPerTrack, &Bios->SectorsPerTrack[0] );
    CopyUchar2( &UnpackedBios->Heads, &Bios->Heads[0] );
    CopyUchar4( &UnpackedBios->HiddenSectors, &Bios->HiddenSectors[0] );
    CopyUchar4( &UnpackedBios->LargeSectors, &Bios->LargeSectors[0] );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fsrec\cdfs_rec.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    cdfs_rec.c

Abstract:

    This module contains the mini-file system recognizer for CDFS.

Author:

    Darryl E. Havens (darrylh) 8-dec-1992

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "fs_rec.h"

//
//  The local debug trace level
//

#define Dbg                              (FSREC_DEBUG_LEVEL_CDFS)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,CdfsRecFsControl)
#endif // ALLOC_PRAGMA


NTSTATUS
CdfsRecFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function performs the mount and driver reload functions for this mini-
    file system recognizer driver.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet (IRP) representing the function to
        be performed.

Return Value:

    The function value is the final status of the operation.


 -*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    //
    // Begin by determining what function that is to be performed.
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    switch ( irpSp->MinorFunction ) {

    case IRP_MN_MOUNT_VOLUME:

        //
        //  Always request the filesystem driver.
        //
        
        status = STATUS_FS_DRIVER_REQUIRED;
        break;

    case IRP_MN_LOAD_FILE_SYSTEM:

        status = FsRecLoadFileSystem( DeviceObject,
                                      L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Cdfs" );
        break;

    default:
        
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }

    //
    // Finally, complete the request and return the same status code to the
    // caller.
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fsrec\fat_rec.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fat_rec.h

Abstract:

    This module contains the mini-file system recognizer for FAT.

Author:

    Darryl E. Havens (darrylh) 8-dec-1992

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

//
//  The following types and macros are used to help unpack the packed and
//  misaligned fields found in the Bios parameter block
//

typedef union _UCHAR1 {
    UCHAR  Uchar[1];
    UCHAR  ForceAlignment;
} UCHAR1, *PUCHAR1;

typedef union _UCHAR2 {
    UCHAR  Uchar[2];
    USHORT ForceAlignment;
} UCHAR2, *PUCHAR2;

typedef union _UCHAR4 {
    UCHAR  Uchar[4];
    ULONG  ForceAlignment;
} UCHAR4, *PUCHAR4;

//
//  This macro copies an unaligned src byte to an aligned dst byte
//

#define CopyUchar1(Dst,Src) {                                \
    *((UCHAR1 *)(Dst)) = *((UNALIGNED UCHAR1 *)(Src)); \
    }

//
//  This macro copies an unaligned src word to an aligned dst word
//

#define CopyUchar2(Dst,Src) {                                \
    *((UCHAR2 *)(Dst)) = *((UNALIGNED UCHAR2 *)(Src)); \
    }

//
//  This macro copies an unaligned src longword to an aligned dsr longword
//

#define CopyUchar4(Dst,Src) {                                \
    *((UCHAR4 *)(Dst)) = *((UNALIGNED UCHAR4 *)(Src)); \
    }

//
//  Define the Packed and Unpacked BIOS Parameter Block
//

typedef struct _PACKED_BIOS_PARAMETER_BLOCK {
    UCHAR  BytesPerSector[2];                       // offset = 0x000  0
    UCHAR  SectorsPerCluster[1];                    // offset = 0x002  2
    UCHAR  ReservedSectors[2];                      // offset = 0x003  3
    UCHAR  Fats[1];                                 // offset = 0x005  5
    UCHAR  RootEntries[2];                          // offset = 0x006  6
    UCHAR  Sectors[2];                              // offset = 0x008  8
    UCHAR  Media[1];                                // offset = 0x00A 10
    UCHAR  SectorsPerFat[2];                        // offset = 0x00B 11
    UCHAR  SectorsPerTrack[2];                      // offset = 0x00D 13
    UCHAR  Heads[2];                                // offset = 0x00F 15
    UCHAR  HiddenSectors[4];                        // offset = 0x011 17
    UCHAR  LargeSectors[4];                         // offset = 0x015 21
} PACKED_BIOS_PARAMETER_BLOCK;                      // sizeof = 0x019 25

typedef PACKED_BIOS_PARAMETER_BLOCK *PPACKED_BIOS_PARAMETER_BLOCK;

typedef struct BIOS_PARAMETER_BLOCK {
    USHORT BytesPerSector;
    UCHAR  SectorsPerCluster;
    USHORT ReservedSectors;
    UCHAR  Fats;
    USHORT RootEntries;
    USHORT Sectors;
    UCHAR  Media;
    USHORT SectorsPerFat;
    USHORT SectorsPerTrack;
    USHORT Heads;
    ULONG  HiddenSectors;
    ULONG  LargeSectors;
} BIOS_PARAMETER_BLOCK, *PBIOS_PARAMETER_BLOCK;

//
//  Define the boot sector
//

typedef struct _PACKED_BOOT_SECTOR {
    UCHAR Jump[3];                                  // offset = 0x000   0
    UCHAR Oem[8];                                   // offset = 0x003   3
    PACKED_BIOS_PARAMETER_BLOCK PackedBpb;          // offset = 0x00B  11
    UCHAR PhysicalDriveNumber;                      // offset = 0x024  36
    UCHAR Reserved;                                 // offset = 0x025  37
    UCHAR Signature;                                // offset = 0x026  38
    UCHAR Id[4];                                    // offset = 0x027  39
    UCHAR VolumeLabel[11];                          // offset = 0x02B  43
    UCHAR SystemId[8];                              // offset = 0x036  54
} PACKED_BOOT_SECTOR;                               // sizeof = 0x03E  62

typedef PACKED_BOOT_SECTOR *PPACKED_BOOT_SECTOR;

//
// Define the functions provided by this driver.
//

BOOLEAN
IsFatVolume(
    IN PPACKED_BOOT_SECTOR Buffer
    );

VOID
UnpackBiosParameterBlock(
    IN PPACKED_BIOS_PARAMETER_BLOCK Bios,
    OUT PBIOS_PARAMETER_BLOCK UnpackedBios
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fsrec\fs_rec.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fs_rec.h

Abstract:

    This module contains the main header file for the mini-file system
    recognizer driver.

Author:

    Darryl E. Havens (darrylh) 22-nov-1993

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "ntifs.h"
#include "ntdddisk.h"
#include "ntddcdrm.h"

//
//  Define the debug trace levels.
//

#define FSREC_DEBUG_LEVEL_FSREC     0x00000001
#define FSREC_DEBUG_LEVEL_NTFS      0x00000002
#define FSREC_DEBUG_LEVEL_CDFS      0x00000004
#define FSREC_DEBUG_LEVEL_UDFS      0x00000008
#define FSREC_DEBUG_LEVEL_FAT       0x00000010

#define FSREC_POOL_TAG		    'crsF' 

//#ifndef SetFlag
//#define SetFlag(Flags,SingleFlag) (     \
//    (Flags) |= (SingleFlag)             \
//)
//#endif

//#ifndef ClearFlag
//#define ClearFlag(Flags,SingleFlag) (   \
//    (Flags) &= ~(SingleFlag)            \
//)
//#endif

//
// Define the file system types for the device extension.
//

typedef enum _FILE_SYSTEM_TYPE {
    CdfsFileSystem = 1,
    FatFileSystem,
    HpfsFileSystem,
    NtfsFileSystem,
    UdfsFileSystem
} FILE_SYSTEM_TYPE, *PFILE_SYSTEM_TYPE;

//
// Define the device extension for this driver.
//

typedef enum _RECOGNIZER_STATE {
    Active,
    Transparent,
    FastUnload
} RECOGNIZER_STATE, *PRECOGNIZER_STATE;

typedef struct _DEVICE_EXTENSION {
    PDEVICE_OBJECT CoRecognizer;
    FILE_SYSTEM_TYPE FileSystemType;
    RECOGNIZER_STATE State;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

//
// Define the functions provided by this driver.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
FsRecCleanupClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FsRecShutdown(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FsRecCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FsRecCreateAndRegisterDO(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT HeadRecognizer OPTIONAL,
    OUT PDEVICE_OBJECT *NewRecognizer OPTIONAL,
    IN PWCHAR RecFileSystem,
    IN PWCHAR FileSystemName,
    IN FILE_SYSTEM_TYPE FileSystemType,
    IN DEVICE_TYPE DeviceType
    );

NTSTATUS
FsRecFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
FsRecUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
FsRecLoadFileSystem (
    IN PDEVICE_OBJECT DeviceObject,
    IN PWCHAR DriverServiceKey
    );

BOOLEAN
FsRecGetDeviceSectorSize (
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG BytesPerSector
    );

BOOLEAN
FsRecGetDeviceSectors (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG BytesPerSector,
    OUT PLARGE_INTEGER NumberOfSectors
    );

BOOLEAN
FsRecReadBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLARGE_INTEGER ByteOffset,
    IN ULONG MinimumBytes,
    IN ULONG BytesPerSector,
    OUT PVOID *Buffer,
    OUT PBOOLEAN IsDeviceFailure OPTIONAL
    );

#if DBG

extern LONG FsRecDebugTraceLevel;
extern LONG FsRecDebugTraceIndent;

BOOLEAN
FsRecDebugTrace (
    LONG IndentIncrement,
    ULONG TraceMask,
    PCHAR Format,
    ...
    );

#define DebugTrace(M) FsRecDebugTrace M

#else

#define DebugTrace(M) TRUE

#endif


//
//  Define the per-type recognizers.
//

NTSTATUS
CdfsRecFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UdfsRecFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FatRecFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
NtfsRecFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fsrec\udfs_rec.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    udfs_rec.c

Abstract:

    This module contains the mini-file system recognizer for UDFS.

Author:

    Dan Lovinger (danlo) 13-Feb-1997

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "fs_rec.h"
#include "udfs_rec.h"

//
//  The local debug trace level
//

#define Dbg                              (FSREC_DEBUG_LEVEL_UDFS)

//
//  Tables of tokens we have to parse up from mount-time on-disk structures
//

PARSE_KEYVALUE VsdIdentParseTable[] = {
    { VSD_IDENT_BEA01, VsdIdentBEA01 },
    { VSD_IDENT_TEA01, VsdIdentTEA01 },
    { VSD_IDENT_CDROM, VsdIdentCDROM },
    { VSD_IDENT_CD001, VsdIdentCD001 },
    { VSD_IDENT_CDW01, VsdIdentCDW01 },
    { VSD_IDENT_CDW02, VsdIdentCDW02 },
    { VSD_IDENT_NSR01, VsdIdentNSR01 },
    { VSD_IDENT_NSR02, VsdIdentNSR02 },
    { VSD_IDENT_BOOT2, VsdIdentBOOT2 },
    { VSD_IDENT_NSR03, VsdIdentNSR03 },
    { NULL,            VsdIdentBad }
    };

NTSTATUS
UdfsRecGetLastSessionStart(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG Psn
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,IsUdfsVolume)
#pragma alloc_text(PAGE,UdfsFindInParseTable)
#pragma alloc_text(PAGE,UdfsRecFsControl)
#pragma alloc_text(PAGE,UdfsRecGetLastSessionStart)
#endif // ALLOC_PRAGMA


//
//  This macro copies an unaligned src longword to a dst longword,
//  performing an little/big endian swap.
//

#define SwapCopyUchar4(Dst,Src) {                                        \
    *((UNALIGNED UCHAR *)(Dst)) = *((UNALIGNED UCHAR *)(Src) + 3);     \
    *((UNALIGNED UCHAR *)(Dst) + 1) = *((UNALIGNED UCHAR *)(Src) + 2); \
    *((UNALIGNED UCHAR *)(Dst) + 2) = *((UNALIGNED UCHAR *)(Src) + 1); \
    *((UNALIGNED UCHAR *)(Dst) + 3) = *((UNALIGNED UCHAR *)(Src));     \
}

#define Max(a,b) (((a) > (b)) ? (a) : (b))


NTSTATUS
UdfsRecGetLastSessionStart(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG Psn
    )
/*++

Routine Description:

    This function queries the underlying device for the address of the
    first track in the last session.  Does nothing for DISK devices.
    
Arguments:

    DeviceObject - Pointer to this driver's device object.

    Psn - receives physical sector number of first block in last session,
          0 for disk devices

Return Value:

    The function value is the final status of the operation.

 -*/
{
    KEVENT Event;
    NTSTATUS Status;
    IO_STATUS_BLOCK ioStatus;
    CDROM_TOC_SESSION_DATA SessionData;
    PIRP Irp;

    *Psn = 0;
    
    if (DeviceObject->DeviceType != FILE_DEVICE_CD_ROM) {

        return STATUS_SUCCESS;
    }

    KeInitializeEvent( &Event, SynchronizationEvent, FALSE );

    Irp = IoBuildDeviceIoControlRequest( IOCTL_CDROM_GET_LAST_SESSION,
                                         DeviceObject,
                                         (PVOID) NULL,
                                         0,
                                         &SessionData,
                                         sizeof( SessionData ),
                                         FALSE,
                                         &Event,
                                         &ioStatus );
    if (!Irp) {
    
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Override verify logic - we don't care. The fact we're in the picture means
    //  someone is trying to mount new/changed media in the first place.
    //
    
    SetFlag( IoGetNextIrpStackLocation( Irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );

    Status = IoCallDriver( DeviceObject, Irp );
    
    if (Status == STATUS_PENDING) {
    
        (VOID) KeWaitForSingleObject( &Event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
        Status = ioStatus.Status;
    }

    if (!NT_SUCCESS( Status )) {
    
        return Status;
    }

    if (SessionData.FirstCompleteSession != SessionData.LastCompleteSession)  {

        SwapCopyUchar4( Psn, &SessionData.TrackData[0].Address );
    }
    
    return STATUS_SUCCESS;
}



NTSTATUS
UdfsRecFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function performs the mount and driver reload functions for this mini-
    file system recognizer driver.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet (IRP) representing the function to
        be performed.

Return Value:

    The function value is the final status of the operation.


 -*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_EXTENSION deviceExtension;
    UNICODE_STRING driverName;
    ULONG bytesPerSector;
    PDEVICE_OBJECT targetDevice;

    PAGED_CODE();

    //
    // Begin by determining what function that is to be performed.
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    switch ( irpSp->MinorFunction ) {

    case IRP_MN_MOUNT_VOLUME:

        //
        // Attempt to mount a volume:  There are two different cases here:
        //
        //     1)  The device is being opened for DASD access, that is, no
        //         file system is required, thus it is OK to allow RAW to
        //         to open it.
        //
        //     2)  We need to rummage the media to see if this is a UDF volume.
        //

        status = STATUS_UNRECOGNIZED_VOLUME;

        targetDevice = irpSp->Parameters.MountVolume.DeviceObject;

        if (FsRecGetDeviceSectorSize( targetDevice,
                                      &bytesPerSector )) {
        
            if (IsUdfsVolume( targetDevice,
                              bytesPerSector )) {

                status = STATUS_FS_DRIVER_REQUIRED;
            }
        }

        break;

    case IRP_MN_LOAD_FILE_SYSTEM:

        status = FsRecLoadFileSystem( DeviceObject,
                                      L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Udfs" );
        break;

    default:
        status = STATUS_INVALID_DEVICE_REQUEST;

    }

    //
    // Finally, complete the request and return the same status code to the
    // caller.
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}


BOOLEAN
IsUdfsVolume (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize
    )

/*++

Routine Description:

    This routine walks the Volume Recognition Sequence to determine
    whether this volume contains an NSR02 (ISO 13346 Section 4) image.
    
    Note: this routine is pretty much diked out of UdfsRecognizeVolume
    in the real filesystem, modulo fitting it into the fs recognizer.

Arguments:

    DeviceObject - device we are checking

    SectorSize - size of a physical sector on this device

Return Value:

    Boolean TRUE if we found NSR02, FALSE otherwise.

--*/

{
    BOOLEAN FoundNSR;

    BOOLEAN FoundBEA;
    BOOLEAN Resolved;

    ULONG LastSessionStartPsn;
    ULONG AssumedDescriptorSize = sizeof(VSD_GENERIC);

    PVSD_GENERIC VolumeStructureDescriptor = NULL;
    PVOID Buffer = NULL;
    ULONGLONG Offset;
    ULONGLONG StartOffset;

    PAGED_CODE();

    DebugTrace(( +1, Dbg,
                 "IsUdfsVolume, DevObj %08x SectorSize %08x\n",
                 DeviceObject,
                 SectorSize ));

    //
    //  Find the start of the last session
    //

    if (!NT_SUCCESS( UdfsRecGetLastSessionStart( DeviceObject, 
                                                 &LastSessionStartPsn)))  {

        return FALSE;
    }

Retry:

    DebugTrace(( 0, Dbg, "IsUdfsVolume, Looking at session starting Psn == 0x%x\n", LastSessionStartPsn));

    StartOffset =
    Offset = (SectorSize * LastSessionStartPsn) + SectorAlignN( SectorSize, VRA_BOUNDARY_LOCATION );

    FoundNSR = 
    FoundBEA =
    Resolved = FALSE;

    while (!Resolved) {

        //
        //  The VRS descriptors are 2kb,  and there's a lot of media out there where
        //  people have interpreted this as meaning the descriptors should be aligned
        //  on 2k boundries even on >2k sector size media.  So we need to look at
        //  both 2k and sector offsets on such media.  (ECMA 2/8.4 specifies that these
        //  descriptors shall all be aligned to the start of a sector).
        //
        
        if (0 == (Offset & (SectorSize - 1)))  {

            if (!FsRecReadBlock( DeviceObject,
                                 (PLARGE_INTEGER)&Offset,
                                 sizeof(VSD_GENERIC),
                                 SectorSize,
                                 &Buffer,
                                 NULL ))  {
                break;
            }

            VolumeStructureDescriptor = Buffer;
        }

        //
        //  Now check the type of the descriptor. All ISO 13346 VSDs are
        //  of Type 0, 9660 PVDs are Type 1, 9660 SVDs are Type 2, and 9660
        //  terminating descriptors are Type 255.
        //
    
        if (VolumeStructureDescriptor->Type == 0) {

            //
            //  In order to properly recognize the volume, we must know all of the
            //  Structure identifiers in ISO 13346 so that we can terminate if a
            //  badly formatted (or, shockingly, non 13346) volume is presented to us.
            //

            switch (UdfsFindInParseTable( VsdIdentParseTable,
                                         VolumeStructureDescriptor->Ident,
                                         VSD_LENGTH_IDENT )) {
                case VsdIdentBEA01:

                    //
                    //  Only one BEA may exist and its version must be 1 (2/9.2.3)
                    //

                    DebugTrace(( 0, Dbg, "IsUdfsVolume, got a BEA01\n" ));


                    if ((FoundBEA &&
                         DebugTrace(( 0, Dbg,
                                      "IsUdfsVolume, ... but it is a duplicate!\n" ))) ||

                        (VolumeStructureDescriptor->Version != 1 &&
                         DebugTrace(( 0, Dbg,
                                      "IsUdfsVolume, ... but it has a wacky version number %02x != 1!\n",
                                      VolumeStructureDescriptor->Version )))) {

                        Resolved = TRUE;
                        break;
                    }

                    FoundBEA = TRUE;
                    break;

                case VsdIdentTEA01:

                    //
                    //  If we reach the TEA it must be the case that we don't recognize
                    //

                    DebugTrace(( 0, Dbg, "IsUdfsVolume, got a TEA01\n" ));

                    Resolved = TRUE;
                    break;

                case VsdIdentNSR02:
                case VsdIdentNSR03:

                    //
                    //  We recognize NSR02 version 1 embedded after a BEA (3/9.1.3).  For
                    //  simplicity we will not bother being a complete nitpick and check
                    //  for a bounding TEA, although we will be optimistic in the case where
                    //  we fail to match the version.
                    //

                    DebugTrace(( 0, Dbg, "IsUdfsVolume, got an NSR02/3\n" ));

                    if ((FoundBEA ||
                         !DebugTrace(( 0, Dbg, "IsUdfsVolume, ... but we haven't seen a BEA01 yet!\n" ))) &&

                        (VolumeStructureDescriptor->Version == 1 ||
                         !DebugTrace(( 0, Dbg, "IsUdfsVolume, ... but it has a wacky version number %02x != 1\n",
                                       VolumeStructureDescriptor->Version )))) {

                        FoundNSR = Resolved = TRUE;
                        break;
                    }

                    break;

                case VsdIdentCD001:
                case VsdIdentCDW01:
                case VsdIdentNSR01:
                case VsdIdentCDW02:
                case VsdIdentBOOT2:

                    DebugTrace(( 0, Dbg, "IsUdfsVolume, got a valid but uninteresting 13346 descriptor\n" ));

                    //
                    //  Valid but uninteresting (to us) descriptors
                    //

                    break;

                default:

                    DebugTrace(( 0, Dbg, "IsUdfsVolume, got an invalid 13346 descriptor\n" ));

                    //
                    //  This probably was a false alert, but in any case there is nothing
                    //  on this volume for us.  Exception is if this media sector size
                    //  is >= 4k,  and this was the second descriptor.  We'll allow
                    //  a failure here,  and switch to reading in whole sector increments.
                    //

                    if ((Offset == (StartOffset + sizeof(VSD_GENERIC))) &&
                        (SectorSize > sizeof( VSD_GENERIC))) {

                        Offset -= AssumedDescriptorSize;
                        AssumedDescriptorSize = SectorSize;
                    }
                    else {
                    
                        Resolved = TRUE;
                    }
                    break;
            }

        } 
        else if (!FoundBEA && (VolumeStructureDescriptor->Type < 3 ||
                 VolumeStructureDescriptor->Type == 255)) {

            DebugTrace(( 0, Dbg, "IsUdfsVolume, got a 9660 descriptor\n" ));

            //
            //  Only HSG (CDROM) and 9660 (CD001) are possible, and they are only legal
            //  before the ISO 13346 BEA/TEA extent.  By design, an ISO 13346 VSD precisely
            //  overlaps a 9660 PVD/SVD in the appropriate fields.
            //
            //  Note that we aren't being strict about the structure of the 9660 descriptors
            //  since that really isn't very interesting.  We care more about the 13346.
            //  
            //

            switch (UdfsFindInParseTable( VsdIdentParseTable,
                                          VolumeStructureDescriptor->Ident,
                                          VSD_LENGTH_IDENT )) {
                case VsdIdentCDROM:
                case VsdIdentCD001:

                    DebugTrace(( 0, Dbg, "IsUdfsVolume, ... seems we have 9660 here\n" ));

                    //
                    //  Note to our caller that we seem to have ISO 9660 here
                    //

                    break;

                default:

                    DebugTrace(( 0, Dbg, "IsUdfsVolume, ... but it looks wacky\n" ));

                    //
                    //  This probably was a false alert, but in any case there is nothing
                    //  on this volume for us.  Exception is if this media sector size
                    //  is >= 4k,  and this was the second descriptor.  We'll allow
                    //  a failure here,  and switch to reading in whole sector increments.
                    //

                    if ((Offset == (StartOffset + sizeof(VSD_GENERIC))) &&
                        (SectorSize > sizeof( VSD_GENERIC))) {

                        Offset -= AssumedDescriptorSize;
                        AssumedDescriptorSize = SectorSize;
                    }
                    else {
                    
                        Resolved = TRUE;
                    }
                    break;
            }

        } else {

            //
            //  Something else must be recorded on this volume.
            //

            DebugTrace(( 0, Dbg, "IsUdfsVolume, got an unrecognizeable descriptor, probably not 13346/9660\n" ));
            break;
        }

        Offset += AssumedDescriptorSize;
        VolumeStructureDescriptor = (PVSD_GENERIC)(((PUCHAR)VolumeStructureDescriptor) + sizeof( VSD_GENERIC));
    }

    //
    //  If we were looking in the last session,  and failed to find anything,  then
    //  go back and try the first.
    //
    
    if (!FoundNSR && (0 != LastSessionStartPsn))  {

        LastSessionStartPsn = 0;

        goto Retry;
    }

    DebugTrace(( -1, Dbg, "IsUdfsVolume -> %c\n", ( FoundNSR ? 'T' : 'F' )));

    //
    //  Free up our temporary buffer
    //

    if (Buffer) {
    
        ExFreePool( Buffer );
    }

    return FoundNSR;
}


ULONG
UdfsFindInParseTable (
    IN PPARSE_KEYVALUE ParseTable,
    IN PCHAR Id,
    IN ULONG MaxIdLen
    )

/*++

Routine Description:

    This routine walks a table of string key/value information for a match of the
    input Id.  MaxIdLen can be set to get a prefix match.

Arguments:

    Table - This is the table being searched.

    Id - Key value.

    MaxIdLen - Maximum possible length of Id.

Return Value:

    Value of matching entry, or the terminating (NULL) entry's value.

--*/

{
    PAGED_CODE();

    while (ParseTable->Key != NULL) {

        if (RtlEqualMemory(ParseTable->Key, Id, MaxIdLen)) {

            break;
        }

        ParseTable++;
    }

    return ParseTable->Value;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fsrec\ntfs_rec.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ntfs_rec.c

Abstract:

    This module contains the mini-file system recognizer for NTFS.

Author:

    Darryl E. Havens (darrylh) 8-dec-1992

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "fs_rec.h"
#include "ntfs_rec.h"

//
//  The local debug trace level
//

#define Dbg                              (FSREC_DEBUG_LEVEL_NTFS)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,NtfsRecFsControl)
#pragma alloc_text(PAGE,IsNtfsVolume)
#endif // ALLOC_PRAGMA


NTSTATUS
NtfsRecFsControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function performs the mount and driver reload functions for this mini-
    file system recognizer driver.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet (IRP) representing the function to
        be performed.

Return Value:

    The function value is the final status of the operation.


--*/

{
    NTSTATUS status;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT targetDevice;
    PPACKED_BOOT_SECTOR buffer;
    LARGE_INTEGER byteOffset;
    LARGE_INTEGER secondByteOffset;
    LARGE_INTEGER lastByteOffset;
    UNICODE_STRING driverName;
    ULONG bytesPerSector;
    LARGE_INTEGER numberOfSectors;

    PAGED_CODE();

    //
    // Begin by determining what function that is to be performed.
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    switch ( irpSp->MinorFunction ) {

    case IRP_MN_MOUNT_VOLUME:

        //
        // Attempt to mount a volume:  Determine whether or not the volume in
        // question is an NTFS volume and, if so, let the I/O system know that it
        // is by returning a special status code so that this driver can get
        // called back to load the NTFS file system.
        //

        status = STATUS_UNRECOGNIZED_VOLUME;

        //
        // Attempt to determine whether or not the target volume being mounted
        // is an NTFS volume.
        //

        targetDevice = irpSp->Parameters.MountVolume.DeviceObject;

        if (FsRecGetDeviceSectorSize( targetDevice,
                                      &bytesPerSector ) &&
            FsRecGetDeviceSectors( targetDevice,
                                   bytesPerSector,
                                   &numberOfSectors )) {

            byteOffset.QuadPart = 0;
            buffer = NULL;
            secondByteOffset.QuadPart = numberOfSectors.QuadPart >> 1;
            secondByteOffset.QuadPart *= (LONG) bytesPerSector;
            lastByteOffset.QuadPart = (numberOfSectors.QuadPart - 1) * (LONG) bytesPerSector;

            if (FsRecReadBlock( targetDevice,
                                &byteOffset,
                                sizeof( PACKED_BOOT_SECTOR ),
                                bytesPerSector,
                                (PVOID *)&buffer,
                                NULL ))
            {

                if (IsNtfsVolume( buffer, bytesPerSector, &numberOfSectors )) {
                    status = STATUS_FS_DRIVER_REQUIRED;
                }

            } else {

                if (FsRecReadBlock( targetDevice,
                                    &secondByteOffset,
                                    sizeof( PACKED_BOOT_SECTOR ),
                                    bytesPerSector,
                                    (PVOID *)&buffer,
                                    NULL ) &&
                    IsNtfsVolume( buffer, bytesPerSector, &numberOfSectors )) {

                    status = STATUS_FS_DRIVER_REQUIRED;

                } else {

                    if (FsRecReadBlock( targetDevice,
                                        &lastByteOffset,
                                        sizeof( PACKED_BOOT_SECTOR ),
                                        bytesPerSector,
                                        (PVOID *)&buffer,
                                        NULL ) &&
                        IsNtfsVolume( buffer, bytesPerSector, &numberOfSectors )) {

                        status = STATUS_FS_DRIVER_REQUIRED;
                    }
                }
            }

            if (buffer != NULL) {
                ExFreePool( buffer );
            }
        }

        break;

    case IRP_MN_LOAD_FILE_SYSTEM:

        status = FsRecLoadFileSystem( DeviceObject,
                                      L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Ntfs" );
        break;

    default:
        status = STATUS_INVALID_DEVICE_REQUEST;

    }

    //
    // Finally, complete the request and return the same status code to the
    // caller.
    //

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}


BOOLEAN
IsNtfsVolume(
    IN PPACKED_BOOT_SECTOR BootSector,
    IN ULONG BytesPerSector,
    IN PLARGE_INTEGER NumberOfSectors
    )

/*++

Routine Description:

    This routine looks at the buffer passed in which contains the NTFS boot
    sector and determines whether or not it represents an NTFS volume.

Arguments:

    BootSector - Pointer to buffer containing a potential NTFS boot sector.

    BytesPerSector - Supplies the number of bytes per sector for the drive.

    NumberOfSectors - Supplies the number of sectors on the partition.

Return Value:

    The function returns TRUE if the buffer contains a recognizable NTFS boot
    sector, otherwise it returns FALSE.

--*/

{
    PAGED_CODE();

    //
    // Now perform all the checks, starting with the Name and Checksum.
    // The remaining checks should be obvious, including some fields which
    // must be 0 and other fields which must be a small power of 2.
    //

    if (BootSector->Oem[0] == 'N' &&
        BootSector->Oem[1] == 'T' &&
        BootSector->Oem[2] == 'F' &&
        BootSector->Oem[3] == 'S' &&
        BootSector->Oem[4] == ' ' &&
        BootSector->Oem[5] == ' ' &&
        BootSector->Oem[6] == ' ' &&
        BootSector->Oem[7] == ' '

            &&

        //
        // Check number of bytes per sector.  The low order byte of this
        // number must be zero (smallest sector size = 0x100) and the
        // high order byte shifted must equal the bytes per sector gotten
        // from the device and stored in the Vcb.  And just to be sure,
        // sector size must be less than page size.
        //

        BootSector->PackedBpb.BytesPerSector[0] == 0

            &&

        ((ULONG) (BootSector->PackedBpb.BytesPerSector[1] << 8) == BytesPerSector)

            &&

        BootSector->PackedBpb.BytesPerSector[1] << 8 <= PAGE_SIZE

            &&

        //
        //  Sectors per cluster must be a power of 2.
        //

        (BootSector->PackedBpb.SectorsPerCluster[0] == 0x1 ||
         BootSector->PackedBpb.SectorsPerCluster[0] == 0x2 ||
         BootSector->PackedBpb.SectorsPerCluster[0] == 0x4 ||
         BootSector->PackedBpb.SectorsPerCluster[0] == 0x8 ||
         BootSector->PackedBpb.SectorsPerCluster[0] == 0x10 ||
         BootSector->PackedBpb.SectorsPerCluster[0] == 0x20 ||
         BootSector->PackedBpb.SectorsPerCluster[0] == 0x40 ||
         BootSector->PackedBpb.SectorsPerCluster[0] == 0x80)

            &&

        //
        //  These fields must all be zero.  For both Fat and HPFS, some of
        //  these fields must be nonzero.
        //

        BootSector->PackedBpb.ReservedSectors[0] == 0 &&
        BootSector->PackedBpb.ReservedSectors[1] == 0 &&
        BootSector->PackedBpb.Fats[0] == 0 &&
        BootSector->PackedBpb.RootEntries[0] == 0 &&
        BootSector->PackedBpb.RootEntries[1] == 0 &&
        BootSector->PackedBpb.Sectors[0] == 0 &&
        BootSector->PackedBpb.Sectors[1] == 0 &&
        BootSector->PackedBpb.SectorsPerFat[0] == 0 &&
        BootSector->PackedBpb.SectorsPerFat[1] == 0 &&
        BootSector->PackedBpb.LargeSectors[0] == 0 &&
        BootSector->PackedBpb.LargeSectors[1] == 0 &&
        BootSector->PackedBpb.LargeSectors[2] == 0 &&
        BootSector->PackedBpb.LargeSectors[3] == 0

            &&

        //
        //  Number of Sectors cannot be greater than the number of sectors
        //  on the partition.
        //

        !( BootSector->NumberSectors.QuadPart > NumberOfSectors->QuadPart )

            &&

        //
        //  Check that both Lcn values are for sectors within the partition.
        //

        !( BootSector->MftStartLcn.QuadPart *
                    BootSector->PackedBpb.SectorsPerCluster[0] >
                NumberOfSectors->QuadPart )

            &&

        !( BootSector->Mft2StartLcn.QuadPart *
                    BootSector->PackedBpb.SectorsPerCluster[0] >
                NumberOfSectors->QuadPart )

            &&

        //
        //  Clusters per file record segment and default clusters for Index
        //  Allocation Buffers must be a power of 2.  A negative number indicates
        //  a shift value to get the actual size of the structure.
        //

        ((BootSector->ClustersPerFileRecordSegment >= -31 &&
          BootSector->ClustersPerFileRecordSegment <= -9) ||
         BootSector->ClustersPerFileRecordSegment == 0x1 ||
         BootSector->ClustersPerFileRecordSegment == 0x2 ||
         BootSector->ClustersPerFileRecordSegment == 0x4 ||
         BootSector->ClustersPerFileRecordSegment == 0x8 ||
         BootSector->ClustersPerFileRecordSegment == 0x10 ||
         BootSector->ClustersPerFileRecordSegment == 0x20 ||
         BootSector->ClustersPerFileRecordSegment == 0x40)

            &&

        ((BootSector->DefaultClustersPerIndexAllocationBuffer >= -31 &&
          BootSector->DefaultClustersPerIndexAllocationBuffer <= -9) ||
         BootSector->DefaultClustersPerIndexAllocationBuffer == 0x1 ||
         BootSector->DefaultClustersPerIndexAllocationBuffer == 0x2 ||
         BootSector->DefaultClustersPerIndexAllocationBuffer == 0x4 ||
         BootSector->DefaultClustersPerIndexAllocationBuffer == 0x8 ||
         BootSector->DefaultClustersPerIndexAllocationBuffer == 0x10 ||
         BootSector->DefaultClustersPerIndexAllocationBuffer == 0x20 ||
         BootSector->DefaultClustersPerIndexAllocationBuffer == 0x40)) {

        return TRUE;

    } else {

        //
        // This does not appear to be an NTFS volume.
        //

        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fsrec\fs_rec.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    fs_rec.c

Abstract:

    This module contains the main functions for the mini-file system recognizer
    driver.

Author:

    Darryl E. Havens (darrylh) 22-nov-1993

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "fs_rec.h"

//
//  The local debug trace level
//

#define Dbg                              (FSREC_DEBUG_LEVEL_FSREC)

#if DBG

#include <stdarg.h>
#include <stdio.h>

LONG FsRecDebugTraceLevel = 0;
LONG FsRecDebugTraceIndent = 0;

#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#pragma alloc_text(INIT,FsRecCreateAndRegisterDO)

#pragma alloc_text(PAGE,FsRecCleanupClose)
#pragma alloc_text(PAGE,FsRecCreate)
#pragma alloc_text(PAGE,FsRecFsControl)
#pragma alloc_text(PAGE,FsRecGetDeviceSectorSize)
#pragma alloc_text(PAGE,FsRecGetDeviceSectors)
#pragma alloc_text(PAGE,FsRecLoadFileSystem)
#pragma alloc_text(PAGE,FsRecReadBlock)
#pragma alloc_text(PAGE,FsRecUnload)
#pragma alloc_text(PAGE,FsRecShutdown)
#endif // ALLOC_PRAGMA

//
// Pointer to a mutex for serializing driver loads.  Note this a pointer
// and not a static KEVENT because it must be nonpaged and this entire
// driver is paged.
//

PKEVENT FsRecLoadSync;


NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is invoked once when the driver is loaded to allow the driver
    to initialize itself.  The initialization for the driver consists of simply
    creating a device object for each type of file system recognized by this
    driver, and then registering each as active file systems.

Arguments:

    DriverObject - Pointer to the driver object for this driver.

    RegistryPath - Pointer to the registry service node for this driver.

Return Value:

    The function value is the final status of the initialization for the driver.

--*/

{
    PDEVICE_OBJECT UdfsMainRecognizerDeviceObject;
    PDEVICE_OBJECT FatMainRecognizerDeviceObject;
    NTSTATUS status;
    ULONG count = 0;

    PAGED_CODE();

    //
    // Mark the entire driver as pagable.
    //

    MmPageEntireDriver ((PVOID)DriverEntry);

    //
    // Begin by initializing the driver object so that it the driver is
    // prepared to provide services.
    //

    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = FsRecFsControl;
    DriverObject->MajorFunction[IRP_MJ_CREATE] = FsRecCreate;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = FsRecCleanupClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = FsRecCleanupClose;
    DriverObject->MajorFunction[IRP_MJ_SHUTDOWN] = FsRecShutdown;
    DriverObject->DriverUnload = FsRecUnload;

    FsRecLoadSync = ExAllocatePoolWithTag( NonPagedPool, sizeof(KEVENT), FSREC_POOL_TAG );

    if (FsRecLoadSync == NULL) {
	    return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeEvent( FsRecLoadSync, SynchronizationEvent, TRUE );

    //
    // Create and initialize each of the file system driver type device
    // objects.
    //

    status = FsRecCreateAndRegisterDO( DriverObject,
                                       NULL,
                                       NULL,
                                       L"\\Cdfs",
                                       L"\\FileSystem\\CdfsRecognizer",
                                       CdfsFileSystem,
                                       FILE_DEVICE_CD_ROM_FILE_SYSTEM );
    if (NT_SUCCESS( status )) {
        count++;
    }

    status = FsRecCreateAndRegisterDO( DriverObject,
                                       NULL,
                                       &UdfsMainRecognizerDeviceObject,
                                       L"\\UdfsCdRom",
                                       L"\\FileSystem\\UdfsCdRomRecognizer",
                                       UdfsFileSystem,
                                       FILE_DEVICE_CD_ROM_FILE_SYSTEM );
    if (NT_SUCCESS( status )) {
        count++;
    }

    status = FsRecCreateAndRegisterDO( DriverObject,
                                       UdfsMainRecognizerDeviceObject,
                                       NULL,
                                       L"\\UdfsDisk",
                                       L"\\FileSystem\\UdfsDiskRecognizer",
                                       UdfsFileSystem,
                                       FILE_DEVICE_DISK_FILE_SYSTEM );
    if (NT_SUCCESS( status )) {
        count++;
    }

    status = FsRecCreateAndRegisterDO( DriverObject,
                                       NULL,
                                       &FatMainRecognizerDeviceObject,
                                       L"\\FatDisk",
                                       L"\\FileSystem\\FatDiskRecognizer",
                                       FatFileSystem,
                                       FILE_DEVICE_DISK_FILE_SYSTEM );
    if (NT_SUCCESS( status )) {
        count++;
    }

    status = FsRecCreateAndRegisterDO( DriverObject,
                                       FatMainRecognizerDeviceObject,
                                       NULL,
                                       L"\\FatCdrom",
                                       L"\\FileSystem\\FatCdRomRecognizer",
                                       FatFileSystem,
                                       FILE_DEVICE_CD_ROM_FILE_SYSTEM );
    if (NT_SUCCESS( status )) {
        count++;
    }

    status = FsRecCreateAndRegisterDO( DriverObject,
                                       NULL,
                                       NULL,
                                       L"\\Ntfs",
                                       L"\\FileSystem\\NtfsRecognizer",
                                       NtfsFileSystem,
                                       FILE_DEVICE_DISK_FILE_SYSTEM );
    if (NT_SUCCESS( status )) {
        count++;
    }

    if (count) {
        return STATUS_SUCCESS;
    } else {
        return STATUS_IMAGE_ALREADY_LOADED;
    }
}


NTSTATUS
FsRecCleanupClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked when someone attempts to cleanup or close one of
    the system recognizer's registered device objects.

Arguments:

    DeviceObject - Pointer to the device object being closed.

    Irp - Pointer to the cleanup/close IRP.

Return Value:

    The final function value is STATUS_SUCCESS.

--*/

{
    PAGED_CODE();

    //
    // Simply complete the request successfully (note that IoStatus.Status in
    // Irp is already initialized to STATUS_SUCCESS).
    //

    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
}


NTSTATUS
FsRecCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked when someone attempts to open one of the file
    system recognizer's registered device objects.

Arguments:

    DeviceObject - Pointer to the device object being opened.

    Irp - Pointer to the create IRP.

Return Value:

    The final function value indicates whether or not the open was successful.

--*/

{
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
    NTSTATUS status;

    PAGED_CODE();

    //
    // Simply ensure that the name of the "file" being opened is NULL, and
    // complete the request accordingly.
    //

    if (irpSp->FileObject->FileName.Length) {
        status = STATUS_OBJECT_PATH_NOT_FOUND;
    } else {
        status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = FILE_OPENED;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
}


NTSTATUS
FsRecCreateAndRegisterDO (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT HeadRecognizer OPTIONAL,
    OUT PDEVICE_OBJECT *NewRecognizer OPTIONAL,
    IN PWCHAR RecFileSystem,
    IN PWCHAR FileSystemName,
    IN FILE_SYSTEM_TYPE FileSystemType,
    IN DEVICE_TYPE DeviceType
    )

/*++

Routine Description:

    This routine creates a device object for the specified file system type and
    registers it as an active file system.

Arguments:

    DriverObject - Pointer to the driver object for this driver.
    
    HeadRecognizer - Optionally supplies a pre-existing recognizer that the
        newly created DO should be jointly serialized and unregistered with.
        This is useful if a given filesystem exists on multiple device types
        and thus requires multiple recognizers.
    
    NewDeviceObject - Receives the created DO on success..

    RecFileSystem - Name of the file system to be recognized.

    FileSystemName - Name of file system device object to be registered.

    FileSystemType - Type of this file system recognizer device object.
    
    DeviceType - Type of media this file system recognizer device object will inspect.

Return Value:

    The final function value indicates whether or not the device object was
    successfully created and registered.

--*/

{
    PDEVICE_OBJECT deviceObject;
    NTSTATUS status;
    UNICODE_STRING nameString;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE fsHandle;
    IO_STATUS_BLOCK ioStatus;
    PDEVICE_EXTENSION deviceExtension;

    PAGED_CODE();

    if (NewRecognizer) {

        *NewRecognizer = NULL;
    }

    //
    // Begin by attempting to open the file system driver's device object.  If
    // it works, then the file system is already loaded, so don't load this
    // driver.  Otherwise, this mini-driver is the one that should be loaded.
    //

    RtlInitUnicodeString( &nameString, RecFileSystem );
    InitializeObjectAttributes( &objectAttributes,
                                &nameString,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = ZwCreateFile( &fsHandle,
                           SYNCHRONIZE,
                           &objectAttributes,
                           &ioStatus,
                           (PLARGE_INTEGER) NULL,
                           0,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN,
                           0,
                           (PVOID) NULL,
                           0 );

    if (NT_SUCCESS( status )) {
        ZwClose( fsHandle );
    } else if (status != STATUS_OBJECT_NAME_NOT_FOUND) {
        status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS( status )) {
        return STATUS_IMAGE_ALREADY_LOADED;
    }

    //
    // Attempt to create a device object for this driver.  This device object
    // will be used to represent the driver as an active file system in the
    // system.
    //

    RtlInitUnicodeString( &nameString, FileSystemName );

    status = IoCreateDevice( DriverObject,
                             sizeof( DEVICE_EXTENSION ),
                             &nameString,
                             DeviceType,
                             0,
                             FALSE,
                             &deviceObject );
    if (!NT_SUCCESS( status )) {
        return status;
    }

    status = IoRegisterShutdownNotification (deviceObject);
    if (!NT_SUCCESS( status )) {
        IoDeleteDevice (deviceObject);
        return status;
    }

    //
    // Initialize the device extension for this device object.
    //

    deviceExtension = (PDEVICE_EXTENSION) deviceObject->DeviceExtension;
    deviceExtension->FileSystemType = FileSystemType;
    deviceExtension->State = Active;

    //
    //  Is this a filesystem being jointly recognized by recognizers for
    //  different device types?
    //
    
    if (HeadRecognizer) {

        //
        //  Link into the list.
        //
        
        deviceExtension->CoRecognizer = ((PDEVICE_EXTENSION)HeadRecognizer->DeviceExtension)->CoRecognizer;
        ((PDEVICE_EXTENSION)HeadRecognizer->DeviceExtension)->CoRecognizer = deviceObject;
    
    } else {

        //
        //  Initialize the list of codependant recognizer objects.
        //
        
        deviceExtension->CoRecognizer = deviceObject;
    }
    
#if _PNP_POWER_
    deviceObject->DeviceObjectExtension->PowerControlNeeded = FALSE;
#endif

    //
    // Finally, register this driver as an active, loaded file system and
    // return to the caller.
    //

    if (NewRecognizer) {

        *NewRecognizer = deviceObject;
    }

    IoRegisterFileSystem( deviceObject );
    return STATUS_SUCCESS;
}


NTSTATUS
FsRecFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function performs the mount and driver reload functions for this mini-
    file system recognizer driver.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet (IRP) representing the function to
        be performed.

Return Value:

    The function value is the final status of the operation.


--*/

{
    PDEVICE_EXTENSION deviceExtension;
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Simply vector to the appropriate FS control function given the type
    // of file system being interrogated.
    //

    deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Handle the inactive recognizer states directly.
    //
    
    if (deviceExtension->State != Active && irpSp->MinorFunction == IRP_MN_MOUNT_VOLUME) {
        
        if (deviceExtension->State == Transparent) {

            status = STATUS_UNRECOGNIZED_VOLUME;
        
        } else {
        
            status = STATUS_FS_DRIVER_REQUIRED;
        }

        Irp->IoStatus.Status = status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }

    switch ( deviceExtension->FileSystemType ) {

        case FatFileSystem:

            status = FatRecFsControl( DeviceObject, Irp );
            break;

        case NtfsFileSystem:

            status = NtfsRecFsControl( DeviceObject, Irp );
            break;

        case CdfsFileSystem:

            status = CdfsRecFsControl( DeviceObject, Irp );
            break;

        case UdfsFileSystem:

            status = UdfsRecFsControl( DeviceObject, Irp );
            break;

        default:

            status = STATUS_INVALID_DEVICE_REQUEST;
    }

    return status;
}


NTSTATUS
FsRecShutdown (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function is the shutdown handle for each of the recognisers file systems

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Shutdown IRP

Return Value:

    The function value is the final status of the operation.


--*/
{
    PDEVICE_EXTENSION DeviceExtension;

    DeviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;

    if (DeviceExtension->State != Transparent) {
        IoUnregisterFileSystem (DeviceObject);
        DeviceExtension->State = Transparent;
    }
    IoDeleteDevice (DeviceObject);

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
}


VOID
FsRecUnload (
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine cleans up the driver's data structures so that it can be
    unloaded.

Arguments:

    DriverObject - Pointer to the driver object for this driver.

Return Value:

    None.

--*/

{
    PAGED_CODE();

    ExFreePool( FsRecLoadSync );
    return;
}


NTSTATUS
FsRecLoadFileSystem (
    IN PDEVICE_OBJECT DeviceObject,
    IN PWCHAR DriverServiceName
    )

/*++


Routine Description:

    This routine performs the common work of loading a filesystem on behalf
    of one of our recognizers.

Arguments:

    DeviceObject - Pointer to the device object for the recognizer.

    DriverServiceName - Specifies the name of the node in the registry
        associated with the driver to be loaded.

Return Value:

    NTSTATUS.  The recognizer will be set into a transparent mode on return.
    
--*/

{
    UNICODE_STRING driverName;
    PDEVICE_EXTENSION deviceExtension = (PDEVICE_EXTENSION) DeviceObject->DeviceExtension;
    NTSTATUS status = STATUS_IMAGE_ALREADY_LOADED;

    PAGED_CODE();

    //
    //  Quickly check if the recognizer has already fired.
    //
    
    if (deviceExtension->State != Transparent) {
    
        //
        //  Serialize all threads trying to load this filesystem.
        //
        //  We need to do this for several reasons.  With the new behavior in
        //  IoRegisterFileSystem, we do not know ahead of time whether the
        //  filesystem has been loaded ahead or behind this recognizer in the
        //  scan queue.  This means that we cannot make this recognizer transparent
        //  before the real filesystem has become registered, or else if the
        //  filesystem loads behind us we may let threads go through that will
        //  not find it in that window of time.
        //
        //  The reason this is possible is that NtLoadDriver does not guarantee
        //  that if it returns STATUS_IMAGE_ALREADY_LOADED, that the driver in
        //  question has actually initialized itself, which *is* guaranteed if
        //  it returns STATUS_SUCCESS.  We have to keep these threads bottled
        //  up until they can rescan with the promise that what they need is there.
        //
        //  As a bonus, we can now guarantee that the recognizer goes away in
        //  all cases, not just when the driver successfully loads itself.
        //
        
        KeEnterCriticalRegion();

        KeWaitForSingleObject( FsRecLoadSync,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );
    
        //
        //  Attempt the filesystem load precisely once for all recognizers
        //  of a given filesystem.
        //
        
        if (deviceExtension->State == Active) {

            //
            //  For bonus points, in the future we may want to log an event
            //  on failure.
            //

            RtlInitUnicodeString( &driverName, DriverServiceName );
            status = ZwLoadDriver( &driverName );

            //
            //  Now walk all codependant recognizers and instruct them to go
            //  into the fast unload state.  Since IO only expects the fsDO
            //  it is asking to load a filesystem to to unregister itself, if
            //  we unregistered all of the co-recognizers they would dangle.
            //  Unfortunately, this means that fsrec may wind up hanging around
            //  quite a bit longer than strictly neccesary.
            //
            //  Note: we come right back to the original DeviceObject at the
            //  end of this loop (important).  It is also very important that
            //  we only did this once since after we release the mutex the co-
            //  recognizers may begin going away in any order.
            //

            while (deviceExtension->State != FastUnload) {

                deviceExtension->State = FastUnload;

                DeviceObject = deviceExtension->CoRecognizer;
                deviceExtension = DeviceObject->DeviceExtension;
            } 
        }
        
        //
        //  Unregister this recognizer precisely once.
        //

        if (deviceExtension->State != Transparent) {
            
            IoUnregisterFileSystem( DeviceObject );
            deviceExtension->State = Transparent;
        }
        
        KeSetEvent( FsRecLoadSync, 0, FALSE );
        KeLeaveCriticalRegion();
    }
    
    return status;
}


BOOLEAN
FsRecGetDeviceSectors (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG BytesPerSector,
    OUT PLARGE_INTEGER NumberOfSectors
    )

/*++

Routine Description:

    This routine returns information about the partition represented by the
    device object.

Arguments:

    DeviceObject - Pointer to the device object from which to read.

    BytesPerSector - The number of bytes per sector for the device being read.

    NumberOfSectors - Variable to receive the number of sectors for this
        partition.

Return Value:

    The function value is TRUE if the information was found, otherwise FALSE.

--*/

{
    GET_LENGTH_INFORMATION lengthInfo;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    PIRP irp;
    NTSTATUS status;
    ULONG remainder;

    PAGED_CODE();

    //
    //  We only do this for disks right now. This is likely to change when we
    //  have to recognize CDUDF media.
    //

    if (DeviceObject->DeviceType != FILE_DEVICE_DISK) {

        return FALSE;
    }

    //
    // Get the number of sectors on this partition.
    //

    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_GET_LENGTH_INFO,
                                         DeviceObject,
                                         (PVOID) NULL,
                                         0,
                                         &lengthInfo,
                                         sizeof( lengthInfo ),
                                         FALSE,
                                         &event,
                                         &ioStatus );
    if (!irp) {
        return FALSE;
    }

    //
    //  Override verify logic - we don't care. The fact we're in the picture means
    //  someone is trying to mount new/changed media in the first place.
    //
    
    SetFlag( IoGetNextIrpStackLocation( irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );

    status = IoCallDriver( DeviceObject, irp );
    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS( status )) {
        return FALSE;
    }

    *NumberOfSectors = RtlExtendedLargeIntegerDivide( lengthInfo.Length,
                                                      BytesPerSector,
                                                      &remainder );

    return TRUE;
}


BOOLEAN
FsRecGetDeviceSectorSize (
    IN PDEVICE_OBJECT DeviceObject,
    OUT PULONG BytesPerSector
    )

/*++

Routine Description:

    This routine returns the sector size of the underlying device.

Arguments:

    DeviceObject - Pointer to the device object from which to read.

    BytesPerSector - Variable to receive the number of bytes per sector for the
        device being read.

Return Value:

    The function value is TRUE if the information was found, otherwise FALSE.

--*/

{
    DISK_GEOMETRY diskGeometry;
    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    PIRP irp;
    NTSTATUS status;
    ULONG ControlCode;

    PAGED_CODE();

    //
    //  Figure out what kind of device we have so we can use the right IOCTL.
    //

    switch (DeviceObject->DeviceType) {
        case FILE_DEVICE_CD_ROM:
            ControlCode = IOCTL_CDROM_GET_DRIVE_GEOMETRY;
            break;

        case FILE_DEVICE_DISK:
            ControlCode = IOCTL_DISK_GET_DRIVE_GEOMETRY;
            break;

        default:
            return FALSE;
    }

    KeInitializeEvent( &event, SynchronizationEvent, FALSE );
    irp = IoBuildDeviceIoControlRequest( ControlCode,
                                         DeviceObject,
                                         (PVOID) NULL,
                                         0,
                                         &diskGeometry,
                                         sizeof( diskGeometry ),
                                         FALSE,
                                         &event,
                                         &ioStatus );

    if (!irp) {
        return FALSE;
    }

    //
    //  Override verify logic - we don't care. The fact we're in the picture means
    //  someone is trying to mount new/changed media in the first place.
    //
    
    SetFlag( IoGetNextIrpStackLocation( irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );
    
    status = IoCallDriver( DeviceObject, irp );
    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS( status )) {
        return FALSE;
    }

    //
    // Ensure that the drive actually knows how many bytes there are per
    // sector.  Floppy drives do not know if the media is unformatted.
    //

    if (!diskGeometry.BytesPerSector) {
        return FALSE;
    }

    //
    // Store the return values for the caller.
    //

    *BytesPerSector = diskGeometry.BytesPerSector;

    return TRUE;
}


BOOLEAN
FsRecReadBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PLARGE_INTEGER ByteOffset,
    IN ULONG MinimumBytes,
    IN ULONG BytesPerSector,
    OUT PVOID *Buffer,
    OUT PBOOLEAN IsDeviceFailure OPTIONAL
    )

/*++

Routine Description:

    This routine reads a minimum numbers of bytes into a buffer starting at
    the byte offset from the base of the device represented by the device
    object.

Arguments:

    DeviceObject - Pointer to the device object from which to read.

    ByteOffset - Pointer to a 64-bit byte offset from the base of the device
        from which to start the read.

    MinimumBytes - Supplies the minimum number of bytes to be read.

    BytesPerSector - The number of bytes per sector for the device being read.

    Buffer - Variable to receive a pointer to the allocated buffer containing
        the bytes read.
        
    IsDeviceFailure - Variable to receive an indication whether a failure
        was a result of talking to the device.

Return Value:

    The function value is TRUE if the bytes were read, otherwise FALSE.

--*/

{
    #define RoundUp( x, y ) ( ((x + (y-1)) / y) * y )

    IO_STATUS_BLOCK ioStatus;
    KEVENT event;
    PIRP irp;
    NTSTATUS status;

    PAGED_CODE();

    if (IsDeviceFailure) {
        *IsDeviceFailure = FALSE;
    }
    
    KeInitializeEvent( &event, SynchronizationEvent, FALSE );

    //
    // Set the minimum number of bytes to read to the maximum of the bytes that
    // the caller wants to read, and the number of bytes in a sector.
    //

    if (MinimumBytes < BytesPerSector) {
        MinimumBytes = BytesPerSector;
    } else {
        MinimumBytes = RoundUp( MinimumBytes, BytesPerSector );
    }

    //
    // Allocate a buffer large enough to contain the bytes required, round the
    // request to a page boundary to solve any alignment requirements.
    //

    if (!*Buffer) {

        *Buffer = ExAllocatePoolWithTag( NonPagedPool,
					 (MinimumBytes + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1),
					 FSREC_POOL_TAG );
        if (!*Buffer) {
            return FALSE;
        }
    }

    //
    // Read the actual bytes off of the media.
    //

    irp = IoBuildSynchronousFsdRequest( IRP_MJ_READ,
                                        DeviceObject,
                                        *Buffer,
                                        MinimumBytes,
                                        ByteOffset,
                                        &event,
                                        &ioStatus );
    if (!irp) {
        return FALSE;
    }
    
    //
    //  Override verify logic - we don't care. The fact we're in the picture means
    //  someone is trying to mount new/changed media in the first place.
    //
    
    SetFlag( IoGetNextIrpStackLocation( irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );

    status = IoCallDriver( DeviceObject, irp );
    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
        status = ioStatus.Status;
    }

    if (!NT_SUCCESS( status )) {

        if (IsDeviceFailure) {
            *IsDeviceFailure = TRUE;
        }
        return FALSE;
    }

    return TRUE;
}


#if DBG
BOOLEAN
FsRecDebugTrace (
    LONG IndentIncrement,
    ULONG TraceMask,
    PCHAR Format,
    ...
    )

/*++

Routine Description:

    This routine is a simple debug info printer that returns a constant boolean value.  This
    makes it possible to splice it into the middle of boolean expressions to discover which
    elements are firing.
    
    We will use this as our general debug printer.  See udfdata.h for how we use the DebugTrace
    macro to accomplish the effect.
    
Arguments:

    IndentIncrement - amount to change the indentation by.
    
    TraceMask - specification of what debug trace level this call should be noisy at.

Return Value:

    USHORT - The 16bit CRC

--*/

{
    va_list Arglist;
    LONG i;
    UCHAR Buffer[128];
    int Bytes;

#define Min(a, b)   ((a) < (b) ? (a) : (b))
    
    if (TraceMask == 0 || (FsRecDebugTraceLevel & TraceMask) != 0) {

        //
        //  Emit a preamble of our thread ID.
        //
        
        DbgPrint( "%p:", PsGetCurrentThread());

        if (IndentIncrement < 0) {
            
            FsRecDebugTraceIndent += IndentIncrement;
        }

        if (FsRecDebugTraceIndent < 0) {
            
            FsRecDebugTraceIndent = 0;
        }

        //
        //  Build the indent in big chunks since calling DbgPrint repeatedly is expensive.
        //
        
        for (i = FsRecDebugTraceIndent; i > 0; i -= (sizeof(Buffer) - 1)) {

            RtlFillMemory( Buffer, Min( i, (sizeof(Buffer) - 1 )), ' ');
            *(Buffer + Min( i, (sizeof(Buffer) - 1 ))) = '\0';
            
            DbgPrint( Buffer );
        }

        //
        // Format the output into a buffer and then print it.
        //

        va_start( Arglist, Format );
        Bytes = _vsnprintf( Buffer, sizeof(Buffer), Format, Arglist );
        va_end( Arglist );

        //
        // detect buffer overflow
        //

        if (Bytes == -1) {

            Buffer[sizeof(Buffer) - 1] = '\n';
        }

        DbgPrint( Buffer );

        if (IndentIncrement > 0) {

            FsRecDebugTraceIndent += IndentIncrement;
        }
    }

    return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fsrec\udfs_rec.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    udfs_rec.h

Abstract:

    This module contains the mini-file system recognizer for UDFS.

Author:

    Dan Lovinger (danlo) 13-Feb-1997

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

//
//  NOTE CAREFULLY: the canonical location for this information is in the UDFS
//      driver source.
//

//
//  Aligning this byte offset to a sector boundary by rounding up will
//  yield the starting offset of the Volume Recognition Area (2/8.3)
//

#define VRA_BOUNDARY_LOCATION (32767 + 1)

/***    ISO 13346 Part 2: Volume and Boot Block Recognition
 *
 *
 */


/***    vsd_generic - Generic Volume Structure Descriptor (2/9.1)
 *
 */

typedef struct  VSD_GENERIC {
    UCHAR       Type;                   // Structure Type
    UCHAR       Ident[5];               // Standard Identifier
    UCHAR       Version;                // Standard Version
    UCHAR       Data[2041];             // Structure Data
} VSD_GENERIC, *PVSD_GENERIC;

//  VSD_LENGTH_... - vsd field lengths

#define VSD_LENGTH_IDENT        5       // Length of regid_Identifier (bytes)

//  VSD_IDENT_... - Values for vsd_generic_Ident

#define VSD_IDENT_BEA01     "BEA01"     // Begin Extended Area
#define VSD_IDENT_TEA01     "TEA01"     // Terminate Extended Area
#define VSD_IDENT_CDROM     "CDROM"     // High Sierra Group (pre-ISO 9660)
#define VSD_IDENT_CD001     "CD001"     // ISO 9660
#define VSD_IDENT_CDW01     "CDW01"     // ECMA 168
#define VSD_IDENT_CDW02     "CDW02"     // ISO 13490
#define VSD_IDENT_NSR01     "NSR01"     // ECMA 167
#define VSD_IDENT_NSR02     "NSR02"     // ISO 13346
#define VSD_IDENT_BOOT2     "BOOT2"     // Boot Descriptor
#define VSD_IDENT_NSR03     "NSR03"     // ECMA 167 3rd Edition

typedef enum _VSD_IDENT {
    VsdIdentBad = 0,
    VsdIdentBEA01,
    VsdIdentTEA01,
    VsdIdentCDROM,
    VsdIdentCD001,
    VsdIdentCDW01,
    VsdIdentCDW02,
    VsdIdentNSR01,
    VsdIdentNSR02,
    VsdIdentBOOT2,
    VsdIdentNSR03
} VSD_IDENT, *PVSD_IDENT;

//
//  Following structure is used to build up static data for parse tables
//

typedef struct _PARSE_KEYVALUE {
    PCHAR Key;
    ULONG Value;
} PARSE_KEYVALUE, *PPARSE_KEYVALUE;

//
// Define the functions provided by this driver.
//

BOOLEAN
IsUdfsVolume (
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize
    );

ULONG
UdfsFindInParseTable (
    IN PPARSE_KEYVALUE ParseTable,
    IN PCHAR Id,
    IN ULONG MaxIdLen
    );

#define SectorAlignN(SECTORSIZE, L) (                                           \
    ((((ULONG)(L)) + ((SECTORSIZE) - 1)) & ~((SECTORSIZE) - 1))                 \
)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\fsrec\ntfs_rec.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ntfs_rec.h

Abstract:

    This module contains the mini-file system recognizer for NTFS.

Author:

    Darryl E. Havens (darrylh) 8-dec-1992

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

//
//  The fundamental unit of allocation on an Ntfs volume is the
//  cluster.  Format guarantees that the cluster size is an integral
//  power of two times the physical sector size of the device.  Ntfs
//  reserves 64-bits to describe a cluster, in order to support
//  large disks.  The LCN represents a physical cluster number on
//  the disk, and the VCN represents a virtual cluster number within
//  an attribute.
//

typedef LARGE_INTEGER LCN;
typedef LCN *PLCN;

typedef LARGE_INTEGER VCN;
typedef VCN *PVCN;

typedef LARGE_INTEGER LBO;
typedef LBO *PLBO;

typedef LARGE_INTEGER VBO;
typedef VBO *PVBO;

//
//  The boot sector is duplicated on the partition.  The first copy
//  is on the first physical sector (LBN == 0) of the partition, and
//  the second copy is at <number sectors on partition> / 2.  If the
//  first copy can not be read when trying to mount the disk, the
//  second copy may be read and has the identical contents.  Format
//  must figure out which cluster the second boot record belongs in,
//  and it must zero all of the other sectors that happen to be in
//  the same cluster.  The boot file minimally contains with two
//  clusters, which are the two clusters which contain the copies of
//  the boot record.  If format knows that some system likes to put
//  code somewhere, then it should also align this requirement to
//  even clusters, and add that to the boot file as well.
//
//  Part of the sector contains a BIOS Parameter Block.  The BIOS in
//  the sector is packed (i.e., unaligned) so we'll supply an
//  unpacking macro to translate a packed BIOS into its unpacked
//  equivalent.  The unpacked BIOS structure is already defined in
//  ntioapi.h so we only need to define the packed BIOS.
//

//
//  Define the Packed and Unpacked BIOS Parameter Block
//

typedef struct _PACKED_BIOS_PARAMETER_BLOCK {

    UCHAR  BytesPerSector[2];                               //  offset = 0x000
    UCHAR  SectorsPerCluster[1];                            //  offset = 0x002
    UCHAR  ReservedSectors[2];                              //  offset = 0x003 (zero)
    UCHAR  Fats[1];                                         //  offset = 0x005 (zero)
    UCHAR  RootEntries[2];                                  //  offset = 0x006 (zero)
    UCHAR  Sectors[2];                                      //  offset = 0x008 (zero)
    UCHAR  Media[1];                                        //  offset = 0x00A
    UCHAR  SectorsPerFat[2];                                //  offset = 0x00B (zero)
    UCHAR  SectorsPerTrack[2];                              //  offset = 0x00D
    UCHAR  Heads[2];                                        //  offset = 0x00F
    UCHAR  HiddenSectors[4];                                //  offset = 0x011 (zero)
    UCHAR  LargeSectors[4];                                 //  offset = 0x015 (zero)

} PACKED_BIOS_PARAMETER_BLOCK;                              //  sizeof = 0x019

typedef PACKED_BIOS_PARAMETER_BLOCK *PPACKED_BIOS_PARAMETER_BLOCK;

//
//  Define the boot sector.  Note that MFT2 is exactly three file
//  record segments long, and it mirrors the first three file record
//  segments from the MFT, which are MFT, MFT2 and the Log File.
//
//  The Oem field contains the ASCII characters "NTFS    ".
//
//  The Checksum field is a simple additive checksum of all of the
//  ULONGs which precede the Checksum ULONG.  The rest of the sector
//  is not included in this Checksum.
//

typedef struct _PACKED_BOOT_SECTOR {

    UCHAR Jump[3];                                                  //  offset = 0x000
    UCHAR Oem[8];                                                   //  offset = 0x003
    PACKED_BIOS_PARAMETER_BLOCK PackedBpb;                          //  offset = 0x00B
    UCHAR Unused[4];                                                //  offset = 0x024
    LARGE_INTEGER NumberSectors;                                    //  offset = 0x028
    LCN MftStartLcn;                                                //  offset = 0x030
    LCN Mft2StartLcn;                                               //  offset = 0x038
    CHAR ClustersPerFileRecordSegment;                              //  offset = 0x040
    UCHAR Reserved0[3];
    CHAR DefaultClustersPerIndexAllocationBuffer;                   //  offset = 0x044
    UCHAR Reserved1[3];
    LARGE_INTEGER SerialNumber;                                     //  offset = 0x048
    ULONG Checksum;                                                 //  offset = 0x050
    UCHAR BootStrap[0x200-0x054];                                   //  offset = 0x054

} PACKED_BOOT_SECTOR;                                               //  sizeof = 0x200

typedef PACKED_BOOT_SECTOR *PPACKED_BOOT_SECTOR;

//
// Define the functions provided by this driver.
//

BOOLEAN
IsNtfsVolume(
    IN PPACKED_BOOT_SECTOR BootSector,
    IN ULONG BytesPerSector,
    IN PLARGE_INTEGER NumberOfSectors
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\drivesup.c ===
#if !defined(NO_LEGACY_DRIVERS)
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    drivesup.c

Abstract:

    This module contains the subroutines for drive support.  This includes
    such things as how drive letters are assigned on a particular platform,
    how device partitioning works, etc.

Author:

    Darryl E. Havens (darrylh) 23-Apr-1992

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "bugcodes.h"

#include "ntddft.h"
#include "ntdddisk.h"
#include "ntdskreg.h"
#include "stdio.h"
#include "string.h"


VOID
HalpAssignDriveLetters(
    PLOADER_PARAMETER_BLOCK LoaderBlock,
    PSTRING NtDeviceName,
    OUT PUCHAR NtSystemPath,
    OUT PSTRING NtSystemPathString
    );

NTSTATUS
HalpReadPartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN BOOLEAN ReturnRecognizedPartitions,
    OUT PDRIVE_LAYOUT_INFORMATION *PartitionBuffer
    );

NTSTATUS
HalpSetPartitionInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG PartitionNumber,
    IN ULONG PartitionType
    );

NTSTATUS
HalpWritePartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfHeads,
    IN PDRIVE_LAYOUT_INFORMATION PartitionBuffer
    );


NTKERNELAPI
VOID
FASTCALL
IoAssignDriveLetters(
    PLOADER_PARAMETER_BLOCK LoaderBlock,
    PSTRING NtDeviceName,
    OUT PUCHAR NtSystemPath,
    OUT PSTRING NtSystemPathString
    );


NTKERNELAPI
NTSTATUS
FASTCALL
IoReadPartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN BOOLEAN ReturnRecognizedPartitions,
    OUT PDRIVE_LAYOUT_INFORMATION *PartitionBuffer
    );

NTKERNELAPI
NTSTATUS
FASTCALL
IoSetPartitionInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG PartitionNumber,
    IN ULONG PartitionType
    );

NTKERNELAPI
NTSTATUS
FASTCALL
IoWritePartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfHeads,
    IN PDRIVE_LAYOUT_INFORMATION PartitionBuffer
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HalpAssignDriveLetters)
#pragma alloc_text(PAGE, HalpReadPartitionTable)
#pragma alloc_text(PAGE, HalpSetPartitionInformation)
#pragma alloc_text(PAGE, HalpWritePartitionTable)
#endif


VOID
HalpAssignDriveLetters(
    PLOADER_PARAMETER_BLOCK LoaderBlock,
    PSTRING NtDeviceName,
    OUT PUCHAR NtSystemPath,
    OUT PSTRING NtSystemPathString
    )
{

    //
    // Stub to call extensible routine in ke so that hal vendors
    // don't have to support.
    //

    IoAssignDriveLetters(
        LoaderBlock,
        NtDeviceName,
        NtSystemPath,
        NtSystemPathString
        );

}


NTSTATUS
HalpReadPartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN BOOLEAN ReturnRecognizedPartitions,
    OUT PDRIVE_LAYOUT_INFORMATION *PartitionBuffer
    )
{
    //
    // Stub to call extensible routine in ke so that hal vendors
    // don't have to support.
    //

    return IoReadPartitionTable(
               DeviceObject,
               SectorSize,
               ReturnRecognizedPartitions,
               PartitionBuffer
               );
}

NTSTATUS
HalpSetPartitionInformation(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG PartitionNumber,
    IN ULONG PartitionType
    )
{
    //
    // Stub to call extensible routine in ke so that hal vendors
    // don't have to support.
    //

    return IoSetPartitionInformation(
               DeviceObject,
               SectorSize,
               PartitionNumber,
               PartitionType
               );

}


NTSTATUS
HalpWritePartitionTable(
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG SectorSize,
    IN ULONG SectorsPerTrack,
    IN ULONG NumberOfHeads,
    IN PDRIVE_LAYOUT_INFORMATION PartitionBuffer
    )
{

    //
    // Stub to call extensible routine in ke so that hal vendors
    // don't have to support.
    //

    return IoWritePartitionTable(
               DeviceObject,
               SectorSize,
               SectorsPerTrack,
               NumberOfHeads,
               PartitionBuffer
               );
}
#endif // NO_LEGACY_DRIVERS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\acpidtct.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acpidtct.c

Abstract:

    This file pulls the ACPI Root Ssytem Description
    Pointer out of the registry.  It was put there
    either by ntdetect.com or by one ARC firmware or
    another.

Author:

    Jake Oshins (jakeo) 6-Feb-1997

Environment:

    Kernel mode only.

Revision History:

--*/


#include "halp.h"
#include "ntacpi.h"

#define rgzMultiFunctionAdapter L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter"
#define rgzAcpiConfigurationData L"Configuration Data"
#define rgzAcpiIdentifier L"Identifier"
#define rgzBIOSIdentifier L"ACPI BIOS"

PHYSICAL_ADDRESS HalpAcpiRsdt;

// from ntrtl.h
NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
    PUNICODE_STRING String1,
    PUNICODE_STRING String2,
    BOOLEAN CaseInSensitive
    );


// internal definitions

NTSTATUS
HalpAcpiGetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION *Information
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpAcpiFindRsdtPhase0)
#pragma alloc_text(PAGELK,HalpAcpiGetRegistryValue)
#pragma alloc_text(PAGELK,HalpAcpiFindRsdt)
#endif

NTSTATUS
HalpAcpiFindRsdtPhase0(
       IN PLOADER_PARAMETER_BLOCK LoaderBlock
       )
/*++

Routine Description:

    This function reads the Root System Description Pointer from
    the ACPI BIOS node in the arc tree.  It puts whatever it finds
    into HalpAcpiRsdt.

    This function is suitable for being called during Phase 0 or
    Phase 1 only.  The LoaderBlock is destroyed after that.

Arguments:

    IN PLOADER_PARAMETER_BLOCK LoaderBlock

Return Value:

    status

--*/
{
   PCONFIGURATION_COMPONENT_DATA RsdtComponent = NULL;
   PCONFIGURATION_COMPONENT_DATA Component = NULL;
   PCONFIGURATION_COMPONENT_DATA Resume = NULL;
   PCM_PARTIAL_RESOURCE_LIST Prl;
   PCM_PARTIAL_RESOURCE_DESCRIPTOR Prd;
   ACPI_BIOS_MULTI_NODE UNALIGNED *Rsdp;

   while (Component = KeFindConfigurationNextEntry(LoaderBlock->ConfigurationRoot,AdapterClass,
                                                   MultiFunctionAdapter,NULL,&Resume)) {
      if (!(strcmp(Component->ComponentEntry.Identifier,"ACPI BIOS"))) {
         RsdtComponent = Component;
         break;
      }
      Resume = Component;
   }

   //if RsdtComponent is still NULL, we didn't find node
   if (!RsdtComponent) {
      DbgPrint("**** HalpAcpiFindRsdtPhase0: did NOT find RSDT\n");
      return STATUS_NOT_FOUND;
   }

   Prl = (PCM_PARTIAL_RESOURCE_LIST)(RsdtComponent->ConfigurationData);
   Prd = &Prl->PartialDescriptors[0];

   Rsdp = (PACPI_BIOS_MULTI_NODE)((PCHAR) Prd + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

   HalpAcpiRsdt.QuadPart = Rsdp->RsdtAddress.QuadPart;

   return STATUS_SUCCESS;
}


NTSTATUS
HalpAcpiFindRsdt (
    OUT PACPI_BIOS_MULTI_NODE   *AcpiMulti
    )
/*++

Routine Description:

    This function looks into the registry to find the ACPI RSDT,
    which was stored there by ntdetect.com.

Arguments:

    RsdtPtr - Pointer to a buffer that contains the ACPI
              Root System Description Pointer Structure.
              The caller is responsible for freeing this
              buffer.  Note:  This is returned in non-paged
              pool.

Return Value:

    A NTSTATUS code to indicate the result of the initialization.

--*/
{
    UNICODE_STRING unicodeString, unicodeValueName, biosId;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE hMFunc, hBus;
    WCHAR wbuffer[10];
    ULONG i, length;
    PWSTR p;
    PKEY_VALUE_PARTIAL_INFORMATION valueInfo;
    NTSTATUS status;
    BOOLEAN same;
    PCM_PARTIAL_RESOURCE_LIST prl;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR prd;
    PACPI_BIOS_MULTI_NODE multiNode;
    ULONG multiNodeSize;

    PAGED_CODE();

    //
    // Look in the registry for the "ACPI BIOS bus" data
    //

    RtlInitUnicodeString (&unicodeString, rgzMultiFunctionAdapter);
    InitializeObjectAttributes (&objectAttributes,
                                &unicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,       // handle
                                NULL);


    status = ZwOpenKey (&hMFunc, KEY_READ, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        DbgPrint("AcpiBios:Can not open MultifunctionAdapter registry key.\n");
        return status;
    }

    unicodeString.Buffer = wbuffer;
    unicodeString.MaximumLength = sizeof(wbuffer);
    RtlInitUnicodeString(&biosId, rgzBIOSIdentifier);

    for (i = 0; TRUE; i++) {
        RtlIntegerToUnicodeString (i, 10, &unicodeString);
        InitializeObjectAttributes (
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            hMFunc,
            NULL);

        status = ZwOpenKey (&hBus, KEY_READ, &objectAttributes);
        if (!NT_SUCCESS(status)) {

            //
            // Out of Multifunction adapter entries...
            //

            DbgPrint("AcpiBios: ACPI BIOS MultifunctionAdapter registry key not found.\n");
            ZwClose (hMFunc);
            return STATUS_UNSUCCESSFUL;
        }

        //
        // Check the Indentifier to see if this is an ACPI BIOS entry
        //

        status = HalpAcpiGetRegistryValue (hBus, rgzAcpiIdentifier, &valueInfo);
        if (!NT_SUCCESS (status)) {
            ZwClose (hBus);
            continue;
        }

        p = (PWSTR) ((PUCHAR) valueInfo->Data);
        unicodeValueName.Buffer = p;
        unicodeValueName.MaximumLength = (USHORT)valueInfo->DataLength;
        length = valueInfo->DataLength;

        //
        // Determine the real length of the ID string
        //

        while (length) {
            if (p[length / sizeof(WCHAR) - 1] == UNICODE_NULL) {
                length -= 2;
            } else {
                break;
            }
        }

        unicodeValueName.Length = (USHORT)length;
        same = RtlEqualUnicodeString(&biosId, &unicodeValueName, TRUE);
        ExFreePool(valueInfo);
        if (!same) {
            ZwClose (hBus);
            continue;
        }

        status = HalpAcpiGetRegistryValue(hBus, rgzAcpiConfigurationData, &valueInfo);
        ZwClose (hBus);
        if (!NT_SUCCESS(status)) {
            continue ;
        }

        prl = (PCM_PARTIAL_RESOURCE_LIST)(valueInfo->Data);
        prd = &prl->PartialDescriptors[0];
        multiNode = (PACPI_BIOS_MULTI_NODE)((PCHAR) prd + sizeof(CM_PARTIAL_RESOURCE_LIST));


        break;
    }

    multiNodeSize = sizeof(ACPI_BIOS_MULTI_NODE) +
                        ((ULONG)(multiNode->Count - 1) * sizeof(ACPI_E820_ENTRY));

    *AcpiMulti = (PACPI_BIOS_MULTI_NODE)
                   ExAllocatePoolWithTag(NonPagedPool,
                           multiNodeSize,
                           'IPCA');
    if (*AcpiMulti == NULL) {
        ExFreePool(valueInfo);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(*AcpiMulti, multiNode, multiNodeSize);

    ExFreePool(valueInfo);
    return STATUS_SUCCESS;
}

NTSTATUS
HalpAcpiGetRegistryValue(
    IN HANDLE KeyHandle,
    IN PWSTR  ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION *Information
    )

/*++

Routine Description:

    This routine is invoked to retrieve the data for a registry key's value.
    This is done by querying the value of the key with a zero-length buffer
    to determine the size of the value, and then allocating a buffer and
    actually querying the value into the buffer.

    It is the responsibility of the caller to free the buffer.

Arguments:

    KeyHandle - Supplies the key handle whose value is to be queried

    ValueName - Supplies the null-terminated Unicode name of the value.

    Information - Returns a pointer to the allocated data buffer.

Return Value:

    The function value is the final status of the query operation.

--*/

{
    UNICODE_STRING unicodeString;
    NTSTATUS status;
    PKEY_VALUE_PARTIAL_INFORMATION infoBuffer;
    ULONG keyValueLength;

    PAGED_CODE();

    RtlInitUnicodeString( &unicodeString, ValueName );

    //
    // Figure out how big the data value is so that a buffer of the
    // appropriate size can be allocated.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValuePartialInformation,
                              (PVOID) NULL,
                              0,
                              &keyValueLength );
    if (status != STATUS_BUFFER_OVERFLOW &&
        status != STATUS_BUFFER_TOO_SMALL) {
        return status;
    }

    //
    // Allocate a buffer large enough to contain the entire key data value.
    //

    infoBuffer = ExAllocatePoolWithTag(NonPagedPool,
                                       keyValueLength,
                                       'IPCA');
    if (!infoBuffer) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Query the data for the key value.
    //

    status = ZwQueryValueKey( KeyHandle,
                              &unicodeString,
                              KeyValuePartialInformation,
                              infoBuffer,
                              keyValueLength,
                              &keyValueLength );
    if (!NT_SUCCESS( status )) {
        ExFreePool( infoBuffer );
        return status;
    }

    //
    // Everything worked, so simply return the address of the allocated
    // buffer to the caller, who is now responsible for freeing it.
    //

    *Information = infoBuffer;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\hals.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

!ENDIF

!if defined(BUILD_CHECKED_KERNEL)
NTDEBUG=ntsd
FREEBUILD=0
!endif

# Always build MP hals for checked builds.

!if !$(FREEBUILD)
NT_UP=0
!endif

VC7_SYMBOLS=1

# No overflow checking for the HAL
BUFFER_OVERFLOW_CHECKS=0
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\bushnd.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    bushnd.c

Abstract:

    Functions which take either BusType-BusNumber or ConfigType-BusNumberm
    and route to a the appropiate registered handler.

Author:

    Ken Reneris (kenr) July-28-1994

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"


typedef struct _ARRAY {
    ULONG           ArraySize;
    PVOID           Element[];      // must be last field
} ARRAY, *PARRAY;

#define ARRAY_SIZE_IN_BYTES(a)  ( (a + 1) * sizeof(PARRAY) +        \
                                  FIELD_OFFSET(ARRAY, Element) )

typedef struct _HAL_BUS_HANDLER {
    LIST_ENTRY      AllHandlers;
    ULONG           ReferenceCount;
    BUS_HANDLER     Handler;
} HAL_BUS_HANDLER, *PHAL_BUS_HANDLER;

//
// Event to serialize with adding new buses
//

KEVENT      HalpBusDatabaseEvent;

//
// Lock to serialize routing functions from accessing handler arrays while
// new buses are added
//

KSPIN_LOCK  HalpBusDatabaseSpinLock;

//
// HalpBusTable - pointers to BusHandlers mapped by InterfaceType,BusNumber
//

PARRAY      HalpBusTable;

//
// HalpConfigTable - pointers to BusHandlers mapped by ConfigType,BusNumber
//

PARRAY      HalpConfigTable;

//
// List of all installed bus handlers
//

LIST_ENTRY  HalpAllBusHandlers;

//
// Lock is high_level since some routed functions can occurs at ISR time
//

#define LockBusDatabase(oldirql)                    \
    KeRaiseIrql(HIGH_LEVEL, oldirql);               \
    KiAcquireSpinLock(&HalpBusDatabaseSpinLock);

#define UnlockBusDatabase(oldirql)                  \
    KiReleaseSpinLock(&HalpBusDatabaseSpinLock);    \
    KeLowerIrql(oldirql);


#ifdef _PNP_POWER_
extern HAL_CALLBACKS    HalCallback;
#endif

//
// Internal prototypes
//

PARRAY
HalpAllocateArray (
    IN ULONG    Type
    );

VOID
HalpGrowArray (
    IN PARRAY   *CurrentArray,
    IN PARRAY   *NewArray
    );

NTSTATUS
HalpQueryInstalledBusInformation (
    OUT PVOID   Buffer,
    IN  ULONG   BufferLength,
    OUT PULONG  ReturnedLength
    );

ULONG
HalpNoBusData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
HalpNoAdjustResourceList (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

NTSTATUS
HalpNoAssignSlotResources (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

NTSTATUS
HalpNoQueryBusSlots (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG                BufferSize,
    OUT PULONG              SlotNumbers,
    OUT PULONG              ReturnedLength
    );

PDEVICE_HANDLER_OBJECT
HalpNoReferenceDeviceHandler (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN ULONG                SlotNumber
    );

ULONG
HalpNoGetDeviceData (
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PDEVICE_HANDLER_OBJECT   DeviceHandler,
    IN ULONG                    DataType,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );

ULONG
HalpNoSetDeviceData (
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PDEVICE_HANDLER_OBJECT   DeviceHandler,
    IN ULONG                    DataType,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );

BOOLEAN
HaliTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

NTSTATUS
HalpAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

BOOLEAN
HaliFindBusAddressTranslation(
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PULONG_PTR Context,
    IN BOOLEAN NextBus
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitBusHandler)
#pragma alloc_text(PAGELK,HaliRegisterBusHandler)
#pragma alloc_text(PAGELK,HalpAllocateArray)
#pragma alloc_text(PAGELK,HalpGrowArray)
#pragma alloc_text(PAGE,HalAdjustResourceList)
#pragma alloc_text(PAGE,HalAssignSlotResources)
#pragma alloc_text(PAGE,HalpAssignSlotResources)
#pragma alloc_text(PAGE,HalGetInterruptVector)
#pragma alloc_text(PAGE,HalpNoAdjustResourceList)
#pragma alloc_text(PAGE,HalpNoAssignSlotResources)
#pragma alloc_text(PAGE,HalpNoQueryBusSlots)
#pragma alloc_text(PAGE,HalpNoReferenceDeviceHandler)
//#pragma alloc_text(PAGE,HaliQueryBusSlots)
#pragma alloc_text(PAGE,HalpQueryInstalledBusInformation)

#ifdef _PNP_POWER_
#pragma alloc_text(PAGELK,HaliSuspendHibernateSystem)
#endif

#endif

VOID
HalpInitBusHandler (
    VOID
    )
/*++

Routine Description:

    Initializes global BusHandler data

--*/
{
    //
    // Initialize bus handler spinlock used to synchronize against
    // buses additions while array lookups are done
    //

    KeInitializeSpinLock (&HalpBusDatabaseSpinLock);

    //
    // Initialize bus handler synchronzation event used to serialize
    // bus additions from < DPC_LVEL
    //

    KeInitializeEvent (&HalpBusDatabaseEvent, SynchronizationEvent, TRUE);

    //
    // Initialize global arrays
    //

    HalpBusTable    = HalpAllocateArray (0);
    HalpConfigTable = HalpAllocateArray (0);
    InitializeListHead (&HalpAllBusHandlers);

    //
    // Fill in HAL API handlers
    //

    HalRegisterBusHandler = HaliRegisterBusHandler;
    HalHandlerForBus = HaliHandlerForBus;
    HalHandlerForConfigSpace = HaliHandlerForConfigSpace;
    //HalQueryBusSlots = HaliQueryBusSlots;
    HalReferenceHandlerForBus = HaliReferenceHandlerForBus;
    HalReferenceBusHandler = HaliReferenceBusHandler;
    HalDereferenceBusHandler = HaliDereferenceBusHandler;

    HALPDISPATCH->HalPciTranslateBusAddress = HaliTranslateBusAddress;
#if !defined(NO_LEGACY_DRIVERS)    
    HALPDISPATCH->HalPciAssignSlotResources = HalpAssignSlotResources;
#endif // NO_LEGACY_DRIVERS
    
    //
    // Supply the "Bus Handler" version of this routine only
    // if this HAL didn't already provide a different version.
    //

    if (!HALPDISPATCH->HalFindBusAddressTranslation) {
        HALPDISPATCH->HalFindBusAddressTranslation =
            HaliFindBusAddressTranslation;
    }
}

NTSTATUS
HaliRegisterBusHandler (
    IN INTERFACE_TYPE          InterfaceType,
    IN BUS_DATA_TYPE           ConfigType,
    IN ULONG                   BusNumber,
    IN INTERFACE_TYPE          ParentBusType,
    IN ULONG                   ParentBusNumber,
    IN ULONG                   SizeofBusExtensionData,
    IN PINSTALL_BUS_HANDLER    InstallBusHandler,
    OUT PBUS_HANDLER           *ReturnedBusHandler
    )
/*++

Routine Description:

    Adds a BusHandler for InterfaceType,BusNumber and for ConfigType,BusNumber.

    Bus specific or Configuration space specific APIs are routed to the
    bus or configuration specific handlers added by this routine.

Arguments:

    InterfaceType   - Identifies the bus type
                      InterfaceTypeUndefined if no interface type for this
                      handler.

    ConfigType      - Identifies the configuration space type
                      ConfigurationSpaceUndefined if no configuration space
                      type for this handler.

    BusNumber       - Identifies the instance of the bus & config space.
                      -1 if the next available bus number for this bus
                      should be used.

    ParentBusType   - If this bus is a child of a bus, then ParentBusType
    ParentBusNumber   and ParentBusNumber identifies that bus.
                      ParentBusType is -1 if no parent bus.

    SizeofBusExetensionData - Sizeof bus specific exentsion data required.

    InstallBusHandler - Function to call to get the bus specific handlers
                        added to the bus handler structure.

Return Value:

    success; otherwise error code of failure.

--*/
{
    PHAL_BUS_HANDLER    Bus, *pBusHandler, OldHandler;
    PBUS_HANDLER        ParentHandler;
    KIRQL               OldIrql;
    NTSTATUS            Status;
    PARRAY              InterfaceArray, InterfaceBusNumberArray;
    PARRAY              ConfigArray, ConfigBusNumberArray;
    PVOID               CodeLockHandle;

    //
    // Must add the handler to at least one table
    //

    ASSERT (InterfaceType != InterfaceTypeUndefined || ConfigType != ConfigurationSpaceUndefined);

    Status = STATUS_SUCCESS;
    OldHandler = NULL;

    //
    // Allocate storage for new bus handler structure
    //

    Bus = (PHAL_BUS_HANDLER)
            ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof (HAL_BUS_HANDLER) + SizeofBusExtensionData,
                HAL_POOL_TAG
                );

    if (!Bus) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Lock pagable code down
    //

    CodeLockHandle = MmLockPagableCodeSection (&HaliRegisterBusHandler);

    //
    // Synchronize adding new bus handlers
    //

    *ReturnedBusHandler = &Bus->Handler;

    KeWaitForSingleObject (
        &HalpBusDatabaseEvent,
        WrExecutive,
        KernelMode,
        FALSE,
        NULL
        );


    //
    // If BusNumber not defined, use next available number for this BusType
    //

    if (BusNumber == -1) {
        ASSERT (InterfaceType != InterfaceTypeUndefined);

        BusNumber = 0;
        while (HaliHandlerForBus (InterfaceType, BusNumber)) {
            BusNumber++;
        }
    }

    //
    // Allocate memory for each array in case any index needs to grow
    //

    InterfaceArray          = HalpAllocateArray (InterfaceType);
    InterfaceBusNumberArray = HalpAllocateArray (BusNumber);
    ConfigArray             = HalpAllocateArray (ConfigType);
    ConfigBusNumberArray    = HalpAllocateArray (BusNumber);

    if (!Bus                            ||
        !InterfaceArray                 ||
        !InterfaceBusNumberArray        ||
        !ConfigArray                    ||
        !ConfigBusNumberArray) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (NT_SUCCESS(Status)) {

        //
        // Lookup parent handler (if any)
        //

        ParentHandler = HaliReferenceHandlerForBus (ParentBusType, ParentBusNumber);

        //
        // Initialize new bus handlers values
        //

        RtlZeroMemory (Bus, sizeof (HAL_BUS_HANDLER) + SizeofBusExtensionData);

        Bus->ReferenceCount = 1;

        Bus->Handler.BusNumber           = BusNumber;
        Bus->Handler.InterfaceType       = InterfaceType;
        Bus->Handler.ConfigurationType   = ConfigType;
        Bus->Handler.ParentHandler       = ParentHandler;

        //
        // Set to dumby handlers
        //

        Bus->Handler.GetBusData           = HalpNoBusData;
        Bus->Handler.SetBusData           = HalpNoBusData;
        Bus->Handler.AdjustResourceList   = HalpNoAdjustResourceList;
        Bus->Handler.AssignSlotResources  = HalpNoAssignSlotResources;

        if (SizeofBusExtensionData) {
            Bus->Handler.BusData = Bus + 1;
        }

        //
        // If bus has a parent, inherit handlers from parent as default
        //

        if (ParentHandler) {
            Bus->Handler.GetBusData           = ParentHandler->GetBusData;
            Bus->Handler.SetBusData           = ParentHandler->SetBusData;
            Bus->Handler.AdjustResourceList   = ParentHandler->AdjustResourceList;
            Bus->Handler.AssignSlotResources  = ParentHandler->AssignSlotResources;
            Bus->Handler.TranslateBusAddress  = ParentHandler->TranslateBusAddress;
            Bus->Handler.GetInterruptVector   = ParentHandler->GetInterruptVector;
        }

        //
        // Install bus specific handlers
        //

        if (InstallBusHandler) {
            Status = InstallBusHandler (&Bus->Handler);
        }

        if (NT_SUCCESS(Status)) {

            //
            // Might change addresses of some arrays synchronize
            // with routing handlers
            //

            LockBusDatabase (&OldIrql);

            //
            // Grow HalpBusTable if needed
            //

            HalpGrowArray (&HalpBusTable, &InterfaceArray);

            if (InterfaceType != InterfaceTypeUndefined) {

                //
                // Grow HalpBusTable if needed
                //

                HalpGrowArray (
                    (PARRAY *) &HalpBusTable->Element[InterfaceType],
                    &InterfaceBusNumberArray
                    );


                //
                // Get registered handler for InterfaceType,BusNumber
                //

                pBusHandler = &((PHAL_BUS_HANDLER)
                    ((PARRAY) HalpBusTable->Element[InterfaceType])->Element[BusNumber]);

                //
                // If handler already defiend, remove the old one
                //

                if (*pBusHandler) {
                    OldHandler = *pBusHandler;
                }

                //
                // Set new handler for supplied InterfaceType,BusNumber
                //

                *pBusHandler = Bus;
            }

            //
            // Grow HalpConfigTable if needed
            //

            HalpGrowArray (&HalpConfigTable, &ConfigArray);

            if (ConfigType != ConfigurationSpaceUndefined) {

                //
                // Grow HalpConfigTable if needed
                //

                HalpGrowArray (
                    (PARRAY *) &HalpConfigTable->Element[ConfigType],
                    &ConfigBusNumberArray
                    );

                //
                // Get registered handler for ConfigType,BusNumber
                //

                pBusHandler = &((PHAL_BUS_HANDLER)
                    ((PARRAY) HalpConfigTable->Element[ConfigType])->Element[BusNumber]);

                if (*pBusHandler) {
                    ASSERT (OldHandler == NULL ||  OldHandler == *pBusHandler);
                    OldHandler = *pBusHandler;
                }

                //
                // Set new handler for supplied ConfigType,BusNumber
                //

                *pBusHandler = Bus;
            }

            //
            // Add new bus handler to list of all installed handlers
            //

            InsertTailList (&HalpAllBusHandlers, &Bus->AllHandlers);

            //
            // Remove old bus handler
            //

            Bus = OldHandler;
            if (Bus) {
                RemoveEntryList (&Bus->AllHandlers);
            }

            //
            // Lookup array modification complete, release lock
            //

            UnlockBusDatabase (OldIrql);
        } else {
            if (ParentHandler) {
                HaliDereferenceBusHandler (ParentHandler);
            }
        }
    }

    //
    // Bus addition modifications complete, set event
    //

    KeSetEvent (&HalpBusDatabaseEvent, 0, FALSE);

    //
    // Unlock pagable code
    //

    MmUnlockPagableImageSection (CodeLockHandle);

    //
    // Free memory which is not in use
    //

    if (Bus) {
        ExFreePool (Bus);
    }

    if (InterfaceArray) {
        ExFreePool (InterfaceArray);
    }

    if (InterfaceBusNumberArray) {
        ExFreePool (InterfaceBusNumberArray);
    }

    if (ConfigArray) {
        ExFreePool (ConfigArray);
    }

    if (ConfigBusNumberArray) {
        ExFreePool (ConfigBusNumberArray);
    }

    return Status;
}

PARRAY
HalpAllocateArray (
    IN ULONG    ArraySize
    )
/*++

Routine Description:

    Allocate an array of size ArraySize.

Arguments:

    ArraySize   - Size of array in elements

Return Value:

    pointer to ARRAY

--*/
{
    PARRAY  Array;

    if (ArraySize == -1) {
        ArraySize = 0;
    }

    Array = ExAllocatePoolWithTag (
                NonPagedPool,
                ARRAY_SIZE_IN_BYTES(ArraySize),
                HAL_POOL_TAG
                );
    if (!Array) {

        //
        // This allocation was critical.
        //

        KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                     ARRAY_SIZE_IN_BYTES(ArraySize),
                     0,
                     (ULONG_PTR)__FILE__,
                     __LINE__
                     );
    }

    //
    // Initialize array
    //

    Array->ArraySize = ArraySize;
    RtlZeroMemory (Array->Element, sizeof(PVOID) * (ArraySize+1));
    return Array;
}

VOID
HalpGrowArray (
    IN PARRAY   *CurrentArray,
    IN PARRAY   *NewArray
    )
/*++

Routine Description:

    If NewArray is larger then CurrentArray, then the CurrentArray
    is grown to the sizeof NewArray by swapping the pointers and
    moving the arrays contents.

Arguments:

    CurrentArray - Address of the current array pointer
    NewArray     - Address of the new array pointer

--*/
{
    PVOID       Tmp;

    if (!*CurrentArray || (*NewArray)->ArraySize > (*CurrentArray)->ArraySize) {

        //
        // Copy current array ontop of new array
        //

        if (*CurrentArray) {
            RtlCopyMemory (&(*NewArray)->Element,
                           &(*CurrentArray)->Element,
                           sizeof(PVOID) * ((*CurrentArray)->ArraySize + 1)
                           );
        }


        //
        // swap current with new such that the new array is the current
        // one, and the old memory will be freed back to pool
        //

        Tmp = *CurrentArray;
        *CurrentArray = *NewArray;
        *NewArray = Tmp;
    }
}

PBUS_HANDLER
FASTCALL
HalpLookupHandler (
    IN PARRAY   Array,
    IN ULONG    Type,
    IN ULONG    Number,
    IN BOOLEAN  AddReference
    )
{
    PHAL_BUS_HANDLER    Bus;
    PBUS_HANDLER        Handler;
    KIRQL               OldIrql;

    LockBusDatabase (&OldIrql);

    //
    // Index by type
    //

    Handler = NULL;
    if (Array->ArraySize >= Type) {
        Array = (PARRAY) Array->Element[Type];

        //
        // Index by instance numberr
        //

        if (Array && Array->ArraySize >= Number) {
            Bus = (PHAL_BUS_HANDLER) Array->Element[Number];
            Handler = &Bus->Handler;

            if (AddReference) {
                Bus->ReferenceCount += 1;
            }
        }
    }

    UnlockBusDatabase (OldIrql);
    return Handler;
}

VOID
FASTCALL
HaliReferenceBusHandler (
    IN PBUS_HANDLER   Handler
    )
/*++

Routine Description:


--*/
{
    KIRQL               OldIrql;
    PHAL_BUS_HANDLER    Bus;


    LockBusDatabase (&OldIrql);

    Bus = CONTAINING_RECORD(Handler, HAL_BUS_HANDLER, Handler);
    Bus->ReferenceCount += 1;

    UnlockBusDatabase (OldIrql);
}

VOID
FASTCALL
HaliDereferenceBusHandler (
    IN PBUS_HANDLER   Handler
    )
/*++

Routine Description:


--*/
{
    KIRQL               OldIrql;
    PHAL_BUS_HANDLER    Bus;


    LockBusDatabase (&OldIrql);

    Bus = CONTAINING_RECORD(Handler, HAL_BUS_HANDLER, Handler);
    Bus->ReferenceCount -= 1;

    UnlockBusDatabase (OldIrql);

    // for now totally removing a bus is not supported
    ASSERT (Bus->ReferenceCount != 0);
}


PBUS_HANDLER
FASTCALL
HaliHandlerForBus (
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG          BusNumber
    )
/*++

Routine Description:

    Returns the BusHandler structure InterfaceType,BusNumber
    or NULL if no such handler exists.

--*/
{
    return HalpLookupHandler (HalpBusTable, (ULONG) InterfaceType, BusNumber, FALSE);
}

PBUS_HANDLER
FASTCALL
HaliHandlerForConfigSpace (
    IN BUS_DATA_TYPE  ConfigType,
    IN ULONG          BusNumber
    )
/*++

Routine Description:

    Returns the BusHandler structure ConfigType,BusNumber
    or NULL if no such handler exists.

--*/
{
    return HalpLookupHandler (HalpConfigTable, (ULONG) ConfigType, BusNumber, FALSE);
}


PBUS_HANDLER
FASTCALL
HaliReferenceHandlerForBus (
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG          BusNumber
    )
/*++

Routine Description:

    Returns the BusHandler structure InterfaceType,BusNumber
    or NULL if no such handler exists.

--*/
{
    return HalpLookupHandler (HalpBusTable, (ULONG) InterfaceType, BusNumber, TRUE);
}

PBUS_HANDLER
FASTCALL
HaliReferenceHandlerForConfigSpace (
    IN BUS_DATA_TYPE  ConfigType,
    IN ULONG          BusNumber
    )
/*++

Routine Description:

    Returns the BusHandler structure ConfigType,BusNumber
    or NULL if no such handler exists.

--*/
{
    return HalpLookupHandler (HalpConfigTable, (ULONG) ConfigType, BusNumber, TRUE);
}

NTSTATUS
HalpQueryInstalledBusInformation (
    OUT PVOID   Buffer,
    IN  ULONG   BufferLength,
    OUT PULONG  ReturnedLength
    )
/*++

Routine Description:

    Returns an array HAL_BUS_INFORMATION, one for each
    bus handler installed.

Arguments:

    Buffer - output buffer
    BufferLength - length of buffer on input
    ReturnedLength - The length of data returned

Return Value:

    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL - The ReturnedLength contains the buffersize
        currently needed.

--*/
{
    PHAL_BUS_INFORMATION    Info;
    PHAL_BUS_HANDLER        Handler;
    ULONG                   i, j;
    ULONG                   Length;
    NTSTATUS                Status;
    PARRAY                  Array;

    PAGED_CODE ();

    //
    // Synchronize adding new bus handlers
    //

    KeWaitForSingleObject (
        &HalpBusDatabaseEvent,
        WrExecutive,
        KernelMode,
        FALSE,
        NULL
        );

    //
    // Determine sizeof return buffer
    //

    Length = 0;
    for (i=0; i <= HalpBusTable->ArraySize; i++) {
        Array = (PARRAY) HalpBusTable->Element[i];
        if (Array) {
            Length += sizeof (HAL_BUS_INFORMATION) *
                      (Array->ArraySize + 1);
        }
    }

    //
    // Return size of buffer returning, or size of buffer needed
    //

    *ReturnedLength = Length;

    //
    // Fill in the return buffer
    //

    if (Length <= BufferLength) {

        Info = (PHAL_BUS_INFORMATION) Buffer;

        for (i=0; i <= HalpBusTable->ArraySize; i++) {
            Array = (PARRAY) HalpBusTable->Element[i];
            if (Array) {
                for (j=0; j <= Array->ArraySize; j++) {
                    Handler = (PHAL_BUS_HANDLER) Array->Element[j];

                    if (Handler) {
                        Info->BusType = Handler->Handler.InterfaceType;
                        Info->ConfigurationType = Handler->Handler.ConfigurationType;
                        Info->BusNumber = Handler->Handler.BusNumber;
                        Info->Reserved = 0;
                        Info += 1;
                    }
                }
            }
        }

        Status = STATUS_SUCCESS;

    } else {

        //
        // Return buffer too small
        //

        Status = STATUS_BUFFER_TOO_SMALL;
    }

    KeSetEvent (&HalpBusDatabaseEvent, 0, FALSE);
    return Status;
}

//
// Default dispatchers to BusHandlers
//

ULONG
HalGetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalGetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

ULONG
HalGetBusDataByOffset (
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for GetBusData

--*/
{
    PBUS_HANDLER Handler;
    NTSTATUS     Status;

    Handler = HaliReferenceHandlerForConfigSpace (BusDataType, BusNumber);
    if (!Handler) {
        return 0;
    }

    Status = Handler->GetBusData (Handler, Handler, SlotNumber, Buffer, Offset, Length);
    HaliDereferenceBusHandler (Handler);
    return Status;
}

ULONG
HalSetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalSetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

ULONG
HalSetBusDataByOffset(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for SetBusData

--*/
{
    PBUS_HANDLER Handler;
    NTSTATUS     Status;

    Handler = HaliReferenceHandlerForConfigSpace (BusDataType, BusNumber);
    if (!Handler) {
        return 0;
    }

    Status = Handler->SetBusData (Handler, Handler, SlotNumber, Buffer, Offset, Length);
    HaliDereferenceBusHandler (Handler);
    return Status;
}

#if !defined(NO_LEGACY_DRIVERS)

NTSTATUS
HalAdjustResourceList (
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    )
/*++

Routine Description:

    Dispatcher for AdjustResourceList

--*/
{
    PBUS_HANDLER Handler;
    NTSTATUS     Status;

    PAGED_CODE ();
    Handler = HaliReferenceHandlerForBus (
                (*pResourceList)->InterfaceType,
                (*pResourceList)->BusNumber
              );
    if (!Handler) {
        return STATUS_SUCCESS;
    }

    Status = Handler->AdjustResourceList (Handler, Handler, pResourceList);
    HaliDereferenceBusHandler (Handler);
    return Status;
}


NTSTATUS
HalAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
{
    PAGED_CODE ();
    if (BusType == PCIBus) {
        //
        // Call through the HAL private dispatch table
        // for PCI-related translations.  This is part
        // of transitioning the HAL out of the bus
        // management business.
        //
        return HALPDISPATCH->HalPciAssignSlotResources(RegistryPath,
                                                       DriverClassName,
                                                       DriverObject,
                                                       DeviceObject,
                                                       BusType,
                                                       BusNumber,
                                                       SlotNumber,
                                                       AllocatedResources);
    } else {

        return HalpAssignSlotResources(RegistryPath,
                                       DriverClassName,
                                       DriverObject,
                                       DeviceObject,
                                       BusType,
                                       BusNumber,
                                       SlotNumber,
                                       AllocatedResources);
    }
}

NTSTATUS
HalpAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
/*++

Routine Description:

    Dispatcher for AssignSlotResources

--*/
{
    PBUS_HANDLER Handler;
    NTSTATUS     Status;

    PAGED_CODE ();
    Handler = HaliReferenceHandlerForBus (BusType, BusNumber);
    if (!Handler) {
        return STATUS_NOT_FOUND;
    }

    Status = Handler->AssignSlotResources (
                Handler,
                Handler,
                RegistryPath,
                DriverClassName,
                DriverObject,
                DeviceObject,
                SlotNumber,
                AllocatedResources
            );

    HaliDereferenceBusHandler (Handler);
    return Status;
}


ULONG
HalGetInterruptVector(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )
/*++

Routine Description:

    Dispatcher for GetInterruptVector

--*/
{
    PBUS_HANDLER Handler;
    ULONG        Vector;

    PAGED_CODE ();
    Handler = HaliReferenceHandlerForBus (InterfaceType, BusNumber);
    *Irql = 0;
    *Affinity = 0;

    if (!Handler) {
        return 0;
    }

    Vector = Handler->GetInterruptVector (Handler, Handler,
              BusInterruptLevel, BusInterruptVector, Irql, Affinity);

    HaliDereferenceBusHandler (Handler);
    return Vector;
}
#endif // NO_LEGACY_DRIVERS


BOOLEAN
HalTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
{
    if (InterfaceType == PCIBus) {
        //
        // Call through the HAL private dispatch table
        // for PCI-related translations.  This is part
        // of transitioning the HAL out of the bus
        // management business.
        //
        return HALPDISPATCH->HalPciTranslateBusAddress(InterfaceType,
                                                       BusNumber,
                                                       BusAddress,
                                                       AddressSpace,
                                                       TranslatedAddress);
    } else {
        return HaliTranslateBusAddress(InterfaceType,
                                       BusNumber,
                                       BusAddress,
                                       AddressSpace,
                                       TranslatedAddress);
    }
}

BOOLEAN
HaliTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
/*++

Routine Description:

    Dispatcher for TranslateBusAddress

--*/
{
    PBUS_HANDLER Handler;
    BOOLEAN      Status;

    Handler = HaliReferenceHandlerForBus (InterfaceType, BusNumber);
    if (!Handler || !Handler->TranslateBusAddress) {
        return FALSE;
    }

    Status = Handler->TranslateBusAddress (Handler, Handler,
              BusAddress, AddressSpace, TranslatedAddress);

    HaliDereferenceBusHandler (Handler);
    return Status;
}

//
// Null handlers
//

ULONG HalpNoBusData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Stub handler for buses which do not have a configuration space

--*/
{
    return 0;
}

NTSTATUS
HalpNoAdjustResourceList (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    )
/*++

Routine Description:

    Stub handler for buses which do not have a configuration space

--*/
{
    PAGED_CODE ();
    return STATUS_UNSUCCESSFUL;
}


NTSTATUS
HalpNoAssignSlotResources (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
/*++

Routine Description:

    Stub handler for buses which do not have a configuration space

--*/
{
    PAGED_CODE ();
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
HalpNoQueryBusSlots (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG                BufferSize,
    OUT PULONG              SlotNumbers,
    OUT PULONG              ReturnedLength
    )
{
    PAGED_CODE ();
    return STATUS_NOT_SUPPORTED;
}

PDEVICE_HANDLER_OBJECT
HalpNoReferenceDeviceHandler (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN ULONG                SlotNumber
    )
{
    PAGED_CODE ();
    return NULL;
}

ULONG
HalpNoGetDeviceData (
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PDEVICE_HANDLER_OBJECT   DeviceHandler,
    IN ULONG                    DataType,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    )
{
    return 0;
}

ULONG
HalpNoSetDeviceData (
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PDEVICE_HANDLER_OBJECT   DeviceHandler,
    IN ULONG                    DataType,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    )
{
    return 0;
}

PBUS_HANDLER
HalpContextToBusHandler(
    IN ULONG_PTR Context
    )

/*++

Routine Description:

    Convert a context into a pointer to a bus handler.   Not really
    a big deal as the context IS a pointer to a bus handler,... or
    possibly null in which case we want the first bus handler.

    For the sake of paranoia, we run down the list of bus handlers
    to find a match for the incoming context.  This is because context
    is supplied by something outside the HAL.

Arguments:

    Context             ULONG_PTR either NULL or a value from which
                        a pointer to a bus handler can be derived.

Return Value:

    Pointer to a bus handler or NULL if the incoming context was not
    valid.

--*/

{
    PLIST_ENTRY OldHalBusHandler;
    PLIST_ENTRY NewHalBusHandler;

    NewHalBusHandler = HalpAllBusHandlers.Flink;

    if (Context) {

        //
        // Caller supplied a handler, convert to a HAL_BUS_HANDLER.
        //

        OldHalBusHandler = &CONTAINING_RECORD((PBUS_HANDLER)Context,
                                              HAL_BUS_HANDLER,
                                              Handler)->AllHandlers;

        while (NewHalBusHandler != &HalpAllBusHandlers) {

            if (NewHalBusHandler == OldHalBusHandler) {

                //
                // Match.
                //

                break;
            }
            NewHalBusHandler = NewHalBusHandler->Flink;
        }
    }

    if (NewHalBusHandler == &HalpAllBusHandlers) {

        //
        // If at end of list, either the incoming value wasn't
        // on the list or this list is empty.
        //

#if DBG

        DbgPrint("HAL: HalpContextToBusHandler, invalid context.\n");

#endif

        return NULL;
    }

    return &CONTAINING_RECORD(NewHalBusHandler,
                              HAL_BUS_HANDLER,
                              AllHandlers)->Handler;

}
#if 0 // PLJ
PBUS_HANDLER
HalpGetNextBusHandler(
    IN PBUS_HANDLER Previous
    )
{
    PLIST_ENTRY OldHalBusHandler;
    PLIST_ENTRY NewHalBusHandler;
    PBUS_HANDLER Next;

    NewHalBusHandler = HalpAllBusHandlers.Flink;

    if (Previous != NULL) {

        //
        // Caller supplied a handler, convert to a HAL_BUS_HANDLER.
        //

        OldHalBusHandler = &CONTAINING_RECORD(Previous,
                                              HAL_BUS_HANDLER,
                                              Handler)->AllHandlers;

        //
        // Paranoia (should probably be DBG only but there isn't
        // that many handlers and we don't do this all that often.
        //

        {
            PLIST_ENTRY ThisIteration = NULL;

            while (NewHalBusHandler != &HalpAllBusHandlers) {

                ThisIteration = NewHalBusHandler;
                NewHalBusHandler = NewHalBusHandler->Flink;

                if (ThisIteration == OldHalBusHandler) {

                    //
                    // Match.
                    //

                    break;
                }
            }

            //
            // If at end of list, either the incoming value wasn't
            // on the list it was the last thing on the list, either
            // way, there is no next entry.
            //

#if DBG

            if (ThisIteration != OldHalBusHandler) {
                DbgPrint("HAL: HalpGetNextBusHandler, previous handler invalid.\n");
            }

#endif

        }
    }

    if (NewHalBusHandler == &HalpAllBusHandlers) {
        return NULL;
    }

    return &CONTAINING_RECORD(NewHalBusHandler,
                              HAL_BUS_HANDLER,
                              AllHandlers)->Handler;
}
#endif

BOOLEAN
HaliFindBusAddressTranslation(
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PULONG_PTR Context,
    IN BOOLEAN NextBus
    )

/*++

Routine Description:

    This routine performs a very similar function to HalTranslateBusAddress
    except that InterfaceType and BusNumber are not known by the caller.
    This function will walk all busses known by the HAL looking for a
    valid translation for the input BusAddress of type AddressSpace.

    This function is recallable using the input/output Context parameter.
    On the first call to this routine for a given translation the ULONG_PTR
    Context should be NULL.  Note:  Not the address of it but the contents.

    If the caller decides the returned translation is not the desired
    translation, it calls this routine again passing Context in as it
    was returned on the previous call.  This allows this routine to
    traverse the bus structures until the correct translation is found
    and is provided because on multiple bus systems, it is possible for
    the same resource to exist in the independent address spaces of
    multiple busses.

    Note:  This routine is not called directly, it is called through
    the HALPDISPATCH table.  If a HAL implements a simpler version of
    this function (eg generic PC/AT boxes don't actually need translation,
    those HALs substitute their own version of this routine.   This
    routine is not otherwise exported from the HAL.

Arguments:

    BusAddress          Address to be translated.
    AddressSpace        0 = Memory
                        1 = IO (There are other possibilities).
                        N.B. This argument is a pointer, the value
                        will be modified if the translated address
                        is of a different address space type from
                        the untranslated bus address.
    TranslatedAddress   Pointer to where the translated address
                        should be stored.
    Context             Pointer to a ULONG_PTR. On the initial call,
                        for a given BusAddress, it should contain
                        0.  It will be modified by this routine,
                        on subsequent calls for the same BusAddress
                        the value should be handed in again,
                        unmodified by the caller.
    NextBus             FALSE if we should attempt this translation
                        on the same bus as indicated by Context,
                        TRUE if we should be looking for another
                        bus.

Return Value:

    TRUE    if translation was successful,
    FALSE   otherwise.

--*/

{
    PLIST_ENTRY HalBusHandler;
    PBUS_HANDLER Handler;

    //
    // First, make sure the context parameter was supplied. (paranoia).
    //

    if (!Context) {
        ASSERT(Context);
        return FALSE;
    }

    ASSERT(*Context || (NextBus == TRUE));

    //
    // Note: The Context is really a PBUS_HANDLER, but,
    // HalpContextToBusHandler is paranoid. If the incoming
    // Context isn't what we expect, we won't use it as a
    // pointer.
    //

    Handler = HalpContextToBusHandler(*Context);

    if (!Handler) {
        ASSERT(Handler);
        return FALSE;
    }

    if (NextBus == FALSE) {

        //
        // Attempt translation on THIS bus (and ONLY this bus).
        //

        ASSERT(Handler == (PBUS_HANDLER)*Context);

        if (HalTranslateBusAddress(
                Handler->InterfaceType,
                Handler->BusNumber,
                BusAddress,
                AddressSpace,
                TranslatedAddress)) {
            *Context = (ULONG_PTR)Handler;
            return TRUE;
        }

        return FALSE;
    }

    HalBusHandler = &CONTAINING_RECORD(Handler,
                                       HAL_BUS_HANDLER,
                                       Handler)->AllHandlers;
    //
    // Handler is either the bus that came in in Context or the
    // first bus if *Context was null.   If *Context wasn't NULL,
    // we want the next bus.
    //

    if (*Context) {
        HalBusHandler = HalBusHandler->Flink;
    }

    //
    // Examine each remaining bus looking for one that will translate
    // this address.
    //

    while (HalBusHandler != &HalpAllBusHandlers) {

        //
        // This is gross, having gone to all the trouble to find
        // the handler, it seems a pity to break it out into parameters
        // used to search for this handler.
        //
        // Use HalTranslateAddress to find out if this translation
        // works on this handler.
        //

        Handler = &CONTAINING_RECORD(HalBusHandler,
                                     HAL_BUS_HANDLER,
                                     AllHandlers)->Handler;

        if (HalTranslateBusAddress(
                Handler->InterfaceType,
                Handler->BusNumber,
                BusAddress,
                AddressSpace,
                TranslatedAddress)) {
            *Context = (ULONG_PTR)Handler;
            return TRUE;
        }

        //
        // Try next handler.
        //

        HalBusHandler = HalBusHandler->Flink;
    }

    //
    // Didn't find another handler this translation works with.  Set
    // the Context such that we don't do the scan again (unless the
    // caller resets it) and indicate failure.
    //

    *Context = 1;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\chiphacks.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    chiphacks.c

Abstract:

    Implements utilities for finding and hacking
    various chipsets

Author:

    Jake Oshins (jakeo) 10/02/2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "chiphacks.h"
#include "stdio.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HalpGetChipHacks)
#pragma alloc_text(PAGE, HalpSetAcpiIrqHack)
#pragma alloc_text(PAGELK, HalpClearSlpSmiStsInICH)
#endif


NTSTATUS
HalpGetChipHacks(
    IN  USHORT  VendorId,
    IN  USHORT  DeviceId,
    IN  UCHAR   RevisionId OPTIONAL,
    OUT ULONG   *HackFlags
    )
/*++

Routine Description:

    This routine looks under HKLM\System\CurrentControlSet\Control\HAL
    to see if there is an entry for the PCI device being
    described.  If so, it returns a set of associated flags.

Arguments:

    VendorId    - PCI Vendor ID of chip
    DeviceId    - PCI Device ID of chip
    RevisionID  - PCI Revision ID of chip, if applicable
    HackFlags   - value read from registry

--*/
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      UnicodeString;
    NTSTATUS            Status;
    HANDLE              Handle = NULL;
    ULONG               Length;
    WCHAR               buffer[9];

    struct {
        KEY_VALUE_PARTIAL_INFORMATION   Inf;
        UCHAR Data[3];
    } PartialInformation;

    PAGED_CODE();

    //
    // Open current control set
    //

    RtlInitUnicodeString (&UnicodeString,
                          L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\Control\\HAL");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    Status = ZwOpenKey(&Handle, KEY_READ, &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Look in the registry to see if the registry
    // contains an entry for this chip.  The first
    // step is to build a string that defines the chip.
    //

    swprintf(buffer, L"%04X%04X", VendorId, DeviceId);

    RtlInitUnicodeString(&UnicodeString, buffer);

    Status = ZwQueryValueKey (Handle,
                              &UnicodeString,
                              KeyValuePartialInformation,
                              &PartialInformation,
                              sizeof(PartialInformation),
                              &Length);

    if (NT_SUCCESS(Status)) {

        //
        // We found a value in the registry
        // that corresponds with the chip
        // we just ran across.
        //

        *HackFlags = *((PULONG)(PartialInformation.Inf.Data));

        //
        // If revisionId is specified, test if there are updated flags
        // for this rev
        //
        *HackFlags =
            ((RevisionId != 0) &&
             (RevisionId >= HACK_REVISION(*HackFlags))) ?
            REVISED_HACKS(*HackFlags):
            BASE_HACKS(*HackFlags);
    }

    ZwClose(Handle);

    return Status;
}

VOID
HalpStopOhciInterrupt(
    ULONG               BusNumber,
    PCI_SLOT_NUMBER     SlotNumber
    )
/*++

Routine Description:

    This routine shuts off the interrupt from an OHCI
    USB controller.  This may be necessary because
    a BIOS may enable the PCI interrupt from a USB controller
    in order to do "legacy USB support" where it translates
    USB keyboard and mouse traffic into something that DOS
    can use.  (Our loader and all of Win9x approximate DOS.)

Arguments:

    BusNumber   - Bus number of OHCI controller
    SlotNumber  - Slot number of OHCI controller

Note:

    This routine also may need to be called at raised IRQL
    when returning from hibernation.

--*/
{
    //
    // 7.1.2 HcControl Register
    //
    #define HcCtrl_InterruptRouting              0x00000100L

    //
    // 7.1.3 HcCommandStatus Register
    //
    #define HcCmd_OwnershipChangeRequest         0x00000008L

    //
    // 7.1.4 HcInterrruptStatus Register
    // 7.1.5 HcInterruptEnable  Register
    // 7.1.6 HcInterruptDisable Register
    //
    #define HcInt_SchedulingOverrun              0x00000001L
    #define HcInt_WritebackDoneHead              0x00000002L
    #define HcInt_StartOfFrame                   0x00000004L
    #define HcInt_ResumeDetected                 0x00000008L
    #define HcInt_UnrecoverableError             0x00000010L
    #define HcInt_FrameNumberOverflow            0x00000020L
    #define HcInt_RootHubStatusChange            0x00000040L
    #define HcInt_OwnershipChange                0x40000000L
    #define HcInt_MasterInterruptEnable          0x80000000L

    //
    // Host Controler Hardware Registers as accessed in memory
    //
    struct  {
       // 0 0x00 - 0,4,8,c
       ULONG                   HcRevision;
       ULONG                   HcControl;
       ULONG                   HcCommandStatus;
       ULONG                   HcInterruptStatus;   // use HcInt flags below
       // 1 0x10
       ULONG                   HcInterruptEnable;   // use HcInt flags below
       ULONG                   HcInterruptDisable;  // use HcInt flags below
    } volatile *ohci;

    PCI_COMMON_CONFIG   PciHeader;
    PHYSICAL_ADDRESS    BarAddr;

    HalGetBusData (
        PCIConfiguration,
        BusNumber,
        SlotNumber.u.AsULONG,
        &PciHeader,
        PCI_COMMON_HDR_LENGTH
        );

    if (PciHeader.Command & PCI_ENABLE_MEMORY_SPACE) {

        //
        // The controller is enabled.
        //

        BarAddr.HighPart = 0;
        BarAddr.LowPart = (PciHeader.u.type0.BaseAddresses[0] & PCI_ADDRESS_MEMORY_ADDRESS_MASK);

        if (BarAddr.LowPart != 0) {

            //
            // The BAR is populated.  So map an address for it.  Since PCI addresses are naturally aligned powers
            // of two we don't need to worry about this spanning two pages.
            //

            ohci = HalpMapPhysicalMemory64(BarAddr, 1);

            //
            // Set the interrupt disable bit, but disable SMM control of the
            // host controller first.
            //

            if (ohci) {

                if (ohci->HcControl & HcCtrl_InterruptRouting) {

                    if ((ohci->HcControl == HcCtrl_InterruptRouting) &&
                        (ohci->HcInterruptEnable == 0)) {

                        // Major assumption:  If HcCtrl_InterruptRouting is
                        // set but no other bits in HcControl are set, i.e.
                        // HCFS==UsbReset, and no interrupts are enabled, then
                        // assume that the BIOS is not actually using the host
                        // controller.  In this case just clear the erroneously
                        // set HcCtrl_InterruptRouting.
                        //
                        ohci->HcControl = 0;  // Clear HcCtrl_InterruptRouting

                    } else {

                        ULONG msCount;

                        //
                        // A SMM driver does own the HC, it will take some time
                        // to get the SMM driver to relinquish control of the
                        // HC.  We will ping the SMM driver, and then wait
                        // repeatedly until the SMM driver has relinquished
                        // control of the HC.
                        //

                        // Disable the root hub status change to prevent an
                        // unhandled interrupt from being asserted after
                        // handoff.  (Not clear what platforms really require
                        // this...)
                        //
                        ohci->HcInterruptDisable = HcInt_RootHubStatusChange;

                        // The HcInt_MasterInterruptEnable and HcInt_OwnershipChange
                        // bits should already be set, but make sure they are.
                        //
                        ohci->HcInterruptEnable = HcInt_MasterInterruptEnable |
                                                  HcInt_OwnershipChange;

                        // Ping the SMM driver to relinquish control of the HC.
                        //
                        ohci->HcCommandStatus = HcCmd_OwnershipChangeRequest;

                        // Wait 500ms for the SMM driver to relinquish control.
                        //
                        for (msCount = 0; msCount < 500; msCount++) {

                            KeStallExecutionProcessor(1000);

                            if (!(ohci->HcControl & HcCtrl_InterruptRouting)) {
                                // SMM driver has relinquished control.
                                break;
                            }
                        }
                    }
                }

                ohci->HcInterruptDisable = HcInt_MasterInterruptEnable;

                //
                // Unmap the virtual address.
                //

                HalpUnmapVirtualAddress((PVOID)ohci, 1);
            }
        }
    }
}

VOID
HalpStopUhciInterrupt(
    ULONG               BusNumber,
    PCI_SLOT_NUMBER     SlotNumber,
    BOOLEAN             ResetHostController
    )
/*++

Routine Description:

    This routine shuts off the interrupt from an UHCI
    USB controller.  This may be necessary because
    a BIOS may enable the PCI interrupt from a USB controller
    in order to do "legacy USB support" where it translates
    USB keyboard and mouse traffic into something that DOS
    can use.  (Our loader and all of Win9x approximate DOS.)

Arguments:

    BusNumber   - Bus number of UHCI controller
    SlotNumber  - Slot number of UHCI controller

Note:

    This routine also may need to be called at raised IRQL
    when returning from hibernation.

--*/
{
    ULONG               Usb = 0;
    USHORT              cmd;
    PCI_COMMON_CONFIG   PciHeader;

    if (ResetHostController) {

        //
        // Clear out the host controller legacy support register
        // prior to handing the USB to the USB driver, because we
        // don't want any SMIs being generated.
        //

        Usb = 0x0000;

        HalSetBusDataByOffset (
            PCIConfiguration,
            BusNumber,
            SlotNumber.u.AsULONG,
            &Usb,
            0xc0,
            sizeof(ULONG)
            );

        //
        // Put the USB controller into reset, as it may share it's
        // PIRQD line with another USB controller on the chipset.
        // This is not a problem unless the bios is running in legacy
        // mode and causing interrupts. In this case, the minute PIRQD
        // gets flipped by one usbuhci controller, the other could
        // start generating unhandled interrupts and hang the system.
        // This is the case with the ICH2 chipset.
        //

        HalGetBusData (
            PCIConfiguration,
            BusNumber,
            SlotNumber.u.AsULONG,
            &PciHeader,
            PCI_COMMON_HDR_LENGTH
            );

        if (PciHeader.Command & PCI_ENABLE_IO_SPACE) {

            //
            // The controller is enabled.
            //

            Usb = (PciHeader.u.type0.BaseAddresses[4] & PCI_ADDRESS_IO_ADDRESS_MASK);

            if (Usb != 0 && Usb < 0x0000ffff) {

                // Valid I/O address.

                //
                // If we are returning from suspend, don't put the controller
                // into reset.
                //
                cmd = READ_PORT_USHORT(UlongToPtr(Usb));

                if (!(cmd & 0x0008)) {
                    //
                    // Put the controller in reset. Usbuhci will take it out of reset
                    // when it grabs it.
                    //
    
                    cmd = 0x0004;
    
                    WRITE_PORT_USHORT(UlongToPtr(Usb), cmd);
 
                    //
                    // Wait 10ms and then take the controller out of reset.
                    //

                    KeStallExecutionProcessor(10000);
 
                    cmd = 0x0000;
    
                    WRITE_PORT_USHORT(UlongToPtr(Usb), cmd);
                }
            }
        }
    } else {

        //
        // Shut off the interrupt for the USB controller, as it
        // is very frequently the reason that the machine freezes
        // during boot.  Anding the register with ~0xbf00 clears bit
        // 13, PIRQ Enable, which is the whole point.  The rest of
        // the bits just avoid writing registers that are "write
        // one to clear."
        //

        HalGetBusDataByOffset (
            PCIConfiguration,
            BusNumber,
            SlotNumber.u.AsULONG,
            &Usb,
            0xc0,
            sizeof(ULONG)
            );

        Usb &= ~0xbf00;

        HalSetBusDataByOffset (
            PCIConfiguration,
            BusNumber,
            SlotNumber.u.AsULONG,
            &Usb,
            0xc0,
            sizeof(ULONG)
            );

    }
}

VOID
HalpWhackICHUsbSmi(
    ULONG               BusNumber,
    PCI_SLOT_NUMBER     SlotNumber
    )
{
    ULONG   PmBase = 0;
    ULONG   SmiEn;

    //
    // ICH (and the like) have the PM_BASE register in
    // config space at offset 0x40.
    //

    HalGetBusDataByOffset (
        PCIConfiguration,
        BusNumber,
        SlotNumber.u.AsULONG,
        &PmBase,
        0x40,
        4);

    if (!PmBase) {
        return;
    }

    PmBase &= PCI_ADDRESS_IO_ADDRESS_MASK;

    //
    // At PM_BASE + 0x30 in I/O space, we have the SMI_EN
    // register.
    //

    SmiEn = READ_PORT_ULONG((PULONG)UlongToPtr(PmBase + 0x30));

    //
    // Clear bit 3, LEGACY_USB_EN.
    //

    SmiEn &= ~8;
    WRITE_PORT_ULONG((PULONG)UlongToPtr(PmBase + 0x30), SmiEn);

    return;
}

VOID
HalpSetAcpiIrqHack(
    ULONG   Value
    )
/*++

Routine Description:

    This routine sets the registry key that causes the
    ACPI driver to attempt to put all PCI interrupts
    on a single IRQ.  While putting this hack here may
    seem strange, the hack has to be applied before
    an INFs are processed.  And so much of the chip
    recognizing code already exists here, duplicating
    it in the ACPI driver would bloat the code and cause
    us to do another PCI bus scan and registry search
    during boot.

Arguments:

    Value   - This goes in the ACPI\Parameters\IRQDistribution
              key.

--*/
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      UnicodeString;
    HANDLE              BaseHandle = NULL;
    NTSTATUS            status;

    PAGED_CODE();

    RtlInitUnicodeString (&UnicodeString,
                          L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\Services\\ACPI\\Parameters");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwCreateKey (&BaseHandle,
                          KEY_WRITE,
                          &ObjectAttributes,
                          0,
                          (PUNICODE_STRING) NULL,
                          REG_OPTION_NON_VOLATILE,
                          NULL);

    if (!NT_SUCCESS(status)) {
        return;
    }

    RtlInitUnicodeString (&UnicodeString,
                          L"IRQDistribution");

    status = ZwSetValueKey (BaseHandle,
                            &UnicodeString,
                            0,
                            REG_DWORD,
                            &Value,
                            sizeof(ULONG));

    ASSERT(NT_SUCCESS(status));
    ZwClose(BaseHandle);
    return;
}

VOID
HalpClearSlpSmiStsInICH(
    VOID
    )
{
    PPCI_COMMON_CONFIG   PciHeader;
    UCHAR   buffer[0x44] = {0};
    ULONG   PmBase;
    UCHAR   SmiSts, SmiEn;

    PciHeader = (PPCI_COMMON_CONFIG)&buffer;

    //
    // ASUS has a BIOS bug that will leave the
    // SLP_SMI_STS bit set even when the SLP_SMI_EN
    // bit is clear.  The BIOS will furthermore
    // shut the machine down on the next SMI when
    // this occurs.
    //


    //
    // Check for ICH.
    //

    HalGetBusDataByOffset (
        PCIConfiguration,
        0,
        0x1f,
        PciHeader,
        0,
        0x44);

    if ((PciHeader->VendorID == 0x8086) &&
        (PciHeader->BaseClass == PCI_CLASS_BRIDGE_DEV) &&
        (PciHeader->SubClass == PCI_SUBCLASS_BR_ISA)) {

        //
        // This is an ICH.  Offset 0x40 will have an I/O BAR
        // which is the PM_BASE register.
        //

        PmBase = *(PULONG)PciHeader->DeviceSpecific;
        PmBase &= PCI_ADDRESS_IO_ADDRESS_MASK;

        SmiEn = READ_PORT_UCHAR(UlongToPtr(PmBase + 0x30));

        if (!(SmiEn & 0x10)) {

            //
            // The SLP_SMI_EN bit in the SMI_EN register was
            // clear.
            //

            SmiSts = READ_PORT_UCHAR(UlongToPtr(PmBase + 0x34));

            if (SmiSts & 0x10) {

                //
                // But the SLP_SMI_STS bit was set, implying
                // that the ASUS BIOS is about to keel over.
                // Clear the bit.
                //

                WRITE_PORT_UCHAR(UlongToPtr(PmBase + 0x34), 0x10);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\rangesup.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
All rights reserved

Module Name:

    rangesup.c

Abstract:

    Supplies support function for dealing with SUPPORTED_RANGEs.

Author:

    Ken Reneris (kenr) March-27-1995

Environment:

    Kernel mode only.

Revision History:


*/

#include "halp.h"

#define STATIC

STATIC ULONG
HalpSortRanges (
    IN PSUPPORTED_RANGE     pRange1
    );

typedef struct tagNRParams {
    PIO_RESOURCE_DESCRIPTOR     InDesc;
    PIO_RESOURCE_DESCRIPTOR     OutDesc;
    PSUPPORTED_RANGE            CurrentPosition;
    LONGLONG                    Base;
    LONGLONG                    Limit;
    UCHAR                       DescOpt;
    BOOLEAN                     AnotherListPending;
} NRPARAMS, *PNRPARAMS;

STATIC PIO_RESOURCE_DESCRIPTOR
HalpGetNextSupportedRange (
    IN LONGLONG             MinimumAddress,
    IN LONGLONG             MaximumAddress,
    IN OUT PNRPARAMS        PNRParams
    );

//
// These following functions are usable at to initialize
// the supported_ranges information for a bus handler.
//    HalpMergeRanges           - merges two bus supported ranges
//    HalpMergeRangeList        - merges two single supported ranges lists
//    HalpCopyRanges            - copy a bus supported ranges to a new supported ranges structure
//    HalpAddRangeList          - adds a supported range list to another
//    HalpAddRange              - adds a single range to a supported range list
//    HalpRemoveRanges          - removes all ranges from one buses supported ranges from another
//    HalpRemoveRangeList       - removes all ranges in one supported range list from another
//    HalpRemoveRange           - removes a single range from a supported range list
//    HalpAllocateNewRangeList  - allocates a new, "blank" bus supported ranges structure
//    HalpFreeRangeList         - frees an entire bus supported ranges
//
//    HalpConsolidateRanges     - cleans up a supported ranges structure to be ready for usage
//
//
// These functions are used to intersect a buses supported ranges
// to an IO_RESOURCE_REQUIREMENTS_LIST:
//    HaliAdjustResourceListRange
//
// These functions are used internal to this module:
//    HalpSortRanges
//    HalpGetNextSupportedRange
//


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpMergeRanges)
#pragma alloc_text(INIT,HalpMergeRangeList)
#pragma alloc_text(INIT,HalpCopyRanges)
#pragma alloc_text(INIT,HalpAddRangeList)
#pragma alloc_text(INIT,HalpAddRange)
#pragma alloc_text(INIT,HalpRemoveRanges)
#pragma alloc_text(INIT,HalpRemoveRangeList)
#pragma alloc_text(INIT,HalpRemoveRange)
#pragma alloc_text(INIT,HalpConsolidateRanges)
#pragma alloc_text(PAGE,HalpAllocateNewRangeList)
#pragma alloc_text(PAGE,HalpFreeRangeList)
#pragma alloc_text(PAGE,HaliAdjustResourceListRange)
#pragma alloc_text(PAGE,HalpSortRanges)
#pragma alloc_text(PAGE,HalpGetNextSupportedRange)
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif
struct {
    ULONG       Offset;
} const HalpRangeList[] = {
    FIELD_OFFSET (SUPPORTED_RANGES, IO),
    FIELD_OFFSET (SUPPORTED_RANGES, Memory),
    FIELD_OFFSET (SUPPORTED_RANGES, PrefetchMemory),
    FIELD_OFFSET (SUPPORTED_RANGES, Dma),
    0,
    };
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif

#define RANGE_LIST(a,i) ((PSUPPORTED_RANGE) ((PUCHAR) a + HalpRangeList[i].Offset))


PSUPPORTED_RANGES
HalpMergeRanges (
    IN PSUPPORTED_RANGES    Parent,
    IN PSUPPORTED_RANGES    Child
    )
/*++
Routine Description:

    This function produces a NewList which is a subset of all overlapping
    ranges in Parent and Child for all range lists.

    The resulting SystemBaseAddresses and SystemAddressSpaces are taken
    from the Child supported ranges.

    Note: Resulting list needs consolidated

--*/
{
    PSUPPORTED_RANGES   NewList;
    PSUPPORTED_RANGES   List1;

    NewList = HalpAllocateNewRangeList();

    HalpMergeRangeList (&NewList->IO,     &Parent->IO,     &Child->IO);
    HalpMergeRangeList (&NewList->Dma,    &Parent->Dma,    &Child->Dma);
    HalpMergeRangeList (&NewList->Memory, &Parent->Memory, &Child->Memory);

    List1  = HalpAllocateNewRangeList();
    HalpAddRangeList (&List1->Memory, &Parent->Memory);
    HalpAddRangeList (&List1->Memory, &Parent->PrefetchMemory);
    HalpMergeRangeList (&NewList->PrefetchMemory, &List1->Memory, &Child->PrefetchMemory);
    HalpFreeRangeList (List1);

    return NewList;
}


VOID
HalpMergeRangeList (
    OUT PSUPPORTED_RANGE    NewList,
    IN PSUPPORTED_RANGE     Parent,
    IN PSUPPORTED_RANGE     Child
    )
/*++
Routine Description:

    Completes NewList to be a subset of all overlapping
    ranges in the Parent and Child list.

    The resulting SystemBaseAddresses and SystemAddressSpaces are
    taken from the Child supported ranges.

    Note: Resulting list needs consolidated

--*/
{
    BOOLEAN             HeadCompleted;
    PSUPPORTED_RANGE    List1, List2;
    LONGLONG            Base, Limit;

    HeadCompleted  = FALSE;

    for (List1 = Parent; List1; List1 = List1->Next) {
        for (List2 = Child; List2; List2 = List2->Next) {

            Base  = List1->Base;
            Limit = List1->Limit;

            //
            // Clip to range supported by List2
            //

            if (Base < List2->Base) {
                Base = List2->Base;
            }

            if (Limit > List2->Limit) {
                Limit = List2->Limit;
            }

            //
            // If valid range, add it
            //

            if (Base <= Limit) {
                if (HeadCompleted) {
                    NewList->Next = ExAllocatePoolWithTag (
                                        SPRANGEPOOL,
                                        sizeof (SUPPORTED_RANGE),
                                        HAL_POOL_TAG
                                        );
                    RtlZeroMemory (NewList->Next, sizeof (SUPPORTED_RANGE));
                    NewList = NewList->Next;
                    NewList->Next = NULL;
                }

                HeadCompleted  = TRUE;
                NewList->Base  = Base;
                NewList->Limit = Limit;
                NewList->SystemBase = List2->SystemBase;
                NewList->SystemAddressSpace = List2->SystemAddressSpace;
            }
        }
    }
}

PSUPPORTED_RANGES
HalpCopyRanges (
    PSUPPORTED_RANGES     Source
    )
/*++
Routine Description:

    Builds a copy of the Source list to the destination list.
    Note that an invalid entry lands at the begining of the copy, but
    that's OK - it will be pulled out at consolidation time.

    Note: Resulting list needs consolidated

--*/
{
    PSUPPORTED_RANGES   Dest;
    ULONG               i;

    Dest = HalpAllocateNewRangeList ();

    for (i=0; HalpRangeList[i].Offset; i++) {
        HalpAddRangeList (RANGE_LIST(Dest, i), RANGE_LIST(Source, i));
    }

    return Dest;
}

VOID
HalpAddRangeList (
    IN OUT PSUPPORTED_RANGE DRange,
    OUT PSUPPORTED_RANGE    SRange
    )
/*++
Routine Description:

    Adds ranges from SRange to DRange.

--*/
{
    while (SRange) {
        HalpAddRange (
            DRange,
            SRange->SystemAddressSpace,
            SRange->SystemBase,
            SRange->Base,
            SRange->Limit
            );

        SRange = SRange->Next;
    }
}


VOID
HalpAddRange (
    PSUPPORTED_RANGE    HRange,
    ULONG               AddressSpace,
    LONGLONG            SystemBase,
    LONGLONG            Base,
    LONGLONG            Limit
    )
/*++
Routine Description:

    Adds a range to the supported list.  Here we just add the range, if it's
    a duplicate it will be removed later at consolidation time.

--*/
{
    PSUPPORTED_RANGE  Range;

    Range = ExAllocatePoolWithTag (
                SPRANGEPOOL,
                sizeof (SUPPORTED_RANGE),
                HAL_POOL_TAG
                );
    RtlZeroMemory (Range, sizeof (SUPPORTED_RANGE));
    Range->Next  = HRange->Next;
    HRange->Next = Range;

    Range->Base = Base;
    Range->Limit = Limit;
    Range->SystemBase = SystemBase;
    Range->SystemAddressSpace = AddressSpace;
}

VOID
HalpRemoveRanges (
    IN OUT PSUPPORTED_RANGES    Minuend,
    IN PSUPPORTED_RANGES        Subtrahend
    )
/*++
Routine Description:

    Returns a list where all ranges from Subtrahend are removed from Minuend.

    Note: Resulting list needs consolidated

--*/
{

    HalpRemoveRangeList (&Minuend->IO,       &Subtrahend->IO);
    HalpRemoveRangeList (&Minuend->Dma,      &Subtrahend->Dma);
    HalpRemoveRangeList (&Minuend->Memory,   &Subtrahend->Memory);
    HalpRemoveRangeList (&Minuend->Memory,   &Subtrahend->PrefetchMemory);
    HalpRemoveRangeList (&Minuend->PrefetchMemory, &Subtrahend->PrefetchMemory);
    HalpRemoveRangeList (&Minuend->PrefetchMemory, &Subtrahend->Memory);
}

VOID
HalpRemoveRangeList (
    IN OUT PSUPPORTED_RANGE Minuend,
    IN PSUPPORTED_RANGE     Subtrahend
    )
/*++
Routine Description:

    Removes all ranges from Subtrahend from Minuend

    ranges in Source1 and Source1 list

--*/
{
    while (Subtrahend) {

        HalpRemoveRange (
            Minuend,
            Subtrahend->Base,
            Subtrahend->Limit
        );

        Subtrahend = Subtrahend->Next;
    }
}


VOID
HalpRemoveRange (
    PSUPPORTED_RANGE    HRange,
    LONGLONG            Base,
    LONGLONG            Limit
    )
/*++
Routine Description:

    Removes the range Base-Limit from the the HRange list

    Note: The returned list needs consolidated, as some entries
    may be turned into "null ranges".

--*/
{
    PSUPPORTED_RANGE    Range;

    //
    // If range isn't a range at all, then nothing to remove
    //

    if (Limit < Base) {
        return ;
    }


    //
    // Clip any area not to include this range
    //

    for (Range = HRange; Range; Range = Range->Next) {

        if (Range->Limit < Range->Base) {
            continue;
        }

        if (Range->Base < Base) {
            if (Range->Limit >= Base  &&  Range->Limit <= Limit) {
                // truncate
                Range->Limit = Base - 1;
            }

            if (Range->Limit > Limit) {

                //
                // Target area is contained totally within this area.
                // Split into two ranges
                //

                HalpAddRange (
                    HRange,
                    Range->SystemAddressSpace,
                    Range->SystemBase,
                    Limit + 1,
                    Range->Limit
                    );

                Range->Limit = Base - 1;

            }
        } else {
            // Range->Base >= Base
            if (Range->Base <= Limit) {
                if (Range->Limit <= Limit) {
                    //
                    // This range is totally within the target area.  Remove it.
                    // (make it invalid - it will get remove when colsolidated)
                    //

                    Range->Base  = 1;
                    Range->Limit = 0;

                } else {
                    // Bump begining
                    Range->Base = Limit + 1;
                }
            }
        }
    }
}

PSUPPORTED_RANGES
HalpConsolidateRanges (
    IN OUT PSUPPORTED_RANGES   Ranges
    )
/*++
Routine Description:

    Cleans the Range list.   Consolidates overlapping ranges, removes
    ranges which don't have any size, etc...

    The returned Ranges list is a clean as possible, and is now ready
    to be used.

--*/
{
    PSUPPORTED_RANGE    RangeList, List1, List2;
    LONGLONG            Base, Limit, SystemBase;
    ULONG               i, AddressSpace;
    LONGLONG            l;

    ASSERT (Ranges != NULL);

    for (i=0; HalpRangeList[i].Offset; i++) {
        RangeList = RANGE_LIST(Ranges, i);

        //
        // Sort the list by base address
        //

        for (List1 = RangeList; List1; List1 = List1->Next) {
            for (List2 = List1->Next; List2; List2 = List2->Next) {
                if (List2->Base < List1->Base) {
                    Base = List1->Base;
                    Limit = List1->Limit;
                    SystemBase = List1->SystemBase;
                    AddressSpace = List1->SystemAddressSpace;

                    List1->Base = List2->Base;
                    List1->Limit = List2->Limit;
                    List1->SystemBase = List2->SystemBase;
                    List1->SystemAddressSpace = List2->SystemAddressSpace;

                    List2->Base = Base;
                    List2->Limit = Limit;
                    List2->SystemBase = SystemBase;
                    List2->SystemAddressSpace = AddressSpace;
                }
            }
        }

        //
        // Check for adjacent/overlapping ranges and combined them
        //

        List1 = RangeList;
        while (List1  &&  List1->Next) {

            if (List1->Limit < List1->Base) {
                //
                // This range's limit is less then it's base.  This
                // entry doesn't reprent anything uasable, remove it.
                //

                List2 = List1->Next;

                List1->Next = List2->Next;
                List1->Base = List2->Base;
                List1->Limit = List2->Limit;
                List1->SystemBase = List2->SystemBase;
                List1->SystemAddressSpace = List2->SystemAddressSpace;

                ExFreePool (List2);
                continue;
            }

            l = List1->Limit + 1;
            if (l > List1->Limit  &&  l >= List1->Next->Base &&
                (List1->SystemBase == List1->Next->SystemBase)) {

                //
                // Overlapping.  Combine them.
                //

                List2 = List1->Next;
                List1->Next = List2->Next;
                if (List2->Limit > List1->Limit) {
                    List1->Limit = List2->Limit;
                    ASSERT (List1->SystemAddressSpace == List2->SystemAddressSpace);
                }

                ExFreePool (List2);
                continue ;
            }

            List1 = List1->Next;
        }

        //
        // If the last range is invalid, and it's not the only
        // thing in the list - remove it
        //

        if (List1 != RangeList  &&  List1->Limit < List1->Base) {
            for (List2=RangeList; List2->Next != List1; List2 = List2->Next) ;
            List2->Next = NULL;
            ExFreePool (List1);
        }
    }

    return Ranges;
}


PSUPPORTED_RANGES
HalpAllocateNewRangeList (
    VOID
    )
/*++

Routine Description:

    Allocates a range list

--*/
{
    PSUPPORTED_RANGES   RangeList;
    ULONG               i;

    PAGED_CODE();

    RangeList = (PSUPPORTED_RANGES) ExAllocatePoolWithTag (
                                        SPRANGEPOOL,
                                        sizeof (SUPPORTED_RANGES),
                                        HAL_POOL_TAG
                                        );
    RtlZeroMemory (RangeList, sizeof (SUPPORTED_RANGES));
    RangeList->Version = BUS_SUPPORTED_RANGE_VERSION;

    for (i=0; HalpRangeList[i].Offset; i++) {
        // Limit set to zero, set initial base to 1
        RANGE_LIST(RangeList, i)->Base = 1;
    }
    return RangeList;
}


VOID
HalpFreeRangeList (
    PSUPPORTED_RANGES   Ranges
    )
/*++

Routine Description:

    Frees a range list which was allocated via HalpAllocateNewRangeList, and
    extended / modified via the generic support functions.


--*/
{
    PSUPPORTED_RANGE    Entry, NextEntry;
    ULONG               i;

    PAGED_CODE();

    for (i=0; HalpRangeList[i].Offset; i++) {
        Entry = RANGE_LIST(Ranges, i)->Next;

        while (Entry) {
            NextEntry = Entry->Next;
            ExFreePool (Entry);
            Entry = NextEntry;
        }
    }

    ExFreePool (Ranges);
}


#if DBG
STATIC VOID
HalpDisplayAddressRange (
    PSUPPORTED_RANGE    Address,
    PUCHAR              String
    )
/*++

Routine Description:

    Debugging code.  Used only by HalpDisplayAllBusRanges

--*/
{
    ULONG       i;

    i = 0;
    while (Address) {
        if (i == 0) {
            DbgPrint (String);
            i = 3;
        }

        i -= 1;
        DbgPrint (" %x:%08x - %x:%08x ",
            (ULONG) (Address->Base >> 32),
            (ULONG) (Address->Base),
            (ULONG) (Address->Limit >> 32),
            (ULONG) (Address->Limit)
            );

        Address = Address->Next;
    }
}

VOID
HalpDisplayAllBusRanges (
    VOID
    )
/*++

Routine Description:

    Debugging code.  Displays the current supported range information
    for all the registered buses in the system.

--*/
{
    PSUPPORTED_RANGES   Addresses;
    PBUS_HANDLER        Bus;
    PUCHAR              p;
    ULONG               i, j;

    DbgPrint ("\nHAL - dumping all supported bus ranges");

    for (i=0; i < MaximumInterfaceType; i++) {
        for (j=0; Bus = HaliHandlerForBus (i, j); j++) {
            Addresses = Bus->BusAddresses;
            if (Addresses) {
                p = NULL;
                switch (Bus->InterfaceType) {
                    case Internal:  p = "Internal";     break;
                    case Isa:       p = "Isa";          break;
                    case Eisa:      p = "Eisa";         break;
                    case PCIBus:    p = "PCI";          break;
                }
                if (p) {
                    DbgPrint ("\n%s %d", p, Bus->BusNumber);
                } else {
                    DbgPrint ("\nBus-%d %d", Bus->InterfaceType, Bus->BusNumber);
                }
                HalpDisplayAddressRange (&Addresses->IO,            "\n  IO......:");
                HalpDisplayAddressRange (&Addresses->Memory,        "\n  Memory..:");
                HalpDisplayAddressRange (&Addresses->PrefetchMemory,"\n  PFMemory:");
                HalpDisplayAddressRange (&Addresses->Dma,           "\n  Dma.....:");
                DbgPrint ("\n");
            }
        }
    }
}
#endif

NTSTATUS
HaliAdjustResourceListRange (
    IN PSUPPORTED_RANGES                    SRanges,
    IN PSUPPORTED_RANGE                     InterruptRange,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    )
/*++

Routine Description:

    This functions takes an IO_RESOURCE_REQUIREMENT_LIST and
    adjusts it such that all ranges in the list fit in the
    ranges specified by SRanges & InterruptRange.

    This function is used by some HALs to clip the possible
    settings to be contained on what the particular bus supports
    in reponse to a HalAdjustResourceList call.

Arguments:

    SRanges         - Valid IO, Memory, Prefetch Memory, and DMA ranges.
    InterruptRange  - Valid InterruptRanges

    pResourceList   - The resource requirements list which needs to
                      be adjusted to only contain the ranges as
                      described by SRanges & InterruptRange.

Return Value:

    STATUS_SUCCESS or an appropiate error return.

--*/
{
    PIO_RESOURCE_REQUIREMENTS_LIST  InCompleteList, OutCompleteList;
    PIO_RESOURCE_LIST               InResourceList, OutResourceList;
    PIO_RESOURCE_DESCRIPTOR         HeadOutDesc, SetDesc;
    NRPARAMS                        Pos;
    ULONG                           len, alt, cnt, i;
    ULONG                           icnt;

    PAGED_CODE();

    //
    // Sanity check
    //

    if (!SRanges  ||  SRanges->Version != BUS_SUPPORTED_RANGE_VERSION) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // If SupportedRanges aren't sorted, sort them and get the
    // number of ranges for each type
    //

    if (!SRanges->Sorted) {
        SRanges->NoIO = HalpSortRanges (&SRanges->IO);
        SRanges->NoMemory = HalpSortRanges (&SRanges->Memory);
        SRanges->NoPrefetchMemory = HalpSortRanges (&SRanges->PrefetchMemory);
        SRanges->NoDma = HalpSortRanges (&SRanges->Dma);
        SRanges->Sorted = TRUE;
    }

    icnt = HalpSortRanges (InterruptRange);

    InCompleteList = *pResourceList;
    len = InCompleteList->ListSize;

    //
    // Scan input list - verify revision #'s, and increase len varible
    // by amount output list may increase.
    //

    i = 1;
    InResourceList = InCompleteList->List;
    for (alt=0; alt < InCompleteList->AlternativeLists; alt++) {
        if (InResourceList->Version != 1 || InResourceList->Revision < 1) {
            return STATUS_INVALID_PARAMETER;
        }

        Pos.InDesc  = InResourceList->Descriptors;
        for (cnt = InResourceList->Count; cnt; cnt--) {
            switch (Pos.InDesc->Type) {
                case CmResourceTypeInterrupt:  i += icnt;           break;
                case CmResourceTypePort:       i += SRanges->NoIO;  break;
                case CmResourceTypeDma:        i += SRanges->NoDma; break;

                case CmResourceTypeMemory:
                    i += SRanges->NoMemory;
                    if (Pos.InDesc->Flags & CM_RESOURCE_MEMORY_PREFETCHABLE) {
                        i += SRanges->NoPrefetchMemory;
                    }
                    break;

                default:
                    return STATUS_INVALID_PARAMETER;
            }

            // take one off for the original which is already accounted for in 'len'
            i -= 1;

            // Next descriptor
            Pos.InDesc++;
        }

        // Next Resource List
        InResourceList  = (PIO_RESOURCE_LIST) Pos.InDesc;
    }
    len += i * sizeof (IO_RESOURCE_DESCRIPTOR);

    //
    // Allocate output list
    //

    OutCompleteList = (PIO_RESOURCE_REQUIREMENTS_LIST)
                            ExAllocatePoolWithTag (PagedPool,
                                                   len,
                                                   ' laH');

    if (!OutCompleteList) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory (OutCompleteList, len);

    //
    // Walk each ResourceList and build output structure
    //

    InResourceList   = InCompleteList->List;
    *OutCompleteList = *InCompleteList;
    OutResourceList  = OutCompleteList->List;

    for (alt=0; alt < InCompleteList->AlternativeLists; alt++) {
        OutResourceList->Version  = 1;
        OutResourceList->Revision = 1;

        Pos.InDesc  = InResourceList->Descriptors;
        Pos.OutDesc = OutResourceList->Descriptors;
        HeadOutDesc = Pos.OutDesc;

        for (cnt = InResourceList->Count; cnt; cnt--) {

            //
            // Limit desctiptor to be with the buses supported ranges
            //

            Pos.DescOpt = Pos.InDesc->Option;
            Pos.AnotherListPending = FALSE;

            switch (Pos.InDesc->Type) {
                case CmResourceTypePort:

                    //
                    // Get supported IO ranges
                    //

                    Pos.CurrentPosition = &SRanges->IO;
                    do {
                        SetDesc = HalpGetNextSupportedRange (
                                    Pos.InDesc->u.Port.MinimumAddress.QuadPart,
                                    Pos.InDesc->u.Port.MaximumAddress.QuadPart,
                                    &Pos
                                    );

                        if (SetDesc) {
                            SetDesc->u.Port.MinimumAddress.QuadPart = Pos.Base;
                            SetDesc->u.Port.MaximumAddress.QuadPart = Pos.Limit;
                        }

                    } while (SetDesc) ;
                    break;

                case CmResourceTypeInterrupt:
                    //
                    // Get supported Interrupt ranges
                    //

                    Pos.CurrentPosition = InterruptRange;
                    do {
                        SetDesc = HalpGetNextSupportedRange (
                                    Pos.InDesc->u.Interrupt.MinimumVector,
                                    Pos.InDesc->u.Interrupt.MaximumVector,
                                    &Pos
                                    );

                        if (SetDesc) {
                            SetDesc->u.Interrupt.MinimumVector = (ULONG) Pos.Base;
                            SetDesc->u.Interrupt.MaximumVector = (ULONG) Pos.Limit;
                        }
                    } while (SetDesc) ;
                    break;

                case CmResourceTypeMemory:
                    //
                    // Get supported memory ranges
                    //

                    if (Pos.InDesc->Flags & CM_RESOURCE_MEMORY_PREFETCHABLE) {

                        //
                        // This is a Prefetchable range.
                        // First add in any supported prefetchable ranges, then
                        // add in any regualer supported ranges
                        //

                        Pos.AnotherListPending = TRUE;
                        Pos.CurrentPosition = &SRanges->PrefetchMemory;

                        do {
                            SetDesc = HalpGetNextSupportedRange (
                                        Pos.InDesc->u.Memory.MinimumAddress.QuadPart,
                                        Pos.InDesc->u.Memory.MaximumAddress.QuadPart,
                                        &Pos
                                        );

                            if (SetDesc) {
                                SetDesc->u.Memory.MinimumAddress.QuadPart = Pos.Base;
                                SetDesc->u.Memory.MaximumAddress.QuadPart = Pos.Limit;
                                SetDesc->Option |= IO_RESOURCE_PREFERRED;
                            }
                        } while (SetDesc) ;

                        Pos.AnotherListPending = FALSE;
                    }

                    //
                    // Add in supported bus memory ranges
                    //

                    Pos.CurrentPosition = &SRanges->Memory;
                    do {
                        SetDesc = HalpGetNextSupportedRange (
                                        Pos.InDesc->u.Memory.MinimumAddress.QuadPart,
                                        Pos.InDesc->u.Memory.MaximumAddress.QuadPart,
                                        &Pos
                                        );
                        if (SetDesc) {
                            SetDesc->u.Memory.MinimumAddress.QuadPart = Pos.Base;
                            SetDesc->u.Memory.MaximumAddress.QuadPart = Pos.Limit;
                        }
                    } while (SetDesc);
                    break;

                case CmResourceTypeDma:
                    //
                    // Get supported DMA ranges
                    //

                    Pos.CurrentPosition = &SRanges->Dma;
                    do {
                        SetDesc = HalpGetNextSupportedRange (
                                    Pos.InDesc->u.Dma.MinimumChannel,
                                    Pos.InDesc->u.Dma.MaximumChannel,
                                    &Pos
                                    );

                        if (SetDesc) {
                            SetDesc->u.Dma.MinimumChannel = (ULONG) Pos.Base;
                            SetDesc->u.Dma.MaximumChannel = (ULONG) Pos.Limit;
                        }
                    } while (SetDesc) ;
                    break;

#if DBG
                default:
                    DbgPrint ("HalAdjustResourceList: Unkown resource type\n");
                    break;
#endif
            }

            //
            // Next descriptor
            //

            Pos.InDesc++;
        }

        OutResourceList->Count = (ULONG)(Pos.OutDesc - HeadOutDesc);

        //
        // Next Resource List
        //

        InResourceList  = (PIO_RESOURCE_LIST) Pos.InDesc;
        OutResourceList = (PIO_RESOURCE_LIST) Pos.OutDesc;
    }

    //
    // Free input list, and return output list
    //

    ExFreePool (InCompleteList);

    OutCompleteList->ListSize = (ULONG) ((PUCHAR) OutResourceList - (PUCHAR) OutCompleteList);
    *pResourceList = OutCompleteList;
    return STATUS_SUCCESS;
}


STATIC PIO_RESOURCE_DESCRIPTOR
HalpGetNextSupportedRange (
    IN LONGLONG             MinimumAddress,
    IN LONGLONG             MaximumAddress,
    IN OUT PNRPARAMS        Pos
    )
/*++

Routine Description:

    Support function for HaliAdjustResourceListRange.
    Returns the next supported range in the area passed in.

Arguments:

    MinimumAddress
    MaximumAddress  - Min & Max address of a range which needs
                      to be clipped to match that of the supported
                      ranges of the current bus.

    Pos             - describes the current postion

Return Value:

    NULL is no more returned ranges

    Otherwise, the IO_RESOURCE_DESCRIPTOR which needs to be set
    with the matching range returned in Pos.

--*/
{
    LONGLONG        Base, Limit;

    //
    // Find next range which is supported
    //

    Base  = MinimumAddress;
    Limit = MaximumAddress;

    while (Pos->CurrentPosition) {
        Pos->Base  = Base;
        Pos->Limit = Limit;

        //
        // Clip to current range
        //

        if (Pos->Base < Pos->CurrentPosition->Base) {
            Pos->Base = Pos->CurrentPosition->Base;
        }

        if (Pos->Limit > Pos->CurrentPosition->Limit) {
            Pos->Limit = Pos->CurrentPosition->Limit;
        }

        //
        // set position to next range
        //

        Pos->CurrentPosition = Pos->CurrentPosition->Next;

        //
        // If valid range, return it
        //

        if (Pos->Base <= Pos->Limit) {
            *Pos->OutDesc = *Pos->InDesc;
            Pos->OutDesc->Option = Pos->DescOpt;

            //
            // next descriptor (if any) is an alternative
            // to the descriptor being returned now
            //

            Pos->OutDesc += 1;
            Pos->DescOpt |= IO_RESOURCE_ALTERNATIVE;
            return Pos->OutDesc - 1;
        }
    }


    //
    // There's no overlapping range.  If this descriptor is
    // not an alternative and this descriptor is not going to
    // be processed by another range list, then return
    // a descriptor which can't be satisified.
    //

    if (!(Pos->DescOpt & IO_RESOURCE_ALTERNATIVE) &&
        Pos->AnotherListPending == FALSE) {
#if DBG
        DbgPrint ("HAL: returning impossible range\n");
#endif
        Pos->Base  = MinimumAddress;
        Pos->Limit = Pos->Base - 1;
        if (Pos->Base == 0) {       // if wrapped, fix it
            Pos->Base  = 1;
            Pos->Limit = 0;
        }

        *Pos->OutDesc = *Pos->InDesc;
        Pos->OutDesc->Option = Pos->DescOpt;

        Pos->OutDesc += 1;
        Pos->DescOpt |= IO_RESOURCE_ALTERNATIVE;
        return Pos->OutDesc - 1;
    }

    //
    // No range found (or no more ranges)
    //

    return NULL;
}

STATIC ULONG
HalpSortRanges (
    IN PSUPPORTED_RANGE     RangeList
    )
/*++

Routine Description:

    Support function for HaliAdjustResourceListRange.
    Sorts a supported range list into decending order.

Arguments:

    pRange  - List to sort

Return Value:

--*/
{
    ULONG               cnt;
    LONGLONG            hldBase, hldLimit, hldSystemBase;
    PSUPPORTED_RANGE    Range1, Range2;

    PAGED_CODE();

    //
    // Sort it
    //

    for (Range1 = RangeList; Range1; Range1 = Range1->Next) {
        for (Range2 = Range1->Next; Range2; Range2 = Range2->Next) {

            if (Range2->Base > Range1->Base) {
                hldBase  = Range1->Base;
                hldLimit = Range1->Limit;
                hldSystemBase = Range1->SystemBase;

                Range1->Base  = Range2->Base;
                Range1->Limit = Range2->Limit;
                Range1->SystemBase = Range2->SystemBase;

                Range2->Base  = hldBase;
                Range2->Limit = hldLimit;
                Range2->SystemBase = hldSystemBase;
            }
        }
    }

    //
    // Count the number of ranges
    //

    cnt = 0;
    for (Range1 = RangeList; Range1; Range1 = Range1->Next) {
        cnt += 1;
    }

    return cnt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\drivesup.c ===
#include "..\drivesup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\chiphacks.c ===
//
// This file simply includes the common sources from the current HAL
// directory.
//

#include "..\chiphacks.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\acpidtct.c ===
//
// This file simply includes the common sources from the current HAL
// directory. When the structure is finally changed, the real file should
// be in this directory.
//

#include "..\acpidtct.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\halp.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\halp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\cmosopregion.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixcmos.c

Abstract:

    Implements CMOS op region interface functionality
    
Author:

    brian guarraci (t-briang) 07-14-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "exboosts.h"
#include "wchar.h"
#include "xxacpi.h"

#ifdef ACPI_CMOS_ACTIVATE

//
// prototypes for the 2 HalpGet/Set ixcmos.asm functions
//
ULONG
HalpGetCmosData(
    IN ULONG        SourceLocation,
    IN ULONG        SourceAddress,
    IN PUCHAR       DataBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpSetCmosData(
    IN ULONG        SourceLocation,
    IN ULONG        SourceAddress,
    IN PUCHAR       DataBuffer,
    IN ULONG        ByteCount
    );
   


ULONG 
HalpcGetCmosDataByType(
    IN CMOS_DEVICE_TYPE CmosType,
    IN ULONG            SourceAddress,
    IN PUCHAR           DataBuffer,
    IN ULONG            ByteCount
    );

ULONG 
HalpcSetCmosDataByType(
    IN CMOS_DEVICE_TYPE CmosType,
    IN ULONG            SourceAddress,
    IN PUCHAR           DataBuffer,
    IN ULONG            ByteCount
    );

ULONG
HalpReadCmosDataByPort(
    IN ULONG        AddrPort,
    IN ULONG        DataPort,
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpWriteCmosDataByPort(
    IN ULONG        AddrPort,
    IN ULONG        DataPort,
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpReadCmosData(
    IN ULONG    SourceLocation,
    IN ULONG    SourceAddress,
    IN ULONG    ReturnBuffer,
    IN PUCHAR   ByteCount
    );

ULONG
HalpWriteCmosData(
    IN ULONG    SourceLocation,
    IN ULONG    SourceAddress,
    IN ULONG    ReturnBuffer,
    IN PUCHAR   ByteCount
    );

ULONG
HalpReadStdCmosData(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpWriteStdCmosData(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpReadRtcStdPCAT(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpWriteRtcStdPCAT(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpReadRtcIntelPIIX4(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpWriteRtcIntelPIIX4(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpReadExtCmosIntelPIIX4(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpWriteExtCmosIntelPIIX4(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpReadRtcDal1501(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpWriteRtcDal1501(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpReadExtCmosDal1501(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

ULONG
HalpWriteExtCmosDal1501(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );


//
// at the time of this writing, the largest known cmos ram address is 0xff
// that is, for a given cmos ram bank, the largest address is 0xff
//                     
typedef enum {
    LARGEST_KNOWN_CMOS_RAM_ADDRESS = 0xff
} CMOS_RAM_ADDR_LIMITS;


//
// Additional information about Standard CMOS/RTC can be acquired at:
//
// "ISA System Architecture" Mindshare, Inc. (ISBN:0-201-40996-8) Chaper 21.
//
// To put the registers and the RTC region in context, the following 
// constants describe the layout of the registers (0x00 - 0x0d).  
// Registers A-D are control registers which affect the state of the rtc.  
//                            
typedef enum {
    CMOS_RAM_STDPCAT_SECONDS = 0,
    CMOS_RAM_STDPCAT_SECONDS_ALARM,
    CMOS_RAM_STDPCAT_MINUTES,
    CMOS_RAM_STDPCAT_MINUTES_ALARM,
    CMOS_RAM_STDPCAT_HOURS,
    CMOS_RAM_STDPCAT_HOURS_ALARM,
    CMOS_RAM_STDPCAT_DAY_OF_WEEK,
    CMOS_RAM_STDPCAT_DATE_OF_MONTH,
    CMOS_RAM_STDPCAT_MONTH,
    CMOS_RAM_STDPCAT_YEAR,
    CMOS_RAM_STDPCAT_REGISTER_A,
    CMOS_RAM_STDPCAT_REGISTER_B,
    CMOS_RAM_STDPCAT_REGISTER_C,
    CMOS_RAM_STDPCAT_REGISTER_D
} CMOS_RAM_STDPCAT_REGISTERS;

//
// definition of bits with in the control registers
//
typedef enum {

    //
    // (Update In Progress)
    // when the rtc is updating the rtc registers, this bit is set
    //
    //
    CMOS_RAM_STDPCAT_REGISTER_A_UIP_BIT = 0x80,

    //
    // this bit must be set when updating the rtc
    //
    CMOS_RAM_STDPCAT_REGISTER_B_SET_BIT = 0x80

} CMOS_RAM_STDPCAT_REGISTER_BITS;


//
// Additional information about the Intel PIIX4 cmos/rtc chip
// can be acquired at: 
//
// http://developer.intel.com/design/intarch/DATASHTS/29056201.pdf
//
// To put the registers and the RTC region in context, the following 
// constants describe the layout of the 
//
//  Intel PIIX4 CMOS ram
// 
// for the 0x00 - 0x0d registers.  Registers A-D are control registers
// which affect the state of the rtc.  
// 
//   
//                            
typedef enum {
    CMOS_RAM_PIIX4_SECONDS = 0,
    CMOS_RAM_PIIX4_SECONDS_ALARM,
    CMOS_RAM_PIIX4_MINUTES,
    CMOS_RAM_PIIX4_MINUTES_ALARM,
    CMOS_RAM_PIIX4_HOURS,
    CMOS_RAM_PIIX4_HOURS_ALARM,
    CMOS_RAM_PIIX4_DAY_OF_WEEK,
    CMOS_RAM_PIIX4_DATE_OF_MONTH,
    CMOS_RAM_PIIX4_MONTH,
    CMOS_RAM_PIIX4_YEAR,
    CMOS_RAM_PIIX4_REGISTER_A,
    CMOS_RAM_PIIX4_REGISTER_B,
    CMOS_RAM_PIIX4_REGISTER_C,
    CMOS_RAM_PIIX4_REGISTER_D
} CMOS_RAM_PIIX4_REGISTERS;

//
// definition of bits with in the control registers
//
typedef enum {

    //
    // (Update In Progress)
    // when the rtc is updating the rtc registers, this bit is set
    //
    //
    CMOS_RAM_PIIX4_REGISTER_A_UIP_BIT = 0x80,

    //
    // this bit must be set when updating the rtc
    //
    CMOS_RAM_PIIX4_REGISTER_B_SET_BIT = 0x80

} CMOS_RAM_PIIX4_REGISTER_BITS;


//
// Additional information about the Dallas 1501 cmos/rtc chip
// can be acquired at: 
//
// http://www.dalsemi.com/datasheets/pdfs/1501-11.pdf
//
// To put the registers and the RTC region in context, the following 
// constants describe the layout of the 
//
//  Dallas 1501 CMOS ram
// 
// for the 0x00 - 0x0d registers.  Registers A-D are control registers
// which affect the state of the rtc.  
// 
//   
//                            
typedef enum {
    CMOS_RAM_DAL1501_SECONDS = 0,
    CMOS_RAM_DAL1501_MINUTES,
    CMOS_RAM_DAL1501_HOURS,
    CMOS_RAM_DAL1501_DAY,
    CMOS_RAM_DAL1501_DATE,
    CMOS_RAM_DAL1501_MONTH,
    CMOS_RAM_DAL1501_YEAR,
    CMOS_RAM_DAL1501_CENTURY,
    CMOS_RAM_DAL1501_ALARM_SECONDS,
    CMOS_RAM_DAL1501_ALARM_MINUTES,
    CMOS_RAM_DAL1501_ALARM_HOURS,
    CMOS_RAM_DAL1501_ALARM_DAYDATE,
    CMOS_RAM_DAL1501_WATCHDOG0,
    CMOS_RAM_DAL1501_WATCHDOG1,
    CMOS_RAM_DAL1501_REGISTER_A,
    CMOS_RAM_DAL1501_REGISTER_B,
    CMOS_RAM_DAL1501_RAM_ADDR_LSB,  // 0x00 - 0xff
    CMOS_RAM_DAL1501_RESERVED0,
    CMOS_RAM_DAL1501_RESERVED1,
    CMOS_RAM_DAL1501_RAM_DATA       // 0x00 - 0xff
} CMOS_RAM_DAL1501_REGISTERS;

typedef enum {

    //
    // The TE bit controls the update status of the external
    // RTC registers.  When it is 0, the registers are frozen
    // with the last RTC values.  If you modifiy the registers
    // while TE = 0, then when TE is set, the modifications
    // will transfer to the internal registers, hence modifying 
    // the RTC state.  In general, when TE is set, the external
    // registers then reflect the current RTC state.
    //
    CMOS_RAM_DAL1501_REGISTER_B_TE_BIT = 0x80


} CMOS_RAM_DAL1501_REGISTER_BITS;


#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MIN(a, b) ((a) < (b) ? (a) : (b))

typedef enum {
    CmosStdAddrPort = 0x70,
    CmosStdDataPort = 0x71
};

typedef enum {
    CMOS_READ,
    CMOS_WRITE
} CMOS_ACCESS_TYPE;

typedef 
ULONG 
(*PCMOS_RANGE_HANDLER) (
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    );

typedef struct {
    ULONG               start;
    ULONG               stop;
    PCMOS_RANGE_HANDLER readHandler;
    PCMOS_RANGE_HANDLER writeHandler;
} CMOS_ADDR_RANGE_HANDLER, *PCMOS_ADDR_RANGE_HANDLER;


//
// define the discrete ranges so that the appropriate
// handlers can be used for each.
//
// Note: address ranges are inclusive
//
CMOS_ADDR_RANGE_HANDLER CmosRangeHandlersStdPCAT[] =
{   
    //
    // The RTC region
    //
    {0,     0x9,    HalpReadRtcStdPCAT,     HalpWriteRtcStdPCAT},       


    //
    // The standard CMOS RAM region
    //
    {0x0a,  0x3f,   HalpReadStdCmosData,    HalpWriteStdCmosData},     

    //
    // end of table
    //
    {0,     0,      0}
};

CMOS_ADDR_RANGE_HANDLER CmosRangeHandlersIntelPIIX4[] =
{   
    //
    // The RTC region
    //
    {0,     0x9,    HalpReadRtcIntelPIIX4,      HalpWriteRtcIntelPIIX4},

    //
    // The standard CMOS RAM region
    //
    {0x0a,  0x7f,   HalpReadStdCmosData,        HalpWriteStdCmosData},

    //
    // The extended CMOS SRAM region
    //
    {0x80,  0xff,   HalpReadExtCmosIntelPIIX4,  HalpWriteExtCmosIntelPIIX4},

    //
    // end of table
    //
    {0,     0,      0}
};

CMOS_ADDR_RANGE_HANDLER CmosRangeHandlersDal1501[] =
{   

    //
    // The RTC region
    //
    {0,     0x0b,    HalpReadRtcDal1501,         HalpWriteRtcDal1501},

    //
    // The standard CMOS RAM region
    //
    {0x0c,  0x0f,   HalpReadStdCmosData,        HalpWriteStdCmosData},
    
    //
    // NOTE: this table skips the standard CMOS range: 0x10 - 0x1f
    // because this area is reserved in the spec, and the is no
    // apparent reason why the op region should access this area.
    // Also, regs 0x10 and 0x13 are used to access the extended 
    // ram, hence there is no reason why the op region should access
    // this either.  Hence, all op region access beyond 0x0f are
    // interpretted as accesses into the Extended CMOS
    //

    //
    // The extended CMOS SRAM region
    //
    {0x10,  0x10f,  HalpReadExtCmosDal1501,     HalpWriteExtCmosDal1501},

    //
    // end of table
    //
    {0,     0,      0}
};


ULONG 
HalpCmosRangeHandler(
    IN CMOS_ACCESS_TYPE AccessType,
    IN CMOS_DEVICE_TYPE CmosType,
    IN ULONG            Address,
    IN PUCHAR           DataBuffer,
    IN ULONG            ByteCount
    )
{
    ULONG   bytes;          // bytes read in last operation
    ULONG   offset;         // the offset beyond the initial address
    ULONG   bufOffset;      // the index into the data buffer as we read in data
    ULONG   extAddr;        // the corrected address for accessing extended SRAM
    ULONG   range;          // the current address range we are checking for
    ULONG   bytesRead;      // total bytes successfully read
    ULONG   length;         // the length of the current operation read

    PCMOS_ADDR_RANGE_HANDLER rangeHandlers;   // the table we are using

    //
    // get the appropriate table
    //
    switch (CmosType) {
    case CmosTypeStdPCAT:       

        rangeHandlers = CmosRangeHandlersStdPCAT;   
        break;

    case CmosTypeIntelPIIX4:    

        rangeHandlers = CmosRangeHandlersIntelPIIX4;
        break;

    case CmosTypeDal1501:       

        rangeHandlers = CmosRangeHandlersDal1501;   
        break;

    default:
        break;
    }

    bytesRead   = 0;
    bufOffset   = 0;
    range       = 0;
    offset      = Address;
    length      = ByteCount;

    while (rangeHandlers[range].stop) {

        if (offset <= rangeHandlers[range].stop) {

            //
            // get the # of bytes to read in this region
            //
            // length = MIN(remaining # bytes remaining to read, # bytes to read in the current range)
            //
            length = MIN((ByteCount - bytesRead), (rangeHandlers[range].stop - offset + 1));

            //
            // Since the handler routines are only called from here, we can consolidate
            // the ASSERTIONS.  This is also nice, because we know which range in the
            // table we are dealing with, hence we know what the limits should be.
            //    
            // make sure both the offset into the range, 
            // and the operation's length are in bounds
            // 
            ASSERT(offset <= rangeHandlers[range].stop);
            ASSERT((offset + length) <= (rangeHandlers[range].stop + 1));


            switch (AccessType) {
            
            case CMOS_READ:
                bytes = (rangeHandlers[range].readHandler)(
                                                          offset,
                                                          &DataBuffer[bufOffset],
                                                          length);
                break;

            case CMOS_WRITE:
                bytes = (rangeHandlers[range].writeHandler)(
                                                           offset,
                                                           &DataBuffer[bufOffset],
                                                           length);
                break;

            default:
                break;
            }

            ASSERT(bytes == length);

            bytesRead += bytes;

            //
            // adjust offset based on the length of the last operation
            //
            offset += length;
            bufOffset += length;
        }

        //
        // if offset is at or beyond specified range, then we are done
        //
        if (offset >= (Address + ByteCount)) {
            break;
        }

        //
        // move to the next range
        //
        range++;
    }

    ASSERT(bytesRead == ByteCount);

    return bytesRead;
}

ULONG 
HalpcGetCmosDataByType(
    IN CMOS_DEVICE_TYPE CmosType,
    IN ULONG            Address,
    IN PUCHAR           DataBuffer,
    IN ULONG            ByteCount
    )
{
    return HalpCmosRangeHandler(
                               CMOS_READ,
                               CmosType,
                               Address,
                               DataBuffer,
                               ByteCount
                               );
}

ULONG 
HalpcSetCmosDataByType(
    IN CMOS_DEVICE_TYPE CmosType,
    IN ULONG            Address,
    IN PUCHAR           DataBuffer,
    IN ULONG            ByteCount
    )
{
    return HalpCmosRangeHandler(
                               CMOS_WRITE,
                               CmosType,
                               Address,
                               DataBuffer,
                               ByteCount
                               );
}


ULONG
HalpReadCmosDataByPort(
    IN ULONG        AddrPort,
    IN ULONG        DataPort,
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine reads the requested number of bytes from CMOS using the 
       specified ports and stores the data read into the supplied buffer in 
       system memory.  If the requested data amount exceeds the allowable 
       extent of the source location, the return data is truncated.

    Arguments:

       AddrPort        : address in the ISA I/O space to put the address

       DataPort        : address in the ISA I/O space to put the data

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

    Note:

       This routine doesn't perform safety precautions when operating
       in the RTC region of the CMOS.  Use the appropriate RTC routine
       instead.

--*/
{
    ULONG   offset;
    ULONG   bufOffset;
    ULONG   upperAddrBound;

    upperAddrBound = SourceAddress + ByteCount;

    ASSERT(SourceAddress <= LARGEST_KNOWN_CMOS_RAM_ADDRESS);
    ASSERT(upperAddrBound <= (LARGEST_KNOWN_CMOS_RAM_ADDRESS + 1));

    //
    // NOTE: The spinlock is needed even in the UP case, because
    //    the resource is also used in an interrupt handler (profiler).
    //    If we own the spinlock in this routine, and we service
    //    the profiler interrupt (which will wait for the spinlock forever),
    //    then we have a hosed system.
    //
    HalpAcquireCmosSpinLock();

    for (offset = SourceAddress, bufOffset = 0; offset < upperAddrBound; offset++, bufOffset++) {

        WRITE_PORT_UCHAR((PUCHAR)AddrPort, (UCHAR)offset);

        ReturnBuffer[bufOffset] = READ_PORT_UCHAR((PUCHAR)DataPort);

    }

    HalpReleaseCmosSpinLock();

    return bufOffset; 
}

ULONG
HalpWriteCmosDataByPort(
    IN ULONG        AddrPort,
    IN ULONG        DataPort,
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine reads the requested number of bytes from CMOS using the 
       specified ports and stores the data read into the supplied buffer in 
       system memory.  If the requested data amount exceeds the allowable 
       extent of the source location, the return data is truncated.

    Arguments:

       AddrPort        : address in the ISA I/O space to put the address

       DataPort        : address in the ISA I/O space to put the data

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

    Note:

       This routine doesn't perform safety precautions when operating
       in the RTC region of the CMOS.  Use the appropriate RTC routine
       instead.

--*/
{
    ULONG   offset;
    ULONG   bufOffset;
    ULONG   upperAddrBound;

    upperAddrBound = SourceAddress + ByteCount;

    ASSERT(SourceAddress <= LARGEST_KNOWN_CMOS_RAM_ADDRESS);
    ASSERT(upperAddrBound <= (LARGEST_KNOWN_CMOS_RAM_ADDRESS + 1));

    //
    // NOTE: The spinlock is needed even in the UP case, because
    //    the resource is also used in an interrupt handler (profiler).
    //    If we own the spinlock in this routine, and we service
    //    the profiler interrupt (which will wait for the spinlock forever),
    //    then we have a hosed system.
    //
    HalpAcquireCmosSpinLock();

    for (offset = SourceAddress, bufOffset = 0; offset < upperAddrBound; offset++, bufOffset++) {

        WRITE_PORT_UCHAR((PUCHAR)AddrPort, (UCHAR)offset);
        WRITE_PORT_UCHAR((PUCHAR)DataPort, (UCHAR)(ReturnBuffer[bufOffset]));

    }

    HalpReleaseCmosSpinLock();

    return bufOffset; 
}


ULONG
HalpReadStdCmosData(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
{
    return HalpReadCmosDataByPort(
                                 CmosStdAddrPort,
                                 CmosStdDataPort,
                                 SourceAddress,
                                 ReturnBuffer,
                                 ByteCount
                                 );
}

ULONG
HalpWriteStdCmosData(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
{
    return HalpWriteCmosDataByPort(
                                  CmosStdAddrPort,
                                  CmosStdDataPort,
                                  SourceAddress,
                                  ReturnBuffer,
                                  ByteCount
                                  );
}


ULONG
HalpReadRtcStdPCAT(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine handles reads into the standard PC/AT RTC range.

    Arguments:

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

--*/
{
    ULONG   offset;
    ULONG   bufOffset;
    ULONG   status;     // register status
    ULONG   uip;        // update in progress bit
    ULONG   upperAddrBound;

    upperAddrBound = SourceAddress + ByteCount;

    //
    // NOTE: The spinlock is needed even in the UP case, because
    //    the resource is also used in an interrupt handler (profiler).
    //    If we own the spinlock in this routine, and we service
    //    the profiler interrupt (which will wait for the spinlock forever),
    //    then we have a hosed system.
    //
    HalpAcquireCmosSpinLock();

    //
    // According to "ISA System Architecture" 
    // by Mindshare, Inc. (ISBN:0-201-40996-8) Chaper 21.
    // the access method for reading standard PC/AT RTC is:
    //
    // 1. wait for the Update In Progress bit to clear
    //    this is bit 7 of register A
    // 
    // 2. read
    // 

    // 
    // wait until the rtc is done updating
    //
    do {
        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_STDPCAT_REGISTER_A);
        status = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);
        uip = status & CMOS_RAM_STDPCAT_REGISTER_A_UIP_BIT;
    } while (uip);

    //
    // read
    //
    for (offset = SourceAddress, bufOffset = 0; offset < upperAddrBound; offset++, bufOffset++) {

        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, (UCHAR)offset);

        ReturnBuffer[bufOffset] = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);

    }

    HalpReleaseCmosSpinLock();

    return bufOffset; 
}

ULONG
HalpWriteRtcStdPCAT(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine handles writes into the standard PC/AT RTC range.

    Arguments:

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

--*/
{
    ULONG   offset;
    ULONG   bufOffset;
    ULONG   status;     // register status
    ULONG   uip;        // update in progress bit
    ULONG   upperAddrBound;

    upperAddrBound = SourceAddress + ByteCount;

    //
    // NOTE: The spinlock is needed even in the UP case, because
    //    the resource is also used in an interrupt handler (profiler).
    //    If we own the spinlock in this routine, and we service
    //    the profiler interrupt (which will wait for the spinlock forever),
    //    then we have a hosed system.
    //

    HalpAcquireCmosSpinLock();

    //
    // According to "ISA System Architecture" 
    // by Mindshare, Inc. (ISBN:0-201-40996-8) Chapter 21.
    // the access method for writing to standard PC/AT RTC is:
    //
    // 1. wait for the Update In Progress bit (UIP) to clear,
    //    where UIP is bit 7 of register A
    // 
    // 2. set the SET bit to notify the RTC that the registers
    //    are being updated.  The SET bit is bit 7 of register B
    //    
    // 3. update the rtc registers
    // 
    // 4. clear the SET bit, notifying the RTC that we are done writing
    //

    // 
    // wait until the rtc is done updating
    //
    do {
        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_STDPCAT_REGISTER_A);
        status = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);
        uip = status & CMOS_RAM_STDPCAT_REGISTER_A_UIP_BIT;
    } while (uip);

    //
    // set the SET bit of register B
    //
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_STDPCAT_REGISTER_B);
    status = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);
    status |= CMOS_RAM_STDPCAT_REGISTER_B_SET_BIT;
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_STDPCAT_REGISTER_B);
    WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)(status));

    //
    // update the rtc registers
    //
    for (offset = SourceAddress, bufOffset = 0; offset < upperAddrBound; offset++, bufOffset++) {

        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, (UCHAR)offset);
        WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)(ReturnBuffer[bufOffset]));

    }

    //
    // clear the SET bit of register B
    //
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_STDPCAT_REGISTER_B);
    status = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);
    status &= ~CMOS_RAM_STDPCAT_REGISTER_B_SET_BIT;
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_STDPCAT_REGISTER_B);
    WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)(status));


    HalpReleaseCmosSpinLock();

    return bufOffset; 
}


ULONG
HalpReadRtcIntelPIIX4(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine reads the RTC range for the Intel PIIX4 CMOS/RTC chip
    
    Arguments:

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

--*/
{

    //
    // Use the access method for the Standard PC/AT since it is 
    // equivalent to the Intel PIIX4 access method.
    //

    return HalpReadRtcStdPCAT(
                             SourceAddress,
                             ReturnBuffer,
                             ByteCount
                             );

}

ULONG
HalpWriteRtcIntelPIIX4(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine handles writes into the RTC range for the Intel PIIX4 CMOS/RTC chip

    Arguments:

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

--*/
{
    
    //
    // Use the access method for the Standard PC/AT since it is 
    // equivalent to the Intel PIIX4 access method.
    //

    return HalpWriteRtcStdPCAT(
                              SourceAddress,
                              ReturnBuffer,
                              ByteCount
                              );
    
}

ULONG
HalpReadExtCmosIntelPIIX4(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine reads the RTC registers for the Intel PIIX4 CMOS/RTC chip.
    
    Arguments:

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

--*/
{
    
    //
    // The Intel PIIX4 Extended SRAM is accessed using 
    // next pair of IO ports above the standard addr/data ports.
    // Hence, we can simply forward the request with the correct pair.
    // 
    
    return HalpReadCmosDataByPort(
                                 CmosStdAddrPort + 2,
                                 CmosStdDataPort + 2,
                                 SourceAddress,
                                 ReturnBuffer,
                                 ByteCount
                                 );
}

ULONG
HalpWriteExtCmosIntelPIIX4(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine handles writes into the RTC registers for the Intel PIIX4 CMOS/RTC chip.
    
    Arguments:

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

--*/
{

    //
    // The Intel PIIX4 Extended SRAM is accessed using 
    // next pair of IO ports above the standard addr/data ports.
    // Hence, we can simply forward the request with the correct pair.
    // 
    
    return HalpWriteCmosDataByPort(
                                  CmosStdAddrPort + 2,
                                  CmosStdDataPort + 2,
                                  SourceAddress,
                                  ReturnBuffer,
                                  ByteCount
                                  );
}


ULONG
HalpReadRtcDal1501(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine reads the RTC registers for the Dallas 1501 CMOS/RTC chip.
    
    Arguments:

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

--*/
{
    ULONG   offset;
    ULONG   bufOffset;
    ULONG   status;     // register status
    ULONG   upperAddrBound;

    upperAddrBound = SourceAddress + ByteCount;

    //
    // NOTE: The spinlock is needed even in the UP case, because
    //    the resource is also used in an interrupt handler (profiler).
    //    If we own the spinlock in this routine, and we service
    //    the profiler interrupt (which will wait for the spinlock forever),
    //    then we have a hosed system.
    //

    HalpAcquireCmosSpinLock();

    //
    // NOTE: The recommended procedure for reading the Dallas 1501 RTC is to stop
    // external register updates while reading.  Internally, updates in the RTC 
    // continue as normal.  This procedure prevents reading the registers while 
    // they are in transition
    // 

    // 
    // Clear the TE bit of register B to stop external updates
    //
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_REGISTER_B);
    status = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);
    status &= ~CMOS_RAM_DAL1501_REGISTER_B_TE_BIT;
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_REGISTER_B);
    WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)status);

    for (offset = SourceAddress, bufOffset = 0; offset < upperAddrBound; offset++, bufOffset++) {

        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, (UCHAR)offset);
        
        ReturnBuffer[bufOffset] = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);

    }

    // 
    // Set the TE bit of register B to enable external updates
    //
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_REGISTER_B);
    status = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);
    status |= CMOS_RAM_DAL1501_REGISTER_B_TE_BIT;
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_REGISTER_B);
    WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)status);

    HalpReleaseCmosSpinLock();

    return bufOffset; 
}

ULONG
HalpWriteRtcDal1501(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
/*++       
    This routine handles writes into the RTC region for the Dallas 1501 CMOS/RTC chip.
    
    Arguments:

       SourceAddress   : address in CMOS where data is to be read from

       ReturnBuffer    : address in system memory for return data

       ByteCount       : number of bytes to be read

    Returns:

       Number of bytes actually read.

--*/
{
    ULONG   offset;
    ULONG   bufOffset;
    ULONG   status;     // register status
    ULONG   upperAddrBound;

    upperAddrBound = SourceAddress + ByteCount;

    //
    // NOTE: The spinlock is needed even in the UP case, because
    //    the resource is also used in an interrupt handler (profiler).
    //    If we own the spinlock in this routine, and we service
    //    the profiler interrupt (which will wait for the spinlock forever),
    //    then we have a hosed system.
    //

    HalpAcquireCmosSpinLock();

    //
    // NOTE: The recommended procedure for writing the Dallas 1501 RTC is to stop
    // external register updates while writing.  The modified register values
    // are transferred into the internal registers when the TE bit is set.  Operation
    // then continues normally.
    // 

    // 
    // Clear the TE bit of register B to stop external updates
    //
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_REGISTER_B);
    status = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);
    status &= ~CMOS_RAM_DAL1501_REGISTER_B_TE_BIT;
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_REGISTER_B);
    WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)status);

    for (offset = SourceAddress, bufOffset = 0; offset < upperAddrBound; offset++, bufOffset++) {

        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, (UCHAR)offset);
        WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)(ReturnBuffer[bufOffset]));

    }

    // 
    // Set the TE bit of register B to enable external updates
    //
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_REGISTER_B);
    status = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);
    status |= CMOS_RAM_DAL1501_REGISTER_B_TE_BIT;
    WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_REGISTER_B);
    WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)status);

    HalpReleaseCmosSpinLock();

    return bufOffset; 
}



ULONG
HalpReadExtCmosDal1501(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
{
    ULONG   offset;
    ULONG   bufOffset;
    ULONG   status;     // register status
    ULONG   upperAddrBound;

    upperAddrBound = SourceAddress + ByteCount;

    //
    // NOTE: The spinlock is needed even in the UP case, because
    //    the resource is also used in an interrupt handler (profiler).
    //    If we own the spinlock in this routine, and we service
    //    the profiler interrupt (which will wait for the spinlock forever),
    //    then we have a hosed system.
    //

    HalpAcquireCmosSpinLock();

    //
    // reading from Dallas 1501 SRAM is a 2 step process:
    // 1. First, we write the address to the RAM_ADDR_LSB register in the standard CMOS region.  
    // 2. Then we read the data byte from the RAM_DATA register in the standard CMOS region.
    //
    for (offset = SourceAddress, bufOffset = 0; offset < upperAddrBound; offset++, bufOffset++) {

        //
        // specify the offset into SRAM
        //
        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_RAM_ADDR_LSB);
        WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)offset);
        
        //
        // read the data from SRAM[offset]
        //
        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_RAM_DATA);
        ReturnBuffer[bufOffset] = READ_PORT_UCHAR((PUCHAR)CmosStdDataPort);

    }

    HalpReleaseCmosSpinLock();

    return bufOffset; 
}

ULONG
HalpWriteExtCmosDal1501(
    IN ULONG        SourceAddress,
    IN PUCHAR       ReturnBuffer,
    IN ULONG        ByteCount
    )
{
    ULONG   offset;
    ULONG   bufOffset;
    ULONG   status;     // register status
    ULONG   upperAddrBound;

    upperAddrBound = SourceAddress + ByteCount;

    //
    // NOTE: The spinlock is needed even in the UP case, because
    //    the resource is also used in an interrupt handler (profiler).
    //    If we own the spinlock in this routine, and we service
    //    the profiler interrupt (which will wait for the spinlock forever),
    //    then we have a hosed system.
    //

    HalpAcquireCmosSpinLock();

    //
    // writing to Dallas 1501 SRAM is a 2 step process:
    // 1. First, we write the address to the RAM_ADDR_LSB register in the standard CMOS region.  
    // 2. Then we write the data byte to the RAM_DATA register in the standard CMOS region.
    //
    for (offset = SourceAddress, bufOffset = 0; offset < upperAddrBound; offset++, bufOffset++) {

        //
        // specify the offset into SRAM
        //
        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_RAM_ADDR_LSB);
        WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)offset);
        
        //
        // specify the data to be written into SRAM[offset]
        //
        WRITE_PORT_UCHAR((PUCHAR)CmosStdAddrPort, CMOS_RAM_DAL1501_RAM_DATA);
        WRITE_PORT_UCHAR((PUCHAR)CmosStdDataPort, (UCHAR)(ReturnBuffer[bufOffset]));

    }

    HalpReleaseCmosSpinLock();

    return bufOffset; 
}


#endif // ACPI_CMOS_ACTIVATE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\acpisetd.c ===
/*++

Copyright (c) 1997  Microsoft Corporation
All rights reserved

Module Name:

    acpisetd.c

Abstract:

    This module detects an ACPI system.  It
    is included into setup so that setup
    can figure out which HAL to load

Author:

    Jake Oshins (jakeo) - Feb. 7, 1997.

Environment:

    Textmode setup.

Revision History:


--*/
VOID
BlPrint(
    PCHAR cp,
    ...
    );

ULONG
SlGetChar(
    VOID
    );

VOID
SlPrint(
    IN PCHAR FormatString,
    ...
    );

#define HalpBiosDbgPrint(_x_) if (HalpGoodBiosDebug) {SlPrint _x_; }
#define HalpGoodBiosPause() if (HalpGoodBiosDebug) {SlGetChar();}


#ifdef DEBUG
#undef DEBUG_PRINT
#define DEBUG_PRINT BlPrint
#else
#define DEBUG_PRINT
#endif

typedef struct _ACPI_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[8];             // "RSD PTR" (ascii)
    UCHAR Checksum;
    UCHAR OemId[6];                 // An OEM-supplied string
    UCHAR reserved;                 // must be 0
    ULONG RsdtAddress;              // 32-bit physical address of RSDT
} ACPI_BIOS_INSTALLATION_CHECK, *PACPI_BIOS_INSTALLATION_CHECK;

#include "acpitabl.h"
#include "halp.h"

typedef
BOOLEAN
(* PFN_RULE)(
    PCHAR Section,
    ULONG KeyIndex
    );

extern BOOLEAN DisableACPI;

BOOLEAN MatchAcpiOemIdRule(PCHAR Section, ULONG KeyIndex);
BOOLEAN MatchAcpiOemTableIdRule(PCHAR Section, ULONG KeyIndex);
BOOLEAN MatchAcpiOemRevisionRule(PCHAR Section, ULONG KeyIndex);
BOOLEAN MatchAcpiRevisionRule(PCHAR Section, ULONG KeyIndex);
BOOLEAN MatchAcpiCreatorRevisionRule(PCHAR Section, ULONG KeyIndex);
BOOLEAN MatchAcpiCreatorIdRule(PCHAR Section, ULONG KeyIndex);

typedef struct _INF_RULE {
    PCHAR szRule;
    PFN_RULE pRule;
} INF_RULE, *PINF_RULE;

INF_RULE InfRule[] =
{
    {"AcpiOemId",       MatchAcpiOemIdRule},
    {"AcpiOemTableId",  MatchAcpiOemTableIdRule},
    {"AcpiOemRevision", MatchAcpiOemRevisionRule},
    {"AcpiRevision",    MatchAcpiRevisionRule},
    {"AcpiCreatorRevision", MatchAcpiCreatorRevisionRule},
    {"AcpiCreatorId",   MatchAcpiCreatorIdRule},
    {NULL, NULL}
};

ULONG
DetectMPACPI (
    OUT PBOOLEAN IsConfiguredMp
    );

ULONG
DetectApicACPI (
    OUT PBOOLEAN IsConfiguredMp
    );

ULONG
DetectPicACPI (
    OUT PBOOLEAN IsConfiguredMp
    );

VOID
HalpFindRsdp (
    VOID
    );

BOOLEAN
HalpValidateRsdp(
    VOID
    );

PVOID
HalpFindApic (
    VOID
    );

ULONG
HalpAcpiNumProcessors(
    VOID
    );

BOOLEAN
HalpMatchInfList(
    IN PCHAR Section
    );

BOOLEAN
HalpMatchDescription(
    PCHAR Section
    );

PRSDP   HalpRsdp = NULL;
PRSDT   HalpRsdt = NULL;
PXSDT   HalpXsdt = NULL;
BOOLEAN HalpSearchedForRsdp = FALSE;
PVOID   HalpApic = NULL;
BOOLEAN HalpSearchedForApic = FALSE;

BOOLEAN HalpGoodBiosDebug = FALSE;

// from boot\detect\i386\acpibios.h
//
// Acpi BIOS Installation check
//
#define ACPI_BIOS_START            0xE0000
#define ACPI_BIOS_END              0xFFFFF
#define ACPI_BIOS_HEADER_INCREMENT 16

#ifndef SETUP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DetectMPACPI)
#pragma alloc_text(INIT,DetectApicACPI)
#pragma alloc_text(INIT,DetectPicACPI)
#endif  // ALLOC_PRAGMA
#endif // SETUP


ULONG
DetectMPACPI(
    OUT PBOOLEAN IsConfiguredMp
    )

/*++

Routine Description:

    This function looks for an ACPI Root System Description
    table in the BIOS.  If it exists, this is an ACPI machine.

 Arguments:

   IsConfiguredMp - TRUE if this machine is a MP instance of the ACPI spec, else FALSE.

 Return Value:
   0 - if not a ACPI
   1 - if ACPI

*/
{

    *IsConfiguredMp = FALSE;

    DEBUG_PRINT("DetectMPACPI\n");

    //
    // Detect whether this is an ACPI machine.
    //
    if (HalpSearchedForRsdp == FALSE) {
        PCHAR AcpiDebug;

        //
        // Check whether ACPI detection debugging is enabled
        //
        if ( InfFile ) {
            AcpiDebug = SlGetIniValue(InfFile, "ACPIOptions", "Debug", "0");
            if (AcpiDebug[0] == '1') {
                HalpGoodBiosDebug = TRUE;
                SlPrint("Enabling GOOD BIOS DEBUG\n");
                SlGetChar();
            }
        }

        HalpFindRsdp();

        HalpSearchedForRsdp = TRUE;
    }

    if (!HalpValidateRsdp()) {
        return(FALSE);
    }

    DEBUG_PRINT("Found Rsdp: %x\n", HalpRsdp);

    if (HalpSearchedForApic == FALSE) {

        HalpApic = HalpFindApic();

        HalpSearchedForApic = TRUE;
    }

    if (HalpAcpiNumProcessors() < 2) {
        return FALSE;
    }

    *IsConfiguredMp = TRUE;
    return TRUE;
}


ULONG
DetectApicACPI(
    OUT PBOOLEAN IsConfiguredMp
    )
/*++

Routine Description:

   This function is called by setup after DetectACPI has returned
   false.  During setup time DetectACPI will return false, if the
   machine is an ACPI system, but only has one processor.   This
   function is used to detect such a machine at setup time.

 Arguments:

   IsConfiguredMp - FALSE

 Return Value:
   0 - if not a UP ACPI
   1 - if UP ACPI

--*/
{
    DEBUG_PRINT("DetectApicACPI\n");

    if (HalpSearchedForRsdp == FALSE) {
        PCHAR AcpiDebug;

        //
        // Check whether ACPI detection debugging is enabled
        //
        if ( InfFile ) {
            AcpiDebug = SlGetIniValue(InfFile, "ACPIOptions", "Debug", "0");
            if (AcpiDebug[0] == '1') {
                HalpGoodBiosDebug = TRUE;
            } else {
                HalpGoodBiosDebug = FALSE;
            }
        }

        HalpFindRsdp();

        HalpSearchedForRsdp = TRUE;
    }

    if (!HalpValidateRsdp()) {
        return FALSE;
    }

    if (HalpSearchedForApic == FALSE) {

        HalpApic = HalpFindApic();

        HalpSearchedForApic = TRUE;
    }

    if (!HalpApic) {
        return FALSE;
    }

    *IsConfiguredMp = FALSE;
    return TRUE;
}

ULONG
DetectPicACPI(
    OUT PBOOLEAN IsConfiguredMp
    )
/*++

Routine Description:

   This function is called by setup after DetectACPI has returned
   false.  During setup time DetectACPI will return false, if the
   machine is an ACPI system, but only has one processor.   This
   function is used to detect such a machine at setup time.

 Arguments:

   IsConfiguredMp - FALSE

 Return Value:
   0 - if not a PIC ACPI
   1 - if PIC ACPI

--*/
{
    *IsConfiguredMp = FALSE;

    if (HalpSearchedForRsdp == FALSE) {
        PCHAR AcpiDebug;

        //
        // Check whether ACPI detection debugging is enabled
        //
        if ( InfFile ) {
            AcpiDebug = SlGetIniValue(InfFile, "ACPIOptions", "Debug", "0");
            if (AcpiDebug[0] == '1') {
                HalpGoodBiosDebug = TRUE;
            } else {
                HalpGoodBiosDebug = FALSE;
            }
        }

        HalpFindRsdp();

        HalpSearchedForRsdp = TRUE;
    }

    if (HalpValidateRsdp()) {
        return TRUE;
    }

    return FALSE;
}

#define EBDA_SEGMENT_PTR    0x40e

VOID
HalpFindRsdp (
    VOID
    )
{
    ULONG romAddr = 0;
    ULONG romEnd = 0;
    PACPI_BIOS_INSTALLATION_CHECK header;
    UCHAR sum;
    USHORT i;
    ULONG EbdaSegmentPtr;
    ULONG EbdaPhysicalAdd = 0;
    PUCHAR EbdaVirtualAdd = 0;
    enum PASS { PASS1 = 0, PASS2, MAX_PASSES } pass;

    //
    // Search on 16 byte boundaries for the signature of the
    // Root System Description Table structure.
    //
    for (pass = PASS1; pass < MAX_PASSES; pass++) {

        if (pass == PASS1) {

            //
            // On the first pass, we search the first 1K of the
            // Extended BIOS data area.  The EBDA segment address
            // is available at physical address 40:0E.
            //

            EbdaSegmentPtr = (ULONG) HalpMapPhysicalMemoryWriteThrough( (PVOID) 0, 1);
            EbdaSegmentPtr += EBDA_SEGMENT_PTR;
            EbdaPhysicalAdd = (ULONG)*((PUSHORT)EbdaSegmentPtr) << 4;

            if (EbdaPhysicalAdd) {
                EbdaVirtualAdd = HalpMapPhysicalMemoryWriteThrough( (PVOID)EbdaPhysicalAdd, 2);
            }

            if (!EbdaVirtualAdd) {
                continue;
            }

            romAddr = (ULONG)EbdaVirtualAdd;
            romEnd  = romAddr + 1024;

        } else {
            //
            // On the second pass, we search (physical) memory 0xE0000
            // to 0xF0000.

            romAddr = (ULONG)HalpMapPhysicalMemoryWriteThrough((PVOID)ACPI_BIOS_START,
                                                   ROUND_TO_PAGES(ACPI_BIOS_END - ACPI_BIOS_START) / PAGE_SIZE);

            romEnd  = romAddr + (ACPI_BIOS_END - ACPI_BIOS_START);
        }

        while (romAddr < romEnd) {

            header = (PACPI_BIOS_INSTALLATION_CHECK)romAddr;

            //
            // Signature to match is the string "RSD PTR ".
            //
            if (header->Signature[0] == 'R' && header->Signature[1] == 'S' &&
                header->Signature[2] == 'D' && header->Signature[3] == ' ' &&
                header->Signature[4] == 'P' && header->Signature[5] == 'T' &&
                header->Signature[6] == 'R' && header->Signature[7] == ' ' ) {

                sum = 0;
                for (i = 0; i < sizeof(ACPI_BIOS_INSTALLATION_CHECK); i++) {
                    sum = sum + ((PUCHAR)romAddr)[i];
                }
                if (sum == 0) {
                    pass = MAX_PASSES; // leave 'for' loop
                    break;    // leave 'while' loop
                }
            }

            romAddr += ACPI_BIOS_HEADER_INCREMENT;
        }
    }

    if (romAddr >= romEnd) {
        HalpRsdp = NULL;
        HalpRsdt = NULL;
        HalpXsdt = NULL;
        HalpBiosDbgPrint(("NO ACPI BIOS FOUND!\n"));
        HalpGoodBiosPause();
        return;
    }

    HalpRsdp = (PRSDP)romAddr;
    HalpRsdt = HalpMapPhysicalRangeWriteThrough((PVOID)HalpRsdp->RsdtAddress,
                                     sizeof(RSDT));
    HalpRsdt = HalpMapPhysicalRangeWriteThrough((PVOID)HalpRsdp->RsdtAddress,
                                    HalpRsdt->Header.Length);
    HalpBiosDbgPrint(("Found RSDP at %08lx, RSDT at %08lx\n", HalpRsdp, HalpRsdt));

#ifdef ACPI_20_COMPLIANT
    if (HalpRsdp->Revision > 1) {

        //
        // ACPI 2.0 BIOS
        //

        HalpXsdt = HalpMapPhysicalRangeWriteThrough((PVOID)HalpRsdp->XsdtAddress.LowPart,
                                        sizeof(XSDT));
        HalpXsdt = HalpMapPhysicalRangeWriteThrough((PVOID)HalpRsdp->XsdtAddress.LowPart,
                                        HalpXsdt->Header.Length);
        HalpBiosDbgPrint(("Found XSDT at %08lx\n", HalpXsdt));
    }
#endif
    return;
}

PVOID
HalpFindApic (
    VOID
    )
{
    ULONG   entry, rsdtEntries, rsdtLength;
    PVOID   physicalAddr;
    PDESCRIPTION_HEADER header = NULL;

    //
    // Calculate the number of entries in the RSDT.
    //

    if (HalpXsdt) {

        //
        // ACPI 2.0 BIOS
        //

        rsdtLength = HalpXsdt->Header.Length;
        rsdtEntries = NumTableEntriesFromXSDTPointer(HalpXsdt);

    } else {

        //
        // ACPI 1.0 BIOS
        //

        rsdtLength = HalpRsdt->Header.Length;
        rsdtEntries = NumTableEntriesFromRSDTPointer(HalpRsdt);
    }

    DEBUG_PRINT("rsdt length: %d\n", HalpRsdt->Header.Length);
    DEBUG_PRINT("rsdtEntries: %d\n", rsdtEntries);
    //
    // Look down the pointer in each entry to see if it points to
    // the table we are looking for.
    //
    for (entry = 0; entry < rsdtEntries; entry++) {

        physicalAddr = HalpXsdt ?
            (PVOID)HalpXsdt->Tables[entry].LowPart :
            (PVOID)HalpRsdt->Tables[entry];

        header = HalpMapPhysicalMemoryWriteThrough(physicalAddr, 2);
        if (!header) {
            return NULL;
        }

        DEBUG_PRINT("header: %x%x\n", ((ULONG)header) >> 16, (ULONG)header & 0xffff);
        DEBUG_PRINT("entry: %d\n", header->Signature);

        if (header->Signature == APIC_SIGNATURE) {
            break;
        }
    }

    //
    // We didn't find an APIC table.
    //
    if (entry >= rsdtEntries) {
        DEBUG_PRINT("Didn't find an APIC table\n");
        return NULL;
    }

    DEBUG_PRINT("returning: %x\n", header);
    return (PVOID)header;
}

ULONG
HalpAcpiNumProcessors(
    VOID
    )
{
    PUCHAR  TraversePtr;
    UCHAR   procCount = 0;

    if (!HalpApic) {
        return 1;
    }

    TraversePtr = (PUCHAR)((PMAPIC)HalpApic)->APICTables;

    DEBUG_PRINT("APIC table header length %d\n", ((PMAPIC)HalpApic)->Header.Length);
    DEBUG_PRINT("APIC table: %x%x  TraversePtr: %x%x\n",
            (ULONG)HalpApic >> 16,
            (ULONG)HalpApic & 0xffff,
            (ULONG)TraversePtr >> 16,
            (ULONG)TraversePtr & 0xffff);

    while (TraversePtr <= ((PUCHAR)HalpApic + ((PMAPIC)HalpApic)->Header.Length)) {

        if ((((PPROCLOCALAPIC)(TraversePtr))->Type == PROCESSOR_LOCAL_APIC)
           && (((PPROCLOCALAPIC)(TraversePtr))->Length == PROCESSOR_LOCAL_APIC_LENGTH)) {

            if(((PPROCLOCALAPIC)(TraversePtr))->Flags & PLAF_ENABLED) {

                //
                // This processor is enabled.
                //

                procCount++;
            }

            TraversePtr += ((PPROCLOCALAPIC)(TraversePtr))->Length;

        } else if ((((PIOAPIC)(TraversePtr))->Type == IO_APIC) &&
           (((PIOAPIC)(TraversePtr))->Length == IO_APIC_LENGTH)) {

            //
            // Found an I/O APIC entry.  Skipping it.
            //

            TraversePtr += ((PIOAPIC)(TraversePtr))->Length;

        } else if ((((PISA_VECTOR)(TraversePtr))->Type == ISA_VECTOR_OVERRIDE) &&
           (((PISA_VECTOR)(TraversePtr))->Length == ISA_VECTOR_OVERRIDE_LENGTH)) {

            //
            // Found an Isa Vector Override entry.  Skipping it.
            //

            TraversePtr += ISA_VECTOR_OVERRIDE_LENGTH;

        } else {

            //
            // Found random bits in the table.  Try the next byte and
            // see if we can make sense of it.
            //

            TraversePtr += 1;
        }
    }

    DEBUG_PRINT("returning %d processors\n", procCount);
    return procCount;
}


BOOLEAN
HalpValidateRsdp(
    VOID
    )
/*++

Routine Description:

    Given a pointer to the RSDP, this function validates that it
    is suitable for running NT. Currently this test includes:
        Checking for a known good version of a known BIOS
     OR Checking for a date of 1/1/99 or greater

Arguments:

Return Value:

    TRUE - The ACPI BIOS on this machine is good and can be used by NT

    FALSE - The ACPI BIOS on this machine is broken and will be ignored
            by NT.

--*/

{
    ULONG AcpiOptionValue = 2;
    PCHAR AcpiOption;
    PCHAR szMonth = "01", szDay = "01", szYear = "1999";
    ULONG Month, Day, Year;
    CHAR Temp[3];
    ULONG BiosDate, CheckDate;
    PUCHAR DateAddress;

    if (HalpRsdp == NULL) {
        HalpBiosDbgPrint(("Disabling ACPI since there is NO ACPI BIOS\n"));
        HalpGoodBiosPause();
        return(FALSE);
    }

    //
    // Check if the user has manually disabled ACPI with the F7 key
    //
    if (DisableACPI) {
        HalpBiosDbgPrint(("Disabling ACPI due to user pressing F7\n"));
        HalpGoodBiosPause();
        return(FALSE);
    }

    if (WinntSifHandle) {

        AcpiOption = SlGetIniValue(WinntSifHandle, "Unattended", "ForceHALDetection", "no");
        if (_stricmp(AcpiOption,"yes") == 0) {

            HalpBiosDbgPrint(("Unattend Files specifies ForceHALDetection.\n"));
            AcpiOptionValue = 2;

        } else {

            //
            // Check the setting for ACPIEnable.
            //    0 = Disable ACPI
            //    1 = Enable ACPI
            //    2 = Do normal good/bad BIOS detection
            //
            HalpBiosDbgPrint(("Unattend Files does not Contain ForceHALDetection.\n"));
            AcpiOption = SlGetIniValue(WinntSifHandle, "Data", "AcpiHAL", "3");
            if (AcpiOption[0] == '0' || AcpiOption[0] == '1') {

                HalpBiosDbgPrint(("Got AcpiHal value from WINNT.SIF\n"));
                AcpiOptionValue = AcpiOption[0] - '0';

            } else if (InfFile) {

                AcpiOption = SlGetIniValue(InfFile, "ACPIOptions", "ACPIEnable", "2");
                if (AcpiOption[0] >= '0' && AcpiOption[0] <= '2') {

                    HalpBiosDbgPrint(("No AcpiHal value from WINNT.SIF\n"));
                    HalpBiosDbgPrint(("Got ACPIEnable from TXTSETUP.SIF\n"));
                    AcpiOptionValue = AcpiOption[0] - '0';

                }

            }

        }

    } else if (InfFile) {

        AcpiOption = SlGetIniValue(InfFile, "ACPIOptions", "ACPIEnable", "2");
        if (AcpiOption[0] >= '0' && AcpiOption[0] <= '2') {

            HalpBiosDbgPrint(("No WINNT.SIF\n"));
            HalpBiosDbgPrint(("Got ACPIEnable from TXTSETUP.SIF\n"));
            AcpiOptionValue = AcpiOption[0] - '0';

        }

    }
    if (AcpiOptionValue == 0) {

        HalpBiosDbgPrint(("Force Disabling ACPI due to ACPIEnable == 0\n"));
        HalpGoodBiosPause();
        return(FALSE);

    } else if (AcpiOptionValue == 1) {

        HalpBiosDbgPrint(("Force Enabling ACPI due to ACPIEnable == 1\n"));
        HalpGoodBiosPause();
        return(TRUE);

    } else {

        HalpBiosDbgPrint(("System will detect ACPI due to ACPIEnable == 2\n"));
        HalpGoodBiosPause();

    }

    if ( InfFile ) {

        //
        // Check the Good BIOS list. If the BIOS is on this list, it is OK to
        // enable ACPI.
        //
        if (HalpMatchInfList("GoodACPIBios")) {
            HalpBiosDbgPrint(("Enabling ACPI since machine is on Good BIOS list\n"));
            HalpGoodBiosPause();
            return(TRUE);
        }

        //
        // The BIOS is not on our Known Good list. Check the BIOS date and see
        // if it is after our date at which we hope all BIOSes work.
        //

        szMonth = SlGetSectionKeyIndex(InfFile, "ACPIOptions", "ACPIBiosDate", 0);
        szDay = SlGetSectionKeyIndex(InfFile, "ACPIOptions", "ACPIBiosDate", 1);
        szYear = SlGetSectionKeyIndex(InfFile, "ACPIOptions", "ACPIBiosDate", 2);
    }


    if ((szMonth == NULL) ||
        (szDay == NULL) ||
        (szYear == NULL)) {
        HalpBiosDbgPrint(("No Good BIOS date present in INF file\n"));

    } else {

        RtlCharToInteger(szMonth, 16, &Month);
        RtlCharToInteger(szDay, 16, &Day);
        RtlCharToInteger(szYear, 16, &Year);
        CheckDate = (Year << 16) + (Month << 8) + Day;

        DateAddress = HalpMapPhysicalRange((PVOID)0xFFFF5, 8);
        Temp[2] = '\0';
        RtlCopyMemory(Temp, DateAddress+6, 2);
        RtlCharToInteger(Temp, 16, &Year);
        if (Year < 0x80) {
            Year += 0x2000;
        } else {
            Year += 0x1900;
        }

        RtlCopyMemory(Temp, DateAddress, 2);
        RtlCharToInteger(Temp, 16, &Month);

        RtlCopyMemory(Temp, DateAddress+3, 2);
        RtlCharToInteger(Temp, 16, &Day);

        BiosDate = (Year << 16) + (Month << 8) + Day;

        HalpBiosDbgPrint(("\n    Checking good date %08lx against BIOS date %08lx - ",CheckDate,BiosDate));
        if (BiosDate >= CheckDate) {
            HalpBiosDbgPrint(("GOOD!\n"));

            //
            // The date on the BIOS is new enough, now just make sure the machine
            // is not on the BAD BIOS list.
            //
            if ( InfFile ) {
                HalpBiosDbgPrint(("Checking BAD BIOS LIST\n"));
                if (HalpMatchInfList("NWACL")) {
                    HalpBiosDbgPrint(("Disabling ACPI since machine is on BAD BIOS list\n"));
                    HalpGoodBiosPause();
                    return(FALSE);
                } else {
                    HalpBiosDbgPrint(("Enabling ACPI since BIOS is new enough to work\n"));
                    HalpGoodBiosPause();
                    return(TRUE);
                }
            } else {
                return(TRUE);
            }
        } else {
            HalpBiosDbgPrint(("BAD!\n"));
        }

    }

    HalpBiosDbgPrint(("Disabling ACPI since machine is NOT on Good BIOS list\n"));
    HalpGoodBiosPause();
    return(FALSE);

}


PDESCRIPTION_HEADER
HalpFindACPITable(
    IN PCHAR TableName,
    IN ULONG TableLength
    )
/*++

Routine Description:

    Given a table name, finds that table in the ACPI BIOS

Arguments:

    TableName - Supplies the table name

    TableLength - Supplies the length of the table to map

Return Value:

    Pointer to the table if found

    NULL if the table is not found

--*/

{
    ULONG Signature;
    PFADT Fadt;
    PDESCRIPTION_HEADER Header;
    ULONG TableCount;
    ULONG i;
    ULONG TableAddr;

    Signature = *((ULONG UNALIGNED *)TableName);
    if (Signature == RSDT_SIGNATURE) {
        return(&HalpRsdt->Header);
    } else if (Signature == XSDT_SIGNATURE) {
        return(&HalpXsdt->Header);
    } else if (Signature == DSDT_SIGNATURE) {
        Fadt = (PFADT)HalpFindACPITable("FACP", sizeof(FADT));
        if (Fadt == NULL) {
            return(NULL);
        }
        Header = HalpMapPhysicalRangeWriteThrough((PVOID)Fadt->dsdt, TableLength);
        return(Header);
    } else {

        TableCount = HalpXsdt ?
            NumTableEntriesFromXSDTPointer(HalpXsdt) :
            NumTableEntriesFromRSDTPointer(HalpRsdt);

        for (i=0;i<TableCount;i++) {

            TableAddr = HalpXsdt ?
                HalpXsdt->Tables[i].LowPart :
                HalpRsdt->Tables[i];

            Header = HalpMapPhysicalRangeWriteThrough((PVOID)TableAddr, sizeof(DESCRIPTION_HEADER));
            if (Header->Signature == Signature) {
                if (TableLength/PAGE_SIZE > sizeof(DESCRIPTION_HEADER)/PAGE_SIZE) {
                    //
                    // if we need to map more than just the DESCRIPTION_HEADER, do that before
                    // returning.
                    //
                    Header = HalpMapPhysicalRangeWriteThrough((PVOID)TableAddr, TableLength);
                }
                return(Header);
            }
        }
    }

    return(NULL);
}


BOOLEAN
HalpMatchInfList(
    IN PCHAR Section
    )
/*++

Routine Description:

    This function determines if the computer matches any of the computer
    descriptions in an INF file list.

Arguments:

    Section - Section of INF that contains the list of descriptions

Return Value:

    TRUE - The computer matches one of the descriptions

    FALSE - The computer does not match any of the descriptions

--*/

{
    ULONG i;
    PCHAR ComputerName;

    for (i=0; ; i++) {
        ComputerName = SlGetKeyName(InfFile,
                                    Section,
                                    i);
        if (ComputerName == NULL) {
            break;
        }
        if (HalpMatchDescription(ComputerName)) {
            return(TRUE);
        }
    }

    return(FALSE);
}


BOOLEAN
HalpMatchDescription(
    PCHAR Section
    )
/*++

Routine Description:

    This function processes an ACPI BIOS description to see if the
    BIOS matches all of the rules in the section

Arguments:

    Section - Supplies the section name of the INF to process

Return Value:

    TRUE - The BIOS matches all the rules

    FALSE - The BIOS failed one or more rules

--*/

{
    ULONG RuleNumber;
    PCHAR Rule;
    ULONG i;
    BOOLEAN Success;

    HalpBiosDbgPrint(("Matching against %s\n", Section));

    //
    // Check to see if the specified section exists
    //
    if (!SpSearchINFSection(InfFile, Section)) {
        HalpBiosDbgPrint(("\tERROR - no INF section %s\n", Section));
        HalpGoodBiosPause();
        return(FALSE);
    }

    for (RuleNumber=0; ;RuleNumber++) {
        Rule = SlGetKeyName(InfFile, Section, RuleNumber);
        if (Rule == NULL) {
            break;
        }
        for (i=0; InfRule[i].szRule != NULL;i++) {
            if (_stricmp(Rule, InfRule[i].szRule) == 0) {
                HalpBiosDbgPrint(("\tTesting Rule %s\n",Rule));
                Success = (*(InfRule[i].pRule))(Section, RuleNumber);
                if (!Success) {
                    HalpBiosDbgPrint(("\tFAILED!\n"));
                    HalpGoodBiosPause();
                    return(FALSE);
                }
                HalpBiosDbgPrint(("\tSucceeded\n"));
                break;
            }
        }
        if (InfRule[i].szRule == NULL) {
            //
            // rule in the INF was not found
            //
            HalpBiosDbgPrint(("\tRULE %s not found!\n",Rule));
            HalpGoodBiosPause();
            return(FALSE);
        }
    }

    HalpBiosDbgPrint(("Machine matches %s\n",Section));
    HalpGoodBiosPause();

    return(TRUE);
}


BOOLEAN
HalpCheckOperator(
    IN PCHAR Operator,
    IN ULONG Arg1,
    IN ULONG Arg2
    )
/*++

Routine Description:

    Given an operator and two ULONG arguments, this function
    returns the boolean result.

Arguments:

    Operator = Supplies the logical operator: =, ==, <=, >=, !=, <, >

    Arg1 - Supplies the first argument

    Arg2 - Supplies the second argument

Return Value:

    TRUE if Arg1 Operator Arg2

    FALSE otherwise

--*/

{
    BOOLEAN Success = FALSE;

    HalpBiosDbgPrint(("\t\tChecking %lx %s %lx - ",Arg1, Operator, Arg2));

    if ((strcmp(Operator, "=") == 0) ||
        (strcmp(Operator, "==") == 0)) {
        Success = (Arg1 == Arg2) ? TRUE : FALSE;
    } else if (strcmp(Operator, "!=") == 0) {
        Success = (Arg1 != Arg2) ? TRUE : FALSE;
    } else if (strcmp(Operator, "<") == 0) {
        Success = (Arg1 < Arg2) ? TRUE : FALSE;
    } else if (strcmp(Operator, "<=") == 0) {
        Success = (Arg1 <= Arg2) ? TRUE : FALSE;
    } else if (strcmp(Operator, ">") == 0) {
        Success = (Arg1 > Arg2) ? TRUE : FALSE;
    } else if (strcmp(Operator, ">=") == 0) {
        Success = (Arg1 >= Arg2) ? TRUE : FALSE;
    } else {
        //
        //      Invalid operator
        //
    }
    if (Success) {
        HalpBiosDbgPrint(("TRUE\n"));
    } else {
        HalpBiosDbgPrint(("FALSE\n"));
    }


    return(Success);
}


BOOLEAN
MatchAcpiOemIdRule(
    PCHAR Section,
    ULONG KeyIndex
    )
/*++

Routine Description:

    This function processes a ACPI OEM ID rule from an INF file

    Examples:

        AcpiOemId="RSDT", "123456"

    is true if the RSDT has the OEM ID of 123456.

        AcpiOemId="DSDT", "768000"

    is true if the DSDT has the OEM ID of 768000.

Arguments:

    Section - Specifies the section name the rule is in

    KeyIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI OEM ID.

    FALSE - the computer does not have the specified ACPI OEM ID.

--*/

{
    PCHAR TableName;
    PCHAR OemId;
    PDESCRIPTION_HEADER Header;
    CHAR ACPIOemId[6];
    ULONG IdLength;

    TableName = SlGetSectionLineIndex(InfFile,
                                      Section,
                                      KeyIndex,
                                      0);
    OemId = SlGetSectionLineIndex(InfFile,
                                  Section,
                                  KeyIndex,
                                  1);
    if ((TableName == NULL) || (OemId == NULL)) {
        //
        //    the INF line is ill-formed
        //
        HalpBiosDbgPrint(("\t\tINF line is ill-formed\n"));
        return(FALSE);
    }

    Header = HalpFindACPITable(TableName, sizeof(DESCRIPTION_HEADER));
    if (Header == NULL) {
        //
        // The specified table was not found
        //
        HalpBiosDbgPrint(("\t\tTable %s was not found\n"));
        return(FALSE);
    }
    RtlZeroMemory(ACPIOemId, sizeof(ACPIOemId));
    IdLength = strlen(OemId);
    if (IdLength > sizeof(ACPIOemId)) {
        IdLength = sizeof(ACPIOemId);
    }
    RtlCopyMemory(ACPIOemId, OemId, IdLength);
    HalpBiosDbgPrint(("\t\tComparing OEM ID %s '%6.6s' with '%6.6s' - ",
                       TableName,
                       ACPIOemId,
                       Header->OEMID));
    if (RtlEqualMemory(ACPIOemId, Header->OEMID, sizeof(Header->OEMID))) {
        HalpBiosDbgPrint(("TRUE\n"));
        return(TRUE);
    } else {
        HalpBiosDbgPrint(("FALSE\n"));
        return(FALSE);
    }
}


BOOLEAN
MatchAcpiOemTableIdRule(
    PCHAR Section,
    ULONG KeyIndex
    )
/*++

Routine Description:

    This function processes a ACPI OEM Table ID rule from an INF file

    Examples:

    AcpiOemTableId="RSDT", "12345678"

        is true if the RSDT has the Oem Table ID of 12345678.

    AcpiOemTableId="DSDT", "87654321"

        is true if the DSDT has the Oem Table ID of 87654321.

Arguments:

    Section - Specifies the section name the rule is in

    KeyIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI OEM ID.

    FALSE - the computer does not have the specified ACPI OEM ID.

--*/

{
    PCHAR TableName;
    PCHAR OemTableId;
    PDESCRIPTION_HEADER Header;
    CHAR ACPIOemTableId[8];
    ULONG IdLength;

    TableName = SlGetSectionLineIndex(InfFile,
                                      Section,
                                      KeyIndex,
                                      0);
    OemTableId = SlGetSectionLineIndex(InfFile,
                                       Section,
                                       KeyIndex,
                                       1);
    if ((TableName == NULL) || (OemTableId == NULL)) {
        //
        //    the INF line is ill-formed
        //
        HalpBiosDbgPrint(("\t\tINF line is ill-formed\n"));
        return(FALSE);
    }

    Header = HalpFindACPITable(TableName, sizeof(DESCRIPTION_HEADER));
    if (Header == NULL) {
        //
        // The specified table was not found
        //
        HalpBiosDbgPrint(("\t\tTable %s was not found\n"));
        return(FALSE);
    }
    RtlZeroMemory(ACPIOemTableId, sizeof(ACPIOemTableId));
    IdLength = strlen(OemTableId);
    if (IdLength > sizeof(ACPIOemTableId)) {
        IdLength = sizeof(ACPIOemTableId);
    }
    RtlCopyMemory(ACPIOemTableId, OemTableId, IdLength);
    HalpBiosDbgPrint(("\t\tComparing OEM TableID %s '%8.8s' with '%8.8s' - ",
                       TableName,
                       ACPIOemTableId,
                       Header->OEMTableID));
    if (RtlEqualMemory(ACPIOemTableId,
                       Header->OEMTableID,
                       sizeof(Header->OEMTableID))) {
        HalpBiosDbgPrint(("TRUE\n"));
        return(TRUE);
    } else {
        HalpBiosDbgPrint(("FALSE\n"));
        return(FALSE);
    }
}

BOOLEAN
MatchAcpiOemRevisionRule(
    PCHAR Section,
    ULONG KeyIndex
    )
/*++

Routine Description:

    This function processes a ACPI Oem Revision rule from an INF file

    Examples:

    AcpiOemRevision="=","RSDT", 1234

        is true if the RSDT has the Oem Revision EQUAL to 1234.

    AcpiOemRevision=">","DSDT", 4321

        is true if the DSDT has the Oem Revision GREATER than 4321.

Arguments:

    Section - Specifies the section name the rule is in

    KeyIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI OEM ID.

    FALSE - the computer does not have the specified ACPI OEM ID.

--*/

{
    PCHAR TableName;
    PCHAR szOemRevision;
    ULONG OemRevision;
    PCHAR Operator;
    PDESCRIPTION_HEADER Header;
    BOOLEAN Success;

    Operator = SlGetSectionLineIndex(InfFile,
                                     Section,
                                     KeyIndex,
                                     0);

    TableName = SlGetSectionLineIndex(InfFile,
                                      Section,
                                      KeyIndex,
                                      1);
    szOemRevision = SlGetSectionLineIndex(InfFile,
                                          Section,
                                          KeyIndex,
                                          2);
    if ((Operator == NULL) || (TableName == NULL) || (szOemRevision == NULL)) {
        //
        //    the INF line is ill-formed
        //
        HalpBiosDbgPrint(("\t\tINF line is ill-formed\n"));
        return(FALSE);
    }
    RtlCharToInteger(szOemRevision, 16, &OemRevision);

    Header = HalpFindACPITable(TableName, sizeof(DESCRIPTION_HEADER));
    if (Header == NULL) {
        //
        // The specified table was not found
        //
        HalpBiosDbgPrint(("\t\tTable %s was not found\n"));
        return(FALSE);
    }
    Success = HalpCheckOperator(Operator, Header->OEMRevision, OemRevision);
    return(Success);
}


BOOLEAN
MatchAcpiRevisionRule(
    PCHAR Section,
    ULONG KeyIndex
    )
/*++

Routine Description:

    This function processes a ACPI Revision rule from an INF file

    Examples:

        AcpiRevision="=", "RSDT", 1234

    is true if the RSDT ACPI Revision is EQUAL to 1234.

        AcpiRevision=">", "DSDT", 4321

    is true if the DSDT ACPI Revision is GREATER than 4321.

Arguments:

    Section - Specifies the section name the rule is in

    KeyIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI OEM ID.

    FALSE - the computer does not have the specified ACPI OEM ID.

--*/

{
    PCHAR TableName;
    PCHAR szRevision;
    ULONG Revision;
    PCHAR Operator;
    PDESCRIPTION_HEADER Header;
    BOOLEAN Success;

    Operator = SlGetSectionLineIndex(InfFile,
                                     Section,
                                     KeyIndex,
                                     0);

    TableName = SlGetSectionLineIndex(InfFile,
                                      Section,
                                      KeyIndex,
                                      1);
    szRevision = SlGetSectionLineIndex(InfFile,
                                       Section,
                                       KeyIndex,
                                       2);
    if ((Operator == NULL) || (TableName == NULL) || (szRevision == NULL)) {
        //
        //    the INF line is ill-formed
        //
        HalpBiosDbgPrint(("\t\tINF line is ill-formed\n"));
        return(FALSE);
    }
    RtlCharToInteger(szRevision, 16, &Revision);

    Header = HalpFindACPITable(TableName, sizeof(DESCRIPTION_HEADER));
    if (Header == NULL) {
        //
        // The specified table was not found
        //
        HalpBiosDbgPrint(("\t\tTable %s was not found\n"));
        return(FALSE);
    }
    Success = HalpCheckOperator(Operator, Header->Revision, Revision);
    return(Success);
}


BOOLEAN
MatchAcpiCreatorRevisionRule(
    PCHAR Section,
    ULONG KeyIndex
    )
/*++

Routine Description:

    This function processes a ACPI Creator Revision rule from an INF file

    Examples:

        AcpiCreatorRevision="=", "RSDT", 1234

    is true if the RSDT ACPI Creator Revision is EQUAL to 1234.

        AcpiCreatorRevision=">", "DSDT", 4321

    is true if the DSDT ACPI Creator Revision is GREATER than 4321.

Arguments:

    Section - Specifies the section name the rule is in

    KeyIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI OEM ID.

    FALSE - the computer does not have the specified ACPI OEM ID.

--*/

{
    PCHAR TableName;
    PCHAR szCreatorRevision;
    ULONG CreatorRevision;
    PCHAR Operator;
    PDESCRIPTION_HEADER Header;
    BOOLEAN Success;

    Operator = SlGetSectionLineIndex(InfFile,
                                     Section,
                                     KeyIndex,
                                     0);

    TableName = SlGetSectionLineIndex(InfFile,
                                      Section,
                                      KeyIndex,
                                      1);
    szCreatorRevision = SlGetSectionLineIndex(InfFile,
                                              Section,
                                              KeyIndex,
                                              2);
    if ((Operator == NULL) || (TableName == NULL) || (szCreatorRevision == NULL)) {
        //
        //    the INF line is ill-formed
        //
        HalpBiosDbgPrint(("\t\tINF line is ill-formed\n"));
        return(FALSE);
    }
    RtlCharToInteger(szCreatorRevision, 16, &CreatorRevision);

    Header = HalpFindACPITable(TableName, sizeof(DESCRIPTION_HEADER));
    if (Header == NULL) {
        //
        // The specified table was not found
        //
        HalpBiosDbgPrint(("\t\tTable %s was not found\n"));
        return(FALSE);
    }
    Success = HalpCheckOperator(Operator, Header->CreatorRev, CreatorRevision);
    return(Success);
}

BOOLEAN
MatchAcpiCreatorIdRule(
    PCHAR Section,
    ULONG KeyIndex
    )
/*++

Routine Description:

    This function processes a ACPI Creator ID rule from an INF file

    Examples:

        AcpiCreatorId="RSDT", "MSFT"

    is true if the RSDT has the Creator ID of MSFT.

Arguments:

    Section - Specifies the section name the rule is in

    KeyIndex - Specifies the index of the rule in the section

Return Value:

    TRUE - the computer has the specified ACPI OEM ID.

    FALSE - the computer does not have the specified ACPI OEM ID.

--*/

{
    PCHAR TableName;
    PCHAR CreatorId;
    PDESCRIPTION_HEADER Header;
    CHAR ACPICreatorId[6];
    ULONG IdLength;

    TableName = SlGetSectionLineIndex(InfFile,
                                      Section,
                                      KeyIndex,
                                      0);
    CreatorId = SlGetSectionLineIndex(InfFile,
                                      Section,
                                      KeyIndex,
                                      1);
    if ((TableName == NULL) || (CreatorId == NULL)) {
        //
        //    the INF line is ill-formed
        //
        HalpBiosDbgPrint(("\t\tINF line is ill-formed\n"));
        return(FALSE);
    }

    Header = HalpFindACPITable(TableName, sizeof(DESCRIPTION_HEADER));
    if (Header == NULL) {
        //
        // The specified table was not found
        //
        HalpBiosDbgPrint(("\t\tTable %s was not found\n"));
        return(FALSE);
    }
    RtlZeroMemory(ACPICreatorId, sizeof(ACPICreatorId));
    IdLength = strlen(CreatorId);
    if (IdLength > sizeof(ACPICreatorId)) {
        IdLength = sizeof(ACPICreatorId);
    }
    RtlCopyMemory(ACPICreatorId, CreatorId, IdLength);
    if (RtlEqualMemory(ACPICreatorId, Header->CreatorID, sizeof(Header->CreatorID))) {
        return(TRUE);
    } else {
        return(FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\halnls.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\halnls.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\dynsysres.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    dynsysres.c

Abstract:

    This module contain functions which support dynamic system
    resources e.g. processors, memory, and I/O.  Among other things,
    it will contain code necessary to configure the OS for the
    'capacity' of a partition rather than the boot resources.

Author:

    Adam Glass

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"

#if defined(_WIN64) && !defined(_AMD64_)
#define HalpGetAcpiTablePhase0  HalpGetAcpiTable
#endif

PHYSICAL_ADDRESS HalpMaxHotPlugMemoryAddress;

VOID
HalpGetHotPlugMemoryInfo(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    PHYSICAL_ADDRESS Extent;
    PACPI_SRAT_ENTRY SratEntry;
    PACPI_SRAT_ENTRY SratEnd;
    PACPI_SRAT SratTable;

    SratTable = HalpGetAcpiTablePhase0(LoaderBlock, ACPI_SRAT_SIGNATURE);
    if (SratTable == NULL) {
        return;
    }

    //
    // The Static Resource Affinity Table (SRAT) exists.
    //
    // Scan it to determine if there are any hot plug memory regions.
    //

    SratEnd = (PACPI_SRAT_ENTRY)(((PUCHAR)SratTable) +
                                        SratTable->Header.Length);
    for (SratEntry = (PACPI_SRAT_ENTRY)(SratTable + 1);
         SratEntry < SratEnd;
         SratEntry = (PACPI_SRAT_ENTRY)(((PUCHAR) SratEntry) + SratEntry->Length)) {
        switch (SratEntry->Type) {
        case SratMemory:
            Extent.QuadPart = SratEntry->MemoryAffinity.Base.QuadPart +
                SratEntry->MemoryAffinity.Length;
            if (SratEntry->MemoryAffinity.Flags.HotPlug &&
                SratEntry->MemoryAffinity.Flags.Enabled &&
                (Extent.QuadPart > HalpMaxHotPlugMemoryAddress.QuadPart)) {
                HalpMaxHotPlugMemoryAddress = Extent;
            }
            break;
        }
    }
}

VOID
HalpDynamicSystemResourceConfiguration(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    HalpGetHotPlugMemoryInfo(LoaderBlock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixenvirv.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixenvirv.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixfirm.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixfirm.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixisa.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixisa.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixdat.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixdat.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixhwsup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixhwsup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixhalt.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    xxacpi.c

Abstract:

    Implements various ACPI utility functions.

Author:

    Jake Oshins (jakeo) 12-Feb-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"
#include <inbv.h>

extern PULONG KiBugCheckData;
SLEEP_STATE_CONTEXT     HalpShutdownContext;

VOID
HaliHaltSystem (
    VOID
    )
/*++

Routine Description:

    This procedure is called when the machine has crashed and is to be
        halted

    N.B.

        Will NOT return.

--*/
{
    for (; ;) {
        HalpCheckPowerButton();
        HalpYieldProcessor();
    }
}


VOID
HalpCheckPowerButton (
    VOID
    )
/*++

Routine Description:

    This procedure is called when the machine is spinning in the debugger,
    or has crashed and halted.

--*/
{
    USHORT                  Pm1Status, Pm1Control;
    SLEEP_STATE_CONTEXT     ShutdownContext;

    //
    // If there's been a bugcheck, or if the hal owns the display check
    // the fixed power button for an unconditional power off
    //

    if ((KiBugCheckData[0] || InbvCheckDisplayOwnership()) &&  HalpShutdownContext.AsULONG) {

        Pm1Status = READ_PORT_USHORT((PUSHORT) (ULONG_PTR)HalpFixedAcpiDescTable.pm1a_evt_blk_io_port);
        if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port) {
            Pm1Status |= READ_PORT_USHORT((PUSHORT) (ULONG_PTR)HalpFixedAcpiDescTable.pm1b_evt_blk_io_port);
        }

        //
        // If the fixed button has been pushed, power off the system
        //

        if (Pm1Status & PM1_PWRBTN_STS) {
            //
            // Only do this once
            //

            ShutdownContext = HalpShutdownContext;
            HalpShutdownContext.AsULONG = 0;

            //
            // Disable & eoi all wake events
            //

            AcpiEnableDisableGPEvents(FALSE);
            WRITE_PORT_USHORT((PUSHORT) (ULONG_PTR)HalpFixedAcpiDescTable.pm1a_evt_blk_io_port, Pm1Status);
            if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port) {
                WRITE_PORT_USHORT((PUSHORT) (ULONG_PTR)HalpFixedAcpiDescTable.pm1b_evt_blk_io_port, Pm1Status);
            }

            //
            // Power off
            //

            Pm1Control = READ_PORT_USHORT((PUSHORT) (ULONG_PTR)HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port);
            Pm1Control = (USHORT) ((Pm1Control & CTL_PRESERVE) | (ShutdownContext.bits.Pm1aVal << SLP_TYP_SHIFT) | SLP_EN);
            WRITE_PORT_USHORT ((PUSHORT) (ULONG_PTR)HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port, Pm1Control);

            if (HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port) {
                Pm1Control = READ_PORT_USHORT((PUSHORT) (ULONG_PTR)HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port);
                Pm1Control = (USHORT) ((Pm1Control & CTL_PRESERVE) | (ShutdownContext.bits.Pm1bVal << SLP_TYP_SHIFT) | SLP_EN);
                WRITE_PORT_USHORT ((PUSHORT) (ULONG_PTR)HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port, Pm1Control);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixinfo.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixinfo.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixisabus.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixisabus.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixisasup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixisasup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixmca.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixmca.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixnmi.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixnmi.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixpcibus.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixpcibus.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixphwsup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixphwsup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixsysbus.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixsysbus.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixslpsup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixslpsup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixreboot.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixreboot.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixpciint.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixpciint.c

Abstract:

    All PCI bus interrupt mapping is in this module, so that a real
    system which doesn't have all the limitations which PC PCI
    systems have can replaced this code easly.
    (bus memory & i/o address mappings can also be fix here)

Author:

    Ken Reneris

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"

ULONG   PciIsaIrq;
ULONG   HalpEisaELCR;
BOOLEAN HalpDoingCrashDump;
BOOLEAN HalpPciLockSettings;


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HalpGetPCIIntOnISABus)
#pragma alloc_text(PAGE,HalpAdjustPCIResourceList)
#pragma alloc_text(PAGE,HalpGetISAFixedPCIIrq)
#endif

VOID
HalpPCIPin2ISALine (
    IN PBUS_HANDLER          BusHandler,
    IN PBUS_HANDLER          RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    )
/*++

    This function maps the device's InterruptPin to an InterruptLine
    value.

    On the current PC implementations, the bios has already filled in
    InterruptLine as it's ISA value and there's no portable way to
    change it.

    On a DBG build we adjust InterruptLine just to ensure driver's
    don't connect to it without translating it on the PCI bus.

--*/
{
    if (!PciData->u.type0.InterruptPin) {
        return ;
    }

    //
    // Set vector as a level vector.  (note: this code assumes the
    // irq is static and does not move).
    //

    if (PciData->u.type0.InterruptLine >= 1  &&
        PciData->u.type0.InterruptLine <= 15) {

        //
        // If this bit was on the in the PIC ELCR register,
        // then mark it in PciIsaIrq.   (for use in hal.dll,
        // such that we can assume the interrupt controller
        // has been properly marked as a level interrupt for
        // this IRQ.  Other hals probabily don't care.)
        //

        PciIsaIrq |= HalpEisaELCR & (1 << PciData->u.type0.InterruptLine);
    }
}



VOID
HalpPCIISALine2Pin (
    IN PBUS_HANDLER          BusHandler,
    IN PBUS_HANDLER          RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciNewData,
    IN PPCI_COMMON_CONFIG   PciOldData
    )
/*++

    This functions maps the device's InterruptLine to it's
    device specific InterruptPin value.

    On the current PC implementations, this information is
    fixed by the BIOS.  Just make sure the value isn't being
    editted since PCI doesn't tell us how to dynically
    connect the interrupt.

--*/
{
}

#if !defined(SUBCLASSPCI)

VOID
HalpPCIAcquireType2Lock (
    PKSPIN_LOCK SpinLock,
    PKIRQL      Irql
    )
{
    if (!HalpDoingCrashDump) {
        *Irql = KfRaiseIrql (HIGH_LEVEL);
        KiAcquireSpinLock (SpinLock);
    } else {
        *Irql = HIGH_LEVEL;
    }
}


VOID
HalpPCIReleaseType2Lock (
    PKSPIN_LOCK SpinLock,
    KIRQL       Irql
    )
{
    if (!HalpDoingCrashDump) {
        KiReleaseSpinLock (SpinLock);
        KeLowerIrql (Irql);
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixpnpdrv.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixpnpdrv.c

Abstract:

    Implements functionality necessary for the
    HAL to become a PnP-style device driver
    after system initialization.  This is done
    so that the HAL can enumerate the ACPI driver
    in the way that the PnP stuff expects.

Author:

    Jake Oshins (jakeo) 27-Jan-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "exboosts.h"
#include "wchar.h"
#include "xxacpi.h"

//
// Cause the GUID to be defined.
//

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
#include "initguid.h"
#include "wdmguid.h"
#include "halpnpp.h"
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA

#if DBG
ULONG HalDebug = 0;
#endif


extern WCHAR HalHardwareIdString[];
#if defined(NT_UP) && defined(APIC_HAL)
extern WCHAR MpHalHardwareIdString[];
#endif

typedef enum {
    Hal = 0x80,
    AcpiDriver,
    WdDriver
} PDO_TYPE;

typedef enum {
    PdoExtensionType = 0xc0,
    FdoExtensionType
} EXTENSION_TYPE;

typedef struct _PDO_EXTENSION *PPDO_EXTENSION;
typedef struct _FDO_EXTENSION *PFDO_EXTENSION;

typedef struct _PDO_EXTENSION{
    EXTENSION_TYPE                  ExtensionType;
    PPDO_EXTENSION                  Next;
    PDEVICE_OBJECT                  PhysicalDeviceObject;
    PFDO_EXTENSION                  ParentFdoExtension;
    PDO_TYPE                        PdoType;
    //
    // Only valid if PdoType == WdDriver
    //
    PWATCHDOG_TIMER_RESOURCE_TABLE  WdTable;
} PDO_EXTENSION, *PPDO_EXTENSION;

#define ASSERT_PDO_EXTENSION(x) ASSERT((x)->ExtensionType == PdoExtensionType );

typedef struct _FDO_EXTENSION{
    EXTENSION_TYPE        ExtensionType;
    PPDO_EXTENSION        ChildPdoList;
    PDEVICE_OBJECT        PhysicalDeviceObject;  // PDO passed into AddDevice()
    PDEVICE_OBJECT        FunctionalDeviceObject;
    PDEVICE_OBJECT        AttachedDeviceObject;
} FDO_EXTENSION, *PFDO_EXTENSION;

#define ASSERT_FDO_EXTENSION(x) ASSERT((x)->ExtensionType == FdoExtensionType );

INT_ROUTE_INTERFACE_STANDARD PciIrqRoutingInterface = {0};

NTSTATUS
HalpDriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
HalpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
HalpDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
HalpDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
HalpDispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
HalpQueryDeviceRelations(
    IN PDEVICE_OBJECT       DeviceObject,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS *DeviceRelations
    );

NTSTATUS
HalpQueryIdPdo(
    IN PDEVICE_OBJECT PdoExtension,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    );

NTSTATUS
HalpQueryIdFdo(
    IN PDEVICE_OBJECT PdoExtension,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    );

NTSTATUS
HalpQueryCapabilities(
    IN PDEVICE_OBJECT PdoExtension,
    IN PDEVICE_CAPABILITIES Capabilities
    );

NTSTATUS
HalpQueryResources(
    PDEVICE_OBJECT DeviceObject,
    PCM_RESOURCE_LIST *Resources
    );

NTSTATUS
HalpQueryResourceRequirements(
    PDEVICE_OBJECT DeviceObject,
    PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    );

NTSTATUS
HalpQueryInterface(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG_PTR       Length
    );

#if defined(_WIN64)

//
//  Define the PNP interface functions.
//

VOID
HalPnpInterfaceReference(
    PVOID Context
    );

VOID
HalPnpInterfaceDereference(
    PVOID Context
    );

struct _DMA_ADAPTER *
HalPnpGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    );

#endif  // _WIN64


NTSTATUS
HalIrqTranslateResourcesRoot(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
);

NTSTATUS
HalIrqTranslateResourceRequirementsRoot(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
);

VOID
HalpMaskAcpiInterrupt(
    VOID
    );

VOID
HalpUnmaskAcpiInterrupt(
    VOID
    );

// from xxacpi.c
NTSTATUS
HalpQueryAcpiResourceRequirements(
    IN  PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    );

NTSTATUS
HalpOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    );

PVOID
HalpGetAcpiTable(
  IN  ULONG  Signature
  );

#ifdef ACPI_CMOS_ACTIVATE
VOID
HalpCmosNullReference(
    PVOID Context
    );

VOID
HalpCmosNullDereference(
    PVOID Context
    );
#endif // ACPI_CMOS_ACTIVATE

#define HAL_DRIVER_NAME  L"\\Driver\\ACPI_HAL"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HaliInitPnpDriver)
#pragma alloc_text(PAGE, HalpOpenRegistryKey)
#pragma alloc_text(PAGE, HalpDriverEntry)
#pragma alloc_text(PAGE, HalpAddDevice)
#pragma alloc_text(PAGE, HalpDispatchPnp)
#pragma alloc_text(PAGELK, HalpDispatchPower)
#pragma alloc_text(PAGE, HalpDispatchWmi)
#pragma alloc_text(PAGE, HalpQueryDeviceRelations)
#pragma alloc_text(PAGE, HalpQueryIdPdo)
#pragma alloc_text(PAGE, HalpQueryIdFdo)
#pragma alloc_text(PAGE, HalpQueryCapabilities)
#pragma alloc_text(PAGE, HalpQueryResources)
#pragma alloc_text(PAGE, HalpQueryResourceRequirements)
#pragma alloc_text(PAGE, HalpQueryInterface)
#endif

PDRIVER_OBJECT HalpDriverObject;


NTSTATUS
HaliInitPnpDriver(
    VOID
    )
/*++

Routine Description:

    This routine starts the process of making the HAL into
    a "driver," which is necessary because we need to
    enumerate a Plug and Play PDO for the ACPI driver.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{

    UNICODE_STRING  DriverName;
    NTSTATUS Status;

    PAGED_CODE();

    RtlInitUnicodeString( &DriverName, HAL_DRIVER_NAME );

    Status = IoCreateDriver( &DriverName, HalpDriverEntry );

    ASSERT( NT_SUCCESS( Status ));

    return Status;

}

NTSTATUS
HalpOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    )

/*++

Routine Description:

    Opens or creates a VOLATILE registry key using the name passed in based
    at the BaseHandle node.

Arguments:

    Handle - Pointer to the handle which will contain the registry key that
        was opened.

    BaseHandle - Handle to the base path from which the key must be opened.

    KeyName - Name of the Key that must be opened/created.

    DesiredAccess - Specifies the desired access that the caller needs to
        the key.

    Create - Determines if the key is to be created if it does not exist.

Return Value:

   The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;

    PAGED_CODE();

    //
    // Initialize the object for the key.
    //

    InitializeObjectAttributes( &objectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE,
                                BaseHandle,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Create the key or open it, as appropriate based on the caller's
    // wishes.
    //

    if (Create) {
        return ZwCreateKey( Handle,
                            DesiredAccess,
                            &objectAttributes,
                            0,
                            (PUNICODE_STRING) NULL,
                            REG_OPTION_VOLATILE,
                            &disposition );
    } else {
        return ZwOpenKey( Handle,
                          DesiredAccess,
                          &objectAttributes );
    }
}

NTSTATUS
HalpDriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the callback function when we call IoCreateDriver to create a
    PnP Driver Object.  In this function, we need to remember the DriverObject.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

    RegistryPath - is NULL.

Return Value:

   STATUS_SUCCESS

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT detectedDeviceObject = NULL;
    ANSI_STRING    AKeyName;

    PAGED_CODE();

    //
    // File the pointer to our driver object away
    //
    HalpDriverObject = DriverObject;

    //
    // Fill in the driver object
    //
    DriverObject->DriverExtension->AddDevice = (PDRIVER_ADD_DEVICE)HalpAddDevice;
    DriverObject->MajorFunction[ IRP_MJ_PNP ] = HalpDispatchPnp;
    DriverObject->MajorFunction[ IRP_MJ_POWER ] = HalpDispatchPower;
    DriverObject->MajorFunction[ IRP_MJ_SYSTEM_CONTROL ] = HalpDispatchWmi;

    status = IoReportDetectedDevice(DriverObject,
                                    InterfaceTypeUndefined,
                                    -1,
                                    -1,
                                    NULL,
                                    NULL,
                                    FALSE,
                                    &detectedDeviceObject);

    ASSERT(detectedDeviceObject);
    if (!(NT_SUCCESS(status))) {
        return status;
    }

    HalpAddDevice(DriverObject,
                  detectedDeviceObject);

    return STATUS_SUCCESS;

}

NTSTATUS
HalpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine handles AddDevice for an madeup PDO device.

Arguments:

    DriverObject - Pointer to our pseudo driver object.

    DeviceObject - Pointer to the device object for which this requestapplies.

Return Value:

    NT status.

--*/
{
    PDEVICE_OBJECT functionalDeviceObject;
    PDEVICE_OBJECT acpiChildDeviceObject;
    PDEVICE_OBJECT wdChildDeviceObject;
    PDEVICE_OBJECT AttachedDevice;
    NTSTATUS       status;
    PFDO_EXTENSION FdoExtension;
    PPDO_EXTENSION AcpiPdoExtension;
    PPDO_EXTENSION WdPdoExtension;
    PWATCHDOG_TIMER_RESOURCE_TABLE WdTable;

    PAGED_CODE();

    //
    // We've been given the PhysicalDeviceObject.  Create the
    // FunctionalDeviceObject.  Our FDO will be nameless.
    //

    status = IoCreateDevice(
                DriverObject,               // our driver object
                sizeof(FDO_EXTENSION),      // size of our extension
                NULL,                       // our name
                FILE_DEVICE_BUS_EXTENDER,   // device type
                0,                          // device characteristics
                FALSE,                      // not exclusive
                &functionalDeviceObject     // store new device object here
                );

    if( !NT_SUCCESS( status )){

        DbgBreakPoint();
        return status;
    }

    //
    // Fill in the FDO extension
    //
    FdoExtension = (PFDO_EXTENSION)functionalDeviceObject->DeviceExtension;
    FdoExtension->ExtensionType = FdoExtensionType;
    FdoExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    FdoExtension->FunctionalDeviceObject = functionalDeviceObject;

    functionalDeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING);

    //
    // Now attach to the PDO we were given.
    //

    AttachedDevice = IoAttachDeviceToDeviceStack(functionalDeviceObject,
                                                 PhysicalDeviceObject );
    if(AttachedDevice == NULL){

        //
        // Couldn't attach.  Delete the FDO.
        //

        IoDeleteDevice( functionalDeviceObject );

        return STATUS_NO_SUCH_DEVICE;

    }

    FdoExtension->AttachedDeviceObject = AttachedDevice;

    //
    // Next, create a PDO for the ACPI driver.
    //
    status = IoCreateDevice(
                DriverObject,               // our driver object
                sizeof(PDO_EXTENSION),      // size of our extension
                NULL,                       // our name
                FILE_DEVICE_BUS_EXTENDER,   // device type
                FILE_AUTOGENERATED_DEVICE_NAME, // device characteristics
                FALSE,                      // not exclusive
                &acpiChildDeviceObject      // store new device object here
                );

    if (!NT_SUCCESS(status)) {
        HalPrint(("Could not create ACPI device object status=0x%08x",status));
        return status;
    }

    //
    // Fill in the PDO extension
    //
    AcpiPdoExtension = (PPDO_EXTENSION)acpiChildDeviceObject->DeviceExtension;
    AcpiPdoExtension->ExtensionType = PdoExtensionType;
    AcpiPdoExtension->Next = NULL;
    AcpiPdoExtension->PhysicalDeviceObject = acpiChildDeviceObject;
    AcpiPdoExtension->ParentFdoExtension = FdoExtension;
    AcpiPdoExtension->PdoType = AcpiDriver;

    //
    // Look for the watchdog timer ACPI table
    // and if it is found then eject a PDO to handle the device
    //
    WdTable = (PWATCHDOG_TIMER_RESOURCE_TABLE) HalpGetAcpiTable( WDTT_SIGNATURE );
    if (WdTable) {

        //
        // Next, create a PDO for the WD driver.
        //
        status = IoCreateDevice(
                    DriverObject,               // our driver object
                    sizeof(PDO_EXTENSION),      // size of our extension
                    NULL,                       // our name
                    FILE_DEVICE_BUS_EXTENDER,   // device type
                    FILE_AUTOGENERATED_DEVICE_NAME, // device characteristics
                    FALSE,                      // not exclusive
                    &wdChildDeviceObject        // store new device object here
                    );

        if (!NT_SUCCESS(status)) {
            HalPrint(("Could not create WD device object status=0x%08x",status));
            IoDeleteDevice( acpiChildDeviceObject );
            return status;
        }

        //
        // Fill in the PDO extension
        //
        WdPdoExtension = (PPDO_EXTENSION)wdChildDeviceObject->DeviceExtension;
        WdPdoExtension->ExtensionType = PdoExtensionType;
        WdPdoExtension->Next = NULL;
        WdPdoExtension->PhysicalDeviceObject = wdChildDeviceObject;
        WdPdoExtension->ParentFdoExtension = FdoExtension;
        WdPdoExtension->PdoType = WdDriver;
        WdPdoExtension->WdTable = WdTable;

        //
        // Link in the device extension
        //
        AcpiPdoExtension->Next = WdPdoExtension;

        wdChildDeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING);
    }

    acpiChildDeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING);

    //
    // Record this as a child of the HAL
    //
    FdoExtension->ChildPdoList = AcpiPdoExtension;

    return STATUS_SUCCESS;
}

NTSTATUS
HalpPassIrpFromFdoToPdo(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Description:

    Given an FDO, pass the IRP to the next device object in the
    device stack.  This is the PDO if there are no lower level
    filters.

Arguments:

    DeviceObject - the Fdo
    Irp - the request

Return Value:

    Returns the result from calling the next level.

--*/

{

    PIO_STACK_LOCATION irpSp;       // our stack location
    PIO_STACK_LOCATION nextIrpSp;   // next guy's
    PFDO_EXTENSION     fdoExtension;

    //
    // Get the pointer to the device extension.
    //

    fdoExtension = (PFDO_EXTENSION)DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);

    //
    // Call the PDO driver with the request.
    //

    return IoCallDriver(fdoExtension->AttachedDeviceObject ,Irp);
}

NTSTATUS
HalpDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_PNP IRPs for madeup PDO device.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    ULONG length;
    DEVICE_RELATION_TYPE relationType;
    EXTENSION_TYPE  extensionType;
    BOOLEAN passDown;
#if DBG
    PUCHAR objectTypeString;
#endif //DBG

    PAGED_CODE();

    extensionType = ((PFDO_EXTENSION)(DeviceObject->DeviceExtension))->ExtensionType;

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    status = Irp->IoStatus.Status;
    switch (extensionType) {

    case PdoExtensionType:

#if DBG
        objectTypeString = "PDO";
#endif //DBG

        switch (irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:

            HalPrint(("HAL: (%s) Start_Device Irp received\n",
                      objectTypeString));

            //
            // If we get a start device request for a PDO, we simply
            // return success.
            //

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_STOP_DEVICE:

            HalPrint(("(%s) Query_Stop_Device Irp received",
                       objectTypeString));

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_CANCEL_STOP_DEVICE:

            HalPrint(("(%s) Cancel_Stop_Device Irp received",
                       objectTypeString));

            status = STATUS_SUCCESS;
            break;


        case IRP_MN_STOP_DEVICE:

            HalPrint(("HAL: (%s) Stop_Device Irp received\n",
                      objectTypeString));

            //
            // If we get a stop device request for a PDO, we simply
            // return success.
            //

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_RESOURCES:

            HalPrint(("HAL: (%s) Query_Resources Irp received\n",
                      objectTypeString));

            status = HalpQueryResources(DeviceObject,
                         (PCM_RESOURCE_LIST*)&Irp->IoStatus.Information);

            break;

        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:

            HalPrint(("HAL: (%s) Query_Resource_Requirements Irp received\n",
                      objectTypeString));

            status = HalpQueryResourceRequirements(DeviceObject,
                         (PIO_RESOURCE_REQUIREMENTS_LIST*)&Irp->IoStatus.Information);
            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:

            HalPrint(("(%s) Query_Remove_device Irp for %x",
                       objectTypeString,
                       DeviceObject));

            status = STATUS_UNSUCCESSFUL;
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:

            HalPrint(("(%s) Cancel_Remove_device Irp for %x",
                       objectTypeString,
                       DeviceObject));

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_REMOVE_DEVICE:

            HalPrint(("HAL: (%s) Remove_device Irp for PDO %x\n",
                      objectTypeString,
                      DeviceObject));

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            HalPrint(("HAL: (%s) Query_Device_Relations Irp received\n",
                      objectTypeString));

            relationType = irpSp->Parameters.QueryDeviceRelations.Type;
            status = HalpQueryDeviceRelations(DeviceObject,
                                              relationType,
                                              (PDEVICE_RELATIONS*)&Irp->IoStatus.Information);
            break;


        case IRP_MN_QUERY_ID:

            HalPrint(("HAL: (%s) Query_Id Irp received\n",
                      objectTypeString));

            status = HalpQueryIdPdo(DeviceObject,
                                 irpSp->Parameters.QueryId.IdType,
                                 (PWSTR*)&Irp->IoStatus.Information);

            break;

        case IRP_MN_QUERY_INTERFACE:

            HalPrint(("HAL: (%s) Query_Interface Irp received\n",
                  objectTypeString));

            status = HalpQueryInterface(
                DeviceObject,
                irpSp->Parameters.QueryInterface.InterfaceType,
                irpSp->Parameters.QueryInterface.Version,
                irpSp->Parameters.QueryInterface.InterfaceSpecificData,
                irpSp->Parameters.QueryInterface.Size,
                irpSp->Parameters.QueryInterface.Interface,
                &Irp->IoStatus.Information
                );
            break;

        case IRP_MN_QUERY_CAPABILITIES:

            HalPrint(("HAL: (%s) Query_Capabilities Irp received\n",
                      objectTypeString));

            status = HalpQueryCapabilities(DeviceObject,
                                           irpSp->Parameters.DeviceCapabilities.Capabilities);

            break;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            HalPrint(("HAL: DEVICE_USAGE Irp received\n"));
            status = STATUS_SUCCESS;
            break;

        default:

            HalPrint(("HAL: (%s) Unsupported Irp (%d) received\n",
                      objectTypeString,
                      irpSp->MinorFunction));
            status = STATUS_NOT_SUPPORTED ;
            break;
        }

        break;  // end PDO cases

    case FdoExtensionType:

#if DBG
        objectTypeString = "FDO";
#endif //DBG
        passDown = TRUE;

        //
        // In case we don't touch this IRP, save the current status.
        //

        switch (irpSp->MinorFunction) {

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            HalPrint(("HAL: (%s) Query_Device_Relations Irp received\n",
                  objectTypeString));

            relationType = irpSp->Parameters.QueryDeviceRelations.Type;
            status = HalpQueryDeviceRelations(DeviceObject,
                                              relationType,
                                              (PDEVICE_RELATIONS*)&Irp->IoStatus.Information);
            break;

        case IRP_MN_QUERY_INTERFACE:

            HalPrint(("HAL: (%s) Query_Interface Irp received\n",
                  objectTypeString));

            status = HalpQueryInterface(
                DeviceObject,
                irpSp->Parameters.QueryInterface.InterfaceType,
                irpSp->Parameters.QueryInterface.Version,
                irpSp->Parameters.QueryInterface.InterfaceSpecificData,
                irpSp->Parameters.QueryInterface.Size,
                irpSp->Parameters.QueryInterface.Interface,
                &Irp->IoStatus.Information
                );

            break;

        case IRP_MN_QUERY_ID:

            HalPrint(("HAL: (%s) Query_Id Irp received\n",
                  objectTypeString));

            status = HalpQueryIdFdo(DeviceObject,
                                 irpSp->Parameters.QueryId.IdType,
                                 (PWSTR*)&Irp->IoStatus.Information);

            break;

        default:

            //
            // Ignore any PNP Irps unknown by the FDO but allow them
            // down to the PDO.
            //

            status = STATUS_NOT_SUPPORTED ;
            break;
        }

        if (passDown && (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED))) {

            //
            // Pass FDO IRPs down to the PDO.
            //
            // Set Irp status first.
            //
            if (status != STATUS_NOT_SUPPORTED) {

                Irp->IoStatus.Status = status;
            }

            HalPrint(("HAL: (%s) Passing down Irp (%x)\n",
                      objectTypeString, irpSp->MinorFunction));
            return HalpPassIrpFromFdoToPdo(DeviceObject, Irp);
        }

        break;  // end FDO cases

    default:

        HalPrint(( "HAL: Received IRP for unknown Device Object\n"));
        status = STATUS_INVALID_DEVICE_REQUEST ;
        break;

    }

    //
    // Complete the Irp and return.
    //

    if (status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = status;

    } else {

        status = Irp->IoStatus.Status ;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
HalpDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_POWER IRPs for madeup PDO device.
    Note: We don't actually handle any Power IRPs at this level so
    all we do is return the status from the incoming IRP.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    NTSTATUS Status;
    EXTENSION_TYPE  extensionType;
    PIO_STACK_LOCATION irpSp;

    HalPrint(("Hal:  Power IRP for DevObj: %x\n", DeviceObject));


    extensionType = ((PFDO_EXTENSION)(DeviceObject->DeviceExtension))->ExtensionType;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Simply store the appropriate status and complete the request.
    //

    Status = Irp->IoStatus.Status;

    PoStartNextPowerIrp(Irp);

    if (extensionType == FdoExtensionType) {

        switch (irpSp->MinorFunction) {
        case IRP_MN_SET_POWER:

            if (irpSp->Parameters.Power.Type == SystemPowerState) {

                switch (irpSp->Parameters.Power.State.SystemState) {
                case PowerSystemSleeping1:
                case PowerSystemSleeping2:
                case PowerSystemSleeping3:
                case PowerSystemHibernate:

                    //
                    // Allocate structures used for starting up
                    // processors while resuming from sleep.
                    //

                    HalpBuildResumeStructures();

                    HalpMaskAcpiInterrupt();

                    break;

                case PowerSystemWorking:

                    HalpUnmaskAcpiInterrupt();

                    //
                    // Free structures used for starting up
                    // processors while resuming from sleep.
                    //

                    HalpFreeResumeStructures();

                    break;

                default:
                    break;
                }
            }

            //
            // Fall through.
            //

        case IRP_MN_QUERY_POWER:

            Irp->IoStatus.Status = Status = STATUS_SUCCESS;

            //
            // Fall through.
            //

        default:

            Status = HalpPassIrpFromFdoToPdo(DeviceObject, Irp);
            break;
        }

    } else {

        switch (irpSp->MinorFunction) {
        case IRP_MN_SET_POWER:
        case IRP_MN_QUERY_POWER:

            Irp->IoStatus.Status = Status = STATUS_SUCCESS;

            //
            // Fall through.
            //

        default:
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            break;
        }
    }

    return Status;
}

NTSTATUS
HalpDispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS Status;
    EXTENSION_TYPE  extensionType;

    extensionType = ((PFDO_EXTENSION)(DeviceObject->DeviceExtension))->ExtensionType;

    if (extensionType == FdoExtensionType) {
        Status = HalpPassIrpFromFdoToPdo(DeviceObject, Irp);
    } else {
        Status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return Status;
}

NTSTATUS
HalpQueryDeviceRelations(
    IN PDEVICE_OBJECT       DeviceObject,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS   *DeviceRelations
    )
/*++

Routine Description:

    This routine builds a DEVICE_RELATIONS structure that
    tells the PnP manager how many children we have.

Arguments:

    DeviceObject - FDO of ACPI_HAL

    RelationType - we only respond to BusRelations

    DeviceRelations - pointer to the structure

Return Value:

    status

--*/
{
    PFDO_EXTENSION      FdoExtension;
    PDEVICE_RELATIONS   relations = NULL;
    ULONG               relationsCount = 0;
    EXTENSION_TYPE      extensionType;
    ULONG               i;
    PPDO_EXTENSION      Next;
    NTSTATUS            Status = STATUS_NOT_SUPPORTED;

    PAGED_CODE();

    FdoExtension = (PFDO_EXTENSION)DeviceObject->DeviceExtension;
    extensionType = FdoExtension->ExtensionType;

    switch(RelationType) {

        case BusRelations:
            if (extensionType == FdoExtensionType) {
                Next = FdoExtension->ChildPdoList;
                while (Next) {
                    relationsCount += 1;
                    Next = Next->Next;
                }

                relations = ExAllocatePoolWithTag(
                    PagedPool,
                    sizeof(DEVICE_RELATIONS) * relationsCount,
                    HAL_POOL_TAG
                    );
                if (relations == NULL) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                relations->Count = relationsCount;

                i = 0;
                Next = FdoExtension->ChildPdoList;
                while (Next) {
                    relations->Objects[i] = Next->PhysicalDeviceObject;
                    ObReferenceObject( relations->Objects[i] );
                    i += 1;
                    Next = Next->Next;
                }

                *DeviceRelations = relations;
                return STATUS_SUCCESS;
            }
            break;

        case TargetDeviceRelation:
            if (extensionType == PdoExtensionType) {
                relations = ExAllocatePoolWithTag(
                    PagedPool,
                    sizeof(DEVICE_RELATIONS),
                    HAL_POOL_TAG
                    );
                if (relations == NULL) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                relations->Count = 1;
                relations->Objects[0] = DeviceObject;

                ObReferenceObject( relations->Objects[0] );
                *DeviceRelations = relations;
                return STATUS_SUCCESS;
            }
            break;
    }

    return Status;
}

NTSTATUS
HalpQueryIdPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    )
/*++

Routine Description:

    This routine identifies each of the children that were
    enumerated in HalpQueryDeviceRelations.

Arguments:

    DeviceObject - PDO of the child

    IdType - the type of ID to be returned, currently ignored

    BusQueryId - pointer to the wide string being returned

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PWSTR idString;
    PWCHAR sourceString;
    ULONG stringLen;
    static WCHAR AcpiHardwareIdString[] = L"ACPI_HAL\\PNP0C08\0*PNP0C08";
    static WCHAR AcpiCompatibleString[] = L"*PNP0C08";
    static WCHAR AcpiInstanceIdString[] = L"0";
    static WCHAR WdHardwareIdString[] = L"ACPI_HAL\\PNP0C18\0*PNP0C18";
    static WCHAR WdCompatibleString[] = L"*PNP0C18";

    PAGED_CODE();

    switch (IdType) {
    case BusQueryDeviceID:
    case BusQueryHardwareIDs:

        switch (PdoExtension->PdoType) {
        case AcpiDriver:
            sourceString = AcpiHardwareIdString;
            stringLen = sizeof(AcpiHardwareIdString);
            break;

        case WdDriver:
            HalPrint(("ID query for WD timer device"));
            sourceString = WdHardwareIdString;
            stringLen = sizeof(WdHardwareIdString);
            break;

        default:
            return STATUS_NOT_SUPPORTED;

        }
        break;

    case BusQueryCompatibleIDs:
        return STATUS_NOT_SUPPORTED;
        break;

    case BusQueryInstanceID:
        sourceString = AcpiInstanceIdString;
        stringLen = sizeof(AcpiInstanceIdString);
        break;

    default:
        return STATUS_NOT_SUPPORTED;
    }

    idString = ExAllocatePoolWithTag(PagedPool,
                                     stringLen + sizeof(UNICODE_NULL),
                                     HAL_POOL_TAG);

    if (!idString) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(idString,
                  sourceString, stringLen);

    *(idString + stringLen / sizeof(WCHAR)) = UNICODE_NULL;

    *BusQueryId = idString;

    return STATUS_SUCCESS;
}
NTSTATUS
HalpQueryIdFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    )
/*++

Routine Description:

    This routine identifies each of the children that were
    enumerated in HalpQueryDeviceRelations.

Arguments:

    DeviceObject - PDO of the child

    IdType - the type of ID to be returned.

    BusQueryId - pointer to the wide string being returned

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PWSTR idString;
    PWCHAR sourceString = NULL;
    ULONG stringLen;
    UNICODE_STRING String;
    WCHAR Buffer[16];
    NTSTATUS Status;
    PWCHAR widechar;
    static WCHAR HalInstanceIdString[] = L"0";

    PAGED_CODE();

    switch (IdType) {
    case BusQueryDeviceID:
    case BusQueryHardwareIDs:

        //
        // For the UP version of the APIC HAL, we want to detect if there is more
        // than one processor installed. If so, we want to return the ID of
        // the MP HAL rather than the UP HAL. This will induce PNP to reconfigure
        // our devnode and setup the MP HAL for the next boot.
        //

        sourceString = HalHardwareIdString;
#if defined(NT_UP) && defined(APIC_HAL)
        if (HalpMpInfoTable.ProcessorCount > 1) {
            sourceString = MpHalHardwareIdString;
        }
#endif
        widechar = sourceString;
        while (*widechar != UNICODE_NULL) {
            widechar++;
        }
        stringLen =  (ULONG)((PUCHAR)widechar - ((PUCHAR)sourceString) + 2);

        break;

    case BusQueryInstanceID:

        sourceString = HalInstanceIdString;
        stringLen = sizeof(HalInstanceIdString);
        break;

    default:
        break;
    }
    if (sourceString) {

        //
        // Note that hardware IDs and compatible IDs must be terminated by
        // 2 NULLs.
        //

        idString = ExAllocatePoolWithTag(PagedPool,
                                         stringLen + sizeof(UNICODE_NULL),
                                         HAL_POOL_TAG);

        if (!idString) {
            HalPrint(( "HalpQueryIdFdo: couldn't allocate pool\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(idString,
                      sourceString, stringLen);

        *(idString + stringLen / sizeof(WCHAR)) = UNICODE_NULL;

        *BusQueryId = idString;

        return STATUS_SUCCESS;
    } else {
        return STATUS_NOT_SUPPORTED;
    }
}

NTSTATUS
HalpQueryCapabilities(
    IN PDEVICE_OBJECT PdoExtension,
    IN PDEVICE_CAPABILITIES Capabilities
    )
/*++

Routine Description:

    This routine fills in the DEVICE_CAPABILITIES structure for
    a device.

Arguments:

    DeviceObject - PDO of the child

    Capabilities - pointer to the structure to be filled in.

Return Value:

    status

--*/
{
    PAGED_CODE();

    ASSERT(Capabilities->Version == 1);
    if (Capabilities->Version != 1) {

        return STATUS_NOT_SUPPORTED;

    }

    Capabilities->LockSupported = FALSE;
    Capabilities->EjectSupported = FALSE;
    Capabilities->Removable = FALSE;
    Capabilities->DockDevice = FALSE;
    Capabilities->UniqueID = TRUE;
    Capabilities->SilentInstall = TRUE;
    Capabilities->RawDeviceOK = FALSE;
    Capabilities->Address = 0xffffffff;
    Capabilities->UINumber = 0xffffffff;
    Capabilities->D1Latency = 0;
    Capabilities->D2Latency = 0;
    Capabilities->D3Latency = 0;

    //
    // Default S->D mapping
    //
    Capabilities->DeviceState[PowerSystemWorking] = PowerDeviceD0;
    Capabilities->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
    Capabilities->DeviceState[PowerSystemShutdown] = PowerDeviceD3;

    return STATUS_SUCCESS;
}


NTSTATUS
HalpQueryResources(
    PDEVICE_OBJECT DeviceObject,
    PCM_RESOURCE_LIST *Resources
    )
{
    PIO_RESOURCE_REQUIREMENTS_LIST requirements;
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PIO_RESOURCE_DESCRIPTOR descriptor;
    PCM_RESOURCE_LIST cmResList;
    NTSTATUS status;
    ULONG i;

    PAGED_CODE();

    if (PdoExtension->PdoType == AcpiDriver) {

        //
        // The whole point behind creating a boot config for the
        // ACPI PDO is that the PnP Manager will not terminate
        // its algorithm that tries to reserve boot configs for
        // all of ACPI's children.  So it is not necessary that
        // ACPI have a complicated list of resources in its boot
        // config.  We'll be happy with just the IRQ.
        //
        // N.B.  At the time of this writing, it should also be
        // true that the IRQ is the only resource that the ACPI
        // claims anyhow.
        //

        status = HalpQueryAcpiResourceRequirements(&requirements);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        cmResList = ExAllocatePoolWithTag(PagedPool,
                                          sizeof(CM_RESOURCE_LIST),
                                          HAL_POOL_TAG);

        if (!cmResList) {
            ExFreePool(requirements);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(cmResList, sizeof(CM_RESOURCE_LIST));

        cmResList->Count = 1;
        cmResList->List[0].InterfaceType = PNPBus;
        cmResList->List[0].BusNumber = -1;
        cmResList->List[0].PartialResourceList.Version = 1;
        cmResList->List[0].PartialResourceList.Revision = 1;
        cmResList->List[0].PartialResourceList.Count = 1;
        cmResList->List[0].PartialResourceList.PartialDescriptors[0].Type =
            CmResourceTypeInterrupt;

        ASSERT(requirements->AlternativeLists == 1);

        for (i = 0; i < requirements->List[0].Count; i++) {

            descriptor = &requirements->List[0].Descriptors[i];

            if (descriptor->Type == CmResourceTypeInterrupt) {

                cmResList->List[0].PartialResourceList.PartialDescriptors[0].ShareDisposition =
                    descriptor->ShareDisposition;
                cmResList->List[0].PartialResourceList.PartialDescriptors[0].Flags =
                    descriptor->Flags;

                ASSERT(descriptor->u.Interrupt.MinimumVector ==
                       descriptor->u.Interrupt.MaximumVector);

                cmResList->List[0].PartialResourceList.PartialDescriptors[0].u.Interrupt.Level =
                    descriptor->u.Interrupt.MinimumVector;

                cmResList->List[0].PartialResourceList.PartialDescriptors[0].u.Interrupt.Vector =
                    descriptor->u.Interrupt.MinimumVector;

                cmResList->List[0].PartialResourceList.PartialDescriptors[0].u.Interrupt.Affinity = -1;

                *Resources = cmResList;

                ExFreePool(requirements);
                return STATUS_SUCCESS;
            }
        }

        ExFreePool(requirements);
        ExFreePool(cmResList);
        return STATUS_NOT_FOUND;


    } else if (PdoExtension->PdoType == WdDriver) {

        return STATUS_SUCCESS;

    } else {
        return STATUS_NOT_SUPPORTED;
    }
}


NTSTATUS
HalpQueryResourceRequirements(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    )
/*++

Routine Description:

    This routine handles IRP_MN_QUERY_RESOURCE_REQUIREMENTS.

Arguments:

    DeviceObject - PDO of the child

    Requirements - pointer to be filled in with the devices
        resource requirements.

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;


    PAGED_CODE();
    if (PdoExtension->PdoType == AcpiDriver) {

        return HalpQueryAcpiResourceRequirements(Requirements);

    } else if (PdoExtension->PdoType == WdDriver) {

        return STATUS_SUCCESS;

    } else {

        return STATUS_NOT_SUPPORTED;

    }
}

NTSTATUS
HalpQueryInterface(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG_PTR       Length
    )

/*++

Routine Description:

    This routine fills in the interface structure for
    a device.

Arguments:

    DeviceObject - PDO of the child

    InterfaceType - Pointer to the interface type GUID.

    Version - Supplies the requested interface version.

    InterfaceSpecificData - This is context that means something based on the
                            interface.

    InterfaceBufferSize - Supplies the length of the buffer for the interface
                          structure.

    Interface - Supplies a pointer where the interface informaiton should
                be returned.

    Length - This value is updated on return to actual number of bytes modified.

Return Value:

    status

--*/
{
#if defined(_WIN64)

    PPDO_EXTENSION  PdoExtension;

    PdoExtension = DeviceObject->DeviceExtension;
    if (PdoExtension->ExtensionType != PdoExtensionType) {
        PdoExtension = NULL;
    }

    if (PdoExtension != NULL &&
        IsEqualGUID(&GUID_BUS_INTERFACE_STANDARD, InterfaceType)) {

        PBUS_INTERFACE_STANDARD standard = (PBUS_INTERFACE_STANDARD)Interface;

        //
        // ASSERT we know about all of the fields in the structure.
        //

        ASSERT(sizeof(BUS_INTERFACE_STANDARD) == FIELD_OFFSET(BUS_INTERFACE_STANDARD, GetBusData) + sizeof(PGET_SET_DEVICE_DATA));

        *Length = sizeof(BUS_INTERFACE_STANDARD);

        if (InterfaceBufferSize < sizeof(BUS_INTERFACE_STANDARD)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        //  The only version this code knows about is 1.
        //

        standard->Size = sizeof(BUS_INTERFACE_STANDARD);
        standard->Version = HAL_BUS_INTERFACE_STD_VERSION;
        standard->Context = DeviceObject;

        standard->InterfaceReference = HalPnpInterfaceReference;
        standard->InterfaceDereference = HalPnpInterfaceDereference;
        standard->TranslateBusAddress = NULL;   // BUGBUG
        standard->GetDmaAdapter = HalPnpGetDmaAdapter;
        standard->SetBusData = NULL;
        standard->GetBusData = NULL;

        return STATUS_SUCCESS;

    } else

#endif  // _WIN64

    if (IsEqualGUID(InterfaceType, (PVOID)&GUID_TRANSLATOR_INTERFACE_STANDARD)) {

        PTRANSLATOR_INTERFACE translator = (PTRANSLATOR_INTERFACE)Interface;

        //
        // Common initialization.
        //

        if (InterfaceBufferSize < sizeof(TRANSLATOR_INTERFACE)) {
            *Length = sizeof(TRANSLATOR_INTERFACE);
            return STATUS_BUFFER_TOO_SMALL;
        }

        switch ((CM_RESOURCE_TYPE)PtrToUlong(InterfaceSpecificData)) {

        case CmResourceTypeInterrupt:

            translator->Size = sizeof(TRANSLATOR_INTERFACE);
            translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
            translator->Context = DeviceObject;
            translator->InterfaceReference = HalTranslatorReference;
            translator->InterfaceDereference = HalTranslatorDereference;
            translator->TranslateResources = HalIrqTranslateResourcesRoot;
            translator->TranslateResourceRequirements =
                HalIrqTranslateResourceRequirementsRoot;

            *Length = sizeof(TRANSLATOR_INTERFACE);

            break;

        default:
            return STATUS_NOT_SUPPORTED ;
        }

        return STATUS_SUCCESS;
    }
#ifdef ACPI_CMOS_ACTIVATE
    else if (IsEqualGUID(InterfaceType, (PVOID) &GUID_ACPI_CMOS_INTERFACE_STANDARD)) {

        PACPI_CMOS_INTERFACE_STANDARD CmosInterface = (PACPI_CMOS_INTERFACE_STANDARD)Interface;

        //
        // Common initialization.
        //

        if (InterfaceBufferSize < sizeof(ACPI_CMOS_INTERFACE_STANDARD)) {

            *Length = sizeof(ACPI_CMOS_INTERFACE_STANDARD);
            return STATUS_BUFFER_TOO_SMALL;
        }

        switch ((CM_RESOURCE_TYPE)InterfaceSpecificData) {

        case CmResourceTypeNull:

            // standard header
            CmosInterface->Size =                   sizeof(ACPI_CMOS_INTERFACE_STANDARD);
            CmosInterface->Version =                1;
            CmosInterface->InterfaceReference =     HalpCmosNullReference;
            CmosInterface->InterfaceDereference =   HalpCmosNullReference;

            // cmos interface specific
            CmosInterface->ReadCmos =               HalpcGetCmosDataByType;
            CmosInterface->WriteCmos =              HalpcSetCmosDataByType;

            *Length = sizeof(ACPI_CMOS_INTERFACE_STANDARD);

            break;

        default:
            return STATUS_NOT_SUPPORTED ;
        }

        return STATUS_SUCCESS;
    }
#endif // ACPI_CMOS_ACTIVATE


    //
    // If we got here, we don't handle this interface type.
    //

    return STATUS_NOT_SUPPORTED ;
}

#if defined(_WIN64)


VOID
HalPnpInterfaceReference(
    PVOID Context
    )
/*++

Routine Description:

    This function increments the reference count on the interface context.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

Return Value:

    None

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );
}

VOID
HalPnpInterfaceDereference(
    PVOID Context
    )
/*++

Routine Description:

    This function decrements the reference count on the interface context.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

Return Value:

    None

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;

    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );
}

PDMA_ADAPTER
HalPnpGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    )
/*++

Routine Description:

    This function writes the PCI configuration space.

Arguments:

    Context - Supplies a pointer  to the interface context.  This is actually
        the PDO for the root bus.

    DeviceDescriptor - Supplies the device descriptor used to allocate the dma
        adapter object.

    NubmerOfMapRegisters - Returns the maximum number of map registers a device
        can allocate at one time.

Return Value:

    Returns a DMA adapter or NULL.

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );

    return (PDMA_ADAPTER) HalGetAdapter( DeviceDescriptor, NumberOfMapRegisters );
}

#endif  // _WIN64

#ifdef ACPI_CMOS_ACTIVATE

//
// This section implements a CMOS access method
//
VOID
HalpCmosNullReference(
    PVOID Context
    )
{
    return;
}

VOID
HalpCmosNullDereference(
    PVOID Context
    )
{
    return;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixproc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixsproc.c

Abstract:

    Stub functions for UP hals.

Author:

    Ken Reneris (kenr) 22-Jan-1991

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITCONST") // INITCONST is OK to use for data_seg
#endif // ALLOC_DATA_PRAGMA
const WCHAR   HalHardwareIdString[]  = L"acpipic_up";

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif // ALLOC_DATA_PRAGMA

const UCHAR HalName[] = "ACPI Compatible Eisa/Isa HAL"; // This is placed in .text for debugging
#define HalName        L"ACPI Compatible Eisa/Isa HAL"

const ULONG HalDisableFirmwareMapper = 1;

BOOLEAN
HalpInitMP (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpMcaInit (
    VOID
    );

VOID
HalpAcpiEnumerate (
    PUNICODE_STRING DriverName
    );

VOID HalpInitOtherBuses (VOID);
VOID HalpInitializePciBus (VOID);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitMP)
#pragma alloc_text(INIT,HalStartNextProcessor)
#pragma alloc_text(INIT,HalAllProcessorsStarted)
#pragma alloc_text(INIT,HalReportResourceUsage)
#pragma alloc_text(INIT,HalpInitOtherBuses)
#endif



BOOLEAN
HalpInitMP (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    // do nothing
    return TRUE;
}


VOID
HalpResetAllProcessors (
    VOID
    )
{
    // Just return, that will invoke the standard PC reboot code
}


BOOLEAN
HalStartNextProcessor (
   IN PLOADER_PARAMETER_BLOCK   pLoaderBlock,
   IN PKPROCESSOR_STATE         pProcessorState
   )
{
    // no other processors
    return FALSE;
}

BOOLEAN
HalAllProcessorsStarted (
    VOID
    )
{
#if !defined(_WIN64)
    if (HalpFeatureBits & HAL_NO_SPECULATION) {

        //
        // Processor doesn't perform speculative execeution,
        // remove fences in critical code paths
        //

        HalpRemoveFences ();
    }
#endif

    return TRUE;
}


VOID
HalReportResourceUsage (
    VOID
    )
{
    INTERFACE_TYPE  interfacetype;
    UNICODE_STRING  UHalName;

    HalInitSystemPhase2 ();

    //
    // Turn on MCA support if present
    //

    HalpMcaInit();

    //
    // Registry is now intialized, see if there are any PCI buses
    //

    HalpInitializePciBus ();

    switch (HalpBusType) {
        case MACHINE_TYPE_ISA:  interfacetype = Isa;            break;
        case MACHINE_TYPE_EISA: interfacetype = Eisa;           break;
        case MACHINE_TYPE_MCA:  interfacetype = MicroChannel;   break;
        default:                interfacetype = Internal;       break;
    }

    RtlInitUnicodeString (&UHalName, HalName);
    HalpReportResourceUsage (
        &UHalName,          // descriptive name
        interfacetype       // device space interface type
    );

#if 0
    //
    // Display all buses & ranges
    //

    HalpDisplayAllBusRanges ();
#endif
    
    HalpRegisterPciDebuggingDeviceInfo();
}


VOID
HalpInitOtherBuses (
    VOID
    )
{
    // no other internal buses supported
}

ULONG
FASTCALL
HalSystemVectorDispatchEntry (
    IN ULONG Vector,
    OUT PKINTERRUPT_ROUTINE **FlatDispatch,
    OUT PKINTERRUPT_ROUTINE *NoConnection
    )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixsleep.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixsleep.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixthrotl.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixthrotl.c

Abstract:

    This module implements the code for throttling the processors

Author:

    Jake Oshins (jakeo) 17-July-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"
#include "pci.h"


VOID
FASTCALL
HalProcessorThrottle (
    IN UCHAR Throttle
    )
/*++

Routine Description:

    This function limits the speed of the processor.

Arguments:

    (ecx) = Throttle setting

Return Value:

    none

--*/
{
    PKPRCB      PrcB;
    PHALPMPRCB  HalPrcB;
    ULONG       ThrottleSetting;
    ULONG       Addr;
    ULONG       Mask;
    ULONG       i;
    ULONG       PblkAddr;

#if DBG
    // debug
    WRITE_PORT_UCHAR ((PUCHAR) 0x80, Throttle);
#endif


    PrcB = KeGetPcr()->Prcb;
    HalPrcB = (PHALPMPRCB) PrcB->HalReserved;
    PblkAddr = HalPrcB->PBlk.Addr;

    ThrottleSetting = READ_PORT_ULONG ((PULONG) PblkAddr);

    if (Throttle == HalpThrottleScale) {

        //
        // If this is a piix4 and we're no longer going to
        // throttle, set the break events (a piix4 thing) to
        // get any interrupt to wake a C2 to C3 stopped
        // processor.  (note that piix4 can only be set on a
        // UP system).  Then clear the bit to allow C2 and C3
        // idle handlers to work again.
        //

        if (HalpPiix4 == 1) {
            HalSetBusDataByOffset (
                PCIConfiguration,
                HalpPiix4BusNumber,
                HalpPiix4SlotNumber,
                &HalpPiix4DevActB,
                0x58,
                sizeof (ULONG)
                );

            HalPrcB->PBlk.AddrAndFlags &= ~PIIX4_THROTTLE_FIX;
        }

        //
        // Throttling is off
        //

        ThrottleSetting &= ~PBLK_THT_EN;
        WRITE_PORT_ULONG ((PULONG) PblkAddr, ThrottleSetting);

    } else {

        //
        // Throttling is on.
        //

        if (HalpPiix4 == 1) {

            //
            // These piix4's have the thottle setting backwards, so
            // invert the value
            //

            Throttle = (UCHAR) HalpThrottleScale - Throttle;
        
            //
            // Piix4 will hang on a high throttle setting, so make
            // sure we don't do that
            //

            if (Throttle < 3) {
                Throttle = 3;
            }

        
        }

        //
        // Shift the throttle and build a mask to be in the proper location
        // for this platform
        //

        Throttle = Throttle << HalpFixedAcpiDescTable.duty_offset;
        Mask = (HalpThrottleScale - 1) << HalpFixedAcpiDescTable.duty_offset;

        //
        // Set the rate
        //

        ThrottleSetting &= ~Mask;
        ThrottleSetting |= Throttle | PBLK_THT_EN;
        WRITE_PORT_ULONG ((PULONG) PblkAddr, ThrottleSetting);

        //
        // If this is a piix4 we need to disable all the break events
        // (a piix4 thing) and then read the level2 processor stop
        // register to get it to start throttling.  Oh yes, also set
        // the bit in the Paddr to stop doing C2 & C3 stops at the
        // same time.
        //

        if (HalpPiix4 == 1) {
            HalPrcB->PBlk.AddrAndFlags |= PIIX4_THROTTLE_FIX;

            i = HalpPiix4DevActB & ~0x23;
            HalSetBusDataByOffset (
                PCIConfiguration,
                HalpPiix4BusNumber,
                HalpPiix4SlotNumber,
                &i,
                0x58,
                sizeof(ULONG)
                );

            READ_PORT_UCHAR ((PUCHAR) PblkAddr + P_LVL2);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\mpclockc.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halmps\i386\mpclockc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixusage.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixusage.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\makefile.inc ===
!if $(AMD64)

#
# There are several steps here.  XMSTUB.ASM contains both 16-bit and
# x86 32-bit code, and so must be assembled with the X86 assembler.
#
# The object code is then extracted from the resultant .obj file via
# DMPOBJ.EXE, and placed into byte arrays declared in rmstub.h and
# pmstub.h
#

STUBOBJ=obj\amd64\xmstub.ob

startup_code: obj\amd64\rmstub.h obj\amd64\pmstub.h

obj\amd64\rmstub.h: $(STUBOBJ)
    dmpobj $? RMSTUB HalpRMStub > $@

obj\amd64\pmstub.h: $(STUBOBJ)
    dmpobj $? PMSTUB HalpPMStub > $@

$(STUBOBJ): ..\amd64\xmstub.asm
    ml -c -Fl -coff -I$(SDXROOT)\public\sdk\inc -Fo$@ $?

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\ixthunk.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixthunk.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\mpdebug.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halmps\i386\mpdebug.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\mmtimer.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mmTimer.h

Abstract:

    This module contains multimedia event timer definitions

Author:

    Eric Nelson (enelson) July 7, 2000

Revision History:

--*/

#ifndef __MMTIMER_H__
#define __MMTIMER_H__

#define ETDT_SIGNATURE  0x54445445      // "ETDT"

//
// Event Timer Description Table
//
typedef struct _EVENT_TIMER_DESCRIPTION_TABLE {

    DESCRIPTION_HEADER  Header;

    //
    // Hardware ID of Event Timer Block:
    // Contents of General_Cap & ID Reg of Timer Block
    // [31:16] = PCI Vendor ID of 1st Timer Block
    // [5] = Legacy IRQ Routing Capable
    // [14] = Reserved
    // [12:8] = Number of Comparitors in 1st Timer Block
    // [7:0] = Hardware Rev ID
    //
    ULONG EventTimerBlockID;

    //
    // Base address of Event Timer Block
    //
    // Each Event Timer Block consumes 1K of system memory,
    // regardless of how many comparators are actually implemented
    // by hardware
    //
    ULONG BaseAddress;

} EVENT_TIMER_DESCRIPTION_TABLE, *PEVENT_TIMER_DESCRIPTION_TABLE;

#define ANYSIZE_ARRAY 1

#define ON  1
#define OFF 0

//
// Define volatile pointer offsets for easy access of event timer
// registers
//
typedef struct _TIMER_REGISTERS {
    volatile ULONG ConfigCapabilities;  // 0x100, 0x120, 0x140, ...
    ULONG Unknown;
    volatile ULONG Comparator;          // 0x108
    ULONG Mystery;
    volatile ULONG FSBInterruptRoute;   // 0x110
    volatile ULONG FSBInterruptAddress; // 0x114
    ULONGLONG Secret;
} TIMER_REGISTERS, *PTIMER_REGISTERS;

//
// Don't try to allocate one of these puppies, it's just a collecton of
// volatile pointer/offsets to make reading of registers easier
//
typedef struct _EVENT_TIMER_BLOCK {
    volatile ULONG GeneralCapabilities;     // 0x000
    volatile ULONG ClockPeriod;             // 0x004
    ULONGLONG Unknown;
    volatile ULONG GeneralConfig;           // 0x010
    ULONG Mystery[3];
    volatile ULONG GeneralIRQStatus;        // 0x020
    ULONG Secret[51];
    volatile ULONG MainCounter;             // 0x0F0
    ULONG Abyss[3];
    TIMER_REGISTERS mmTimer[ANYSIZE_ARRAY]; // 0x100
} EVENT_TIMER_BLOCK, *PEVENT_TIMER_BLOCK;

//
// Define our multi media event timer block context
//
typedef struct _ETB_CONTEXT {
    ULONG TimerCount;
    PEVENT_TIMER_BLOCK EventTimer;
    PHYSICAL_ADDRESS BaseAddress;
    ULONG ClockPeriod; // In nanoseconds
    ULONG SystemClockFrequency; // Rate of system clock in Hz
    ULONG SystemClockTicks; // Period of system clock in ticks
    BOOLEAN Initialized;
    BOOLEAN NewClockFrequency;
} ETB_CONTEXT, *PETB_CONTEXT;

//
// General Capabilities and ID
//
typedef union {
    struct {
        ULONG RevisionID: 8;
        ULONG TimerCount: 5;
        ULONG MainCounterSize: 1;
        ULONG Reserved: 1;
        ULONG LegacyIRQRoutingCapable: 1;
        ULONG VendorID: 16;
    };
    ULONG AsULONG;
} ETB_GEN_CAP_ID, *PETB_GEN_CAP_ID;

//
// General Configuration
//
typedef union {
    struct {
        ULONG GlobalIRQEnable: 1;
        ULONG LegacyIRQRouteEnable: 1;
        ULONG Reserved: 30;
    };
    ULONG AsULONG;
} ETB_GEN_CONF, *PETB_GEN_CONF;

//
// Timer n Configuration and Capabilities
//
typedef union {
    struct {
        ULONG Reserved0:          1;
        ULONG EdgeLevelSelect:    1;
        ULONG IRQEnable:          1;
        ULONG PeriodicModeEnable: 1;
        ULONG PeriodicCapable:    1;
        ULONG CompareWidth:       1;
        ULONG ValueSetConfig:     1;
        ULONG Reserved1:          1;
        ULONG Mode32BitConfig:    1;
        ULONG IRQRouteConfig:     5;
        ULONG IRQDeliverySelect:  1;
        ULONG FSBIRQCapable:      1;
        ULONG Reserved2:         16;
    };
    ULONG AsULONG;
} ETB_CONF_CAPS, *PETB_CONF_CAPS;

VOID
HalpmmTimerInit(
    IN ULONG EventTimerBlockID,
    IN ULONG BaseAddress
    );

ULONG
HalpmmTimerSetTimeIncrement(
    IN ULONG DesiredIncrement
    );

VOID
HalpmmTimerStallExecProc(
    IN ULONG Microseconds
    );

LARGE_INTEGER
HalpmmTimerQueryPerfCount(
   OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
   );

VOID
HalpmmTimerCalibratePerfCount(
    IN LONG volatile *Number,
    IN ULONGLONG NewCount
    );

BOOLEAN
HalpmmTimer(
    VOID
    );

VOID
HalpmmTimerClockInit(
    VOID
    );

#endif // __MMTIMER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\mpdat.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halmps\i386\mpdat.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\mmtimer.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mmtimer.c

Abstract:

    This module contains the HAL's multimedia event timer support

Author:

    Eric Nelson (enelson) July 7, 2000

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "mmtimer.h"
#include "xxtimer.h"

//
// Event timer block context
//
static ETB_CONTEXT ETBContext = { 0,        // Number of event timers
                                  NULL,     // VA of event timer block
                                  { 0, 0 }, // PA of event timer block
                                  100,      // Clock period in nanoseconds
                                  100,      // System clock frequency in Hz
                                  100000,   // System clock period in ticks
                                  FALSE,    // Multi media HW initialized?
                                  FALSE };  // Change system clock frequency?

//
// Event timer block registers address usage
//
static ADDRESS_USAGE HalpmmTimerResource = {
    NULL, CmResourceTypeMemory, DeviceUsage, { 0, 0x400, 0, 0 }
};

//
// Offset is the difference between the multi media timer HW's main
// 32-bit counter register and the HAL's 64-bit software PerfCount:
//
// ASSERT(PerfCount == ETBContext.EventTimer->MainCounter + Offset);
//
static LONGLONG Offset = 0;
static ULONGLONG PerfCount = 0;

#define HAL_PRIMARY_PROCESSOR 0
#define MAX_ULONG 0xFFFFFFFF
#define __4GB 0x100000000

#define __1MHz     1000000
#define __10MHz   10000000
#define __1GHz  1000000000

#define HALF(n) ((n) / 2)

#if DBG || MMTIMER_DEV
static ULONG CounterReads = 0;
#endif

#define MIN_LOOP_QUANTUM 1
static ULONG MinLoopCount = MIN_LOOP_QUANTUM;
static UCHAR StallCount = 0;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpmmTimer)
#pragma alloc_text(INIT, HalpmmTimerInit)
#pragma alloc_text(INIT, HalpmmTimerClockInit)
#pragma alloc_text(INIT, HalpmmTimerCalibratePerfCount)
#endif


BOOLEAN
HalpmmTimer(
    VOID
    )
/*++

Routine Description:

    This routine is used to determine if multi media timer HW is
    present, and has been initialized

    note: this routine should only used during HAL init

Arguments:

    None

Return Value:

    TRUE if the multi media timer HW is present, and has been initialized

--*/
{
    return ETBContext.Initialized;
}


ULONG
HalpmmTimerSetTimeIncrement(
    IN ULONG DesiredIncrement
    )
/*++

Routine Description:

    This routine initialize system time clock to generate an
    interrupt at every DesiredIncrement interval

Arguments:

     DesiredIncrement - Desired interval between every timer tick (in
                        100ns unit)

Return Value:

     The *REAL* time increment set

--*/
{
    //
    // For starters we will only support a default system clock
    // frequency of 10ms
    //
    // 100ns = 1/10MHz, and (1/SysClock) / (1/10MHz) == 10MHz/SysClock, .:.
    //
    return __10MHz / ETBContext.SystemClockFrequency;
}


VOID
HalpmmTimerClockInit(
    VOID
    )
/*++

Routine Description:

    This routine initializes the system clock using the multi media event
    timer to generate an interrupt every 10ms

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG MinSysClockFreq;
    ULONG MaxSysClockFreq;
    ETB_GEN_CONF GenConf;
    ETB_CONF_CAPS mmT0ConfCaps;

    //
    // Reset the main counter and its associated performance variables
    // to 0, nobody should be using them this early
    //
    GenConf.AsULONG = ETBContext.EventTimer->GeneralConfig;
    GenConf.GlobalIRQEnable = OFF;
    ETBContext.EventTimer->GeneralConfig = GenConf.AsULONG;
    ETBContext.EventTimer->MainCounter = 0;
    Offset = 0;
    PerfCount = 0;

    //
    // Initialize multi media context for a default system clock
    // freuqency of 100Hz, with a period of 10ms
    //
    ETBContext.SystemClockFrequency = 100;
    ETBContext.SystemClockTicks = __1GHz /
        (ETBContext.SystemClockFrequency * ETBContext.ClockPeriod);

    //
    // Setup timer 0 for periodc mode
    //
    mmT0ConfCaps.AsULONG =
        ETBContext.EventTimer->mmTimer[0].ConfigCapabilities;

    ASSERT(mmT0ConfCaps.PeriodicCapable == ON);

    mmT0ConfCaps.ValueSetConfig = ON;
    mmT0ConfCaps.IRQEnable = ON;
    mmT0ConfCaps.PeriodicModeEnable = ON;
    ETBContext.EventTimer->mmTimer[0].ConfigCapabilities =
        mmT0ConfCaps.AsULONG;

    //
    // Set comparator to the desired system clock frequency
    //
    ETBContext.EventTimer->mmTimer[0].Comparator = ETBContext.SystemClockTicks;

    //
    // Fire up the main counter
    //
    GenConf.AsULONG = ETBContext.EventTimer->GeneralConfig;
    GenConf.GlobalIRQEnable = ON;
    ETBContext.EventTimer->GeneralConfig = GenConf.AsULONG;

    //
    // Inform kernel of our supported system clock frequency range in
    // 100ns units, but for starters we will only support 10ms default
    //
    MinSysClockFreq = __10MHz / ETBContext.SystemClockFrequency;
    MaxSysClockFreq = MinSysClockFreq;
#ifndef MMTIMER_DEV
    KeSetTimeIncrement(MinSysClockFreq, MaxSysClockFreq);
#endif
}

#ifdef MMTIMER_DEV
static ULONG HalpmmTimerClockInts = 0;
#endif


VOID
HalpmmTimerClockInterrupt(
    VOID
    )
/*++

Routine Description:

    This routine is entered as the result of an interrupt generated by
    CLOCK, update our performance count and change system clock frequency
    if necessary

Arguments:

    None

 Return Value:

    None

--*/
{
    //
    // Update PerfCount
    //
    PerfCount += ETBContext.SystemClockTicks;

    //
    // If the 32-bit counter has wrapped, update Offset accordingly
    //
    if (PerfCount - Offset > MAX_ULONG) {
        Offset += __4GB;
    }

#ifdef MMTIMER_DEV
    HalpmmTimerClockInts++;
#endif

    //
    // Check if a new frequency has been requested
    //
    if (ETBContext.NewClockFrequency) {

        //
        // ???
        //

        ETBContext.NewClockFrequency = FALSE;
    }
}


VOID
HalpmmTimerInit(
    IN ULONG EventTimerBlockID,
    IN ULONG BaseAddress
    )
/*++

Routine Description:

    This routine initializes the multimedia event timer

Arguments:

    EventTimerBlockID - Various bits of info, including number of Event
                        Timers

    BaseAddress - Physical Base Address of 1st Event Timer Block
    
Return Value:

    None

--*/
{
    ULONG i;
    ETB_GEN_CONF GenConf;
    ETB_GEN_CAP_ID GenCaps;
    PHYSICAL_ADDRESS PhysAddr;
    PEVENT_TIMER_BLOCK EventTimer;

    TIMER_FUNCTIONS TimerFunctions = { HalpmmTimerStallExecProc,
                                       HalpmmTimerCalibratePerfCount,
                                       HalpmmTimerQueryPerfCount,
                                       HalpmmTimerSetTimeIncrement };

#if MMTIMER_DEV && PICACPI
    {
        UCHAR Data;
        
        //
        // (BUGBUG!) BIOS should enable the device
        //
        Data = 0x87;
        HalpPhase0SetPciDataByOffset(0,
                                     9,
                                     &Data,
                                     4,
                                     sizeof(Data));
    }
#endif

    //
    // Establish VA for Multimedia Timer HW Base Address
    //
    PhysAddr.QuadPart = BaseAddress;
    EventTimer = HalpMapPhysicalMemoryWriteThrough(PhysAddr, 1);

    //
    // Register address usage
    //    
    HalpmmTimerResource.Element[0].Start = BaseAddress;
    HalpRegisterAddressUsage(&HalpmmTimerResource);

    //
    // Read the General Capabilities and ID Register
    //
    GenCaps.AsULONG = EventTimer->GeneralCapabilities;

    //
    // Save context
    //
    ETBContext.TimerCount = GenCaps.TimerCount + 1; // Convert from zero-based
    ETBContext.BaseAddress.QuadPart = BaseAddress;
    ETBContext.EventTimer = EventTimer;
    ETBContext.NewClockFrequency = FALSE;

    //
    // Save clock period as nanoseconds, convert from femptoseconds so
    // we don't have to worry about nasty overflow
    //
#ifndef MMTIMER_DEV
    ETBContext.ClockPeriod = EventTimer->ClockPeriod / __1MHz;
#else
    ETBContext.ClockPeriod = 100; // Proto HW is 10MHz, with a period of 100ns
#endif

    //
    // Reset the main counter and its associated performance counter
    // variables
    //
    GenConf.AsULONG = EventTimer->GeneralConfig;
    GenConf.GlobalIRQEnable = ON;
    //GenConf.LegacyIRQRouteEnable = ON;
    EventTimer->MainCounter = 0;
    Offset = 0;
    PerfCount = 0;   
    EventTimer->GeneralConfig = GenConf.AsULONG;

    //
    // Set HAL timer functions to use Multimedia Timer HW
    //
    HalpSetTimerFunctions(&TimerFunctions);

    ETBContext.Initialized = TRUE; 
}


//ULONG
//HalpmmTimerTicks(
//    IN ULONG StartCount,
//    IN ULONG EndCount
//    )
///*++
//
//Routine Description:
//
//    Calculate the difference in ticks between StartCount and EndCount
//    taking into consideraton counter rollover
//
//Arguments:
//
//    StartCount - Value of main counter at time t0
//
//    EndCount - Value of main counter at end time t1
//
//Return Value:
//
//    Returns the positive number of ticks which have elapsed between time
//    t0, and t1
//
//--*/
//
#define HalpmmTimerTicks(StartCount, EndCount) (((EndCount) >= (StartCount)) ? (EndCount) - (StartCount): (EndCount) + (MAX_ULONG - (StartCount)) + 1)

#define WHACK_HIGH_DIFF 0xFFFF0000
#define ULONG_BITS 32


VOID
HalpmmTimerStallExecProc(
    IN ULONG MicroSeconds
    )
/*++

Routine Description:

    This function stalls execution for the specified number of microseconds

Arguments:

    MicroSeconds - Supplies the number of microseconds that execution is to be
                   stalled

 Return Value:

    None

--*/
{
    ULONG i;
#ifndef i386
    ULONG j;
    ULONG Mirror;
#endif
    ULONG EndCount;
    ULONG StartCount;
    ULONG TargetTicks;
    ULONG ElapsedTicks;
    ULONG CyclesStalled;    
    ULONG TicksPerMicroSec;

    ElapsedTicks = 0;
    CyclesStalled = 0;
#if DBG || MMTIMER_DEV
    CounterReads = 0;
#endif

    TicksPerMicroSec = 1000 / ETBContext.ClockPeriod;
    TargetTicks = MicroSeconds * TicksPerMicroSec;
    StartCount = ETBContext.EventTimer->MainCounter;

    //
    // BIAS: We've stalled for .5us already!
    //
    TargetTicks -= HALF(TicksPerMicroSec);

    //
    // Get a warm fuzzy for what it's like to stall for more than .5us
    //
    while (TRUE) {

#ifdef i386
        _asm { rep nop }
#endif

        i = MinLoopCount;
        CyclesStalled += i;

        while (i--) {
#ifdef i386
            _asm {
                xor eax, eax
                cpuid
            }
#else
            Mirror = 0;
            for (j = 0; j < ULONG_BITS; j++) {
                Mirror <<= 1;
                Mirror |= EndCount & 1;
                EndCount >>= 1;
            }
            EndCount = Mirror;
#endif // i386
        }

        EndCount = ETBContext.EventTimer->MainCounter;
#if DBG || MMTIMER_DEV
        CounterReads++;
#endif
        ElapsedTicks = HalpmmTimerTicks(StartCount, EndCount);

        if (ElapsedTicks >= HALF(TicksPerMicroSec)) {
            break;
        }

        MinLoopCount += MIN_LOOP_QUANTUM;
    }

#ifdef MMTIMER_DEV
    //
    // Something is whack, probably time went backwards!  Act as if we
    // hit our target of .5us and reset StartCount to the current value
    // less ElapsedTicks
    //
    if (ElapsedTicks > WHACK_HIGH_DIFF) {
        ElapsedTicks = HALF(TicksPerMicroSec);
        StartCount = EndCount - ElapsedTicks;
    }
#endif // MMTIMER_DEV

    //
    // Now that we have a warm fuzzy, try to approximate a workload that
    // will keep us busy for the remainder of microsoeconds
    //
    while (TargetTicks > ElapsedTicks) {

#ifdef i386
        _asm { rep nop }
#endif

        i = (TargetTicks - ElapsedTicks) * CyclesStalled / ElapsedTicks;
        CyclesStalled += i;

        while (i--) {
#ifdef i386
            _asm {
                xor eax, eax
                cpuid
            }
#else
            Mirror = 0;
            for (j = 0; j < ULONG_BITS; j++) {
                Mirror <<= 1;
                Mirror |= EndCount & 1;
                EndCount >>= 1;
            }
            EndCount = Mirror;
#endif // i386
        }

        EndCount = ETBContext.EventTimer->MainCounter;
#if DBG || MMTIMER_DEV
        CounterReads++;
#endif
        ElapsedTicks = HalpmmTimerTicks(StartCount, EndCount);
    }

    //
    // Decrement MinimumLoopCount every 0x100 calls so we don't accidentally
    // wind up stalling for longer periods
    //
    StallCount++;
    if ((StallCount == 0) && (MinLoopCount > MIN_LOOP_QUANTUM)) {
        MinLoopCount -= MIN_LOOP_QUANTUM;
    }
}


VOID
HalpmmTimerCalibratePerfCount(
    IN LONG volatile *Number,
    IN ULONGLONG NewCount
    )
/*++

Routine Description:

    This routine resets the performance counter value for the current
    processor to zero, the reset is done such that the resulting value
    is closely synchronized with other processors in the configuration

Arguments:

    Number - Supplies a pointer to count of the number of processors in
             the configuration

    NewCount - Supplies the value to synchronize the counter too

Return Value:

    None

--*/
{
    ULONG MainCount;

    //
    // If this isn't the primary processor, then return
    //
    if (KeGetCurrentPrcb()->Number != HAL_PRIMARY_PROCESSOR) {
        return;
    }

    MainCount = ETBContext.EventTimer->MainCounter;

    PerfCount = NewCount;

    Offset = PerfCount - MainCount;
}


LARGE_INTEGER
HalpmmTimerQueryPerfCount(
   OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
   )
/*++

Routine Description:

    This routine returns current 64-bit performance counter and,
    optionally, the Performance Frequency

    N.B. The performace counter returned by this routine is
    not necessary the value when this routine is just entered,
    The value returned is actually the counter value at any point
    between the routine is entered and is exited

Arguments:

    PerformanceFrequency - optionally, supplies the address of a
                           variable to receive the performance counter
                           frequency

Return Value:

    Current value of the performance counter will be returned

--*/
{
    ULONG MainCount;
    LARGE_INTEGER li;

    //
    // Clock period is in nanoseconds, help the calculation remain
    // integer by asserting multi media HW clock frequency is between
    // 1MHz and 1GHz, with a period between 1ns and 1Kns, seems
    // reasonable to me?
    //
    if (PerformanceFrequency) {
        
        ASSERT((ETBContext.ClockPeriod > 0) &&
               (ETBContext.ClockPeriod <= 1000));

        PerformanceFrequency->QuadPart =
            (1000 / ETBContext.ClockPeriod) * __1MHz;
    }

    //
    // Read main counter
    //
    MainCount = ETBContext.EventTimer->MainCounter;

    //
    // Check if our 32-bit counter has wrapped since we took our last
    // clock tick
    //
    li.QuadPart = (PerfCount - Offset > MainCount) ?
            Offset + __4GB + MainCount:
            MainCount + Offset;
    return li;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\mpprocst.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halmps\i386\mpprocst.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\mpinfo.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halmps\i386\mpinfo.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\mpipic.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halmps\i386\mpipic.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\mphal.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halmps\i386\mphal.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\mpsys.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halmps\i386\mpsys.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\mpsysbus.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halmps\i386\mpsysbus.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\mpsproc.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halmps\i386\mpsproc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\pmpcisup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\pmpcisup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\pcip.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\pcip.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\pmdata.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmdat.c

Abstract:

    Declares various data which is initialize data, or pagable data.

Author:

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"

FADT    HalpFixedAcpiDescTable;
PDEBUG_PORT_TABLE HalpDebugPortTable = NULL;
ULONG   HalpThrottleScale;

UCHAR   HalpBrokenAcpiTimer = 0;

UCHAR   HalpPiix4 = 0;
ULONG   HalpPiix4BusNumber;
ULONG   HalpPiix4SlotNumber;
ULONG   HalpPiix4DevActB;
ULONG   HalpAcpiFlags = HAL_ACPI_PCI_RESOURCES;

BOOLEAN HalpBroken440BX = FALSE;
BOOLEAN HalpProcessedACPIPhase0 = FALSE;
PBOOT_TABLE HalpSimpleBootFlagTable = NULL;

#ifdef APIC_HAL
//
// MP data
//

MP_INFO HalpMpInfoTable;
PMAPIC  HalpApicTable;

PROC_LOCAL_APIC HalpProcLocalApicTable[MAX_PROCESSORS] = {0};

PVOID *HalpLocalNmiSources = NULL;

#endif // APIC_HAL

//
// This array represents the ISA PIC vectors.
// They start out identity-mapped.
//
ULONG   HalpPicVectorRedirect[PIC_VECTORS] =
{
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
    10, 11, 12, 13, 14, 15
};

#ifdef APIC_HAL
ULONG   HalpPicVectorFlags[PIC_VECTORS] = {0};
#endif // APIC_HAL

SLEEP_STATE_CONTEXT HalpSleepContext = {0};
PVOID               HalpWakeVector  = NULL;
PVOID               HalpVirtAddrForFlush = NULL;
PVOID               HalpPteForFlush = NULL;
BOOLEAN             HalpCr4Exists   = FALSE;
UCHAR               HalpRtcRegA;
UCHAR               HalpRtcRegB;

PACPI_BIOS_MULTI_NODE HalpAcpiMultiNode = NULL;
PUCHAR HalpAcpiNvsData = NULL;
PVOID  HalpNvsVirtualAddress = NULL;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INIT")
#endif

UCHAR  rgzNoApicTable[]     = "HAL: No ACPI APIC Table Found\n";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\mpsyssup.c ===
/*++

Module Name:

    mpsyssup.c

Abstract:

    This file contains APIC-related funtions that are
    specific to halmps.  The functions that can be
    shared with the APIC version of the ACPI HAL are
    still in mpsys.c.

Author:

    Ron Mosgrove (Intel)

Environment:

    Kernel mode only.

Revision History:

    Jake Oshins - 10-20-97 - split off from mpsys.c


*/

#include "halp.h"
#include "apic.inc"
#include "acpi_mp.inc"
#include "acpitabl.h"
#include "ntacpi.h"

extern ULONG HalpPicVectorRedirect[];
extern ULONG HalpPicVectorFlags[];
extern FADT HalpFixedAcpiDescTable;
extern PVOID *HalpLocalNmiSources;
extern UCHAR HalpMaxProcs;

#define ISA_PIC_VECTORS 16

UCHAR   HalpIoApicId[MAX_IOAPICS];

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpInitIntiInfo)
#pragma alloc_text(PAGELK, HalpGetApicInterruptDesc)
#pragma alloc_text(PAGELK, HalpEnableLocalNmiSources)
#pragma alloc_text(PAGE, HaliSetVectorState)
#pragma alloc_text(PAGE, HaliIsVectorValid)
#endif

VOID
HalpInitIntiInfo (
    VOID
    )
/*++

Routine Description:

    This function is called at initialization time before any interrupts
    are connected.  It reads the PC+MP Inti table and builds internal
    information needed to route each Inti.

Return Value:

    The following structures are filled in:
        HalpIntiInfo
        HalpSourceIrqIds
        HalpSourceIrqMapping
        HalpISAIqpToVector

--*/

{
    ULONG           ApicNo, BusNo, InterruptInput, IdIndex, ProcNo;
    ULONG           i, id;
    USHORT          rtcInti, sciInti;
    UCHAR           Level, Polarity;
    BOOLEAN         found;

    //
    // Clear IntiInfo table.  Assume to begin with that
    // all interrupts are active-low, level-triggered.
    //

    for (i=0; i < MAX_INTI; i++) {
        HalpIntiInfo[i].Type = INT_TYPE_INTR;
        HalpIntiInfo[i].Level = CFG_LEVEL;
        HalpIntiInfo[i].Polarity = POLARITY_LOW;
    }

    //
    // Set up the RTC inti with the right flags from
    // the redirection table.
    //

    found = HalpGetApicInterruptDesc( DEFAULT_PC_BUS,
                                      0,
                                      HalpPicVectorRedirect[RTC_IRQ],
                                      &rtcInti
                                      );

    if (!found) {
        KeBugCheckEx(HAL_INITIALIZATION_FAILED,
                     0x3000,
                     1,
                     HalpPicVectorRedirect[RTC_IRQ],
                     0);
    }

    if ((HalpPicVectorFlags[RTC_IRQ] & PO_BITS) == POLARITY_CONFORMS_WITH_BUS) {

        //
        // The flags indicated "conforms to bus,"
        // so this should be active high.
        //

        HalpIntiInfo[rtcInti].Polarity = POLARITY_HIGH;

    } else {

        //
        // The polarity flags are overriden.
        //

        HalpIntiInfo[rtcInti].Polarity =
            (UCHAR)HalpPicVectorFlags[RTC_IRQ] & PO_BITS;
    }

    if ((HalpPicVectorFlags[RTC_IRQ] & EL_BITS) == EL_CONFORMS_WITH_BUS) {

        //
        // The flags indicated "conforms to bus,"
        // so this should be edge triggered.
        //

        HalpIntiInfo[rtcInti].Level = CFG_EDGE;

    } else {

        //
        // The mode flags are overriden.
        //

        HalpIntiInfo[rtcInti].Level =
            ((UCHAR)(HalpPicVectorFlags[RTC_IRQ] & EL_BITS) == EL_EDGE_TRIGGERED ?
              CFG_EDGE : CFG_LEVEL);
    }

    //
    //
    // Set up the SCI inti with the right flags from
    // the redirection table.
    //

    found = HalpGetApicInterruptDesc( DEFAULT_PC_BUS,
                                      0,
                                      HalpPicVectorRedirect[HalpFixedAcpiDescTable.sci_int_vector],
                                      &sciInti
                                      );

    if (!found) {
        KeBugCheckEx(HAL_INITIALIZATION_FAILED,
                     0x3000,
                     2,
                     HalpPicVectorRedirect[HalpFixedAcpiDescTable.sci_int_vector],
                     0);
    }

    if ((HalpPicVectorFlags[HalpFixedAcpiDescTable.sci_int_vector]
         & PO_BITS) == POLARITY_CONFORMS_WITH_BUS) {

        //
        // The flags indicated "conforms to bus,"
        // so this should default to the ACPI spec (active low.)
        //

        HalpIntiInfo[sciInti].Polarity = POLARITY_LOW;

    } else {

        //
        // The polarity flags are overriden.
        //

        HalpIntiInfo[sciInti].Polarity =
            (UCHAR)HalpPicVectorFlags[HalpFixedAcpiDescTable.sci_int_vector] & PO_BITS;
    }

    if (((HalpPicVectorFlags[HalpFixedAcpiDescTable.sci_int_vector] & EL_BITS) ==
          EL_CONFORMS_WITH_BUS) ||
        ((HalpPicVectorFlags[HalpFixedAcpiDescTable.sci_int_vector] & EL_BITS) ==
          EL_LEVEL_TRIGGERED)) {

        //
        // The flags indicated "conforms to bus,"
        // so this should be level-triggered.
        //

        HalpIntiInfo[sciInti].Level = CFG_LEVEL;

    } else {

        //
        // The SCI cannot be edge-triggered.
        //

        KeBugCheckEx(ACPI_BIOS_ERROR,
                        0x10008,
                        HalpFixedAcpiDescTable.sci_int_vector,
                        0,
                        0);
    }

    // Make sure there aren't more Inti lines than we can support
    //

    InterruptInput = 0;
    for (i=0; i < MAX_IOAPICS; i++) {
        InterruptInput += HalpMaxApicInti[i];
    }
    ASSERT (InterruptInput < MAX_INTI);

    //
    // Fill in the boot processors Apic ID.
    //

    ApicNo = *(PVULONG)(LOCALAPIC + LU_ID_REGISTER);

    ApicNo &= APIC_ID_MASK;
    ApicNo >>= APIC_ID_SHIFT;

    ((PHALPRCB)KeGetCurrentPrcb()->HalReserved)->PCMPApicID = (UCHAR)ApicNo;

    //
    // Mark the boot processor as started.
    //

    for (ProcNo = 0; ProcNo < HalpMpInfoTable.ProcessorCount; ProcNo++) {

        if (HalpProcLocalApicTable[ProcNo].ApicID == (UCHAR)ApicNo) {

            HalpProcLocalApicTable[ProcNo].Started = TRUE;
            HalpProcLocalApicTable[ProcNo].Enumerated = TRUE;
            break;
        }
    }

    if (ProcNo == HalpMpInfoTable.ProcessorCount) {
        KeBugCheckEx(HAL_INITIALIZATION_FAILED, 0xdead000a, ApicNo, (ULONG_PTR)&HalpProcLocalApicTable, 0);
    }

    //
    // If this is an EISA machine check the ELCR
    //
//
//  if (HalpBusType == MACHINE_TYPE_EISA) {
//      HalpCheckELCR ();
//  }
}

BOOLEAN
HalpGetApicInterruptDesc (
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    OUT PUSHORT PcMpInti
    )
/*++

Routine Description:

    This procedure gets a "Inti" describing the requested interrupt

Arguments:

    BusType - The Bus type as known to the IO subsystem

    BusNumber - The number of the Bus we care for

    BusInterruptLevel - IRQ on the Bus

Return Value:

    TRUE if PcMpInti found; otherwise FALSE.

    PcMpInti - A number that describes the interrupt to the HAL.

--*/
{
    ULONG   i;
    ULONG   index = 0;

    UNREFERENCED_PARAMETER(BusType);
    UNREFERENCED_PARAMETER(BusNumber);

    for (i = 0; i < HalpMpInfoTable.IOApicCount; i++) {

        if ((BusInterruptLevel >=
                HalpMpInfoTable.IoApicIntiBase[i]) &&
            (BusInterruptLevel <
                HalpMpInfoTable.IoApicIntiBase[i] +
                    HalpMaxApicInti[i])) {

            //
            // Return value is an offset into the INTI_INFO array.  So
            // calculate which one it is.
            //

            *PcMpInti = (USHORT)(index + BusInterruptLevel -
                 HalpMpInfoTable.IoApicIntiBase[i]);

            return TRUE;
        }

        index += HalpMaxApicInti[i];
    }

    //
    // Not found or search out of range
    //

    return FALSE;
}

ULONG
HalpGetIoApicId(
    ULONG   ApicNo
    )
{
    return (ULONG) HalpIoApicId[ApicNo];
}

ULONG
HalpInti2BusInterruptLevel(
    ULONG   Inti
    )
{

    return Inti;
}

VOID
HalpMarkProcessorStarted(
    ULONG   ApicID,
    ULONG   NtNumber
    )
{
    ULONG ProcNo;

    for (ProcNo = 0; ProcNo < HalpMpInfoTable.ProcessorCount; ProcNo++) {
        if (HalpProcLocalApicTable[ProcNo].ApicID == (UCHAR)ApicID) {
            HalpProcLocalApicTable[ProcNo].Started = TRUE;
            HalpProcLocalApicTable[ProcNo].NtNumber = (UCHAR) NtNumber;
            break;
        }
    }

}

NTSTATUS
HalpGetNextProcessorApicId(
    IN ULONG ProcessorNumber,
    IN OUT UCHAR    *ApicId
    )
/*++

Routine Description:

    This function returns an APIC ID of a non-started processor,
    which will be started by HalpStartProcessor.

Arguments:

    ProcessorNumber - The logical processor number that will
        be associated with this APIC ID.

    ApicId - pointer to a value to fill in with the APIC ID.

Return Value:

    status

--*/
{
    UCHAR Proc;

    //
    // Find a processor that hasn't been enumerated.
    //

    for (Proc = 0; Proc < HalpMpInfoTable.ProcessorCount; Proc++) {

        if (!HalpProcLocalApicTable[Proc].Enumerated) {
            break;
        }
    }

    if (Proc == HalpMpInfoTable.ProcessorCount) {

        //
        // Couldn't find a processor to start.
        //
        return STATUS_NOT_FOUND;
    }

    //
    // Keep track of this processor.
    //

    HalpProcLocalApicTable[Proc].Enumerated = TRUE;

    *ApicId = HalpProcLocalApicTable[Proc].ApicID;
    return STATUS_SUCCESS;
}

NTSTATUS
HalpGetApicIdByProcessorNumber(
    IN     UCHAR     Processor,
    IN OUT USHORT   *ApicId
    )
/*++

Routine Description:

    This function returns an APIC ID for a given processor.
    It is intended this routine be able to produce the same
    APIC ID order as HalpGetNextProcessorApicId.

    NOTES: This code is used only by the NUMA code to look up an
    ApicID by processor number so that this ApicId can then be looked
    up in the SRAT table.  A better design would be for the kernel to
    ask for this information via ApicID or a opaqued hardware
    description provided by the HAL that can be associated with an
    ApicID.

Arguments:

    Processor - The logical processor number that is
        associated with this APIC ID.

    ApicId - pointer to a value to fill in with the APIC ID.

Return Value:

    status

--*/
{
    UCHAR Proc;
    LONG  Skip;

    //
    // Run thru the processors that have already been started
    // to see if this is on of them.
    //

    Skip = Processor;
    for (Proc = 0; Proc < HalpMpInfoTable.ProcessorCount; Proc++) {
        if (HalpProcLocalApicTable[Proc].Started) {
            Skip--;
            if (HalpProcLocalApicTable[Proc].NtNumber == (UCHAR)Processor) {
                *ApicId = (USHORT)HalpProcLocalApicTable[Proc].ApicID;
                return STATUS_SUCCESS;
            }
        }
    }

    //
    // Not amongst the started, rely on the order that processors
    // will be started (see HalpGetNextProcessorApicId) to get the
    // number.
    //

    ASSERT(Skip >= 0);

    for (Proc = 0; Proc < HalpMpInfoTable.ProcessorCount; Proc++) {

        //
        // If we've started this processor or if it was enumerated and
        // not licensed by the OS, then it isn't a candidate.
        //

        if (HalpProcLocalApicTable[Proc].Started || HalpProcLocalApicTable[Proc].Enumerated) {
            continue;
        }

        if (Skip == 0) {

            //
            // Return this processor.
            //

            *ApicId = (USHORT)HalpProcLocalApicTable[Proc].ApicID;
            return STATUS_SUCCESS;
        }

        Skip--;
    }

    //
    // Couldn't find a processor to start.
    //

    return STATUS_NOT_FOUND;
}

VOID
HaliSetVectorState(
    IN ULONG Vector,
    IN ULONG Flags
    )
{
    BOOLEAN found;
    USHORT  inti;
    ULONG   picVector;
    UCHAR   i;

    PAGED_CODE();

    found = HalpGetApicInterruptDesc(0, 0, Vector, &inti);

    if (!found) {
        KeBugCheckEx(ACPI_BIOS_ERROR,
                     0x10007,
                     Vector,
                     0,
                     0);
    }

    ASSERT(HalpIntiInfo[inti].Type == INT_TYPE_INTR);

    //
    // Vector is already translated through
    // the PIC vector redirection table.  We need
    // to make sure that we are honoring the flags
    // in the redirection table.  So look in the
    // table here.
    //

    for (i = 0; i < PIC_VECTORS; i++) {

        if (HalpPicVectorRedirect[i] == Vector) {

            picVector = i;
            break;
        }
    }

    if (i != PIC_VECTORS) {

        //
        // Found this vector in the redirection table.
        //

        if (HalpPicVectorFlags[picVector] != 0) {

            //
            // And the flags say something other than "conforms
            // to bus."  So we honor the flags from the table.
            //

            HalpIntiInfo[inti].Level =
                (((HalpPicVectorFlags[picVector] & EL_BITS) == EL_LEVEL_TRIGGERED) ?
                    CFG_LEVEL : CFG_EDGE);

            HalpIntiInfo[inti].Polarity = (UCHAR)(HalpPicVectorFlags[picVector] & PO_BITS);

            return;
        }
    }

    //
    // This vector is not covered in the table, or it "conforms to bus."
    // So we honor the flags passed into this function.
    //

    if (IS_LEVEL_TRIGGERED(Flags)) {

        HalpIntiInfo[inti].Level = CFG_LEVEL;

    } else {

        HalpIntiInfo[inti].Level = CFG_EDGE;
    }

    if (IS_ACTIVE_LOW(Flags)) {

        HalpIntiInfo[inti].Polarity = POLARITY_LOW;

    } else {

        HalpIntiInfo[inti].Polarity = POLARITY_HIGH;
    }
}

VOID
HalpEnableLocalNmiSources(
    VOID
    )
/*++

Routine Description:

    This routine parses the information from the MAPIC table and
    enables any NMI sources in the local APIC of the processor
    that it is running on.

    Callers of this function must be holding HalpAccountingLock.

Arguments:

Return Value:

--*/
{
    PLOCAL_NMISOURCE localSource;
    PKPCR       pPCR;
    UCHAR       ThisCpu;
    ULONG       i;
    ULONG       modeBits = 0;

    pPCR = KeGetPcr();
    ThisCpu = CurrentPrcb(pPCR)->Number;

    //
    //  Enable local processor NMI source
    //

    if (!HalpLocalNmiSources) {

        //
        // Nobody has cataloged any local NMI sources.
        //

        return;
    }

    for (i = 0; i < (ULONG)HalpMaxProcs * 2; i++) {

        if (!HalpLocalNmiSources[i]) {

            //
            // Out of entries.
            //
            return;
        }

        localSource = (PLOCAL_NMISOURCE)(HalpLocalNmiSources[i]);

        if (((HalpProcLocalApicTable[ThisCpu].NamespaceProcID == localSource->ProcessorID) ||
             (localSource->ProcessorID == 0xff) &&
             HalpProcLocalApicTable[ThisCpu].Started)) {

            //
            // This entry corresponds to this processor.
            //

            modeBits |= ((localSource->Flags & PO_BITS) == POLARITY_LOW) ?
                        ACTIVE_LOW : ACTIVE_HIGH;

            modeBits |= ((localSource->Flags & EL_BITS) == EL_LEVEL_TRIGGERED) ?
                        LEVEL_TRIGGERED : EDGE_TRIGGERED;

            if (localSource->LINTIN == 0) {

                pLocalApic[LU_INT_VECTOR_0/4] =
                    modeBits | DELIVER_NMI | NMI_VECTOR;

            } else {

                pLocalApic[LU_INT_VECTOR_1/4] =
                    modeBits | DELIVER_NMI | NMI_VECTOR;
            }
        }
    }
}

BOOLEAN
HaliIsVectorValid(
    IN ULONG Vector
    )
{
    BOOLEAN found;
    USHORT  inti;

    PAGED_CODE();

    return HalpGetApicInterruptDesc(0, 0, Vector, &inti);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\pmpic.c ===
/*++

Module Name:

    pmpic.c

Abstract:

    This file contains functions that are specific to
    the PIC version of the ACPI hal.

Author:

    Jake Oshins

Environment:

    Kernel mode only.

Revision History:

*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"
#include "eisa.h"
#include "ixsleep.h"

VOID
HalpAcpiSetTempPicState(
    VOID
    );

VOID
HalpMaskAcpiInterrupt(
    VOID
    );

VOID
HalpUnmaskAcpiInterrupt(
    VOID
    );

extern PVOID   HalpEisaControlBase;
#define EISA_CONTROL (PUCHAR)&((PEISA_CONTROL) HalpEisaControlBase)

BOOLEAN HalpPicStateIntact = TRUE;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK, HalpAcpiSetTempPicState)
#pragma alloc_text(PAGELK, HalpSetAcpiEdgeLevelRegister)
#pragma alloc_text(PAGELK, HalpAcpiPicStateIntact)
#pragma alloc_text(PAGELK, HalpSaveInterruptControllerState)
#pragma alloc_text(PAGELK, HalpRestoreInterruptControllerState)
#pragma alloc_text(PAGELK, HalpSetInterruptControllerWakeupState)
#pragma alloc_text(PAGELK, HalpPostSleepMP)
#pragma alloc_text(PAGELK, HalpMaskAcpiInterrupt)
#pragma alloc_text(PAGELK, HalpUnmaskAcpiInterrupt)
#pragma alloc_text(PAGE, HaliSetVectorState)
#pragma alloc_text(PAGE, HaliIsVectorValid)
#endif

VOID
HaliSetVectorState(
    IN ULONG Vector,
    IN ULONG Flags
    )
{
    return;
}
BOOLEAN
HaliIsVectorValid(
    IN ULONG Vector
    )
{
    if (Vector < 16) {
        return TRUE;
    }
    
    return FALSE;
}
VOID
HalpAcpiSetTempPicState(
    VOID
    )
{
    ULONG flags;
    USHORT picMask;

    flags = HalpDisableInterrupts();

    HalpInitializePICs(FALSE);

    //
    // Halacpi lets the PCI interrupt programming be
    // dynamic.  So...
    //
    // Unmask only the clock sources on the PIC and the
    // ACPI vector.  The rest of the vectors will be
    // unmasked later, after we have restored PCI IRQ
    // routing.
    //

    picMask = 0xfefe; // mask everything but clocks

    //
    // Unmask ACPI vector
    //

    picMask &= ~(1 << (UCHAR)HalpFixedAcpiDescTable.sci_int_vector);

    //
    // Write the mask into the hardware.
    //

    WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt1ControlPort1,
                     (UCHAR)(picMask & 0xff));

    WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt2ControlPort1,
                     (UCHAR)((picMask >> 8) & 0xff));

    //
    // For now, set the edge-level control register
    // so that all vectors are edge except the
    // ACPI vector.  This is done because the PIC
    // will trigger if an idle ISA vector is set to
    // edge.  After the ACPI driver resets all the
    // PCI vectors to what we thought they should be,
    //

    HalpSetAcpiEdgeLevelRegister();

    HalpPicStateIntact = FALSE;

    HalpRestoreInterrupts(flags);
}

VOID
HalpSetAcpiEdgeLevelRegister(
    VOID
    )
{
    USHORT  elcr;

    //
    // The idea here is to set the ELCR so that only the ACPI
    // vector is set to 'level.'  That way we can reprogram
    // the PCI interrupt router without worrying that the
    // PIC will start triggering endless interrupts because
    // we have a source programmed to level that is being
    // routed to the ISA bus.
    //

    if (HalpFixedAcpiDescTable.sci_int_vector < PIC_VECTORS) {

        elcr = 1 << HalpFixedAcpiDescTable.sci_int_vector;

        WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt1EdgeLevel,
                         (UCHAR)(elcr & 0xff));

        WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt2EdgeLevel,
                         (UCHAR)(elcr >> 8));
    }
}

VOID
HalpRestoreInterruptControllerState(
    VOID
    )
{
    ULONG flags;
    USHORT picMask;

    flags = HalpDisableInterrupts();

    //
    // This function is called after PCI interrupt routing has
    // been restored.
    //

    WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt1ControlPort1,
                     HalpMotherboardState.PicState.MasterMask);

    WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt2ControlPort1,
                     HalpMotherboardState.PicState.SlaveMask);

    HalpRestorePicEdgeLevelRegister();

    HalpPicStateIntact = TRUE;

    HalpRestoreInterrupts(flags);
}

BOOLEAN
HalpAcpiPicStateIntact(
    VOID
    )
{
    return HalpPicStateIntact;
}

VOID
HalpSaveInterruptControllerState(
    VOID
    )
{
    HalpSavePicState();
}

VOID
HalpSetInterruptControllerWakeupState(
    ULONG Context
    )
{
    HalpAcpiSetTempPicState();
}

VOID
HalpPostSleepMP(
    IN LONG           NumberProcessors,
    IN volatile PLONG Number
    )
{
}

VOID
HalpMaskAcpiInterrupt(
    VOID
    )
{
}

VOID
HalpUnmaskAcpiInterrupt(
    VOID
    )
{
}


#if DBG

NTSTATUS
HalpGetApicIdByProcessorNumber(
    IN     UCHAR     Processor,
    IN OUT USHORT   *ApicId
    )

/*++

Routine Description:

    This routine only exists on DEBUG builds of the PIC ACPI HAL because
    that HAL is build MP and the SRAT code will be included.   The SRAT
    code will not be exercised but needs this routine in order to link.

Arguments:

    Ignored.

Return Value:

    STATUS_NOT_FOUND

--*/

{
    return STATUS_NOT_FOUND;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\pmapic.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmapic.c

Abstract:

    Implements various APIC-ACPI functions.

Author:

    Jake Oshins (jakeo) 19-May-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "apic.inc"
#include "xxacpi.h"
#include "ixsleep.h"

#ifdef DEBUGGING
#include "string.h"
#include "stdlib.h"
#include "stdio.h"
#endif

ULONG
DetectAcpiMP (
    OUT PBOOLEAN IsConfiguredMp,
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpInitMpInfo (
    IN PMAPIC ApicTable,
    IN ULONG  Phase
    );

BOOLEAN
HalpVerifyIOUnit(
    IN PUCHAR BaseAddress
    );

VOID
HalpMaskAcpiInterrupt(
    VOID
    );

VOID
HalpUnmaskAcpiInterrupt(
    VOID
    );

extern UCHAR  rgzNoApicTable[];
extern UCHAR  rgzNoApic[];
extern UCHAR  rgzBadApicVersion[];
extern UCHAR  rgzApicNotVerified[];

extern UCHAR HalpIRQLtoTPR[];
extern UCHAR HalpVectorToIRQL[];
extern ULONG HalpPicVectorRedirect[];
extern ULONG HalpPicVectorFlags[];
extern USHORT HalpMaxApicInti[];
extern UCHAR HalpIoApicId[];
extern ULONG HalpIpiClock;
extern PVOID *HalpLocalNmiSources;

ULONG HalpIOApicVersion[MAX_IOAPICS];

extern BOOLEAN HalpHiberInProgress;

BOOLEAN HalpPicStateIntact = TRUE;
UCHAR   HalpMaxProcs = 0;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DetectAcpiMP)
#pragma alloc_text(PAGELK, HalpInitMpInfo)
#pragma alloc_text(PAGELK, HalpVerifyIOUnit)
#pragma alloc_text(PAGELK, HalpSaveInterruptControllerState)
#pragma alloc_text(PAGELK, HalpRestoreInterruptControllerState)
#pragma alloc_text(PAGELK, HalpSetInterruptControllerWakeupState)
#pragma alloc_text(PAGELK, HalpAcpiPicStateIntact)
#pragma alloc_text(PAGELK, HalpGetApicVersion)
#pragma alloc_text(PAGELK, HalpMaskAcpiInterrupt)
#pragma alloc_text(PAGELK, HalpUnmaskAcpiInterrupt)
#endif


ULONG
DetectAcpiMP(
    OUT PBOOLEAN    IsConfiguredMp,
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    UCHAR ApicVersion, i;
    PUCHAR  LocalApic;
#ifdef DEBUGGING
    CHAR    string[100];
#endif
    PHYSICAL_ADDRESS physicalAddress;

    //
    // The addres of the IRQL translation tables must be returned
    // to the kernel
    // 

#if defined(_X86_)
    LoaderBlock->Extension->HalpIRQLToTPR = HalpIRQLtoTPR;
    LoaderBlock->Extension->HalpVectorToIRQL = HalpVectorToIRQL;
#endif

    //
    // Initialize MpInfo table
    //

    RtlZeroMemory (&HalpMpInfoTable, sizeof(MP_INFO));

    //
    // Set the return Values to the default
    //

    *IsConfiguredMp = FALSE;

    //
    // See if there is an APIC Table
    //

    if ((HalpApicTable = HalpGetAcpiTablePhase0(LoaderBlock, APIC_SIGNATURE)) == NULL) {
        HalDisplayString(rgzNoApicTable);
        return(FALSE);
    }

    // We have an APIC table. Initialize a HAL specific MP information
    // structure that gets information from the MAPIC table.

#ifdef DEBUGGING
    sprintf(string, "Signature: %x      Length: %x\n",
            HalpApicTable->Header.Signature,
            HalpApicTable->Header.Length);
    HalDisplayString(string);
    sprintf(string, "OEMID: %s\n", HalpApicTable->Header.OEMID);
    HalDisplayString(string);
    sprintf(string, "Local Apic Address: %x\n", HalpApicTable->LocalAPICAddress);
    HalDisplayString(string);
    sprintf(string, "Flags: %x\n", HalpApicTable->Flags);
    HalDisplayString(string);
#endif

    HalpInitMpInfo(HalpApicTable, 0);

    // Verify the information in the MAPIC table as best as we can.

    if (HalpMpInfoTable.IOApicCount == 0) {
        //
        //  Someone Has a MP Table and no IO Units -- Weird
        //  We have to assume the BIOS knew what it was doing
        //  when it built the table.  so ..
        //
        HalDisplayString (rgzNoApic);

        return (FALSE);
    }

    //
    //  It's an APIC System.  It could be a UP System though.
    //

    if (HalpMpInfoTable.ProcessorCount > 1) {
        *IsConfiguredMp = TRUE;
    }

    HalpMpInfoTable.LocalApicBase = (ULONG) HalpApicTable->LocalAPICAddress;
    physicalAddress =
        HalpPtrToPhysicalAddress( UlongToPtr(HalpMpInfoTable.LocalApicBase) );

    LocalApic = (PUCHAR) HalpMapPhysicalMemoryWriteThrough( physicalAddress,
                                                            1 );
    HalpRemapVirtualAddress (
        (PVOID) LOCALAPIC,
        physicalAddress,
        TRUE
        );

    ApicVersion = (UCHAR) *(LocalApic + LU_VERS_REGISTER);

    if (ApicVersion > 0x1f) {
        //
        //  Only known Apics are 82489dx with version 0.x and
        //  Embedded Apics with version 1.x (where x is don't care)
        //
        //  Return of 0xFF?   Can't have an MPS system without a Local Unit.
        //

#ifdef DEBUGGING
        sprintf(string, "HALMPS: apic version %x, read from %x\n",
            ApicVersion, LocalApic + LU_VERS_REGISTER);

        HalDisplayString(string);
#endif

        HalDisplayString (rgzBadApicVersion);

        return (FALSE);
    }

    for(i=0; i < HalpMpInfoTable.IOApicCount; i++)
    {
        //
        //  Verify the existance of the IO Unit
        //


        if (!(HalpVerifyIOUnit((PUCHAR)HalpMpInfoTable.IoApicBase[i]))) {
            HalDisplayString (rgzApicNotVerified);

            return (FALSE);
        }
    }

    HalDisplayString("HAL: DetectAPIC: APIC system found - Returning TRUE\n");

    return TRUE;
}

VOID
HalpInitMpInfo (
    IN PMAPIC ApicTable,
    IN ULONG  Phase
    )

/*++
Routine Description:
    This routine initializes a HAL specific data structure that is
    used by the HAL to simplify access to MP information.

Arguments:

    ApicTable - Pointer to the APIC table.

    Phase - indicates which pass we are are doing through the table.

 Return Value:
     Pointer to the HAL MP information table.

*/
{
    PUCHAR  TraversePtr;
    UCHAR   CheckSum;
    UCHAR   apicNo = 0;
    ULONG   nmiSources = 0;
#ifdef DEBUGGING
    CHAR    string[100];
#endif
    PIO_APIC_UNIT   apic;
    PHYSICAL_ADDRESS physicalAddress;
    PIOAPIC ioApic;
    UCHAR totalProcs = 0;

    union {
        ULONG        raw;
        APIC_VERSION version;
    } versionUnion;

    // Walk the MAPIC table.

    TraversePtr = (PUCHAR) ApicTable->APICTables;

    //
    // ACPI machines have embedded APICs.
    //
    HalpMpInfoTable.ApicVersion = 0x10;

#ifdef DUMP_MAPIC_TABLE

    while ((ULONG)TraversePtr <
           ((ULONG)ApicTable + ApicTable->Header.Length)) {

        sprintf(string, "%08x  %08x  %08x  %08x\n",
                *(PULONG)TraversePtr,
                *(PULONG)(TraversePtr + 4),
                *(PULONG)(TraversePtr + 8),
                *(PULONG)(TraversePtr + 12)
                );
        HalDisplayString(string);
        TraversePtr += 16;
    }

    TraversePtr = (PUCHAR) ApicTable->APICTables;
#endif

    if (!(ApicTable->Flags & PCAT_COMPAT)) {

        //
        // This HAL can't actually handle a machine without 8259's,
        // even though it doesn't use them.
        //

        KeBugCheckEx(MISMATCHED_HAL,
                        6, 0, 0, 0);

    }

    while ((ULONG_PTR)TraversePtr <
           ((ULONG_PTR)ApicTable + ApicTable->Header.Length)) {

        if ((((PPROCLOCALAPIC)(TraversePtr))->Type == PROCESSOR_LOCAL_APIC)
           && (((PPROCLOCALAPIC)(TraversePtr))->Length == PROCESSOR_LOCAL_APIC_LENGTH)) {

#ifdef DEBUGGING
            sprintf(string, "Found a processor-local APIC: %x\n", TraversePtr);
            HalDisplayString(string);
#endif

            if (Phase == 0) {

                if(((PPROCLOCALAPIC)(TraversePtr))->Flags & PLAF_ENABLED) {

                    //
                    // This processor is enabled, so keep track of useful stuff.
                    //

                    HalpProcLocalApicTable[HalpMpInfoTable.ProcessorCount].NamespaceProcID =
                        ((PPROCLOCALAPIC)(TraversePtr))->ACPIProcessorID;

                    HalpProcLocalApicTable[HalpMpInfoTable.ProcessorCount].ApicID =
                        ((PPROCLOCALAPIC)(TraversePtr))->APICID;

                    HalpMpInfoTable.ProcessorCount += 1;
                }
            }

            totalProcs++;

            HalpMaxProcs = (totalProcs > HalpMaxProcs) ? totalProcs : HalpMaxProcs;

            TraversePtr += ((PPROCLOCALAPIC)(TraversePtr))->Length;

        } else if ((((PIOAPIC)(TraversePtr))->Type == IO_APIC) &&
           (((PIOAPIC)(TraversePtr))->Length == IO_APIC_LENGTH)) {


#ifdef DEBUGGING
            sprintf(string, "Found an IO APIC: [%x] %x\n",
                    HalpMpInfoTable.IOApicCount,
                    TraversePtr);
            HalDisplayString(string);
#endif

            ioApic = (PIOAPIC)TraversePtr;

            if (Phase == 0) {
                //
                // Found an IO APIC entry.  Record the info from
                // the table.
                //

                apicNo = (UCHAR)HalpMpInfoTable.IOApicCount;

                HalpIoApicId[apicNo] = ioApic->IOAPICID;

                HalpMpInfoTable.IoApicIntiBase[apicNo] =
                    ioApic->SystemVectorBase;

                HalpMpInfoTable.IoApicPhys[apicNo] =
                    ioApic->IOAPICAddress;

                //
                // Get a virtual address for it.
                //

                physicalAddress = HalpPtrToPhysicalAddress(
                                   UlongToPtr(ioApic->IOAPICAddress) );

                HalpMpInfoTable.IoApicBase[apicNo] =
                    HalpMapPhysicalMemoryWriteThrough( physicalAddress, 1 );

                apic = (PIO_APIC_UNIT)HalpMpInfoTable.IoApicBase[apicNo];

                if (!apic) {
#ifdef DEBUGGING
                    sprintf(string, "Couldn't map the I/O apic\n");
                    HalDisplayString(string);
#endif
                    return;
                }

                //
                // Dig the number of Intis out of the hardware.
                //

                apic->RegisterSelect = IO_VERS_REGISTER;
                apic->RegisterWindow = 0;
                versionUnion.raw = apic->RegisterWindow;

                HalpMaxApicInti[apicNo] = versionUnion.version.MaxRedirEntries + 1;

                //
                // Also store the version so that it can be retrieved by the ACPI driver
                //

                HalpIOApicVersion[apicNo] = versionUnion.raw;

#ifdef DEBUGGING
                    sprintf(string, "GSIV base: %x  PhysAddr: %x  VirtAddr: %x  Intis: %x\n",
                            HalpMpInfoTable.IoApicVectorBase[apicNo],
                            HalpMpInfoTable.IoApicPhys[apicNo],
                            HalpMpInfoTable.IoApicBase[apicNo],
                            HalpMaxApicInti[apicNo]);

                    HalDisplayString(string);
#endif

                HalpMpInfoTable.IOApicCount += 1;
            }

            TraversePtr += ioApic->Length;

        } else if ((((PISA_VECTOR)TraversePtr)->Type == ISA_VECTOR_OVERRIDE) &&
           (((PISA_VECTOR)TraversePtr)->Length == ISA_VECTOR_OVERRIDE_LENGTH)) {

#ifdef DEBUGGING
            sprintf(string, "Found an ISA VECTOR: %x, %x -> %x, flags: %x\n",
                    TraversePtr,
                    ((PISA_VECTOR)TraversePtr)->Source,
                    ((PISA_VECTOR)TraversePtr)->GlobalSystemInterruptVector,
                    ((PISA_VECTOR)TraversePtr)->Flags
                    );
            HalDisplayString(string);
#endif

            if (Phase == 0) {

                //
                // Found an ISA vector redirection entry.
                //

                HalpPicVectorRedirect[((PISA_VECTOR)TraversePtr)->Source] =
                    ((PISA_VECTOR)TraversePtr)->GlobalSystemInterruptVector;

                HalpPicVectorFlags[((PISA_VECTOR)TraversePtr)->Source] =
                    ((PISA_VECTOR)TraversePtr)->Flags;

            }

            TraversePtr += ISA_VECTOR_OVERRIDE_LENGTH;

        } else if ((((PIO_NMISOURCE)TraversePtr)->Type == IO_NMI_SOURCE) &&
           (((PIO_NMISOURCE)TraversePtr)->Length == IO_NMI_SOURCE_LENGTH)) {

            if (Phase == 1) {

                BOOLEAN found;
                USHORT  inti;

                found = HalpGetApicInterruptDesc(0,
                                                 0,
                                                 ((PIO_NMISOURCE)TraversePtr)->GlobalSystemInterruptVector,
                                                 &inti);

                if (found) {

                    HalpIntiInfo[inti].Type = INT_TYPE_NMI;
                    HalpIntiInfo[inti].Level =
                        (((((((PIO_NMISOURCE)TraversePtr)->Flags & EL_BITS) == EL_EDGE_TRIGGERED) ||
                             ((PIO_NMISOURCE)TraversePtr)->Flags & EL_BITS) == EL_CONFORMS_WITH_BUS)
                         ? CFG_EDGE : CFG_LEVEL);
                    HalpIntiInfo[inti].Polarity =
                        ((PIO_NMISOURCE)TraversePtr)->Flags & PO_BITS;
                }
            }

            TraversePtr += IO_NMI_SOURCE_LENGTH;

        } else if ((((PLOCAL_NMISOURCE)TraversePtr)->Type == LOCAL_NMI_SOURCE) &&
           (((PLOCAL_NMISOURCE)TraversePtr)->Length == LOCAL_NMI_SOURCE_LENGTH)) {

            if (Phase == 1) {

                //
                // While running through phase 1, we should catalog local NMI sources.
                //

                if (!HalpLocalNmiSources) {

                    //
                    // Allocate enough pool to point to all the possible local NMI structures.
                    // Since there are two NMI pins on each processor, this is the number of processors
                    // times two times the size of a pointer.
                    //

                    HalpLocalNmiSources = ExAllocatePoolWithTag(NonPagedPool,
                                                                sizeof(PVOID) * HalpMaxProcs * 2,
                                                                HAL_POOL_TAG);

                    RtlZeroMemory(HalpLocalNmiSources,
                                  sizeof(PVOID) * HalpMaxProcs * 2);
                }

                HalpLocalNmiSources[nmiSources++] = (PVOID)TraversePtr;

            }

            TraversePtr += LOCAL_NMI_SOURCE_LENGTH;

        } else {
#ifdef DEBUGGING
            sprintf(string, "%x: %x \n", TraversePtr, *TraversePtr);
            HalDisplayString(string);
#endif
            //
            // Found random bits in the table.  Try the next byte and
            // see if we can make sense of it.
            //

            TraversePtr += 1;
        }
    }

    return;
}

BOOLEAN
HalpVerifyIOUnit(
    IN PUCHAR BaseAddress
    )
/*++

Routine Description:

    Verify that an IO Unit exists at the specified address

 Arguments:

    BaseAddress - Virtual address of the IO Unit to test.

 Return Value:
    BOOLEAN - TRUE if a IO Unit was found at the passed address
            - FALSE otherwise

--*/

{
    union ApicUnion {
        ULONG Raw;
        struct ApicVersion Ver;
    } Temp1, Temp2;

    struct ApicIoUnit *IoUnitPtr = (struct ApicIoUnit *) BaseAddress;

    //
    //  The documented detection mechanism is to write all zeros to
    //  the Version register.  Then read it back.  The IO Unit exists if the
    //  same result is read both times and the Version is valid.
    //

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    IoUnitPtr->RegisterWindow = 0;

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    Temp1.Raw = IoUnitPtr->RegisterWindow;

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    IoUnitPtr->RegisterWindow = 0;

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    Temp2.Raw = IoUnitPtr->RegisterWindow;

    if ((Temp1.Ver.Version != Temp2.Ver.Version) ||
        (Temp1.Ver.MaxRedirEntries != Temp2.Ver.MaxRedirEntries)) {
        //
        //  No IO Unit There
        //
        return (FALSE);
    }

    return (TRUE);
}

#ifdef DEBUGGING
struct PcMpTable *PcMpTablePtr, *PcMpDefaultTablePtrs[];

void
ComputeCheckSum(UCHAR This, UCHAR That)
{
}
#endif


VOID
HalpSaveInterruptControllerState(
    VOID
    )
{

    HalpHiberInProgress = TRUE;
}

VOID
HalpRestoreInterruptControllerState(
    VOID
    )
{
    //
    // Restore the IO APIC state
    //

    HalpRestoreIoApicRedirTable();

    HalpPicStateIntact = TRUE;
}

VOID
HalpSetInterruptControllerWakeupState(
    ULONG Context
    )
{
    LOADER_PARAMETER_BLOCK LoaderBlock;
    SLEEP_STATE_CONTEXT sleepContext;
    BOOLEAN IsMpSystem;
    ULONG   flags;
    KIRQL   OldIrql;
    KPRCB   Prcb;
    ULONG   ii;
    USHORT  inti;
    ULONG   localApicId;
    ULONG   oldProcNumber, oldProcsStarted;
    ULONG   localApicBase;

    sleepContext.AsULONG = Context;

    flags = HalpDisableInterrupts();

    if (sleepContext.bits.Flags & SLEEP_STATE_RESTART_OTHER_PROCESSORS) {

        //
        // If you are remapping local apic, io apic and ACPI MAPIC table
        // resources, you first have to unmap the current resources!!!
        // The BIOS may have created the MAPIC table at a different place or may
        // have changed values like processor local APIC IDs. Reparse it.
        //

        ASSERT(HalpApicTable);
        oldProcNumber = HalpMpInfoTable.ProcessorCount;
        oldProcsStarted = HalpMpInfoTable.NtProcessors;
        localApicBase = HalpMpInfoTable.LocalApicBase;

        HalpUnMapIOApics();

        RtlZeroMemory (&HalpMpInfoTable, sizeof(MP_INFO));
        RtlZeroMemory(HalpProcLocalApicTable,
                      sizeof(PROC_LOCAL_APIC) * MAX_PROCESSORS);

        HalpInitMpInfo(HalpApicTable, 0);

        if (HalpMpInfoTable.ProcessorCount != oldProcNumber) {

            KeBugCheckEx(HAL_INITIALIZATION_FAILED,
                         0x2000,
                         oldProcNumber,
                         HalpMpInfoTable.ProcessorCount,
                         0);
        }

        HalpMpInfoTable.NtProcessors = oldProcsStarted;
        HalpMpInfoTable.LocalApicBase = localApicBase;

        RtlZeroMemory(&LoaderBlock, sizeof(LoaderBlock));
        RtlZeroMemory(&Prcb, sizeof(Prcb));
        LoaderBlock.Prcb = (ULONG_PTR) &Prcb;
    }

    //
    // Initialize minimum global hardware state needed.
    //

    HalpIpiClock = 0;
    HalpInitializeIOUnits();
    HalpInitializePICs(FALSE);
    HalpSet8259Mask(HalpGlobal8259Mask);

    //
    // Initialize boot processor's local APIC so it can wake other processors
    //

    HalpInitializeLocalUnit ();
    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    //
    // Wake up the other processors
    //

    if (sleepContext.bits.Flags & SLEEP_STATE_RESTART_OTHER_PROCESSORS) {

        //
        // Fill in this processor's Apic ID.
        //

        localApicId = *(PVULONG)(LOCALAPIC + LU_ID_REGISTER);

        localApicId &= APIC_ID_MASK;
        localApicId >>= APIC_ID_SHIFT;

        ((PHALPRCB)KeGetCurrentPrcb()->HalReserved)->PCMPApicID = (UCHAR)localApicId;

        //
        // Mark this processor as started.
        //

        for (ii = 0; ii < HalpMpInfoTable.NtProcessors; ii++) {

            if (HalpProcLocalApicTable[ii].ApicID ==
                ((PHALPRCB)KeGetCurrentPrcb()->HalReserved)->PCMPApicID) {

                HalpProcLocalApicTable[ii].Started = TRUE;
                HalpProcLocalApicTable[ii].Enumerated = TRUE;

                break;
            }
        }

        ASSERT(ii != HalpMpInfoTable.ProcessorCount);

        for(ii = 1; ii < HalpMpInfoTable.NtProcessors; ++ii)  {

            // Set processor number in dummy loader parameter block

            Prcb.Number = (UCHAR) ii;
            CurTiledCr3LowPart = HalpTiledCr3Addresses[ii].LowPart;
            if (!HalStartNextProcessor(&LoaderBlock, &HalpHiberProcState[ii]))  {

                //
                // We could not start a processor. This is a fatal error.
                //

                KeBugCheckEx(HAL_INITIALIZATION_FAILED,
                             0x2001,
                             oldProcNumber,
                             HalpMpInfoTable.NtProcessors,
                             0);
            }
        }
    }

    //
    // Enable the clock interrupt.
    //

    HalpGetApicInterruptDesc(
            DEFAULT_PC_BUS,
            0,
            HalpPicVectorRedirect[RTC_IRQ],
            &inti
            );

    HalpSetRedirEntry((UCHAR)inti,
                      HalpIntiInfo[inti].Entry,
                      HalpIntiInfo[inti].Destinations << DESTINATION_SHIFT);

    HalpPicStateIntact = FALSE;

    HalpRestoreInterrupts(flags);
}

BOOLEAN
HalpAcpiPicStateIntact(
    VOID
    )
{
    return HalpPicStateIntact;
}


ULONG HalpGetApicVersion(ULONG ApicNo)
{
/*++
Routine Description:

   Obtains the contents of the version register
   for a particular system IO APIC unit. These contents
   are saved by the HAL in HalpInitMpInfo.

Arguments:

   ApicNo - the number of the IO APIC Unit whose version we want.


Return Value:

   The contents of the version register for the given IO APIC unit.

   A 0 is returned if no version can be obtained because the given
   APIC number is not valid.
*/

   // If this APIC has been found by the HAL ...

   if (ApicNo < HalpMpInfoTable.IOApicCount) {

      // ... return its version

      return HalpIOApicVersion[ApicNo];
   }
   else
   {
      // Otherwise, return 0.

      return 0;
   }
}

VOID
HalpMaskAcpiInterrupt(
    VOID
    )
{
    USHORT inti = 0;
    ULONG  apicEntry;

    HalpGetApicInterruptDesc(
            DEFAULT_PC_BUS,
            0,
            HalpPicVectorRedirect[HalpFixedAcpiDescTable.sci_int_vector],
            &inti
            );

    apicEntry = HalpIntiInfo[inti].Entry;
    apicEntry |= INTERRUPT_MASKED;

    HalpSetRedirEntry((UCHAR)inti,
                      apicEntry,
                      0);


}

VOID
HalpUnmaskAcpiInterrupt(
    VOID
    )
{
    USHORT inti = 0;

    HalpGetApicInterruptDesc(
            DEFAULT_PC_BUS,
            0,
            HalpPicVectorRedirect[HalpFixedAcpiDescTable.sci_int_vector],
            &inti
            );

    HalpSetRedirEntry((UCHAR)inti,
                      HalpIntiInfo[inti].Entry,
                      HalpIntiInfo[inti].Destinations << DESTINATION_SHIFT);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\pmisabus.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmapic.c

Abstract:

    Implements functions specific to ISA busses
    in ACPI-APIC machines.

Author:

    Jake Oshins (jakeo) 11-October-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"

NTSTATUS
TranslateGlobalVectorToIsaVector(
    IN  ULONG   GlobalVector,
    OUT PULONG  IsaVector
    );

NTSTATUS
HalacpiIrqTranslateResourceRequirementsIsa(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalacpiIrqTranslateResourcesIsa(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

extern ULONG HalpPicVectorRedirect[];
extern FADT HalpFixedAcpiDescTable;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TranslateGlobalVectorToIsaVector)
#pragma alloc_text(PAGE, HalacpiIrqTranslateResourceRequirementsIsa)
#pragma alloc_text(PAGE, HalacpiIrqTranslateResourcesIsa)
#pragma alloc_text(PAGE, HalacpiGetInterruptTranslator)
#endif

#define TranslateIsaVectorToGlobalVector(vector)  \
            (HalpPicVectorRedirect[vector])

NTSTATUS
TranslateGlobalVectorToIsaVector(
    IN  ULONG   GlobalVector,
    OUT PULONG  IsaVector
    )
{
    UCHAR   i;

    for (i = 0; i < PIC_VECTORS; i++) {

        if (HalpPicVectorRedirect[i] == GlobalVector) {

            *IsaVector = i;

            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}


NTSTATUS
HalacpiIrqTranslateResourceRequirementsIsa(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
/*++

Routine Description:

    This function is basically a wrapper for
    HalIrqTranslateResourceRequirementsRoot that understands
    the weirdnesses of the ISA bus.

Arguments:

Return Value:

    status

--*/
{
    PIO_RESOURCE_DESCRIPTOR modSource, target, rootTarget;
    NTSTATUS                status;
    BOOLEAN                 deleteResource;
    ULONG                   sourceCount = 0;
    ULONG                   targetCount = 0;
    ULONG                   resource, resourceLength;
    ULONG                   rootCount;
    ULONG                   irq, startIrq, endIrq;
    ULONG                   maxTargets;

    PAGED_CODE();
    ASSERT(Source->Type == CmResourceTypeInterrupt);

    maxTargets = Source->u.Interrupt.MaximumVector -
                     Source->u.Interrupt.MinimumVector + 3;

    resourceLength = sizeof(IO_RESOURCE_DESCRIPTOR) * maxTargets;

    modSource = ExAllocatePoolWithTag(PagedPool, resourceLength, HAL_POOL_TAG);

    if (!modSource) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modSource, resourceLength);

    //
    // Is the PIC_SLAVE_IRQ in this resource?
    //
    if ((Source->u.Interrupt.MinimumVector <= PIC_SLAVE_IRQ) &&
        (Source->u.Interrupt.MaximumVector >= PIC_SLAVE_IRQ)) {

        //
        // Clip the maximum
        //
        if (Source->u.Interrupt.MinimumVector < PIC_SLAVE_IRQ) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MinimumVector =
                Source->u.Interrupt.MinimumVector;

            modSource[sourceCount].u.Interrupt.MaximumVector =
                PIC_SLAVE_IRQ - 1;

            sourceCount++;
        }

        //
        // Clip the minimum
        //
        if (Source->u.Interrupt.MaximumVector > PIC_SLAVE_IRQ) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MaximumVector =
                Source->u.Interrupt.MaximumVector;

            modSource[sourceCount].u.Interrupt.MinimumVector =
                PIC_SLAVE_IRQ + 1;

            sourceCount++;
        }

        //
        // In ISA machines, the PIC_SLAVE_IRQ is rerouted
        // to PIC_SLAVE_REDIRECT.  So find out if PIC_SLAVE_REDIRECT
        // is within this list. If it isn't we need to add it.
        //
        if (!((Source->u.Interrupt.MinimumVector <= PIC_SLAVE_REDIRECT) &&
             (Source->u.Interrupt.MaximumVector >= PIC_SLAVE_REDIRECT))) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MinimumVector = PIC_SLAVE_REDIRECT;
            modSource[sourceCount].u.Interrupt.MaximumVector = PIC_SLAVE_REDIRECT;

            sourceCount++;
        }

    } else {

        *modSource = *Source;
        sourceCount = 1;
    }

    //
    // Clip out the SCI vector, if it is here.  Also limit the vectors
    // to those that might be on an ISA bus.
    //

    for (resource = 0; resource < sourceCount; resource++) {

        //
        // Make sure that all values are within ISA ranges.
        //

        if ((modSource[resource].u.Interrupt.MaximumVector >= PIC_VECTORS) ||
            (modSource[resource].u.Interrupt.MinimumVector >= PIC_VECTORS)) {

            ExFreePool(modSource);
            return STATUS_UNSUCCESSFUL;
        }

        if ((modSource[resource].u.Interrupt.MinimumVector <=
                HalpFixedAcpiDescTable.sci_int_vector) &&
            (modSource[resource].u.Interrupt.MaximumVector >=
                HalpFixedAcpiDescTable.sci_int_vector)) {

            //
            // The SCI vector is within this range.
            //

            if (modSource[resource].u.Interrupt.MinimumVector <
                    HalpFixedAcpiDescTable.sci_int_vector) {

                //
                // Put a new range on the end of modSource.
                //

                modSource[sourceCount].u.Interrupt.MinimumVector =
                    modSource[resource].u.Interrupt.MinimumVector;

                modSource[sourceCount].u.Interrupt.MaximumVector =
                    HalpFixedAcpiDescTable.sci_int_vector - 1;

                sourceCount++;
            }

            if (modSource[resource].u.Interrupt.MaximumVector >
                    HalpFixedAcpiDescTable.sci_int_vector) {

                //
                // Put a new range on the end of modSource.
                //

                modSource[sourceCount].u.Interrupt.MinimumVector =
                    HalpFixedAcpiDescTable.sci_int_vector + 1;

                modSource[sourceCount].u.Interrupt.MaximumVector =
                    modSource[resource].u.Interrupt.MaximumVector;

                sourceCount++;
            }

            //
            // Now remove the range that we just broke up.
            //

            RtlMoveMemory(modSource + resource,
                          modSource + resource + 1,
                          sizeof(IO_RESOURCE_DESCRIPTOR) *
                            (sourceCount - resource));

            sourceCount--;
        }
    }


    target = ExAllocatePoolWithTag(PagedPool, resourceLength, HAL_POOL_TAG);

    if (!target) {
        ExFreePool(modSource);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(target, resourceLength);

    //
    // Now translate each range from ISA vectors to ACPI
    // "global system interrupt vectors."  Since GSIVs aren't
    // necessarily contiguous with respect to the ISA vectors,
    // this may involve breaking each range up into smaller
    // ranges, each independently translated into the GSIV space.
    //
    for (resource = 0; resource < sourceCount; resource++) {

        //
        // For each existing resource, start with the minimum
        // and maximum, unchanged.
        //

        irq    = modSource[resource].u.Interrupt.MinimumVector;
        endIrq = modSource[resource].u.Interrupt.MaximumVector;

        do {

            //
            // Now cycle through every IRQ in this range, testing
            // to see if its translated value is contiguous
            // with respect to the translated value of the next
            // IRQ in the range.
            //

            startIrq = irq;

            for (; irq < endIrq; irq++) {

                if (TranslateIsaVectorToGlobalVector(irq) + 1 !=
                    TranslateIsaVectorToGlobalVector(irq + 1)) {

                    //
                    // This range is not contiguous.  Stop now
                    // and create a target range.
                    //

                    break;
                }
            }

            //
            // Clone the source descriptor
            //
            target[targetCount] = *Source;

            //
            // Fill in the relevant changes.
            //
            target[targetCount].u.Interrupt.MinimumVector =
                TranslateIsaVectorToGlobalVector(startIrq);

            target[targetCount].u.Interrupt.MaximumVector =
                TranslateIsaVectorToGlobalVector(irq);


            ASSERT(target[targetCount].u.Interrupt.MinimumVector <=
                     target[targetCount].u.Interrupt.MaximumVector);

            targetCount++;

        } while (irq != endIrq);
    }

    *TargetCount = targetCount;

    if (targetCount > 0) {

        *Target = target;

    } else {

        ExFreePool(target);
    }

    ExFreePool(modSource);
    return STATUS_SUCCESS;
}

NTSTATUS
HalacpiIrqTranslateResourcesIsa(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function is basically a wrapper for
    HalIrqTranslateResourcesRoot that understands
    the weirdnesses of the ISA bus.

Arguments:

Return Value:

    status

--*/
{
    NTSTATUS    status;
    BOOLEAN     usePicSlave = FALSE;
    ULONG       i;
    ULONG       vector;

    PAGED_CODE();

    ASSERT(Source->Type == CmResourceTypeInterrupt);

    //
    // Copy everything
    //
    *Target = *Source;

    switch (Direction) {
    case TranslateChildToParent:

        Target->u.Interrupt.Level  =
            TranslateIsaVectorToGlobalVector(Source->u.Interrupt.Level);

        Target->u.Interrupt.Vector =
            TranslateIsaVectorToGlobalVector(Source->u.Interrupt.Vector);

        break;

    case TranslateParentToChild:

        status = TranslateGlobalVectorToIsaVector(Source->u.Interrupt.Level,
                                                  &vector);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        Target->u.Interrupt.Level = vector;

        status = TranslateGlobalVectorToIsaVector(Source->u.Interrupt.Vector,
                                                  &vector);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        Target->u.Interrupt.Vector = vector;

        //
        // Because the ISA interrupt controller is
        // cascaded, there is one case where there is
        // a two-to-one mapping for interrupt sources.
        // (On a PC, both 2 and 9 trigger vector 9.)
        //
        // We need to account for this and deliver the
        // right value back to the driver.
        //

        if (Target->u.Interrupt.Level == PIC_SLAVE_REDIRECT) {

            //
            // Search the Alternatives list.  If it contains
            // PIC_SLAVE_IRQ but not PIC_SLAVE_REDIRECT,
            // we should return PIC_SLAVE_IRQ.
            //

            for (i = 0; i < AlternativesCount; i++) {

                if ((Alternatives[i].u.Interrupt.MinimumVector >= PIC_SLAVE_REDIRECT) &&
                    (Alternatives[i].u.Interrupt.MaximumVector <= PIC_SLAVE_REDIRECT)) {

                    //
                    // The list contains, PIC_SLAVE_REDIRECT.  Stop
                    // looking.
                    //

                    usePicSlave = FALSE;
                    break;
                }

                if ((Alternatives[i].u.Interrupt.MinimumVector >= PIC_SLAVE_IRQ) &&
                    (Alternatives[i].u.Interrupt.MaximumVector <= PIC_SLAVE_IRQ)) {

                    //
                    // The list contains, PIC_SLAVE_IRQ.  Use it
                    // unless we find PIC_SLAVE_REDIRECT later.
                    //

                    usePicSlave = TRUE;
                }
            }

            if (usePicSlave) {

                Target->u.Interrupt.Level  = PIC_SLAVE_IRQ;
                Target->u.Interrupt.Vector = PIC_SLAVE_IRQ;
            }
        }

        break;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
HalacpiGetInterruptTranslator(
	IN INTERFACE_TYPE ParentInterfaceType,
	IN ULONG ParentBusNumber,
	IN INTERFACE_TYPE BridgeInterfaceType,
	IN USHORT Size,
	IN USHORT Version,
	OUT PTRANSLATOR_INTERFACE Translator,
	OUT PULONG BridgeBusNumber
	)
/*++

Routine Description:


Arguments:

	ParentInterfaceType - The type of the bus the bridge lives on (normally PCI).

	ParentBusNumber - The number of the bus the bridge lives on.

	ParentSlotNumber - The slot number the bridge lives in (where valid).

	BridgeInterfaceType - The bus type the bridge provides (ie ISA for a PCI-ISA bridge).

	ResourceType - The resource type we want to translate.

	Size - The size of the translator buffer.

	Version - The version of the translator interface requested.

	Translator - Pointer to the buffer where the translator should be returned

	BridgeBusNumber - Pointer to where the bus number of the bridge bus should be returned

Return Value:

    Returns the status of this operation.

--*/
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(ParentInterfaceType);
    UNREFERENCED_PARAMETER(ParentBusNumber);

    ASSERT(Version == HAL_IRQ_TRANSLATOR_VERSION);
    ASSERT(Size >= sizeof (TRANSLATOR_INTERFACE));

    switch (BridgeInterfaceType) {
    case Eisa:
    case Isa:
    case InterfaceTypeUndefined:   // special "IDE" cookie

        //
        // Pass back an interface for an IRQ translator for
        // the (E)ISA interrupts.
        //
        RtlZeroMemory(Translator, sizeof (TRANSLATOR_INTERFACE));

        Translator->Size = sizeof (TRANSLATOR_INTERFACE);
        Translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
        Translator->InterfaceReference = &HalTranslatorReference;
        Translator->InterfaceDereference = &HalTranslatorDereference;
        Translator->TranslateResources = &HalacpiIrqTranslateResourcesIsa;
        Translator->TranslateResourceRequirements = &HalacpiIrqTranslateResourceRequirementsIsa;

        return STATUS_SUCCESS;

    default:
        return STATUS_NOT_IMPLEMENTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\pmbus.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmbus.c

Abstract:

    Implements functions that were done in
    previous HALs by bus handlers.  Basically,
    these will be somewhat simplified versions
    since much of the code in the bus handlers
    has effectively been moved into bus 
    drivers in NT5.

Author:

    Jake Oshins (jakeo) 1-Dec-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"

ULONG HalpGetCmosData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

ULONG HalpSetCmosData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

HalpGetEisaData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
HalpAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

BOOLEAN
HalpTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

BOOLEAN
HalpFindBusAddressTranslation(
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PULONG_PTR Context,
    IN BOOLEAN NextBus
    );

extern BUS_HANDLER  HalpFakePciBusHandler;
extern ULONG        HalpMinPciBus;
extern ULONG        HalpMaxPciBus;
extern ULONG HalpPicVectorRedirect[];

VOID
HalpGetNMICrashFlag (
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitNonBusHandler)
#pragma alloc_text(INIT,HalpInitializePciBus)
#pragma alloc_text(PAGE,HalAssignSlotResources)
#pragma alloc_text(PAGE,HalpAssignSlotResources)
#endif

VOID
HalpInitNonBusHandler (
    VOID
    )
{
    HALPDISPATCH->HalPciTranslateBusAddress = HalpTranslateBusAddress;
    HALPDISPATCH->HalPciAssignSlotResources = HalpAssignSlotResources;
    HALPDISPATCH->HalFindBusAddressTranslation = HalpFindBusAddressTranslation;
}

VOID
HalpInitializePciBus(
    VOID
    )
{
    HalpInitializePciStubs();

    //
    // Check if we should crashdump on NMI.
    //

    HalpGetNMICrashFlag();
}

NTSTATUS
HalAdjustResourceList (
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    )
{
    return STATUS_SUCCESS;
}

ULONG
HalGetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalGetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}


ULONG
HalGetBusDataByOffset (
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for GetBusData

--*/
{
    PCI_SLOT_NUMBER slot;
    BUS_HANDLER bus;
    ULONG length;
    
    switch (BusDataType) {
    case PCIConfiguration:

        //
        // Hack.  If the bus is outside of the known PCI busses, return
        // a length of zero.
        //

        if ((BusNumber < HalpMinPciBus) || (BusNumber > HalpMaxPciBus)) {
            return 0;
        }

        RtlCopyMemory(&bus, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
        bus.BusNumber = BusNumber;
        slot.u.AsULONG = SlotNumber;
    
        length = HalpGetPCIData(&bus,
                                &bus,
                                slot,
                                Buffer,
                                Offset,
                                Length
                                );
        
        return length;

    case Cmos:
        return HalpGetCmosData(0, SlotNumber, Buffer, Length);

    case EisaConfiguration:

        //
        // Fake a bus handler.
        //
        
        bus.BusNumber = 0;

        return HalpGetEisaData(&bus,
                               &bus,
                               SlotNumber,
                               Buffer,
                               Offset,
                               Length
                               );

    default:
        return 0;
    }
}

ULONG
HalSetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalSetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

ULONG
HalSetBusDataByOffset(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for SetBusData

--*/
{
    PCI_SLOT_NUMBER slot;
    BUS_HANDLER bus;

    switch (BusDataType) {
    case PCIConfiguration:

        RtlCopyMemory(&bus, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
        bus.BusNumber = BusNumber;
        slot.u.AsULONG = SlotNumber;

        return HalpSetPCIData(&bus,
                              &bus,
                              slot,
                              Buffer,
                              Offset,
                              Length
                              );
    case Cmos:

        return HalpSetCmosData(0, SlotNumber, Buffer, Length);

    default:
        return 0;
    }
}

NTSTATUS
HalAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
{
    if (BusType == PCIBus) {
        //
        // Call through the HAL private dispatch table
        // for PCI-related translations.  This is part 
        // of transitioning the HAL out of the bus 
        // management business.
        //
        return HALPDISPATCH->HalPciAssignSlotResources(RegistryPath,
                                                       DriverClassName,
                                                       DriverObject,
                                                       DeviceObject,
                                                       BusType,
                                                       BusNumber,
                                                       SlotNumber,
                                                       AllocatedResources);
    } else {

        return HalpAssignSlotResources(RegistryPath,
                                       DriverClassName,
                                       DriverObject,
                                       DeviceObject,
                                       BusType,
                                       BusNumber,
                                       SlotNumber,
                                       AllocatedResources);
    }
}

NTSTATUS
HalpAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
/*++

Routine Description:

    Dispatcher for AssignSlotResources

--*/
{
    BUS_HANDLER busHand;
    
    PAGED_CODE();
    
    switch (BusType) {
    case PCIBus:

        //
        // Fake a bus handler.
        //
    
        RtlCopyMemory(&busHand, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
        busHand.BusNumber = BusNumber;

        return HalpAssignPCISlotResources(&busHand,
                                          &busHand,
                                          RegistryPath,
                                          DriverClassName,
                                          DriverObject,
                                          DeviceObject,
                                          SlotNumber,
                                          AllocatedResources);

    default:
        return STATUS_NOT_IMPLEMENTED;
    }
    
}


ULONG
HalGetInterruptVector(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )
/*++

Routine Description:

    Dispatcher for GetInterruptVector

--*/
{
    BUS_HANDLER busHand;
    
    //
    // If this is an ISA vector, pass it through the ISA vector
    // redirection table.
    //

    if (InterfaceType == Isa) {
        
        ASSERT(BusInterruptVector < PIC_VECTORS);
        
        BusInterruptVector = HalpPicVectorRedirect[BusInterruptVector];
        BusInterruptLevel = HalpPicVectorRedirect[BusInterruptLevel];
    }
    
    //
    // Fake bus handlers.
    //

    RtlCopyMemory(&busHand, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
    
    busHand.BusNumber = BusNumber;
    busHand.InterfaceType = InterfaceType;
    busHand.ParentHandler = &busHand;
    
    return HalpGetSystemInterruptVector(&busHand,
                                        &busHand,
                                        BusInterruptLevel,
                                        BusInterruptVector,
                                        Irql,
                                        Affinity);
}

BOOLEAN
HalTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
{
    if (InterfaceType == PCIBus) {
        //
        // Call through the HAL private dispatch table
        // for PCI-related translations.  This is part 
        // of transitioning the HAL out of the bus 
        // management business.
        //
        return HALPDISPATCH->HalPciTranslateBusAddress(InterfaceType,
                                                       BusNumber,
                                                       BusAddress,
                                                       AddressSpace,
                                                       TranslatedAddress);
    } else {
        return HalpTranslateBusAddress(InterfaceType,
                                       BusNumber,
                                       BusAddress,
                                       AddressSpace,
                                       TranslatedAddress);
    }
};

BOOLEAN
HalpTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
/*++

Routine Description:

    Dispatcher for TranslateBusAddress

--*/
{
    *TranslatedAddress = BusAddress;
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\pmtimerc.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pmtimerc.c

Abstract:

    Implements workarounds for PIIX4 bugs.  The
    nature of the ACPI timer in PIIX4 is that it
    occasionally returns completely bogus data.
    Intel claims that this happens about 0.02% of
    the time when it is polled continuously.  As NT
    almost never polls it continuously, we don't
    really know what the real behavior is.

    The workaround is something like this:  On
    every clock tick, we read the timer.  Using this
    value, we compute an upper bound for what the
    timer may read by the next clock tick.  We also
    record the minimum value ever returned.  If, at
    any time, we read the timer and it does not fall
    within the minimum and upper bound, then we read
    it again.  If it either falls within the bounds
    or it is very close to the last read, we use it.
    If not, we read it again.

    This behavior allows us to read the timer only
    once almost all the time that we need a time
    stamp.  Exiting the debugger is almost guaranteed
    to cause the read-twice behavior.

Author:

    Jake Oshins (jakeo) 30-Oct-1998

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#ifdef APIC_HAL
#include "apic.inc"
#include "ntapic.inc"
#endif

BOOLEAN
HalpPmTimerSpecialStall(
    IN ULONG Ticks
    );

BOOLEAN
HalpPmTimerScaleTimers(
    VOID
    );

LARGE_INTEGER
HalpPmTimerQueryPerfCount(
   OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
   );

VOID
HalpAdjustUpperBoundTable2X(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpPmTimerScaleTimers)
#pragma alloc_text(INIT, HalpPmTimerSpecialStall)
#pragma alloc_text(INIT, HalpAdjustUpperBoundTable2X)
#endif

typedef struct {
    ULONG   CurrentTimePort;
    volatile ULONG TimeLow;
    volatile ULONG TimeHigh2;
    volatile ULONG TimeHigh1;
    ULONG   MsbMask;
    ULONG   BiasLow;
    ULONG   BiasHigh;
    volatile ULONG UpperBoundLow;
    volatile ULONG UpperBoundHigh2;
    volatile ULONG UpperBoundHigh1;
} TIMER_INFO, *PTIMER_INFO;

typedef struct {
    ULONG   RawRead[2];
    ULONG   AdjustedLow[2];
    ULONG   AdjustedHigh[2];
    ULONG   TITL;
    ULONG   TITH;
    ULONG   UBL;
    ULONG   UBH;
    ULONG   ReturnedLow;
    ULONG   ReturnedHigh;
    ULONG   ReadCount;
    ULONG   TickMin;
    ULONG   TickCount;
    ULONG   TickNewUB;
    //UCHAR   padding[4];
} TIMER_PERF_INDEX ,*PTIMER_PERF_INDEX;

extern TIMER_INFO TimerInfo;

#if DBG
ULONG LastKQPCValue[3] = {0};
static ULARGE_INTEGER LastClockSkew = { 0, 0 };
#endif

extern PVOID QueryTimer;
typedef LARGE_INTEGER (*PQUERY_TIMER)(VOID);

#ifndef NO_PM_KEQPC

extern ULONG HalpCurrentMSRateTableIndex;
extern UCHAR HalpBrokenAcpiTimer;
extern UCHAR HalpPiix4;

#if DBG && !defined(_AMD64_)
#define DBG_TIMER_PERF 1
#else
#define DBG_TIMER_PERF 0
#endif


#if DBG_TIMER_PERF
extern TIMER_PERF_INDEX TimerPerf[];
extern ULONG TimerPerfIndex;
#endif

#if 0
static KSPIN_LOCK HalpBrokenTimerLock; 
#endif

//
// The UpperBoundTable contains the values which should be added
// to the current counter value to ensure that the upper bound is
// reasonable.  Values listed here are for all the 15 possible
// timer tick lengths.  The unit is "PM Timer Ticks" and the
// value corresponds to the number of ticks that will pass in
// roughly two timer ticks at this rate.
//
#define UPPER_BOUND_TABLE_SIZE 15
static ULONG HalpPiix4UpperBoundTable[] = {
#if 0
    20000 ,        //  1 ms
    35000 ,        //  2 ms
    50000 ,        //  3 ms
    65000 ,        //  4 ms
    85000 ,        //  5 ms
    100000,        //  6 ms
    115000,        //  7 ms
    130000,        //  8 ms
    150000,        //  9 ms
    165000,        // 10 ms
    180000,        // 11 ms
    195000,        // 12 ms
    211000,        // 13 ms
    230000,        // 14 ms
    250000         // 15 ms
#endif
    14318,
    28636,
    42954,
    57272,
    71590,
    85908,
    100226,
    114544,
    128862,
    143180,
    157498,
    171818,
    186136,
    200454,
    214772
};

VOID
HalpAdjustUpperBoundTable2X(
    VOID
    )
/*++

Routine Description:

    This adjusts the upper bound table for PM timer running at 2X

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG Looper;

    for (Looper = 0; Looper < UPPER_BOUND_TABLE_SIZE; Looper++) {
        HalpPiix4UpperBoundTable[Looper] *= 2;
    }
}


ULONG
HalpQuery8254Counter(
    VOID
    );

static ULARGE_INTEGER ClockSkew = { 0, 0 };
static BOOLEAN PositiveSkew = TRUE;

#ifdef TIMER_DBG
static BOOLEAN DoItOnce = TRUE;
static BOOLEAN PacketLog = TRUE;
static BOOLEAN TimerTick = FALSE;

static ULONG NegativeGlitches = 0;
static ULONG PositiveGlitches = 0;

static ULONG PacketLogCount = 5;

typedef struct _TIMER_PACKET {
    ULONG Hardware;
    ULARGE_INTEGER CurrentRead0;
    ULARGE_INTEGER TimeStamp;
    ULARGE_INTEGER Minimum;
    ULARGE_INTEGER Maximum;
    BOOLEAN PositiveSkew;
    BOOLEAN TimerTick;
    UCHAR Reserved[2];
    ULARGE_INTEGER Skew;
    ULARGE_INTEGER CurrentRead1;
} TIMER_PACKET, *PTIMER_PACKET;

#define MAX_TIMER_PACKETS 10
static ULONG PacketIndex = 0;
static TIMER_PACKET TimerLog[MAX_TIMER_PACKETS];
#endif // TIMER_DBG

#define A_FEW_TICKS 3


ULARGE_INTEGER
FASTCALL
HalpQueryBrokenPiix4(
    VOID
    )
{
    ULARGE_INTEGER  lastRead;
    ULARGE_INTEGER  currentRead;
    ULARGE_INTEGER  currentRead0;
    ULARGE_INTEGER  minTime;
    ULARGE_INTEGER  upperBound;
    ULONG           hardwareVal;
    ULONG           bitsInHardware;
    ULONG           flags;
    ULONG           ClockBits;
    ULARGE_INTEGER  RollOver;
    ULARGE_INTEGER  SkewedTime;
#ifndef NT_UP
    KIRQL Irql;
#endif

#ifdef TIMER_DBG
    ULONG Index;
#endif

#if DBG_TIMER_PERF
    ULONG readCount = 0;
    PTIMER_PERF_INDEX timerPerfRecord =
        &(TimerPerf[TimerPerfIndex]);

    RtlZeroMemory(timerPerfRecord, sizeof(TIMER_PERF_INDEX));
#endif

    //
    // N.B.  This is, of course, not MP safe.  But none
    // of the PIIX4 workaround code is.  MP machines don't
    // use PIIX4 code.
    //

#if 0
    KeAcquireSpinLock(&HalpBrokenTimerLock, &Irql);
#endif

    flags = HalpDisableInterrupts();
    lastRead.QuadPart = 0;
    bitsInHardware = (TimerInfo.MsbMask << 1) - 1;

    //
    // Get current minimum reported time.
    //
    minTime.HighPart = TimerInfo.TimeHigh2;
    minTime.LowPart = TimerInfo.TimeLow;

#if DBG_TIMER_PERF
    timerPerfRecord->TITL = TimerInfo.TimeLow;
    timerPerfRecord->TITH = TimerInfo.TimeHigh1;
#endif

    //
    // Loop until we get a time that we can believe.
    //
    RollOver.QuadPart = 0;
    while (TRUE) {

        //
        // Read the hardware.
        //

        hardwareVal = READ_PORT_ULONG(UlongToPtr(TimerInfo.CurrentTimePort));

#ifdef TIMER_DBG
        if (DoItOnce) {
            RtlZeroMemory(&TimerLog[0], sizeof(TIMER_PACKET) *
                          MAX_TIMER_PACKETS);
            DoItOnce = FALSE;
        }

        if (FALSE) { //((hardwareVal & 0xFFFF8000) == 0xFFFF8000) {
            PacketLog = TRUE;
            PacketLogCount = 5;
        }

        if (PacketLog) {
            
            if (PacketLogCount == 0) {
                PacketLog = FALSE;
            }

            if (PacketLogCount > 0) {
                Index = PacketIndex++ % MAX_TIMER_PACKETS;
                RtlZeroMemory(&TimerLog[Index], sizeof(TIMER_PACKET));
                TimerLog[Index].Hardware = hardwareVal;
                TimerLog[Index].TimerTick = TimerTick;
                
                {
                    ULONG TSCounterHigh;
                    ULONG TSCounterLow;
                    
                    _asm { rdtsc
                               mov TSCounterLow, eax
                               mov TSCounterHigh, edx };
                    
                    TimerLog[Index].TimeStamp.HighPart = TSCounterHigh;
                    TimerLog[Index].TimeStamp.LowPart = TSCounterLow;  
                }
                                
                TimerLog[Index].Minimum = minTime;
                TimerLog[Index].PositiveSkew = PositiveSkew;
                TimerLog[Index].Skew = ClockSkew;
                
                if ((PacketLogCount < 4) && (PacketLogCount > 0)) {
                    PacketLogCount--;
                }
            }
        }
#endif // TIMER_DBG

        currentRead.HighPart = minTime.HighPart;
        currentRead.LowPart = (minTime.LowPart & (~bitsInHardware)) |
            hardwareVal;

        currentRead0 = currentRead;

        //
        // Check for rollover, since this function is called during each
        // system clock interrupt, if the HW has really rolled over, then it
        // should be within upper bound ticks since that is approximately
        // twice the number of ticks we expect during each system clock
        // interrupt, however, some broken timers occasionally tick backward
        // a few ticks, and if this happens, we may accidentally detect
        // more than one rollover during this period depending upon how
        // frequently applications are calling this API, and how often the
        // HW glitches, and this can cause applications to jerk like mad,
        // but we cannot apply heuristics to try to throw out any of these
        // detected rolls during this interval because we could accidentally
        // throw out the one and only legitimate rollover
        //
        if (RollOver.QuadPart > 0) {
            currentRead.QuadPart += RollOver.QuadPart;
        
        } else {
            SkewedTime = minTime;

            //
            // If time is skewed, we need to remove the skew to accurately
            // assess whether the timer has wrapped
            //
            if (ClockSkew.QuadPart > 0) {
                if (PositiveSkew) {
                    SkewedTime.QuadPart -= ClockSkew.QuadPart;
                } else {
                    SkewedTime.QuadPart += ClockSkew.QuadPart;
                }
            }
            
            if (((ULONG)(SkewedTime.LowPart & bitsInHardware) > hardwareVal) &&
                (hardwareVal < (HalpPiix4UpperBoundTable[HalpCurrentMSRateTableIndex] / 2))) {
                
                RollOver.QuadPart = (UINT64)(TimerInfo.MsbMask) << 1;
                currentRead.QuadPart += RollOver.QuadPart;
            }
        }

#ifdef TIMER_DBG
        if (PacketLog) {
            TimerLog[Index].CurrentRead0 = currentRead;
        }
#endif

#if DBG_TIMER_PERF
        readCount = timerPerfRecord->ReadCount;
        readCount &= 1;
        timerPerfRecord->RawRead[readCount] = hardwareVal;
        timerPerfRecord->AdjustedLow[readCount] = currentRead.LowPart;
        timerPerfRecord->AdjustedHigh[readCount] = currentRead.HighPart;
        timerPerfRecord->ReadCount++;
#endif

        //
        // Get the current upper bound.
        //
        upperBound.HighPart = TimerInfo.UpperBoundHigh2;
        upperBound.LowPart = TimerInfo.UpperBoundLow;

#ifdef TIMER_DBG
        if (PacketLog) {
            TimerLog[Index].Maximum = upperBound;
        }
#endif

        if ((minTime.QuadPart <= currentRead.QuadPart) &&
            (currentRead.QuadPart <= upperBound.QuadPart)) {

            //
            // This value from the counter is within the boundaries
            // that we expect.
            //
            //
            // If there was previously a skew, unskew
            //
            ClockSkew.QuadPart = 0;
            break;
        }
        
        if (ClockSkew.QuadPart > 0) {
            SkewedTime = currentRead;

            if (PositiveSkew) {
                SkewedTime.QuadPart += ClockSkew.QuadPart;
            } else {
                SkewedTime.QuadPart -= ClockSkew.QuadPart;
            }

            if ((minTime.QuadPart <= SkewedTime.QuadPart) &&
                (SkewedTime.QuadPart <= upperBound.QuadPart)) {
                
                //
                // This value from the counter is within the boundaries
                // that we accept
                //
                currentRead = SkewedTime;
                break;
            }
        }

        //
        // We are guaranteed to break out of this as soon as we read
        // two consectutive non-decreasing values from the timer whose
        // difference is less than or equal to 0xfff-- is this
        // too much to ask?
        //
        if ((currentRead.QuadPart - lastRead.QuadPart) > 0xfff) {
            lastRead = currentRead;
            continue;
        }

#ifdef TIMER_DBG
        if (PacketLog) {
            if (PacketLogCount > 0) {
                PacketLogCount--;
            }
        }
#endif

        //
        // Now we are really screwed-- we are consistently reading values
        // from the timer, that are not within the boundaries we expect
        //
        // We are going to record/apply a skew that will get us back on
        // track
        //
        if (currentRead.QuadPart < minTime.QuadPart) {

            //
            // Time jumped backward a small fraction, just add a few ticks
            //
            if ((minTime.QuadPart - currentRead.QuadPart) < 0x40) {
                SkewedTime.QuadPart = minTime.QuadPart + A_FEW_TICKS;
            
            //
            // Time jumped backward quite a bit, add half a system clock
            // interrupt worth of ticks since we know this routine
            // gets called every clock interrupt
            //
            } else {
                SkewedTime.QuadPart = minTime.QuadPart +
                    (HalpPiix4UpperBoundTable[HalpCurrentMSRateTableIndex] /
                     8);
            }

#ifdef TIMER_DBG
            PositiveGlitches++;
            if (PacketLog) {
                TimerLog[Index].PositiveSkew = TRUE;
                TimerLog[Index].Skew.QuadPart =
                    SkewedTime.QuadPart - currentRead.QuadPart;
            }
#endif // TIMER_DBG

            PositiveSkew = TRUE;
            ClockSkew.QuadPart = SkewedTime.QuadPart - currentRead.QuadPart;

        //
        // currentRead > upperBound
        //
        } else {

            //
            // Time jumped forward more than a system clock, interrupts
            // may have been disabled by some unruly driver, or maybe
            // we were hung up in the debugger, at any rate, let's add
            // a full system clock interrupt worth of ticks
            //
            SkewedTime.QuadPart = minTime.QuadPart +
                (HalpPiix4UpperBoundTable[HalpCurrentMSRateTableIndex] /
                 4);

#ifdef TIMER_DBG
            NegativeGlitches++;

            if (PacketLog) {
                TimerLog[Index].PositiveSkew = FALSE;
                TimerLog[Index].Skew.QuadPart =
                    currentRead.QuadPart - SkewedTime.QuadPart;
            }
#endif // TIMER_DBG

            PositiveSkew = FALSE;
            ClockSkew.QuadPart = currentRead.QuadPart - SkewedTime.QuadPart;
        }

        currentRead = SkewedTime;
        break;
    }

#ifdef TIMER_DBG
    if (PacketLog) {
        TimerLog[Index].CurrentRead1 = currentRead;
    }
#endif

    //
    // If we detected a rollover, and there is negative skew, then we
    // should recalculate the skew as positive skew to avoid making
    // an erroneous correction on the next read
    //
    if ((ClockSkew.QuadPart > 0) && (RollOver.QuadPart > 0) &&
        (PositiveSkew == FALSE) && (ClockSkew.QuadPart > hardwareVal)) {

        if (currentRead.QuadPart >= currentRead0.QuadPart) {
            ClockSkew.QuadPart = currentRead.QuadPart - currentRead0.QuadPart;
            PositiveSkew = TRUE;

        //
        // I've studied this case a few times, and it appears we
        // have detected a rollover and a glitch together, and
        // the skew is incorrectly the difference between the bogus
        // rollover time, the one we don't respect, rather than
        // currentRead0, so we need to patch it to keep skew from
        // growing larger than clock bits
        //
        } else /* currentRead.QuadPart < currentRead0.QuadPart */ {
            
            ASSERT((ClockSkew.QuadPart > bitsInHardware) &&
                   (currentRead0.QuadPart =
                    (currentRead.QuadPart +
                     (ClockSkew.QuadPart & bitsInHardware))));

            if ((ClockSkew.QuadPart > bitsInHardware) &&
                   (currentRead0.QuadPart =
                    (currentRead.QuadPart +
                     (ClockSkew.QuadPart & bitsInHardware)))) {

                ClockSkew.QuadPart &= bitsInHardware;
            }
#if TIMER_DBG
            else {
                if ((PacketLog) && (PacketLogCount > 3)) {
                    PacketLogCount = 3;
                }
            }
#endif
        }
    }

    //
    // Similarly, if there is no rollover, but positive skew is causing
    // the timer to rollover, then we need to readjust the skew also to
    // avoid the possibility of making an erroneous correction on the next
    // read
    //
    if ((ClockSkew.QuadPart > 0) && (RollOver.QuadPart == 0) &&
        (PositiveSkew == TRUE) && ((currentRead.QuadPart & ~(ULONG_PTR)bitsInHardware) >
                                   (minTime.QuadPart & ~(ULONG_PTR)bitsInHardware))) {

        //
        // I'm not sure what this means, or how it can happen, but I will
        // endeavor to decipher the condition if and when it occurs
        //
        ASSERT((currentRead0.QuadPart + bitsInHardware + 1) >
               currentRead.QuadPart);

        if (currentRead0.QuadPart + bitsInHardware + 1 >
            currentRead.QuadPart) {
            ClockSkew.QuadPart = currentRead0.QuadPart + bitsInHardware + 1 -
                currentRead.QuadPart;
            PositiveSkew = FALSE;
        }
#if TIMER_DBG
        else {
            if ((PacketLog) && (PacketLogCount > 3)) {
                PacketLogCount = 3;
            }
        }
#endif
    }

    //
    // Compute new upper bound.
    //
    upperBound.QuadPart = currentRead.QuadPart +
        HalpPiix4UpperBoundTable[HalpCurrentMSRateTableIndex];

    //
    // Update upper and lower bounds.
    //

    TimerInfo.TimeHigh1 = currentRead.HighPart;
    TimerInfo.TimeLow = currentRead.LowPart;
    TimerInfo.TimeHigh2 = currentRead.HighPart;

    TimerInfo.UpperBoundHigh1 = upperBound.HighPart;
    TimerInfo.UpperBoundLow   = upperBound.LowPart;
    TimerInfo.UpperBoundHigh2 = upperBound.HighPart;

#if DBG
    LastClockSkew = ClockSkew;
#endif

#if 0
    KeReleaseSpinLock(&HalpBrokenTimerLock, Irql);
#endif

    HalpRestoreInterrupts(flags);

#if DBG_TIMER_PERF
    timerPerfRecord->ReturnedLow = currentRead.LowPart;
    timerPerfRecord->ReturnedHigh = currentRead.HighPart;
    timerPerfRecord->UBL = upperBound.LowPart;
    timerPerfRecord->UBH = upperBound.HighPart;
    TimerPerfIndex = (TimerPerfIndex + 1) % (4096 / sizeof(TIMER_PERF_INDEX));
#endif

    return currentRead;
}

VOID
HalpBrokenPiix4TimerTick(
    VOID
    )
{
    ULARGE_INTEGER currentCount;
    ULARGE_INTEGER upperBound;

#if DBG
    PTIMER_PERF_INDEX timerPerfRecord;
#endif

#ifdef TIMER_DBG
    TimerTick = TRUE;
#endif

    currentCount =
        HalpQueryBrokenPiix4();

#ifdef TIMER_DBG
    TimerTick = FALSE;
#endif

#if DBG_TIMER_PERF
    timerPerfRecord = &(TimerPerf[TimerPerfIndex]);
    timerPerfRecord->TickMin = currentCount.LowPart;
    timerPerfRecord->TickNewUB = TimerInfo.UpperBoundLow;
    timerPerfRecord->TickCount++;
#endif
}

#endif // NO_PM_KEQPC

VOID
HalaAcpiTimerInit(
   IN ULONG    TimerPort,
   IN BOOLEAN  TimerValExt
   )
{
#if 0
    KeInitializeSpinLock(&HalpBrokenTimerLock);
#endif

    TimerInfo.CurrentTimePort = TimerPort;

    if (TimerValExt) {
        TimerInfo.MsbMask = 0x80000000;
    }

#ifndef NO_PM_KEQPC
    if (HalpBrokenAcpiTimer) {
        QueryTimer = HalpQueryBrokenPiix4;

#if DBG
        {
            KIRQL oldIrql;

            KeRaiseIrql(HIGH_LEVEL, &oldIrql);
            LastKQPCValue[0] = 0;
            LastKQPCValue[1] = 0;
            LastKQPCValue[2] = 0;
            KeLowerIrql(oldIrql);
        }
#endif
    }
#endif // NO_PM_KEQPC
}


#define PIT_FREQUENCY 1193182
#define PM_TMR_FREQ   3579545

#define EIGHTH_SECOND_PM_TICKS 447443

ULONG PMTimerFreq = PM_TMR_FREQ;

#ifdef SPEEDY_BOOT

static ULONG HalpFoundPrime = 0; 

VOID
HalpPrimeSearch(
    IN ULONG Primer,
    IN ULONG BitMask
    )
/*++

Routine Description:

    The objective of this routine is to waste as many CPU cycles as possible
    by searching for prime numbers.  To be fairly consistent in the amount
    of time it wastes, it is severly less than optimal-- we force Primer
    to be odd by or-ing in 15, then we and it with the BitMask, and or
    in BitMask+1, and finally we continue testing after we discover the
    Primer's not prime, until out test factor squared is greater than, or
    equal to the Primer.

Arguments:

    Primer - The number to search (seed)

    BitMask - How many bits of primer to use in search, controls amount
              of time wasted

Return Value:

    None

--*/
{
    ULONG Index;
    BOOLEAN FoundPrime;

    Primer |= 0xF;
    BitMask |= 0xF;
    Primer &= BitMask;
    Primer |= (BitMask + 1);

    FoundPrime = TRUE;
    for (Index = 3; (Index * Index) < Primer; Index += 2) {
        if ((Primer % Index) == 0) {
            FoundPrime = FALSE;
            // Do not break-- we're trying to waste time, remember?
        }
    }
    
    //
    // Stuff prime(s) in global so sneaky optimizing compiler
    // doesn't optimize out this B.S.
    //
    if (FoundPrime) {
        HalpFoundPrime = Primer;
    }
}



BOOLEAN
HalpPmTimerSpecialStall(
    IN ULONG Ticks
    )
/*++

Routine Description:

Arguments:

    Ticks - Number of PM timer ticks to stall

Return Value:

    TRUE if we were able to stall for the correct interval,
    otherwise FALSE

--*/
{
    BOOLEAN TimerWrap;
    LARGE_INTEGER TimerWrapBias;
    LARGE_INTEGER LastRead;
    LARGE_INTEGER InitialTicks;
    LARGE_INTEGER TargetTicks;
    LARGE_INTEGER CurrentTicks;
    ULONG ZeroElapsedTickReads;
    
    InitialTicks = HalpPmTimerQueryPerfCount(NULL);

    //
    // Let's test the rollover action...
    //
#if 0
    while (InitialTicks.QuadPart < 0xFFF000) {
        
        _asm { xor eax, eax
               cpuid }

        InitialTicks = HalpPmTimerQueryPerfCount(NULL); 
    }
#endif

    CurrentTicks = InitialTicks;
    LastRead.QuadPart = InitialTicks.QuadPart;
    ZeroElapsedTickReads = 0;
    TimerWrapBias.QuadPart = 0;
    TimerWrap = FALSE;

    TargetTicks.QuadPart = InitialTicks.QuadPart + Ticks;

    while (CurrentTicks.QuadPart < TargetTicks.QuadPart) {

        //
        // Now let's really chew up some cycles and see if we can find
        // some prime numbers while we're at it
        //
        HalpPrimeSearch(CurrentTicks.LowPart, 0x7FFF);

        CurrentTicks = HalpPmTimerQueryPerfCount(NULL);
        CurrentTicks.QuadPart += TimerWrapBias.QuadPart;

        //
        // Did the timer wrap, or is it broken?
        //
        if (CurrentTicks.QuadPart < LastRead.QuadPart) {

            //
            // The timer can wrap once, otherwise something's amiss 
            //
            if (!TimerWrap) {

                TimerWrapBias.QuadPart = (UINT64)(TimerInfo.MsbMask) << 1;
                CurrentTicks.QuadPart += TimerWrapBias.QuadPart;
                TimerWrap = TRUE;

                //
                // Something is whack, considering our elaborate stall
                // algorithm, this difference is still too significant,
                // maybe it's time to upgrade that 200MHz CPU if you
                // want fast boot!
                //
                if ((CurrentTicks.QuadPart - LastRead.QuadPart) > 0x1000) {
                    return FALSE;
                }

            //
            // We already had one decreasing read, looser!
            //
            } else {
                return FALSE;
            }
        }

        //
        // Is the timer really ticking?  In practice it is virtually
        // impossible to read the timer so quickly that you get the same
        // answer twice, but in theory it should be possible, so to avoid
        // the possibility of getting stuck in this loop for all eternity
        // we will permit this condition to occur one thousand times
        // before we give up
        //
        if (CurrentTicks.QuadPart == LastRead.QuadPart) ZeroElapsedTickReads++;
        if (ZeroElapsedTickReads > 1000) {
            return FALSE;
        }

        LastRead = CurrentTicks;
    }

    return TRUE;
}

static BOOLEAN SpecialStallSuccess = TRUE;

#define TSC 0x10

#if defined (_WIN64)

LONGLONG
ReadCycleCounter (
    VOID
    )
{
    return ReadTimeStampCounter();
}

#else

LONGLONG ReadCycleCounter(VOID) { _asm { rdtsc } }

#endif

#define TIMER_ROUNDING 10000
#define __1MHz 1000000


BOOLEAN
HalpPmTimerScaleTimers(
    VOID
    )
/*++

Routine Description:

    Determines the frequency of the APIC timer, this routine is run
    during initialization

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG Flags;
    ULONG ReadBack;
    PHALPCR HalPCR;
    PKPCR pPCR;
    ULONG ApicHz;
    ULONGLONG TscHz;
    ULONG RoundApicHz;
    ULONGLONG RoundTscHz;
    ULONGLONG RoundTscMhz;

    //
    // If we ever failed before, don't bother wasting any more time
    //
    if (!SpecialStallSuccess) {
        return FALSE;
    }

    //
    // Don't interrupt us!
    //

    Flags = HalpDisableInterrupts();

    pPCR = KeGetPcr();
    HalPCR = (PHALPCR)(KeGetPcr()->HalReserved);

    //
    // Configure APIC timer
    //
    pLocalApic[LU_TIMER_VECTOR / 4] = INTERRUPT_MASKED |
        PERIODIC_TIMER | APIC_PROFILE_VECTOR;
    pLocalApic[LU_DIVIDER_CONFIG / 4] = LU_DIVIDE_BY_1;
    
    //
    // Make sure the write has happened ???
    //
    ReadBack = pLocalApic[LU_DIVIDER_CONFIG / 4];

    //
    // Zero the perf counter
    //
    HalPCR->PerfCounterLow = 0;
    HalPCR->PerfCounterHigh = 0;

    //
    // Fence ???
    //

    PROCESSOR_FENCE;

    //
    // Reset APIC counter and TSC
    //
    pLocalApic[LU_INITIAL_COUNT / 4] = (ULONG)-1;
    WRMSR(TSC, 0);

    //
    // Stall for an eigth second
    //
    SpecialStallSuccess = HalpPmTimerSpecialStall(EIGHTH_SECOND_PM_TICKS);

    if (SpecialStallSuccess) {
 
        //
        // Read/compute APIC clock and TSC Frequencies (ticks * 8)
        //
        TscHz = ReadCycleCounter() * 8;
        ApicHz = ((ULONG)-1 - pLocalApic[LU_CURRENT_COUNT / 4]) * 8;

        //
        // Round APIC frequency
        //
        RoundApicHz = ((ApicHz + (TIMER_ROUNDING / 2)) / TIMER_ROUNDING) *
            TIMER_ROUNDING;

        HalPCR->ApicClockFreqHz = RoundApicHz;

        //
        // Round TSC frequency
        //
        RoundTscHz = ((TscHz + (TIMER_ROUNDING / 2)) / TIMER_ROUNDING) *
            TIMER_ROUNDING;
        HalPCR->TSCHz = RoundTscHz;

        //
        // Convert TSC frequency to MHz
        //
        RoundTscMhz = (RoundTscHz + (__1MHz / 2)) / __1MHz;
        pPCR->StallScaleFactor = (ULONG)RoundTscMhz;

        HalPCR->ProfileCountDown = RoundApicHz;
        pLocalApic[LU_INITIAL_COUNT / 4] = RoundApicHz; 
    }

    //
    // Restore interrupt state
    //

    HalpRestoreInterrupts(Flags);

    return SpecialStallSuccess;
}
#endif

#if defined(_WIN64)

LARGE_INTEGER
HalpPmTimerQueryPerfCount (
    OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
    )

/*++

Routine Description:

    This routine returns current 64-bit performance counter and,
    optionally, the Performance Frequency.

    N.B. The performace counter returned by this routine is
    not necessary the value when this routine is just entered.
    The value returned is actually the counter value at any point
    between the routine is entered and is exited.

Arguments:

    PerformanceFrequency - optionally, supplies the address
        of a variable to receive the performance counter frequency.

Return Value:

    Current value of the performance counter will be returned.

--*/

{
    LARGE_INTEGER time;
    LARGE_INTEGER bias;

    time = ((PQUERY_TIMER)QueryTimer)();

    bias.HighPart = TimerInfo.BiasHigh;
    bias.LowPart = TimerInfo.BiasLow;
    time.QuadPart += bias.QuadPart;

    if (ARGUMENT_PRESENT(PerformanceFrequency)) {

        PerformanceFrequency->LowPart = PMTimerFreq;
        PerformanceFrequency->HighPart = 0;
    }

    return time;
}

#endif // SPEEDY_BOOT

#if !defined(_WIN64)

#ifndef NO_PM_KEQPC

static ULONG PIT_Ticks = 0xBADCEEDE;

VOID
HalpAcpiTimerPerfCountHack(
    VOID
    )
/*++

Routine Description:

    Some cheezy PIC-based laptops seemed to have wired their ACPI timer to
    the wrong frequecy crystal, and their perf counter freq is twice what
    it should be.  These systems seem to run fine in every other way
    except for midi file playback, or anything else that goes by KeQuery-
    PerformanceCounter's return frequency value, so we perform a simple
    check late during init to see if this clock is twice what we expect,
    and if it is we return twice the ACPI frequency in KeQuery...

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG T0_Count = 0;
    ULONG T1_Count = 1;
    ULONG Retry = 10;

    //
    // If we happen to hit the rollover just do it again
    //
    while ((T0_Count < T1_Count) && (Retry--)) {
        T0_Count = HalpQuery8254Counter();
        KeStallExecutionProcessor(1000);
        T1_Count = HalpQuery8254Counter();
    }

    if (T0_Count < T1_Count) {
        return;
    }

    //
    // We should have read ~1200 ticks during this interval, so if we
    // recorded between 575 and 725 we can reasonably assume the ACPI 
    // Timer is running at 2 * spec
    //
    PIT_Ticks = T0_Count - T1_Count;
    if ((PIT_Ticks < 725) && (PIT_Ticks > 575)) {
        PMTimerFreq = 2 * PM_TMR_FREQ;
        HalpAdjustUpperBoundTable2X();
    }
}

#endif  // NO_PM_KEQPC
#endif  // _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\pmsleep.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmsleep.c

Abstract:

    This file provides the code that changes the system from
    the ACPI S0 (running) state to any one of the sleep states.

Author:

    Jake Oshins (jakeo) Feb. 11, 1997

Revision History:

--*/
#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"
#include "kddll.h"
#include "ixsleep.h"

//
// Internal functions
//

NTSTATUS
HalpAcpiSleep(
    IN PVOID                    Context,
    IN LONG                     NumberProcessors,
    IN volatile PLONG           Number
    );

VOID
HalpSetClockBeforeSleep(
    VOID
    );

VOID
HalpSetClockAfterSleep(
    VOID
    );

BOOLEAN
HalpWakeupTimeElapsed(
    VOID
    );

VOID
HalpFreeTiledCR3 (
    VOID
    );

VOID
HalpReenableAcpi(
    VOID
    );

VOID
HalpPiix4Detect(
    BOOLEAN DuringBoot
    );

typedef struct _ERESOURCE {
    LIST_ENTRY SystemResourcesList;
    PVOID OwnerTable;
    SHORT ActiveCount;
    USHORT Flag;
    PKSEMAPHORE SharedWaiters;
    PKEVENT ExclusiveWaiters;
    LIST_ENTRY OwnerThreads[2];
    ULONG ContentionCount;
    USHORT NumberOfSharedWaiters;
    USHORT NumberOfExclusiveWaiters;
    union {
        PVOID Address;
        ULONG CreatorBackTraceIndex;
    };

    KSPIN_LOCK SpinLock;
} ERESOURCE, *PERESOURCE;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK, HalpAcpiPreSleep)
#pragma alloc_text(PAGELK, HalpAcpiPostSleep)
#pragma alloc_text(PAGELK, HalpWakeupTimeElapsed)
#pragma alloc_text(PAGELK, HalpReenableAcpi)
#pragma alloc_text(PAGELK, HaliSetWakeEnable)
#pragma alloc_text(PAGELK, HaliSetWakeAlarm)
#pragma alloc_text(PAGELK, HalpMapNvsArea)
#pragma alloc_text(PAGELK, HalpFreeNvsBuffers)
#endif

HAL_WAKEUP_STATE HalpWakeupState;

#if DBG
BOOLEAN          HalpFailSleep = FALSE;
#endif

#define PM1_TMR_EN 0x0001
#define PM1_RTC_EN 0x0400

//
// For re-enabling the debugger's com port.
//
extern PUCHAR KdComPortInUse;

extern PACPI_BIOS_MULTI_NODE HalpAcpiMultiNode;
extern PUCHAR HalpAcpiNvsData;
extern PVOID  *HalpNvsVirtualAddress;


BOOLEAN
HalpAcpiPreSleep(
    SLEEP_STATE_CONTEXT Context
    )
/*++

Routine Description:

Arguments:

    none

Return Value:

    status

--*/
{
    USHORT pmTimer;
    PUSHORT pm1a;
    PUSHORT pm1b;
    PUSHORT pm1astatus;
    PUSHORT pm1bstatus;

    pm1astatus = (PUSHORT)(ULONG_PTR) HalpFixedAcpiDescTable.pm1a_evt_blk_io_port;
    pm1bstatus = (PUSHORT)(ULONG_PTR) HalpFixedAcpiDescTable.pm1b_evt_blk_io_port;
    pm1a = (PUSHORT)(ULONG_PTR) (HalpFixedAcpiDescTable.pm1a_evt_blk_io_port +
                     (HalpFixedAcpiDescTable.pm1_evt_len / 2));

    pm1b = (PUSHORT)(ULONG_PTR) (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port +
                     (HalpFixedAcpiDescTable.pm1_evt_len / 2));

    HalpSleepContext.AsULONG = Context.AsULONG;

#if DBG
    if (HalpFailSleep) {
        return FALSE;
    }
#endif

    HalpSetClockBeforeSleep();

    //
    // Save the (A)PIC for any sleep state, as we need to play
    // with it on the way back up again.
    //
    HalpSaveInterruptControllerState();
    if (Context.bits.Flags & SLEEP_STATE_SAVE_MOTHERBOARD) {

        HalpSaveDmaControllerState();
        HalpSaveTimerState();

    }

    //
    // We need to make sure that the PM Timer is disabled from this
    // point onward. We also need to make that the RTC Enable is only
    // enabled if the RTC should wake up the computer
    //
    pmTimer = READ_PORT_USHORT(pm1a);
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port) {

        pmTimer |= READ_PORT_USHORT(pm1b);

    }

    //
    // Clear the timer enable bit.
    //
    pmTimer &= ~PM1_TMR_EN;

    //
    // Check to see if we the machine supports RTC Wake in Fixed Feature
    // space. Some machines implement RTC support via control methods
    //
    if ( !(HalpFixedAcpiDescTable.flags & RTC_WAKE_GENERIC) ) {

        //
        // Check to see if we need to disable/enable the RTC alarm
        //
        if (!HalpWakeupState.RtcWakeupEnable) {

            pmTimer &= ~PM1_RTC_EN;

        } else {

            pmTimer |= PM1_RTC_EN;
        }
    }

    //
    // Write it back into the hardware.
    //
    WRITE_PORT_USHORT(pm1a, pmTimer);
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port) {

        WRITE_PORT_USHORT(pm1b, pmTimer);
    }

    //
    // At this point, we should be running with interrupts disabled and
    // the TMR_EN bit cleared. This is a good place to clear the PM1 Status
    // Register
    //
    pmTimer = READ_PORT_USHORT( pm1astatus );
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port) {

        pmTimer |= READ_PORT_USHORT( pm1bstatus );
    }

    WRITE_PORT_USHORT( pm1astatus, pmTimer );
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port) {

        WRITE_PORT_USHORT( pm1bstatus, pmTimer );
    }

    //
    // Check to see if we need to disable all wakeup events.
    //

    if (!HalpWakeupState.GeneralWakeupEnable) {

        AcpiEnableDisableGPEvents(FALSE);

    } else {

        //
        // Only call this before going to sleep --- waking up should
        // reset the GPEs to the 'proper' value
        //
        AcpiGpeEnableWakeEvents();
    }

    HalpPreserveNvsArea();

    //
    // If we should have woken up already, don't sleep.
    //
    return !HalpWakeupTimeElapsed();
}

BOOLEAN
HalpAcpiPostSleep(
    ULONG Context
    )
{
    USHORT pmTimer;
    PUSHORT pm1a;
    PUSHORT pm1b;
    BOOLEAN ProfileInterruptEnabled;

#ifdef PICACPI
    extern ULONG HalpProfilingStopped;

    ProfileInterruptEnabled = (HalpProfilingStopped == 0);
#else
    extern ULONG HalpProfileRunning;

    ProfileInterruptEnabled = (HalpProfileRunning == 1);
#endif

    pm1a = (PUSHORT)(ULONG_PTR)(HalpFixedAcpiDescTable.pm1a_evt_blk_io_port +
                     (HalpFixedAcpiDescTable.pm1_evt_len / 2));

    pm1b = (PUSHORT)(ULONG_PTR)(HalpFixedAcpiDescTable.pm1b_evt_blk_io_port +
                     (HalpFixedAcpiDescTable.pm1_evt_len / 2));


    //
    // Read the currently set PM1 Enable bits
    //
    pmTimer = READ_PORT_USHORT(pm1a);
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port) {

        pmTimer |= READ_PORT_USHORT(pm1b);

    }

    //
    // Set the timer enable bit. Clear the RTC enable bit
    //
    pmTimer |= PM1_TMR_EN;
    pmTimer &= ~PM1_RTC_EN;

    //
    // Write back the new PM1 Enable bits
    //
    WRITE_PORT_USHORT(pm1a, pmTimer);
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port) {

        WRITE_PORT_USHORT(pm1b, pmTimer);

    }

    //
    // Unset the RTC alarm and re-enable periodic interrupts.
    //
    HalpSetClockAfterSleep();

    HalpWakeupState.RtcWakeupEnable = FALSE;

    *((PULONG)HalpWakeVector) = 0;

    HalpSetInterruptControllerWakeupState(Context);

    if (HalpSleepContext.bits.Flags & SLEEP_STATE_SAVE_MOTHERBOARD) {

        //
        // If Kd was in use, then invalidate it.  It will re-sync itself.
        //
        if (KdComPortInUse) {
            KdRestore(TRUE);
        }

        HalpRestoreDmaControllerState();

        HalpRestoreTimerState();

    }

    HalpPiix4Detect(FALSE);

    //
    // Enable all GPEs, not just the wake ones
    //

    AcpiEnableDisableGPEvents(TRUE);

    HalpRestoreNvsArea();

    HalpResetSBF();

    //
    // If we were profiling before, fire up the profile interrupt
    //
    if (ProfileInterruptEnabled) {
        HalStartProfileInterrupt(0);
    }

    return TRUE;
}


BOOLEAN
HalpWakeupTimeElapsed(
    VOID
    )
{
    LARGE_INTEGER wakeupTime, currentTime;
    TIME_FIELDS currentTimeFields;

    //
    // Check to see if a wakeup timer has already expired.
    //
    if (HalpWakeupState.RtcWakeupEnable) {

        HalQueryRealTimeClock(&currentTimeFields);

        RtlTimeFieldsToTime(&currentTimeFields, &currentTime);

        RtlTimeFieldsToTime(&HalpWakeupState.RtcWakeupTime, &wakeupTime);

        //
        // We advance currentTime by 1 second to make sure the timer doesn't
        // expire before we go to sleep.
        //
        currentTime.QuadPart += 10000000;   // Add 1 second

        return ((ULONGLONG)wakeupTime.QuadPart <= (ULONGLONG)currentTime.QuadPart);
    }

    return FALSE;
}

NTSTATUS
HaliSetWakeAlarm (
        IN ULONGLONG    WakeSystemTime,
        IN PTIME_FIELDS WakeTimeFields OPTIONAL
        )
/*++

Routine Description:

    This routine sets the real-time clock's alarm to go
    off at a specified time in the future and programs
    the ACPI chipset so that this wakes the computer.

Arguments:

    WakeSystemTime - amount of time that passes before we wake
    WakeTimeFields - time to wake broken down into TIME_FIELDS

Return Value:

    status

--*/
{
    if (WakeSystemTime == 0) {

        HalpWakeupState.RtcWakeupEnable = FALSE;
        return STATUS_SUCCESS;

    }

    ASSERT( WakeTimeFields );
    HalpWakeupState.RtcWakeupEnable = TRUE;
    HalpWakeupState.RtcWakeupTime = *WakeTimeFields;
    return HalpSetWakeAlarm(WakeSystemTime, WakeTimeFields);
}

VOID
HaliSetWakeEnable(
        IN BOOLEAN      Enable
        )
/*++

Routine Description:

    This routine is called to set the policy for waking up.
    As we go to sleep, the global HalpWakeupState will be
    read and the hardware set accordingly.

Arguments:

    Enable - true or false

Return Value:

--*/
{
    //
    // Always clear the RTC wake --- we expect that someone will
    // set the alarm after they call this function
    //
    HalpWakeupState.RtcWakeupEnable     = FALSE;

    //
    // Toggle the generate wake up bit
    //
    HalpWakeupState.GeneralWakeupEnable = Enable;
}

VOID
HalpReenableAcpi(
    VOID
    )
/*++

Routine Description:

    This calls into the ACPI driver to switch back into ACPI mode,
    presumably after S4 and sets the ACPI registers that the HAL
    controls.

Arguments:

Return Value:

--*/
{
    // TEMPTEMP?
    HalpInitializeClock();

    AcpiInitEnableAcpi(TRUE);
    AcpiEnableDisableGPEvents(TRUE);
}

VOID
HalpMapNvsArea(
    VOID
    )
{
    NTSTATUS status;
    ULONG i, bufferSize, bufferOffset, nodeCount;

    PAGED_CODE();

    status = HalpAcpiFindRsdt(&HalpAcpiMultiNode);

    if (!NT_SUCCESS(status)) {
        return;
    }

    if (HalpAcpiMultiNode->Count == 0) {

        //
        // There's no work to do here.
        //

        goto HalpMapNvsError;
    }

    //
    // Find total size of the buffer we need.
    //

    bufferSize = 0;
    nodeCount = 0;

    for (i = 0; i < HalpAcpiMultiNode->Count; i++) {

        if (HalpAcpiMultiNode->E820Entry[i].Type == AcpiAddressRangeNVS) {

            ASSERT(HalpAcpiMultiNode->E820Entry[i].Length.HighPart == 0);

            bufferSize += HalpAcpiMultiNode->E820Entry[i].Length.LowPart;
            nodeCount++;
        }
    }

    if (bufferSize == 0) {

        //
        // There's no work to do here.
        //

        goto HalpMapNvsError;
    }

#if DBG
    if (bufferSize > (20 * PAGE_SIZE)) {
        DbgPrint("HALACPI:  The BIOS wants the OS to preserve %x bytes\n", bufferSize);
    }
#endif

    HalpAcpiNvsData = ExAllocatePoolWithTag(NonPagedPool,
                                            bufferSize,
                                            'AlaH');

    if (!HalpAcpiNvsData) {

        DbgPrint("HALACPI:  The BIOS's non-volatile data will not be preserved\n");
        goto HalpMapNvsError;
    }

    HalpNvsVirtualAddress = ExAllocatePoolWithTag(NonPagedPool,
                                                  (nodeCount + 1) * sizeof(PVOID),
                                                  'AlaH');

    if (!HalpNvsVirtualAddress) {
        goto HalpMapNvsError;
    }


    //
    // Make a mapping for each run.
    //

    bufferOffset = 0;
    nodeCount = 0;

    for (i = 0; i < HalpAcpiMultiNode->Count; i++) {

        if (HalpAcpiMultiNode->E820Entry[i].Type == AcpiAddressRangeNVS) {

            HalpNvsVirtualAddress[nodeCount] =
                MmMapIoSpace(HalpAcpiMultiNode->E820Entry[i].Base,
                             HalpAcpiMultiNode->E820Entry[i].Length.LowPart,
                             MmNonCached);

            ASSERT(HalpNvsVirtualAddress[nodeCount]);

            nodeCount++;
        }
    }

    //
    // Mark the end.
    //

    HalpNvsVirtualAddress[nodeCount] = NULL;

    return;

HalpMapNvsError:

    if (HalpAcpiMultiNode)          ExFreePool(HalpAcpiMultiNode);
    if (HalpNvsVirtualAddress)      ExFreePool(HalpNvsVirtualAddress);
    if (HalpAcpiNvsData)            ExFreePool(HalpAcpiNvsData);

    HalpAcpiMultiNode = NULL;

    return;
}

VOID
HalpPreserveNvsArea(
    VOID
    )
{
    ULONG i, dataOffset = 0, nodeCount = 0;

    if (!HalpAcpiMultiNode) {

        //
        // Either there was nothing to save or there
        // was a fatal error.
        //

        return;
    }

    for (i = 0; i < HalpAcpiMultiNode->Count; i++) {

        if (HalpAcpiMultiNode->E820Entry[i].Type == AcpiAddressRangeNVS) {

            //
            // Copy from BIOS memory to temporary buffer.
            //

            RtlCopyMemory(HalpAcpiNvsData + dataOffset,
                          HalpNvsVirtualAddress[nodeCount],
                          HalpAcpiMultiNode->E820Entry[i].Length.LowPart);

            nodeCount++;
            dataOffset += HalpAcpiMultiNode->E820Entry[i].Length.LowPart;
        }
    }
}

VOID
HalpRestoreNvsArea(
    VOID
    )
{
    ULONG i, dataOffset = 0, nodeCount = 0;

    if (!HalpAcpiMultiNode) {

        //
        // Either there was nothing to save or there
        // was a fatal error.
        //

        return;
    }

    for (i = 0; i < HalpAcpiMultiNode->Count; i++) {

        if (HalpAcpiMultiNode->E820Entry[i].Type == AcpiAddressRangeNVS) {

            //
            // Copy from temporary buffer to BIOS area.
            //

            RtlCopyMemory(HalpNvsVirtualAddress[nodeCount],
                          HalpAcpiNvsData + dataOffset,
                          HalpAcpiMultiNode->E820Entry[i].Length.LowPart);

            nodeCount++;
            dataOffset += HalpAcpiMultiNode->E820Entry[i].Length.LowPart;

        }
    }
}

VOID
HalpFreeNvsBuffers(
    VOID
    )
{
    ULONG i, nodeCount = 0;

    PAGED_CODE();

    if (!HalpAcpiMultiNode) {

        //
        // Either there was nothing to save or there
        // was a fatal error.
        //

        return;
    }

    for (i = 0; i < HalpAcpiMultiNode->Count; i++) {

        if (HalpAcpiMultiNode->E820Entry[i].Type == AcpiAddressRangeNVS) {

            //
            // Give back all the PTEs that we took earlier
            //

            MmUnmapIoSpace(HalpNvsVirtualAddress[nodeCount],
                           HalpAcpiMultiNode->E820Entry[i].Length.LowPart);

            nodeCount++;
        }
    }

    ASSERT(HalpAcpiMultiNode);
    ASSERT(HalpNvsVirtualAddress);
    ASSERT(HalpAcpiNvsData);

    ExFreePool(HalpAcpiMultiNode);
    ExFreePool(HalpNvsVirtualAddress);
    ExFreePool(HalpAcpiNvsData);

    HalpAcpiMultiNode = NULL;
    HalpNvsVirtualAddress = NULL;
    HalpAcpiNvsData = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\rangesup.c ===
//
// This file simply includes the common sources from the current HAL
// directory. When the structure is finally changed, the real file should
// be in this directory.
//

#include "..\rangesup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\sratnuma.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sratnuma.c

Abstract:

    This module contain functions which support static NUMA configurations
    as provided by the ACPI SRAT "Static Resource Affinity Table".

Author:

    Peter L Johnston (peterj) 2-Jul-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"

#if !defined(NT_UP)

#define ROUNDUP_TO_NEXT(base, size) \
        ((((ULONG_PTR)(base)) + (size)) & ~((size) - 1))

//
// The following routine is external but only used by NUMA support
// at the moment.
//

NTSTATUS
HalpGetApicIdByProcessorNumber(
    IN     UCHAR     Processor,
    IN OUT USHORT   *ApicId
    );

//
// Prototypes for alloc pragmas.
//

VOID
HalpNumaInitializeStaticConfiguration(
    IN PLOADER_PARAMETER_BLOCK
    );


#if defined(ALLOC_PRAGMA)
#pragma alloc_text(INIT,HalpNumaInitializeStaticConfiguration)
#endif

#define NEXT_ENTRY(base) (((PUCHAR)base) + (base)->Length)

#if defined(_WIN64)

#define HAL_MAX_PROCESSORS  64

#else

#define HAL_MAX_PROCESSORS  32

#endif

typedef struct _STATIC_NUMA_CONFIG {
    USHORT  ProcessorApicId[HAL_MAX_PROCESSORS];
    UCHAR   ProcessorProximity[HAL_MAX_PROCESSORS];
    UCHAR   ProximityId[MAXIMUM_CCNUMA_NODES];
    UCHAR   NodeCount;
    UCHAR   ProcessorCount;
} HALPSRAT_STATIC_NUMA_CONFIG, *PHALPSRAT_STATIC_NUMA_CONFIG;

PHALPSRAT_STATIC_NUMA_CONFIG    HalpNumaConfig;
PACPI_SRAT                      HalpAcpiSrat;
PULONG_PTR                      HalpNumaMemoryRanges;
PUCHAR                          HalpNumaMemoryNode;
ULONG                           HalpNumaLastRangeIndex;

ULONG
HalpNumaQueryPageToNode(
    IN ULONG_PTR PhysicalPageNumber
    )
/*++

Routine Description:

    Search the memory range descriptors to determine the node
    this page exists on.

Arguments:

    PhysicalPageNumber  Provides the page number.

Return Value:

    Returns the node number for the page.

--*/

{
    ULONG Index = HalpNumaLastRangeIndex;

    //
    // Starting in the same range as the last page returned,
    // look for this page.
    //

    if (PhysicalPageNumber >= HalpNumaMemoryRanges[Index]) {

        //
        // Search upwards.
        //

        while (PhysicalPageNumber >= HalpNumaMemoryRanges[Index+1]) {
            Index++;
        }

    } else {

        //
        // Search downwards.
        //

        do {
            Index--;
        } while (PhysicalPageNumber < HalpNumaMemoryRanges[Index]);
    }

    HalpNumaLastRangeIndex = Index;
    return HalpNumaMemoryNode[Index];
}

NTSTATUS
HalpNumaQueryProcessorNode(
    IN  ULONG   ProcessorNumber,
    OUT PUSHORT Identifier,
    OUT PUCHAR  Node
    )
{
    NTSTATUS Status;
    USHORT   ApicId;
    UCHAR    Proximity;
    UCHAR    i, j;

    //
    // Get the APIC Id for this processor.
    //

    Status = HalpGetApicIdByProcessorNumber((UCHAR)ProcessorNumber, &ApicId);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Return the APIC Id as the Identifier.   This should probably
    // be the ACPI Id but we don't have a way to get that yet.
    //

    *Identifier = ApicId;

    //
    // Find the node this processor belongs to.  The node is the
    // index into the array of Proximity Ids for the entry corresponding
    // to the Proximity Id of this processor.
    //

    for (i = 0; i < HalpNumaConfig->ProcessorCount; i++) {
        if (HalpNumaConfig->ProcessorApicId[i] == ApicId) {
            Proximity = HalpNumaConfig->ProcessorProximity[i];
            for (j = 0; j < HalpNumaConfig->NodeCount; j++) {
                if (HalpNumaConfig->ProximityId[j] == Proximity) {
                    *Node = j;
                    return STATUS_SUCCESS;
                }
            }
        }
    }

    //
    // Didn't find this processor in the known set of APIC IDs, this
    // would indicate a mismatch between the BIOS MP tables and the
    // SRAT, or, didn't find the proximity for this processor in the
    // table of proximity IDs.   This would be an internal error as
    // this array is build from the set of proximity IDs in the SRAT.
    //

    return STATUS_NOT_FOUND;
}

VOID
HalpNumaInitializeStaticConfiguration(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This routine reads the ACPI Static Resource Affinity Table to build
    a picture of the system's NUMA configuration.   This information is
    saved in the HalpNumaConfig structure in a form which is optimal for
    the OS's use.

Arguments:

    LoaderBlock supplies a pointer to the system loader parameter block.

Return Value:

    None.

--*/

{
    ULONG MemoryDescriptorCount;
    UCHAR ProcessorCount;
    PACPI_SRAT_ENTRY SratEntry;
    PACPI_SRAT_ENTRY SratEnd;
    ULONG i, j;
    BOOLEAN Swapped;
    PHYSICAL_ADDRESS Base;
    ULONG_PTR p;
    ULONG_PTR Phys;

    HalpAcpiSrat = HalpGetAcpiTablePhase0(LoaderBlock, ACPI_SRAT_SIGNATURE);
    if (HalpAcpiSrat == NULL) {
        return;
    }

    //
    // The Static Resource Affinity Table (SRAT) exists.
    //
    // Scan it to determine the number of memory descriptors then
    // allocate memory to contain the tables needed to hold the
    // system's NUMA configuration.
    //

    MemoryDescriptorCount = 0;
    ProcessorCount = 0;
    SratEnd = (PACPI_SRAT_ENTRY)(((PUCHAR)HalpAcpiSrat) +
                                        HalpAcpiSrat->Header.Length);
    for (SratEntry = (PACPI_SRAT_ENTRY)(HalpAcpiSrat + 1);
         SratEntry < SratEnd;
         SratEntry = (PACPI_SRAT_ENTRY)NEXT_ENTRY(SratEntry)) {
        switch (SratEntry->Type) {
        case SratMemory:
            if (SratEntry->MemoryAffinity.Flags.Enabled == 1) {

                MemoryDescriptorCount++;
            }
            break;
        case SratProcessorLocalAPIC:

            if (SratEntry->ApicAffinity.Flags.Enabled == 1) {

                ProcessorCount++;
            }
            break;
        }
    }

    if ((MemoryDescriptorCount == 0) || (ProcessorCount == 0)) {
        //
        // Can't handle the case where there is either no memory or no
        // processors in the table.  Turn this into a non-numa
        // machine.
        //

        HalpAcpiSrat = NULL;
        return;
    }

    //
    // HalpNumaConfig format:
    //
    // HalpNumaConfig->
    //      USHORT      ProcessorApicId[HAL_MAX_PROCESSORS];
    //      UCHAR       ProcessorProximity[HAL_MAX_PROCESSORS];
    //      UCHAR       ProximityIds[MAXIMUM_CCNUMA_NODES];
    //      UCHAR       NodeCount;
    //      -pad- to 128 byte boundary
    // HalpNumaMemoryNode->
    //      UCHAR       MemoryRangeProximityId[NumberOfMemoryRanges];
    //      -pad to     ULONG_PTR alignment-
    // HalpNumaMemoryRanges->
    //      ULONG_PTR   MemoryRangeBasePage[NumberOfMemoryRanges];
    //
    // This format has been selected to maximize cache hits while
    // searching the ranges.  Specifically, the size of the ranges
    // array is kept to a minumum.
    //
    // NOTE: This code does not account for the length of the memory
    // ranges specified in the SRAT table.  Instead it treats each
    // memory range as extending to the next specified memory range.
    // The rationale is that the code shouldn't be asked about pages
    // not found in the SRAT table and if we are to return something
    // for these pages it might as well be the NUMA node associated
    // with the pages from the previous range.
    //

    //
    // Calculate number of pages required to hold the needed structures.
    //

    i = MemoryDescriptorCount * (sizeof(ULONG_PTR) + sizeof(UCHAR)) +
        sizeof(HALPSRAT_STATIC_NUMA_CONFIG) + 2 * sizeof(ULONG_PTR) +
        128 + sizeof(ULONG_PTR);
    i += PAGE_SIZE - 1;
    i >>= PAGE_SHIFT;

    Phys = (ULONG_PTR)HalpAllocPhysicalMemory(LoaderBlock,
                                              MAXIMUM_PHYSICAL_ADDRESS,
                                              i,
                                              FALSE);
    if (Phys == 0) {

        //
        // Allocation failed, the system will not be able to run
        // as a NUMA system,.... actually the system will probably
        // not run far at all.
        //

        DbgPrint("HAL NUMA Initialization failed, could not allocate %d pages\n",
                 i);

        HalpAcpiSrat = NULL;
        return;
    }
    Base.QuadPart = (ULONG_PTR)Phys;

#if !defined(_IA64_)

    HalpNumaConfig = HalpMapPhysicalMemory(Base, 1);

#else

    HalpNumaConfig = HalpMapPhysicalMemory(Base, 1, MmCached);

#endif

    if (HalpNumaConfig == NULL) {

        //
        // Couldn't map the allocation, give up.
        //

        HalpAcpiSrat = NULL;
        return;
    }
    RtlZeroMemory(HalpNumaConfig, i * PAGE_SIZE);

    //
    // MemoryRangeProximity is an array of UCHARs starting at the next
    // 128 byte boundary.
    //

    p = ROUNDUP_TO_NEXT((HalpNumaConfig + 1), 128);
    HalpNumaMemoryNode = (PUCHAR)p;

    //
    // NumaMemoryRanges is an array of ULONG_PTRs starting at the next
    // ULONG_PTR boundary.
    //

    p += (MemoryDescriptorCount + sizeof(ULONG_PTR)) & ~(sizeof(ULONG_PTR) - 1);
    HalpNumaMemoryRanges = (PULONG_PTR)p;

    //
    // Rescan the SRAT entries filling in the HalpNumaConfig structure.
    //

    ProcessorCount = 0;
    MemoryDescriptorCount = 0;

    for (SratEntry = (PACPI_SRAT_ENTRY)(HalpAcpiSrat + 1);
         SratEntry < SratEnd;
         SratEntry = (PACPI_SRAT_ENTRY)NEXT_ENTRY(SratEntry)) {

        //
        // Does this entry belong to a proximity domain not previously
        // seen?   If so, we have a new node.
        //

        for (i = 0; i < HalpNumaConfig->NodeCount; i++) {
            if (SratEntry->ProximityDomain == HalpNumaConfig->ProximityId[i]) {
                break;
            }
        }

        if (i == HalpNumaConfig->NodeCount) {

            //
            // This is an ID we haven't seen before.  New Node.
            //

            if (HalpNumaConfig->NodeCount >= MAXIMUM_CCNUMA_NODES) {

                //
                // We support a limited number of nodes, make this machine
                // not NUMA.  (Yes, we should free the config space
                // we allocated,... but this is an error when it happens
                // so I'm not worrying about it.  peterj).
                //

                HalpAcpiSrat = NULL;
                return;
            }
            HalpNumaConfig->ProximityId[i] = SratEntry->ProximityDomain;
            HalpNumaConfig->NodeCount++;
        }

        switch (SratEntry->Type) {
        case SratProcessorLocalAPIC:

            if (SratEntry->ApicAffinity.Flags.Enabled == 0) {

                //
                // This processor is not enabled, skip it.
                //

                continue;
            }
            if (ProcessorCount == HAL_MAX_PROCESSORS) {

                //
                // Can't handle any more processors.   Turn this
                // into a non-numa machine.
                //

                HalpAcpiSrat = NULL;
                return;
            }
            HalpNumaConfig->ProcessorApicId[ProcessorCount] =

#if defined(_IA64_)

                SratEntry->ApicAffinity.ApicId << 8  |
                (SratEntry->ApicAffinity.SApicEid);

#else

                SratEntry->ApicAffinity.ApicId;

#endif

            HalpNumaConfig->ProcessorProximity[ProcessorCount] =
                SratEntry->ProximityDomain;
            ProcessorCount++;
            break;
        case SratMemory:

            if (SratEntry->MemoryAffinity.Flags.Enabled == 0) {

                //
                // This memory is not enabled, skip it.
                //

                continue;
            }

            //
            // Save the proximity and the base page for this range.
            //

            HalpNumaMemoryNode[MemoryDescriptorCount] =
                SratEntry->ProximityDomain;
            Base = SratEntry->MemoryAffinity.Base;
            Base.QuadPart >>= PAGE_SHIFT;

#if !defined(_WIN64)
            ASSERT(Base.u.HighPart == 0);
#endif

            HalpNumaMemoryRanges[MemoryDescriptorCount] = (ULONG_PTR) Base.QuadPart;

            //
            // Explicitly ignore the entry's MemoryAffinity.Length as
            // the code treats anything up to the next greatest range
            // as associated with this entry.
            //

            MemoryDescriptorCount++;
            break;
        }
    }

    HalpNumaConfig->ProcessorCount = ProcessorCount;

    //
    // Make sure processor 0 is always in 'logical' node 0.  This
    // is achieved by making sure the proximity Id for the first
    // processor is always the first proximity Id in the table.
    //

    i = 0;
    if (!NT_SUCCESS(HalpGetApicIdByProcessorNumber(0, (PUSHORT)&i))) {

        //
        // Couldn't find the ApicId of processor 0?  Not quite
        // sure what to do, I suspect the MP table's APIC IDs
        // don't match the SRAT's.
        //

        DbgPrint("HAL No APIC ID for boot processor.\n");
    }

    for (j = 0; j < ProcessorCount; j++) {
        if (HalpNumaConfig->ProcessorApicId[j] == (USHORT)i) {
            UCHAR Proximity = HalpNumaConfig->ProcessorProximity[j];
            for (i = 0; i < HalpNumaConfig->NodeCount; i++) {
                if (HalpNumaConfig->ProximityId[i] == Proximity) {
                    HalpNumaConfig->ProximityId[i] =
                        HalpNumaConfig->ProximityId[0];
                    HalpNumaConfig->ProximityId[0] = Proximity;
                    break;
                }
            }
            break;
        }
    }

    //
    // Sort the memory ranges.   There shouldn't be very many
    // so a bubble sort should suffice.
    //

    j = MemoryDescriptorCount - 1;
    do {
        Swapped = FALSE;
        for (i = 0; i < j; i++) {
            
            ULONG_PTR t;
            UCHAR td;
            
            t = HalpNumaMemoryRanges[i];
            if (t > HalpNumaMemoryRanges[i+1]) {
                Swapped = TRUE;
                HalpNumaMemoryRanges[i] = HalpNumaMemoryRanges[i+1];
                HalpNumaMemoryRanges[i+1] = t;

                //
                // Keep the proximity domain in sync with the base.
                //

                td = HalpNumaMemoryNode[i];
                HalpNumaMemoryNode[i] = HalpNumaMemoryNode[i+1];
                HalpNumaMemoryNode[i+1] = td;
            }
        }

        //
        // The highest value is now at the top so cut it from the sort.
        //

        j--;
    } while (Swapped == TRUE);

    //
    // When searching the memory descriptors to find out which domain
    // a page is in, we don't care about gaps, we'll never be asked
    // for a page in a gap, so, if two descriptors refer to the same
    // domain, merge them in place.
    //

    j = 0;
    for (i = 1; i < MemoryDescriptorCount; i++) {
        if (HalpNumaMemoryNode[j] !=
            HalpNumaMemoryNode[i]) {
            j++;
            HalpNumaMemoryNode[j] = HalpNumaMemoryNode[i];
            HalpNumaMemoryRanges[j] = HalpNumaMemoryRanges[i];
            continue;
        }
    }

    MemoryDescriptorCount = j + 1;

    //
    // Terminate the table with ~0 which won't actually correspond to
    // any domain but will always be higher than any valid value.
    //

    HalpNumaMemoryRanges[MemoryDescriptorCount] = (ULONG_PTR) ~0I64;

    //
    // And the base of the lowest range should be 0 even if there
    // are no pages that low.
    //

    HalpNumaMemoryRanges[0] = 0;

    //
    // Convert the proximity IDs in the memory node array to
    // node number.   Node number is the index of the matching
    // entry in proximity ID array.
    //

    for (i= 0; i < MemoryDescriptorCount; i++) {
        for (j = 0;  j < HalpNumaConfig->NodeCount; j++) {
            if (HalpNumaMemoryNode[i] == HalpNumaConfig->ProximityId[j]) {
                HalpNumaMemoryNode[i] = (UCHAR)j;
                break;
            }
        }
    }
}

#endif

NTSTATUS
HalpGetAcpiStaticNumaTopology(
    HAL_NUMA_TOPOLOGY_INTERFACE * NumaInfo
    )
{
#if !defined(NT_UP)

    //
    // This routine is never called unless this ACPI HAL found
    // a Static Resource Affinity Table (SRAT).  But just in case ...
    //

    if (HalpAcpiSrat == NULL) {
        return STATUS_INVALID_LEVEL;
    }

    //
    // Fill in the data structure for the kernel.
    //

    NumaInfo->NumberOfNodes = HalpNumaConfig->NodeCount;
    NumaInfo->QueryProcessorNode = HalpNumaQueryProcessorNode;
    NumaInfo->PageToNode = HalpNumaQueryPageToNode;
    return STATUS_SUCCESS;

#else

    return STATUS_INVALID_LEVEL;

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\xxbiosc.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxbiosc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

!ENDIF

!include $(PROJECT_ROOT)\hals\hals.inc

#
# Souce files used by all ACPI HALs, all processors
#

CSOURCES= \
    hal.rc                 \
    ..\acpidtct.c          \
    ..\chiphacks.c         \
    ..\cmosopregion.c      \
    ..\drivesup.c	   \
    ..\dynsysres.c         \
    ..\ixenvirv.c          \
    ..\ixfirm.c            \
    ..\ixhalt.c            \
    ..\ixhwsup.c           \
    ..\ixinfo.c            \
    ..\ixisabus.c          \
    ..\ixisasup.c          \
    ..\ixnmi.c             \
    ..\ixpcibus.c          \
    ..\ixpciint.c          \
    ..\ixphwsup.c          \
    ..\ixpnpdrv.c          \
    ..\ixreboot.c          \
    ..\ixslpsup.c          \
    ..\ixthunk.c           \
    ..\ixusage.c           \
    ..\mpipic.c            \
    ..\mpprocst.c          \
    ..\pmbus.c             \
    ..\pmdata.c            \
    ..\pmisabus.c          \
    ..\pmpcisup.c          \
    ..\pmsleep.c           \
    ..\sratnuma.c          \
    ..\xxacpi.c            \
    ..\xxdisp.c            \
    ..\xxmemory.c          \
    ..\xxstubs.c           \
    ..\xxtime.c            

#
# Source files used by all ACPI HALs, i386 only
#

SOURCES_I386=\
    ..\xxbiosc.c         \
    ..\i386\ixbeep.asm   \
    ..\i386\ixcmos.asm   \
    ..\i386\ixidle.asm   \
    ..\i386\ixmcaa.asm   \
    ..\i386\ixmovnti.asm \
    ..\i386\ixslpctx.asm \
    ..\i386\ixsstate.asm \
    ..\mmtimer.c         \
    ..\i386\pmrtc.asm    \
    ..\i386\xxbiosa.asm  \
    ..\i386\xxioacc.asm  \
    ..\xxtimer.c         


#
# Source files used by all ACPI HALs, AMD64 only
#

AMD64_ASM=\
    ..\amd64\amd64s.asm  

SOURCES_AMD64=\
    ..\amd64\interrupt.c \
    ..\amd64\ixbeep.c  	 \
    ..\amd64\ixcmos.c    \
    ..\amd64\ixsstate.c  \
    ..\amd64\picinit.c   \
    ..\amd64\pmrtc.c     \
    ..\amd64\x86bios.c	 \
    $(AMD64_ASM)

ASM_DEFINES=$(ASM_DEFINES) -DIS_HAL
    

DLLDEF=$(O)\hal.def

LINKER_FLAGS=$(LINKER_FLAGS) -merge:PAGECONST=PAGE -merge:INITCONST=INIT /LARGEADDRESSAWARE

TARGETLIBS = \
    $(HALKIT_LIB_PATH)\kdcom.lib

!IF $(AMD64)

TARGETLIBS = $(TARGETLIBS) \
    $(HALKIT_LIB_PATH)\x86new.lib

NTTARGETFILE0=startup_code
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\xxacpi.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    xxacpi.c

Abstract:

    Implements various ACPI utility functions.

Author:

    Jake Oshins (jakeo) 12-Feb-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"
#include "pci.h"
#include "string.h"
#include "stdlib.h"
#include "stdio.h"
#include "mmtimer.h"
#include "chiphacks.h"


//#define DUMP_FADT

VOID
HalAcpiTimerCarry(
    VOID
    );

VOID
HalAcpiBrokenPiix4TimerCarry(
    VOID
    );

VOID
HalaAcpiTimerInit(
    ULONG      TimerPort,
    BOOLEAN    TimerValExt
    );

ULONG
HaliAcpiQueryFlags(
    VOID
    );

VOID
HaliAcpiTimerInit(
    IN ULONG TimerPort  OPTIONAL,
    IN BOOLEAN    TimerValExt
    );

VOID
HaliAcpiMachineStateInit(
    IN PPROCESSOR_INIT ProcInit,
    IN PHAL_SLEEP_VAL  SleepValues,
    OUT PULONG         PicVal
    );

BOOLEAN
FASTCALL
HalAcpiC1Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

BOOLEAN
FASTCALL
HalAcpiC2Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

BOOLEAN
FASTCALL
HalAcpiC3ArbdisIdle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

BOOLEAN
FASTCALL
HalAcpiC3WbinvdIdle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

VOID
FASTCALL
HalProcessorThrottle(
    IN UCHAR Throttle
    );

NTSTATUS
HaliSetWakeAlarm (
        IN ULONGLONG    WakeSystemTime,
        IN PTIME_FIELDS WakeTimeFields OPTIONAL
        );

VOID
HaliSetWakeEnable(
        IN BOOLEAN      Enable
        );

ULONG
HaliPciInterfaceReadConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HaliPciInterfaceWriteConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

VOID
HaliSetMaxLegacyPciBusNumber(
    IN ULONG BusNumber
    );

VOID
HalpInitBootTable (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
HalReadBootRegister(
    PUCHAR BootRegisterValue
    );

NTSTATUS
HalWriteBootRegister(
    UCHAR BootRegisterValue
    );

VOID
HalpEndOfBoot(
    VOID
    );

VOID
HalpPutAcpiHacksInRegistry(
    VOID
    );

VOID
HalpDynamicSystemResourceConfiguration(
    IN PLOADER_PARAMETER_BLOCK
    );

#if !defined(NT_UP)

VOID
HalpNumaInitializeStaticConfiguration(
    IN PLOADER_PARAMETER_BLOCK
    );

#endif

//
// Externs
//

extern ULONG    HalpAcpiFlags;
extern PHYSICAL_ADDRESS HalpAcpiRsdt;
extern SLEEP_STATE_CONTEXT HalpShutdownContext;
extern ULONG HalpPicVectorRedirect[];
extern ULONG HalpTimerWatchdogEnabled;
extern ULONG HalpOutstandingScatterGatherCount;
extern BOOLEAN HalpDisableHibernate;

//
// Globals
//

ULONG HalpInvalidAcpiTable;
PRSDT HalpAcpiRsdtVA;
PXSDT HalpAcpiXsdtVA;

//
// This is the dispatch table used by the ACPI driver
//
HAL_ACPI_DISPATCH_TABLE HalAcpiDispatchTable = {
        HAL_ACPI_DISPATCH_SIGNATURE, // Signature
    HAL_ACPI_DISPATCH_VERSION, // Version
    &HaliAcpiTimerInit, // HalpAcpiTimerInit
    NULL, // HalpAcpiTimerInterrupt
    &HaliAcpiMachineStateInit, // HalpAcpiMachineStateInit
    &HaliAcpiQueryFlags, // HalpAcpiQueryFlags
    &HalpAcpiPicStateIntact, // HalxPicStateIntact
    &HalpRestoreInterruptControllerState, // HalxRestorePicState
    &HaliPciInterfaceReadConfig, // HalpPciInterfaceReadConfig
    &HaliPciInterfaceWriteConfig, // HalpPciInterfaceWriteConfig
    &HaliSetVectorState, // HalpSetVectorState
    (pHalGetIOApicVersion)&HalpGetApicVersion, // HalpGetIOApicVersion
    &HaliSetMaxLegacyPciBusNumber, // HalpSetMaxLegacyPciBusNumber
    &HaliIsVectorValid // HalpIsVectorValid
};
PPM_DISPATCH_TABLE PmAcpiDispatchTable = NULL;


NTSTATUS
HalpQueryAcpiResourceRequirements(
    IN  PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    );

NTSTATUS
HalpBuildAcpiResourceList(
    OUT PIO_RESOURCE_REQUIREMENTS_LIST  List
    );

NTSTATUS
HalpAcpiDetectResourceListSize(
    OUT  PULONG   ResourceListSize
    );

VOID
HalpPiix4Detect(
    BOOLEAN DuringBoot
    );

ULONG
HalpGetPCIData (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpGetCmosData(
    IN ULONG    SourceLocation,
    IN ULONG    SourceAddress,
    IN PUCHAR   ReturnBuffer,
    IN ULONG    ByteCount
    );

VOID
HalpSetCmosData(
    IN ULONG    SourceLocation,
    IN ULONG    SourceAddress,
    IN PUCHAR   ReturnBuffer,
    IN ULONG    ByteCount
    );

#define LOW_MEMORY          0x000100000

#define MAX(a, b)       \
    ((a) > (b) ? (a) : (b))

#define MIN(a, b)       \
    ((a) < (b) ? (a) : (b))

//
// The following is a Stub version of HalpGetApicVersion
// for non-APIC halacpi's (which don't include
// pmapic.c). This stub just always returns 0.
//

#ifndef APIC_HAL
ULONG HalpGetApicVersion(ULONG ApicNo)
{
   return 0;
}
#endif

//
// ADRIAO 09/16/98 - We are no longer having the HAL declare the IO ports
//                   specified in the FADT. These will be declared in a future
//                   defined PNP0Cxx node (for now, in PNP0C02). This is done
//                   because we cannot know at the hal level what bus the ACPI
//                   FADT resources refer to. We can only use the translated
//                   resource info.
//
//   Hence...
//
#define DECLARE_FADT_RESOURCES_AT_ROOT 0

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpGetAcpiTablePhase0)
#pragma alloc_text(INIT, HalpSetupAcpiPhase0)
#pragma alloc_text(INIT, HalpInitBootTable)
#pragma alloc_text(PAGE, HaliInitPowerManagement)
#pragma alloc_text(PAGE, HalpQueryAcpiResourceRequirements)
#pragma alloc_text(PAGE, HalpBuildAcpiResourceList)
#pragma alloc_text(PAGE, HalpAcpiDetectResourceListSize)
#pragma alloc_text(PAGE, HaliAcpiTimerInit)
#pragma alloc_text(PAGE, HaliAcpiMachineStateInit)
#pragma alloc_text(PAGE, HaliAcpiQueryFlags)
#pragma alloc_text(PAGE, HaliSetWakeEnable)
#pragma alloc_text(PAGE, HalpEndOfBoot)
#pragma alloc_text(PAGE, HalpPutAcpiHacksInRegistry)
#pragma alloc_text(PAGELK, HalpPiix4Detect)
#pragma alloc_text(PAGELK, HalReadBootRegister)
#pragma alloc_text(PAGELK, HalWriteBootRegister)
#pragma alloc_text(PAGELK, HalpResetSBF)
#endif

PVOID
HalpGetAcpiTablePhase0(
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN  ULONG   Signature
    )
/*++

Routine Description:

    This function returns a pointer to the ACPI table that is
    identified by Signature.

Arguments:

    Signature - A four byte value that identifies the ACPI table

Return Value:

    Pointer to a copy of the table

--*/
{
    PRSDT rsdt;
    PXSDT xsdt = NULL;
    ULONG entry, rsdtEntries, rsdtLength;
    PVOID table;
    PHYSICAL_ADDRESS physicalAddr;
    PDESCRIPTION_HEADER header;
    NTSTATUS status;
    ULONG lengthInPages;
    ULONG offset;

    physicalAddr.QuadPart = 0;
    header = NULL;

    if ((HalpAcpiRsdtVA == NULL) && (HalpAcpiXsdtVA == NULL)) {

        //
        // Find and map the RSDT once.  This mapping is reused on
        // subsequent calls to this routine.
        //

        status = HalpAcpiFindRsdtPhase0(LoaderBlock);

        if (!NT_SUCCESS(status)) {
            DbgPrint("*** make sure you are using ntdetect.com v5.0 ***\n");
            KeBugCheckEx(MISMATCHED_HAL,
                4, 0xac31, 0, 0);
        }

        rsdt = HalpMapPhysicalMemoryWriteThrough( HalpAcpiRsdt, 2);

        if (!rsdt) {
            return NULL;
        }

        //
        // Do a sanity check on the RSDT.
        //
        if ((rsdt->Header.Signature != RSDT_SIGNATURE) &&
            (rsdt->Header.Signature != XSDT_SIGNATURE)) {
            HalDisplayString("Bad RSDT pointer\n");
            KeBugCheckEx(MISMATCHED_HAL,
                4, 0xac31, 0, 0);
        }

        //
        // Calculate the number of entries in the RSDT.
        //

        rsdtLength = rsdt->Header.Length;

        //
        // Remap the RSDT now that we know how long it is.
        //

        offset = HalpAcpiRsdt.LowPart & (PAGE_SIZE - 1);
        lengthInPages = (offset + rsdtLength + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
        if (lengthInPages != 2) {
            HalpUnmapVirtualAddress(rsdt, 2);
            rsdt = HalpMapPhysicalMemoryWriteThrough( HalpAcpiRsdt, lengthInPages);
            if (!rsdt) {
                DbgPrint("HAL: Couldn't remap RSDT\n");
                return NULL;
            }
        }

        if (rsdt->Header.Signature == XSDT_SIGNATURE) {

            xsdt = (PXSDT)rsdt;
            rsdt = NULL;
        }

        HalpAcpiRsdtVA = rsdt;
        HalpAcpiXsdtVA = xsdt;
    }
    rsdt = HalpAcpiRsdtVA;
    xsdt = HalpAcpiXsdtVA;

    //
    // Calculate the number of entries in the RSDT.
    //
    rsdtEntries = xsdt ?
        NumTableEntriesFromXSDTPointer(xsdt) :
        NumTableEntriesFromRSDTPointer(rsdt);

    //
    // Look down the pointer in each entry to see if it points to
    // the table we are looking for.
    //
    for (entry = 0; entry < rsdtEntries; entry++) {

        if (xsdt) {

            physicalAddr = xsdt->Tables[entry];

        } else {

            physicalAddr.LowPart = rsdt->Tables[entry];
        }

        if (header != NULL) {
            HalpUnmapVirtualAddress(header, 2);
        }

        header = HalpMapPhysicalMemoryWriteThrough( physicalAddr, 2);

        if (!header) {
            return NULL;
        }

        if (header->Signature == Signature) {
            break;
        }
    }

    if (entry == rsdtEntries) {

        //
        // Signature not found, free the PTE for the last entry
        // examined and indicate failure to the caller.
        //

        HalpUnmapVirtualAddress(header, 2);
        return NULL;
    }

    //
    // Make sure we have mapped enough memory to cover the entire
    // table.
    //

    offset = (ULONG)((ULONG_PTR)header & (PAGE_SIZE - 1));
    lengthInPages = (header->Length + offset + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
    if (lengthInPages != 2) {
        HalpUnmapVirtualAddress(header, 2);
        header = HalpMapPhysicalMemoryWriteThrough( physicalAddr, lengthInPages);
    }

    //
    // Validate the table's checksum.
    // N.B. We expect the checksum to be wrong on some early versions
    // of the FADT.
    //

    if ((header != NULL)  &&
        ((header->Signature != FADT_SIGNATURE) || (header->Revision > 2))) {

        PUCHAR c = (PUCHAR)header + header->Length;
        UCHAR s = 0;

        if (header->Length) {
            do {
                s += *--c;
            } while (c != (PUCHAR)header);
        }


        if ((s != 0) || (header->Length == 0)) {

            //
            // This table is not valid.
            //

            HalpInvalidAcpiTable = header->Signature;

#if 0

            //
            // Don't return this table.
            //

            HalpUnmapVirtualAddress(header, lengthInPages);
            return NULL;

#endif

        }
    }
    return header;
}

PVOID
HalpGetAcpiTable(
  IN  ULONG  Signature
  )
/*++

  Routine Description:

      This routine will retrieve any table referenced in the ACPI
      RSDT.

  Arguments:

      Signature - Target table signature

  Return Value:

      pointer to a copy of the table, or NULL if not found

--*/
{

  PACPI_BIOS_MULTI_NODE multiNode;
  NTSTATUS status;
  ULONG entry, rsdtEntries;
  PDESCRIPTION_HEADER header;
  PHYSICAL_ADDRESS physicalAddr;
  PRSDT rsdt;
  ULONG rsdtSize;
  PVOID table = NULL;


  //
  // Get the physical address of the RSDT from the Registry
  //

  status = HalpAcpiFindRsdt(&multiNode);

  if (!NT_SUCCESS(status)) {
    DbgPrint("AcpiFindRsdt() Failed!\n");
    return NULL;
  }


  //
  // Map down header to get total RSDT table size
  //

  header = MmMapIoSpace(multiNode->RsdtAddress, sizeof(DESCRIPTION_HEADER), MmNonCached);

  if (!header) {
    return NULL;
  }

  rsdtSize = header->Length;
  MmUnmapIoSpace(header, sizeof(DESCRIPTION_HEADER));


  //
  // Map down entire RSDT table
  //

  rsdt = MmMapIoSpace(multiNode->RsdtAddress, rsdtSize, MmNonCached);

  ExFreePool(multiNode);

  if (!rsdt) {
    return NULL;
  }


  //
  // Do a sanity check on the RSDT.
  //

  if ((rsdt->Header.Signature != RSDT_SIGNATURE) &&
      (rsdt->Header.Signature != XSDT_SIGNATURE)) {

    DbgPrint("RSDT table contains invalid signature\n");
    goto GetAcpiTableEnd;
  }


  //
  // Calculate the number of entries in the RSDT.
  //

  rsdtEntries = rsdt->Header.Signature == XSDT_SIGNATURE ?
      NumTableEntriesFromXSDTPointer(rsdt) :
      NumTableEntriesFromRSDTPointer(rsdt);


  //
  // Look down the pointer in each entry to see if it points to
  // the table we are looking for.
  //

  for (entry = 0; entry < rsdtEntries; entry++) {

    if (rsdt->Header.Signature == XSDT_SIGNATURE) {
      physicalAddr = ((PXSDT)rsdt)->Tables[entry];
    } else {
      physicalAddr.HighPart = 0;
      physicalAddr.LowPart = (ULONG)rsdt->Tables[entry];
    }

    //
    // Map down the header, check the signature
    //

    header = MmMapIoSpace(physicalAddr, sizeof(DESCRIPTION_HEADER), MmNonCached);

    if (!header) {
      goto GetAcpiTableEnd;
    }

    if (header->Signature == Signature) {

      table = ExAllocatePoolWithTag(PagedPool, header->Length, HAL_POOL_TAG );

      if (table) {
        RtlCopyMemory(table, header, header->Length);
      }

      MmUnmapIoSpace(header, sizeof(DESCRIPTION_HEADER));
      break;
    }

    MmUnmapIoSpace(header, sizeof(DESCRIPTION_HEADER));
  }


GetAcpiTableEnd:

  MmUnmapIoSpace(rsdt, rsdtSize);
  return table;

}

NTSTATUS
HalpSetupAcpiPhase0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    Save some information from the ACPI tables before they get
    destroyed.

Arguments:

    none

Return Value:

    none

--*/
{
    NTSTATUS    status;
    ULONG entry, rsdtEntries, rsdtLength;
    PVOID table;
    PHYSICAL_ADDRESS physicalAddr;
    PDESCRIPTION_HEADER header;
    PEVENT_TIMER_DESCRIPTION_TABLE EventTimerDescription = NULL;

    if (HalpProcessedACPIPhase0) {
        return STATUS_SUCCESS;
    }

    //
    // Copy the Fixed Acpi Descriptor Table (FADT) to a permanent
    // home.
    //

    header = HalpGetAcpiTablePhase0(LoaderBlock, FADT_SIGNATURE);
    if (header == NULL) {
        DbgPrint("HAL: Didn't find the FACP\n");
        return STATUS_NOT_FOUND;
    }

    RtlCopyMemory(&HalpFixedAcpiDescTable,
                  header,
                  MIN(header->Length, sizeof(HalpFixedAcpiDescTable)));

    HalpUnMapPhysicalRange(header, header->Length);

#ifdef DUMP_FADT
    DbgPrint("HAL: ACPI Fixed ACPI Description Table\n");
    DbgPrint("\tDSDT:\t\t\t0x%08x\n", HalpFixedAcpiDescTable.dsdt);
    DbgPrint("\tSCI_INT:\t\t%d\n", HalpFixedAcpiDescTable.sci_int_vector);
    DbgPrint("\tPM1a_EVT:\t\t0x%04x\n", HalpFixedAcpiDescTable.pm1a_evt_blk_io_port);
    DbgPrint("\tPM1b_EVT:\t\t0x%04x\n", HalpFixedAcpiDescTable.pm1b_evt_blk_io_port);
    DbgPrint("\tPM1a_CNT:\t\t0x%04x\n", HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port);
    DbgPrint("\tPM1b_CNT:\t\t0x%04x\n", HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port);
    DbgPrint("\tPM2_CNT:\t\t0x%04x\n", HalpFixedAcpiDescTable.pm2_ctrl_blk_io_port);
    DbgPrint("\tPM_TMR:\t\t\t0x%04x\n", HalpFixedAcpiDescTable.pm_tmr_blk_io_port);
    DbgPrint("\t\t flags: %08x\n", HalpFixedAcpiDescTable.flags);
#endif

    HalpDebugPortTable = HalpGetAcpiTablePhase0(LoaderBlock, DBGP_SIGNATURE);

#if !defined(NT_UP)

    //
    // See if Static Resource Affinity Table is present.
    //

    HalpNumaInitializeStaticConfiguration(LoaderBlock);

#endif

    HalpDynamicSystemResourceConfiguration(LoaderBlock);

#if 0
    EventTimerDescription =
        HalpGetAcpiTablePhase0(LoaderBlock, ETDT_SIGNATURE);

    //
    // Initialize timer HW needed for boot
    //
    if (EventTimerDescription) {
        HalpmmTimerInit(EventTimerDescription->EventTimerBlockID,
                        EventTimerDescription->BaseAddress);
    }
#endif

    HaliAcpiTimerInit(0, FALSE);

    //
    // Claim a page of memory below 1MB to be used for transitioning
    // a sleeping processor back from real mode to protected mode
    //

    // check first to see if this has already been done by MP startup code
    if (!HalpLowStubPhysicalAddress) {

        HalpLowStubPhysicalAddress = UlongToPtr(HalpAllocPhysicalMemory (LoaderBlock,
                                            LOW_MEMORY, 1, FALSE));

        if (HalpLowStubPhysicalAddress) {

            HalpLowStub = HalpMapPhysicalMemory(
                            HalpPtrToPhysicalAddress( HalpLowStubPhysicalAddress ),
                            1);
        }
    }

    //
    // Claim a PTE that will be used for cache flushing in states S2 and S3.
    //

    HalpVirtAddrForFlush = HalpMapPhysicalMemory(
                            HalpPtrToPhysicalAddress((PVOID)LOW_MEMORY),
                            1);

    HalpPteForFlush = MiGetPteAddress(HalpVirtAddrForFlush);

    HalpProcessedACPIPhase0 = TRUE;

    HalpInitBootTable (LoaderBlock);

    return STATUS_SUCCESS;
}

VOID
HaliAcpiTimerInit(
    IN ULONG      TimerPort  OPTIONAL,
    IN BOOLEAN    TimerValExt
    )
/*++
Routine Description:

    This routine initializes the ACPI timer.

Arguments:

    TimerPort - The address in I/O space of the ACPI timer.  If this is
                0, then the values from the cached FADT will be used.

    TimerValExt - signifies whether the timer is 24 or 32 bits.

--*/
{
    ULONG port = TimerPort;
    BOOLEAN ext = TimerValExt;

    PAGED_CODE();

    if (port == 0) {
        port = HalpFixedAcpiDescTable.pm_tmr_blk_io_port;
        if (HalpFixedAcpiDescTable.flags & TMR_VAL_EXT) {
            ext = TRUE;
        } else {
            ext = FALSE;
        }
    }

    HalaAcpiTimerInit(port,
                      ext);
}

VOID
HaliAcpiMachineStateInit(
    IN PPROCESSOR_INIT ProcInit,
    IN PHAL_SLEEP_VAL  SleepValues,
    OUT PULONG         PicVal
    )
/*++
Routine Description:

    This function is a callback used by the ACPI driver
    to notify the HAL with the processor blocks.

Arguments:

--*/
{
    POWER_STATE_HANDLER powerState;
    SLEEP_STATE_CONTEXT sleepContext;
    NTSTATUS    status;
    ULONG       i;
    USHORT      us;
    ULONG       cStates = 1;
    ULONG       ntProc;
    ULONG       procCount = 0;

    PAGED_CODE();
    UNREFERENCED_PARAMETER(ProcInit);

    HalpWakeupState.GeneralWakeupEnable = TRUE;
    HalpWakeupState.RtcWakeupEnable = FALSE;

#ifdef APIC_HAL
    *PicVal = 1;
#else
    *PicVal = 0;
#endif
    //
    // Register sleep handlers with Policy Manager
    //

    if (SleepValues[0].Supported) {
        powerState.Type = PowerStateSleeping1;
        powerState.RtcWake = TRUE;
        powerState.Handler = &HaliAcpiSleep;

        sleepContext.bits.Pm1aVal = SleepValues[0].Pm1aVal;
        sleepContext.bits.Pm1bVal = SleepValues[0].Pm1bVal;
        sleepContext.bits.Flags = SLEEP_STATE_SAVE_MOTHERBOARD;

        powerState.Context = UlongToPtr(sleepContext.AsULONG);

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);
        ASSERT(NT_SUCCESS(status));

    }

    if (SleepValues[1].Supported && HalpWakeVector) {
        powerState.Type = PowerStateSleeping2;
        powerState.RtcWake = TRUE;
        powerState.Handler = &HaliAcpiSleep;

        sleepContext.bits.Pm1aVal = SleepValues[1].Pm1aVal;
        sleepContext.bits.Pm1bVal = SleepValues[1].Pm1bVal;
        sleepContext.bits.Flags = SLEEP_STATE_FLUSH_CACHE |
                                  SLEEP_STATE_FIRMWARE_RESTART |
                                  SLEEP_STATE_SAVE_MOTHERBOARD |
                                  SLEEP_STATE_RESTART_OTHER_PROCESSORS;

        powerState.Context = UlongToPtr(sleepContext.AsULONG);

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);
        ASSERT(NT_SUCCESS(status));

    }

    if (SleepValues[2].Supported && HalpWakeVector) {
        powerState.Type = PowerStateSleeping3;
        powerState.RtcWake = TRUE;
        powerState.Handler = &HaliAcpiSleep;

        sleepContext.bits.Pm1aVal = SleepValues[2].Pm1aVal;
        sleepContext.bits.Pm1bVal = SleepValues[2].Pm1bVal;
        sleepContext.bits.Flags = SLEEP_STATE_FLUSH_CACHE |
                                  SLEEP_STATE_FIRMWARE_RESTART |
                                  SLEEP_STATE_SAVE_MOTHERBOARD |
                                  SLEEP_STATE_RESTART_OTHER_PROCESSORS;

        powerState.Context = UlongToPtr(sleepContext.AsULONG);

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);
        ASSERT(NT_SUCCESS(status));

    }

    i = 0;
    if (SleepValues[3].Supported) {
        i = 3;
    } else if (SleepValues[4].Supported) {
        i = 4;
    }

    if (i && (HalpDisableHibernate == FALSE)) {
        powerState.Type = PowerStateSleeping4;
        powerState.RtcWake = HalpFixedAcpiDescTable.flags & RTC_WAKE_FROM_S4 ? TRUE : FALSE;
        powerState.Handler = &HaliAcpiSleep;

        sleepContext.bits.Pm1aVal = SleepValues[i].Pm1aVal;
        sleepContext.bits.Pm1bVal = SleepValues[i].Pm1bVal;
        sleepContext.bits.Flags = SLEEP_STATE_SAVE_MOTHERBOARD |
                                  SLEEP_STATE_RESTART_OTHER_PROCESSORS;

        powerState.Context = UlongToPtr(sleepContext.AsULONG);

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);
        ASSERT(NT_SUCCESS(status));
    }

    if (SleepValues[4].Supported) {
        powerState.Type = PowerStateShutdownOff;
        powerState.RtcWake = FALSE;
        powerState.Handler = &HaliAcpiSleep;

        sleepContext.bits.Pm1aVal = SleepValues[4].Pm1aVal;
        sleepContext.bits.Pm1bVal = SleepValues[4].Pm1bVal;
        sleepContext.bits.Flags = SLEEP_STATE_OFF;
        HalpShutdownContext = sleepContext;

        powerState.Context = UlongToPtr(sleepContext.AsULONG);

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);
        ASSERT(NT_SUCCESS(status));
    }
}

ULONG
HaliAcpiQueryFlags(
    VOID
    )
/*++

Routine Description:

    This routine is temporary is used to report the presence of the
    boot.ini switch

Arguments:

    None

Return Value:

    TRUE, if switch present

--*/
{
    return HalpAcpiFlags;
}



NTSTATUS
HaliInitPowerManagement(
    IN PPM_DISPATCH_TABLE  PmDriverDispatchTable,
    IN OUT PPM_DISPATCH_TABLE *PmHalDispatchTable
    )

/*++

Routine Description:

    This is called by the ACPI driver to start the PM
    code.

Arguments:

    PmDriverDispatchTable - table of functions provided
        by the ACPI driver for the HAL

    PmHalDispatchTable - table of functions provided by
        the HAL for the ACPI driver

Return Value:

    status

--*/
{
    OBJECT_ATTRIBUTES objAttributes;
    PCALLBACK_OBJECT  callback;
    PHYSICAL_ADDRESS  pAddr;
    UNICODE_STRING    callbackName;
    NTSTATUS          status;
    PFACS         facs;

    PAGED_CODE();

    //
    // Figure out if we have to work around PIIX4
    //

    HalpPiix4Detect(TRUE);
    HalpPutAcpiHacksInRegistry();

    //
    // Keep a pointer to the driver's dispatch table.
    //
//  ASSERT(PmDriverDispatchTable);
//  ASSERT(PmDriverDispatchTable->Signature == ACPI_HAL_DISPATCH_SIGNATURE);
    PmAcpiDispatchTable = PmDriverDispatchTable;

#if defined(_WIN64)

    HalAcpiDispatchTable.HalpAcpiTimerInterrupt =
        (pHalAcpiTimerInterrupt)&HalAcpiTimerCarry;

#else

    //
    // Fill in the function table
    //
    if (!HalpBrokenAcpiTimer) {

        HalAcpiDispatchTable.HalpAcpiTimerInterrupt =
            (pHalAcpiTimerInterrupt)&HalAcpiTimerCarry;

    } else {

        HalAcpiDispatchTable.HalpAcpiTimerInterrupt =
            (pHalAcpiTimerInterrupt)&HalAcpiBrokenPiix4TimerCarry;

    }

#endif

    *PmHalDispatchTable = (PPM_DISPATCH_TABLE)&HalAcpiDispatchTable;

    //
    // Fill in Hal's private dispatch table
    //
    HalSetWakeEnable = HaliSetWakeEnable;
    HalSetWakeAlarm  = HaliSetWakeAlarm;

    //
    // Register callback that tells us to make
    // anything we need for sleeping non-pageable.
    //

    RtlInitUnicodeString(&callbackName, L"\\Callback\\PowerState");

    InitializeObjectAttributes(
        &objAttributes,
        &callbackName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        NULL
        );

    ExCreateCallback(&callback,
                     &objAttributes,
                     FALSE,
                     TRUE);

    ExRegisterCallback(callback,
                       (PCALLBACK_FUNCTION)&HalpPowerStateCallback,
                       NULL);

    //
    // Find the location of the firmware waking vector.
    //  N.B.  If any of this fails, then HalpWakeVector will be NULL
    //        and we won't support S2 or S3.
    //
    if (HalpFixedAcpiDescTable.facs) {

        pAddr.HighPart = 0;
        pAddr.LowPart = HalpFixedAcpiDescTable.facs;

        facs = MmMapIoSpace(pAddr, sizeof(FACS), MmNonCached);

        if (facs) {

            if (facs->Signature == FACS_SIGNATURE) {

                HalpWakeVector = &facs->pFirmwareWakingVector;
            }
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
HalpQueryAcpiResourceRequirements(
    IN  PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    )
/*++

Routine Description:

    This routine is a temporary stub that tries to detect the presence
    of an ACPI controller within the system. This code is meant to be
    inserted within NT's root system enumerator.

Arguents:

    Requirements - pointer to list of resources

Return Value:

    STATUS_SUCCESS                  - If we found a device object
    STATUS_NO_SUCH_DEVICE           - If we can't find info about the new PDO

--*/
{
    NTSTATUS                        ntStatus;
    PIO_RESOURCE_REQUIREMENTS_LIST  resourceList;
    ULONG                           resourceListSize;

    PAGED_CODE();

    //
    // Now figure out the number of resource that we need
    //
    ntStatus = HalpAcpiDetectResourceListSize(
        &resourceListSize
        );

    //
    // Convert this resourceListSize into the number of bytes that we
    // must allocate
    //
    resourceListSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
        ( (resourceListSize - 1) * sizeof(IO_RESOURCE_DESCRIPTOR) );

    //
    // Allocate the correct number of bytes of the Resource List
    //
    resourceList = ExAllocatePoolWithTag(
        PagedPool,
        resourceListSize,
        HAL_POOL_TAG
        );

    //
    // This call must have succeeded or we cannot lay claim to ACPI
    //
    if (resourceList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set up the ListSize in the structure
    //
    RtlZeroMemory(resourceList, resourceListSize);
    resourceList->ListSize = resourceListSize;

    //
    // Build the ResourceList here
    //
    ntStatus = HalpBuildAcpiResourceList(resourceList);

    //
    // Did we build the list okay?
    //
    if (!NT_SUCCESS(ntStatus)) {

        //
        // Free memory and exit
        //
        ExFreePool(resourceList);
        return STATUS_NO_SUCH_DEVICE;
    }

    *Requirements = resourceList;
    return ntStatus;
}

NTSTATUS
HalpBuildAcpiResourceList(
    OUT PIO_RESOURCE_REQUIREMENTS_LIST  List
    )
/*++

Routine Description:

    This is the routine that builds the ResourceList given the FADT and
    an arbitrary number of ResourceDescriptors. We assume that the
    ResourceList has been properly allocated and sized

Arguments:

    List    - The list to fill in

Return Value:

    STATUS_SUCCESS if okay
    STATUS_UNSUCCESSUL if not

--*/
{
    PIO_RESOURCE_DESCRIPTOR partialResource;
    ULONG                   count = 0;

    PAGED_CODE();

    ASSERT( List != NULL );

    //
    // Specify default values for Bus Type and
    // the bus number. These values represent root
    //
    List->AlternativeLists = 1;
    List->InterfaceType = PNPBus;
    List->BusNumber = -1;
    List->List[0].Version = 1;
    List->List[0].Revision = 1;

    //
    // Is there an interrupt resource required?
    //
    if (HalpFixedAcpiDescTable.sci_int_vector != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypeInterrupt;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareShared;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
        List->List[0].Descriptors[count].u.Interrupt.MinimumVector =
        List->List[0].Descriptors[count].u.Interrupt.MaximumVector =
            HalpPicVectorRedirect[HalpFixedAcpiDescTable.sci_int_vector];
        List->List[0].Count++;
        count++;
    }

#if DECLARE_FADT_RESOURCES_AT_ROOT

    //
    // Is there an SMI CMD IO Port?
    //
    if (HalpFixedAcpiDescTable.smi_cmd_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags =CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            (ULONG) HalpFixedAcpiDescTable.smi_cmd_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            (ULONG) HalpFixedAcpiDescTable.smi_cmd_io_port;
        List->List[0].Descriptors[count].u.Port.Length = 1;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there an PM1A Event Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1a_evt_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1a_evt_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1a_evt_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm1_evt_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm1_evt_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM1B Event Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1b_evt_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1b_evt_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm1_evt_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm1_evt_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM1A Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm1_ctrl_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm1_ctrl_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM1B Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm1_ctrl_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm1_ctrl_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM2 Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm2_ctrl_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm2_ctrl_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm2_ctrl_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm2_ctrl_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm2_ctrl_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM Timer Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm_tmr_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm_tmr_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm_tmr_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm_tmr_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm_tmr_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a GP0 Block IO Port?
    //
    if (HalpFixedAcpiDescTable.gp0_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.gp0_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.gp0_blk_io_port + (ULONG) HalpFixedAcpiDescTable.gp0_blk_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.gp0_blk_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a GP1 Block IO port?
    //
    if (HalpFixedAcpiDescTable.gp1_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.gp1_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.gp1_blk_io_port + (ULONG) HalpFixedAcpiDescTable.gp1_blk_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.gp1_blk_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }
#endif // DECLARE_FADT_RESOURCES_AT_ROOT

    return STATUS_SUCCESS;
}

NTSTATUS
HalpAcpiDetectResourceListSize(
    OUT  PULONG   ResourceListSize
    )
/*++

Routine Description:

    Given a pointer to an FADT, determine the number of
    CM_PARTIAL_RESOURCE_DESCRIPTORS that are required to
    describe all the resource mentioned in the FADT

Arguments:

    ResourceListSize    - Location to store the answer

Return Value:

    STATUS_SUCCESS if everything went okay

--*/
{
    PAGED_CODE();

    //
    // First of all, assume that we need no resources
    //
    *ResourceListSize = 0;

    //
    // Is there an interrupt resource required?
    //
    if (HalpFixedAcpiDescTable.sci_int_vector != 0) {
        *ResourceListSize += 1;
    }

#if DECLARE_FADT_RESOURCES_AT_ROOT
    //
    // Is there an SMI CMD IO Port?
    //
    if (HalpFixedAcpiDescTable.smi_cmd_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there an PM1A Event Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1a_evt_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM1B Event Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM1A Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM1B Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM2 Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm2_ctrl_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM Timer Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm_tmr_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a GP0 Block IO Port?
    //
    if (HalpFixedAcpiDescTable.gp0_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a GP1 Block IO Port?
    //
    if (HalpFixedAcpiDescTable.gp1_blk_io_port != 0) {
        *ResourceListSize += 1;
    }
#endif // DECLARE_FADT_RESOURCES_AT_ROOT

    return STATUS_SUCCESS;
}

VOID
HalpPiix4Detect(
    BOOLEAN DuringBoot
    )
/*++

Routine Description:

    This routine detects both the PIIX4 and the 440BX and
    enables various workarounds.  It also disconnects the
    PIIX4 USB controller from the interrupt controller, as
    many BIOSes boot with the USB controller in an
    interrupting state.

Arguments:

    DuringBoot - if TRUE, then do all the things that
                 have to happen at first boot
                 if FALSE, then do only the things that
                 have to happen each time the system
                 transitions to system state S0.

Note:

    This routine calls functions that must be called
    at PASSIVE_LEVEL when DuringBoot is TRUE.

--*/
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      UnicodeString;
    STRING              AString;
    NTSTATUS            Status;
    HANDLE              BaseHandle = NULL;
    HANDLE              Handle = NULL;
    BOOLEAN             i440BXpresent = FALSE;
    ULONG               Length;
    ULONG               BytesRead;
    UCHAR               BusNumber;
    ULONG               DeviceNumber;
    ULONG               FuncNumber;
    PCI_SLOT_NUMBER     SlotNumber;
    PCI_COMMON_CONFIG   PciHeader;
    UCHAR               DevActB;
    UCHAR               DramControl;
    ULONG               disposition;
    ULONG               flags;
    CHAR                buffer[20] = {0};

    struct {
        KEY_VALUE_PARTIAL_INFORMATION   Inf;
        UCHAR Data[3];
    } PartialInformation;

    if (DuringBoot) {
        PAGED_CODE();

        //
        // Open current control set
        //

        RtlInitUnicodeString (&UnicodeString,
                              L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET");

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   (PSECURITY_DESCRIPTOR) NULL);

        Status = ZwOpenKey (&BaseHandle,
                            KEY_READ,
                            &ObjectAttributes);

        if (!NT_SUCCESS(Status)) {
            return;
        }

        // Get the right key

        RtlInitUnicodeString (&UnicodeString,
                              L"Control\\HAL");

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   BaseHandle,
                                   (PSECURITY_DESCRIPTOR) NULL);

        Status = ZwCreateKey (&Handle,
                              KEY_READ,
                              &ObjectAttributes,
                              0,
                              (PUNICODE_STRING) NULL,
                              REG_OPTION_NON_VOLATILE,
                              &disposition);

        if(!NT_SUCCESS(Status)) {
            goto Piix4DetectCleanup;
        }
    }

    //
    // Check each existing PCI bus for a PIIX4 chip.
    //


    for (BusNumber = 0; BusNumber < 0xff; BusNumber++) {

        SlotNumber.u.AsULONG = 0;

        for (DeviceNumber = 0; DeviceNumber < PCI_MAX_DEVICES; DeviceNumber ++ ) {
            for (FuncNumber = 0; FuncNumber < PCI_MAX_FUNCTION; FuncNumber ++) {

            SlotNumber.u.bits.DeviceNumber = DeviceNumber;
            SlotNumber.u.bits.FunctionNumber = FuncNumber;

            BytesRead = HalGetBusData (
                            PCIConfiguration,
                            BusNumber,
                            SlotNumber.u.AsULONG,
                            &PciHeader,
                            PCI_COMMON_HDR_LENGTH
                            );

            if (!BytesRead) {
                // past last bus
                goto Piix4DetectEnd;
            }

            if (PciHeader.VendorID == PCI_INVALID_VENDORID) {
                continue;
            }

            if (DuringBoot) {

                //
                // Look for broken 440BX.
                //

                if (((PciHeader.VendorID == 0x8086) &&
                     (PciHeader.DeviceID == 0x7190 ||
                      PciHeader.DeviceID == 0x7192) &&
                     (PciHeader.RevisionID <= 2))) {

                    i440BXpresent = TRUE;

                    BytesRead = HalGetBusDataByOffset (
                                    PCIConfiguration,
                                    BusNumber,
                                    SlotNumber.u.AsULONG,
                                    &DramControl,
                                    0x57,
                                    1
                                    );

                    ASSERT(BytesRead == 1);

                    if (DramControl & 0x18) {

                        //
                        // This machine is using SDRAM or Registered SDRAM.
                        //

                        if (DramControl & 0x20) {

                            //
                            // SDRAM dynamic power down unavailable.
                            //

                            HalpBroken440BX = TRUE;
                        }
                    }
                }

                Status = HalpGetChipHacks(PciHeader.VendorID,
                                          PciHeader.DeviceID,
                                          PciHeader.RevisionID,
                                          &flags);

                if (NT_SUCCESS(Status)) {

                    if (flags & PM_TIMER_HACK_FLAG) {
                        HalpBrokenAcpiTimer = TRUE;
                    }

                    if (flags & DISABLE_HIBERNATE_HACK_FLAG) {
                        HalpDisableHibernate = TRUE;
                    }

#if !defined(APIC_HAL)
                    if (flags & SET_ACPI_IRQSTACK_HACK_FLAG) {
                        HalpSetAcpiIrqHack(2); // AcpiIrqDistributionDispositionStackUp
                    }
#endif
                    if (flags & WHACK_ICH_USB_SMI_HACK_FLAG) {
                        HalpWhackICHUsbSmi(BusNumber, SlotNumber);
                    }
                }
            }

            //
            // Look for PIIX4.
            //

            if (PciHeader.VendorID == 0x8086 && PciHeader.DeviceID == 0x7110) {

                //
                // Get the power management function
                //

                SlotNumber.u.bits.FunctionNumber = 3;
                HalGetBusData (
                    PCIConfiguration,
                    BusNumber,
                    SlotNumber.u.AsULONG,
                    &PciHeader,
                    PCI_COMMON_HDR_LENGTH
                    );

                ASSERT(PciHeader.RevisionID != 0);

                HalpPiix4 = PciHeader.RevisionID;
                        HalpBrokenAcpiTimer = TRUE;

                //
                // If this is an original piix4, then it has thermal joined
                // with C2&C3&Throttle clock stopping.
                //

                if (PciHeader.RevisionID <= 1) {

                    //
                    // This piix4 needs some help - remember where it is and
                    // set the HalpPiix4 flag
                    //

                    HalpPiix4BusNumber = BusNumber;
                    HalpPiix4SlotNumber = SlotNumber.u.AsULONG;

                    //
                    // Does not work MP
                    //

                    // ASSERT (KeNumberProcessors == 1);

                    //
                    // Read the DevActB register and set all IRQs to be break events
                    //

                    HalGetBusDataByOffset (
                        PCIConfiguration,
                        HalpPiix4BusNumber,
                        HalpPiix4SlotNumber,
                        &HalpPiix4DevActB,
                        0x58,
                        sizeof(ULONG)
                        );

                    HalpPiix4DevActB |= 0x23;

                    HalSetBusDataByOffset (
                        PCIConfiguration,
                        HalpPiix4BusNumber,
                        HalpPiix4SlotNumber,
                        &HalpPiix4DevActB,
                        0x58,
                        sizeof(ULONG)
                        );
                }

                //
                // Shut off the interrupt for the USB controller.
                //

                SlotNumber.u.bits.FunctionNumber = 2;

                HalpStopUhciInterrupt(BusNumber,
                                      SlotNumber,
                                      TRUE);

                // piix4 was found, we're done
                goto Piix4DetectEnd;
            }

            //
            // Look for ICH, or any other Intel or VIA UHCI USB controller.
            //

            if ((PciHeader.BaseClass == PCI_CLASS_SERIAL_BUS_CTLR) &&
                (PciHeader.SubClass == PCI_SUBCLASS_SB_USB) &&
                (PciHeader.ProgIf == 0x00)) {
                if (PciHeader.VendorID == 0x8086) {

                    HalpStopUhciInterrupt(BusNumber,
                                          SlotNumber,
                                          TRUE);

                } else if (PciHeader.VendorID == 0x1106) {

                    HalpStopUhciInterrupt(BusNumber,
                                          SlotNumber,
                                          FALSE);

                }
            }

            //
            // Look for an OHCI-compliant USB controller.
            //

            if ((PciHeader.BaseClass == PCI_CLASS_SERIAL_BUS_CTLR) &&
                (PciHeader.SubClass == PCI_SUBCLASS_SB_USB) &&
                (PciHeader.ProgIf == 0x10)) {

                HalpStopOhciInterrupt(BusNumber,
                                      SlotNumber);
            }

            if ((FuncNumber == 0) &&
                !PCI_MULTIFUNCTION_DEVICE((&PciHeader))) {
                break;
            }

            } // func number
        }   // device number
    }   // bus number

Piix4DetectEnd:

    if (!DuringBoot) {
        return;
    }

    if (Handle) {
        ZwClose (Handle);
        Handle = NULL;
    }

    if (i440BXpresent) {

        // Get the right key

        RtlInitUnicodeString (&UnicodeString,
                              L"Services\\ACPI\\Parameters");

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   BaseHandle,
                                   (PSECURITY_DESCRIPTOR) NULL);

        Status = ZwCreateKey (&Handle,
                              KEY_READ,
                              &ObjectAttributes,
                              0,
                              (PUNICODE_STRING) NULL,
                              REG_OPTION_NON_VOLATILE,
                              &disposition);

        if(!NT_SUCCESS(Status)) {
            goto Piix4DetectCleanup;
        }

        // Get the value of the hack

        RtlInitUnicodeString (&UnicodeString,
                              L"EnableBXWorkAround");

        Status = ZwQueryValueKey (Handle,
                                  &UnicodeString,
                                  KeyValuePartialInformation,
                                  &PartialInformation,
                                  sizeof (PartialInformation),
                                  &Length);

        if (!NT_SUCCESS(Status)) {
            goto Piix4DetectCleanup;
        }

        // Check to make sure the retrieved data makes sense

        if(PartialInformation.Inf.DataLength < sizeof(UCHAR))
        {
           goto Piix4DetectCleanup;
        }

        HalpBroken440BX = *((PCHAR)(PartialInformation.Inf.Data));
    }

Piix4DetectCleanup:

    if (Handle) ZwClose (Handle);
    if (BaseHandle) ZwClose (BaseHandle);
}

VOID
HalpInitBootTable (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    UCHAR BootRegisterValue;

    HalpSimpleBootFlagTable = (PBOOT_TABLE)HalpGetAcpiTablePhase0(LoaderBlock, BOOT_SIGNATURE);

    //
    // We also verify that the CMOS index of the flag offset is >9 to catch those
    // BIOSes (Toshiba) which mistakenly use the time and date fields to store their
    // simple boot flag.
    //

    if ( HalpSimpleBootFlagTable &&
        (HalpSimpleBootFlagTable->Header.Length >= sizeof(BOOT_TABLE)) &&
        (HalpSimpleBootFlagTable->CMOSIndex > 9)) {

        if ( HalReadBootRegister (&BootRegisterValue) == STATUS_SUCCESS ) {

            if ( !(BootRegisterValue & SBF_PNPOS) ) {
                BootRegisterValue |= SBF_PNPOS;
                HalWriteBootRegister (BootRegisterValue);
            }
        }

    } else {

        HalpSimpleBootFlagTable = NULL;
    }

    HalEndOfBoot = HalpEndOfBoot;
}

NTSTATUS
HalReadBootRegister(
    PUCHAR BootRegisterValue
    )
/*++

Routine Description:

Arguments:

Note:

--*/
{
    if (!HalpSimpleBootFlagTable ||
        (HalpSimpleBootFlagTable->CMOSIndex == 0xFFFFFFFF)) return STATUS_NO_SUCH_DEVICE;

    if (!BootRegisterValue) return STATUS_INVALID_PARAMETER;

    HalpGetCmosData (0, HalpSimpleBootFlagTable->CMOSIndex, (PVOID)BootRegisterValue, 1);

    return STATUS_SUCCESS;
}

NTSTATUS
HalWriteBootRegister(
    UCHAR BootRegisterValue
    )
/*++

Routine Description:

Arguments:

Note:

--*/
{
    UCHAR numbits = 0, mask = 1;

    if (!HalpSimpleBootFlagTable ||
        (HalpSimpleBootFlagTable->CMOSIndex == 0xFFFFFFFF)) return STATUS_NO_SUCH_DEVICE;

    for (mask = 1;mask < 128;mask <<= 1) {

        if (BootRegisterValue & mask) numbits++;

    }

    if ( !(numbits & 1) ) {

        BootRegisterValue |= SBF_PARITY;
    }
    else {

        BootRegisterValue &= (~SBF_PARITY);
    }

    HalpSetCmosData (0, HalpSimpleBootFlagTable->CMOSIndex, (PVOID)&BootRegisterValue, 1);

    return STATUS_SUCCESS;
}

VOID
HalpEndOfBoot(
    VOID
    )
/*++

Routine Description:

Arguments:

Note:

--*/
{
    HalpResetSBF();
}

VOID
HalpResetSBF(
    VOID
    )
{
    UCHAR value;

    if (!HalpSimpleBootFlagTable) {
        //
        // No SBF in this machine.
        //
        return;
    }

    if ( HalReadBootRegister (&value) == STATUS_SUCCESS ) {

        value &=(~(SBF_BOOTING | SBF_DIAG));
        HalWriteBootRegister (value);
    }
}

VOID
HalpPutAcpiHacksInRegistry(
    VOID
    )
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      UnicodeString;
    HANDLE              BaseHandle = NULL;
    HANDLE              Handle = NULL;
    ULONG               disposition;
    ULONG               value;
    NTSTATUS            status;

    PAGED_CODE();

    //
    // Open PCI service key.
    //

    RtlInitUnicodeString (&UnicodeString,
                          L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\Control\\HAL");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey (&BaseHandle,
                        KEY_READ,
                        &ObjectAttributes);

    if (!NT_SUCCESS(status)) {
        return;
    }

    // Get the right key

    RtlInitUnicodeString (&UnicodeString,
                          L"CStateHacks");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               BaseHandle,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwCreateKey (&Handle,
                          KEY_READ,
                          &ObjectAttributes,
                          0,
                          (PUNICODE_STRING) NULL,
                          REG_OPTION_VOLATILE,
                          &disposition);

    ZwClose(BaseHandle);

    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Create keys for each of the hacks.
    //

    value = (ULONG)HalpPiix4;

    RtlInitUnicodeString (&UnicodeString,
                          L"Piix4");

    status = ZwSetValueKey (Handle,
                            &UnicodeString,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof(ULONG));

    //ASSERT(NT_SUCCESS(status));

    value = (ULONG)HalpBroken440BX;

    RtlInitUnicodeString (&UnicodeString,
                          L"440BX");

    status = ZwSetValueKey (Handle,
                            &UnicodeString,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof(ULONG));

    //ASSERT(NT_SUCCESS(status));

#if !defined(_WIN64)

    value = (ULONG)&HalpOutstandingScatterGatherCount;

    RtlInitUnicodeString (&UnicodeString,
                          L"SGCount");

    status = ZwSetValueKey (Handle,
                            &UnicodeString,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof(ULONG));

    //ASSERT(NT_SUCCESS(status));

#endif

    value = HalpPiix4SlotNumber | (HalpPiix4BusNumber << 16);

    RtlInitUnicodeString (&UnicodeString,
                          L"Piix4Slot");

    status = ZwSetValueKey (Handle,
                            &UnicodeString,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof(ULONG));

    //ASSERT(NT_SUCCESS(status));

    value = HalpPiix4DevActB;

    RtlInitUnicodeString (&UnicodeString,
                          L"Piix4DevActB");

    status = ZwSetValueKey (Handle,
                            &UnicodeString,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof(ULONG));

    //ASSERT(NT_SUCCESS(status));

    ZwClose(Handle);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\xxacpi.h ===
;/*++
;
; Copyright (c) 1997  Microsoft Corporation
;
; Module Name:
;
;   xxacpi.h
;
; Abstract:
;
;
;   This module contains definitions specific to the HAL's
;   ACPI function.
;
; Author:
;
;   Jake Oshins (jakeo) Feb. 18, 1997
;
; Revision History:
;
;-

if 0        ; Begin C only code         */

#if !defined(_XXACPI_H_)
#define __XACPI_H_

#include "eisa.h"
#include "ntacpi.h"
#include "acpi_mp.inc"

//
// General ACPI structures
//
typedef struct {
    BOOLEAN     GeneralWakeupEnable;
    BOOLEAN     RtcWakeupEnable;
    TIME_FIELDS RtcWakeupTime;
} HAL_WAKEUP_STATE, *PHAL_WAKEUP_STATE;


ULONG
HalpBuildTiledCR3 (
    IN PKPROCESSOR_STATE    ProcessorState
    );

VOID
HalpFreeTiledCR3 (
    VOID
    );

#if defined(_AMD64_)

ULONG
HalpBuildCr3Identity (VOID);

#endif

//
// internal prototypes
//
PVOID
HalpGetAcpiTablePhase0(
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN  ULONG   Signature
    );

BOOLEAN
HalpAcpiPreSleep(
    SLEEP_STATE_CONTEXT Context
    );

NTSTATUS
HaliAcpiSleep(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    );

BOOLEAN
HalpAcpiPostSleep(
    ULONG Context
    );

NTSTATUS
HaliSetWakeAlarm (
	IN ULONGLONG	WakeSystemTime,
	IN PTIME_FIELDS	WakeTimeFields OPTIONAL
	);

NTSTATUS
HalpSetWakeAlarm (
	IN ULONGLONG	WakeSystemTime,
	IN PTIME_FIELDS	WakeTimeFields OPTIONAL
	);

VOID
HaliSetWakeEnable(
	IN BOOLEAN	Enable
	);

VOID
HalpSleepGetProcState(
    IN OUT PKPROCESSOR_STATE ProcState
    );

BOOLEAN
HalpAcpiPicStateIntact(
    VOID
    );

ULONG
HalpGetApicVersion(
    ULONG ApicNo
    );

VOID
HalpResetSBF(
    VOID
    );

//
// The kernel leaves some space (64 byte) of the PCR for the HAL to use
// as it needs.
//

typedef struct {
    ULONG   Reserved1;  // this space is used by APIC stuff (see pcmp_nt.inc)
    union {
        ULONG       AddrAndFlags;
        struct {
            USHORT  Addr;
            UCHAR   Flags;
            UCHAR   Spare1;
        } ;
    } PBlk;
} HALPMPRCB, *PHALPMPRCB;

//
// Global HAL-ACPI stuff
//
extern FADT HalpFixedAcpiDescTable;
extern PDEBUG_PORT_TABLE HalpDebugPortTable;
extern BOOLEAN HalpProcessedACPIPhase0;
extern HAL_WAKEUP_STATE HalpWakeupState;
extern ULONG HalpThrottleScale;
extern SLEEP_STATE_CONTEXT HalpSleepContext;
extern KPROCESSOR_STATE    HalpSleepProcState;
extern PHYSICAL_ADDRESS    HalpTiledCR3Address;

extern UCHAR   HalpBrokenAcpiTimer;

extern UCHAR   HalpPiix4;
extern ULONG   HalpPiix4BusNumber;
extern ULONG   HalpPiix4SlotNumber;
extern ULONG   HalpPiix4DevActB;

extern BOOLEAN HalpBroken440BX;

extern PUCHAR  HalpLowStub;
extern PVOID   HalpLowStubPhysicalAddress;
extern PVOID   HalpWakeVector;
extern PVOID   HalpVirtAddrForFlush;
extern PVOID   HalpPteForFlush;
extern BOOLEAN HalpCr4Exists;

extern MP_INFO HalpMpInfoTable;
extern PMAPIC  HalpApicTable;
extern PBOOT_TABLE HalpSimpleBootFlagTable;


#define PIIX4_THROTTLE_FIX  0x10000

#endif // _XXACPI_H_

/*
endif
;
;  Begin assembly part of the definitions
;

include ntacpi.h

;
; The kernel leaves some space (64 byte) of the PCR for the HAL to use
; as it needs.
;

PrcbE struc
    Reserved1           dd      1       ; used in APIC HAL
    PcrPblk             dd      0       ; PBlk and flags
PrcbE ends

PIIX4_THROTTLE_FIX  EQU 10000h

;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\xxflshbf.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxflshbf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\xxdisp.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxdisp.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\xxhal.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxhal.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\xxstubs.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxstubs.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\xxmemory.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxmemory.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\xxtime.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxtime.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\xxtimer.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    xxtimer.h

Abstract:

    This module contains definitions used by the HAL's timer-related 
    functions

Author:

    Eric Nelson (enelson) July 7, 2000

Revision History:

--*/

#ifndef __XXTIMER_H__
#define __XXTIMER_H__

typedef
ULONG
(*PSTE_ROUTINE)( // (S)et (T)ime (I)ncrement
    IN ULONG DesiredIncrement
    );

typedef
VOID
(*PSEP_ROUTINE)( // (S)tall (E)xecution (P)rocessor
    IN ULONG Microseconds
    );

typedef
VOID
(*PCPC_ROUTINE)( // (C)alibrate (P)erformance (C)ounter
    IN LONG volatile *Number,
    IN ULONGLONG NewCount
    );

typedef
LARGE_INTEGER
(*PQPC_ROUTINE)( // (Q)uery (P)erformance (C)ounter
   OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
   );

typedef struct _TIMER_FUNCTIONS {
    PSEP_ROUTINE StallExecProc;
    PCPC_ROUTINE CalibratePerfCount;
    PQPC_ROUTINE QueryPerfCount;
    PSTE_ROUTINE SetTimeIncrement;
} TIMER_FUNCTIONS, *PTIMER_FUNCTIONS;

VOID
HalpSetTimerFunctions(
    IN PTIMER_FUNCTIONS TimerFunctions
    );

#endif // __XXTIMER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\xxtimer.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    xxtimer.c

Abstract:

    This module contains the HAL's timer-related APIs

Author:

    Eric Nelson (enelson) July 6, 2000

Revision History:

--*/

#include "halp.h"
#include "xxtimer.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpSetTimerFunctions)
#endif

//
// External function prototypes
//
ULONG
HalpAcpiTimerSetTimeIncrement(
    IN ULONG DesiredIncrement
    );

VOID
HalpAcpiTimerStallExecProc(
    IN ULONG MicroSeconds
    );

VOID
HalpAcpiTimerCalibratePerfCount(
    IN LONG volatile *Number,
    IN ULONGLONG NewCount
    );
VOID
HalpPmTimerCalibratePerfCount(
    IN LONG volatile *Number,
    IN ULONGLONG NewCount
    );

LARGE_INTEGER
HalpAcpiTimerQueryPerfCount(
   OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
   );

LARGE_INTEGER
HalpPmTimerQueryPerfCount(
   OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
   );

//
// Local variables
//
static TIMER_FUNCTIONS HalpTimerFunctions = { HalpAcpiTimerStallExecProc,
#ifdef NO_PM_KEQPC
                                              HalpAcpiTimerCalibratePerfCount,
                                              HalpAcpiTimerQueryPerfCount,
#else
                                              HalpPmTimerCalibratePerfCount,
                                              HalpPmTimerQueryPerfCount,
#endif
                                              HalpAcpiTimerSetTimeIncrement };


VOID
HalpSetTimerFunctions(
    IN PTIMER_FUNCTIONS TimerFunctions
    )
/*++

Routine Description:

    This routine can be used to override the HALs ACPI-timer functions with
    multimedia event timer functions

Arguments:

    TimerFunctions - Pointer to a table of timer functions

Return Value:

    None

--*/
{
    HalpTimerFunctions = *TimerFunctions;

#if 1
    HalpTimerFunctions.SetTimeIncrement = HalpAcpiTimerSetTimeIncrement;
#endif
}


ULONG
HalSetTimeIncrement(
    IN ULONG DesiredIncrement
    )
/*++

Routine Description:

    This routine initialize system time clock to generate an
    interrupt at every DesiredIncrement interval

Arguments:

     DesiredIncrement - Desired interval between every timer tick (in
                        100ns unit)

Return Value:

     The *REAL* time increment set

--*/
{
    return (HalpTimerFunctions.SetTimeIncrement)(DesiredIncrement);
}


VOID
HalCalibratePerformanceCounter(
    IN LONG volatile *Number,
    IN ULONGLONG NewCount
    )
/*++

Routine Description:

    This routine resets the performance counter value for the current
    processor to zero, the reset is done such that the resulting value
    is closely synchronized with other processors in the configuration

Arguments:

    Number - Supplies a pointer to count of the number of processors in
             the configuration

    NewCount - Supplies the value to synchronize the counter too

Return Value:

    None

--*/
{
    (HalpTimerFunctions.CalibratePerfCount)(Number, NewCount);
}


#ifdef TIMER_DBG
static ULONG HalpQueryPerfLogIndex = 0;
#define MAX_QUERY_LOG 10
static LARGE_INTEGER HalpQueryPerfLog[MAX_QUERY_LOG];
static LARGE_INTEGER HalpQueryPerfTSLog[MAX_QUERY_LOG];
#endif


LARGE_INTEGER
KeQueryPerformanceCounter(
   OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
   )
/*++

Routine Description:

    This routine returns current 64-bit performance counter and,
    optionally, the Performance Frequency

    N.B. The performace counter returned by this routine is
    not necessary the value when this routine is just entered,
    The value returned is actually the counter value at any point
    between the routine is entered and is exited

Arguments:

    PerformanceFrequency - optionally, supplies the address of a
                           variable to receive the performance counter
                           frequency

Return Value:

    Current value of the performance counter will be returned

--*/
{
#ifdef TIMER_DBG
    ULONG Index;
    ULONG TSCounterHigh;
    ULONG TSCounterLow;
    KIRQL Irql;
    ULONG flags;
    extern BOOLEAN HalInitialized;

    _asm {
        pushfd
        pop     eax
        mov     flags, eax
        cli
    }

    Index = HalpQueryPerfLogIndex % MAX_QUERY_LOG;
    HalpQueryPerfLogIndex++;

    HalpQueryPerfLog[Index] =
        (HalpTimerFunctions.QueryPerfCount)(PerformanceFrequency);
    
   _asm { rdtsc
           mov TSCounterLow, eax
           mov TSCounterHigh, edx };

    HalpQueryPerfTSLog[Index].HighPart = TSCounterHigh;
    HalpQueryPerfTSLog[Index].LowPart = TSCounterLow;

    if (HalInitialized) {
        ULONG PriorIndex;

        PriorIndex = (Index == 0) ? MAX_QUERY_LOG - 1: Index - 1;

        if (HalpQueryPerfLog[Index].QuadPart <
            HalpQueryPerfLog[PriorIndex].QuadPart) {
           
            ASSERT(FALSE);
        }
    }

    _asm {
        mov  eax, flags
        push eax
        popfd
    }
    
    return HalpQueryPerfLog[Index];

#else
    return (HalpTimerFunctions.QueryPerfCount)(PerformanceFrequency);
#endif
}


VOID
KeStallExecutionProcessor(
   IN ULONG MicroSeconds
   )
/*++

Routine Description:

    This function stalls execution for the specified number of microseconds

Arguments:

    MicroSeconds - Supplies the number of microseconds that execution is to be
                   stalled

 Return Value:

    None

--*/
{
    (HalpTimerFunctions.StallExecProc)(MicroSeconds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\amd64.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    amd64.h

Abstract:

    This module contains function prototypes, declarations used by the 
    profiling functions for the Amd64 platform

Author:

    Steve Deng (sdeng) 18-Jun-2002

Environment:

    Kernel mode only.

--*/

#ifndef _AMD64_H_
#define _AMD64_H_

//
// Defines the attributes of counter registers
//

#define AMD64_NUMBER_COUNTERS 4     // number of performance counters
#define AMD64_COUNTER_RESOLUTION 48 // resolution of performance counters

//
// Define constants for bits in PerfEvtSel register
//

#define EVENT_MASK(i) (i)
#define UNIT_MASK(i) ((i) << 8)

#define PERF_EVT_SEL_USER_COUNT   (1 << 16)
#define PERF_EVT_SEL_OS_COUNT     (1 << 17)
#define PERF_EVT_SEL_EDGE_DETECT  (1 << 18)
#define PERF_EVT_SEL_PIN_CONTROL  (1 << 19)
#define PERF_EVT_SEL_INTERRUPT    (1 << 20)
#define PERF_EVT_SEL_ENABLE       (1 << 22)
#define PERF_EVT_SEL_INVERT       (1 << 23)
#define PERF_EVT_SEL_COUNTER_MASK (0xf << 24)

#define DEFAULT_METHOD ( PERF_EVT_SEL_USER_COUNT  |  \
                         PERF_EVT_SEL_OS_COUNT    &  \
                        ~PERF_EVT_SEL_EDGE_DETECT &  \
                        ~PERF_EVT_SEL_PIN_CONTROL &  \
                        ~PERF_EVT_SEL_INTERRUPT   &  \
                        ~PERF_EVT_SEL_INVERT      &  \
                        ~PERF_EVT_SEL_COUNTER_MASK )
//
// Some events are not supported in Rev A silicon but will be available in
// Rev B. We temporarily mark these events as not supported.
//

#define NOT_SUPPORTED_IN_K8_REVA FALSE

//
// The data in this structure describes the the hardware aspects of
// profile sources
//

typedef struct _AMD64_PROFILE_SOURCE_DESCRIPTOR {   
    KPROFILE_SOURCE ProfileSource;  // Profile source
    BOOLEAN     Supported;          // Is it supported
    ULONGLONG   Interval;           // Current Interval
    ULONGLONG   DefInterval;        // Default or Desired Interval
    ULONGLONG   MaxInterval;        // Maximum Interval
    ULONGLONG   MinInterval;        // Maximum Interval
    ULONG       PerfEvtSelDef;      // Default value of PerfEvtSel register
    PWSTR       Description;        // Mnemonic event name
} AMD64_PROFILE_SOURCE_DESCRIPTOR, *PAMD64_PROFILE_SOURCE_DESCRIPTOR;
    
#define AMD64_PROFILE_MINIMUM  (ProfileMaximum + 1)
typedef enum _AMD64_PROFILE_LIST {
    ProfileAmd64Minimum         = AMD64_PROFILE_MINIMUM,
    ProfileFPDispatchedFPUOps   = AMD64_PROFILE_MINIMUM,
    ProfileFPDispatchedFPUOpsAddExcludeJunk, 
    ProfileFPDispatchedFPUOpsMulExcludeJunk,   
    ProfileFPDispatchedFPUOpsStoreExcludeJunk,   
    ProfileFPDispatchedFPUOpsAddJunk,
    ProfileFPDispatchedFPUOpsMulJunk,   
    ProfileFPDispatchedFPUOpsStoreJunk,   
    ProfileFPCyclesNoFPUOpsRetired,
    ProfileFPDispathedFPUOpsWithFastFlag,
    ProfileLSSegmentRegisterLoad,
    ProfileLSSegmentRegisterLoadES,
    ProfileLSSegmentRegisterLoadCS,
    ProfileLSSegmentRegisterLoadSS,
    ProfileLSSegmentRegisterLoadDS,
    ProfileLSSegmentRegisterLoadFS,
    ProfileLSSegmentRegisterLoadGS,
    ProfileLSSegmentRegisterLoadHS,
    ProfileLSResyncBySelfModifyingCode,
    ProfileLSResyncBySnoop,
    ProfileLSBuffer2Full,
    ProfileLSLockedOperation,
    ProfileLSLateCancelOperation,
    ProfileLSRetiredCFLUSH,
    ProfileLSRetiredCPUID,
    ProfileDCAccess,
    ProfileDCMiss,
    ProfileDCRefillFromL2,
    ProfileDCRefillFromL2Invalid,
    ProfileDCRefillFromL2Shared,
    ProfileDCRefillFromL2Exclusive,
    ProfileDCRefillFromL2Owner,
    ProfileDCRefillFromL2Modified,
    ProfileDCRefillFromSystem,
    ProfileDCRefillFromSystemInvalid,
    ProfileDCRefillFromSystemShared,
    ProfileDCRefillFromSystemExclusive,
    ProfileDCRefillFromSystemOwner,
    ProfileDCRefillFromSystemModified,
    ProfileDCRefillCopyBack,
    ProfileDCRefillCopyBackInvalid,
    ProfileDCRefillCopyBackShared,
    ProfileDCRefillCopyBackExclusive,
    ProfileDCRefillCopyBackOwner,
    ProfileDCRefillCopyBackModified,
    ProfileDCL1DTLBMissL2DTLBHit,
    ProfileDCL1DTLBMissL2DTLBMiss,
    ProfileDCMisalignedDataReference,
    ProfileDCLateCancelOfAnAccess,
    ProfileDCEarlyCancelOfAnAccess,
    ProfileDCOneBitECCError,
    ProfileDCOneBitECCErrorScrubberError,
    ProfileDCOneBitECCErrorPiggybackScrubberError,
    ProfileDCDispatchedPrefetchInstructions,
    ProfileDCDispatchedPrefetchInstructionsLoad,
    ProfileDCDispatchedPrefetchInstructionsStore,
    ProfileDCDispatchedPrefetchInstructionsNTA,
    ProfileBUInternalL2Request,
    ProfileBUInternalL2RequestICFill,
    ProfileBUInternalL2RequestDCFill,
    ProfileBUInternalL2RequestTLBReload,
    ProfileBUInternalL2RequestTagSnoopRequest,
    ProfileBUInternalL2RequestCancelledRequest,
    ProfileBUFillRequestMissedInL2,
    ProfileBUFillRequestMissedInL2ICFill,
    ProfileBUFillRequestMissedInL2DCFill,
    ProfileBUFillRequestMissedInL2TLBLoad,
    ProfileBUFillIntoL2,
    ProfileBUFillIntoL2DirtyL2Victim,
    ProfileBUFillIntoL2VictimFromL1,
    ProfileICFetch,
    ProfileICMiss,
    ProfileICRefillFromL2,
    ProfileICRefillFromSystem,
    ProfileICL1TLBMissL2TLBHit,
    ProfileICL1TLBMissL2TLBMiss,
    ProfileICResyncBySnoop,
    ProfileICInstructionFetchStall,
    ProfileICReturnStackHit,
    ProfileICReturnStackOverflow,
    ProfileFRRetiredx86Instructions,
    ProfileFRRetireduops,
    ProfileFRRetiredBranches,
    ProfileFRRetiredBranchesMispredicted,
    ProfileFRRetiredTakenBranches,
    ProfileFRRetiredTakenBranchesMispredicted,
    ProfileFRRetiredFarControlTransfers,
    ProfileFRRetiredResyncsNonControlTransferBranches,
    ProfileFRRetiredNearReturns,
    ProfileFRRetiredNearReturnsMispredicted,
    ProfileFRRetiredTakenBranchesMispredictedByAddressMiscompare,
    ProfileFRRetiredFPUInstructions,
    ProfileFRRetiredFPUInstructionsx87,
    ProfileFRRetiredFPUInstructionsMMXAnd3DNow,
    ProfileFRRetiredFPUInstructionsPackedSSEAndSSE2,
    ProfileFRRetiredFPUInstructionsScalarSSEAndSSE2,
    ProfileFRRetiredFastpathDoubleOpInstructions,
    ProfileFRRetiredFastpathDoubleOpInstructionsLowOpInPosition0,
    ProfileFRRetiredFastpathDoubleOpInstructionsLowOpInPosition1,
    ProfileFRRetiredFastpathDoubleOpInstructionsLowOpInPosition2,
    ProfileFRInterruptsMaskedCycles,
    ProfileFRInterruptsMaskedWhilePendingCycles,
    ProfileFRTakenHardwareInterrupts,
    ProfileFRNothingToDispatch,
    ProfileFRDispatchStalls,
    ProfileFRDispatchStallsFromBranchAbortToRetire,
    ProfileFRDispatchStallsForSerialization,
    ProfileFRDispatchStallsForSegmentLoad,
    ProfileFRDispatchStallsWhenReorderBufferFull,
    ProfileFRDispatchStallsWhenReservationStationsFull,
    ProfileFRDispatchStallsWhenFPUFull,
    ProfileFRDispatchStallsWhenLSFull,
    ProfileFRDispatchStallsWhenWaitingForAllQuiet,
    ProfileFRDispatchStallsWhenFarControlOrResyncBranchPending,
    ProfileFRFPUExceptions,
    ProfileFRFPUExceptionsx87ReclassMicroFaults,
    ProfileFRFPUExceptionsSSERetypeMicroFaults,
    ProfileFRFPUExceptionsSSEReclassMicroFaults,
    ProfileFRFPUExceptionsSSEAndx87MicroTraps,
    ProfileFRNumberOfBreakPointsForDR0,
    ProfileFRNumberOfBreakPointsForDR1,
    ProfileFRNumberOfBreakPointsForDR2,
    ProfileFRNumberOfBreakPointsForDR3,
    ProfileNBMemoryControllerPageAccessEvent,
    ProfileNBMemoryControllerPageAccessEventPageHit,
    ProfileNBMemoryControllerPageAccessEventPageMiss,
    ProfileNBMemoryControllerPageAccessEventPageConflict,
    ProfileNBMemoryControllerPageTableOverflow,
    ProfileNBMemoryControllerDRAMCommandSlotsMissed,
    ProfileNBMemoryControllerTurnAround,
    ProfileNBMemoryControllerTurnAroundDIMM,
    ProfileNBMemoryControllerTurnAroundReadToWrite,
    ProfileNBMemoryControllerTurnAroundWriteToRead,
    ProfileNBMemoryControllerBypassCounter,
    ProfileNBMemoryControllerBypassCounterHighPriority,
    ProfileNBMemoryControllerBypassCounterLowPriority,
    ProfileNBMemoryControllerBypassCounterDRAMControllerInterface,
    ProfileNBMemoryControllerBypassCounterDRAMControllerQueue,
    ProfileNBSizedCommands,
    ProfileNBSizedCommandsNonPostWrSzByte,
    ProfileNBSizedCommandsNonPostWrSzDword,
    ProfileNBSizedCommandsWrSzByte,
    ProfileNBSizedCommandsWrSzDword,
    ProfileNBSizedCommandsRdSzByte,
    ProfileNBSizedCommandsRdSzDword,
    ProfileNBSizedCommandsRdModWr,
    ProfileNBProbeResult,
    ProfileNBProbeResultMiss,
    ProfileNBProbeResultHit,
    ProfileNBProbeResultHitDirtyWithoutMemoryCancel,
    ProfileNBProbeResultHitDirtyWithMemoryCancel,
    ProfileNBHyperTransportBus0Bandwidth,
    ProfileNBHyperTransportBus0BandwidthCommandSent,
    ProfileNBHyperTransportBus0BandwidthDataSent,
    ProfileNBHyperTransportBus0BandwidthBufferReleaseSent,
    ProfileNBHyperTransportBus0BandwidthNopSent,
    ProfileNBHyperTransportBus1Bandwidth,
    ProfileNBHyperTransportBus1BandwidthCommandSent,
    ProfileNBHyperTransportBus1BandwidthDataSent,
    ProfileNBHyperTransportBus1BandwidthBufferReleaseSent,
    ProfileNBHyperTransportBus1BandwidthNopSent,
    ProfileNBHyperTransportBus2Bandwidth,
    ProfileNBHyperTransportBus2BandwidthCommandSent,
    ProfileNBHyperTransportBus2BandwidthDataSent,
    ProfileNBHyperTransportBus2BandwidthBufferReleaseSent,
    ProfileNBHyperTransportBus2BandwidthNopSent,
    ProfileAmd64Maximum
} AMD64_PROFILE_LIST;

AMD64_PROFILE_SOURCE_DESCRIPTOR
Amd64ProfileSourceDescriptorTable[ProfileAmd64Maximum - 
                                  ProfileAmd64Minimum + 
                                  ProfileMaximum] = {
    { 
        ProfileTime,
        TRUE,
        TIME_UNITS_PER_SECOND,
        TIME_UNITS_PER_SECOND,
        TIME_UNITS_PER_SECOND,
        1221,
        0,
        L"Timer"
    },
    { 
        ProfileAlignmentFixup,
        FALSE,
        0,
        0,
        0,
        0,
        0,
        L"AlignmentFixup"
    },
    { 
        ProfileTotalIssues,         // Same as ProfileFRRetiredx86Instructions
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xc0) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"TotalIssues"
    },
    { 
        ProfilePipelineDry,
        FALSE,
        0,
        0,
        0,
        0,
        0,
        L"PipelineDry"
    },
    { 
        ProfileLoadInstructions,
        FALSE,
        0,
        0,
        0,
        0,
        0,
        L"LoadInstructions"
    },
    { 
        ProfilePipelineFrozen,
        FALSE,
        0,
        0,
        0,
        0,
        0,
        L"PipelineFrozen"
    },
    { 
        ProfileBranchInstructions,  // Same as ProfileFRRetiredBranches
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xc2) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"BranchInstructions"
    },
    { 
        ProfileTotalNonissues,
        FALSE,
        0,
        0,
        0,
        0,
        0,
        L"TotalNonissues"
    },
    { 
        ProfileDcacheMisses,        // Same as ProfileDCMiss
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x41) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"DcacheMisses"
    },
    { 
        ProfileIcacheMisses,        // Same as ProfileICMiss
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x81) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"IcacheMisses"
    },
    { 
        ProfileCacheMisses,
        FALSE,
        0,
        0,
        0,
        0,
        0,
        L"CacheMisses"
    },
    { 
        ProfileBranchMispredictions, // Same as ProfileFRRetiredBranchesMispredicted
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xc3) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"BranchMispredictions"
    },
    { 
        ProfileStoreInstructions,
        FALSE,
        0,
        0,
        0,
        0,
        0,
        L"StoreInstructions"
    },
    { 
        ProfileFpInstructions,       // Same as ProfileFRRetiredFPUInstructions
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xcb) | UNIT_MASK(0x0f) | DEFAULT_METHOD, 
        L"FpInstructions"
    },
    { 
        ProfileIntegerInstructions,
        FALSE,
        0,
        0,
        0,
        0,
        0,
        L"IntegerInstructions"
    },
    { 
        Profile2Issue,
        FALSE,
        0,
        0,
        0,
        0,
        0,
        L"2Issue"
    },
    { 
        Profile3Issue,
        FALSE,
        0,
        0,
        0,
        0,
        0,
        L"3Issue"
    },
    { 
        Profile4Issue,
        FALSE,
        0,
        0,
        0,
        0,
        0,
        L"4Issue"
    },
    { 
        ProfileSpecialInstructions,
        FALSE,
        0,
        0,
        0,
        0,
        0,
        L"SpecialInstructions"
    },
    { 
        ProfileTotalCycles,
        FALSE,
        0,
        0,
        0,
        0,
        0,
        L"TotalCycles"
    },
    { 
        ProfileIcacheIssues,            // Same as ProfileICFetch
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x80) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"IcacheIssues"
    },
    { 
        ProfileDcacheAccesses,         // Same as ProfileDCAccess
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x40) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"DcacheAccesses"
    },
    { 
        ProfileMemoryBarrierCycles,
        FALSE,
        0,
        0,
        0,
        0,
        0,
        L"MemoryBarrierCycles"
    },
    { 
        ProfileLoadLinkedIssues,
        FALSE,
        0,
        0,
        0,
        0,
        0,
        L"LoadLinkedIssues"
    },

    //
    // End of generic profile sources. Everything below is Amd64 specific. 
    //
    // IMPORTANT NOTE: The order of the structures below should be 
    // exactly the same as the order of the the profile sources defined 
    // in _AMD64_PROFILE_LIST. The code in HalpGetProfileDescriptor 
    // relies on this assumption.
    //

    { 
        ProfileFPDispatchedFPUOps, 
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x00) | UNIT_MASK(0x3f) | DEFAULT_METHOD, 
        L"FPDispatchedFPUOps"
    },
    { 
        ProfileFPDispatchedFPUOpsAddExcludeJunk, 
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x00) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"FPDispatchedFPUOpsAddExcludeJunk"
    },
    { 
        ProfileFPDispatchedFPUOpsMulExcludeJunk,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x00) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"FPDispatchedFPUOpsMulExcludeJunk"
    },
    { 
        ProfileFPDispatchedFPUOpsStoreExcludeJunk,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x00) | UNIT_MASK(0x04) | DEFAULT_METHOD, 
        L"FPDispatchedFPUOpsStoreExcludeJunk"
    },
    { 
        ProfileFPDispatchedFPUOpsAddJunk, 
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x00) | UNIT_MASK(0x08) | DEFAULT_METHOD, 
        L"FPDispatchedFPUOpsAddJunk"
    },
    { 
        ProfileFPDispatchedFPUOpsMulJunk,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x00) | UNIT_MASK(0x10) | DEFAULT_METHOD, 
        L"FPDispatchedFPUOpsMulJunk"
    },
    { 
        ProfileFPDispatchedFPUOpsStoreJunk,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x00) | UNIT_MASK(0x20) | DEFAULT_METHOD, 
        L"FPDispatchedFPUOpsStoreJunk"
    },
    { 
        ProfileFPCyclesNoFPUOpsRetired,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x01) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FPCyclesNoFPUOpsRetired"
    },
    { 
        ProfileFPDispathedFPUOpsWithFastFlag,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x02) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FPDispathedFPUOpsWithFastFlag"
    },
    { 
        ProfileLSSegmentRegisterLoad,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x20) | UNIT_MASK(0x7f) | DEFAULT_METHOD, 
        L"LSSegmentRegisterLoad"
    },
    { 
        ProfileLSSegmentRegisterLoadES,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x20) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"LSSegmentRegisterLoadES"
    },
    { 
        ProfileLSSegmentRegisterLoadCS,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x20) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"LSSegmentRegisterLoadCS"
    },
    { 
        ProfileLSSegmentRegisterLoadSS,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x20) | UNIT_MASK(0x04) | DEFAULT_METHOD, 
        L"LSSegmentRegisterLoadSS"
    },
    { 
        ProfileLSSegmentRegisterLoadDS,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x20) | UNIT_MASK(0x08) | DEFAULT_METHOD, 
        L"LSSegmentRegisterLoadDS"
    },
    { 
        ProfileLSSegmentRegisterLoadFS,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x20) | UNIT_MASK(0x10) | DEFAULT_METHOD, 
        L"LSSegmentRegisterLoadFS"
    },
    { 
        ProfileLSSegmentRegisterLoadGS,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x20) | UNIT_MASK(0x20) | DEFAULT_METHOD, 
        L"LSSegmentRegisterLoadGS"
    },
    { 
        ProfileLSSegmentRegisterLoadHS,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x20) | UNIT_MASK(0x40) | DEFAULT_METHOD, 
        L"LSSegmentRegisterLoadHS"
    },
    { 
        ProfileLSResyncBySelfModifyingCode,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x21) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"LSResyncBySelfModifyingCode"
    },
    { 
        ProfileLSResyncBySnoop,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x22) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"LSResyncBySnoop"
    },
    { 
        ProfileLSBuffer2Full,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x23) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"LSBuffer2Full"
    },
    { 
        ProfileLSLockedOperation,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x24) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"LSLockedOperation"
    },
    { 
        ProfileLSLateCancelOperation,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x25) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"LSLateCancelOperation"
    },
    { 
        ProfileLSRetiredCFLUSH,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x26) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"LSRetiredCFLUSH"
    },
    { 
        ProfileLSRetiredCPUID,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x27) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"LSRetiredCPUID"
    },
    { 
        ProfileDCAccess,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x40) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"DCAccess"
    },
    { 
        ProfileDCMiss,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x41) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"DCMiss"
    },
    { 
        ProfileDCRefillFromL2,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x42) | UNIT_MASK(0x1f) | DEFAULT_METHOD, 
        L"DCRefillFromL2"
    },
    { 
        ProfileDCRefillFromL2Invalid,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x42) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"DCRefillFromL2Invalid"
    },
    { 
        ProfileDCRefillFromL2Shared,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x42) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"DCRefillFromL2Shared"
    },
    { 
        ProfileDCRefillFromL2Exclusive,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x42) | UNIT_MASK(0x04) | DEFAULT_METHOD, 
        L"DCRefillFromL2Exclusive"
    },
    { 
        ProfileDCRefillFromL2Owner,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x42) | UNIT_MASK(0x08) | DEFAULT_METHOD, 
        L"DCRefillFromL2Owner"
    },
    { 
        ProfileDCRefillFromL2Modified,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x42) | UNIT_MASK(0x10) | DEFAULT_METHOD, 
        L"DCRefillFromL2Modified"
    },
    { 
        ProfileDCRefillFromSystem,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x43) | UNIT_MASK(0x1f) | DEFAULT_METHOD, 
        L"DCRefillFromSystem"
    },
    { 
        ProfileDCRefillFromSystemInvalid,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x43) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"DCRefillFromSystemInvalid"
    },
    { 
        ProfileDCRefillFromSystemShared,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x43) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"DCRefillFromSystemShared"
    },
    { 
        ProfileDCRefillFromSystemExclusive,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x43) | UNIT_MASK(0x04) | DEFAULT_METHOD, 
        L"DCRefillFromSystemExclusive"
    },
    { 
        ProfileDCRefillFromSystemOwner,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x43) | UNIT_MASK(0x08) | DEFAULT_METHOD, 
        L"DCRefillFromSystemOwner"
    },
    { 
        ProfileDCRefillFromSystemModified,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x43) | UNIT_MASK(0x10) | DEFAULT_METHOD, 
        L"DCRefillFromSystemModified"
    },
    { 
        ProfileDCRefillCopyBack,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x44) | UNIT_MASK(0x1f) | DEFAULT_METHOD, 
        L"DCRefillCopyBack"
    },
    { 
        ProfileDCRefillCopyBackInvalid,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x44) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"DCRefillCopyBackInvalid"
    },
    { 
        ProfileDCRefillCopyBackShared,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x44) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"DCRefillCopyBackShared"
    },
    { 
        ProfileDCRefillCopyBackExclusive,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x44) | UNIT_MASK(0x04) | DEFAULT_METHOD, 
        L"DCRefillCopyBackExclusive"
    },
    { 
        ProfileDCRefillCopyBackOwner,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x44) | UNIT_MASK(0x08) | DEFAULT_METHOD, 
        L"DCRefillCopyBackOwner"
    },
    { 
        ProfileDCRefillCopyBackModified,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x44) | UNIT_MASK(0x10) | DEFAULT_METHOD, 
        L"DCRefillCopyBackModified"
    },
    { 
        ProfileDCL1DTLBMissL2DTLBHit,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x45) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"DCL1DTLBMissL2DTLBHit"
    },
    { 
        ProfileDCL1DTLBMissL2DTLBMiss,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x46) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"DCL1DTLBMissL2DTLBMiss"
    },
    { 
        ProfileDCMisalignedDataReference,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x47) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"DCMisalignedDataReference"
    },
    { 
        ProfileDCLateCancelOfAnAccess,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x48) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"DCLateCancelOfAnAccess"
    },
    { 
        ProfileDCEarlyCancelOfAnAccess,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x49) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"DCEarlyCancelOfAnAccess"
    },
    { 
        ProfileDCOneBitECCError,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x4a) | UNIT_MASK(0x03) | DEFAULT_METHOD, 
        L"DCOneBitECCError"
    },
    { 
        ProfileDCOneBitECCErrorScrubberError,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x4a) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"DCOneBitECCErrorScrubberError"
    },
    { 
        ProfileDCOneBitECCErrorPiggybackScrubberError,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x4a) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"DCOneBitECCErrorPiggybackScrubberError"
    },
    { 
        ProfileDCDispatchedPrefetchInstructions,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x4b) | UNIT_MASK(0x07) | DEFAULT_METHOD, 
        L"DCDispatchedPrefetchInstructions"
    },
    { 
        ProfileDCDispatchedPrefetchInstructionsLoad,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x4b) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"DCDispatchedPrefetchInstructionsLoad"
    },
    { 
        ProfileDCDispatchedPrefetchInstructionsStore,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x4b) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"DCDispatchedPrefetchInstructionsStore"
    },
    { 
        ProfileDCDispatchedPrefetchInstructionsNTA,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x4b) | UNIT_MASK(0x04) | DEFAULT_METHOD, 
        L"DCDispatchedPrefetchInstructionsNTA"
    },
    { 
        ProfileBUInternalL2Request,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x7d) | UNIT_MASK(0x1f) | DEFAULT_METHOD, 
        L"BUInternalL2Request"
    },
    { 
        ProfileBUInternalL2RequestICFill,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x7d) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"BUInternalL2RequestICFill"
    },
    { 
        ProfileBUInternalL2RequestDCFill,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x7d) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"BUInternalL2RequestDCFill"
    },
    { 
        ProfileBUInternalL2RequestTLBReload,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x7d) | UNIT_MASK(0x04) | DEFAULT_METHOD, 
        L"BUInternalL2RequestTLBReload"
    },
    { 
        ProfileBUInternalL2RequestTagSnoopRequest,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x7d) | UNIT_MASK(0x08) | DEFAULT_METHOD, 
        L"BUInternalL2RequestTagSnoopRequest"
    },
    { 
        ProfileBUInternalL2RequestCancelledRequest,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x7d) | UNIT_MASK(0x10) | DEFAULT_METHOD, 
        L"BUInternalL2RequestCancelledRequest"
    },
    { 
        ProfileBUFillRequestMissedInL2,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x7e) | UNIT_MASK(0x07) | DEFAULT_METHOD, 
        L"BUFillRequestMissedInL2"
    },
    { 
        ProfileBUFillRequestMissedInL2ICFill,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x7e) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"BUFillRequestMissedInL2ICFill"
    },
    { 
        ProfileBUFillRequestMissedInL2DCFill,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x7e) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"BUFillRequestMissedInL2DCFill"
    },
    { 
        ProfileBUFillRequestMissedInL2TLBLoad,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x7e) | UNIT_MASK(0x04) | DEFAULT_METHOD, 
        L"BUFillRequestMissedInL2TLBLoad"
    },
    {
        ProfileBUFillIntoL2,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x7f) | UNIT_MASK(0x03) | DEFAULT_METHOD, 
        L"BUFillIntoL2"
    },
    { 
        ProfileBUFillIntoL2DirtyL2Victim,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x7f) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"BUFillIntoL2DirtyL2Victim"
    },
    { 
        ProfileBUFillIntoL2VictimFromL1,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x7f) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"BUFillIntoL2VictimFromL1"
    },
    { 
        ProfileICFetch,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x80) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"ICFetch"
    },
    { 
        ProfileICMiss,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x81) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"ICMiss"
    },
    { 
        ProfileICRefillFromL2,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x82) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"ICRefillFromL2"
    },
    { 
        ProfileICRefillFromSystem,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x83) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"ICRefillFromSystem"
    },
    { 
        ProfileICL1TLBMissL2TLBHit,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x84) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"ICL1TLBMissL2TLBHit"
    },
    { 
        ProfileICL1TLBMissL2TLBMiss,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x85) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"ICL1TLBMissL2TLBMiss"
    },
    { 
        ProfileICResyncBySnoop,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x86) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"ICResyncBySnoop"
    },
    { 
        ProfileICInstructionFetchStall,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x87) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"ICInstructionFetchStall"
    },
    { 
        ProfileICReturnStackHit,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x88) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"ICReturnStackHit"
    },
    { 
        ProfileICReturnStackOverflow,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0x89) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"ICReturnStackOverflow"
    },
    { 
        ProfileFRRetiredx86Instructions,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xc0) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRRetiredx86Instructions"
    },
    { 
        ProfileFRRetireduops,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xc1) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRRetireduops"
    },
    { 
        ProfileFRRetiredBranches,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xc2) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRRetiredBranches"
    },
    { 
        ProfileFRRetiredBranchesMispredicted,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xc3) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRRetiredBranchesMispredicted"
    },
    { 
        ProfileFRRetiredTakenBranches,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xc4) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRRetiredTakenBranches"
    },
    { 
        ProfileFRRetiredTakenBranchesMispredicted,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xc5) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRRetiredTakenBranchesMispredicted"
    },
    { 
        ProfileFRRetiredFarControlTransfers,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xc6) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRRetiredFarControlTransfers"
    },
    { 
        ProfileFRRetiredResyncsNonControlTransferBranches,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xc7) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRRetiredResyncsNonControlTransferBranches"
    },
    { 
        ProfileFRRetiredNearReturns,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xc8) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRRetiredNearReturns"
    },
    { 
        ProfileFRRetiredNearReturnsMispredicted,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xc9) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRRetiredNearReturnsMispredicted"
    },
    { 
        ProfileFRRetiredTakenBranchesMispredictedByAddressMiscompare,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xca) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRRetiredTakenBranchesMispredictedByAddressMiscompare"
    },
    { 
        ProfileFRRetiredFPUInstructions,
        NOT_SUPPORTED_IN_K8_REVA,
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xcb) | UNIT_MASK(0x0f) | DEFAULT_METHOD, 
        L"FRRetiredFPUInstructions"
    },
    { 
        ProfileFRRetiredFPUInstructionsx87,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xcb) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"FRRetiredFPUInstructionsx87"
    },
    { 
        ProfileFRRetiredFPUInstructionsMMXAnd3DNow,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xcb) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"FRRetiredFPUInstructionsMMXAnd3DNow"
    },
    { 
        ProfileFRRetiredFPUInstructionsPackedSSEAndSSE2,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xcb) | UNIT_MASK(0x04) | DEFAULT_METHOD, 
        L"FRRetiredFPUInstructionsPackedSSEAndSSE2"
    },
    { 
        ProfileFRRetiredFPUInstructionsScalarSSEAndSSE2,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xcb) | UNIT_MASK(0x08) | DEFAULT_METHOD, 
        L"FRRetiredFPUInstructionsScalarSSEAndSSE2"
    },
    { 
        ProfileFRRetiredFastpathDoubleOpInstructions,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xcc) | UNIT_MASK(0x07) | DEFAULT_METHOD, 
        L"FRRetiredFastpathDoubleOpInstructions"
    },
    { 
        ProfileFRRetiredFastpathDoubleOpInstructionsLowOpInPosition0,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xcc) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"FRRetiredFastpathDoubleOpInstructionsLowOpInPosition0"
    },
    { 
        ProfileFRRetiredFastpathDoubleOpInstructionsLowOpInPosition1,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xcc) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"FRRetiredFastpathDoubleOpInstructionsLowOpInPosition1"
    },
    { 
        ProfileFRRetiredFastpathDoubleOpInstructionsLowOpInPosition2,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xcc) | UNIT_MASK(0x04) | DEFAULT_METHOD, 
        L"FRRetiredFastpathDoubleOpInstructionsLowOpInPosition2"
    },
    { 
        ProfileFRInterruptsMaskedCycles,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xcd) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRInterruptsMaskedCycles"
    },
    { 
        ProfileFRInterruptsMaskedWhilePendingCycles,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xce) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRInterruptsMaskedWhilePendingCycles"
    },
    { 
        ProfileFRTakenHardwareInterrupts,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xcf) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRTakenHardwareInterrupts"
    },
    { 
        ProfileFRNothingToDispatch,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xd0) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRNothingToDispatch"
    },
    { 
        ProfileFRDispatchStalls,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xd1) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRDispatchStalls"
    },
    { 
        ProfileFRDispatchStallsFromBranchAbortToRetire,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xd2) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRDispatchStallsFromBranchAbortToRetire"
    },
    { 
        ProfileFRDispatchStallsForSerialization,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xd3) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRDispatchStallsForSerialization"
    },
    { 
        ProfileFRDispatchStallsForSegmentLoad,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xd4) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRDispatchStallsForSegmentLoad"
    },
    { 
        ProfileFRDispatchStallsWhenReorderBufferFull,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xd5) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRDispatchStallsWhenReorderBufferFull"
    },
    { 
        ProfileFRDispatchStallsWhenReservationStationsFull,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xd6) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRDispatchStallsWhenReservationStationsFull"
    },
    { 
        ProfileFRDispatchStallsWhenFPUFull,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xd7) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRDispatchStallsWhenFPUFull"
    },
    { 
        ProfileFRDispatchStallsWhenLSFull,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xd8) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRDispatchStallsWhenLSFull"
    },
    { 
        ProfileFRDispatchStallsWhenWaitingForAllQuiet,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xd9) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRDispatchStallsWhenWaitingForAllQuiet"
    },
    { 
        ProfileFRDispatchStallsWhenFarControlOrResyncBranchPending,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xda) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRDispatchStallsWhenFarControlOrResyncBranchPending"
    },
    { 
        ProfileFRFPUExceptions,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xdb) | UNIT_MASK(0x0f) | DEFAULT_METHOD, 
        L"FRFPUExceptions"
    },
    { 
        ProfileFRFPUExceptionsx87ReclassMicroFaults,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xdb) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"FRFPUExceptionsx87ReclassMicroFaults"
    },
    { 
        ProfileFRFPUExceptionsSSERetypeMicroFaults,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xdb) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"FRFPUExceptionsSSERetypeMicroFaults"
    },
    { 
        ProfileFRFPUExceptionsSSEReclassMicroFaults,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xdb) | UNIT_MASK(0x04) | DEFAULT_METHOD, 
        L"FRFPUExceptionsSSEReclassMicroFaults"
    },
    { 
        ProfileFRFPUExceptionsSSEAndx87MicroTraps,
        NOT_SUPPORTED_IN_K8_REVA, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xdb) | UNIT_MASK(0x08) | DEFAULT_METHOD, 
        L"FRFPUExceptionsSSEAndx87MicroTraps"
    },
    { 
        ProfileFRNumberOfBreakPointsForDR0,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xdc) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRNumberOfBreakPointsForDR0"
    },
    { 
        ProfileFRNumberOfBreakPointsForDR1,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xdd) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRNumberOfBreakPointsForDR1"
    },
    { 
        ProfileFRNumberOfBreakPointsForDR2,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xde) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRNumberOfBreakPointsForDR2"
    },
    { 
        ProfileFRNumberOfBreakPointsForDR3,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xdf) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"FRNumberOfBreakPointsForDR3"
    },
    { 
        ProfileNBMemoryControllerPageAccessEvent,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xe0) | UNIT_MASK(0x07) | DEFAULT_METHOD, 
        L"NBMemoryControllerPageAccessEvent"
    },
    { 
        ProfileNBMemoryControllerPageAccessEventPageHit,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xe0) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"NBMemoryControllerPageAccessEventPageHit"
    },
    { 
        ProfileNBMemoryControllerPageAccessEventPageMiss,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xe0) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"NBMemoryControllerPageAccessEventPageMiss"
    },
    { 
        ProfileNBMemoryControllerPageAccessEventPageConflict,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xe0) | UNIT_MASK(0x04) | DEFAULT_METHOD, 
        L"NBMemoryControllerPageAccessEventPageConflict"
    },
    { 
        ProfileNBMemoryControllerPageTableOverflow,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xe1) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"NBMemoryControllerPageTableOverflow"
    },
    { 
        ProfileNBMemoryControllerDRAMCommandSlotsMissed,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xe2) | UNIT_MASK(0x00) | DEFAULT_METHOD, 
        L"NBMemoryControllerDRAMCommandSlotsMissed"
    },
    { 
        ProfileNBMemoryControllerTurnAround,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xe3) | UNIT_MASK(0x07) | DEFAULT_METHOD, 
        L"NBMemoryControllerTurnAround"
    },
    { 
        ProfileNBMemoryControllerTurnAroundDIMM,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xe3) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"NBMemoryControllerTurnAroundDIMM"
    },
    { 
        ProfileNBMemoryControllerTurnAroundReadToWrite,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xe3) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"NBMemoryControllerTurnAroundReadToWrite"
    },
    { 
        ProfileNBMemoryControllerTurnAroundWriteToRead,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xe3) | UNIT_MASK(0x04) | DEFAULT_METHOD, 
        L"NBMemoryControllerTurnAroundWriteToRead"
    },
    { 
        ProfileNBMemoryControllerBypassCounter,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xe4) | UNIT_MASK(0x0f) | DEFAULT_METHOD, 
        L"NBMemoryControllerBypassCounter"
    },
    { 
        ProfileNBMemoryControllerBypassCounterHighPriority,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xe4) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"NBMemoryControllerBypassCounterHighPriority"
    },
    { 
        ProfileNBMemoryControllerBypassCounterLowPriority,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xe4) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"NBMemoryControllerBypassCounterLowPriority"
    },
    { 
        ProfileNBMemoryControllerBypassCounterDRAMControllerInterface,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xe4) | UNIT_MASK(0x04) | DEFAULT_METHOD, 
        L"NBMemoryControllerBypassCounterDRAMControllerInterface"
    },
    { 
        ProfileNBMemoryControllerBypassCounterDRAMControllerQueue,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xe4) | UNIT_MASK(0x08) | DEFAULT_METHOD, 
        L"NBMemoryControllerBypassCounterDRAMControllerQueue"
    },
    { 
        ProfileNBSizedCommands,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xeb) | UNIT_MASK(0x7f) | DEFAULT_METHOD, 
        L"NBSizedCommands"
    },
    { 
        ProfileNBSizedCommandsNonPostWrSzByte,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xeb) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"NBSizedCommandsNonPostWrSzByte"
    },
    { 
        ProfileNBSizedCommandsNonPostWrSzDword,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xeb) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"NBSizedCommandsNonPostWrSzDword"
    },
    { 
        ProfileNBSizedCommandsWrSzByte,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xeb) | UNIT_MASK(0x04) | DEFAULT_METHOD, 
        L"NBSizedCommandsWrSzByte"
    },
    { 
        ProfileNBSizedCommandsWrSzDword,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xeb) | UNIT_MASK(0x08) | DEFAULT_METHOD, 
        L"NBSizedCommandsWrSzDword"
    },
    { 
        ProfileNBSizedCommandsRdSzByte,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xeb) | UNIT_MASK(0x10) | DEFAULT_METHOD, 
        L"NBSizedCommandsRdSzByte"
    },
    { 
        ProfileNBSizedCommandsRdSzDword,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xeb) | UNIT_MASK(0x20) | DEFAULT_METHOD, 
        L"NBSizedCommandsRdSzDword"
    },
    { 
        ProfileNBSizedCommandsRdModWr,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xeb) | UNIT_MASK(0x40) | DEFAULT_METHOD, 
        L"NBSizedCommandsRdModWr"
    },
    { 
        ProfileNBProbeResult,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xec) | UNIT_MASK(0x0f) | DEFAULT_METHOD, 
        L"NBProbeResult"
    },
    { 
        ProfileNBProbeResultMiss,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xec) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"NBProbeResultMiss"
    },
    { 
        ProfileNBProbeResultHit,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xec) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"NBProbeResultHit"
    },
    { 
        ProfileNBProbeResultHitDirtyWithoutMemoryCancel,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xec) | UNIT_MASK(0x04) | DEFAULT_METHOD, 
        L"NBProbeResultHitDirtyWithoutMemoryCancel"
    },
    { 
        ProfileNBProbeResultHitDirtyWithMemoryCancel,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xec) | UNIT_MASK(0x08) | DEFAULT_METHOD, 
        L"NBProbeResultHitDirtyWithMemoryCancel"
    },
    { 
        ProfileNBHyperTransportBus0Bandwidth,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xf6) | UNIT_MASK(0x0f) | DEFAULT_METHOD, 
        L"NBHyperTransportBus0Bandwidth"
    },
    { 
        ProfileNBHyperTransportBus0BandwidthCommandSent,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xf6) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"NBHyperTransportBus0BandwidthCommandSent"
    },
    { 
        ProfileNBHyperTransportBus0BandwidthDataSent,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xf6) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"NBHyperTransportBus0BandwidthDataSent"
    },
    { 
        ProfileNBHyperTransportBus0BandwidthBufferReleaseSent,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xf6) | UNIT_MASK(0x04) | DEFAULT_METHOD, 
        L"NBHyperTransportBus0BandwidthBufferReleaseSent"
    },
    { 
        ProfileNBHyperTransportBus0BandwidthNopSent,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xf6) | UNIT_MASK(0x08) | DEFAULT_METHOD, 
        L"NBHyperTransportBus0BandwidthNopSent"
    },
    { 
        ProfileNBHyperTransportBus1Bandwidth,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xf7) | UNIT_MASK(0x0f) | DEFAULT_METHOD, 
        L"NBHyperTransportBus1Bandwidth"
    },
    { 
        ProfileNBHyperTransportBus1BandwidthCommandSent,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xf7) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"NBHyperTransportBus1BandwidthCommandSent"
    },
    { 
        ProfileNBHyperTransportBus1BandwidthDataSent,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xf7) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"NBHyperTransportBus1BandwidthDataSent"
    },
    { 
        ProfileNBHyperTransportBus1BandwidthBufferReleaseSent,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xf7) | UNIT_MASK(0x04) | DEFAULT_METHOD, 
        L"NBHyperTransportBus1BandwidthBufferReleaseSent"
    },
    { 
        ProfileNBHyperTransportBus1BandwidthNopSent,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xf7) | UNIT_MASK(0x08) | DEFAULT_METHOD, 
        L"NBHyperTransportBus1BandwidthNopSent"
    },
    { 
        ProfileNBHyperTransportBus2Bandwidth,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xf8) | UNIT_MASK(0x0f) | DEFAULT_METHOD, 
        L"NBHyperTransportBus2Bandwidth"
    },
    { 
        ProfileNBHyperTransportBus2BandwidthCommandSent,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xf8) | UNIT_MASK(0x01) | DEFAULT_METHOD, 
        L"NBHyperTransportBus2BandwidthCommandSent"
    },
    { 
        ProfileNBHyperTransportBus2BandwidthDataSent,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xf8) | UNIT_MASK(0x02) | DEFAULT_METHOD, 
        L"NBHyperTransportBus2BandwidthDataSent"
    },
    { 
        ProfileNBHyperTransportBus2BandwidthBufferReleaseSent,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xf8) | UNIT_MASK(0x04) | DEFAULT_METHOD, 
        L"NBHyperTransportBus2BandwidthBufferReleaseSent"
    },
    { 
        ProfileNBHyperTransportBus2BandwidthNopSent,
        TRUE, 
        0x10000, 
        0x10000, 
        0x10000, 
        0x10, 
        EVENT_MASK(0xf8) | UNIT_MASK(0x08) | DEFAULT_METHOD, 
        L"NBHyperTransportBus2BandwidthNopSent"
    }
};  

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\amd64.c ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    Amd64.c

Abstract:

    This module implements profiling functions for the Amd64 platform.

Author:

    Steve Deng (sdeng) 18-Jun-2002

Environment:

    Kernel mode only.

--*/

#include "halcmn.h"
#include "mpprofil.h"
#include "amd64.h"

//
// Local prototypes
//

VOID
Amd64InitializeProfiling(
    VOID
    );

NTSTATUS
Amd64EnableMonitoring(
    KPROFILE_SOURCE ProfileSource
    );

VOID
Amd64DisableMonitoring(
    KPROFILE_SOURCE ProfileSource
    );

NTSTATUS
Amd64SetInterval(
    IN KPROFILE_SOURCE  ProfileSource,
    IN OUT ULONG_PTR   *Interval
    );

NTSTATUS 
Amd64QueryInformation(
    IN HAL_QUERY_INFORMATION_CLASS InformationType,
    IN ULONG     BufferSize,
    IN OUT PVOID Buffer,
    OUT PULONG   ReturnedLength
    );

VOID
Amd64CheckOverflowStatus(
    POVERFLOW_STATUS pOverflowStatus
    );

NTSTATUS
HalpGetProfileDescriptor(
    KPROFILE_SOURCE ProfileSource,
    PAMD64_PROFILE_SOURCE_DESCRIPTOR *ProfileSourceDescriptor
    );

NTSTATUS
HalpAllocateCounter(
    KPROFILE_SOURCE ProfileSource,
    OUT PULONG Counter
    );

VOID
HalpFreeCounter(
    ULONG Counter
    );

#pragma alloc_text(PAGE, Amd64QueryInformation)
#pragma alloc_text(INIT, Amd64InitializeProfiling)

PROFILE_INTERFACE Amd64PriofileInterface = {
    Amd64InitializeProfiling,
    Amd64EnableMonitoring,
    Amd64DisableMonitoring,
    Amd64SetInterval,
    Amd64QueryInformation,
    Amd64CheckOverflowStatus
};

//
// The status of counter registers
//

typedef struct _COUNTER_STATUS {
    BOOLEAN Idle;
    KPROFILE_SOURCE ProfileSource;
} COUNTER_STATUS;

COUNTER_STATUS 
CounterStatus[MAXIMUM_PROCESSORS][AMD64_NUMBER_COUNTERS];

//
// The profile sources of overflowed counters
//

KPROFILE_SOURCE 
OverflowedProfileList[MAXIMUM_PROCESSORS][AMD64_NUMBER_COUNTERS];

VOID
Amd64InitializeProfiling(
    VOID
    )

/*++

Routine Description:

    This function does one time initialization of the performance monitoring 
    registers and related data structures.

Arguments:

    None.

Return Value:

    None.

--*/

{
    LONG i;
 
    //         
    // Initialize all PerfEvtSel registers to zero. This will effectively 
    // disable all counters.
    //         

    for (i = 0; i < AMD64_NUMBER_COUNTERS; i++) {
        WRMSR(MSR_PERF_EVT_SEL0 + i, 0); 
        HalpFreeCounter(i);
    }
}

NTSTATUS
Amd64EnableMonitoring(
    KPROFILE_SOURCE ProfileSource
    )

/*++

Routine Description:

    This function enables the monitoring of the hardware events specified 
    by ProfileSource and set up MSRs to generate performance monitor 
    interrupt (PMI) when counters overflow.

Arguments:

    ProfileSource - Supplies the Profile Source 

Return Value:

    STATUS_SUCCESS - If the monitoring of the event is successfully enabled.

    STATUS_NOT_SUPPORTED - If the specified profile source is not supported.

    STATUS_DEVICE_BUSY - If no free counters available.

--*/

{
    PAMD64_PROFILE_SOURCE_DESCRIPTOR ProfileSourceDescriptor;
    NTSTATUS Status;
    ULONG i;

    //
    // If the specified ProfileSource is not supported, return immediately
    //

    Status = HalpGetProfileDescriptor(ProfileSource, 
                                      &ProfileSourceDescriptor);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Get an idle counter if available. Otherwise return immediately.
    //

    Status = HalpAllocateCounter(ProfileSource, &i);
    if (!NT_SUCCESS(Status)) {
        return Status;
    } 

    //
    // Set counter register to its initial value
    //

    WRMSR (MSR_PERF_CTR0  + i, 0 - ProfileSourceDescriptor->Interval); 

    //
    // Enable counting and overflow interrupt
    //

    WRMSR (MSR_PERF_EVT_SEL0 + i, 
           ProfileSourceDescriptor->PerfEvtSelDef | 
                           PERF_EVT_SEL_INTERRUPT | 
                           PERF_EVT_SEL_ENABLE); 

    return STATUS_SUCCESS;
}

VOID
Amd64DisableMonitoring(
    KPROFILE_SOURCE ProfileSource
    )

/*++

Routine Description:

    This function stops the monitoring of the hardware event specified 
    by ProfileSource, and disables the interrupt associated with the event.
    

Arguments:

    ProfileSource - Supplies the Profile Source 

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    ULONG ProcessorNumber, i;
    PAMD64_PROFILE_SOURCE_DESCRIPTOR ProfileSourceDescriptor;

    //
    // If the specified ProfileSource is not supported, return immediately.
    //

    Status = HalpGetProfileDescriptor(ProfileSource, &ProfileSourceDescriptor);
    if (!NT_SUCCESS(Status)) {
        return;
    }

    ProcessorNumber = KeGetCurrentProcessorNumber();
    for (i = 0; i < AMD64_NUMBER_COUNTERS; i++) {

        //
        // Find out the counter assigned to the given profile source and 
        // disable it
        //

        if (!(CounterStatus[ProcessorNumber][i].Idle) &&
            (ProfileSource == CounterStatus[ProcessorNumber][i].ProfileSource)){

            //
            // Disable counting and overflow interrupt
            //

            WRMSR( MSR_PERF_EVT_SEL0 + i,
                   ProfileSourceDescriptor->PerfEvtSelDef &
                   ~(PERF_EVT_SEL_INTERRUPT | PERF_EVT_SEL_ENABLE)); 

            //
            // Free up the counter
            //

            HalpFreeCounter (i);
            break;
        }
    }

    return;
}

NTSTATUS
Amd64SetInterval(
    IN KPROFILE_SOURCE ProfileSource,
    IN OUT ULONG_PTR *Interval
    )

/*++

Routine Description:

    This function sets the interrupt interval of given profile source 
    for Amd64 platform.

    It is assumed that all processors in the system use same interval 
    value for same ProfileSource.

Arguments:

    ProfileSource - Supplies the profile source.

    Interval - Supplies the interval value and returns the actual interval.

Return Value:

    STATUS_SUCCESS - If the profile interval is successfully updated.

    STATUS_NOT_SUPPORTED - If the specified profile source is not supported.

--*/

{
    NTSTATUS Status;
    PAMD64_PROFILE_SOURCE_DESCRIPTOR ProfileSourceDescriptor;

    Status = HalpGetProfileDescriptor(ProfileSource, &ProfileSourceDescriptor);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (*Interval < ProfileSourceDescriptor->MinInterval) {
        *Interval = ProfileSourceDescriptor->MinInterval;        
    }

    if (*Interval > ProfileSourceDescriptor->MaxInterval) {
        *Interval = ProfileSourceDescriptor->MaxInterval;        
    }

    ProfileSourceDescriptor->Interval = *Interval;
    return STATUS_SUCCESS;
}

VOID
Amd64CheckOverflowStatus(
    POVERFLOW_STATUS pOverflowStatus
    )

/*++

Routine Description:

    This function find out the overflowed counters and return the related
    profile sources to the caller.

Arguments:

    ProfileSource - Supplies the profile source.

Return Value:

    None.

--*/

{
    PAMD64_PROFILE_SOURCE_DESCRIPTOR ProfileSourceDescriptor;
    KPROFILE_SOURCE ProfileSource;
    ULONG64 CurrentCount, Mask;
    NTSTATUS Status;
    LONG i, j;
    ULONG ProcessorNumber;

    ProcessorNumber = KeGetCurrentProcessorNumber();
    for(i = j = 0; i < AMD64_NUMBER_COUNTERS; i++) {

        if (!(CounterStatus[ProcessorNumber][i].Idle)) {
            ProfileSource = CounterStatus[ProcessorNumber][i].ProfileSource;
            Status = HalpGetProfileDescriptor (ProfileSource, 
                                               &ProfileSourceDescriptor);

            if (NT_SUCCESS(Status)) {

                //
                // Mask off the reserved bits
                //

                Mask = (((ULONG64)1 << AMD64_COUNTER_RESOLUTION) - 1);

                CurrentCount = RDMSR(MSR_PERF_CTR0 + i);

                //
                // An overflow occured if the current value in counter
                // is smaller than the initial value
                //

                if ((CurrentCount & Mask) < 
                    ((ULONG64)(0 - ProfileSourceDescriptor->Interval) & Mask)) {

                    //
                    // Add it to the overflowed profile source list.
                    // 
                    //

                    OverflowedProfileList[ProcessorNumber][j] = ProfileSource;
                    j++;    
                }
            }
        }
    }

    //
    // Record the number of overflowed counters
    //

    pOverflowStatus->Number = j;

    if(j) {
        pOverflowStatus->pSource = &(OverflowedProfileList[ProcessorNumber][0]);
    } 
}

NTSTATUS
HalpGetProfileDescriptor(
    IN KPROFILE_SOURCE ProfileSource,
    IN OUT PAMD64_PROFILE_SOURCE_DESCRIPTOR *ProfileSourceDescriptor
    )

/*++

Routine Description:

    This function retrieves the descriptor of specified profile source.

Arguments:

    ProfileSource - Supplies the profile source.

    ProfileSourceDescriptor - Where the pointer of descriptor is returned.
        

Return Value:

    STATUS_SUCCESS - If the requested mapping is found.

    STATUS_NOT_SUPPORTED - If the specified profile source is not supported.

--*/

{

    LONG i;
    
    if ((ULONG)ProfileSource < ProfileMaximum) {

        //
        // This is a generic profile source
        //

        i = ProfileSource;

    } 
    else if ((ULONG)ProfileSource <  ProfileAmd64Maximum && 
             (ULONG)ProfileSource >= ProfileAmd64Minimum ) {

        //
        // This is an Amd64 specific profile source
        //

        i = ProfileSource - ProfileAmd64Minimum + ProfileMaximum;

    } 
    else {
        return STATUS_NOT_SUPPORTED;
    }

    *ProfileSourceDescriptor = &(Amd64ProfileSourceDescriptorTable[i]);
    if (!((*ProfileSourceDescriptor)->Supported)) {
        return STATUS_NOT_SUPPORTED;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
HalpAllocateCounter(
    IN KPROFILE_SOURCE ProfileSource,
    OUT PULONG Counter
    )

/*++

Routine Description:

    This function finds an idle counter register and assigns the specified
    profile source to it.

Arguments:

    ProfileSource - Supplies the profile source.

    Counter - Supplies a pointer where the index of the idle counter is returned.

Return Value:

    STATUS_SUCCESS - If an idle counter register is found.

    STATUS_DEVICE_BUSY - If all counter registers are occupied.

--*/

{
    LONG i;
    ULONG ProcessorNumber;

    ProcessorNumber = KeGetCurrentProcessorNumber();

    for(i = 0; i < AMD64_NUMBER_COUNTERS; i++) {
        if (CounterStatus[ProcessorNumber][i].Idle == TRUE) {
	
            // 
            // Found an idle counter. Mark it busy and assign ProfileSource
            // to it 
            // 

            CounterStatus[ProcessorNumber][i].Idle = FALSE;
            CounterStatus[ProcessorNumber][i].ProfileSource = ProfileSource;
            *Counter = i;
            return STATUS_SUCCESS;
        }
    }

    return STATUS_DEVICE_BUSY;
}

VOID
HalpFreeCounter(
    ULONG Counter
    )

/*++

Routine Description:

    This function marks the specified counter idle.

Arguments:

    Counter - The index of the counter to be freed.

Return Value:

    None.

--*/

{
    ULONG ProcessorNumber;

    ProcessorNumber = KeGetCurrentProcessorNumber();
    CounterStatus[ProcessorNumber][Counter].Idle = TRUE;
    CounterStatus[ProcessorNumber][Counter].ProfileSource = 0;
}

NTSTATUS 
Amd64QueryInformation(
    IN HAL_QUERY_INFORMATION_CLASS InformationType,
    IN ULONG BufferSize,
    IN OUT PVOID Buffer,
    OUT PULONG ReturnedLength
    )

/*++

Routine Description:

    This function retrieves the information of profile sources.

Arguments:

    InformationClass - Constant that describes the type of information . 

    BufferSize - Size of the memory pointed to by Buffer.

    Buffer - Requested information described by InformationClass.

    ReturnedLength - The actual bytes returned or needed for the requested 
        information.

Return Value:

    STATUS_SUCCESS - If the requested information is retrieved successfully.

    STATUS_INFO_LENGTH_MISMATCH - If the incoming BufferSize is too small.
    
    STATUS_NOT_SUPPORTED - If the specified information class or profile 
        source is not supported.

--*/

{
    NTSTATUS Status;
    ULONG i, TotalProfieSources;
    PHAL_PROFILE_SOURCE_INFORMATION ProfileSourceInformation;
    PHAL_PROFILE_SOURCE_LIST ProfileSourceList;
    PAMD64_PROFILE_SOURCE_DESCRIPTOR ProfileSourceDescriptor;

    switch (InformationType) {
        case HalQueryProfileSourceList:

            TotalProfieSources = sizeof(Amd64ProfileSourceDescriptorTable) / 
                                 sizeof(AMD64_PROFILE_SOURCE_DESCRIPTOR);

            if (BufferSize == 0) {

                //
                // This indicates the caller just wants to know the
                // size of the buffer to allocate but is not prepared
                // to accept any data content. In this case the bytes
                // needed to store HAL_PROFILE_SOURCE_LIST structures
                // of all profile sources is returned.
                //

                *ReturnedLength = TotalProfieSources * 
                                  sizeof(HAL_PROFILE_SOURCE_LIST);
                Status = STATUS_SUCCESS;
                break;
            }

            if (BufferSize < TotalProfieSources * 
                             sizeof(HAL_PROFILE_SOURCE_LIST)) {
                *ReturnedLength = 0;
                Status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            ProfileSourceList = (PHAL_PROFILE_SOURCE_LIST) Buffer;

            for (i = 0; i < TotalProfieSources; i++) {
                Status = HalpGetProfileDescriptor(i, &ProfileSourceDescriptor);
                if (NT_SUCCESS(Status)) {
	
                    //
                    // Filling in requested data
                    //

                    ProfileSourceList->Source = ProfileSourceDescriptor->ProfileSource;
                    ProfileSourceList->Description = ProfileSourceDescriptor->Description;
                    ProfileSourceList++; 
                }
            }

            *ReturnedLength = (ULONG)((ULONG_PTR)ProfileSourceList - 
                                      (ULONG_PTR)Buffer);
            Status = STATUS_SUCCESS;
            break;

        case HalProfileSourceInformation:

            if (BufferSize < sizeof(HAL_PROFILE_SOURCE_INFORMATION)) {
                *ReturnedLength = 0;
                Status = STATUS_INFO_LENGTH_MISMATCH;
                break;
            }

            ProfileSourceInformation = (PHAL_PROFILE_SOURCE_INFORMATION) Buffer;

            Status = HalpGetProfileDescriptor(ProfileSourceInformation->Source, 
                                              &ProfileSourceDescriptor);

            if (!NT_SUCCESS(Status)) {
                *ReturnedLength = 0;
                Status = STATUS_NOT_SUPPORTED;
                break;
            }

            //
            // Filling in requested data
            //

            ProfileSourceInformation->Supported = ProfileSourceDescriptor->Supported;
            ProfileSourceInformation->Interval = (ULONG) ProfileSourceDescriptor->Interval;

            Status = STATUS_SUCCESS;
            break;

        default:
            *ReturnedLength = 0;
            Status = STATUS_NOT_SUPPORTED;
            break;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\8259.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    8259.h

Abstract:

    This module contains a variety of constants, function prototypes,
    inline functions and external data declarations used by code to
    access the 8259 PIC.

Author:

    Forrest Foltz (forrestf) 24-Oct-2000

--*/

#ifndef _8259_H_
#define _8259_H_

//
// Initialization control words for the PICs
//

#define ICW1_ICW4_NEEDED                    0x01
#define ICW1_CASCADE                        0x00
#define ICW1_INTERVAL8                      0x00
#define ICW1_LEVEL_TRIG                     0x08
#define ICW1_EDGE_TRIG                      0x00
#define ICW1_ICW                            0x10

#define ICW4_8086_MODE                      0x01
#define ICW4_AUTO_EOI                       0x02
#define ICW4_NORM_EOI                       0x00
#define ICW4_NON_BUF_MODE                   0x00
#define ICW4_SPEC_FULLY_NESTED              0x10
#define ICW4_NOT_SPEC_FULLY_NESTED          0x00

#define PIC1_EOI_MASK   0x60
#if defined(NEC_98)
#define PIC2_EOI        0x67
#else
#define PIC2_EOI        0x62
#endif

#define OCW2_NON_SPECIFIC_EOI   0x20
#define OCW2_SPECIFIC_EOI       0x60
#define OCW3_READ_ISR           0x0B
#define OCW3_READ_IRR           0x0A

#define PIC1_BASE               0x30
#define PIC2_BASE               0x38


#if defined(PIC1_PORT0)

C_ASSERT(PIC1_PORT0 == 0x20);
C_ASSERT(PIC1_PORT1 == 0x21);
C_ASSERT(PIC2_PORT0 == 0xA0);
C_ASSERT(PIC2_PORT1 == 0xA1);

#undef PIC1_PORT0
#undef PIC1_PORT1
#undef PIC2_PORT0
#undef PIC2_PORT1

#endif

#define PIC1_PORT0 (PUCHAR)0x20
#define PIC1_PORT1 (PUCHAR)0x21
#define PIC2_PORT0 (PUCHAR)0xA0
#define PIC2_PORT1 (PUCHAR)0xA1

#if defined(EISA_EDGE_LEVEL0)

C_ASSERT(EISA_EDGE_LEVEL0 == 0x4D0);
C_ASSERT(EISA_EDGE_LEVEL1 == 0x4D1);

#undef EISA_EDGE_LEVEL0
#undef EISA_EDGE_LEVEL1

#endif

#define EISA_EDGE_LEVEL0 (PUCHAR)0x4D0
#define EISA_EDGE_LEVEL1 (PUCHAR)0x4D1

__inline
VOID
SET_8259_MASK (
    IN USHORT Mask
    )
{
    WRITE_PORT_USHORT_PAIR (PIC1_PORT1,PIC2_PORT1,Mask);
    IO_DELAY();
}

__inline
USHORT
GET_8259_MASK (
    VOID
    )
{
    USHORT mask;

    mask = READ_PORT_USHORT_PAIR (PIC1_PORT1,PIC2_PORT1);
    IO_DELAY();

    return mask;
}

__inline
VOID
PIC1DELAY(
    VOID
    )
{
    READ_PORT_UCHAR(PIC1_PORT0);
    IO_DELAY();
}   

__inline
VOID
PIC2DELAY(
    VOID
    )
{
    READ_PORT_UCHAR(PIC2_PORT0);
    IO_DELAY();
}

#endif  // _8259_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\amd64s.asm ===
TITLE  "AMD64 Support Routines"
;++
;
; Copyright (c) 2000 Microsoft Corporation
;
; Module Name:
;
;    miscs.asm
;
; Abstract:
;
;    This module implements various routines for the AMD64 that must be
;    written in assembler.
;
; Author:
;
;    Forrest Foltz (forrestf) 14-Oct-2000
;
; Environment:
;
;    Kernel mode only.
;
;--

include kxamd64.inc
include ksamd64.inc

extern  HalpHiberInProgress:byte

FLUSH_TB macro
        mov     rcx, cr4
        and     rcx, NOT CR4_PGE
        mov     cr4, rcx
        mov     rax, cr3
        mov     cr3, rax
        or      rcx, CR4_PGE
        mov     cr4, rcx
        endm

;++
;
; VOID
; HalProcessorIdle(
;       VOID
;       )
;
; Routine Description:
;
;   This function is called when the current processor is idle.
;
;   This function is called with interrupts disabled, and the processor
;   is idle until it receives an interrupt.  The does not need to return
;   until an interrupt is received by the current processor.
;
;   This is the lowest level of processor idle.  It occurs frequently,
;   and this function (alone) should not put the processor into a
;   power savings mode which requeres large amount of time to enter & exit.
;
; Return Value:
;
;--

        LEAF_ENTRY HalProcessorIdle, _TEXT$00
        
        ;
        ; the following code sequence "sti-halt" puts the processor
        ; into a Halted state, with interrupts enabled, without processing
        ; an interrupt before halting.   The STI instruction has a delay
        ; slot such that it does not take effect until after the instruction
        ; following it - this has the effect of HALTing without allowing
        ; a possible interrupt and then enabling interrupts while HALTed.
        ;
    
        ;
        ; On an MP hal we don't stop the processor, since that causes
        ; the SNOOP to slow down as well
        ;

        sti

ifdef NT_UP
        hlt
endif

        ;
        ; Now return to the system.  If there's still no work, then it
        ; will call us back to halt again.
        ;

        ret
        
        LEAF_END HalProcessorIdle, _TEXT$00

;++
;
; VOID
; HalpHalt (
;     VOID
;     );
;
; Routine Description:
;
;     Executes a hlt instruction.  Should the hlt instruction execute,
;     control is returned to the caller.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     None.
;
;--*/

        LEAF_ENTRY HalpHalt, _TEXT$0
        
        hlt
        ret
        
        LEAF_END HalpHalt, _TEXT$0

;++
;
; VOID
; HalpIoDelay (
;     VOID
;     );
;
; Routine Description:
;
;     Generate a delay after port I/O.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     None.
;
;--

        LEAF_ENTRY HalpIoDelay, _TEXT$00
        
        jmp     $+2
        jmp     $+2
        ret
        
        LEAF_END HalpIoDelay, _TEXT$00


;++
;
; VOID
; HalpSerialize (
;     VOID
; )
;
; Routine Description:
;
;     This function implements the fence operation for out-of-order execution
;
; Arguments:
;
;     None
;
; Return Value:
;
;     None
;
;--

HsFrame struct
        SavedRbx    dq ?                ; preserve RBX
HsFrame ends

        NESTED_ENTRY HalpSerialize, _TEXT$00
        
        push_reg rbx
        
        END_PROLOGUE
        
        cpuid
        pop     rbx
        ret
        
        NESTED_END HalpSerialize, _TEXT$00

;++
;
; HalpLMIdentityStub
;
; This routine is entered during startup of a secondary processor.  The
; contents of this routine is actually copied into the startup block
; (see mpsproca.c).  It's purpose is to give StartPx_PMStub a 32-bit
; addressable target.
;
; The act of jumping here causes the processor to begin execution in
; long mode.  Therefore, we can now perform a 64-bit jump to HalpLMStub.
;
; Arguments:
;
;   rdi -> idenity-mapped address of PROCESSOR_START_BLOCK
;
; Return Value:
;
;   None
;
;--

        LEAF_ENTRY HalpLMIdentityStub, _TEXT$00

        mov     edi, edi                ; zero extend high 32 bits
        mov     rcx, QWORD PTR [rdi] + PsbLmTarget
        mov     rax, QWORD PTR [rdi] + PsbProcessorState + PsCr3
        mov     rdi, QWORD PTR [rdi] + PsbSelfMap
        jmp     rcx

        public HalpLMIdentityStubEnd
HalpLMIdentityStubEnd::

        LEAF_END HalpLMIdentityStub, _TEXT$00


;++
;
; HalpLMStub
;
; This routine is entered during startup of a secondary processor.  We
; have just left StartPx_PMStub (xmstub.asm) and are running in an
; identity-mapped address space.
;
; Arguments:
;
;   rax == Final CR3 to be used
;   rdi -> idenity-mapped address of PROCESSOR_START_BLOCK
;
; Return Value:
;
;   None
;
;--

        LEAF_ENTRY HalpLMStub, _TEXT$00

        ;
        ; Set the final CR3 value.  We are now executing in image-loaded
        ; code, rather than code that has been copied to low memory.
        ;
        ; LEAF_ENTRY ensures 16-byte alignment, so the following two
        ; instructions are guaranteed to be on the same page.
        ;

        mov     cr3, rax
        jmp     $+2

        ;
        ; Load the PAT and invalidate the TLB
        ;

        FLUSH_TB

        mov     eax, [rdi] + PsbMsrPat
        mov     edx, [rdi] + PsbMsrPat + 4
        mov     ecx, MSR_PAT
        wbinvd
        wrmsr
        wbinvd

        FLUSH_TB
        
        ;
        ; Load this processor's GDT and IDT.  Because PSB_GDDT32_CODE64 is
        ; identical to KGDT64_R0_CODE (asserted in mpsproca.c), no far jump
        ; is necessary to load a new CS.
        ;
        
        lgdt    fword ptr [rdi] + PsbProcessorState + PsGdtr
        lidt    fword ptr [rdi] + PsbProcessorState + PsIdtr

        ;
        ; Set rdx to point to the context frame and load the segment
        ; registers.
        ; 
        
        mov     ds, [rdi] + PsbProcessorState + PsContextFrame + CxSegDS
        mov     es, [rdi] + PsbProcessorState + PsContextFrame + CxSegES
        mov     fs, [rdi] + PsbProcessorState + PsContextFrame + CxSegFS
        mov     gs, [rdi] + PsbProcessorState + PsContextFrame + CxSegGS
        mov     ss, [rdi] + PsbProcessorState + PsContextFrame + CxSegSS

        ; 
        ; Force the TSS descriptor into a non-busy state, so we don't fault
        ; when we load the TR.
        ; 

        movzx   eax, word ptr [rdi] + PsbProcessorState + SrTr ; get TSS selector
        add     rax, [rdi] + PsbProcessorState + PsGdtr + 2 ; add TSS base
        and     byte ptr [rax+5], NOT 2 ; clear the busy bit

        ;
        ; Load the task register
        ;

        ltr     WORD PTR [rdi] + PsbProcessorState + SrTr

        ; 
        ; Check if it is a fresh startup or a resume from hibernate
        ; 

        mov     al, HalpHiberInProgress 
        cmp     al, 0
        jz      @f

        ; 
        ; We are waking up from lower power state. We should restore
        ; control registers and MSRs here. 
        ; 

        mov     rax, [rdi] + PsbProcessorState + PsSpecialRegisters + PsCr8
        mov     cr8, rax

        mov     ax, word ptr [rdi] + PsbProcessorState + PsLdtr
        lldt    ax

        mov     rdx, [rdi] + PsbProcessorState + PsSpecialRegisters + SrMsrGsBase
        mov     eax, edx
        shr     rdx, 32
        mov     ecx, MSR_GS_BASE
        wrmsr                  

        mov     rdx, [rdi] + PsbProcessorState + PsSpecialRegisters + SrMsrGsSwap
        mov     eax, edx
        shr     rdx, 32
        mov     ecx, MSR_GS_SWAP
        wrmsr                  

        mov     rdx, [rdi] + PsbProcessorState + PsSpecialRegisters + SrMsrStar
        mov     eax, edx
        shr     rdx, 32
        mov     ecx, MSR_STAR
        wrmsr                  

        mov     rdx, [rdi] + PsbProcessorState + PsSpecialRegisters + SrMsrLStar
        mov     eax, edx
        shr     rdx, 32
        mov     ecx, MSR_LSTAR
        wrmsr                  

        mov     rdx, [rdi] + PsbProcessorState + PsSpecialRegisters + SrMsrCStar
        mov     eax, edx
        shr     rdx, 32
        mov     ecx, MSR_CSTAR
        wrmsr                  

        mov     rdx, [rdi] + PsbProcessorState + PsSpecialRegisters + SrMsrSyscallMask
        mov     eax, edx
        shr     rdx, 32
        mov     ecx, MSR_SYSCALL_MASK
        wrmsr              

        ;
        ; Load the debug registers
        ;
        
@@:     xor     rax, rax
        mov     dr7, rax

        lea     rsi, [rdi] + PsbProcessorState + SrKernelDr0
        
        .errnz  (SrKernelDr1 - SrKernelDr0 - 1 * 8)
        .errnz  (SrKernelDr2 - SrKernelDr0 - 2 * 8)
        .errnz  (SrKernelDr3 - SrKernelDr0 - 3 * 8)
        .errnz  (SrKernelDr6 - SrKernelDr0 - 4 * 8)
        .errnz  (SrKernelDr7 - SrKernelDr0 - 5 * 8)
        
        lodsq
        mov     dr0, rax
        
        lodsq
        mov     dr1, rax
        
        lodsq
        mov     dr2, rax
        
        lodsq
        mov     dr3, rax
        
        lodsq
        mov     dr6, rax
        
        lodsq
        mov     dr7, rax
        
        ;
        ; Load the stack pointer, eflags and store the new IP in
        ; a return frame.  Also push two registers that will be used
        ; to the very end.
        ;
        ; Note that up to this point, no stack is available.
        ; 
        
        mov     rsp, [rdi] + PsbProcessorState + PsContextFrame + CxRsp
        
        pushq   [rdi] + PsbProcessorState + PsContextFrame + CxEflags
        popfq
        
        pushq   [rdi] + PsbProcessorState + PsContextFrame + CxRip
        pushq   [rdi] + PsbProcessorState + PsContextFrame + CxRdi
        
        mov     rax, [rdi] + PsbProcessorState + PsContextFrame + CxRax
        mov     rbx, [rdi] + PsbProcessorState + PsContextFrame + CxRbx
        mov     rcx, [rdi] + PsbProcessorState + PsContextFrame + CxRcx
        mov     rdx, [rdi] + PsbProcessorState + PsContextFrame + CxRdx
        mov     rsi, [rdi] + PsbProcessorState + PsContextFrame + CxRsi
        mov     rbp, [rdi] + PsbProcessorState + PsContextFrame + CxRbp
        mov     r8,  [rdi] + PsbProcessorState + PsContextFrame + CxR8
        mov     r9,  [rdi] + PsbProcessorState + PsContextFrame + CxR9
        mov     r10, [rdi] + PsbProcessorState + PsContextFrame + CxR10
        mov     r11, [rdi] + PsbProcessorState + PsContextFrame + CxR11
        mov     r12, [rdi] + PsbProcessorState + PsContextFrame + CxR12
        mov     r13, [rdi] + PsbProcessorState + PsContextFrame + CxR13
        mov     r14, [rdi] + PsbProcessorState + PsContextFrame + CxR14
        mov     r15, [rdi] + PsbProcessorState + PsContextFrame + CxR15

        ;
        ; Indicate that we've started, pop the correct value for rdi
        ; and return.
        ;
        
        inc     DWORD PTR [rdi] + PsbCompletionFlag
        
        pop     rdi
        ret

        LEAF_END HalpLMStub, _TEXT$00
        
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\halcmn.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    halcmn.h

Abstract:

    This module contains a variety of constants, function prototypes,
    inline functions and external data declarations used by the AMD64
    hal code.

Author:

    Forrest Foltz (forrestf) 24-Oct-2000

--*/

#ifndef _HALCMN_H_
#define _HALCMN_H_

#include <halp.h>
#include <apic.inc>
#include <ntapic.inc>
#include <ntacpi.h>
#include "io_cmos.h"
#include "8259.h"
#include "mp8254.inc"

typedef VOID (*PHALP_SOFTWARE_INTERRUPT)(VOID);

extern PHALP_SOFTWARE_INTERRUPT HalpSoftwareInterruptTable[];
extern KIRQL SWInterruptLookupTable[];
extern USHORT Halp8259MaskTable[];
extern LARGE_INTEGER (*QueryTimer)(VOID);
extern KAFFINITY HalpDefaultInterruptAffinity;
extern KAFFINITY HalpActiveProcessors;
extern ULONG HalpTimerWatchdogEnabled;

//
// Number of 100nS units in one second
//

#define TIME_UNITS_PER_SECOND 10000000


#if defined(DBG)
#define AMD64_IMPLEMENT DbgPrint("AMD64: Not implemented\n"); DbgBreakPoint()
#else
#define AMD64_IMPLEMENT
#endif

#if !defined(RTL_FIELD_SIZE)
#define RTL_FIELD_SIZE(type, field) (sizeof(((type *)0)->field))
#endif

VOID
HalpAcquireSystemHardwareSpinLock(
    VOID
    );

VOID
HalpReleaseSystemHardwareSpinLock(
    VOID
    );

__forceinline
VOID
KPcrReadData (
    IN ULONG Offset,
    IN ULONG Length,
    OUT PVOID Buffer
    )

/*++

Routine Description:

    Used to read data from the current processor's KPCR.  This is a support
    function for KPCR_READ_FIELD

Arguments:

    Offset - Supplies the offset within the KPCR to begin the read

    Length - Supplies the length of the data to read from the KPCR.  Must
             be one of 1, 2, 4 or 8.

    Buffer - Supplies the target buffer that contains the data to read from
             the KPCR.

Return value:

    None

--*/

{
    switch (Length) {
        case 1:
            *(PUCHAR)Buffer = __readgsbyte(Offset);
            break;

        case 2:
            *(PUSHORT)Buffer = __readgsword(Offset);
            break;

        case 4:
            *(PULONG)Buffer = __readgsdword(Offset);
            break;

        case 8:
            *(PULONG64)Buffer = __readgsqword(Offset);
            break;
    }
}

__forceinline
VOID
KPcrWriteData (
    IN ULONG Offset,
    IN ULONG Length,
    IN PVOID Buffer
    )

/*++

Routine Description:

    Used to write data to the current processor's KPCR.  This is a support
    function for KPCR_WRITE_FIELD

Arguments:

    Offset - Supplies the offset within the KPCR to begin the write

    Length - Supplies the length of the data to write within the KPCR.  Must
             be one of 1, 2, 4 or 8

    Buffer - Supplies the source buffer that contains the data to write into
             the KPCR.

Return value:

    None

--*/

{
    switch (Length) {
        case 1:
            __writegsbyte(Offset,*(PUCHAR)Buffer);
            break;

        case 2:
            __writegsword(Offset,*(PUSHORT)Buffer);
            break;

        case 4:
            __writegsdword(Offset,*(PULONG)Buffer);
            break;

        case 8:
            __writegsqword(Offset,*(PULONG64)Buffer);
            break;
    }
}


#define KPCR_READ_FIELD(field,value)                        \
    KPcrReadData(FIELD_OFFSET(KPCR,field),                  \
                 RTL_FIELD_SIZE(KPCR,field),                \
                 value);

#define KPCR_WRITE_FIELD(field,value)                       \
    KPcrWriteData(FIELD_OFFSET(KPCR,field),                 \
                  RTL_FIELD_SIZE(KPCR,field),               \
                  value);

NTSTATUS
HalpConnectInterrupt (
    IN ULONG SystemInterruptVector,
    IN KIRQL SystemIrql,
    IN PHAL_INTERRUPT_SERVICE_ROUTINE HalInterruptServiceRoutine,
    IN KINTERRUPT_MODE InterruptMode
    );

BOOLEAN
PicSpuriousService37 (
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext
);

BOOLEAN
HalpApicSpuriousService (
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext
);

VOID
HalpMarkProcessorStarted(
    ULONG   ApicID,
    ULONG   NtNumber
    );

VOID
HalpPmTimerSpecialStall(
    IN ULONG Ticks
    );

VOID
HalpWasteTime (
    ULONG Ticks
    );

#endif  // _HALCMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\interrupt.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    interrupt.c

Abstract:

    HAL routines required to support generic interrupt processing.

Author:

    Forrest Foltz (forrestf) 23-Oct-2000

Revision History:

--*/

#include "halcmn.h"

typedef struct _HAL_INTERRUPT_OBJECT *PHAL_INTERRUPT_OBJECT;
typedef struct _HAL_INTERRUPT_OBJECT {
    PHAL_INTERRUPT_OBJECT Next;
    KSPIN_LOCK SpinLock;
    KINTERRUPT InterruptArray[];
} HAL_INTERRUPT_OBJECT;

//
// Global list of hal interrupt objects
// 

PHAL_INTERRUPT_OBJECT HalpInterruptObjectList = NULL;

//
// Statically allocated heap of KINTERRUPT objects for use during
// initialization of processor 0.
//

#define HALP_INIT_STATIC_INTERRUPTS (8 * 64)

KINTERRUPT
HalpKInterruptHeap[ HALP_INIT_STATIC_INTERRUPTS ];

ULONG HalpKInterruptHeapUsed = 0;

PKINTERRUPT
HalpAllocateKInterrupt (
    VOID
    )

/*++

Routine Description:

    This allocates a KINTERRUPT structure from HalpKInterruptHeap[].  If
    this array is exhausted then the allocation is satisfied with nonpaged
    pool.

    Several KINTERRUPT structures are required very early in system init
    (before pool is initialized).  HalpKInterruptHeap[] must be
    sufficiently large to accomodate these early structures.

Arguments:

    None.

Return Value:

    Returns a pointer to the KINTERRUPT structure if successful, or NULL
    if not.

--*/

{
    PKINTERRUPT interrupt;

    if (HalpKInterruptHeapUsed < HALP_INIT_STATIC_INTERRUPTS) {

        //
        // Allocate from our private heap of KINTERRUPT objects.  If
        // this is exhausted, then assume we are at an init stage post pool
        // init and allocate from regular heap.
        //

        interrupt = &HalpKInterruptHeap[HalpKInterruptHeapUsed];
        HalpKInterruptHeapUsed += 1;

    } else {

        //
        // The private KINTERRUPT heap has been exhausted.  Assume that
        // the system heap has been initialized.
        //

        interrupt = ExAllocatePoolWithTag(NonPagedPool,
                                          sizeof(KINTERRUPT),
                                          HAL_POOL_TAG);
    }

    return interrupt;
}


NTSTATUS
HalpEnableInterruptHandler (
    IN UCHAR ReportFlags,
    IN ULONG BusInterruptVector,
    IN ULONG SystemInterruptVector,
    IN KIRQL SystemIrql,
    IN PHAL_INTERRUPT_SERVICE_ROUTINE HalInterruptServiceRoutine,
    IN KINTERRUPT_MODE InterruptMode
    )

/*++

Routine Description:

    This function connects & registers an IDT vectors usage by the HAL.

Arguments:

    ReportFlags - Flags passed to HalpRegisterVector indicating how this
                  interrupt should be reported.

    BusInterruptVector - Supplies the interrupt vector from the bus's
                         perspective.

    SystemInterruptVector - Supplies the interrupt vector from the system's
                            perspective.

    SystemIrql - Supplies the IRQL associated with the vector.

    HalInterruptServiceRoutine - Supplies the interrupt handler for the
                                 interrupt.

    InterruptMode - Supplies the interupt mode.

Return Value:

    Returns the final status of the operation.

--*/

{
    ULONG size;
    ULONG processorCount;
    UCHAR processorNumber;
    KAFFINITY processorMask;
    PKINTERRUPT kernelInterrupt;
    PKSPIN_LOCK spinLock;
    NTSTATUS status;

#if !defined(ACPI_HAL)

    //
    // Remember which vector the hal is connecting so it can be reported
    // later on
    //
    // If this is an ACPI HAL, the vectors will be claimed by the BIOS.  This
    // is done for Win98 compatibility.
    //

    HalpRegisterVector (ReportFlags,
                        BusInterruptVector,
                        SystemInterruptVector,
                        SystemIrql);

#endif

    status = HalpConnectInterrupt (SystemInterruptVector,
                                   SystemIrql,
                                   HalInterruptServiceRoutine,
                                   InterruptMode);
    return status;
}

PKINTERRUPT
HalpCreateInterrupt (
    IN PKSERVICE_ROUTINE ServiceRoutine,
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KINTERRUPT_MODE InterruptMode,
    IN UCHAR ProcessorNumber,
    IN UCHAR IstIndex OPTIONAL,
    IN PVOID IstStack OPTIONAL
    )

/*++

Routine Description:

    This function connects an IDT vector to a hal service routine.

Arguments:

    ServiceRoutine - Supplies the interrupt handler for the interrupt.

    Vector - Supplies the interrupt vector from the system's perspective.

    Irql - Supplies the IRQL associated with the interrupt.

    Interrupt Mode - Supplies the interrupt mode, Latched or LevelSensitive.

    ProcessorNumber - Supplies the processor number.  

    IstIndex - The Ist index of the stack that this interrupt must run on
               if other than the default (which is zero).  This is an
               optional parameter.

    IstStack - Supplies a pointer to the top of the stack to be used for this
               interrupt.  This is an optional parameter.

Return Value:

    Returns a pointer to the allocated interrupt object, or NULL in the
    event of failure.

--*/

{
    PKINTERRUPT interrupt;
    PKPCR pcr;
    PKIDTENTRY64 idt;
    PKTSS64 tss;
    BOOLEAN connected;

    //
    // Allocate and initialize the kernel interrupt.
    // 

    interrupt = HalpAllocateKInterrupt();
    if (interrupt == NULL) {

        KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                     sizeof(KINTERRUPT),
                     3,
                     (ULONG_PTR)__FILE__,
                     __LINE__
                     );
    }

    KeInitializeInterrupt(interrupt,
                          ServiceRoutine,
                          NULL,             // ServiceContext
                          NO_INTERRUPT_SPINLOCK,
                          Vector,
                          Irql,             // Irql
                          Irql,             // SynchronizeIrql
                          InterruptMode,
                          FALSE,            // ShareVector
                          ProcessorNumber,
                          FALSE);           // FloatingSave

    if (IstIndex != 0) {

        pcr = KeGetPcr();
        idt = &pcr->IdtBase[Vector];

        //
        // Check that we're not overwriting an existing IST index and store
        // the index in the IDT.
        //

        ASSERT(idt->IstIndex == 0);
        idt->IstIndex = IstIndex;
        tss = pcr->TssBase;

        //
        // If a stack was supplied for this IstIndex then store it in the
        // TSS.
        // 

        if (ARGUMENT_PRESENT(IstStack)) {

            ASSERT(tss->Ist[IstIndex] == 0);
            tss->Ist[IstIndex] = (ULONG64)IstStack;

        } else {

            ASSERT(tss->Ist[IstIndex] != 0);
        }
    }

    KeSetIdtHandlerAddress(Vector, &interrupt->DispatchCode[0]);

    return interrupt;
}

VOID
HalpSetHandlerAddressToIDTIrql (
    IN ULONG Vector,
    IN PHAL_INTERRUPT_SERVICE_ROUTINE ServiceRoutine,
    IN PVOID Context,
    IN KIRQL Irql
    )
{
    PKINTERRUPT interrupt;
    KIRQL irql;

    if (Irql == 0) {
        irql = (KIRQL)(Vector / 16);
    } else {
        irql = (KIRQL)Irql;
    }

    interrupt = HalpCreateInterrupt(ServiceRoutine,
                                    Vector,
                                    irql,
                                    Latched,
                                    PROCESSOR_CURRENT,
                                    0,
                                    NULL);
}


NTSTATUS
HalpConnectInterrupt (
    IN ULONG SystemInterruptVector,
    IN KIRQL SystemIrql,
    IN PHAL_INTERRUPT_SERVICE_ROUTINE HalInterruptServiceRoutine,
    IN KINTERRUPT_MODE InterruptMode
    )

/*++

Routine Description:

    This function connects & registers an IDT vectors usage by the HAL.

Arguments:

    SystemInterruptVector - Supplies the interrupt vector from the system's
                            perspective.

    SystemIrql - Supplies the IRQL associated with the vector.

    HalInterruptServiceRoutine - Supplies the interrupt handler for the
                                 interrupt.

    InterruptMode - Supplies the interupt mode.

Return Value:

    Returns the final status of the operation.

--*/

{
    ULONG size;
    ULONG processorCount;
    UCHAR processorNumber;
    KAFFINITY processorMask;
    PHAL_INTERRUPT_OBJECT interruptObject;
    PKINTERRUPT kernelInterrupt;
    PKSPIN_LOCK spinLock;
    PHAL_INTERRUPT_OBJECT interruptObjectHead;
    PKSERVICE_ROUTINE interruptServiceRoutine;

    //
    // Count the number of processors in the system
    //

    processorCount = 0;
    processorMask = 1;

    processorMask = HalpActiveProcessors;
    while (processorMask != 0) {
        if ((processorMask & 1) != 0) {
            processorCount += 1;
        }
        processorMask >>= 1;
    }

    //
    // Allocate and initialize the hal interrupt object
    //

    size = FIELD_OFFSET(HAL_INTERRUPT_OBJECT,InterruptArray) +
           sizeof(KINTERRUPT) * processorCount;

    interruptObject = ExAllocatePoolWithTag(NonPagedPool,size,HAL_POOL_TAG);
    if (interruptObject == NULL) {
        return STATUS_NO_MEMORY;
    }

    spinLock = &interruptObject->SpinLock;
    KeInitializeSpinLock(spinLock);

    //
    // Initialize each of the kernel interrupt objects
    //

    kernelInterrupt = interruptObject->InterruptArray;

    for (processorNumber = 0, processorMask = HalpActiveProcessors;
         processorMask != 0;
         processorNumber += 1, processorMask >>= 1) {

        if ((processorMask & 1) == 0) {
            continue;
        }

        interruptServiceRoutine =
            (PKSERVICE_ROUTINE)(HalInterruptServiceRoutine);

        KeInitializeInterrupt(kernelInterrupt,
                              interruptServiceRoutine,
                              NULL,
                              spinLock,
                              SystemInterruptVector,
                              SystemIrql,
                              SystemIrql,
                              InterruptMode,
                              FALSE,
                              processorNumber,
                              FALSE);
        kernelInterrupt += 1;
    }

    //
    // Atomically insert the hal interrupt object in our global list
    // and return success.
    //

    do {

        interruptObject->Next = HalpInterruptObjectList;

    } while (interruptObject->Next !=
             InterlockedCompareExchangePointer(&HalpInterruptObjectList,
                                               interruptObject,
                                               interruptObject->Next)); 

    return STATUS_SUCCESS;
}


BOOLEAN
PicSpuriousService37 (
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext
)
{
    return FALSE;
}

BOOLEAN
HalpApicSpuriousService (
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext
)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\ixbeep.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ixbeep.c

Abstract:

    HAL routine to make noise.  It needs to synchronize is access to the
    8254, since we also use the 8254 for the profiling interrupt.

Author:

    John Vert (jvert) 31-Jul-1991

Revision History:

    Forrest Foltz (forrestf) 23-Oct-2000
        Ported from ixbeep.asm to ixbeep.c

Revision History:

--*/

#include "halcmn.h"

BOOLEAN
HalMakeBeep (
    IN ULONG Frequency
    )

/*++

Routine Description:

    This function sets the frequency of the speaker, causing it to sound a
    tone.  The tone will sound until the speaker is explicitly turned off,
    so the driver is responsible for controlling the duration of the tone.

Arguments:

    Frequency - Supplies the frequency of the desired tone.  A frequency of
                0 means the speaker should be shut off.

Return Value:

    TRUE  - Operation was successful (frequency within range or zero)
    FALSE - Operation was unsuccessful (frequency was out of range)
            Current tone (if any) is unchanged.

--*/

{
    UCHAR value;
    ULONG count;
    BOOLEAN result;

    HalpAcquireSystemHardwareSpinLock();

    //
    // Stop the speaker
    //

#if defined(NEC_98)
    WRITE_PORT_UCHAR(SPEAKER_CONTROL_PORT,SPEAKER_OFF);
    IO_DELAY();
#else
    value = READ_PORT_UCHAR(SPEAKER_CONTROL_PORT);
    IO_DELAY();
    value &= SPEAKER_OFF_MASK;
    WRITE_PORT_UCHAR(SPEAKER_CONTROL_PORT,value);
    IO_DELAY();
#endif

    //
    // If the frequency is zero, we are finished.
    //

    if (Frequency == 0) {
        result = TRUE;
        goto Exit;
    }

    //
    // Determine the timer register value based on the desired frequency.
    // If it is invalid then FALSE is returned.
    // 

    count = TIMER_CLOCK_IN / Frequency;
    if (count > 65535) {
        result = FALSE;
        goto Exit;
    }

#if defined(NEC_98)

    //
    // Program frequency
    //

    WRITE_PORT_UCHAR(TIMER_CONTROL_PORT,TIMER_CONTROL_SELECT);
    IO_DELAY();

    WRITE_PORT_USHORT_PAIR(TIMER_DATA_PORT,
                           TIMER_DATA_PORT,
                           (USHORT)count);
    IO_DELAY();

    //
    // Turn speaker on
    //

    WRITE_PORT_UCHAR(SPEAKER_CONTROL_PORT,SPEAKER_ON);
    IO_DELAY();

#else

    //
    // Put channel 2 in mode 3 (square-wave generator) and load the
    // proper value in.
    //

    WRITE_PORT_UCHAR(TIMER1_CONTROL_PORT,
                     TIMER_COMMAND_COUNTER2 +
                     TIMER_COMMAND_RW_16BIT +
                     TIMER_COMMAND_MODE3);
    IO_DELAY();
    WRITE_PORT_USHORT_PAIR (TIMER1_DATA_PORT2,
                            TIMER1_DATA_PORT2,
                            (USHORT)count);
    IO_DELAY();

    //
    // Turn the speaker on
    //

    value = READ_PORT_UCHAR(SPEAKER_CONTROL_PORT); IO_DELAY();
    value |= SPEAKER_ON_MASK;
    WRITE_PORT_UCHAR(SPEAKER_CONTROL_PORT,value); IO_DELAY();

#endif  // NEC_98

    //
    // Indicate success, we're done
    //

    result = TRUE;

Exit:
    HalpReleaseSystemHardwareSpinLock();
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\ixsstate.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ixstate.c

Abstract:

    This module implements the code for putting the machine to sleep.

Author:

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halcmn.h"
#include <acpitabl.h>

ULONG HalpBarrier;
ULONG volatile HalpSleepSync;

extern FADT HalpFixedAcpiDescTable;
extern PKPROCESSOR_STATE HalpHiberProcState;

#define PM1a_CNT ((PUSHORT)UlongToPtr(HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port))
#define PM1b_CNT ((PUSHORT)UlongToPtr(HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port))

#define PM1a_EVT ((PUSHORT)UlongToPtr(HalpFixedAcpiDescTable.pm1a_evt_blk_io_port))
#define PM1b_EVT ((PUSHORT)UlongToPtr(HalpFixedAcpiDescTable.pm1b_evt_blk_io_port))

#define WAK_STS 0x8000

//
// Bitfield layout for the PM1 Control register
// 

typedef union _PM1_CNT {
    struct {
        USHORT _SCI_EN:1;
        USHORT _BM_RLD:1;
        USHORT _GBL_RLS:1;
        USHORT Reserved1:6;
        USHORT Ignore:1;
        USHORT _SLP_TYP:3;
        USHORT _SLP_EN:1;
        USHORT Reserved2:2;
    };
    USHORT Value;
} PM1_CNT;

//
// Forward declarations
//

VOID
HalpAcpiFlushCache (
    VOID
    );

BOOLEAN
HalpAcpiPostSleep (
    ULONG Context
    );

BOOLEAN
HalpAcpiPreSleep (
    SLEEP_STATE_CONTEXT Context
    );

VOID
HalpReenableAcpi (
    VOID
    );

VOID
HalpSaveProcessorStateAndWait (
    IN PKPROCESSOR_STATE ProcessorState,
    IN ULONG volatile *Barrier
    );

NTSTATUS
HaliAcpiSleep(
    IN SLEEP_STATE_CONTEXT          Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    )
/*++

Routine Description:

    This is called by the Policy Manager to enter Sx

Arguments:

    Context - Supplies various flags to control operation

    SystemHandler -

    System Context -

    NumberProcessors -

    Number -

--*/

{

    ULONG flags;
    NTSTATUS status;
    PKPCR pcr;
    ULONG sleepSync;
    BOOLEAN result;
    KIRQL oldIrql;
    PUSHORT portAddress;
    USHORT slpTypA;
    USHORT slpTypB;
    PUSHORT pm1aEvt;
    PUSHORT pm1bEvt;
    USHORT value;
    ULONG processorNumber;
    PKPROCESSOR_STATE procState;
    PM1_CNT pm1Control;

    sleepSync = HalpSleepSync;
    oldIrql = KeGetCurrentIrql();
    status = STATUS_SUCCESS;

    flags = HalpDisableInterrupts();
    pcr = KeGetPcr();

    if (pcr->Number == 0) {

        HalpBarrier = 0;

        //
        // Make sure the other processors have saved their
        // state and begun to spin
        //

        InterlockedIncrement(&HalpSleepSync);
        while (HalpSleepSync != NumberProcessors) {
            PAUSE_PROCESSOR;
        }

        //
        // Take care of chores (RTC, interrupt controller, etc.)
        //

        result = HalpAcpiPreSleep(Context);
        if (result == FALSE) {

            //
            // Notify other processors of completion
            //

            HalpSleepSync = 0;
            goto RestoreApic;
        }

        //
        // If we will be losing processor state, save it
        //

        if ((Context.bits.Flags & SLEEP_STATE_FIRMWARE_RESTART) != 0) {
            AMD64_IMPLEMENT;
        }

        //
        // Record the values in the SLP_TYP registers
        //

        if (PM1a_CNT != NULL) {
            slpTypA = READ_PORT_USHORT(PM1a_CNT);
        }

        if (PM1b_CNT != NULL) {
            slpTypB = READ_PORT_USHORT(PM1b_CNT);
        }

        //
        // The hal has all of its state saved into RAM and is ready
        // for the power down.  If there's a system state handler give
        // it a shot.
        //

        if (ARGUMENT_PRESENT(SystemHandler)) {
            status = SystemHandler(SystemContext);
            if (status != STATUS_SUCCESS) {
                HalpReenableAcpi();
                goto hasWake;
            }
        }

        pm1aEvt = PM1a_EVT;
        pm1bEvt = PM1b_EVT;
        if (pm1bEvt == NULL) {
            pm1bEvt = pm1aEvt;
        }

        //
        // Reset WAK_STS
        //

        WRITE_PORT_USHORT(pm1aEvt,WAK_STS);
        WRITE_PORT_USHORT(pm1bEvt,WAK_STS);

        //
        // Flush the caches if necessary
        //

        if ((Context.bits.Flags & SLEEP_STATE_FLUSH_CACHE) != 0) {
            HalpAcpiFlushCache();
        }

        //
        // Issue SLP commands to PM1a_CNT and PM1b_CNT
        //

        pm1Control.Value = READ_PORT_USHORT(PM1a_CNT) & CTL_PRESERVE;
        pm1Control._SLP_TYP = (USHORT)Context.bits.Pm1aVal;
        pm1Control._SLP_EN = 1;
        WRITE_PORT_USHORT(PM1a_CNT,pm1Control.Value);

        if (PM1b_CNT != NULL) {
            pm1Control.Value = READ_PORT_USHORT(PM1b_CNT) & CTL_PRESERVE;
            pm1Control._SLP_TYP = (USHORT)Context.bits.Pm1bVal;
            pm1Control._SLP_EN = 1;
            WRITE_PORT_USHORT(PM1b_CNT,pm1Control.Value);
        }

        //
        // Wait for sleep to be over
        //

        while ((READ_PORT_USHORT(pm1aEvt) == 0) &&
                READ_PORT_USHORT(pm1bEvt) == 0) {

            PAUSE_PROCESSOR;
        }

        //
        // Restore the SLP_TYP registers (so that embedded controllers
        // and BIOSes can be sure that we think the machine is awake.)
        //

hasWake:

        WRITE_PORT_USHORT(PM1a_CNT,slpTypA);
        if (PM1b_CNT != NULL) {
            WRITE_PORT_USHORT(PM1b_CNT,slpTypB);
        }
        HalpAcpiPostSleep(Context.AsULONG);

        //
        // Notify other processors of completion
        //

        HalpSleepSync = 0;

    } else {

        //
        // Secondary processors here
        //

        if ((Context.bits.Flags & SLEEP_STATE_OFF) == 0) {
            procState = &HalpHiberProcState[pcr->Number];
        } else {
            procState = NULL;
        }
        HalpSaveProcessorStateAndWait(procState,&HalpSleepSync);

        //
        // Wait for barrier to move
        //

        while (HalpSleepSync != 0) {
            PAUSE_PROCESSOR;
        }

        //
        // All phases complete, exit
        //
    }

RestoreApic:

    HalpPostSleepMP(NumberProcessors,&HalpBarrier);
    KeLowerIrql(oldIrql);

    HalpSleepSync = 0;
    HalpRestoreInterrupts(flags);
    return status;

}

    
VOID
HalpSaveProcessorStateAndWait (
    IN PKPROCESSOR_STATE ProcessorState,
    IN ULONG volatile *Barrier
    )

/*++

Routine Description:

    This function saves the volatile, non-volatile and special register
    state of the current processor.

Arguments:

    ProcessorState  - Address of processor state record to fill in.

    Barrier         - Address of a value to use as a lock.

Return Value:

    None. This function does not return.

--*/

{
    if (ARGUMENT_PRESENT(ProcessorState)) {
        KeSaveStateForHibernate(ProcessorState);

#if defined(_AMD64_)
        ProcessorState->ContextFrame.Rip = (ULONG_PTR)_ReturnAddress();
        ProcessorState->ContextFrame.Rsp = (ULONG_PTR)&ProcessorState;
#else
#error "Not implemented for this platform"
#endif
    }

    //
    // Flush the cache, as the processor may be about to power off.
    //

    HalpAcpiFlushCache();

    //
    // Signal that this processor has saved its state
    //

    InterlockedIncrement(Barrier);
}

VOID
HalpAcpiFlushCache (
    VOID
    )

/*++

Routine Description:

    This is called to flush everything from the caches

Arguments:

    None

Return Value:

    None

--*/

{
    WritebackInvalidate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\io_cmos.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    io_cmos.h

Abstract:

    This module contains a variety of constants, function prototypes,
    inline functions and external data declarations used by code to
    access the CMOS/ECMOS and well-known, standard I/O ports.

Author:

    Forrest Foltz (forrestf) 24-Oct-2000

--*/

#ifndef _IO_CMOS_H_
#define _IO_CMOS_H_

//
// Constants used to initialize timer 0
//

#if defined(NEC_98)

#define TIMER_CONTROL_PORT    (PUCHAR)0x3fdf
#define TIMER_DATA_PORT       (PUCHAR)0x3fdb
#define TIMER_CLOCK_IN             0x2457600
#define TIMER_CONTROL_SELECT            0x76
#define SPEAKER_CONTROL_PORT    (PUCHAR)0x61
#define SPEAKER_OFF                     0x07
#define SPEAKER_ON                      0x06

#else

#define TIMER1_DATA_PORT0    (PUCHAR)0x40 // Timer1, channel 0 data port
#define TIMER1_DATA_PORT1    (PUCHAR)0x41 // Timer1, channel 1 data port
#define TIMER1_DATA_PORT2    (PUCHAR)0x42 // Timer1, channel 2 data port
#define TIMER1_CONTROL_PORT  (PUCHAR)0x43 // Timer1 control port

#define TIMER2_DATA_PORT0    (PUCHAR)0x48 // Timer2, channel 0 data port
#define TIMER2_CONTROL_PORT  (PUCHAR)0x4B // Timer2 control port

#define TIMER_COMMAND_COUNTER0       0x00 // Select channel 0
#define TIMER_COMMAND_COUNTER1       0x40 // Select channel 1
#define TIMER_COMMAND_COUNTER2       0x80 // Select channel 2

#define TIMER_COMMAND_RW_16BIT       0x30 // Read/Write LSB firt then MSB
#define TIMER_COMMAND_MODE2             4 // Use mode 2
#define TIMER_COMMAND_MODE3             6
#define TIMER_COMMAND_BCD               0 // Binary count down
#define TIMER_COMMAND_LATCH_READ        0 // Latch read command

#define TIMER_CLOCK_IN            1193167

#define SPEAKER_CONTROL_PORT  (PCHAR)0x61
#define SPEAKER_OFF_MASK             0xFC  
#define SPEAKER_ON_MASK              0x03

#endif

//
// CMOS ports
//

#define CMOS_ADDRESS_PORT        (PCHAR)0x70
#define CMOS_DATA_PORT           (PCHAR)0x71
#define ECMOS_ADDRESS_PORT_LSB   (PCHAR)0x74
#define ECMOS_ADDRESS_PORT_MSB   (PCHAR)0x75
#define ECMOS_DATA_PORT          (PCHAR)0x76

#define CMOS_STATUS_A                   0x0A
#define CMOS_STATUS_B                   0x0B
#define CMOS_STATUS_C                   0x0C
#define CMOS_STATUS_D                   0x0D
#define CMOS_STATUS_BUSY                0x80
#define CMOS_STATUS_BANK1               0x10
#define CMOS_BANK_1                    0x100
#define RTC_OFFSET_SECOND                  0
#define RTC_OFFSET_SECOND_ALARM            1
#define RTC_OFFSET_MINUTE                  2
#define RTC_OFFSET_MINUTE_ALARM            3
#define RTC_OFFSET_HOUR                    4
#define RTC_OFFSET_HOUR_ALARM              5
#define RTC_OFFSET_DAY_OF_WEEK             6
#define RTC_OFFSET_DATE_OF_MONTH           7    
#define RTC_OFFSET_MONTH                   8     
#define RTC_OFFSET_YEAR                    9      
#define RTC_OFFSET_CENTURY_MCA          0x37       
#define RTC_OFFSET_CENTURY              0x32        
#define RTC_OFFSET_CENTURY_DS          0x148

#define REGISTER_B_DAYLIGHT_SAVINGS_TIME        (1 << 0)
#define REGISTER_B_24HOUR_MODE                  (1 << 1)
#define REGISTER_B_ENABLE_ALARM_INTERRUPT       (1 << 5)
#define REGISTER_B_ENABLE_PERIODIC_INTERRUPT    ((1 << 6) | REGISTER_B_24HOUR_MODE)

VOID
HalpIoDelay (
    VOID
    );

#define IO_DELAY() HalpIoDelay()

//
// CMOS-related function prototypes
//

UCHAR
CMOS_READ_BCD (
    UCHAR Address
    );

VOID
CMOS_WRITE_BCD (
    UCHAR Address,
    UCHAR Value
    );

VOID
HalpAcquireCmosSpinLockAndWait(
    VOID
    );

//
// Inline functions
//

__inline
UCHAR
BIN_TO_BCD (
    UCHAR Value
    )

/*++

Routine Description:

    This function converts an 8-bit binary value to an packed, 8-bit,
    two-digit BCD value.

Arguments:

    Value - supplies the binary value to convert.

Return Value:

    Returns a two-digit packed BCD representation of Value.

--*/

{
    UCHAR tens;
    UCHAR units;

    tens = Value / 10;
    units = Value % 10;

    return (tens << 4) + units;
}

__inline
UCHAR
BCD_TO_BIN (
    UCHAR Value
    )

/*++

Routine Description:

    This function converts a packed, 8-bit, two-digit BCD value to an
    8-bit binary value.

Arguments:

    Value - supplies the BCD value to convert.

Return Value:

    Returns a binary representation of Value.

--*/

{
    UCHAR tens;
    UCHAR units;

    tens = (Value >> 4) & 0x0F;
    units = Value & 0x0F;

    return tens * 10 + units;
}

__inline
UCHAR
CMOS_READ (
    UCHAR Address
    )

/*++

Routine Description:

    This function reads a CMOS byte.

Arguments:

    Address - supplies the CMOS address of the value to retrieve.

Return Value:

    Returns the value residing in CMOS at Address.

--*/

{
    UCHAR data;
    UCHAR oldAddress;

    //
    // Record the current control port contents, write the address,
    // read the data, and restore the control port contents.
    //

    oldAddress = READ_PORT_UCHAR(CMOS_ADDRESS_PORT);

    WRITE_PORT_UCHAR(CMOS_ADDRESS_PORT,Address);
    IO_DELAY();

    data = READ_PORT_UCHAR(CMOS_DATA_PORT);
    WRITE_PORT_UCHAR(CMOS_ADDRESS_PORT,oldAddress);
    IO_DELAY();

    return data;
}

__inline
VOID
CMOS_WRITE (
    UCHAR Address,
    UCHAR Data
    )

/*++

Routine Description:

    This function writes a CMOS byte.

Arguments:

    Address - supplies the CMOS address of the value to retrieve.

    Data - supplies the value to write at the supplied address.

Return Value:

    None.

--*/

{
    UCHAR oldAddress;

    //
    // Record the current control port contents, write the address,
    // write the data, and restore the control port contents.
    //

    oldAddress = READ_PORT_UCHAR(CMOS_ADDRESS_PORT);

    WRITE_PORT_UCHAR(CMOS_ADDRESS_PORT,Address);
    IO_DELAY();

    WRITE_PORT_UCHAR(CMOS_DATA_PORT,Data);
    WRITE_PORT_UCHAR(CMOS_ADDRESS_PORT,oldAddress);
    IO_DELAY();
}

__inline
VOID
WRITE_PORT_USHORT_PAIR (
    IN PUCHAR LsbPort,
    IN PUCHAR MsbPort,
    IN USHORT Value
    )

/*++

Routine Description:

    This function retrieves a USHORT value by reading two UCHAR values,
    each from one of two supplied 8 bit ports.

    NOTE - the LsbPort is read first, followed by the MsbPort.  

Arguments:

    LsbPort - supplies the port address from which to retrieve the
              least significant UCHAR value.

    MsbPort - supplies the port address from which to retrieve the
              most significant UCHAR value.

Return Value:

    Returns the resultant USHORT value.

--*/

{
    WRITE_PORT_UCHAR(LsbPort,(UCHAR)Value);
    IO_DELAY();
    WRITE_PORT_UCHAR(MsbPort,(UCHAR)(Value >> 8));
}

__inline
USHORT
READ_PORT_USHORT_PAIR (
    IN PUCHAR LsbPort,
    IN PUCHAR MsbPort
    )

/*++

Routine Description:

    This function retrieves a USHORT value by reading two UCHAR values,
    each from one of two supplied 8 bit ports.

    NOTE - the LsbPort is read first, followed by the MsbPort.  

Arguments:

    LsbPort - supplies the port address from which to retrieve the
              least significant UCHAR value.

    MsbPort - supplies the port address from which to retrieve the
              most significant UCHAR value.

Return Value:

    Returns the resultant USHORT value.

--*/

{
    UCHAR lsByte;
    UCHAR msByte;

    lsByte = READ_PORT_UCHAR(LsbPort);
    IO_DELAY();
    msByte = READ_PORT_UCHAR(MsbPort);

    return (USHORT)lsByte | ((USHORT)msByte << 8);
}

extern ULONG HalpCmosCenturyOffset;
extern UCHAR HalpRtcRegA;
extern UCHAR HalpRtcRegB;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\ixcmos.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ixcmos.c

Abstract:

    Procedures necessary to access CMOS/ECMOS information.

Author:

    David Risner (o-ncrdr) 20 Apr 1992

Revision History:

    Landy Wang (corollary!landy) 04 Dec 1992
    - Move much code from ixclock.asm to here so different HALs
      can reuse the common functionality.

    Forrest Foltz (forrestf) 24-Oct-2000
        Ported ixcmos.asm to ixcmos.c

--*/

#include "halcmn.h"

ULONG HalpHardwareLockFlags;

//
// Module-specific types
// 

typedef UCHAR (*READ_CMOS_CHAR)(ULONG Address);
typedef VOID (*WRITE_CMOS_CHAR)(ULONG Address, UCHAR Data);

typedef struct _CMOS_BUS_PARAMETERS {
    ULONG MaximumAddress;
    READ_CMOS_CHAR ReadFunction;
    WRITE_CMOS_CHAR WriteFunction;
} CMOS_BUS_PARAMETERS, *PCMOS_BUS_PARAMETERS;

//
// External data
//

extern KSPIN_LOCK HalpSystemHardwareLock;

//
// Local prototypes
//

UCHAR
HalpCmosReadByte(
    ULONG Address
    );

VOID
HalpCmosWriteByte(
    ULONG Address,
    UCHAR Data
    );

UCHAR
HalpECmosReadByte(
    ULONG Address
    );

VOID
HalpECmosWriteByte(
    ULONG Address,
    UCHAR Data
    );

UCHAR
HalpGetCmosCenturyByte (
    VOID
    );

ULONG
HalpGetSetCmosData (
    IN ULONG SourceLocation,
    IN ULONG SourceAddress,
    IN PVOID ReturnBuffer,
    IN ULONG ByteCount,
    IN BOOLEAN Write
    );

VOID
HalpSetCmosCenturyByte (
    UCHAR Century
    );

//
// Local data
//

//
// Describes each of the CMOS types
// 

CMOS_BUS_PARAMETERS HalpCmosBusParameterTable[] = {
    {   0xFF, HalpCmosReadByte,  HalpCmosWriteByte  },
    { 0xFFFF, HalpECmosReadByte, HalpECmosWriteByte }
};

//
// Contains the offset to the CMOS century information
//

ULONG HalpCmosCenturyOffset;

//
// HalpRebootNow is a reboot vector.  Set in an MP system to cause any
// processors that might be looping in HalpAcquireCmosSpinLock to transfer
// control to the vector in HalpRebootNow.
//

VOID (*HalpRebootNow)(VOID);

ULONG
HalpGetCmosData (
    IN ULONG SourceLocation,
    IN ULONG SourceAddress,
    IN PVOID ReturnBuffer,
    IN ULONG ByteCount
    )

/*++

Routine Description:

   This routine reads the requested number of bytes from CMOS/ECMOS and
   stores the data read into the supplied buffer in system memory.  If
   the requested data amount exceeds the allowable extent of the source
   location, the return data is truncated.

Arguments:

    SourceLocation - where data is to be read from CMOS or ECMOS
                        0 - CMOS, 1 - ECMOS

    SourceAddress - address in CMOS/ECMOS where data is to be transferred

    ReturnBuffer - address in system memory for data to transfer

    ByteCount - number of bytes to be read

Returns:

    Number of byte actually read.

--*/

{
    return HalpGetSetCmosData(SourceLocation,
                              SourceAddress,
                              ReturnBuffer,
                              ByteCount,
                              FALSE);
}

ULONG
HalpSetCmosData (
    IN ULONG SourceLocation,
    IN ULONG SourceAddress,
    IN PVOID ReturnBuffer,
    IN ULONG ByteCount
    )

/*++

Routine Description:

   This routine writes the requested number of bytes to CMOS/ECMOS.

Arguments:

    SourceLocation - where data is to be written from CMOS or ECMOS
                        0 - CMOS, 1 - ECMOS

    SourceAddress - address in CMOS/ECMOS where data is to be transferred

    ReturnBuffer - address in system memory for data to transfer

    ByteCount - number of bytes to be written

Returns:

    Number of byte actually read.

--*/

{
    return HalpGetSetCmosData(SourceLocation,
                              SourceAddress,
                              ReturnBuffer,
                              ByteCount,
                              TRUE);
}

ULONG
HalpGetSetCmosData (
    IN ULONG SourceLocation,
    IN ULONG RangeStart,
    IN PVOID Buffer,
    IN ULONG ByteCount,
    IN BOOLEAN Write
    )

/*++

Routine Description:

   This routine reads the requested number of bytes from CMOS/ECMOS and
   stores the data read into the supplied buffer in system memory.  If
   the requested data amount exceeds the allowable extent of the source
   location, the return data is truncated.

Arguments:

    SourceLocation - where data is to be read from CMOS or ECMOS
                        0 - CMOS, 1 - ECMOS

    RangeStart - address in CMOS/ECMOS where data is to be transferred

    Buffer - address in system memory for data to transfer

    ByteCount - number of bytes to be transferred

    Write - Indicates whether the operation is a read or a write

Returns:

    Number of byte actually transferred

--*/

{
    ULONG address;
    PCHAR buffer;
    ULONG last;
    PCMOS_BUS_PARAMETERS cmosParameters;

    //
    // Validate the "bus type" and get a pointer to the parameters
    // for the corresponding CMOS "bus".
    //

    if (SourceLocation != 0 && SourceLocation != 1) {
        return 0;
    }

    cmosParameters = &HalpCmosBusParameterTable[SourceLocation];

    //
    // Limit the range of bytes to that which the cmos bus can accomodate.
    // 

    address = RangeStart;
    buffer = Buffer;

    last = address + ByteCount - 1;
    if (last > cmosParameters->MaximumAddress) {
        last = cmosParameters->MaximumAddress;
    }

    //
    // Take the cmos spin lock, perform the transfer, and release the lock.
    //

    HalpAcquireCmosSpinLock();

    while (address <= last) {
        if (Write == FALSE) {
            *buffer = cmosParameters->ReadFunction(address);
        } else {
            cmosParameters->WriteFunction(address,*buffer);
        }

        address += 1;
        buffer += 1;
    }
    HalpReleaseCmosSpinLock();

    //
    // Calculate and return the number of bytes trasferred.
    // 

    return last - RangeStart;
}


UCHAR
HalpCmosReadByte(
    ULONG Address
    )

/*++

Routine Description:

   This routine reads a single byte from cmos.

Arguments:

    Address - The CMOS address from which to retrieve the byte.

Returns:

    The byte that was read.

--*/

{
    return CMOS_READ((UCHAR)Address);
}

VOID
HalpCmosWriteByte(
    ULONG Address,
    UCHAR Data
    )

/*++

Routine Description:

   This routine writes a single byte to cmos.

Arguments:

    Address - The CMOS address at which to write the byte

    Data - The byte to write

Returns:

    Nothing

--*/

{
    CMOS_WRITE((UCHAR)Address,Data);
}

UCHAR
HalpECmosReadByte(
    ULONG Address
    )

/*++

Routine Description:

   This routine reads a single byte from extended cmos (ECMOS).

Arguments:

    Address - The CMOS address from which to retrieve the byte.

Returns:

    The byte that was read.

--*/

{
    UCHAR data;

    WRITE_PORT_USHORT_PAIR (ECMOS_ADDRESS_PORT_LSB,
                            ECMOS_ADDRESS_PORT_MSB,
                            (USHORT)Address);
    IO_DELAY();

    data = READ_PORT_UCHAR(ECMOS_DATA_PORT);
    IO_DELAY();

    return data;
}

VOID
HalpECmosWriteByte(
    ULONG Address,
    UCHAR Data
    )

/*++

Routine Description:

   This routine writes a single byte to extended cmos (ECMOS).

Arguments:

    Address - The CMOS address at which to write the byte

    Data - The byte to write

Returns:

    Nothing

--*/

{
    WRITE_PORT_USHORT_PAIR (ECMOS_ADDRESS_PORT_LSB,
                            ECMOS_ADDRESS_PORT_MSB,
                            (USHORT)Address);
    IO_DELAY();

    WRITE_PORT_UCHAR(ECMOS_DATA_PORT,Data);
    IO_DELAY();
}

VOID
HalpReadCmosTime(
    PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine reads current time from CMOS memory and stores it
    in the TIME_FIELDS structure passed in by caller.

Arguments:

    TimeFields - A pointer to the TIME_FIELDS structure.

Return Value:

    None.

--*/

{
    USHORT year;

    HalpAcquireCmosSpinLockAndWait();

    //
    // The RTC is only accurate to within one second.  So add a
    // half a second so that we are closer, on average, to the right
    // answer.
    //

    TimeFields->Milliseconds = 500;
    TimeFields->Second = CMOS_READ_BCD(RTC_OFFSET_SECOND);
    TimeFields->Minute = CMOS_READ_BCD(RTC_OFFSET_MINUTE);
    TimeFields->Hour = CMOS_READ_BCD(RTC_OFFSET_HOUR);
    TimeFields->Weekday = CMOS_READ_BCD(RTC_OFFSET_DAY_OF_WEEK);
    TimeFields->Day = CMOS_READ_BCD(RTC_OFFSET_DATE_OF_MONTH);
    TimeFields->Month = CMOS_READ_BCD(RTC_OFFSET_MONTH);

    year = BCD_TO_BIN(HalpGetCmosCenturyByte());
    year = year * 100 + CMOS_READ_BCD(RTC_OFFSET_YEAR);

    if (year >= 1900 && year < 1920) {

        //
        // Compensate for the century field
        //

        year += 100;
    }

    TimeFields->Year = year;

    HalpReleaseCmosSpinLock();
}

VOID
HalpWriteCmosTime (
    PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

   This routine writes current time from TIME_FIELDS structure
   to CMOS memory.

Arguments:

   TimeFields - A pointer to the TIME_FIELDS structure.

Return Value:

   None.

--*/

{
    ULONG year;

    HalpAcquireCmosSpinLockAndWait();

    CMOS_WRITE_BCD(RTC_OFFSET_SECOND,(UCHAR)TimeFields->Second);
    CMOS_WRITE_BCD(RTC_OFFSET_MINUTE,(UCHAR)TimeFields->Minute);
    CMOS_WRITE_BCD(RTC_OFFSET_HOUR,(UCHAR)TimeFields->Hour);
    CMOS_WRITE_BCD(RTC_OFFSET_DAY_OF_WEEK,(UCHAR)TimeFields->Weekday);
    CMOS_WRITE_BCD(RTC_OFFSET_DATE_OF_MONTH,(UCHAR)TimeFields->Day);
    CMOS_WRITE_BCD(RTC_OFFSET_MONTH,(UCHAR)TimeFields->Month);

    year = TimeFields->Year;
    if (year > 9999) {
        year = 9999;
    }

    HalpSetCmosCenturyByte(BIN_TO_BCD((UCHAR)(year / 100)));
    CMOS_WRITE_BCD(RTC_OFFSET_YEAR,(UCHAR)(year % 100));

    HalpReleaseCmosSpinLock();
}

VOID
HalpAcquireCmosSpinLockAndWait (
    VOID
    )

/*++

Routine Description:

    This routine acquires the CMOS spinlock, then waits for the CMOS
    BUSY flag to be clear.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG count;
    ULONG value;

    //
    // Acquire the cmos spinlock and wait until it is not busy.  While
    // waiting, periodically release and re-acquire the spinlock.
    //

    HalpAcquireCmosSpinLock();
    count = 0;
    while (TRUE) {

        value = CMOS_READ(CMOS_STATUS_A);
        if ((value & CMOS_STATUS_BUSY) == 0) {
            return;
        }

        count += 1;
        if (count == 100) {

            count = 0;
            HalpReleaseCmosSpinLock();
            HalpAcquireCmosSpinLock();
        }
    }
}

VOID
HalpReleaseCmosSpinLock (
    VOID
    )

/*++

Routine Description:

   This routine acquires the spin lock used to protect access to various
   pieces of hardware.

Arguments:

    None

Returns:

    Nothing

--*/

{
    ULONG flags;

    flags = HalpHardwareLockFlags;
#if !defined(NT_UP)
    KeReleaseSpinLockFromDpcLevel(&HalpSystemHardwareLock);
#endif
    HalpRestoreInterrupts(flags);
}

VOID
HalpAcquireCmosSpinLock (
    VOID
    )

/*++

Routine Description:

   This routine acquires the spin lock used to protect access to various
   pieces of hardware.

Arguments:

    None

Returns:

    Nothing

--*/

{
    BOOLEAN acquired;
    ULONG flags;
    KIRQL oldIrql;

#if defined(NT_UP)
    HalpHardwareLockFlags = HalpDisableInterrupts();
#else
    while (TRUE) {

        flags = HalpDisableInterrupts();
        acquired = KeTryToAcquireSpinLockAtDpcLevel(&HalpSystemHardwareLock);
        if (acquired != FALSE) {
            break;
        }
        HalpRestoreInterrupts(flags);

        while (KeTestSpinLock(&HalpSystemHardwareLock) == FALSE) {
            if (HalpRebootNow != NULL) {
                HalpRebootNow();
            }
            PAUSE_PROCESSOR;
        }
    }

    HalpHardwareLockFlags = flags;
#endif
}

VOID
HalpAcquireSystemHardwareSpinLock (
    VOID
    )

/*++

Routine Description:

   This routine acquires the spin lock used to protect access to various
   pieces of hardware.  It is a synonym of HalpAcquireCmosSpinLock().

Arguments:

    None

Returns:

    Nothing

--*/

{
    HalpAcquireCmosSpinLock();
}

VOID
HalpReleaseSystemHardwareSpinLock (
    VOID
    )

/*++

Routine Description:

   This routine releases the spin lock used to protect access to various
   pieces of hardware.  It is a synonym of HalpReleaseCmosSpinLock().

Arguments:

    None

Returns:

    Nothing

--*/

{
    HalpReleaseCmosSpinLock();
}

UCHAR
HalpGetCmosCenturyByte (
    VOID
    )

/*++

Routine Description:

   This routine retrieves the century byte from the CMOS.

   N.B. The cmos spinlock must be acquired before calling this function.

Arguments:

    None

Returns:

    The century byte.

--*/

{
    UCHAR value;
    UCHAR oldStatus;
    UCHAR centuryByte;

    //
    // Make sure the century offset is initialized
    //

    ASSERT(HalpCmosCenturyOffset != 0);

    if ((HalpCmosCenturyOffset & CMOS_BANK_1) != 0) {

        //
        // Perform a bank 1 read
        //

        oldStatus = CMOS_READ(CMOS_STATUS_A);
        value = oldStatus | CMOS_STATUS_BANK1;
        CMOS_WRITE(CMOS_STATUS_A,value);
        centuryByte = CMOS_READ((UCHAR)HalpCmosCenturyOffset);
        CMOS_WRITE(CMOS_STATUS_A,oldStatus);

    } else {
        centuryByte = CMOS_READ((UCHAR)HalpCmosCenturyOffset);
    }

    return centuryByte;
}

VOID
HalpSetCmosCenturyByte (
    UCHAR Century
    )

/*++

Routine Description:

   This routine sets the century byte in the CMOS.

   N.B. The cmos spinlock must be acquired before calling this function.

Arguments:

    Century - The century byte to set

Returns:

    Nothing

--*/

{
    UCHAR value;
    UCHAR oldStatus;

    //
    // Make sure the century offset is initialized
    //

    ASSERT(HalpCmosCenturyOffset != 0);

    if ((HalpCmosCenturyOffset & CMOS_BANK_1) != 0) {

        //
        // Perform a bank 1 write
        //

        oldStatus = CMOS_READ(CMOS_STATUS_A);
        value = oldStatus | CMOS_STATUS_BANK1;
        CMOS_WRITE(CMOS_STATUS_A,value);
        CMOS_WRITE((UCHAR)HalpCmosCenturyOffset,Century);
        CMOS_WRITE(CMOS_STATUS_A,oldStatus);

    } else {
        CMOS_WRITE((UCHAR)HalpCmosCenturyOffset,Century);
    }
}

VOID
HalpFlushTLB (
    VOID
    )

/*++

Routine Description:

    Flushes the current TLB.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG flags;
    PKPCR pcr;
    PKPRCB prcb;
    ULONG64 cr3;
    ULONG64 cr4;
    ULONG64 oldCr4;

    flags = HalpDisableInterrupts();

    cr3 = ReadCR3();

    pcr = KeGetPcr();
    prcb = pcr->CurrentPrcb;

    //
    // Note: the original code (ixcmos.asm) had differing behavior based
    //       on whether this was CPU 0.  That behavior is mimicked here.
    //       It would be good to find out why this is done.
    //

    if (prcb->Number == 0) {
        WriteCR3(cr3);
    } else {
        cr4 = ReadCR4();
        WriteCR4(cr4 & ~CR4_PGE);
        WriteCR3(cr3);
        WriteCR4(cr4);
    }

    HalpRestoreInterrupts(flags);
}

               
VOID
HalpCpuID (
    IN ULONG  Function,
    OUT PULONG Eax,
    OUT PULONG Ebx,
    OUT PULONG Ecx,
    OUT PULONG Edx
    )

/*++

Routine Description:

    This function executes a cpu id and returns the result as found in
    registers eax, ebx, ecx and edx.

Arguments:

    Function - supplies the CPUID function to execute.

    Eax - supplies a pointer to the storage to contain the contents of eax.

    Eax - supplies a pointer to the storage to contain the contents of ebx.

    Eax - supplies a pointer to the storage to contain the contents of ecx.

    Eax - supplies a pointer to the storage to contain the contents of edx.

Return Value:

    None.

--*/

{
    CPU_INFO cpuInfo;

    KiCpuId (Function,&cpuInfo);

    *Eax = cpuInfo.Eax;
    *Ebx = cpuInfo.Ebx;
    *Ecx = cpuInfo.Ecx;
    *Edx = cpuInfo.Edx;
}


UCHAR
CMOS_READ_BCD (
    UCHAR Address
    )

/*++

Routine Description:

    This function reads a CMOS byte as a two-digit packed BCD value and
    returns its binary representation.

Arguments:

    Address - supplies the CMOS address of the BCD value to retrieve.

Return Value:

    Returns the binary representation of the BCD value residing in CMOS
    at Address.

--*/

{
    UCHAR value;

    value = CMOS_READ(Address);
    return BCD_TO_BIN(value);
}

VOID
CMOS_WRITE_BCD (
    UCHAR Address,
    UCHAR Value
    )

/*++

Routine Description:

    This function writes a CMOS byte as a two-digit packed BCD value.

Arguments:

    Address - supplies the CMOS address of the BCD value to write.

    Value - supplies the binary representation of the value to write in
            CMOS.

Return Value:

    None.

--*/

{
    UCHAR value;

    ASSERT(Value <= 99);

    value = BIN_TO_BCD(Value);
    CMOS_WRITE(Address,value);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\mpirql.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mpirql.c

Abstract:

    This module implements support for int<->vector translation.

Author:

    Forrest Foltz (forrestf) 1-Dec-2000

Environment:

    Kernel mode only.

Revision History:

--*/


#include "halcmn.h"

#define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))

#define NUM_VECTORS 0x100

typedef struct _VECTOR_INIT {
    ULONG Vector;
    KIRQL Irql;
} VECTOR_INIT, *PVECTOR_INIT;

VECTOR_INIT HalpVectorInit[] = {
    { ZERO_VECTOR, 0 },
    { APC_VECTOR, APC_LEVEL },
    { DPC_VECTOR, DISPATCH_LEVEL },
    { APIC_GENERIC_VECTOR, PROFILE_LEVEL },
    { APIC_CLOCK_VECTOR, CLOCK_LEVEL },
    { APIC_IPI_VECTOR, IPI_LEVEL },
    { POWERFAIL_VECTOR, POWER_LEVEL }
};

//
// HalpVectorToIRQL maps interrupt vectors to NT IRQLs
//

KIRQL HalpVectorToIRQL[NUM_VECTORS];

//
// HalpVectorToINTI maps interrupt vector to EISA interrupt level
// on a per-node (cluster) basis.  This can be thought of as a
// two-dimensional array.
//

USHORT HalpVectorToINTI[MAX_NODES * NUM_VECTORS];


VOID
HalpInitializeIrqlTables (
    VOID
    )

/*++

Routine Description:

    This routine is responsible for initializing the HalpVectorToINTI[] and
    HalpVectorToIRQL[] tables, based on the contents of the HalpVectorInit[]
    array.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG count;
    PVECTOR_INIT vectorInit;

    //
    // Initialize every element of HalpVectorToINTI to 0xFFFF
    //

    for (count = 0; count < ARRAY_SIZE(HalpVectorToINTI); count++) {
        HalpVectorToINTI[count] = 0xFFFF;
    }

    //
    // Build HalpVectorToIrql based on the contents of HalpVectorInit.
    // Any unused entries are initialized to (KIRQL)0xFF.
    //

    for (count = 0; count < ARRAY_SIZE(HalpVectorToIRQL); count++) {
        HalpVectorToIRQL[count] = (KIRQL)0xFF;
    }

    for (count = 0; count < ARRAY_SIZE(HalpVectorInit); count++) {
        vectorInit = &HalpVectorInit[count];
        HalpVectorToIRQL[vectorInit->Vector] = vectorInit->Irql;
    }




}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\mcheck.c ===
/*++

    Copyright (c) 2002  Microsoft Corporation

Module Name:

    mcheck.c

Abstract:

    This module implments machine check functions for the AMD64 platform.

Author:

    David N. Cutler (davec) 18-May-2002

Environment:

    Kernel mode.

--*/

#include <bugcodes.h>
#include <halp.h>
#include <stdlib.h>
#include <stdio.h>
#include <nthal.h>

//
// Define retry counts.
//

#define MAX_CACHE_LIMIT 3
#define MIN_TIME_TO_CLEAR (2 * 1000 * 1000 * 100)

//
// Default MCA bank enable mask.
//

#define MCA_DEFAULT_BANK_ENABLE 0xFFFFFFFFFFFFFFFF

//
// MCG_CTL enable mask.
//

#define MCA_MCGCTL_ENABLE_LOGGING 0xffffffffffffffff

//
// MCA architecture related definitions.
//

#define MCA_NUMBER_REGISTERS 4          // number of registers per bank

//
// Bit masks for MCA_CAP register.
//

#define MCA_COUNT_MASK 0xFF             // number of banks
#define MCG_CTL_PRESENT 0x100           // control register present 

//
// Bit masks for MCG_STATUS register.
//

#define MCG_RESTART_RIP_VALID 0x1       // restart RIP valid
#define MCG_ERROR_RIP_VALID 0x2         // error RIP valid
#define MCG_MC_IN_PROGRESS 0x4          // machine check in progress

//
// Define machine check state variables.
//

BOOLEAN McaBlockErrorClearing = FALSE;
PVOID McaDeviceContext;
PDRIVER_MCA_EXCEPTION_CALLBACK McaDriverExceptionCallback;
KERNEL_MCA_DELIVERY McaWmiCallback;     // WMI corrected MC handler
BOOLEAN McaInterfaceLocked;
FAST_MUTEX McaMutex;
BOOLEAN McaNoBugCheck = FALSE;
ULONG McaEnableCmc;
UCHAR McaNumberOfBanks;
KAFFINITY McaSavedAffinity = 0;
ULONG McaSavedBankNumber = 0;
ULONG64 McaSavedStatus = 0;
ULONG McaStatusCount = 0;
ULONG64 McaSavedTimeStamp = 0;

//
// Define external references.
//

extern KAFFINITY HalpActiveProcessors;
extern WCHAR rgzSessionManager[];
extern WCHAR rgzEnableMCA[];
extern WCHAR rgzEnableCMC[];
extern WCHAR rgzNoMCABugCheck[];

//
// Define forward referenced prototypes.
//

VOID
HalpMcaInit (
    VOID
    );

VOID
HalpMcaLockInterface (
    VOID
    );

NTSTATUS
HalpMcaReadProcessorException (
    IN OUT PMCA_EXCEPTION  Exception,
    IN BOOLEAN  NonRestartableOnly
    );

NTSTATUS
HalpMcaReadRegisterInterface (
    IN ULONG BankNumber,
    IN OUT PMCA_EXCEPTION Exception
    );

VOID
HalpMcaUnlockInterface (
    VOID
    );

#pragma alloc_text(PAGELK, HalpMcaCurrentProcessorSetConfig)
#pragma alloc_text(PAGE, HalpGetMcaLog)
#pragma alloc_text(INIT, HalpMcaInit)
#pragma alloc_text(PAGE, HalpMcaLockInterface)
#pragma alloc_text(PAGE, HalpMceRegisterKernelDriver)
#pragma alloc_text(PAGE, HalpMcaRegisterDriver)
#pragma alloc_text(PAGE, HalpMcaUnlockInterface)
#pragma alloc_text(PAGE, HalpGetMceInformation)

VOID
HalpMcaInit (
    VOID
    )

/*++

Routine Description:

    This routine initializes the machine check configuration for the system.

Arguments:

    None.

Return Value:

    None.

--*/

{

    KAFFINITY ActiveProcessors;
    KAFFINITY Affinity;
    ULONG MCAEnabled;
    KIRQL OldIrql;
    RTL_QUERY_REGISTRY_TABLE Parameters[4];

    //
    // Initialize the fast mutext that is used to synchronize access to
    // machine check information.
    //

    ExInitializeFastMutex(&McaMutex);

    //
    // Clear registered driver information.
    //

    McaDriverExceptionCallback = NULL;
    McaDeviceContext = NULL;
    McaWmiCallback = NULL;

    //
    // Get the machine check configuration enables from the registry.
    //
    // N.B. It is assumed that all AMD64 chip implementations support MCE
    //      and MCA.
    //
    // N.B. MCA is enabled by default. MCA can be disabled via the registry.
    //

    ASSERT((HalpFeatureBits & HAL_MCA_PRESENT) != 0);
    ASSERT((HalpFeatureBits & HAL_MCE_PRESENT) != 0);

    RtlZeroMemory(Parameters, sizeof(Parameters));

    MCAEnabled = TRUE;
    Parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[0].Name = &rgzEnableMCA[0];
    Parameters[0].EntryContext = &MCAEnabled;
    Parameters[0].DefaultType = REG_DWORD;
    Parameters[0].DefaultData = &MCAEnabled;
    Parameters[0].DefaultLength = sizeof(ULONG);

    McaNoBugCheck = FALSE;
    Parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[1].Name = &rgzNoMCABugCheck[0];
    Parameters[1].EntryContext = &McaNoBugCheck;
    Parameters[1].DefaultType = REG_DWORD;
    Parameters[1].DefaultData = &McaNoBugCheck;
    Parameters[1].DefaultLength = sizeof(ULONG);

    McaEnableCmc = 60; // default polling interval, in seconds
    Parameters[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[2].Name = &rgzEnableCMC[0];
    Parameters[2].EntryContext = &McaEnableCmc;
    Parameters[2].DefaultType = REG_DWORD;
    Parameters[2].DefaultData = &McaEnableCmc;
    Parameters[2].DefaultLength = sizeof(ULONG);

    RtlQueryRegistryValues(RTL_REGISTRY_CONTROL | RTL_REGISTRY_OPTIONAL,
                           rgzSessionManager,
                           &Parameters[0],
                           NULL,
                           NULL);

    //
    // If MCA support is enabled, then initialize the MCA configuration.
    // Otherwise, disable MCA and MCE support.
    //

    if (MCAEnabled == FALSE) {
        HalpFeatureBits &= ~(HAL_MCA_PRESENT | HAL_MCE_PRESENT);

        McaEnableCmc = HAL_CMC_DISABLED; // disable CMC too

    } else {

        //
        // Make sure the value for CMCEnabled is valid. If less than 0, set it to
        // 0 (disabled). If greater than 0, make sure polling isn't too frequent.
        //
    
        if ( (LONG)McaEnableCmc <= 0 ) {
            McaEnableCmc = HAL_CMC_DISABLED;
        } else if ( McaEnableCmc < 15 ) {
            McaEnableCmc = 15;
        }

        //
        // Read the number of banks.
        //

        McaNumberOfBanks = (UCHAR)RDMSR(MSR_MCG_CAP) & MCA_COUNT_MASK;

        //
        // Initialize the machine check configuration for each processor in
        // the host system.
        //
    
        ActiveProcessors = HalpActiveProcessors;
        Affinity = 1;
        do {
            if (ActiveProcessors & Affinity) {
                ActiveProcessors &= ~Affinity;
                KeSetSystemAffinityThread(Affinity);
                OldIrql = KfRaiseIrql(HIGH_LEVEL);
                HalpMcaCurrentProcessorSetConfig();
                KeLowerIrql(OldIrql);
            }

            Affinity <<= 1;
        } while (ActiveProcessors);
    
        KeRevertToUserAffinityThread();
    }

    return;
}

VOID
HalHandleMcheck (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )

/*++

Routine Description:

    This function is called by the machine check exception dispatch code to
    process a machine check exception.

    N.B. Machine check in progress is not cleared by this function. If the
         machine check is subsequently restartable as the result of software
         fixup, then machine check in progress will be cleared by the machine
         check exception dispatch code. This makes the window between clearing
         the machine check and continuing execution as small as posssible. If
         a machine check occurs within this window, then a recursion onto the
         machine check stack will occur.

Arguments:

    TrapFrame - Supplies a pointer to the machine check trap frame.

    ExceptionFrame - Supplies a pointer to the machine check exception
        frame.

Return Value:

    None.

--*/

{

    ERROR_SEVERITY ErrorCode;
    MCA_EXCEPTION Exception;
    NTSTATUS Status;

    //
    // Block clearing of status state and attempt to find a nonrestartable
    // machine check. 
    //

    ASSERT((RDMSR(MSR_MCG_STATUS) & MCG_MC_IN_PROGRESS) != 0);

    McaBlockErrorClearing = TRUE;
    Exception.VersionNumber = 1;
    Status = HalpMcaReadProcessorException(&Exception, TRUE);

    //
    // Check if a nonrestartable machine check was found.
    //

    if (Status == STATUS_SEVERITY_ERROR) {

        //
        // A nonrestartable machine check was located. If a driver has
        // registered for a callback, then call the driver to see if it
        // can resolve the machine check.
        //

        ErrorCode = ErrorFatal;
        if (McaDriverExceptionCallback != NULL) {
            ErrorCode = McaDriverExceptionCallback(McaDeviceContext,
                                                   TrapFrame,
                                                   ExceptionFrame,
                                                   &Exception);
        }

        //
        // If an uncorrected error was encountered and bug checks are not being
        // suppressed, then bug check the system.
        //

        if ((ErrorCode != ErrorCorrected) && (McaNoBugCheck == FALSE)) {
            KeBugCheckEx(MACHINE_CHECK_EXCEPTION,
                         Exception.u.Mca.BankNumber,
                         (ULONG64)&Exception,
                         (ULONG64)Exception.u.Mca.Status.QuadPart >> 32,
                         (ULONG64)Exception.u.Mca.Status.QuadPart & 0xffffffff);
        }
    }

    //
    // The machine check was either restartable or a driver was registered
    // and the driver was able to recover the operation. Signal the clock
    // routine that it should call the routine to queue a DPC to log the
    // machine check information.
    //
    // NOTE: This used to check for the MCA logging driver being registered.
    // We no longer deliver corrected machine checks to the driver. They only
    // go to WMI.
    //

    McaBlockErrorClearing = FALSE;
    if (McaWmiCallback != NULL) {
        HalpClockMcaQueueDpc = 1;
    }

    return;
}

VOID
HalpMcaCurrentProcessorSetConfig (
    VOID
    )

/*++

Routine Description:

    This function sets the machine check configuration for the current
    processor.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG Bank;
    ULONG64 MciCtl;

    //
    // If MCA is enabled, then initialize the MCA control register and all
    // bank control registers. 
    //

    if ((HalpFeatureBits & HAL_MCA_PRESENT) != 0) {

        //
        // Enable logging all errors in the global control register.
        // 

        ASSERT((RDMSR(MSR_MCG_CAP) & MCG_CTL_PRESENT) != 0);

        WRMSR(MSR_MCG_CTL, MCA_MCGCTL_ENABLE_LOGGING);

        //
        // Enable logging all errors for each bank.
        //

        for (Bank = 0; Bank < McaNumberOfBanks; Bank += 1) {

            MciCtl = MCA_DEFAULT_BANK_ENABLE;

            //
            // Enable machine checks for the bank.
            //

            WRMSR(MSR_MC0_CTL + (Bank * MCA_NUMBER_REGISTERS), MciCtl);
        }

        //
        // Enable MCE bit in CR4.
        //
    
        WriteCR4(ReadCR4() | CR4_MCE);
    }

    return;
}

NTSTATUS
HalpGetMcaLog (
    IN OUT PMCA_EXCEPTION Exception,
    IN ULONG BufferSize,
    OUT PULONG Length
    )

/*++
 
Routine Description:

    This function returns machine check error information for a MCA bank
    that contains an error.

Arguments:

    Exception - Supplies a pointer to a machine check exception log area.

    BufferSize - Supplies the size of the machine check exception log area.

    Length - Supplies a pointer to a variable that receives the machine
       information log.

Return Value:

    STATUS_SUCCESS - if the error data for an MCA bank is copied into the
        exception buffer and the machine check is restartable.

    STATUS_SEVERITY_ERROR - if the error data for an MCA bank is copied
        into the exception buffer and the machine check is not restartable.

    STATUS_NOT_FOUND - if no bank had any error information present.

    STATUS_INVALID_PARAMETER - if the size of the specifed buffer is not
        large enough or the version number is not valid. The length of the
        required buffer is returned.

--*/

{

    KAFFINITY ActiveProcessors;
    KAFFINITY Affinity;
    NTSTATUS Status;
    ULONG64 TimeStamp;

    PAGED_CODE();

    //
    // If MCA support is not enabled, return a failure status. 
    //

    if ((HalpFeatureBits & HAL_MCA_PRESENT) == 0) {
        return STATUS_NOT_FOUND;
    }

    //
    // Don't allow the logging driver to read machine check information.
    // Only WMI is allowed to retrieve this information.
    //

    if ( *(PULONG)Exception != HALP_KERNEL_TOKEN ) {
        return STATUS_NOT_FOUND;
    }

    //
    // If the buffer size is not equal to the MCA exception information
    // record size, then return a failure status.
    //

    if (BufferSize < sizeof(MCA_EXCEPTION)) {

        *Length = sizeof(MCA_EXCEPTION);
        return STATUS_INVALID_PARAMETER;
    }

    Exception->VersionNumber = 1;

    //
    // Scan through the machine check banks on each processor until error
    // information is located or there are no more banks to scan.
    //

    *Length = 0;
    Status = STATUS_NOT_FOUND;
    ActiveProcessors = HalpActiveProcessors;
    HalpMcaLockInterface();
    for (Affinity = 1; ActiveProcessors; Affinity <<= 1) {
        if (ActiveProcessors & Affinity) {
            ActiveProcessors &= ~Affinity;
            KeSetSystemAffinityThread(Affinity);

            //
            // Attempt to find machine check error status information
            // from the MCA banks on the current processor.
            //

            Status = HalpMcaReadProcessorException(Exception, FALSE);

            //
            // Check to determine if any machine check information was found.
            //

            if (Status != STATUS_NOT_FOUND) {

                //
                // If the relative time between this machine check event
                // and the previous machine check event is greater than
                // the minimum time, then reset the machine check identity
                // information.
                // 

                TimeStamp = ReadTimeStampCounter();
                if ((TimeStamp - McaSavedTimeStamp) > MIN_TIME_TO_CLEAR) {
                    McaStatusCount = 0;
                    McaSavedAffinity = Affinity;
                    McaSavedBankNumber = Exception->u.Mca.BankNumber;
                    McaSavedStatus = Exception->u.Mca.Status.QuadPart;
                }

                McaSavedTimeStamp = TimeStamp;

                //
                // Check to determine if the same processor is reporting
                // the same status.
                //

                if ((Affinity == McaSavedAffinity) &&
                    (McaSavedBankNumber == Exception->u.Mca.BankNumber) &&
                    (McaSavedStatus == Exception->u.Mca.Status.QuadPart)) {

                    //
                    // Check to determine if the same error has occurred
                    // more than the cache flush limit. Exceeding the
                    // cache flush limit results in a writeback invalidate
                    // of the cache on the current processor.
                    //

                    McaStatusCount += 1;
                    if (McaStatusCount >= MAX_CACHE_LIMIT) {
                        WritebackInvalidate();
                    } 

                } else {

                    //
                    // This is the first occurrence of the error on the
                    // current processor. Reset the machine check identity
                    // information.
                    //

                    McaStatusCount = 0;
                    McaSavedAffinity = Affinity;
                    McaSavedBankNumber = Exception->u.Mca.BankNumber;
                    McaSavedStatus = Exception->u.Mca.Status.QuadPart;
                }

                //
                // Set the the length of the information, save the time
                // stamp, and break out of the scan.
                //
                //

                *Length = sizeof(MCA_EXCEPTION);
                break;
            }
        }
    }

    //
    // Restore the thread affinity, release the fast mutex, and return
    // the completion status.
    //

    KeRevertToUserAffinityThread();
    HalpMcaUnlockInterface();
    return Status;
}

VOID
HalpMcaLockInterface (
    VOID
    )

/*++

Routine Description:

    This function acquires the MCA fast mutex.

    N.B. This function is exported via HalQueryMcaInterface information
         code.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PAGED_CODE();

    ExAcquireFastMutex(&McaMutex);

#if DBG

    ASSERT(McaInterfaceLocked == FALSE);

    McaInterfaceLocked = TRUE;

#endif
        
}

VOID
HalpMcaQueueDpc (
    VOID
    )

/*++

Routine Description:

    This function is called from the timer tick to tell WMI about a corrected
    machine check.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ASSERT( McaWmiCallback != NULL );

    McaWmiCallback( (PVOID)HALP_KERNEL_TOKEN, McaAvailable, NULL );
    
    return;
}

NTSTATUS
HalpMcaReadProcessorException (
    IN OUT PMCA_EXCEPTION Exception,
    IN BOOLEAN NonRestartableOnly
    )

/*++

Routine Description:

    This function returns error information from the MCA banks on the
    current processor.

Arguments:

    Exception - Supplies a pointer to a MCA exception record.

    NonRestartableOnly - Supplies a boolean variable that determines the type
        of error information returned.

Return Value:

    STATUS_SUCCESS - if the data for the bank registers is copied into the
        exception buffer and the machine check is restartable.

    STATUS_SEVERITY_ERROR - if the data for the bank registers is copied
        into the exception buffer and the machine check is not restartable.

    STATUS_NOT_FOUND - if no bank had any error information present.

--*/

{

    ULONG Bank;
    NTSTATUS Status;

    //
    // Scan the MCA banks on current processor and return the exception
    // information for the first bank reporting an error.
    //

    for (Bank = 0; Bank < McaNumberOfBanks; Bank += 1) {
        Status = HalpMcaReadRegisterInterface(Bank, Exception);

        //
        // If the status is unsuccessful, then the current bank has no
        // error information present.
        //

        if (Status != STATUS_UNSUCCESSFUL) {

            //
            // If the status is success, then the current bank has restartable
            // error information. Otherwise, if the status is severity error,
            // then the current bank has nonrestartable error information.
            //

            if (((Status == STATUS_SUCCESS) &&
                 (NonRestartableOnly == FALSE)) ||
                (Status == STATUS_SEVERITY_ERROR)) {

                return Status;
            }
        }
    }

    return STATUS_NOT_FOUND;
}

NTSTATUS
HalpMcaReadRegisterInterface (
    IN ULONG Bank,
    IN OUT PMCA_EXCEPTION Exception
    )

/*++

Routine Description:

    This function reads the MCA registers from the current processor
    and returns the result in the specified exception structure.

    N.B. This function is exported via HalQueryMcaInterface information
         code.

Arguments:

    Bank - Supplies the MCA bank to be be read.

    Exception - Supplies a pointer to the exception information buffer.

Return Value:

    STATUS_SUCCESS - if the data for the specified bank registers is copied
        into the exception buffer and the machine check is restartable.

    STATUS_SEVERITY_ERROR - if the data for the specified bank registers
        is copied into the exception buffer and the machine check is not
        restartable.

    STATUS_UNSUCCESSFUL - if the specified bank has no error information
        present.

    STATUS_NOT_FOUND - if the specified bank number exceeds the number of
        MCA banks.

    STATUS_INVALID_PARAMETER - if the exception record is of an unknown
        version.

--*/

{

    ULONG BankBase = Bank * MCA_NUMBER_REGISTERS;
    MCI_STATS BankStatus;
    ULONG64 McgStatus;
    NTSTATUS Status;

    //
    // Check for a valid MCA register bank number.
    //

    if (Bank >= McaNumberOfBanks) {
        return STATUS_NOT_FOUND;
    }

    //
    // Check if the exception buffer specifies a correct version number.
    //

    if (Exception->VersionNumber != 1) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Check if any errors are present for the specified bank.
    //
                   
    BankStatus.QuadPart = RDMSR(MSR_MC0_STATUS + BankBase);

    if (BankStatus.MciStatus.Valid == 0) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Set the return status to indicate whether execution can be continued.
    // STATUS_SUCCESS means "An exception was found, and execution can be
    // continued." STATUS_SEVERITY_ERROR means "An exception was found, and
    // execution must not be continued."
    //
    // If a machine check exception is not in progress, then execution can be
    // continued. This happens when polling for hardware-corrected errors
    // finds an error that the hardware corrected without interrupting
    // execution. (Note that this case also applies to an error that was fatal
    // to an earlier boot. The system bugchecked, and initial polling on the
    // reboot is now finding the error.)
    //
    // If a machine check exception is in progress, then execution can be
    // restarted only if the error has been corrected and the necessary
    // restart information is intact (restart RIP valid and processor context
    // not corrupt).
    //
    // This code used to check only for the restart information being valid.
    // These bits do indicate whether there is valid context for restarting
    // from an error, but there has still been an error, and unless we plan
    // to correct the error, we should not continue. Currently we do not do
    // any correction or containment in software, so all uncorrected errors
    // are fatal.
    //

    Status = STATUS_SUCCESS;
    McgStatus = RDMSR(MSR_MCG_STATUS);
    if ( ((McgStatus & MCG_MC_IN_PROGRESS) != 0) &&
         ( (BankStatus.MciStatus.UncorrectedError == 1) ||
           ((McgStatus & MCG_RESTART_RIP_VALID) == 0) ||
           (BankStatus.MciStatus.ContextCorrupt == 1) ) ) {

        Status = STATUS_SEVERITY_ERROR;
    }

    //
    // Fill in the complete exception record.
    //

    Exception->ExceptionType = HAL_MCA_RECORD;
    Exception->TimeStamp.QuadPart = 0;
    Exception->TimeStamp.LowPart = SharedUserData->SystemTime.LowPart;
    Exception->TimeStamp.HighPart = SharedUserData->SystemTime.High1Time;
    Exception->ProcessorNumber = KeGetCurrentProcessorNumber();
    Exception->Reserved1 = 0;
    Exception->u.Mca.BankNumber = (UCHAR)Bank;
    memset(&Exception->u.Mca.Reserved2[0], 0, sizeof(Exception->u.Mca.Reserved2));
    Exception->u.Mca.Status = BankStatus;
    Exception->u.Mca.Address.QuadPart = 0;
    if (BankStatus.MciStatus.AddressValid != 0) {
        Exception->u.Mca.Address.QuadPart = RDMSR(MSR_MC0_ADDR + BankBase);
    }

    Exception->u.Mca.Misc = RDMSR(MSR_MC0_MISC + BankBase);

    //
    // If error clearing is not blocked, then clear the machine check in the
    // bank status register.
    //

    if (McaBlockErrorClearing == FALSE) {
        WRMSR(MSR_MC0_STATUS + BankBase, 0);
    }

    //
    // When the valid bit of status register is cleared, a new buffered
    // error may be written into the bank status registers. A serializing
    // instruction is required to permit the update to complete.
    //

    HalpSerialize();
    return Status;
}

NTSTATUS
HalpMceRegisterKernelDriver(
    IN PKERNEL_ERROR_HANDLER_INFO DriverInfo,
    IN ULONG                      InfoSize
    )
/*++
    Routine Description:
        This routine is called by the kernel (via HalSetSystemInformation)
        to register its presence. This is mostly for WMI callbacks registration.

    Arguments:
        DriverInfo: Contains kernel info about the callbacks and associated objects.

    Return Value:
        Unless a MCA driver is already registered OR one of the two callback
        routines are NULL, this routine returns Success.

    Implementation Notes:
        - the current implementation assumes the kernel registers its callbacks
          earlier than a driver will. The current kernel registration is done by
          WMI and should be done at WMI-Phase 0.
        - the registrations do not consider if the HAL supports or not the MCA
          functionalities. It simply registers the callbacks if no other callback was
          registered before. This allows us to allow some flexibility if a machine event
          functionality is enabled AFTER the hal initialization (e.g. HalpGetFeatureBits())
          through the mean of a registry key or driver event, for example.

--*/

{
    NTSTATUS status;
    
    PAGED_CODE();

    if ( DriverInfo == NULL )  {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Backward compatibility only.
    //

    if ( (DriverInfo->Version != 0) && 
         (DriverInfo->Version > KERNEL_ERROR_HANDLER_VERSION) )  {
        return STATUS_REVISION_MISMATCH;
    }

    //
    // Register Kernel MCA notification.
    //

    status = STATUS_UNSUCCESSFUL;

    HalpMcaLockInterface();
    if ( McaWmiCallback == NULL ) {
        McaWmiCallback = DriverInfo->KernelMcaDelivery;
        status = STATUS_SUCCESS;
    }
    HalpMcaUnlockInterface();

    return status;

} // HalpMceRegisterKernelDriver

NTSTATUS
HalpMcaRegisterDriver (
    IN PMCA_DRIVER_INFO DriverInformation
    )

/*++

Routine Description:

    This function to register or deregister an exception callout.
    It is called via the interface HalSetSystemInformation.

Arguments:

    DriverInformation - Supplies a pointer to the driver information.

Return Value:

    STATUS_SUCCESS is returned if the driver is registered or deregistered.
    Otherwise, STATUS_UNSUCCESSFUL is returned.

--*/

{

    KIRQL OldIrql;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // If MCA is enabled and the driver exception callback is not NULL, then
    // attempt to register the driver. Otherwise, attempt to deregister the
    // driver.
    //

    Status = STATUS_UNSUCCESSFUL;
    if (((HalpFeatureBits & HAL_MCA_PRESENT) != 0) &&
        (DriverInformation->ExceptionCallback != NULL)) {

        //
        // If a driver is not already registered, then register the driver.
        //

        HalpMcaLockInterface();
        if (McaDriverExceptionCallback == NULL) {
            McaDriverExceptionCallback = DriverInformation->ExceptionCallback;
            McaDeviceContext = DriverInformation->DeviceContext;
            Status = STATUS_SUCCESS;
        }

        HalpMcaUnlockInterface();

    } else if (DriverInformation->ExceptionCallback == NULL) {

        //
        // If the driver is deregistering itself, then deregister the driver.
        //

        HalpMcaLockInterface();
        if (McaDeviceContext == DriverInformation->DeviceContext) {
            McaDriverExceptionCallback = NULL;
            McaDeviceContext = NULL;
            Status = STATUS_SUCCESS;
        }

        HalpMcaUnlockInterface();
    }

    return Status;
}

VOID
HalpMcaUnlockInterface (
    VOID
    )

/*++

Routine Description:

    This function releases the MCA fast mutex.

    N.B. This function is exported via HalQueryMcaInterface information
         code.

Arguments:

    None.

Return Value:

    None.

--*/

{

    PAGED_CODE();

#if DBG

    ASSERT(McaInterfaceLocked == TRUE);

    McaInterfaceLocked = FALSE;

#endif
        
    ExReleaseFastMutex(&McaMutex);

}

NTSTATUS
HalpGetMceInformation(
    PHAL_ERROR_INFO ErrorInfo,
    PULONG ErrorInfoLength
    )
/*++
    Routine Description:
        This routine is called by HaliQuerySystemInformation for the HalErrorInformation class.

    Arguments:
        ErrorInfo : pointer to HAL_ERROR_INFO structure.

        ErrorInfoLength : size of the valid memory structure pointed by ErrorInfo.

    Return Value:
        STATUS_SUCCESS if successful
        error status otherwise
--*/
{
    NTSTATUS status;
    ULONG savedVersion;

    PAGED_CODE();

    ASSERT( ErrorInfo != NULL );
    ASSERT( *ErrorInfoLength == sizeof(HAL_ERROR_INFO) );

    //
    // Backward compatibility only.
    //

    if ( (ErrorInfo->Version == 0) || (ErrorInfo->Version > HAL_ERROR_INFO_VERSION) ) {
        return STATUS_REVISION_MISMATCH;
    }

    ASSERT( ErrorInfo->Version == HAL_ERROR_INFO_VERSION );

    //
    // Zero the output structure, then in the few fields that are meaningful.
    //

    savedVersion = ErrorInfo->Version;

    RtlZeroMemory( ErrorInfo, sizeof(HAL_ERROR_INFO) );

    ErrorInfo->Version = savedVersion;

    ErrorInfo->McaMaxSize = sizeof(MCA_EXCEPTION);
    ErrorInfo->CmcMaxSize = sizeof(MCA_EXCEPTION);
    ErrorInfo->McaPreviousEventsCount = 1; // Set to 1 to get WMI to poll immediately

    if ( (HalpFeatureBits & HAL_MCA_PRESENT) != 0 ) {
        ErrorInfo->CmcPollingInterval = McaEnableCmc;
    } else {
        ErrorInfo->CmcPollingInterval = HAL_CMC_DISABLED;
    }

    ErrorInfo->CpePollingInterval = HAL_CPE_DISABLED;

    ErrorInfo->McaKernelToken = HALP_KERNEL_TOKEN;
    ErrorInfo->CmcKernelToken = HALP_KERNEL_TOKEN;

    *ErrorInfoLength = sizeof(HAL_ERROR_INFO);

    return STATUS_SUCCESS;

} // HalpGetMceInformation
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\mpprofil.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mpprofil.c

Abstract:

    This module implements the HAL profiling functions. 

Author:

    Shie-Lin Tzong (shielint) 12-Jan-1990

Environment:

    Kernel mode only.

Revision History:

    bryanwi 20-Sep-90

    Forrest Foltz (forrestf) 28-Oct-2000
        Ported from ixprofil.asm to ixprofil.c

--*/

#include "halcmn.h"
#include "mpprofil.h"

#define APIC_TIMER_ENABLED  (PERIODIC_TIMER | APIC_PROFILE_VECTOR)

#define APIC_TIMER_DISABLED (INTERRUPT_MASKED |     \
                             PERIODIC_TIMER   |     \
                             APIC_PROFILE_VECTOR)

#define TIMER_ROUND(x) ((((x) + 10000 / 2) / 10000) * 10000)

// 
// Platform specifc interface functions
//

PPROFILE_INTERFACE HalpProfileInterface;

#define InitializeProfiling  HalpProfileInterface->InitializeProfiling
#define EnableMonitoring     HalpProfileInterface->EnableMonitoring    
#define DisableMonitoring    HalpProfileInterface->DisableMonitoring 
#define SetInterval          HalpProfileInterface->SetInterval 
#define QueryInformation     HalpProfileInterface->QueryInformation
#define CheckOverflowStatus  HalpProfileInterface->CheckOverflowStatus 

ULONG HalpProfileRunning = FALSE;

VOID (*HalpPerfInterruptHandler)(PKTRAP_FRAME);

#pragma alloc_text(PAGE, HalpQueryProfileInformation)
#pragma alloc_text(INIT, HalpInitializeProfiling)

VOID
HalpInitializeProfiling (
    ULONG Number
    )

/*++

Routine Description:

    This routine is called at phase 1 initialization to initialize profiling
    for each processor in the system.

Arguments:

    Number - Supplies the processor number.

Return Value:

    None.

--*/

{
    if (Number == 0) {

        //
        // Setup profile interface functions of Amd64
        //

        HalpProfileInterface = &Amd64PriofileInterface;
        HalpPerfInterruptHandler = NULL;  
    }

    InitializeProfiling();
}

VOID
HalStartProfileInterrupt(
    KPROFILE_SOURCE ProfileSource
    )

/*++

Routine Description:

     If ProfileSource is ProfileTime, this routine enables local APIC 
     Timer interrupt. Otherwise it calls the platform specific interface 
     functions to enable the monitoring of the specifed performance event 
     and set up MSRs to generate performance monitor interrupt (PMI) when
     counters overflow.

     This function is called at PROFILE_LEVEL on every processor.

Arguments:

    ProfileSource - Supplies the Profile Source.

Return Value:

    None.

--*/

{
    ULONG initialCount;

    if (ProfileSource == ProfileTime) {

        initialCount = HalpGetCurrentHalPcr()->ProfileCountDown;

        LOCAL_APIC(LU_INITIAL_COUNT) = initialCount;
        HalpProfileRunning = TRUE;

        //
        // Set the Local APIC Timer to interrupt periodically at
        // APIC_PROFILE_VECTOR
        //

        LOCAL_APIC(LU_TIMER_VECTOR) = APIC_TIMER_ENABLED;

    } 
    else {
        EnableMonitoring(ProfileSource);
    }
}

VOID
HalStopProfileInterrupt (
    IN ULONG ProfileSource
    )

/*++

Routine Description:

     If ProfileSource is ProfileTime, this routine disables local APIC 
     Timer interrupt. Otherwise if calls the platform specific interface 
     functions to disable the monitoring of specified performance event 
     and its interrupt.

     This function is called at PROFILE_LEVEL on every processor.

Arguments:

    ProfileSource - Supplies the Profile Source.

Return Value:

    None.

--*/

{

    if (ProfileSource == ProfileTime) {
        HalpProfileRunning = FALSE;
        LOCAL_APIC(LU_TIMER_VECTOR) = APIC_TIMER_DISABLED;
    } 
    else {
        DisableMonitoring(ProfileSource);
    }
}

ULONG_PTR
HalSetProfileInterval (
    ULONG_PTR Interval
    )

/*++

Routine Description:

    This procedure sets the interrupt rate (and thus the sampling
    interval) of the ProfileTime.

Arguments:

    Interval - Supplies the desired profile interrupt interval which is
               specified in 100ns units (MINIMUM is 1221 or 122.1 uS, 
               see ke\profobj.c )

Return Value:

    Interval actually used

--*/

{
    ULONG64 period;
    ULONG apicFreqency;
    PHALPCR halPcr;
    ULONG countDown;


    halPcr = HalpGetCurrentHalPcr();

    //
    // Call SetInterval to validate the input value and update 
    // internal structure
    //

    period = Interval;
    SetInterval(ProfileTime, &period);

    //
    // Compute the countdown value corresponding to the desired period.
    // The calculation is done with 64-bit intermediate values.
    //

    countDown =
        (ULONG)((period * halPcr->ApicClockFreqHz) / TIME_UNITS_PER_SECOND);

    halPcr->ProfileCountDown = countDown;
    LOCAL_APIC(LU_INITIAL_COUNT) = countDown;

    return period;
}

VOID
HalpWaitForCmosRisingEdge (
    VOID
    )

/*++

Routine Description:

    Waits until the rising edge of the CMOS_STATUS_BUSY bit is detected.

    Note - The CMOS spin lock must be acquired before calling this routine.

Arguments:

    None.

Return Value:

    None.

--*/

{
    UCHAR value;

    //
    // We're going to be polling the CMOS_STATUS_A register.  Program
    // that register address here, outside of the loop.
    // 

    WRITE_PORT_UCHAR(CMOS_ADDRESS_PORT,CMOS_STATUS_A);

    //
    // Wait for the status bit to be clear
    //

    do {
        value = READ_PORT_UCHAR(CMOS_DATA_PORT);
    } while ((value & CMOS_STATUS_BUSY) != 0);

    //
    // Now wait for the rising edge of the status bit
    //

    do {
        value = READ_PORT_UCHAR(CMOS_DATA_PORT);
    } while ((value & CMOS_STATUS_BUSY) == 0);
}


ULONG
HalpScaleTimers (
    VOID
    )

/*++

Routine Description:

    Determines the frequency of the APIC timer.  This routine is run
    during initialization

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG flags;
    ULONG passCount;
    ULONG64 cpuFreq;
    ULONG apicFreq;
    UCHAR value;
    PHALPCR halPcr;

    HalpAcquireCmosSpinLock();
    flags = HalpDisableInterrupts();

    LOCAL_APIC(LU_TIMER_VECTOR) = APIC_TIMER_DISABLED;
    LOCAL_APIC(LU_DIVIDER_CONFIG) = LU_DIVIDE_BY_1;

    passCount = 2;
    while (passCount > 0) {

        //
        // Make sure the write has occured
        //

        LOCAL_APIC(LU_TIMER_VECTOR);

        //
        // Wait for the rising edge of the UIP bit, this is the start of the
        // cycle.
        //

        HalpWaitForCmosRisingEdge();

        //
        // At this point the UIP bit has just changed to the set state.
        // Clear the time stamp counter and start the APIC counting down
        // from it's maximum value.
        //

        PROCESSOR_FENCE;

        LOCAL_APIC(LU_INITIAL_COUNT) = 0xFFFFFFFF;
        cpuFreq = ReadTimeStampCounter();

        //
        // Wait for the next rising edge, this marks the end of the CMOS
        // clock update cycle.
        //

        HalpWaitForCmosRisingEdge();

        PROCESSOR_FENCE;

        apicFreq = 0xFFFFFFFF - LOCAL_APIC(LU_CURRENT_COUNT);
        cpuFreq = ReadTimeStampCounter() - cpuFreq;

        passCount -= 1;
    }

    halPcr = HalpGetCurrentHalPcr();

    //
    // cpuFreq is elapsed timestamp in one second.  Round to nearest
    // 10Khz and store.
    //

    halPcr->TSCHz = TIMER_ROUND(cpuFreq);

    //
    // Calculate the apic frequency, rounding to the nearest 10Khz
    //

    apicFreq = TIMER_ROUND(apicFreq);
    halPcr->ApicClockFreqHz = apicFreq;

    //
    // Store microsecond representation of TSC frequency.
    //

    halPcr->StallScaleFactor = (ULONG)(halPcr->TSCHz / 1000000);
    if ((halPcr->TSCHz % 1000000) != 0) {
        halPcr->StallScaleFactor += 1;
    }

    HalpReleaseCmosSpinLock();
    halPcr->ProfileCountDown = apicFreq;

    //
    // Set the interrupt rate in the chip and return the apic frequency
    //

    LOCAL_APIC(LU_INITIAL_COUNT) = apicFreq;
    HalpRestoreInterrupts(flags);

    return halPcr->ApicClockFreqHz;
}

BOOLEAN
HalpProfileInterrupt (
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    Interrupt handler of APIC_PROFILE_VECTOR

    This routine is entered as the result of local APIC Timer interrupt.  
    Its function is to update the profile information of ProfileTime.

Arguments:

    Interrupt - Supplies a pointer to the kernel interrupt object

    ServiceContext - Supplies the service context

Return Value:

    TRUE

--*/

{
    UNREFERENCED_PARAMETER(ServiceContext);

    if (HalpProfileRunning != FALSE) {
        KeProfileInterruptWithSource(Interrupt->TrapFrame, ProfileTime);
    }

    return TRUE;
}

BOOLEAN
HalpPerfInterrupt (
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    Interrupt handler of APIC_PERF_VECTOR

    This routine is entered as the result of an overflow interrupt 
    from performance-monitoring counters. Its function is to find 
    out the counters overflowed, reset them and update the related
    profile information for the profile objects.

Arguments:

    Interrupt - Supplies a pointer to the kernel interrupt object

    ServiceContext - Supplies the service context

Return Value:

    TRUE

--*/

{
    ULONG_PTR InterVal = 0;
    OVERFLOW_STATUS OverflowStatus;
    ULONG i;
    KPROFILE_SOURCE *p;

    UNREFERENCED_PARAMETER(Interrupt);

    if (HalpPerfInterruptHandler != NULL) {
        HalpPerfInterruptHandler(Interrupt->TrapFrame);
        return TRUE;
    }

    CheckOverflowStatus(&OverflowStatus);

    i = OverflowStatus.Number;
    p = OverflowStatus.pSource;

    //
    // ASSERT if we reached here but no counter overflowed
    //

    ASSERT(i);
    
    while (i--) {
        DisableMonitoring(*p);
        KeProfileInterruptWithSource(Interrupt->TrapFrame, *p);
        EnableMonitoring(*p);
        p++;
    }

    return TRUE;
}


NTSTATUS
HalpSetProfileSourceInterval(
    IN KPROFILE_SOURCE ProfileSource,
    IN OUT ULONG_PTR *Interval
    )

/*++

Routine Description:

    This function sets the interrupt interval of given profile source.

Arguments:

    ProfileSource - Supplies the profile source.

    Interval - Supplies the interval value and returns the actual interval.

Return Value:
             
    STATUS_SUCCESS - If the profile interval is successfully updated.

    STATUS_NOT_SUPPORTED - If the specified profile source is not supported.
     
--*/

{

    if (ProfileSource == ProfileTime) {
        *Interval = HalSetProfileInterval(*Interval);
        return STATUS_SUCCESS;
    }

    return SetInterval(ProfileSource, Interval);
}

NTSTATUS
HalpQueryProfileInformation(
    IN HAL_QUERY_INFORMATION_CLASS InformationClass,
    IN ULONG BufferSize,
    OUT PVOID Buffer,
    OUT PULONG ReturnedLength
    )

/*++

Routine Description:

    This function retrieves the information of profile sources.

Arguments:

    InformationClass - Constant that describes the type of information . 

    BufferSize - Size of the memory pointed to by Buffer.

    Buffer - Requested information described by InformationClass.

    ReturnedLength - The actual bytes returned or needed for the requested 
        information.

Return Value:
             
    STATUS_SUCCESS - If the requested information is retrieved successfully.

    STATUS_INFO_LENGTH_MISMATCH - If the incoming BufferSize is too small.
    
    STATUS_NOT_SUPPORTED - If the specified information class or profile 
        source is not supported.

--*/

{
    PHAL_PROFILE_SOURCE_INFORMATION_EX ProfileInformation;

    return QueryInformation (InformationClass, 
                             BufferSize,
                             Buffer, 
                             ReturnedLength);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\mpipi.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mpipi.c

Abstract:

    This module provides the HAL support for interprocessor interrupts and
    processor initialization for MPS systems.

Author:

    Forrest Foltz (forrestf) 27-Oct-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halcmn.h"

//
// External functions
//

VOID
HalpResetThisProcessor (
    VOID
    );

VOID
HalpSendIpi (
    IN KAFFINITY Affinity,
    IN ULONG Command
    );

ULONG
DetectAcpiMP (
    OUT PBOOLEAN IsConfiguredMp,
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock
    );

//
// External data
//

extern BOOLEAN HalpStaticIntAffinity;
extern UCHAR rgzBadHal[];
extern UCHAR HalpPICINTToVector[16];

//
// Local types
//

typedef
VOID
(*HAL_GENERIC_IPI_FUNCTION) (
    ULONG_PTR Context
    );

//
// Local prototypes
//

VOID
HalInitApicInterruptHandlers(
    VOID
    );

//
// Local data and defines
//

ULONG_PTR HalpBroadcastContext;
HAL_GENERIC_IPI_FUNCTION HalpBroadcastFunction;
KSPIN_LOCK HalpBroadcastLock;
KAFFINITY volatile HalpBroadcastTargets;
PKPCR HalpProcessorPCR[MAXIMUM_PROCESSORS];

//
// HalpGlobal8259Mask is used to avoid reading the PIC to get the current
// interrupt mask; format is the same as for SET_8259_MASK, i.i.,
// bits 7:0 -> PIC1, 15:8 -> PIC2
//

USHORT HalpGlobal8259Mask = 0;

#define GENERIC_IPI (DELIVER_FIXED | LOGICAL_DESTINATION | ICR_USE_DEST_FIELD | APIC_GENERIC_VECTOR)

//
// Globals and constants used to log local apic errors
//

#define LogApicErrors TRUE
#if LogApicErrors

//
// Structure defining the layout of an apic error record.
// 

typedef struct _APIC_ERROR {
    union {
        struct {
            UCHAR SendChecksum:1;
            UCHAR ReceiveChecksum:1;
            UCHAR SendAccept:1;
            UCHAR ReceiveAccept:1;
            UCHAR Reserved1:1;
            UCHAR SendVector:1;
            UCHAR ReceiveVector:1;
            UCHAR RegisterAddress:1;
        };
        UCHAR AsByte;
    };
    UCHAR Processor;
} APIC_ERROR, *PAPIC_ERROR;

#define APIC_ERROR_LOG_SIZE 128

//
// Count of local apic errors.
// 

ULONG HalpLocalApicErrorCount = 0;

//
// Apic error log.  This is circular, indexed by
// HalpLocalApicErrorCount % APIC_ERROR_LOG_SIZE.
//

APIC_ERROR HalpApicErrorLog[APIC_ERROR_LOG_SIZE];

//
// Spinlock used to protect access to HalpLocalApicErrorCount.
//

KSPIN_LOCK HalpLocalApicErrorLock;

#endif

VOID
HalInitializeProcessor(
    ULONG ProcessorNumber,
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    Initialize hal pcr values for current processor (if any)
    (called shortly after processor reaches kernel, before
    HalInitSystem if P0)

    IPI's and KeReadir/LowerIrq's must be available once this function
    returns.  (IPI's are only used once two or more processors are
    available)

   . Enable IPI interrupt (makes sense for P1, P2, ...).
   . Save Processor Number in PCR.
   . if (P0)
       . determine if the system is a PC+MP,
       . if not a PC+MP System Halt;
   . Enable IPI's on CPU.

Arguments:

    Number - Logical processor number of calling processor

Return Value:

    None.

--*/

{
    PKPCR pcr;
    KAFFINITY affinity;
    KAFFINITY oldAffinity;
    ULONG detectAcpiResult;
    BOOLEAN isMp;

    affinity = (KAFFINITY)1 << ProcessorNumber;
    pcr = KeGetPcr();

    //
    // Mark all interrupts as disabled, and store the processor number and
    // the default stall scale factor in the pcr.
    //

    pcr->Idr = 0xFFFFFFFF;
    pcr->Number = (UCHAR)ProcessorNumber;
    pcr->StallScaleFactor = INITIAL_STALL_COUNT;

    //
    // Record the pcr pointer in our lookup table and set the affinity
    // bit in our set of active processors.
    // 

    HalpProcessorPCR[ProcessorNumber] = pcr;
    HalpActiveProcessors |= affinity;

    if (HalpStaticIntAffinity == 0) {

        //
        // Interrupts can go to any processor
        //

        HalpDefaultInterruptAffinity |= affinity;

    } else {

        //
        // Interrupts go only to the highest numbered processor
        //

        if (HalpDefaultInterruptAffinity < affinity) {
            HalpDefaultInterruptAffinity = affinity;
        }
    }

    if (ProcessorNumber == 0) {

        KeInitializeSpinLock(&HalpBroadcastLock);

#if LogApicErrors

        KeInitializeSpinLock(&HalpLocalApicErrorLock);

#endif

        //
        // Determine whether the system we are on is an MPS system.
        //
        // DetectAcpiMP has a parameter we don't currently use.  It's a boolean
        // which is set to TRUE if the system we're on is an MP system.
        // We could have a UP MPS system.
        //
        // The DetectAcpiMP routine also allocates virtual addresses for all of
        // the APICs in the system.
        //

        detectAcpiResult = DetectAcpiMP(&isMp,LoaderBlock);
        if (detectAcpiResult == FALSE) {
            HalDisplayString(rgzBadHal);

            HalpDisableInterrupts();
            while (TRUE) {
                HalpHalt();
            }
        }

        HalpRegisterKdSupportFunctions(LoaderBlock);

        //
        // Mask all PIC interrupts
        //

        HalpGlobal8259Mask = 0xFFFF;
        SET_8259_MASK(HalpGlobal8259Mask);
    }

    //
    // All processors execute this code
    //

    HalInitApicInterruptHandlers();
    HalpInitializeLocalUnit();
}

VOID
HalInitApicInterruptHandlers(
    VOID
    )

/*++

Routine Description:

    This routine installs the interrupt vector in the IDT for the APIC
    spurious interrupt.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PKPCR pcr;
    PKIDTENTRY64 idt;

    KiSetHandlerAddressToIDTIrql(PIC1_SPURIOUS_VECTOR,
                                 PicSpuriousService37,
                                 NULL,
                                 0);

    KiSetHandlerAddressToIDTIrql(APIC_SPURIOUS_VECTOR,
                                 HalpApicSpuriousService,
                                 NULL,
                                 0);
}

__forceinline
VOID
HalpPollForBroadcast (
    VOID
    )

/*++

Routine Description:

    Checks whether the current processor has a broadcast function pending
    and, if so, clears it's pending bit and calls the function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KAFFINITY affinity;
    ULONG_PTR broadcastContext;
    HAL_GENERIC_IPI_FUNCTION broadcastFunction;
    KAFFINITY broadcastTargets;

    affinity = KeGetPcr()->CurrentPrcb->SetMember;
    if ((HalpBroadcastTargets & affinity) != 0) {

        //
        // A generic IPI call appears to be pending for this processor.
        // Pick up the function pointer and context locally.
        //

        broadcastFunction = HalpBroadcastFunction;
        broadcastContext = HalpBroadcastContext;

        //
        // Atomically acknowledge the broadcast.  If the broadcast is still
        // pending for this processor, then call it.
        //

        broadcastTargets = InterlockedAnd64(&HalpBroadcastTargets,~affinity);
        if ((broadcastTargets & affinity) != 0) {
            broadcastFunction(broadcastContext);
        }
    }
}

VOID
HalpGenericCall(
    IN HAL_GENERIC_IPI_FUNCTION BroadcastFunction,
    IN ULONG Context,
    IN KAFFINITY TargetProcessors
    )

/*++

Routine Description:

    Causes the WorkerFunction to be called on the specified target
    processors.  The WorkerFunction is called at CLOCK2_LEVEL-1
    (Must be below IPI_LEVEL in order to prevent system deadlocks).

Enviroment:

    Must be called with interrupts enabled.
    Must be called with IRQL = CLOCK2_LEVEL-1

--*/

{
    //
    // Nothing to do if no target processors have been specified.
    //

    if (TargetProcessors == 0) {
        return;
    }

    //
    // Acquire the broadcast lock, polling for broadcasts while spinning.
    //

    while (KeTryToAcquireSpinLockAtDpcLevel(&HalpBroadcastLock) == FALSE) {
        do {
            HalpPollForBroadcast();
        } while (KeTestSpinLock(&HalpBroadcastLock) == FALSE);
    }

    //
    // We own the broadcast lock.  Store the broadcast parameters
    // into the broadcast prameters and send the generic IPI.
    //

    HalpBroadcastFunction = BroadcastFunction;
    HalpBroadcastContext = Context;
    HalpBroadcastTargets = TargetProcessors;
    HalpSendIpi(TargetProcessors,GENERIC_IPI);

    //
    // Wait for all processors to pick up the IPI and process the generic
    // call, then release the broadcast lock.
    // 

    do {
        HalpPollForBroadcast();
    } while (HalpBroadcastTargets != 0);

    KeReleaseSpinLockFromDpcLevel(&HalpBroadcastLock);
}


ULONG
HalpWaitForPending (
    IN ULONG Count,                           
    IN ULONG volatile *ICR
    )

/*++

Routine Description:

    Spins waiting for the DELIVERY_PENDING bit in the ICR to clear or
    until spinning Count times.

Arguments:

    Count - Number of times through the loop before giving up.

    ICR - Pointer to the ICR register containing the DELIVERY_PENDING
          status bit.

Return Value:

    Zero if the DELIVERY_PENDING bit has cleared within the number of
    test cycles, non-zero otherwise.

--*/

{
    ULONG countRemaining;

    countRemaining = Count;
    while (countRemaining > 0) {

        if ((*ICR & DELIVERY_PENDING) == 0) {
            break;
        }
        countRemaining -= 1;
    }

    return countRemaining;
}

BOOLEAN
HalpApicRebootService (
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This is the ISR that handles Reboot interrupts.

Arguments:

    Interrupt - Supplies a pointer to the kernel interrupt object

    ServiceContext - Supplies the service context

Return Value:

    None.  This routine does not return.

--*/

{
    UNREFERENCED_PARAMETER(Interrupt);
    UNREFERENCED_PARAMETER(ServiceContext);

    LOCAL_APIC(LU_TPR) = APIC_REBOOT_VECTOR;

    //
    // EOI the local APIC.  Warm reset does not reset the 82489 APIC
    // so if we don't EOI here we'll never see an interrupt after the
    // reboot.
    //

    LOCAL_APIC(LU_EOI) = 0;

    //
    // Reset this processor.  This function will not return.
    // 

    HalpResetThisProcessor();
    ASSERT(FALSE);

    return TRUE;
}


BOOLEAN
HalpBroadcastCallService (
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This is the ISR that handles broadcast call interrupts.

Arguments:

    Interrupt - Supplies a pointer to the kernel interrupt object

    ServiceContext - Supplies the service context

Return Value:

    TRUE

--*/

{
    UNREFERENCED_PARAMETER(Interrupt);
    UNREFERENCED_PARAMETER(ServiceContext);

    HalpPollForBroadcast();
    return TRUE;
}

BOOLEAN
HalpIpiHandler (
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This routine is entered as the result of an interrupt generated by
    interprocessor communication.

Arguments:

    Interrupt - Supplies a pointer to the kernel interrupt object

    ServiceContext - Supplies the service context

Return Value:

    TRUE

--*/

{
    UNREFERENCED_PARAMETER(Interrupt);

    KeIpiInterrupt(Interrupt->TrapFrame);

    return TRUE;
}

BOOLEAN
HalpLocalApicErrorService (
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This routine is entered as the result of an interrupt generated by
    a local apic error.  It clears the error and, if apic error logging
    is turned on, records information about the error.

Arguments:

    Interrupt - Supplies a pointer to the kernel interrupt object

    ServiceContext - Supplies the service context

Return Value:

    TRUE

--*/

{
    ULONG flags;
    PAPIC_ERROR apicError;
    ULONG index;
    ULONG errorStatus;
    PKPCR pcr;

#if LogApicErrors

    //
    // Take the apic error log lock, get a pointer to the next available
    // error log slot, and increment the error count.
    //

    flags = HalpAcquireHighLevelLock(&HalpLocalApicErrorLock);

    index = HalpLocalApicErrorCount % APIC_ERROR_LOG_SIZE;
    apicError = &HalpApicErrorLog[index];
    HalpLocalApicErrorCount += 1;

#endif

    //
    // The Apic EDS (Rev 4.0) says you have to write before you read.
    // This doesn't work.  The write clears the status bits, but the P6 works
    // according to the EDS.
    //
    // For AMD64, for now assume that things work according to the EDS spec.
    //

    LOCAL_APIC(LU_ERROR_STATUS) = 0;
    errorStatus = LOCAL_APIC(LU_ERROR_STATUS);

#if LogApicErrors

    //
    // Fill in the error log and release the apic error log lock.
    //

    pcr = KeGetPcr();
    apicError->AsByte = (UCHAR)errorStatus;
    apicError->Processor = pcr->Number;

    HalpReleaseHighLevelLock(&HalpLocalApicErrorLock,flags);

#endif

    return TRUE;
}


BOOLEAN
PicNopHandlerInt (
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    )

/*++

Routine Description:

    This handler is designed to be installed on a system to field any PIC
    interrupts when there are not supposed to be any delivered.

    This routine EOIs the PIC and returns.

Arguments:

    Interrupt - Supplies a pointer to the kernel interrupt object

    ServiceContext - Supplies the service context

Return Value:

    TRUE

--*/

{
    UCHAR irq;

    AMD64_COVERAGE_TRAP();

    //
    // Context is the PIC IRQ
    //

    ASSERT((ULONG_PTR)Context <= 15);

    irq = (UCHAR)(ULONG_PTR)(Context);
    if (irq <= 7) {

        WRITE_PORT_UCHAR(PIC1_PORT0,irq | OCW2_SPECIFIC_EOI);

    } else {

        if (irq == 0x0D) {
            WRITE_PORT_UCHAR(I386_80387_BUSY_PORT, 0);
        }

        WRITE_PORT_UCHAR(PIC2_PORT0,OCW2_NON_SPECIFIC_EOI);
        WRITE_PORT_UCHAR(PIC1_PORT0,OCW2_SPECIFIC_EOI | PIC_SLAVE_IRQ);
    }

    return TRUE;
}


BOOLEAN
PicInterruptHandlerInt (
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    )

/*++

Routine Description:

    These handlers receive interrupts from the PIC and reissues them via a
    vector at the proper priority level.  This is used to provide a symetric
    interrupt distribution on a non symetric system.
 
    The PIC interrupts will normally only be received (in the PC+MP Hal) via
    an interrupt input from on either the IO Unit or the Local unit which has
    been programed as EXTINT.  EXTINT interrupts are received outside of the
    APIC priority structure (the PIC provides the vector).  We use the APIC
    ICR to generate interrupts to the proper handler at the proper priority.
 
    The EXTINT interrupts are directed to a single processor, currently P0.
    There is no good reason why they can't be directed to another processor.
 
    Since one processor must absorb the overhead of redistributing PIC
    interrupts the interrupt handling on a system using EXTINT interrupts is
    not symetric.
 
Arguments:

    Interrupt - Supplies a pointer to the kernel interrupt object

    ServiceContext - Supplies the service context

Return Value:

    TRUE

--*/

{
    UCHAR irq;
    UCHAR isrRegister;
    UCHAR ipiVector;

    AMD64_COVERAGE_TRAP();

    //
    // Context is the PIC IRQ
    //

    ASSERT((ULONG_PTR)Context <= 15);

    irq = (UCHAR)(ULONG_PTR)(Context);
    if (irq == 7) {

        //
        // Check to see if this is a spurious interrupt
        //

        WRITE_PORT_UCHAR(PIC1_PORT0,OCW3_READ_ISR);
        IO_DELAY();
        isrRegister = READ_PORT_UCHAR(PIC1_PORT0);
        if ((isrRegister & 0x80) == 0) {

            //
            // Spurious.
            //

            return TRUE;
        }
    }

    if (irq == 0x0D) {

        WRITE_PORT_UCHAR(I386_80387_BUSY_PORT,0);

    } else if (irq == 0x1F) {

        WRITE_PORT_UCHAR(PIC2_PORT0,OCW3_READ_ISR);
        IO_DELAY();
        isrRegister = READ_PORT_UCHAR(PIC2_PORT0);
        if ((isrRegister & 0x80) == 0) {

            //
            // Spurious.
            //

            return TRUE;
        }
    }

    if (irq <= 7) {

        //
        // Master PIC
        //

        WRITE_PORT_UCHAR(PIC1_PORT0,irq | OCW2_SPECIFIC_EOI);

    } else {

        //
        // Slave PIC
        //

        WRITE_PORT_UCHAR(PIC2_PORT0,OCW2_NON_SPECIFIC_EOI);
        WRITE_PORT_UCHAR(PIC1_PORT0,OCW2_SPECIFIC_EOI | PIC_SLAVE_IRQ);
    }

    ipiVector = HalpPICINTToVector[irq];

    if (ipiVector != 0) {

        HalpStallWhileApicBusy();
        if (irq == 8) {

            //
            // Clock interrupt
            //

            LOCAL_APIC(LU_INT_CMD_LOW) =
                DELIVER_FIXED | ICR_SELF | APIC_CLOCK_VECTOR;

        } else {

            //
            // Write the IPI command to the Memory Mapped Register
            //

            LOCAL_APIC(LU_INT_CMD_HIGH) = DESTINATION_ALL_CPUS;
            LOCAL_APIC(LU_INT_CMD_LOW) = ipiVector;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\mpswint.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mpswint.c

Abstract:

    This module implements the software interrupt handlers
    for x86 machines

Author:

    John Vert (jvert) 2-Jan-1992

Environment:

    Kernel mode only.

Revision History:

    Forrest Foltz (forrestf) 23-Oct-2000
        Ported from ixswint.asm to ixswint.c

--*/

#include "halcmn.h"

//
// Array used to look up the correct ICR command based on the requested
// software interrupt
//

const
ULONG
HalpIcrCommandArray[3] = {
    0,
    APC_VECTOR | DELIVER_FIXED | ICR_SELF,  // APC_LEVEL
    DPC_VECTOR | DELIVER_FIXED | ICR_SELF   // DISPATCH_LEVEL
};

C_ASSERT(APC_LEVEL == 1);
C_ASSERT(DISPATCH_LEVEL == 2);


VOID
FASTCALL
HalRequestSoftwareInterrupt (
    IN KIRQL RequestIrql
    )

/*++

Routine Description:

    This routine is used to request a software interrupt of
    the system.

Arguments:

    RequestIrql - Supplies the request IRQL value

 Return Value:

    None.

--*/

{
    ULONG icrCommand;
    ULONG flags;

    ASSERT(RequestIrql == APC_LEVEL || RequestIrql == DISPATCH_LEVEL);

    icrCommand = HalpIcrCommandArray[RequestIrql];

    flags = HalpDisableInterrupts();
    HalpStallWhileApicBusy();

    LOCAL_APIC(LU_INT_CMD_LOW) = icrCommand;

    HalpStallWhileApicBusy();
    HalpRestoreInterrupts(flags);
}


VOID
HalClearSoftwareInterrupt (
    IN KIRQL RequestIrql
    )

/*++

Routine Description:

    This routine is used to clear a possible pending software interrupt.
    Support for this function is optional, and allows the kernel to
    reduce the number of spurious software interrupts it receives/
 
Arguments:
 
     RequestIrql - Supplies the request IRQL value
 
Return Value:
 
     None.

--*/

{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\mpsysint.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mpcsysint.c

Abstract:

    This module implements the HAL routines to enable/disable system
    interrupts on an MPS system.

Author:

    John Vert (jvert) 22-Jul-1991

Revision History:

    Forrest Foltz (forrestf) 27-Oct-2000
        Ported from mcsysint.asm to mcsysint.c

Revision History:

--*/

#include "halcmn.h"

VOID
HalEndSystemInterrupt (
    IN KIRQL NewIrql,
    IN ULONG Vector
    )

/*++

Routine Description:

    This routine is used to send an EOI to the local APIC.

Arguments:

    NewIrql - the new irql to be set.

    Vector - Vector number of the interrupt

Return Value:

    None.

--*/
    
{
    UNREFERENCED_PARAMETER(NewIrql);
    UNREFERENCED_PARAMETER(Vector);

    //
    // Send EOI to APIC local unit
    //

    LOCAL_APIC(LU_EOI) = 0;
}


BOOLEAN
HalBeginSystemInterrupt (
    IN KIRQL Irql,
    IN ULONG Vector,
    OUT PKIRQL OldIrql
    )

/*++

Routine Description:

    This routine raises the IRQL to the level of the specified
    interrupt vector.  It is called by the hardware interrupt
    handler before any other interrupt service routine code is
    executed.  The CPU interrupt flag is set on exit.

    On APIC-based systems we do not need to check for spurious
    interrupts since they now have their own vector.  We also
    no longer need to check whether or not the incoming priority
    is higher than the current priority that is guaranteed by
    the priority mechanism of the APIC.

    SO

    All BeginSystemInterrupt needs to do is set the APIC TPR
    appropriate for the IRQL, and return TRUE.  Note that to
    use the APIC ISR priority we are not going issue EOI until
    EndSystemInterrupt is called.

Arguments:

    Irql   - Supplies the IRQL to raise to

    Vector - Supplies the vector of the interrupt to be
             handled

    OldIrql- Location to return OldIrql

 Return Value:

    TRUE -  Interrupt successfully dismissed and Irql raised.
            This routine can not fail.

--*/

{
    KeRaiseIrql(Irql,OldIrql);
    HalpEnableInterrupts();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\mpspin.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mpspin.c

Abstract:

    This module implements the hal high level lock manipulation routines.

Author:

    Forrest Foltz (forrestf) 1-Dec-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halcmn.h"

//
// On UP machines, the high level lock routines are macros
// 

#if !defined(NT_UP)

ULONG
HalpAcquireHighLevelLock (
    IN PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    Acquires a spinlock with interrupts disabled.

    On a UP system, this routine is replaced with a macro that simply disables
    interrupts and returns the state of EFLAGS.

Arguments:

    SpinLock - Supplies a pointer to a kernel spin lock.

Return Value:

    Returns the state of the EFLAGS register.

--*/

{
    ULONG flags;

    //
    // Remember the state of the processor flags
    // 

    flags = HalpGetProcessorFlags();

    while (TRUE) {

        //
        // Disable interrupts and attempt to take the spinlock, exiting
        // the loop if it was available.
        //

        _disable();
        if (KeTryToAcquireSpinLockAtDpcLevel(SpinLock) != FALSE) {
            break;
        }

        //
        // The spinlock was not available.  Restore the state of the
        // interrupt flag and spin, waiting for it to become available.
        //

        HalpRestoreInterrupts(flags);
        while (KeTestSpinLock(SpinLock) == FALSE) {
            NOTHING;
        }
    }

    return flags;
}

VOID
HalpReleaseHighLevelLock (
    IN PKSPIN_LOCK SpinLock,
    IN ULONG       Flags
    )

/*++

Routine Description:

    This function releases a kernel spin lock that was taken by
    HalpAcquireHighLevelLock() and lowers to the new irql.

    On a UP system, this routine is replaced with a macro that simply
    restores interrupts based on the state of Flags.

Arguments:

    SpinLock - Supplies a pointer to a kernel spin lock.
    Flags    - The contents of the EFLAGS register when the
               lock was taken.

Return Value:

    None.

--*/

{
    //
    // Interrupts at this point are disabled.  Release the spinlock and
    // enable interrupts if they were enabled when the lock was taken.
    //

    KeReleaseSpinLockFromDpcLevel(SpinLock);
    HalpRestoreInterrupts(Flags);
}

#endif  // NT_UP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\mpprofil.h ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    mpprofil.h

Abstract:

    This module contains function prototypes, declarations for HAL
    profiling interface functions. 

Author:

    Steve Deng (sdeng)  14-Jun-2002

Environment:

    Kernel mode.

--*/

#ifndef _MPPROFIL_H_
#define _MPPROFIL_H_

#include <halp.h>

//
// Define data types userd by profile interface functions
//

typedef struct _OVERFLOW_STATUS {
    ULONG Number; 
    KPROFILE_SOURCE *pSource;
} OVERFLOW_STATUS, *POVERFLOW_STATUS;

//
// Protocals for profile interface functions
//

typedef VOID (*PINITIALIZE_PROFILING)(
    VOID
    );

typedef NTSTATUS (*PENABLE_MONITORING)(
    IN KPROFILE_SOURCE ProfileSource
    );

typedef NTSTATUS (*PENABLE_MONITORING)(
    IN KPROFILE_SOURCE ProfileSource
    );

typedef VOID (*PDISABLE_MONITORING)(
    IN KPROFILE_SOURCE ProfileSource
    );

typedef NTSTATUS (*PSET_INTERVAL)(
    IN KPROFILE_SOURCE  ProfileSource,
    IN OUT ULONG_PTR   *Interval
    );

typedef NTSTATUS (*PQUERY_INFORMATION)(
    IN HAL_QUERY_INFORMATION_CLASS InformationType,
    IN ULONG BufferSize,
    IN OUT PVOID Buffer,
    OUT PULONG ReturnedLength
    );

typedef VOID (*PCHECK_OVERFLOW_STATUS)(
    POVERFLOW_STATUS pOverflowStatus
    );

typedef struct _PROFILE_INTERFACE {
    PINITIALIZE_PROFILING  InitializeProfiling;
    PENABLE_MONITORING     EnableMonitoring;
    PDISABLE_MONITORING    DisableMonitoring;
    PSET_INTERVAL          SetInterval;
    PQUERY_INFORMATION     QueryInformation;
    PCHECK_OVERFLOW_STATUS CheckOverflowStatus;

} PROFILE_INTERFACE, *PPROFILE_INTERFACE;

extern PROFILE_INTERFACE Amd64PriofileInterface;

#endif  // _MPPROFIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\picinit.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    picinit.c

Abstract:

    This module implements pic initialization code.

Author:

    Forrest Foltz (forrestf) 1-Dec-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halcmn.h"

VOID
HalpInitialize8259Tables (
    VOID
    );

VOID
HalpInitializeIrqlTables (
    VOID
    );

VOID
HalpInitializePICs (
    IN BOOLEAN EnableInterrupts
    )

/*++

Routine Description:

    This routine sends the 8259 PIC initialization commands and masks all
    the interrupts on 8259s.

Parameters:

    EnableInterupts - Indicates whether interrupts should be explicitly
                      enabled just before returning.

Return Value:

    Nothing.

--*/

{
    ULONG flags;

#if defined(PICACPI)

    //
    // Build the irq<->IRQL mapping tables
    //

    HalpInitialize8259Tables();

#else

    //
    // Build the vector <-> INTI tables
    //

    HalpInitializeIrqlTables();

#endif

    flags = HalpDisableInterrupts();

    //
    // First, program the master pic with ICW1 through ICW4
    // 

    WRITE_PORT_UCHAR(PIC1_PORT0,
                     ICW1_ICW +
                     ICW1_EDGE_TRIG +
                     ICW1_INTERVAL8 +
                     ICW1_CASCADE +
                     ICW1_ICW4_NEEDED);

    WRITE_PORT_UCHAR(PIC1_PORT1,
                     PIC1_BASE);

    WRITE_PORT_UCHAR(PIC1_PORT1,
                     1 << PIC_SLAVE_IRQ);

    WRITE_PORT_UCHAR(PIC1_PORT1,
                     ICW4_NOT_SPEC_FULLY_NESTED + 
                     ICW4_NON_BUF_MODE + 
                     ICW4_NORM_EOI + 
                     ICW4_8086_MODE);

    //
    // Mask all irqs on the master
    // 

    WRITE_PORT_UCHAR(PIC1_PORT1,0xFF);

    //
    // Next, program the slave pic with ICW1 through ICW4
    //

    WRITE_PORT_UCHAR(PIC2_PORT0,
                     ICW1_ICW +
                     ICW1_EDGE_TRIG +
                     ICW1_INTERVAL8 +
                     ICW1_CASCADE +
                     ICW1_ICW4_NEEDED);

    WRITE_PORT_UCHAR(PIC2_PORT1,
                     PIC2_BASE);

    WRITE_PORT_UCHAR(PIC2_PORT1,
                     PIC_SLAVE_IRQ);

    WRITE_PORT_UCHAR(PIC2_PORT1,
                     ICW4_NOT_SPEC_FULLY_NESTED + 
                     ICW4_NON_BUF_MODE + 
                     ICW4_NORM_EOI + 
                     ICW4_8086_MODE);

    //
    // Mask all IRQs on the slave
    //

    WRITE_PORT_UCHAR(PIC2_PORT1,0xFF);

    if (EnableInterrupts != FALSE) {
        HalpEnableInterrupts();
    } else {
        HalpRestoreInterrupts(flags);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\mpsproca.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mpclock.c

Abstract:

    This module implements processor starup code.

Author:

    Forrest Foltz (forrestf) 27-Oct-2000

Environment:

    Kernel mode only.

Revision History:

--*/


#include "halcmn.h"
#include <acpitabl.h>
#include <xxacpi.h>
#include <ixsleep.h>

#if !defined(NT_UP)

//
// Pull in the real- and 32-bit protected-mode object code
//

#include "pmstub.h"
#include "rmstub.h"

extern UCHAR HalpLMStub[];
extern UCHAR HalpLMIdentityStub[];
extern UCHAR HalpLMIdentityStubEnd[];

#define HALP_LMIDENTITYSTUB_LENGTH (HalpLMIdentityStubEnd - HalpLMIdentityStub)


#endif

extern BOOLEAN HalpHiberInProgress;
extern PUCHAR Halp1stPhysicalPageVaddr;

#define WARM_RESET_VECTOR   0x467   // warm reset vector in ROM data segment
#define CMOS_SHUTDOWN_REG   0x0f
#define CMOS_SHUTDOWN_JMP   0x0a

#define _20BITS (1 << 20)


ULONG
HalpStartProcessor (
    IN PVOID InitCodePhysAddr,
    IN ULONG ProcessorNumber
    );

VOID
HalpBuildKGDTEntry32 (
    IN PKGDTENTRY64 Gdt,
    IN ULONG Selector,
    IN ULONG Base,
    IN ULONG Limit,
    IN ULONG Type,
    IN BOOLEAN LongMode
    );

BOOLEAN
HalStartNextProcessor (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PKPROCESSOR_STATE ProcessorState
    )

/*++

Routine Description:

    This routine is called by the kernel during kernel initialization to
    obtain more processors.  It is called until no more processors are
    available.

    If another processor exists this function is to initialize it to the
    passed in processor state structure, and return TRUE.

    If another processor does not exist or if the processor fails to start,
    then FALSE is returned.

    Also note that the loader block has been set up for the next processor.
    The new processor logical thread number can be obtained from it if
    required.

    In order to use the Startup IPI the real mode startup code must be page
    aligned.  The HalpLowStubPhysicalAddress has always been page aligned
    but because the PxParamBlock was placed first in this segment the real
    mode code has been something other than page aligned.  THis has been
    changed by making the first entry in the PxParamBlock a jump instruction
    to the real mode startup code.

Arguments:

    LoaderBlock - A pointer to the loader block which has been initialized
                  for the next processor.

    ProcessorState - A pointer to a structure which containts the initial
                     state of the processor.

Return Value:

    TRUE - ProcessorNumber was dispatched.

    FALSE - A processor was not dispatched, or no other processor exists.

--*/

{

#if defined(NT_UP)

    return FALSE;

#else

    ULONG cr3;
    PPROCESSOR_START_BLOCK startupBlock;
    ULONG __unaligned *resetVectorLocation;
    ULONG oldResetVector;
    ULONG newResetVector;
    UCHAR cmosValue;
    PKPRCB prcb;
    ULONG apicId;
    ULONG count;
    PVOID pmStubStart;
    ULONG startupBlockPhysical;
    PVOID pmStub;
    PCHAR dst;
    BOOLEAN processorStarted;

    C_ASSERT(PSB_GDT32_CODE64 == KGDT64_R0_CODE);

    //
    // Assume failure.
    //

    processorStarted = FALSE;

    //
    // Initialize the startup block.  First, copy the x86 real-mode
    // code, the protected-mode 32-bit code and a bit of 64-bit long
    // mode code into the startup block.
    //
    // The structure that is ultimately assembled by this code is laid
    // out as follows.
    //

    /*

    +========================================================+ <- HalpLowStub
    | Jmp instruction to end of PROCESSOR_START_BLOCK        | >--+
    +--------------------------------------------------------+    |
    |                                                        |    |
    | Remainder of PROCESSOR_START_BLOCK fields              |    |
    |                                                        |    |
    +--------------------------------------------------------+    |  
    |                                                        | <--+  
    | 16-bit real-mode code from StartPx_RMStub (xmstub.asm) |       
    |                                                        |       
    | Enters 32-bit protected mode (no paging), performs a   |       
    | far jump to StartPx_PMStub.                            |       
    |                                                        | >--+  
    +--------------------------------------------------------+    |  
    |                                                        | <--+
    | 32-bit protected-mode code from StartPx_PMStub.        |
    |                                                        |
    | Enters 64-bit long mode using the identity-mapped      |
    | CR3 found in PROCESSOR_START_BLOCK.  Performs a 32-bit |
    | far jump to HalpLMIdentityStub.                        |
    |                                                        | >--+
    +--------------------------------------------------------+    |
    |                                                        | <--+
    | 64-bit long mode code from HalpLMIdentityStub          |
    | (amd64s.asm).  This performs a long (64-bit) jump to   |
    | HalpLMStub (amd64s.asm).  This code exists only because|
    | HalpLMStub resides at an address that is inaccessible  |
    | via a 32-bit far jump.                                 |
    |                                                        | -> HalpLMStub()
    +========================================================+

    */

    //
    // Copy HalpRMStub
    // 

    startupBlock = (PPROCESSOR_START_BLOCK)HalpLowStub;
    startupBlockPhysical = PtrToUlong(HalpLowStubPhysicalAddress);

    dst = (PCHAR)startupBlock;
    RtlCopyMemory(dst, HalpRMStub, HalpRMStubSize);

    //
    // Copy HalpPMStub
    //

    dst += HalpRMStubSize;
    RtlCopyMemory(dst, HalpPMStub, HalpPMStubSize);

    startupBlock->PmTarget.Selector = PSB_GDT32_CODE32;
    startupBlock->PmTarget.Offset =
        (ULONG)(dst - (PUCHAR)startupBlock) + startupBlockPhysical;

    //
    // Copy HalpLMIdentityStub
    //

    dst += HalpPMStubSize;
    RtlCopyMemory(dst, HalpLMIdentityStub, HALP_LMIDENTITYSTUB_LENGTH);

    startupBlock->LmIdentityTarget.Selector = PSB_GDT32_CODE64;
    startupBlock->LmIdentityTarget.Offset =
        (ULONG)(dst - (PUCHAR)startupBlock) + startupBlockPhysical;

    //
    // Now begin filling in other startup block fields
    //

    startupBlock->SelfMap = startupBlock;
    startupBlock->LmTarget = HalpLMStub;

    //
    // Build the temporary GDT entries to be used while in 32-bit
    // protected mode
    //

    HalpBuildKGDTEntry32(startupBlock->Gdt,
                         PSB_GDT32_CODE32,
                         0,
                         (ULONG)(-1),
                         TYPE_CODE,
                         FALSE);

    HalpBuildKGDTEntry32(startupBlock->Gdt,
                         PSB_GDT32_DATA32,
                         0,
                         (ULONG)(-1),
                         TYPE_DATA,
                         FALSE);

    //
    // Build the temporary code selector GDT entry to be used while in long
    // mode.
    //

    HalpBuildKGDTEntry32(startupBlock->Gdt,
                         PSB_GDT32_CODE64,
                         0,             // base and limit are ignored in 
                         0,             // a long-mode CS selector
                         TYPE_CODE,
                         TRUE);

    //
    // Build the pseudo-descriptor for the GDT
    //

    startupBlock->Gdt32.Limit = sizeof(startupBlock->Gdt) - 1;
    startupBlock->Gdt32.Base =
        startupBlockPhysical + FIELD_OFFSET(PROCESSOR_START_BLOCK,Gdt);

    //
    // Build a CR3 for the starting processor.  If returning from
    // hibernation, then use setup tiled CR3 else create a new map.
    //
    // Also, record the PAT of the current processor
    //

    if (HalpHiberInProgress == FALSE) {
        startupBlock->TiledCr3 = HalpBuildTiledCR3(ProcessorState);
    } else {
        startupBlock->TiledCr3 = CurTiledCr3LowPart;
    }
    startupBlock->MsrPat = ReadMSR(MSR_PAT);

    //
    // Copy in the processor state and the linear address of the startup
    // block, and zero the completionflag.
    //

    startupBlock->ProcessorState = *ProcessorState;
    startupBlock->CompletionFlag = 0;

    //
    // The reset vector lives in the BIOS data area.  Build a pointer to it
    // and store the existing value locally.
    //

    resetVectorLocation = (PULONG)((PUCHAR)Halp1stPhysicalPageVaddr +
                                   WARM_RESET_VECTOR);
    oldResetVector = *resetVectorLocation;

    //
    // Build the new real-mode vector in SEG:OFFS format and store it in the
    // BIOS data area.
    //

    newResetVector = PtrToUlong(HalpLowStubPhysicalAddress);
    newResetVector <<= 12;
    *resetVectorLocation = newResetVector;

    //
    // Tell the BIOS to jump via the vector we gave it by setting the
    // reset code in the cmos
    //

    HalpAcquireCmosSpinLock();
    cmosValue = CMOS_READ(CMOS_SHUTDOWN_REG);
    CMOS_WRITE(CMOS_SHUTDOWN_REG,CMOS_SHUTDOWN_JMP);
    HalpReleaseCmosSpinLock();

    prcb = (PKPRCB)LoaderBlock->Prcb;
    apicId = HalpStartProcessor(HalpLowStubPhysicalAddress, prcb->Number);
    if (apicId == 0) {

        //
        // The processor could not be started.
        //

        goto procStartCleanup;
    }

    //
    // Set the apic ID in the target processor's PRCB and wait for it to
    // signal that it has started.
    //

    apicId -= 1;
    ((PHALPCR)&prcb->HalReserved)->ApicId = apicId;
    count = 0;
    while (TRUE) {
        if (startupBlock->CompletionFlag != 0) {
            break;
        }
        if (count == 200) {
            goto procStartCleanup;
        }
        KeStallExecutionProcessor(2000);
        count += 1;
    }

    HalpMarkProcessorStarted(apicId, prcb->Number);
    processorStarted = TRUE;

procStartCleanup:

    //
    // Free the identity mapping structures, restore the CMOS reset vector
    // and method, and return
    //

    HalpFreeTiledCR3();

    *resetVectorLocation = oldResetVector;
    HalpAcquireCmosSpinLock();
    CMOS_WRITE(CMOS_SHUTDOWN_REG,cmosValue);
    HalpReleaseCmosSpinLock();

    return processorStarted;

#endif  // NT_UP
}

VOID
HalpBuildKGDTEntry32 (
    IN PKGDTENTRY64 Gdt,
    IN ULONG Selector,
    IN ULONG Base,
    IN ULONG Limit,
    IN ULONG Type,
    IN BOOLEAN LongMode
    )
{
    KGDT_BASE base;
    KGDT_LIMIT limit;
    PKGDTENTRY64 gdtEntry;

    gdtEntry = &Gdt[Selector >> 4];

    //
    // Note that although gdtEntry points to a 16-byte structure,
    // we're actually building an 8-byte GDT so we are careful to not
    // touch the high 8 bytes.
    // 

    RtlZeroMemory(gdtEntry, 8);

    //
    // Set limit information
    //  

    if (Limit > (_20BITS - 1)) {
        gdtEntry->Bits.Granularity = GRANULARITY_PAGE;
        limit.Limit = Limit / PAGE_SIZE;
    } else {
        limit.Limit = Limit;
    }

    gdtEntry->LimitLow = limit.LimitLow;
    gdtEntry->Bits.LimitHigh = limit.LimitHigh;

    //
    // Set base information
    //

    base.Base = Base;
    gdtEntry->BaseLow = base.BaseLow;
    gdtEntry->Bits.BaseMiddle = base.BaseMiddle;
    gdtEntry->Bits.BaseHigh = base.BaseHigh;

    //
    // Set other bits
    //

    gdtEntry->Bits.Present = 1;
    gdtEntry->Bits.Dpl = DPL_SYSTEM;
    if (LongMode == FALSE) {
        gdtEntry->Bits.DefaultBig = 1;
    }
    gdtEntry->Bits.Type = Type;

    if (LongMode != FALSE) {
        gdtEntry->Bits.LongMode = 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\pmrtc.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    pmrtc.c

Abstract:

    This module implements the code for ACPI-related RTC functions.

Author:
 
    Jake Oshins (jakeo) March 28, 1997
 
Environment:
 
    Kernel mode only.
 
Revision History:
 
    Split from pmclock.asm due to PIIX4 bugs.

    Forrest Foltz (forrestf) 24-Oct-2000
        Ported from pmrtc.asm to pmrtc.c
 
--*/

#include <halp.h>
#include <acpitabl.h>
#include <xxacpi.h>
#include "io_cmos.h"

VOID
HalpInitializeCmos (
    VOID
    )

/*++

Routine Description

    This routine reads CMOS and initializes globals required for CMOS access,
    such as the location of the century byte.

Arguments

    None

Return Value

    None

--*/

{
    UCHAR centuryAlarmIndex;

    //
    // If the century byte is filled in, use it... otherwise assume
    // a default value.
    //

    centuryAlarmIndex = HalpFixedAcpiDescTable.century_alarm_index;
    if (centuryAlarmIndex == 0) {
        centuryAlarmIndex = RTC_OFFSET_CENTURY;
    }

    HalpCmosCenturyOffset = centuryAlarmIndex;
}

NTSTATUS
HalpSetWakeAlarm (
    IN ULONG64 WakeSystemTime,
    IN PTIME_FIELDS WakeTimeFields
    )

/*++

Routine Description:

    This routine sets the real-time clock's alarm to go
    off at a specified time in the future and programs
    the ACPI chipset so that this wakes the computer.

Arguments:

    WakeSystemTime - amount of time that passes before we wake
    WakeTimeFields - time to wake broken down into TIME_FIELDS

Return Value:

    status

--*/

{
    UCHAR alarmPort;
    UCHAR value;

    HalpAcquireCmosSpinLockAndWait();

    CMOS_WRITE_BCD(RTC_OFFSET_SECOND_ALARM,(UCHAR)WakeTimeFields->Second);
    CMOS_WRITE_BCD(RTC_OFFSET_MINUTE_ALARM,(UCHAR)WakeTimeFields->Minute);
    CMOS_WRITE_BCD(RTC_OFFSET_HOUR_ALARM,(UCHAR)WakeTimeFields->Hour);

    alarmPort = HalpFixedAcpiDescTable.day_alarm_index;
    if (alarmPort != 0) {

        CMOS_WRITE_BCD(alarmPort,(UCHAR)WakeTimeFields->Day);
        alarmPort = HalpFixedAcpiDescTable.month_alarm_index;
        if (alarmPort != 0) {
            CMOS_WRITE_BCD(alarmPort,(UCHAR)WakeTimeFields->Month);
        }
    }

    //
    // Enable the alarm.  Be sure to preserve the daylight savings time
    // bit.
    //

    value = CMOS_READ(CMOS_STATUS_B);
    value &= REGISTER_B_DAYLIGHT_SAVINGS_TIME;
    value |= REGISTER_B_ENABLE_ALARM_INTERRUPT | REGISTER_B_24HOUR_MODE;

    CMOS_WRITE(CMOS_STATUS_B,value);
    CMOS_READ(CMOS_STATUS_C);
    CMOS_READ(CMOS_STATUS_D);

    HalpReleaseCmosSpinLock();

    return STATUS_SUCCESS;
}

VOID
HalpSetClockBeforeSleep (
   VOID
   )

/*++

Routine Description:

   This routine sets the RTC such that it will not generate
   periodic interrupts while the machine is sleeping, as this
   could be interpretted as an RTC wakeup event.

Arguments:

Return Value:

   None

--*/

{
    UCHAR value;

    HalpAcquireCmosSpinLock();

    HalpRtcRegA = CMOS_READ(CMOS_STATUS_A);
    HalpRtcRegB = CMOS_READ(CMOS_STATUS_B);

    value = HalpRtcRegB & ~REGISTER_B_ENABLE_PERIODIC_INTERRUPT;
    value |= REGISTER_B_24HOUR_MODE;
    CMOS_WRITE(CMOS_STATUS_B,value);

    CMOS_READ(CMOS_STATUS_C);
    CMOS_READ(CMOS_STATUS_D);

    HalpReleaseCmosSpinLock();
}

VOID
HalpSetClockAfterSleep (
   VOID
   )

/*++

Routine Description:

   This routine sets the RTC back to the way it was
   before a call to HalpSetClockBeforeSleep.

Arguments:

Return Value:

   None

--*/

{
    UCHAR value;

    HalpAcquireCmosSpinLock();

    CMOS_WRITE(CMOS_STATUS_A,HalpRtcRegA);

    value = HalpRtcRegB;
    value &= ~REGISTER_B_ENABLE_ALARM_INTERRUPT;
    value |= REGISTER_B_24HOUR_MODE;
    CMOS_WRITE(CMOS_STATUS_B,value);

    CMOS_READ(CMOS_STATUS_C);
    CMOS_READ(CMOS_STATUS_D);

    HalpReleaseCmosSpinLock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\pmstall.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    pmstall.c

Abstract:

    This module implements the code necessary to implement the
    Halp...StallExecution() routines for the ACPI HAL.

Author:

    Shie-Lin Tzong (shielint) 12-Jan-1990

Environment:

    Kernel mode only.

Revision History:

    bryanwi 20-Sep-90

        Add KiSetProfileInterval, KiStartProfileInterrupt,
        KiStopProfileInterrupt procedures.
        KiProfileInterrupt ISR.
        KiProfileList, KiProfileLock are delcared here.

    shielint 10-Dec-90
        Add performance counter support.
        Move system clock to irq8, ie we now use RTC to generate system
          clock.  Performance count and Profile use timer 1 counter 0.
          The interval of the irq0 interrupt can be changed by
          KiSetProfileInterval.  Performance counter does not care about the
          interval of the interrupt as long as it knows the rollover count.
        Note: Currently I implemented 1 performance counter for the whole
        i386 NT.
 
    John Vert (jvert) 11-Jul-1991
        Moved from ke\i386 to hal\i386.  Removed non-HAL stuff
 
    shie-lin tzong (shielint) 13-March-92
        Move System clock back to irq0 and use RTC (irq8) to generate
        profile interrupt.  Performance counter and system clock use time1
        counter 0 of 8254.
 
    Landy Wang (corollary!landy) 04-Dec-92
        Created this module by moving routines from ixclock.asm to here.

    Forrest Foltz (forrestf) 24-Oct-2000
        Ported from pmstall.asm to pmstall.c

--*/

#include "halcmn.h"

ULONG64 HalpStallLoopsPerTick = 3;

LARGE_INTEGER
HalpQueryPerformanceCounter (VOID);

VOID
HalpInitializeStallExecution (
   IN CCHAR ProcessorNumber                                
   )

/*++

 Routine Description:

    This routine is obsolete in this HAL.

 Arguments:

    ProcessorNumber - Processor Number

 Return Value:

    None.

--*/

{
    return;
}


VOID
KeStallExecutionProcessor (
    IN ULONG MicroSeconds
    )

/*++

Routine Description:

    This function stalls execution for the specified number of microseconds.
    KeStallExecutionProcessor

Arguments:

    MicroSeconds - Supplies the number of microseconds that execution is to be
        stalled.

Return Value:

    None.

--*/

{
    ULONG stallTicks;
    ULONG64 endTime;

    PROCESSOR_FENCE;

    if (MicroSeconds == 0) {
        return;
    }

    //
    // Target is in microseconds, or 1MHz.  Convert to PM_TMR_FREQ,
    // which is a colorburst crystal (3,579,545 Hz).
    //

    stallTicks = (ULONG)(((ULONG64)MicroSeconds * PM_TMR_FREQ) / 1000000);
    HalpPmTimerSpecialStall(stallTicks);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\acpi_mp.inc ===
;/*
;++
;
;   Module Name:
;
;       acpi_mp.inc
;
;   Abstract:
;
;       include file for ACPI MP systems.
;
;       WARNING: This file is included by both ASM and C files.
;
;   Author:
;
;
;--
;

if 0        ; Begin C only code         */

//
// The next structures are defined so that ntapic.h is 
// satisfied.  They are dummied up here so that halacpi
// can share code with halmps more easily.
//

typedef PVOID PPCMPPROCESSOR;
typedef PVOID PPCMPBUS;
typedef PVOID PPCMPIOAPIC;
typedef PVOID PPCMPINTI;
typedef PVOID PPCMPLINTI;
typedef PVOID PMPS_EXTENTRY;

//
// Generic NT APIC HAL stuff
//
#include "ntapic.inc"

/*
endif
;
;  Begin assembly part of the definitions
;

OEMPcr struc
        Reserved        dd      ?
OEMPcr ends

include ..\..\inc\ntapic.inc

;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\apic\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\ix8259.inc ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ix8259.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\xmstub.asm ===
title "Amd64 startup"

;++
;
; Copyright (c) 2001 Microsoft Corporation
;
; Module Name:
;
;    xmstub.asm
;
; Abstract:
;
;    This module implements the code that starts secondary processors.  This
;    module is unique in that it is assembled by the i386 32-bit assembler,
;    because the Amd64 assembler does not assemble 16- or 32-bit x86 code.
;
;    The .obj file that is the result of assembling this module is fed
;    through a tool, DMPOBJ.EXE, that stores the contents of the relevant
;    section and generates a c file (startup.c) that can be included in the
;    64-bit compilation process.
;
; Author:
;
;    Forrest Foltz (forrestf) March 6, 2001
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.586p

include ksamd64.inc

RMSTUB SEGMENT DWORD PUBLIC USE16 'CODE'

;++
;
; VOID
; StartPx_RMStub
;
;   When a new processor is started, it starts in real mode and is sent to a
;   copy of this function which resides in low (<1MB) memory.
;
;   When this function is complete, it jumps to StartPx_PMStub.
;
;   At this point, cs will contain (start block physical address) / 16,
;   and ip == 0.
;
;    
;
; Arguments:
;   None
;
; Return Value:
;   Does not return, jumps to StartPx_PMStub
;--

StartPx_RMStub:

        jmp     spr10                   ; skip the processor start block

        db (ProcessorStartBlockLength - ($ - StartPx_RMStub)) dup (0)

spr10:  cli
        sub     eax, eax
        mov     ax, cs
        mov     ds, ax

        ;
        ; Load edi with the linear address of the processor start block.
        ;

        shl     eax, 4
        mov     edi, eax

        ;
        ; Load the 32-bit GDT.
        ; 

        db      066h
        lgdt    fword ptr ds:[PsbGdt32]

        ;
        ; Enter protected mode.  Note paging is still off.
        ;

        mov     eax, cr0
        or      eax, CR0_PE OR CR0_ET
        mov     cr0, eax

        ;
        ; Load ds
        ;

        mov     ax, 020h
        mov     ds, ax

        ;
        ; Load CS by performing a far jump to the protected mode target
        ; address
        ;

        db      066h
        jmp     DWORD PTR ds:[edi + PsbPmTarget]

RMSTUB ENDS

;++
;
; VOID
; StartPx_PMStub
;
;   When a new processor is started, it starts in real mode and is sent to a
;   copy of this function which resides in low (<1MB) memory.
;
;   When this function is complete, it jumps to StartPx_PMStub.
;
; Arguments:
;   None
;
; Return Value:
;   Does not return, jumps to StartPx_LMStub
;--


PMSTUB SEGMENT PARA PUBLIC 'CODE'

StartPx_PMStub:

        ;
        ; 32-bit protected-mode boot code goes here.  We are still executing
        ; the low-memory, identity-mapped copy of this code.
        ;
        ; edi -> linear address of PROCESSOR_START_BLOCK
        ;

        ;
        ; Enable PAE mode (requisite for LongMode), load the tiled CR3
        ;

        mov     eax, DWORD PTR [edi] + PsbProcessorState + PsCr4
        mov     cr4, eax

        mov     eax, DWORD PTR [edi] + PsbTiledCr3
        mov     cr3, eax

        ;
        ; Set the long mode enable syscall in the EFER msr
        ;

        mov     ecx, MSR_EFER
        rdmsr
        or      eax, MSR_LME OR MSR_SCE OR MSR_NXE
        wrmsr

        ;
        ; Enable paging and activate long mode
        ;

        mov     eax, cr0
        or      eax, CR0_PG OR CR0_WP OR CR0_AM OR CR0_NE
        mov     cr0, eax

        ;
        ; Still in 32-bit legacy mode until we branch to a long mode
        ; code selector.  This will branch to HalpLMStub in amd64s.asm.
        ;

        jmp     FAR PTR [edi] + PsbLmIdentityTarget

PMSTUB ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\pmtimer.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    pmtimer.c

Abstract:

    This module implements the code for ACPI-related timer
    functions.

Author:

    Jake Oshins (jakeo) March 28, 1997

Environment:

    Kernel mode only.

Revision History:

    Split from pmclock.asm due to PIIX4 bugs.

    Forrest Foltz (forrestf) 23-Oct-2000
        Ported from pmtimer.asm to pmtimer.c

--*/


#include "halcmn.h"

#define TSC 0x10
#define PM_TMR_FREQ 3579545
#define TIMER_ROUNDING 10000
#define __1MHz 1000000


//
// HalpCurrentTime is the value of the hardware timer.  It is updated at
// every timer tick.
//

volatile ULONG64 HalpCurrentTime;
volatile ULONG HalpGlobalVolatile;

//
// HalpHardwareTimeRollover represents the maximum count + 1 of the
// hardware timer.
//
// The hardware is either 24- or 32-bits.  HalpHardwareTimeRollover will
// therefore have a vale of either 0x1000000 or 0x100000000.
//
// ACPI generates an interrupt whenever the MSb of the hardware timer
// changes.
//

ULONG64 HalpHardwareTimeRollover;

ULONG64 HalpTimeBias = 0;

//
// HalpCurrentTimePort is the port number of the 32-bit hardware timer.
//

ULONG HalpCurrentTimePort;

FORCEINLINE
ULONG
HalpReadPmTimer (
    VOID
    )
{
    ULONG value;

    ASSERT(HalpCurrentTimePort != 0);
    value = READ_PORT_ULONG(UlongToPtr(HalpCurrentTimePort));

    return value;
}

ULONG64
HalpQueryPerformanceCounter (
    VOID
    )
{
    ULONG64 currentTime;
    ULONG hardwareTime;
    ULONG lastHardwareTime;

    //
    // Get a local copy of HalpCurrentTime and the value of the hardware
    // timer, in that order.
    //

    currentTime = HalpCurrentTime;
    hardwareTime = HalpReadPmTimer();

    //
    // Extract the hardware portion of the currentTime.
    //

    lastHardwareTime = (ULONG)(currentTime & (HalpHardwareTimeRollover - 1));

    //
    // Replace the lastHardwareTime component of currentTime with the
    // current hardware time.
    //

    currentTime ^= lastHardwareTime;
    currentTime |= hardwareTime;

    //
    // Check and compensate for hardware timer rollover
    // 

    if (lastHardwareTime > hardwareTime) {
        currentTime += HalpHardwareTimeRollover;
    }

    return currentTime;
}

LARGE_INTEGER
KeQueryPerformanceCounter (
    OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
    )
{
    LARGE_INTEGER value;

    if (ARGUMENT_PRESENT(PerformanceFrequency)) {
        PerformanceFrequency->QuadPart = PM_TMR_FREQ;
    }

    value.QuadPart = HalpQueryPerformanceCounter() + HalpTimeBias;

    return value;
}


VOID
HalAcpiTimerCarry (
   VOID
   )

/*++

Routine Description:

   This routine is called to service the PM timer carry interrupt

   N.B. This function is called at interrupt time and assumes the
   caller clears the interrupt

Arguments:

   None

Return Value:

   None

--*/

{
    ULONG hardwareTime;
    ULONG64 currentTime;
    ULONG64 halfRollover;

    currentTime = HalpCurrentTime;
    hardwareTime = HalpReadPmTimer();

    //
    // ACPI generates an interrupt whenever the MSb of the hardware timer
    // changes.  Each interrupt represents, therefore, half a rollover.
    //

    halfRollover = HalpHardwareTimeRollover / 2;
    currentTime += halfRollover;

    //
    // Make sure the MSb of the hardware matches the software MSb.  Breaking
    // into the debugger might have gotten these out of sync.
    //

    currentTime += halfRollover & (currentTime ^ hardwareTime);

    //
    // Finally, store the new current time back into the global
    //

    HalpCurrentTime = currentTime;
}

VOID
HalaAcpiTimerInit(
   IN ULONG    TimerPort,
   IN BOOLEAN  TimerValExt
   )
{
    HalpCurrentTimePort = TimerPort;

    if (TimerValExt) {
        HalpHardwareTimeRollover = 0x100000000;
    } else {
        HalpHardwareTimeRollover = 0x1000000;
    }
}

VOID
HalpPmTimerSpecialStall(
    IN ULONG Ticks
    )
/*++

Routine Description:

Arguments:

    Ticks - Number of PM timer ticks to stall

Return Value:

    TRUE if we were able to stall for the correct interval,
    otherwise FALSE

--*/

{
    ULONG64 currentCounter;
    ULONG64 lastCounter;
    ULONG64 baseTime;
    ULONG64 currentTime;
    ULONG64 endTime;
    ULONG64 newCurrentTime;

    ASSERT(HalpHardwareTimeRollover != 0);

    baseTime = 0;
    lastCounter = HalpReadPmTimer();
    endTime = lastCounter + Ticks;

    do {
        currentCounter = HalpReadPmTimer();
        if (currentCounter < lastCounter) {
            baseTime += HalpHardwareTimeRollover;
        }
        lastCounter = currentCounter;
        currentTime = baseTime + currentCounter;
        if (currentTime >= endTime) {
            break;
        }
        HalpWasteTime(200);
    } while (TRUE);
}


BOOLEAN
HalpPmTimerScaleTimers(
    VOID
    )
/*++

Routine Description:

    Determines the frequency of the APIC timer, this routine is run
    during initialization

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG eflags;
    PHALPCR HalPCR;
    PKPCR PCR;
    ULONG ApicHz;
    ULONGLONG TscHz;
    ULONG RoundApicHz;
    ULONGLONG RoundTscHz;
    ULONGLONG RoundTscMhz;
    ULONGLONG currentTime;
    ULONGLONG startTime;
    ULONGLONG endTime;

    //
    // Disable interrupts on this processor
    //

    eflags = HalpDisableInterrupts();

    PCR = KeGetPcr();
    HalPCR = HalpGetCurrentHalPcr();

    //
    // Configure APIC timer
    //

    LOCAL_APIC(LU_TIMER_VECTOR) = INTERRUPT_MASKED |
                                  PERIODIC_TIMER |
                                  APIC_PROFILE_VECTOR;

    LOCAL_APIC(LU_DIVIDER_CONFIG) = LU_DIVIDE_BY_1;
    
    //
    // Make sure the write has completed, zero the perf counter,
    // and insert a processor fence
    //

    HalPCR->PerfCounter = 0;
    LOCAL_APIC(LU_DIVIDER_CONFIG);
    PROCESSOR_FENCE;

    //
    // Reset APIC counter and TSC
    //

    LOCAL_APIC(LU_INITIAL_COUNT) = 0xFFFFFFFF;
    WRMSR(TSC, 0);

    //
    // Stall for an eighth of a second
    //

    HalpPmTimerSpecialStall(PM_TMR_FREQ / 8);
    TscHz = ReadTimeStampCounter() * 8;
    ApicHz = (0 - LOCAL_APIC(LU_CURRENT_COUNT)) * 8;

    //
    // Round APIC frequency
    //

    RoundApicHz = ((ApicHz + (TIMER_ROUNDING / 2)) / TIMER_ROUNDING) *
        TIMER_ROUNDING;

    HalPCR->ApicClockFreqHz = RoundApicHz;

    //
    // Round TSC frequency
    //

    RoundTscHz = ((TscHz + (TIMER_ROUNDING / 2)) / TIMER_ROUNDING) *
        TIMER_ROUNDING;

    HalPCR->TSCHz = RoundTscHz;

    //
    // Convert TSC frequency to MHz
    //

    RoundTscMhz = (RoundTscHz + (__1MHz / 2)) / __1MHz;
    PCR->StallScaleFactor = (ULONG)RoundTscMhz;

    HalPCR->ProfileCountDown = RoundApicHz;
    LOCAL_APIC(LU_INITIAL_COUNT) = RoundApicHz; 

    //
    // Restore interrupt state
    //

    HalpRestoreInterrupts(eflags);

    return TRUE;
}

VOID
HalpWasteTime (
    ULONG Ticks
    )
{
    ULONG i;

    for (i = 0; i < Ticks; i++) {
        HalpGlobalVolatile *= i;
    }
}

VOID
#if defined(MMTIMER)
HalpPmTimerCalibratePerfCount (
#else
HalCalibratePerformanceCounter (
#endif
    IN LONG volatile *Number,
    IN ULONGLONG NewCount
    )

/*++

Routine Description:

    This routine sets the performance counter value for the current
    processor to the specified value. The reset is done such that the 
    resulting value is closely synchronized with other processors in 
    the configuration.

Arguments:

    Number - Supplies a pointer to count of the number of processors in
    the configuration.

    NewCount - Supplies the value to synchronize the counter to

Return Value:

    None.

--*/

{
    ULONG64 CurrentTime;

    if(KeGetCurrentProcessorNumber() == 0) {
        CurrentTime = HalpQueryPerformanceCounter(); 
        HalpTimeBias = NewCount - CurrentTime;
    }

    InterlockedDecrement(Number);

    //
    // Wait for all processors to signal        
    //

    while (*Number > 0) { 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\amd64\x86bios.c ===
/*--
Copyright (c) 2001  Microsoft Corporation

Module Name:

    x86bios.c

Abstract:

    This is the AMD64 specific part of the video port driver

Author:

    Forrest C. Foltz (forrestf)

Environment:

    Kernel mode only

Notes:

    This module is a driver which implements OS dependent functions on
    behalf of the video drivers

Revision history:

--*/

#include "halcmn.h"
#include <xm86.h>
#include <x86new.h>

#define LOW_MEM_SEGMET 0
#define LOW_MEM_OFFSET 0
#define SIZE_OF_VECTOR_TABLE 0x400
#define SIZE_OF_BIOS_DATA_AREA 0x400

PVOID HalpIoControlBase = NULL;
PVOID HalpIoMemoryBase = (PVOID)KSEG0_BASE;
BOOLEAN HalpX86BiosInitialized = FALSE;

extern PVOID x86BiosTranslateAddress (
    IN USHORT Segment,
    IN USHORT Offset
    );

BOOLEAN
HalpBiosDisplayReset (
    VOID
    )

/*++

Routine Description:

    This function places the VGA display into 640 x 480 16 color mode
    by calling the BIOS.

Arguments:

    None.

Return Value:

    TRUE if reset have been executed successfuly

--*/

{
    ULONG eax;
    ULONG exx;

    //
    // ah = function 0: reset display
    // al = mode 0x12: 640x480 16 color
    //

    eax = 0x0012;
    exx = 0;

    //
    // Simulate:
    //
    // mov ax, 0012h
    // int 10h
    //

    return HalCallBios(0x10,&eax,&exx,&exx,&exx,&exx,&exx,&exx);
}


BOOLEAN
HalCallBios (
    IN ULONG BiosCommand,
    IN OUT PULONG Eax,
    IN OUT PULONG Ebx,
    IN OUT PULONG Ecx,
    IN OUT PULONG Edx,
    IN OUT PULONG Esi,
    IN OUT PULONG Edi,
    IN OUT PULONG Ebp
    )

/*++

Routine Description:

    This function provides the platform specific interface between a device
    driver and the execution of the x86 ROM bios code for the specified ROM
    bios command.

Arguments:

    BiosCommand - Supplies the ROM bios command to be emulated.

    Eax to Ebp - Supplies the x86 emulation context.

Return Value:

    A value of TRUE is returned if the specified function is executed.
    Otherwise, a value of FALSE is returned.

--*/

{
    XM86_CONTEXT context;
    XM_STATUS status;

    if (HalpX86BiosInitialized == FALSE) {
        return FALSE;
    }
 
    //                                           s
    // Copy the x86 bios context and emulate the specified command.
    //
 
    context.Eax = *Eax;
    context.Ebx = *Ebx;
    context.Ecx = *Ecx;
    context.Edx = *Edx;
    context.Esi = *Esi;
    context.Edi = *Edi;
    context.Ebp = *Ebp;

    status = x86BiosExecuteInterrupt((UCHAR)BiosCommand,
                                     &context,
                                     (PVOID)HalpIoControlBase,
                                     (PVOID)HalpIoMemoryBase);

    if (status != XM_SUCCESS) {
        return FALSE;
    }
 
    //
    // Copy the x86 bios context and return TRUE.
    //
 
    *Eax = context.Eax;
    *Ebx = context.Ebx;
    *Ecx = context.Ecx;
    *Edx = context.Edx;
    *Esi = context.Esi;
    *Edi = context.Edi;
    *Ebp = context.Ebp;
 
    return TRUE;
}

VOID
HalpInitializeBios (
    VOID
    )

/*++

Routine Description:

    This routine initializes the X86 emulation module and an attached VGA
    adapter.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PULONG x86BiosLowMemoryPtr, InterruptTablePtr;
    PHYSICAL_ADDRESS COMPATIBLE_PCI_PHYSICAL_BASE_ADDRESS = { 0x0};

    x86BiosInitializeBios(NULL, (PVOID)KSEG0_BASE);

    HalpX86BiosInitialized = TRUE;

    //
    // Copy the VECTOR TABLE from 0 to 2k. This is because we are not executing
    // the initialization of Adapter. The initialization code of the Adapter 
    // could be discarded after POST. However, the emulation memory needs to be
    // updated from the interrupt vector and BIOS data area.
    //

    InterruptTablePtr = 
         (PULONG) MmMapIoSpace(COMPATIBLE_PCI_PHYSICAL_BASE_ADDRESS,
                               SIZE_OF_VECTOR_TABLE + SIZE_OF_BIOS_DATA_AREA,
                               (MEMORY_CACHING_TYPE)MmNonCached);

    if(InterruptTablePtr) {    

        x86BiosLowMemoryPtr = (PULONG)(x86BiosTranslateAddress(LOW_MEM_SEGMET, LOW_MEM_OFFSET));

        RtlCopyMemory(x86BiosLowMemoryPtr,
                      InterruptTablePtr,
                      SIZE_OF_VECTOR_TABLE + SIZE_OF_BIOS_DATA_AREA);

        MmUnmapIoSpace(InterruptTablePtr, 
                       SIZE_OF_VECTOR_TABLE + SIZE_OF_BIOS_DATA_AREA);
    
    }

}


HAL_DISPLAY_BIOS_INFORMATION
HalpGetDisplayBiosInformation (
    VOID
    )

/*++

Routine Description:

    This routine returns a value indicating how video (int 10) bios calls
    are handled.

Arguments:

    None.

Return Value:

    HalDisplayEmulatedBios

--*/

{
    //
    // This hal emulates int 10 bios calls
    //

    return HalDisplayEmulatedBios;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\ixbeep.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixbeep.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\ixclock.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixclock.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process the
;    interval clock interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;
;       Add KiSetProfileInterval, KiStartProfileInterrupt,
;       KiStopProfileInterrupt procedures.
;       KiProfileInterrupt ISR.
;       KiProfileList, KiProfileLock are delcared here.
;
;   shielint 10-Dec-90
;       Add performance counter support.
;       Move system clock to irq8, ie we now use RTC to generate system
;         clock.  Performance count and Profile use timer 1 counter 0.
;         The interval of the irq0 interrupt can be changed by
;         KiSetProfileInterval.  Performance counter does not care about the
;         interval of the interrupt as long as it knows the rollover count.
;       Note: Currently I implemented 1 performance counter for the whole
;       i386 NT.
;
;   John Vert (jvert) 11-Jul-1991
;       Moved from ke\i386 to hal\i386.  Removed non-HAL stuff
;
;   shie-lin tzong (shielint) 13-March-92
;       Move System clock back to irq0 and use RTC (irq8) to generate
;       profile interrupt.  Performance counter and system clock use time1
;       counter 0 of 8254.
;
;   Landy Wang (corollary!landy) 04-Dec-92
;       Move much code into separate modules for easy inclusion by various
;       HAL builds.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
include i386\ixcmos.inc
        .list

        EXTRNP  _KeUpdateSystemTime,0
        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _KeSetTimeIncrement,2,IMPORT
        EXTRNP  _HalEndSystemInterrupt,2
        EXTRNP  _HalBeginSystemInterrupt,3
        EXTRNP  _HalpReleaseCmosSpinLock  ,0
        EXTRNP  _HalpMcaQueueDpc, 0
        EXTRNP  _HalpBrokenPiix4TimerTick, 0
        extrn   _HalpBrokenAcpiTimer:byte
        extrn   _QueryTimer:DWORD
        extrn   _KdEnteredDebugger:DWORD
        extrn   _HalpTimerWatchdogEnabled:DWORD
        extrn   _HalpTimerWatchdogStorage:DWORD
        extrn   _HalpTimerWatchdogCurFrame:DWORD
        extrn   _HalpTimerWatchdogLastFrame:DWORD
        extrn   _HalpTimerWatchdogStorageOverflow:DWORD

;
; Constants used to initialize timer 0
;

TIMER1_DATA_PORT0       EQU     40H     ; Timer1, channel 0 data port
TIMER1_CONTROL_PORT0    EQU     43H     ; Timer1, channel 0 control port
TIMER2_DATA_PORT0       EQU     48H     ; Timer1, channel 0 data port
TIMER2_CONTROL_PORT0    EQU     4BH     ; Timer1, channel 0 control port
TIMER1_IRQ              EQU     0       ; Irq 0 for timer1 interrupt

COMMAND_8254_COUNTER0   EQU     00H     ; Select count 0
COMMAND_8254_RW_16BIT   EQU     30H     ; Read/Write LSB firt then MSB
COMMAND_8254_MODE2      EQU     4       ; Use mode 2
COMMAND_8254_BCD        EQU     0       ; Binary count down
COMMAND_8254_LATCH_READ EQU     0       ; Latch read command

PERFORMANCE_FREQUENCY   EQU     1193182

COUNTER_TICKS_AVG_SHIFT EQU     4
COUNTER_TICKS_FOR_AVG   EQU     16
PAGE_SIZE               EQU     1000H
FRAME_COPY_SIZE         EQU     64

;
; ==== Values used for System Clock ====
;


_DATA   SEGMENT  DWORD PUBLIC 'DATA'

;
; The following array stores the per microsecond loop count for each
; central processor.
;

;
; 8254 performance counter.
;

        public HalpCurrentRollOver, HalpCurrentTimeIncrement, _HalpCurrentMSRateTableIndex
HalpCurrentRollOver           dd      0
HalpCurrentTimeIncrement      dd      0
_HalpCurrentMSRateTableIndex  dd      0
	
        public _HalpClockWork, _HalpClockSetMSRate, _HalpClockMcaQueueDpc
_HalpClockWork label dword
    _HalpClockSetMSRate     db  0
    _HalpClockMcaQueueDpc   db  0
    _bReserved1             db  0
    _bReserved2             db  0

;
; timer latency watchdog variables
;

        public  _HalpWatchdogAvgCounter, _HalpWatchdogCountLow, _HalpWatchdogCountHigh
        public  _HalpWatchdogTscLow, _HalpWatchdogTscHigh

    _HalpWatchdogAvgCounter dd  0
    _HalpWatchdogCountLow   dd  0
    _HalpWatchdogCountHigh  dd  0
    _HalpWatchdogTscLow     dd  0
    _HalpWatchdogTscHigh    dd  0

_DATA   ends

_TEXT   SEGMENT  DWORD PUBLIC 'DATA'

;
; Convert the interval to rollover count for 8254 Timer1 device.
; Timer1 counts down a 16 bit value at a rate of 1.193181667M counts-per-sec.
; (The main crystal freq is 14.31818, and this is a divide by 12)
;
; The best fit value closest to 10ms is 10.0144012689ms:
;   ROLLOVER_COUNT      11949
;   TIME_INCREMENT      100144
;   Calculated error is -.0109472 s/day
;
;
; The following table contains 8254 values timer values to use at
; any given ms setting from 1ms - 15ms.  All values work out to the
; same error per day (-.0109472 s/day).
;

        public HalpRollOverTable

        ;                    RollOver   Time
        ;                    Count      Increment   MS
HalpRollOverTable       dd      1197,   10032       ;  1 ms
                        dd      2394,   20064       ;  2 ms
                        dd      3591,   30096       ;  3 ms
                        dd      4767,   39952       ;  4 ms
                        dd      5964,   49984       ;  5 ms
                        dd      7161,   60016       ;  6 ms
                        dd      8358,   70048       ;  7 ms
                        dd      9555,   80080       ;  8 ms
                        dd     10731,   89936       ;  9 ms
                        dd     11949,  100144       ; 10 ms
                        dd     13125,  110000       ; 11 ms
                        dd     14322,  120032       ; 12 ms
                        dd     15519,  130064       ; 13 ms
                        dd     16695,  139920       ; 14 ms
                        dd     17892,  149952       ; 15 ms

TimeIncr equ    4
RollOver equ    0

_TEXT   ends

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

        public HalpLargestClockMS, _HalpNextMSRate, HalpPendingMSRate
HalpLargestClockMS      dd      15      ; Table goes to 15MS
_HalpNextMSRate         dd      14
HalpPendingMSRate       dd      0

        extrn _TimerInfo:DWORD

BiasLow equ 20
BiasHigh equ 24


_DATA   ends


PAGELK  SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Initialize Clock"
;++
;
; VOID
; HalpInitializeClock (
;    )
;
; Routine Description:
;
;    This routine initialize system time clock using 8254 timer1 counter 0
;    to generate an interrupt at every 15ms interval at 8259 irq0.
;
;    See the definitions of TIME_INCREMENT and ROLLOVER_COUNT if clock rate
;    needs to be changed.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None.
;
;--
cPublicProc _HalpInitializeClock      ,0

        mov     eax, PCR[PcPrcb]
        cmp     byte ptr [eax].PbCpuType, 4     ; 486 or better?
        jc      short @f                        ; no, skip

        mov     HalpLargestClockMS, 10          ; Limit 486's to 10MS
	mov     _HalpNextMSRate, 9
@@:
        mov     eax, HalpLargestClockMS
	mov     _HalpCurrentMSRateTableIndex, eax
	dec     _HalpCurrentMSRateTableIndex
        mov     ecx, HalpRollOverTable.TimeIncr
        mov     edx, HalpRollOverTable[eax*8-8].TimeIncr
        mov     eax, HalpRollOverTable[eax*8-8].RollOver

        mov     HalpCurrentTimeIncrement, edx

;
; (ecx) = Min time_incr
; (edx) = Max time_incr
; (eax) = max roll over count
;

        push    eax
        stdCall _KeSetTimeIncrement, <edx, ecx>
        pop     ecx

;
; timer latency watchdog initialization
;
        cmp     _HalpTimerWatchdogEnabled, 0
        jz      short @f

        .586p
        rdtsc
        .386p
        mov     _HalpWatchdogAvgCounter, COUNTER_TICKS_FOR_AVG
        mov     _HalpWatchdogTscLow, eax
        mov     _HalpWatchdogTscHigh, edx
        xor     eax, eax
        mov     _HalpWatchdogCountLow, eax
        mov     _HalpWatchdogCountHigh, eax
@@:    

        pushfd                          ; save caller's eflag
        cli                             ; make sure interrupts are disabled

;
; Set clock rate
; (ecx) = RollOverCount
;

        mov     al,COMMAND_8254_COUNTER0+COMMAND_8254_RW_16BIT+COMMAND_8254_MODE2
        out     TIMER1_CONTROL_PORT0, al ;program count mode of timer 0
        IoDelay
        mov     al, cl
        out     TIMER1_DATA_PORT0, al   ; program timer 0 LSB count
        IoDelay
        mov     al,ch
        out     TIMER1_DATA_PORT0, al   ; program timer 0 MSB count

        popfd                             ; restore caller's eflag
        mov     HalpCurrentRollOver, ecx  ; Set RollOverCount & initialized

        stdRET    _HalpInitializeClock

stdENDP _HalpInitializeClock

PAGELK  ends

_TEXT$03   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "System Clock Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt generated by CLOCK.
;    Its function is to dismiss the interrupt, raise system Irql to
;    CLOCK2_LEVEL, update performance counter and transfer control to the
;    standard system routine to update the system time and the execution
;    time of the current thread
;    and process.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    Does not return, jumps directly to KeUpdateSystemTime, which returns
;
;    Sets Irql = CLOCK2_LEVEL and dismisses the interrupt
;
;--
        ENTER_DR_ASSIST Hci_a, Hci_t

cPublicProc _HalpClockInterrupt     ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hci_a, Hci_t

;
; (esp) - base of trap frame
;

ifdef MCA

;
; Special hack for MCA machines
;

        in      al, 61h
        jmp     $+2
        or      al, 80h
        out     61h, al
        jmp     $+2

endif   ; MCA


;
; Dismiss interrupt and raise irq level to clock2 level
;

Hci10:
        push    CLOCK_VECTOR
        sub     esp, 4                  ; allocate space to save OldIrql
        stdCall   _HalBeginSystemInterrupt, <CLOCK2_LEVEL, CLOCK_VECTOR, esp>

        or      al,al                           ; check for spurious interrupt
        jz      Hci100

;
; Check to see if we need to fix up a broken PIIX4
;

        .if (_HalpBrokenAcpiTimer)
        stdCall _HalpBrokenPiix4TimerTick
        .endif

;
; Timer latency watchdog
;

        cmp     _HalpTimerWatchdogEnabled, 0
        jz      Hci14

        .586p
        rdtsc
        .386p

;
; Compare difference to watchdog count, while storing a copy of the
; current counter.
;

        xor     ebx, ebx
        push    eax
        push    edx
        sub     eax, _HalpWatchdogTscLow
        sbb     edx, _HalpWatchdogTscHigh
        pop     _HalpWatchdogTscHigh
        pop     _HalpWatchdogTscLow
        js      Hci115                      ; Was this a bogus counter?
                                            ;   (e.g, negative delta)


        push    eax
        mov     ecx, dword ptr _KdEnteredDebugger
        xor     eax, eax
        xchg    eax, [ecx]
        or      al, al                      
        pop     eax
        jnz     Hci14

        cmp     HalpPendingMSRate, ebx      ; Was a new rate set during last
        jnz     Hci14                       ; tick?  Yes, skip this compare

;
; If we need to compute the average of the time-stamp counter for
; the current period, add the delta to the counter.
;

        cmp     _HalpWatchdogAvgCounter, ebx
        jnz     Hci12

        cmp     edx, _HalpWatchdogCountHigh
        ja      short Hci11
        jb      Hci14

        cmp     eax, _HalpWatchdogCountLow
        jbe     Hci14

Hci11:  
        cmp     dword ptr [_HalpTimerWatchdogStorageOverflow], 0
        jne     short Hci115


;
; copy FRAME_COPY_SIZE dwords from the stack, or to next page boundary,
; whichever is less
;       

        push    esi
        push    edi
        lea     esi, [esp + 8]
        lea     ecx, [esi + PAGE_SIZE - 1]
        and     ecx, NOT(PAGE_SIZE - 1)
        sub     ecx, esi
        shr     ecx, 2
        cmp     ecx, FRAME_COPY_SIZE
        jbe     short Hci111
        mov     ecx, FRAME_COPY_SIZE
Hci111:
        mov     edi, dword ptr _HalpTimerWatchdogCurFrame
        rep     movsd
        add     dword ptr _HalpTimerWatchdogCurFrame, (FRAME_COPY_SIZE*4)
;
; If we didn't copy an entire FRAME_COPY_SIZE dwords, zero fill.
;
        mov     ecx, dword ptr _HalpTimerWatchdogCurFrame
        sub     ecx, edi
        shr     ecx, 2
        xor     eax, eax
        rep     stosd
        cmp     edi, dword ptr _HalpTimerWatchdogLastFrame
        jbe     short Hci112
        mov     dword ptr [_HalpTimerWatchdogStorageOverflow], 1
Hci112:

        pop     edi
        pop     esi

Hci115:


;
; reset last time so that we're accurate after the trap
;
        .586p
        rdtsc
        .386p
        mov     _HalpWatchdogTscHigh, edx
        mov     _HalpWatchdogTscLow, eax
        
        jmp     short Hci14

Hci12:
;
; Increment the total counter, perform average when the count is reached
;

        add     _HalpWatchdogCountLow, eax
        adc     _HalpWatchdogCountHigh, edx        
        dec     _HalpWatchdogAvgCounter
        jnz     short Hci14

        mov     edx, _HalpWatchdogCountHigh
        mov     eax, _HalpWatchdogCountLow

;
; compute the average * 2, this measures when we have missed 
; an interrupt at this rate.
;                 
        mov     ecx, COUNTER_TICKS_AVG_SHIFT - 1
Hci13:    
        shr     edx, 1
        rcr     eax, 1
        loop    short Hci13

        mov     _HalpWatchdogCountLow, eax
        mov     _HalpWatchdogCountHigh, edx

Hci14:

;
; Check for any more work
;
        mov     eax, HalpCurrentTimeIncrement

        xor     ebx, ebx
        cmp     _HalpClockWork, ebx         ; Any clock interrupt work desired?
        jz      _KeUpdateSystemTime@0       ; No, process tick

        cmp     _HalpClockMcaQueueDpc, bl
        je      short Hci20

        mov     _HalpClockMcaQueueDpc, bl

;
; Queue MCA Dpc 
;

        push    eax
        stdCall _HalpMcaQueueDpc            ; Queue MCA Dpc
        pop     eax


Hci20:
;
; (esp)   = OldIrql
; (esp+4) = Vector
; (esp+8) = base of trap frame
; ebp = trap frame
; eax = time increment
; ebx = 0
;
        cmp     _HalpClockSetMSRate, bl     ; New clock rate desired?
        jz      _KeUpdateSystemTime@0       ; No, process tick


;
; Time of clock frequency is being changed.  See if the 8254 was
; was reprogrammed for a new rate during last tick
;
        cmp     HalpPendingMSRate, ebx      ; Was a new rate set durning last
        jnz     short Hci50                 ; tick?  Yes, go update globals

Hci40:
; (eax) = time increment for current tick

;
; A new clock rate needs to be set.  Setting the rate here will
; cause the tick after the next tick to be at the new rate.
; (the next tick is already in progress by the 8254 and will occur
; at the same rate as this tick)
;
        mov     ebx, _HalpNextMSRate
        mov     HalpPendingMSRate, ebx  ; pending rate

        mov     ecx, HalpRollOverTable[ebx*8-8].RollOver

;
; Set clock rate
; (ecx) = RollOverCount
;
        push    eax                     ; save current tick's rate

        mov     al,COMMAND_8254_COUNTER0+COMMAND_8254_RW_16BIT+COMMAND_8254_MODE2
        out     TIMER1_CONTROL_PORT0, al ;program count mode of timer 0
        IoDelay
        mov     al, cl
        out     TIMER1_DATA_PORT0, al   ; program timer 0 LSB count
        IoDelay
        mov     al,ch
        out     TIMER1_DATA_PORT0, al   ; program timer 0 MSB count

        pop     eax

;
; (esp)   = OldIrql
; (esp+4) = Vector
; (esp+8) = base of trap frame
; ebp = trap frame
; eax = time increment
;
        jmp     _KeUpdateSystemTime@0   ; dispatch this tick

Hci50:
;
; The next tick will occur at the rate which was programmed during the last
; tick. Update globals for new rate which starts with the next tick.
;
; (eax) = time increment for current tick
;
        mov     ebx, HalpPendingMSRate
	mov     _HalpCurrentMSRateTableIndex, ebx
	dec     _HalpCurrentMSRateTableIndex
        mov     ecx, HalpRollOverTable[ebx*8-8].RollOver
        mov     edx, HalpRollOverTable[ebx*8-8].TimeIncr

        mov     HalpCurrentRollOver, ecx
        mov     HalpCurrentTimeIncrement, edx   ; next tick rate
        mov     HalpPendingMSRate, 0    ; no longer pending, clear it

        cmp     _HalpTimerWatchdogEnabled, 0
        jz      short @f

;
; Schedule to recalibrate watchdog counter
;
        push    eax
        .586p
        rdtsc
        .386p
        mov     _HalpWatchdogAvgCounter, COUNTER_TICKS_FOR_AVG
        mov     _HalpWatchdogTscLow, eax
        mov     _HalpWatchdogTscHigh, edx

        xor     eax,eax
        mov     _HalpWatchdogCountHigh, eax
        mov     _HalpWatchdogCountLow, eax
        pop     eax
@@:

        cmp     ebx, _HalpNextMSRate    ; new rate == NextRate?
        jne     Hci40                   ; no, go set new pending rate

        mov     _HalpClockSetMSRate, 0  ; all done setting new rate
        jmp     _KeUpdateSystemTime@0   ; dispatch this tick

Hci100:
        add     esp, 8                  ; spurious, no EndOfInterrupt
        SPURIOUS_INTERRUPT_EXIT         ; exit interrupt without eoi

stdENDP _HalpClockInterrupt

;++
;
; ULONG
; HalpAcpiTimerSetTimeIncrement (
;     IN ULONG DesiredIncrement
;     )
;
; /*++
;
; Routine Description:
;
;    This routine initialize system time clock to generate an
;    interrupt at every DesiredIncrement interval.
;
; Arguments:
;
;     DesiredIncrement - desired interval between every timer tick (in
;                        100ns unit.)
;
; Return Value:
;
;     The *REAL* time increment set.
;--
cPublicProc _HalpAcpiTimerSetTimeIncrement,1

        mov     eax, [esp+4]                ; desired setting
        xor     edx, edx
        mov     ecx, 9990
        div     ecx                         ; round to MS

        cmp     eax, HalpLargestClockMS     ; MS > max?
        jc      short @f
        mov     eax, HalpLargestClockMS     ; yes, use max
@@:
        or      eax, eax                    ; MS < min?
        jnz     short @f
        inc     eax                         ; yes, use min
@@:
        mov     _HalpNextMSRate, eax
        mov     _HalpClockSetMSRate, 1      ; New clock rate desired.

        mov     eax, HalpRollOverTable[eax*8-8].TimeIncr
        stdRET  _HalpAcpiTimerSetTimeIncrement

stdENDP _HalpAcpiTimerSetTimeIncrement

        page ,132
        subttl  "Query 8254 Counter"
;++
;
; ULONG
; HalpQuery8254Counter(
;    VOID
;    )
;
; Routine Description:
;
;    This routine returns the current value of the 8254 counter
;
; Arguments:
;
;    None
;
; Return Value:
;
;    Current value of the 8254 counter is returned
;
;--

	cPublicProc _HalpQuery8254Counter, 0

	pushfd
        cli

;
; Fetch the current counter value from the hardware
;

        mov     al, COMMAND_8254_LATCH_READ + COMMAND_8254_COUNTER0
                                        ; Latch PIT Ctr 0 command.
        out     TIMER1_CONTROL_PORT0, al
        IODelay
        in      al, TIMER1_DATA_PORT0   ; Read PIT Ctr 0, LSByte.
        IODelay
        movzx   ecx, al                 ; Zero upper bytes of (ECX).
        in      al, TIMER1_DATA_PORT0   ; Read PIT Ctr 0, MSByte.
        mov     ch, al                  ; (CX) = PIT Ctr 0 count.

	mov     eax, ecx
		
        popfd                           ; restore interrupt flag

        stdRET    _HalpQuery8254Counter

stdENDP _HalpQuery8254Counter
	
_TEXT$03   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\ixcmos.inc ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixcmos.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\ixcmos.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

ACPI_HAL equ 1

include ..\..\halx86\i386\ixcmos.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\ixidle.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixidle.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\ixprofil.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixprofil.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\ixmovnti.asm ===
;
; Include code from halx86
;

include ..\..\halx86\i386\ixmovnti.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\ixipi.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixipi.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\ixmcaa.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixmcaa.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\ixslpctx.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

ACPI_HAL equ 1

include ..\..\halx86\i386\ixslpctx.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\ixslpctx.inc ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixslpctx.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\ixswint.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixswint.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\mpclksup.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

MMTIMER equ 1

include ..\..\halmps\i386\mpclksup.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\mp8254.inc ===
;/*
; Include code from halx86
; This is a cpp style symbolic link
;

if 0 ; */

#include "..\..\halmps\i386\mp8254.inc"

/*
else

include ..\..\halmps\i386\mp8254.inc

endif ; */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\mcsysint.asm ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    ixsysint.asm
;
;Abstract:
;
;    This module implements the HAL routines to enable/disable system
;    interrupts.
;
;Author:
;
;    John Vert (jvert) 22-Jul-1991
;
;Environment:
;
;    Kernel Mode
;
;Revision History:
;
;--


.386p
        .xlist
include hal386.inc
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
include callconv.inc
include xxacpi.h
        .list

        extrn   KiI8259MaskTable:DWORD
        EXTRNP  _KeBugCheck,1,IMPORT

;
; Constants used to initialize CMOS/Real Time Clock
;

CMOS_CONTROL_PORT       EQU     70h     ; command port for cmos
CMOS_DATA_PORT          EQU     71h     ; cmos data port

;
; Macros to Read/Write/Reset CMOS to initialize RTC
;

; CMOS_READ
;
; Description: This macro read a byte from the CMOS register specified
;        in (AL).
;
; Parameter: (AL) = address/register to read
; Return: (AL) = data
;

CMOS_READ       MACRO
        OUT     CMOS_CONTROL_PORT,al    ; ADDRESS LOCATION AND DISABLE NMI
        IODelay                         ; I/O DELAY
        IN      AL,CMOS_DATA_PORT       ; READ IN REQUESTED CMOS DATA
        IODelay                         ; I/O DELAY
ENDM

_TEXT   SEGMENT DWORD PUBLIC 'DATA'

align   dword
;
; HalDismissSystemInterrupt does an indirect jump through this table so it
; can quickly execute specific code for different interrupts.
;
        public  HalpSpecialDismissTable
HalpSpecialDismissTable label   dword
        dd      offset FLAT:HalpDismissNormal   ; irq 0
        dd      offset FLAT:HalpDismissNormal   ; irq 1
        dd      offset FLAT:HalpDismissNormal   ; irq 2
        dd      offset FLAT:HalpDismissNormal   ; irq 3
        dd      offset FLAT:HalpDismissNormal   ; irq 4
        dd      offset FLAT:HalpDismissNormal   ; irq 5
        dd      offset FLAT:HalpDismissNormal   ; irq 6
        dd      offset FLAT:HalpDismissIrq07    ; irq 7
        dd      offset FLAT:HalpDismissNormal   ; irq 8
        dd      offset FLAT:HalpDismissNormal   ; irq 9
        dd      offset FLAT:HalpDismissNormal   ; irq A
        dd      offset FLAT:HalpDismissNormal   ; irq B
        dd      offset FLAT:HalpDismissNormal   ; irq C
        dd      offset FLAT:HalpDismissNormal   ; irq D
        dd      offset FLAT:HalpDismissNormal   ; irq E
        dd      offset FLAT:HalpDismissIrq0f    ; irq F
        dd      offset FLAT:HalpDismissNormal   ; irq 10
        dd      offset FLAT:HalpDismissNormal   ; irq 11
        dd      offset FLAT:HalpDismissNormal   ; irq 12
        dd      offset FLAT:HalpDismissNormal   ; irq 13
        dd      offset FLAT:HalpDismissNormal   ; irq 14
        dd      offset FLAT:HalpDismissNormal   ; irq 15
        dd      offset FLAT:HalpDismissNormal   ; irq 16
        dd      offset FLAT:HalpDismissNormal   ; irq 17
        dd      offset FLAT:HalpDismissNormal   ; irq 18
        dd      offset FLAT:HalpDismissNormal   ; irq 19
        dd      offset FLAT:HalpDismissNormal   ; irq 1A
        dd      offset FLAT:HalpDismissNormal   ; irq 1B
        dd      offset FLAT:HalpDismissNormal   ; irq 1C
        dd      offset FLAT:HalpDismissNormal   ; irq 1D
        dd      offset FLAT:HalpDismissNormal   ; irq 1E
        dd      offset FLAT:HalpDismissNormal   ; irq 1F
        dd      offset FLAT:HalpDismissNormal   ; irq 20
        dd      offset FLAT:HalpDismissNormal   ; irq 21
        dd      offset FLAT:HalpDismissNormal   ; irq 22
        dd      offset FLAT:HalpDismissNormal   ; irq 23
        dd      offset FLAT:HalpDismissInvalidVector  ;24
        dd      offset FLAT:HalpDismissInvalidVector  ;25
        dd      offset FLAT:HalpDismissInvalidVector  ;26
        dd      offset FLAT:HalpDismissInvalidVector  ;27
        dd      offset FLAT:HalpDismissInvalidVector  ;28
        dd      offset FLAT:HalpDismissInvalidVector  ;29
        dd      offset FLAT:HalpDismissInvalidVector  ;2a
        dd      offset FLAT:HalpDismissInvalidVector  ;2b
        dd      offset FLAT:HalpDismissInvalidVector  ;2c
        dd      offset FLAT:HalpDismissInvalidVector  ;2d
        dd      offset FLAT:HalpDismissInvalidVector  ;2e
        dd      offset FLAT:HalpDismissInvalidVector  ;2f
        dd      offset FLAT:HalpDismissInvalidVector  ;30
        dd      offset FLAT:HalpDismissInvalidVector  ;31
        dd      offset FLAT:HalpDismissInvalidVector  ;32
        dd      offset FLAT:HalpDismissInvalidVector  ;33
        dd      offset FLAT:HalpDismissInvalidVector  ;34
        dd      offset FLAT:HalpDismissInvalidVector  ;35
        dd      offset FLAT:HalpDismissInvalidVector  ;36
        dd      offset FLAT:HalpDismissInvalidVector  ;37
        dd      offset FLAT:HalpDismissInvalidVector  ;38
        dd      offset FLAT:HalpDismissInvalidVector  ;39
        dd      offset FLAT:HalpDismissInvalidVector  ;3a
        dd      offset FLAT:HalpDismissInvalidVector  ;3b
        dd      offset FLAT:HalpDismissInvalidVector  ;3c
        dd      offset FLAT:HalpDismissInvalidVector  ;3d
        dd      offset FLAT:HalpDismissInvalidVector  ;3e
        dd      offset FLAT:HalpDismissInvalidVector  ;3f
        dd      offset FLAT:HalpDismissInvalidVector  ;40
        dd      offset FLAT:HalpDismissInvalidVector  ;41
        dd      offset FLAT:HalpDismissInvalidVector  ;42
        dd      offset FLAT:HalpDismissInvalidVector  ;43
        dd      offset FLAT:HalpDismissInvalidVector  ;44
        dd      offset FLAT:HalpDismissInvalidVector  ;45
        dd      offset FLAT:HalpDismissInvalidVector  ;46
        dd      offset FLAT:HalpDismissInvalidVector  ;47
        dd      offset FLAT:HalpDismissInvalidVector  ;48
        dd      offset FLAT:HalpDismissInvalidVector  ;49
        dd      offset FLAT:HalpDismissInvalidVector  ;4a
        dd      offset FLAT:HalpDismissInvalidVector  ;4b
        dd      offset FLAT:HalpDismissInvalidVector  ;4c
        dd      offset FLAT:HalpDismissInvalidVector  ;4d
        dd      offset FLAT:HalpDismissInvalidVector  ;4e
        dd      offset FLAT:HalpDismissInvalidVector  ;4f
        dd      offset FLAT:HalpDismissInvalidVector  ;50
        dd      offset FLAT:HalpDismissInvalidVector  ;51
        dd      offset FLAT:HalpDismissInvalidVector  ;52
        dd      offset FLAT:HalpDismissInvalidVector  ;53
        dd      offset FLAT:HalpDismissInvalidVector  ;54
        dd      offset FLAT:HalpDismissInvalidVector  ;55
        dd      offset FLAT:HalpDismissInvalidVector  ;56
        dd      offset FLAT:HalpDismissInvalidVector  ;57
        dd      offset FLAT:HalpDismissInvalidVector  ;58
        dd      offset FLAT:HalpDismissInvalidVector  ;59
        dd      offset FLAT:HalpDismissInvalidVector  ;5a
        dd      offset FLAT:HalpDismissInvalidVector  ;5b
        dd      offset FLAT:HalpDismissInvalidVector  ;5c
        dd      offset FLAT:HalpDismissInvalidVector  ;5d
        dd      offset FLAT:HalpDismissInvalidVector  ;5e
        dd      offset FLAT:HalpDismissInvalidVector  ;5f
        dd      offset FLAT:HalpDismissInvalidVector  ;60
        dd      offset FLAT:HalpDismissInvalidVector  ;61
        dd      offset FLAT:HalpDismissInvalidVector  ;62
        dd      offset FLAT:HalpDismissInvalidVector  ;63
        dd      offset FLAT:HalpDismissInvalidVector  ;64
        dd      offset FLAT:HalpDismissInvalidVector  ;65
        dd      offset FLAT:HalpDismissInvalidVector  ;66
        dd      offset FLAT:HalpDismissInvalidVector  ;67
        dd      offset FLAT:HalpDismissInvalidVector  ;68
        dd      offset FLAT:HalpDismissInvalidVector  ;69
        dd      offset FLAT:HalpDismissInvalidVector  ;6a
        dd      offset FLAT:HalpDismissInvalidVector  ;6b
        dd      offset FLAT:HalpDismissInvalidVector  ;6c
        dd      offset FLAT:HalpDismissInvalidVector  ;6d
        dd      offset FLAT:HalpDismissInvalidVector  ;6e
        dd      offset FLAT:HalpDismissInvalidVector  ;6f
        dd      offset FLAT:HalpDismissInvalidVector  ;70
        dd      offset FLAT:HalpDismissInvalidVector  ;71
        dd      offset FLAT:HalpDismissInvalidVector  ;72
        dd      offset FLAT:HalpDismissInvalidVector  ;73
        dd      offset FLAT:HalpDismissInvalidVector  ;74
        dd      offset FLAT:HalpDismissInvalidVector  ;75
        dd      offset FLAT:HalpDismissInvalidVector  ;76
        dd      offset FLAT:HalpDismissInvalidVector  ;77
        dd      offset FLAT:HalpDismissInvalidVector  ;78
        dd      offset FLAT:HalpDismissInvalidVector  ;79
        dd      offset FLAT:HalpDismissInvalidVector  ;7a
        dd      offset FLAT:HalpDismissInvalidVector  ;7b
        dd      offset FLAT:HalpDismissInvalidVector  ;7c
        dd      offset FLAT:HalpDismissInvalidVector  ;7d
        dd      offset FLAT:HalpDismissInvalidVector  ;7e
        dd      offset FLAT:HalpDismissInvalidVector  ;7f
        dd      offset FLAT:HalpDismissInvalidVector  ;80
        dd      offset FLAT:HalpDismissInvalidVector  ;81
        dd      offset FLAT:HalpDismissInvalidVector  ;82
        dd      offset FLAT:HalpDismissInvalidVector  ;83
        dd      offset FLAT:HalpDismissInvalidVector  ;84
        dd      offset FLAT:HalpDismissInvalidVector  ;85
        dd      offset FLAT:HalpDismissInvalidVector  ;86
        dd      offset FLAT:HalpDismissInvalidVector  ;87
        dd      offset FLAT:HalpDismissInvalidVector  ;88
        dd      offset FLAT:HalpDismissInvalidVector  ;89
        dd      offset FLAT:HalpDismissInvalidVector  ;8a
        dd      offset FLAT:HalpDismissInvalidVector  ;8b
        dd      offset FLAT:HalpDismissInvalidVector  ;8c
        dd      offset FLAT:HalpDismissInvalidVector  ;8d
        dd      offset FLAT:HalpDismissInvalidVector  ;8e
        dd      offset FLAT:HalpDismissInvalidVector  ;8f
        dd      offset FLAT:HalpDismissInvalidVector  ;90
        dd      offset FLAT:HalpDismissInvalidVector  ;91
        dd      offset FLAT:HalpDismissInvalidVector  ;92
        dd      offset FLAT:HalpDismissInvalidVector  ;93
        dd      offset FLAT:HalpDismissInvalidVector  ;94
        dd      offset FLAT:HalpDismissInvalidVector  ;95
        dd      offset FLAT:HalpDismissInvalidVector  ;96
        dd      offset FLAT:HalpDismissInvalidVector  ;97
        dd      offset FLAT:HalpDismissInvalidVector  ;98
        dd      offset FLAT:HalpDismissInvalidVector  ;99
        dd      offset FLAT:HalpDismissInvalidVector  ;9a
        dd      offset FLAT:HalpDismissInvalidVector  ;9b
        dd      offset FLAT:HalpDismissInvalidVector  ;9c
        dd      offset FLAT:HalpDismissInvalidVector  ;9d
        dd      offset FLAT:HalpDismissInvalidVector  ;9e
        dd      offset FLAT:HalpDismissInvalidVector  ;9f
        dd      offset FLAT:HalpDismissInvalidVector  ;a0
        dd      offset FLAT:HalpDismissInvalidVector  ;a1
        dd      offset FLAT:HalpDismissInvalidVector  ;a2
        dd      offset FLAT:HalpDismissInvalidVector  ;a3
        dd      offset FLAT:HalpDismissInvalidVector  ;a4
        dd      offset FLAT:HalpDismissInvalidVector  ;a5
        dd      offset FLAT:HalpDismissInvalidVector  ;a6
        dd      offset FLAT:HalpDismissInvalidVector  ;a7
        dd      offset FLAT:HalpDismissInvalidVector  ;a8
        dd      offset FLAT:HalpDismissInvalidVector  ;a9
        dd      offset FLAT:HalpDismissInvalidVector  ;aa
        dd      offset FLAT:HalpDismissInvalidVector  ;ab
        dd      offset FLAT:HalpDismissInvalidVector  ;ac
        dd      offset FLAT:HalpDismissInvalidVector  ;ad
        dd      offset FLAT:HalpDismissInvalidVector  ;ae
        dd      offset FLAT:HalpDismissInvalidVector  ;af
        dd      offset FLAT:HalpDismissInvalidVector  ;b0
        dd      offset FLAT:HalpDismissInvalidVector  ;b1
        dd      offset FLAT:HalpDismissInvalidVector  ;b2
        dd      offset FLAT:HalpDismissInvalidVector  ;b3
        dd      offset FLAT:HalpDismissInvalidVector  ;b4
        dd      offset FLAT:HalpDismissInvalidVector  ;b5
        dd      offset FLAT:HalpDismissInvalidVector  ;b6
        dd      offset FLAT:HalpDismissInvalidVector  ;b7
        dd      offset FLAT:HalpDismissInvalidVector  ;b8
        dd      offset FLAT:HalpDismissInvalidVector  ;b9
        dd      offset FLAT:HalpDismissInvalidVector  ;ba
        dd      offset FLAT:HalpDismissInvalidVector  ;bb
        dd      offset FLAT:HalpDismissInvalidVector  ;bc
        dd      offset FLAT:HalpDismissInvalidVector  ;bd
        dd      offset FLAT:HalpDismissInvalidVector  ;be
        dd      offset FLAT:HalpDismissInvalidVector  ;bf
        dd      offset FLAT:HalpDismissInvalidVector  ;c0
        dd      offset FLAT:HalpDismissInvalidVector  ;c1
        dd      offset FLAT:HalpDismissInvalidVector  ;c2
        dd      offset FLAT:HalpDismissInvalidVector  ;c3
        dd      offset FLAT:HalpDismissInvalidVector  ;c4
        dd      offset FLAT:HalpDismissInvalidVector  ;c5
        dd      offset FLAT:HalpDismissInvalidVector  ;c6
        dd      offset FLAT:HalpDismissInvalidVector  ;c7
        dd      offset FLAT:HalpDismissInvalidVector  ;c8
        dd      offset FLAT:HalpDismissInvalidVector  ;c9
        dd      offset FLAT:HalpDismissInvalidVector  ;ca
        dd      offset FLAT:HalpDismissInvalidVector  ;cb
        dd      offset FLAT:HalpDismissInvalidVector  ;cc
        dd      offset FLAT:HalpDismissInvalidVector  ;cd
        dd      offset FLAT:HalpDismissInvalidVector  ;ce
        dd      offset FLAT:HalpDismissInvalidVector  ;cf

_TEXT   ENDS

_TEXT$01   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


;++
;BOOLEAN
;HalBeginSystemInterrupt(
;    IN KIRQL Irql
;    IN ULONG Vector,
;    OUT PKIRQL OldIrql
;    )
;
;
;
;Routine Description:
;
;    This routine is used to dismiss the specified vector number.  It is called
;    before any interrupt service routine code is executed.
;
;    N.B.  This routine does NOT preserve EAX or EBX
;
;    On a UP machine the interrupt dismissed at BeginSystemInterrupt time.
;    This is fine since the irql is being raise to mask it off.
;    HalEndSystemInterrupt is simply a LowerIrql request.
;
;
;Arguments:
;
;    Irql   - Supplies the IRQL to raise to
;
;    Vector - Supplies the vector of the interrupt to be processed
;
;    OldIrql- Location to return OldIrql
;
;
;Return Value:
;
;    FALSE - Interrupt is spurious and should be ignored
;
;    TRUE -  Interrupt successfully dismissed and Irql raised.
;
;--
align dword
HbsiIrql        equ     byte  ptr [esp+4]
HbsiVector      equ     byte  ptr [esp+8]
HbsiOldIrql     equ     dword ptr [esp+12]

cPublicProc _HalBeginSystemInterrupt ,3
cPublicFpo 3, 0
        movzx   ebx,HbsiVector                  ; (ebx) = IDTEntry
        sub     ebx, PRIMARY_VECTOR_BASE        ; (ebx) = 8259 IRQ #
if DBG
        cmp     ebx, 23h
        jbe     hbsi00
        int     3
hbsi00:

endif
        jmp     HalpSpecialDismissTable[ebx*4]  ; jmp to proper dismiss code

HalpDismissIrq0f:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC2_PORT0, al
        IODelay                         ; delay
        in      al, PIC2_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     short HalpDismissNormal ; No, this is NOT a spurious int,
                                        ; go do the normal interrupt stuff

;
; This is a spurious interrupt.
; Because the slave PIC is cascaded to irq2 of master PIC, we need to
; dismiss the interupt on master PIC's irq2.
;

        mov     al, PIC2_EOI            ; Specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master
        mov     eax,0                   ; return FALSE
;       sti
        stdRET    _HalBeginSystemInterrupt

HalpDismissIrq07:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC1_PORT0, al
        IODelay                         ; delay
        in      al, PIC1_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     short HalpDismissNormal ; No, so this is NOT a spurious int
        mov     eax, 0                  ; return FALSE
;       sti
        stdRET    _HalBeginSystemInterrupt

HalpDismissNormal:
;
; Store OldIrql
;
        mov     eax, HbsiOldIrql
        mov     ecx, dword ptr PCR[PcIrql]
        mov     byte ptr [eax], cl

;
; Raise IRQL to requested level
;
        movzx   eax, HbsiIrql           ; (eax) = irql
                                        ; (ebx) = IRQ #

        mov     PCR[PcIrql], eax        ; set new Irql


        mov     eax, KiI8259MaskTable[eax*4]    ; get 8259's masks
        or      eax, PCR[PcIDR]         ; mask disabled irqs
        SET_8259_MASK                   ; send mask to 8259s

;
; Dismiss interrupt.  Current interrupt is already masked off.
;
        mov     eax, ebx                ; (eax) = IRQ #
        cmp     eax, 8                  ; EOI to master or slave?

        jae     short Hbsi100           ; EIO to both master and slave
        or      al, PIC1_EOI_MASK       ; create specific eoi mask for master
        out     PIC1_PORT0, al          ; dismiss the interrupt
        jmp     short Hbsi200           ; IO delay - This is not enough for 486

Hbsi100:
        mov     al, OCW2_NON_SPECIFIC_EOI ; send non specific eoi to slave
        out     PIC2_PORT0, al
        mov     al, PIC2_EOI            ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master
Hbsi200:
        PIC1DELAY                       ; *MUST* wait for 8259 before sti
        sti
        mov     eax, 1                  ; return TRUE, interrupt dismissed
        stdRET    _HalBeginSystemInterrupt
        
align 4
HalpDismissInvalidVector:
        mov     eax,0                   ; return FALSE
        stdRET    _HalBeginSystemInterrupt

stdENDP _HalBeginSystemInterrupt


;++
;VOID
;HalDisableSystemInterrupt(
;    IN CCHAR Vector,
;    IN KIRQL Irql
;    )
;
;
;
;Routine Description:
;
;    Disables a system interrupt.
;
;Arguments:
;
;    Vector - Supplies the vector of the interrupt to be disabled
;
;    Irql   - Supplies the interrupt level of the interrupt to be disabled
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalDisableSystemInterrupt      ,2
cPublicFpo 2, 0

;

        movzx   ecx, byte ptr [esp+4]           ; (ecx) = IDTEntry
        sub     ecx, PRIMARY_VECTOR_BASE        ; (ecx) = 8259 irq #
        mov     edx, 1
        shl     edx, cl                         ; (ebx) = bit in IMR to disable
        cli
        or      PCR[PcIDR], edx
        xor     eax, eax

;
; Get the current interrupt mask register from the 8259
;
        in      al, PIC2_PORT1
        shl     eax, 8
        in      al, PIC1_PORT1
;
; Mask off the interrupt to be disabled
;
        or      eax, edx
;
; Write the new interrupt mask register back to the 8259
;
        out     PIC1_PORT1, al
        shr     eax, 8
        out     PIC2_PORT1, al
        PIC2DELAY

        sti
        stdRET    _HalDisableSystemInterrupt

stdENDP _HalDisableSystemInterrupt

;++
;
;BOOLEAN
;HalEnableSystemInterrupt(
;    IN ULONG Vector,
;    IN KIRQL Irql,
;    IN KINTERRUPT_MODE InterruptMode
;    )
;
;
;Routine Description:
;
;    Enables a system interrupt
;
;Arguments:
;
;    Vector - Supplies the vector of the interrupt to be enabled
;
;    Irql   - Supplies the interrupt level of the interrupt to be enabled.
;
;Return Value:
;
;    None.
;
;--
Vector        EQU     [esp+4]
Irql          EQU     [esp+8]
InterruptMode EQU     [esp+12]

cPublicProc _HalEnableSystemInterrupt       ,3
cPublicFpo 3, 0

        movzx   ecx, byte ptr Vector            ; (ecx) = IDTEntry
        sub     ecx, PRIMARY_VECTOR_BASE
        jc      hes_error
        cmp     ecx, CLOCK2_LEVEL
        jnc     hes_error

        ;
        ; Set Edge/Level bit in the interrupt controller
        ;
        
        ; read the edge/level control bits into ax
        mov     edx, EISA_EDGE_LEVEL1
        in      al, dx
        shl     ax, 8
        mov     edx, EISA_EDGE_LEVEL0
        in      al, dx
 
        mov     dx, 1
        shl     dx, cl          ; set the bit corresponding to this Vector
        .IF     InterruptMode == 0         ; if level,
        or      ax, dx          ; set the bit
        .ELSE                   ; else (edge)
        not     dx              
        and     ax, dx          ; clear the bit
        .ENDIF
        
        ; write it back
        mov     edx, EISA_EDGE_LEVEL0
        out     dx, al
        shr     ax, 8
        mov     edx, EISA_EDGE_LEVEL1
        out     dx, al

        mov     eax, 1
        shl     eax, cl                         ; (ebx) = bit in IMR to enable
        not     eax

        cli
        and     PCR[PcIDR], eax

;
; Get the PIC masks for the current Irql
;
        mov     eax, dword ptr PCR[PcIrql]
        mov     eax, KiI8259MaskTable[eax*4]
        or      eax, PCR[PcIDR]
;
; Write the new interrupt mask register back to the 8259
;
        SET_8259_MASK

        sti
        mov     eax, 1                          ; return TRUE
        stdRET    _HalEnableSystemInterrupt

hes_error:
if DBG
        int 3
endif
        xor     eax, eax                        ; FALSE
        stdRET    _HalEnableSystemInterrupt

stdENDP _HalEnableSystemInterrupt


_TEXT$01   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\ixsstate.asm ===
title  "Sleep Handlers"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixsstate.asm
;
; Abstract:
;
;    This module implements the code for putting the machine to
;    sleep.
;
; Author:
;
;    Jake Oshins (jakeo) March 13, 1997
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
include i386\ixcmos.inc
include xxacpi.h
include i386\ixslpctx.inc
        .list

        EXTRNP  _HalpAcpiPreSleep   ,1
        EXTRNP  _HalpAcpiPostSleep  ,1
        EXTRNP  _HalpPostSleepMP, 2
        EXTRNP  _HalpReenableAcpi, 0
        EXTRNP  _StartPx_BuildRealModeStart,1
        EXTRNP  KfLowerIrql, 1,,FASTCALL
        EXTRNP  _KeGetCurrentIrql,0
        EXTRNP  _HalpSaveProcessorStateAndWait,2
        EXTRNP  _KeStallExecutionProcessor, 1
        EXTRNP  _HalpClearSlpSmiStsInICH,0
        EXTRNP  _HalpWakeupTimeElapsed,0

        extrn   _HalpLowStubPhysicalAddress:DWORD
        extrn   _KeSaveStateForHibernate:proc
        extrn   _HalpFixedAcpiDescTable:DWORD
        extrn   _HalpWakeVector:DWORD
        extrn   _HalpTiledCr3Addresses:DWORD
        extrn   _HalpVirtAddrForFlush:DWORD
        extrn   _HalpPteForFlush:DWORD
        extrn   _HalpHiberProcState:DWORD
        extrn   _HalpBroken440BX:byte

_DATA   SEGMENT  DWORD PUBLIC 'DATA'
    ALIGN   dword

        public  HalpSleepSync
HalpSleepSync   dd      0

        public  HalpBarrier
HalpBarrier     dd      0

_DATA   ends



PAGELK  SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Sleep Handlers"


; VOID
; FASTCALL
; HalpAcpiFlushCache(
;     VOID
;     )
; /*++
;
; Routine Description:
;
;     This is called to flush everything from the caches.
;
; Arguments:
;
;     none
;
; Return Value:
;
;     none
;
; --*/
;
; eax - offset within a page
; ebx - stride size
; ecx - address of PTE we are manipulating
; edi - Physical Address of page
; esi - Virtual Address of page used for flush
; ebp - Flush Limit
;

FlushBase       equ     100000h
PageLength      equ     4096
PteValid        equ     1
PteWrite        equ     2
PteAccessed     equ     20h
PteDirty        equ     40h
PteBits         equ     (PteValid or PteWrite)

cPublicFastCall HalpAcpiFlushCache, 0
cPublicFpo 0, 0
        mov     eax, [FADT_FLAGS]
        test    eax, WBINVD_SUPPORTED or WBINVD_FLUSH
        jz      short hafc10

.586p
        wbinvd
        fstRET    HalpAcpiFlushCache

hafc10:
        push    ebp
        push    ebx
        push    esi
        push    edi

        movzx   eax, word ptr [FLUSH_STRIDE]
        mov     ebx, eax                        ; save the stride size
        movzx   ecx, word ptr [FLUSH_SIZE]
        mul     ecx
        add     eax, FlushBase
        mov     ebp, eax                        ; ebp <- ending physical address

        ;
        ; Iterate across all cache lines
        ;
        mov     edi, FlushBase                  ; start at 1MB, physical

        mov     esi, [_HalpVirtAddrForFlush]
        mov     ecx, [_HalpPteForFlush]

hafc20:
        ; put the right physical page into the PTE
        mov     edx, PteBits                    ; mask off the page
        or      edx, edi
        mov     [ecx], edx
        invlpg  [esi]

        add     edi, PageLength                 ; next physical page
        xor     eax, eax

        ; flush a cache line
hafc30: mov     edx, [esi][eax]
        add     eax, ebx
        cmp     eax, PageLength
        jl      short hafc30

        cmp     edi, ebp
        jl      short hafc20

        pop     edi
        pop     esi
        pop     ebx
        pop     ebp
.386p


        fstRET    HalpAcpiFlushCache
fstENDP HalpAcpiFlushCache

;++
; UCHAR
; FASTCALL
; HalpSetup440BXWorkaround(
;     )
;
; Routine Description:
;
;     This function provides part of the workaround for
;     broken 440BX chips.
;
; Arguments:
;
;     none
;
; Return Value:
;
;     the previous contents of 440BX DRAM Control Register (57h)
;
;--
cPublicFastCall HalpSetup440BXWorkaround, 0
cPublicFpo 0,0

        mov     dx, 0cf8h
        mov     eax, 80000054h
        out     dx, eax
        mov     dx, 0cffh
        in      al, dx
        mov     cl, al
        or      al, 7
        out     dx, al
        push    ecx
        stdCall _KeStallExecutionProcessor <15>
        pop     ecx
        mov     dx, 0cf8h
        mov     eax, 80000054h
        out     dx, eax
        mov     dx, 0cffh
        in      al, dx
        and     al, 0f8h
        out     dx, al
        movzx   eax, cl
        fstRET  HalpSetup440BXWorkaround

fstENDP HalpSetup440BXWorkaround

;++
; VOID
; FASTCALL
; HalpComplete440BXWorkaround(
;     UCHAR DramControl
;     )
;
; Routine Description:
;
;     This function provides the other part of the workaround for
;     broken 440BX chips.
;
; Arguments:
;
;     the previous contents of 440BX DRAM Control Register (57h)
;
; Return Value:
;
;     none
;
;--
cPublicFastCall HalpComplete440BXWorkaround, 1
cPublicFpo 0,0

        mov     dx, 0cf8h
        mov     eax, 80000054h
        out     dx, eax

        mov     dx, 0cffh
        mov     al, cl
        out     dx, al
        fstRET  HalpComplete440BXWorkaround

fstENDP HalpComplete440BXWorkaround

; NTSTATUS
; HaliAcpiSleep(
;     IN PVOID                        Context,
;     IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
;     IN PVOID                        SystemContext,
;     IN LONG                         NumberProcessors,
;     IN volatile PLONG               Number
;     )
; /*++
;
; Routine Description:
;
;     This is called by the Policy Manager to enter Sx.
;
; Arguments:
;
;     Context - unused
;
;     NumberProcessors - currently unused
;
;     Number - currently unused
;
; Return Value:
;
;     none
;
; --*/

Context     equ     [ebp+8]
SysHandler  equ     [ebp+12]
SysContext  equ     [ebp+16]
NumberProc  equ     [ebp+20]
Barrier     equ     [ebp+24]

Pm1aEvt     equ     [ebp-4]
Pm1bEvt     equ     [ebp-8]
Status      equ     [ebp-12]
SlpTypA     equ     [ebp-14]
SlpTypB     equ     [ebp-16]
ThisProc    equ     [ebp-20]
OldIrql     equ     [ebp-24]
PrevDRAM    equ     [ebp-28]
FrameSize   equ     28

cPublicProc _HaliAcpiSleep, 5
cPublicFpo 5, 4
        push    ebp
        mov     ebp, esp
        sub     esp, FrameSize
        push    ebx
        push    esi
        push    edi
        pushfd
        cli

        mov     edi, HalpSleepSync                  ; Get current sleep sync value
        xor     eax, eax
        mov     Status, eax

        ;
        ; Get current IRQL
        ;

        stdCall _KeGetCurrentIrql
        mov     OldIrql, eax

        ;
        ; Send all
        ;

        mov     al, PCR[PcNumber]
        or      al, al                          ; Is this processor 0?
        jnz     has_wait                        ; if not, set it waiting

        mov     HalpBarrier, 0                  ; init Barrier, processor 0 does it

        ;
        ; Make sure the other processors have saved their
        ; state and begun to spin.
        ;

        lock inc [HalpSleepSync]                ; account for this proc
has1:   YIELD
        mov     eax, [HalpSleepSync]
        cmp     eax, NumberProc
        jnz     short has1

        ;
        ; Take care of chores (RTC, interrupt controller, etc.)
        stdCall _HalpAcpiPreSleep, <Context>
        or      al, al                          ; check for failure
        jz      has_slept                       ; if FALSE, then don't sleep at all

        ;
        ; If we will be losing processor state, save it
        ;
        mov     eax, Context
        test    eax, SLEEP_STATE_FIRMWARE_RESTART shl CONTEXT_FLAG_SHIFT
        jz      short has2

        lea     eax, haswake
        stdCall _HalpSetupRealModeResume, <eax>

        ;
        ; Record the values in the SLP_TYP registers
        ;
has2:
        mov     edx, [PM1a_CNT]
        in      ax, dx
        mov     SlpTypA, ax

        mov     edx, [PM1b_CNT]
        or      edx, edx
        jz      short has5

        in      ax, dx
        mov     SlpTypB, ax

has5:
        ;
        ; The hal has all of it's state saved into ram and is ready
        ; for the power down.  If there's a system state handler give
        ; it a shot
        ;

        mov     ebx, SysHandler
        or      ebx, ebx
        jz      short has10

        mov     ecx, SysContext
        push    ecx
        call    ebx                                 ; Call the system state handler
        mov     Status, eax
        test    eax, eax
        jnz     has_s4_wake                         ; If not success, exit

        ;
        ; Check the RTC one last time in case it expired while we were writing
        ; out the Hiberfile.
        ;
        stdCall _HalpWakeupTimeElapsed
        or      eax, eax
        jnz     has_s4_wake                         ; If expired, exit

has10:
        mov     esi, Context

        mov     edx, [PM1a_EVT]
        mov     ecx, [PM1b_EVT]
        or      ecx, ecx
        jnz     short has20
        mov     ecx, edx

has20:
        mov     Pm1aEvt, ecx
        mov     Pm1bEvt, edx                        ; save PM1a_EVT & PM1b_EVT address

        ;
        ; Reset WAK_STS
        ;

        mov     eax, WAK_STS
        out     dx, ax                              ; clear PM1a WAK_STS
        mov     edx, ecx
        out     dx, ax                              ; clear PM1b WAK_STS

        ;
        ; Flush the caches if necessary
        ;
        mov     eax, SLEEP_STATE_FLUSH_CACHE shl CONTEXT_FLAG_SHIFT
        test    eax, esi
        jz      short @f
        fstCall HalpAcpiFlushCache
@@:
        ;
        ; Work around 440BX bug.  Criteria is that we have one of
        ; the broken BX parts and we are not hibernating, which
        ; we know because the SysHandler is 0.
        ;

        mov     eax, SysHandler
        .if (_HalpBroken440BX && (eax == 0))
        fstCall HalpSetup440BXWorkaround
        movzx   eax, al
        mov     PrevDRAM, eax
        .endif

        ;
        ; Issue SLP commands to PM1a_CNT and PM1b_CNT
        ;

        mov     edx, [PM1a_CNT]
        mov     ecx, esi
        and     ecx, 0fh                            ; nibble 0 is 1a sleep type
        shl     ecx, SLP_TYP_SHIFT                  ; put it in position
        or      ecx, SLP_EN                         ; enable sleep  ********

        in      ax, dx
        and     ax, CTL_PRESERVE                    ; preserve some bits
        or      ax, cx
        out     dx, ax

        mov     edx, [PM1b_CNT]
        or      edx, edx
        jz      short has30

        mov     ecx, esi
        and     ecx, 0f0h                           ; nibble 1 is 1b sleep type
        shl     ecx, (SLP_TYP_SHIFT-4)              ; put it in position
        or      ecx, SLP_EN                         ; enable sleep  *********

        in      ax, dx
        and     ax, CTL_PRESERVE                    ; preserve some bits
        or      ax, cx
        out     dx, ax

has30:
        ;
        ; Wait for sleep to be over
        ;

        mov     ecx, Pm1bEvt
        mov     edx, Pm1aEvt                        ; retrieve PM1_EVT & PM1b_EVT

has40:  in      ax, dx
        test    ax, WAK_STS
        xchg    edx, ecx
        jz      short has40

        ;
        ; Finish 440BX workaround
        ;

        mov     eax, SysHandler
        .if (_HalpBroken440BX && (eax == 0))
        mov     ecx, PrevDRAM
        fstCall HalpComplete440BXWorkaround
        .endif

        ;
        ; Invalidate the processor cache so that any stray gamma
        ; rays (I'm serious) that may have flipped cache bits
        ; while in S1 will be ignored.
        ;
        ; Honestly.  Intel asked for this.  I'm serious.
        ;
;.586
;        invd
;.386

haswake:
        ;
        ; Hack around ICH2/ASUS BIOS.
        ;

        stdCall _HalpClearSlpSmiStsInICH

        ;
        ; Restore the SLP_TYP registers.  (So that embedded controllers
        ; and BIOSes can be sure that we think the machine is awake.)
        ;
        mov     edx, [PM1a_CNT]
        mov     ax, SlpTypA
        out     dx, ax

        mov     edx, [PM1b_CNT]
        or      edx, edx
        jz      short has_slept

        mov     ax, SlpTypB
        out     dx, ax

has_slept:
        stdCall _HalpAcpiPostSleep, <Context>

        ;
        ; Notify other processor of completion
        ;

        mov     HalpSleepSync, 0
        jmp     short has_90

has_wait:
        xor     eax, eax
        mov     edx, Context
        test    edx, SLEEP_STATE_OFF shl CONTEXT_FLAG_SHIFT
        jnz     has_wait2                       ; if going to S5, don't save context

        mov     al, PCR[PcNumber]               ; get processor number
        mov     edx, ProcessorStateLength       ; get size of proc state
        mul     dx                              ; generate an index into HalpHiberProcState
        add     eax, _HalpHiberProcState        ; add the index to base
has_wait2:
        lea     edx, HalpSleepSync
        stdCall _HalpSaveProcessorStateAndWait <eax, edx>

        ;
        ; Wait for next phase
        ;


hasw10: YIELD
        cmp     HalpSleepSync, 0                ; wait for barrier to move
        jne     short hasw10

        ;
        ; All phases complete, exit
        ;

has_90:
        ;
        ; Restore each processor's APIC state.
        ;

        lea     eax, HalpBarrier
        stdCall _HalpPostSleepMP <NumberProc, eax>

        ;
        ; Restore caller's IRQL
        ;

        mov     ecx, OldIrql
        fstCall KfLowerIrql

        ;
        ; Exit
        ;

        mov     HalpSleepSync, 0
        mov     eax, Status
        popfd
        pop     edi
        pop     esi
        pop     ebx
        mov     esp, ebp
        pop     ebp
        stdRET  _HaliAcpiSleep

has_s4_wake:

        stdCall _HalpReenableAcpi
        jmp     haswake

stdENDP _HaliAcpiSleep

;++
;
; BOOLEAN
; HalpSetupRealModeResume (
; )
;
; Routine Description:
;
;    This routine is called by the kernel durning kernel initialization
;    to obtain more processors.  It is called until no more processors
;    are available.
;
;    If another processor exists this function is to initialize it to
;    the passed in processorstate structure, and return TRUE.
;
;    If another processor does not exists or if the processor fails to
;    start, then a FALSE is returned.
;
;    Also note that the loader block has been setup for the next processor.
;    The new processor logical thread number can be obtained from it, if
;    required.
;
;    In order to use the Startup IPI the real mode startup code must be
;    page aligned.  The MpLowStubPhysicalAddress has always been page
;    aligned but because the PxParamBlock was placed first in this
;    segment the real mode code has been something other than page aligned.
;    This has been changed by making the first entry in the PxParamBlock
;    a jump instruction to the real mode startup code.
;
; Arguments:
;
;    WakeupReturnAddress - address that processor should return to
;                          after it has been asleep
;
; Return Value:
;
;
;--

WakeupReturnAddress equ dword ptr [ebp + 20]

;
; Local variables
;

PxFrame             equ [ebp - size PxParamBlock]
LWarmResetVector    equ [ebp - size PxParamBlock - 4]
LStatusCode         equ [ebp - size PxParamBlock - 8]
LCmosValue          equ [ebp - size PxParamBlock - 12]
CallingEbp          equ [ebp]
CallingEsi          equ [ebp + 12]
CallingEdi          equ [ebp + 8]
CallingEbx          equ [ebp + 4]
CallingEsp          equ 24              ; relative to current ebp

cPublicProc _HalpSetupRealModeResume ,1
cPublicFpo 4, 80

    push    esi                         ; Save required registers
    push    edi
    push    ebx

    push    ebp                         ; save ebp
    mov     ebp, esp                    ; Save Frame
    sub     esp, size PxParamBlock + 12 ; Make room for local vars

    xor     eax, eax
    mov     LStatusCode, eax

    ;
    ; Fill in the firmware wakeup vector
    ;
    mov     eax, _HalpLowStubPhysicalAddress
    mov     ecx, [_HalpWakeVector]
    mov     [ecx], eax

    ;
    ; Save the processor context
    ;

    lea     edi, PxFrame.SPx_PB
    push    edi
    call    _KeSaveStateForHibernate        ; _cdecl function
    add     esp, 4

    ;
    ; Get a CR3 for the starting processor
    ;
    mov     eax, [_HalpTiledCr3Addresses] ; the low 32-bits of processor 0's CR3
    mov     eax, [eax]                    ; physical address will be here
    mov     PxFrame.SPx_TiledCR3, eax     ; Newly contructed CR3

    mov     PxFrame.SPx_P0EBP, ebp        ; Stack pointer

    lea     edi, PxFrame.SPx_PB.PsContextFrame

    mov     eax, WakeupReturnAddress
    mov     dword ptr [edi].CsEip, eax      ; make a copy of remaining
    mov     eax, CallingEbx                 ; registers which need
    mov     dword ptr [edi].CsEbx, eax      ; loaded
    mov     eax, CallingEsi
    mov     dword ptr [edi].CsEsi, eax
    mov     eax, CallingEdi
    mov     dword ptr [edi].CsEdi, eax
    mov     eax, CallingEbp
    mov     dword ptr [edi].CsEbp, eax
    mov     eax, ebp
    add     eax, CallingEsp
    mov     dword ptr [edi].CsEsp, eax

    lea     eax, PxFrame
    stdCall _StartPx_BuildRealModeStart, <eax>

snp_exit:
    mov     esp, ebp
    pop     ebp
    pop     ebx
    pop     edi
    pop     esi
    stdRET  _HalpSetupRealModeResume

stdENDP _HalpSetupRealModeResume


PAGELK   ends

    end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\mcirql.asm ===
title  "Irql Processing"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixirql.asm
;
; Abstract:
;
;    This module implements the code necessary to raise and lower i386
;    Irql and dispatch software interrupts with the 8259 PIC.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 8-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;    John Vert (jvert) 27-Nov-1991
;       Moved from kernel into HAL
;
;--

.586p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
        .list


        EXTRNP  _KeBugCheckEx,5,IMPORT
        EXTRNP  _KeSetEventBoostPriority, 2, IMPORT
        EXTRNP  _KeWaitForSingleObject,5, IMPORT

        extrn   _HalpApcInterrupt:near
        extrn   _HalpDispatchInterrupt:near
        extrn   _KiUnexpectedInterrupt:near
        extrn   _HalpBusType:DWORD
        extrn   _HalpApcInterrupt2ndEntry:NEAR
        extrn   _HalpDispatchInterrupt2ndEntry:NEAR

ifdef NT_UP
    LOCK_ADD  equ   add
    LOCK_DEC  equ   dec
    LOCK_CMPXCHG    equ   cmpxchg
else
    LOCK_ADD  equ   lock add
    LOCK_DEC  equ   lock dec
    LOCK_CMPXCHG    equ   lock cmpxchg
endif


;
; Initialization control words equates for the PICs
;

ICW1_ICW4_NEEDED                equ     01H
ICW1_CASCADE                    equ     00H
ICW1_INTERVAL8                  equ     00H
ICW1_LEVEL_TRIG                 equ     08H
ICW1_EDGE_TRIG                  equ     00H
ICW1_ICW                        equ     10H

ICW4_8086_MODE                  equ     001H
ICW4_NORM_EOI                   equ     000H
ICW4_NON_BUF_MODE               equ     000H
ICW4_SPEC_FULLY_NESTED          equ     010H
ICW4_NOT_SPEC_FULLY_NESTED      equ     000H

OCW2_NON_SPECIFIC_EOI           equ     020H
OCW2_SPECIFIC_EOI               equ     060H
OCW2_SET_PRIORITY               equ     0c0H

PIC_SLAVE_IRQ                   equ     2
PIC1_BASE                       equ     30H
PIC2_BASE                       equ     38H

;
; Interrupt flag bit maks for EFLAGS
;

EFLAGS_IF                       equ     200H
EFLAGS_SHIFT                    equ     9


_DATA   SEGMENT DWORD PUBLIC 'DATA'

;
; PICsInitializationString - Master PIC initialization command string
;

PS2PICsInitializationString        dw      PIC1_PORT0

;
; Master PIC initialization command
;

                           db      ICW1_ICW + ICW1_LEVEL_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC1_BASE
                           db      1 SHL PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
;
; Slave PIC initialization command strings
;

                           dw      PIC2_PORT0
                           db      ICW1_ICW + ICW1_LEVEL_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC2_BASE
                           db      PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
                           dw      0               ; end of string


PICsInitializationString   dw      PIC1_PORT0

;
; Master PIC initialization command
;

                           db      ICW1_ICW + ICW1_EDGE_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC1_BASE
                           db      1 SHL PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE

; Slave PIC initialization command strings
;

                           dw      PIC2_PORT0
                           db      ICW1_ICW + ICW1_EDGE_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC2_BASE
                           db      PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
                           dw      0               ; end of string

            align   4
            public  KiI8259MaskTable
KiI8259MaskTable    label   dword
                dd      00000000000000000000000000000000B ; irql 0
                dd      00000000000000000000000000000000B ; irql 1
                dd      00000000000000000000000000000000B ; irql 2
                dd      00000000000000000000000000000000B ; irql 3
                dd      11111111100000000000000000000000B ; irql 4
                dd      11111111110000000000000000000000B ; irql 5
                dd      11111111111000000000000000000000B ; irql 6
                dd      11111111111100000000000000000000B ; irql 7
                dd      11111111111110000000000000000000B ; irql 8
                dd      11111111111111000000000000000000B ; irql 9
                dd      11111111111111100000000000000000B ; irql 10
                dd      11111111111111110000000000000000B ; irql 11
                dd      11111111111111111000000000000000B ; irql 12
                dd      11111111111111111100000000000000B ; irql 13
                dd      11111111111111111110000000000000B ; irql 14
                dd      11111111111111111111000000000000B ; irql 15
                dd      11111111111111111111100000000000B ; irql 16
                dd      11111111111111111111110000000000B ; irql 17
                dd      11111111111111111111111000000000B ; irql 18
                dd      11111111111111111111111000000000B ; irql 19
                dd      11111111111111111111111010000000B ; irql 20
                dd      11111111111111111111111011000000B ; irql 21
                dd      11111111111111111111111011100000B ; irql 22
                dd      11111111111111111111111011110000B ; irql 23
                dd      11111111111111111111111011111000B ; irql 24
                dd      11111111111111111111111011111000B ; irql 25
                dd      11111111111111111111111011111010B ; irql 26
                dd      11111111111111111111111111111010B ; irql 27
                dd      11111111111111111111111111111011B ; irql 28
                dd      11111111111111111111111111111011B ; irql 29
                dd      11111111111111111111111111111011B ; irql 30
                dd      11111111111111111111111111111011B ; irql 31

        align   4
;
; The following tables define the addresses of software interrupt routers
;

;
; Use this table if there is NO machine state frame on stack already
;

        public  SWInterruptHandlerTable
SWInterruptHandlerTable label dword
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 0
        dd      offset FLAT:_HalpApcInterrupt           ; irql 1
        dd      offset FLAT:_HalpDispatchInterrupt      ; irql 2

;
; Use this table if there is a machine state frame on stack already
;

        public  SWInterruptHandlerTable2
SWInterruptHandlerTable2 label dword
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 0
        dd      offset FLAT:_HalpApcInterrupt2ndEntry   ; irql 1
        dd      offset FLAT:_HalpDispatchInterrupt2ndEntry ; irql 2

;
; The following table picks up the highest pending software irq level
; from software irr
;

        public  SWInterruptLookUpTable
SWInterruptLookUpTable label byte
        db      0               ; SWIRR=0, so highest pending SW irql= 0
        db      0               ; SWIRR=1, so highest pending SW irql= 0
        db      1               ; SWIRR=2, so highest pending SW irql= 1
        db      1               ; SWIRR=3, so highest pending SW irql= 1
        db      2               ; SWIRR=4, so highest pending SW irql= 2
        db      2               ; SWIRR=5, so highest pending SW irql= 2
        db      2               ; SWIRR=6, so highest pending SW irql= 2
        db      2               ; SWIRR=7, so highest pending SW irql= 2

_DATA   ENDS

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

        PAGE
        subttl  "Raise Irql"

;++
;
; KIRQL
; FASTCALL
; KfRaiseIrql (
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to the specified value.
;    Also, a mask will be used to mask off all the lower lever 8259
;    interrupts.
;
; Arguments:
;
;    (cl) = NewIrql - the new irql to be raised to
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicFastCall KfRaiseIrql,1
cPublicFpo 0,0

        mov     eax, PCR[PcIrql]        ; get current irql
        movzx   ecx, cl                 ; 32bit extend NewIrql

if DBG
        cmp     eax,ecx                 ; old > new?
        ja      short Kri99             ; raising to a lower IRQL is BAD
endif
        cmp     ecx,DISPATCH_LEVEL      ; software level?
        jbe     short kri10             ; Skip setting 8259 masks

        mov     edx, eax                ; Save OldIrql

        pushfd
        cli                             ; disable interrupt
        mov     PCR[PcIrql], cl         ; set the new irql
        mov     eax, KiI8259MaskTable[ecx*4]; get pic masks for the new irql
        or      eax, PCR[PcIDR]         ; mask irqs which are disabled
        SET_8259_MASK                   ; set 8259 masks

        popfd

        mov     eax, edx                ; (al) = OldIrql
        fstRET  KfRaiseIrql

align 4
kri10:
;
; Note it is very important that we set the old irql AFTER we raise to
; the new irql.  Otherwise, if there is an interrupt in between and the
; OldIrql is not a local variable, the caller will get the wrong OldIrql.
; The bottom line is that raising irql and returning the old irql has to be
; atomic to the caller.
;
        mov     PCR[PcIrql], ecx
        fstRET  KfRaiseIrql

if DBG
Kri99:  mov     dword ptr PCR[PcIrql],0   ; avoid recursive error
        stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,eax,ecx,0,9>
        ; never returns (but need the following for the debugger)
        fstRET  KfRaiseIrql
endif

fstENDP KfRaiseIrql

;++
;
; VOID
; KIRQL
; KeRaiseIrqlToDpcLevel (
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to DPC level.
;
; Arguments:
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicProc _KeRaiseIrqlToDpcLevel,0
cPublicFpo 0, 0

        mov     eax, PCR[PcIrql]                        ; (eax) = Old Irql
        mov     dword ptr PCR[PcIrql], DISPATCH_LEVEL   ; set new irql

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif
if DBG
        cmp     eax, DISPATCH_LEVEL     ; old > new?
        ja      short Krid99            ; yes, go bugcheck
endif

        stdRET  _KeRaiseIrqlToDpcLevel

if DBG
cPublicFpo 0,1
Krid99: stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,eax,DISPATCH_LEVEL,0,1>
        ; never returns (but need the following for the debugger)
        stdRET  _KeRaiseIrqlToDpcLevel
endif

stdENDP _KeRaiseIrqlToDpcLevel

;++
;
; VOID
; KIRQL
; KeRaiseIrqlToSynchLevel (
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to SYNC level.
;
; Arguments:
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicProc _KeRaiseIrqlToSynchLevel,0
cPublicFpo 0, 0
        pushfd
        cli                             ; disable interrupt
        mov     eax, KiI8259MaskTable[SYNCH_LEVEL*4]; get pic masks for the new irql
        or      eax, PCR[PcIDR]         ; mask irqs which are disabled
        SET_8259_MASK                   ; set 8259 masks

        mov     eax, PCR[PcIrql]        ; (eax) = Old irql
        mov     dword ptr PCR[PcIrql], SYNCH_LEVEL   ; set new irql

        popfd

if DBG
        cmp     eax, SYNCH_LEVEL
        ja      short Kris99
endif

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif
        stdRET  _KeRaiseIrqlToSynchLevel

if DBG
cPublicFpo 0,1
Kris99: stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,eax,SYNCH_LEVEL,0,2>
        stdRET  _KeRaiseIrqlToSynchLevel
endif

stdENDP _KeRaiseIrqlToSynchLevel

        page ,132
        subttl  "Lower irql"

;++
;
; VOID
; FASTCALL
; KfLowerIrql (
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
;          On a UP system, HalEndSystenInterrupt is treated as a
;          LowerIrql.
;
; Arguments:
;
;    (cl) = NewIrql - the new irql to be set.
;
; Return Value:
;
;    None.
;
;--


cPublicFastCall KfLowerIrql    ,1
cPublicFpo 0,1

        pushfd                          ; save caller's eflags
        movzx   ecx, cl                 ; zero extend irql

if DBG
        cmp     ecx,PCR[PcIrql]
        ja      short Kli99
endif
        cmp     dword ptr PCR[PcIrql],DISPATCH_LEVEL ; Software level?
        cli
        jbe     short kli02             ; no, go set 8259 hw

        mov     eax, KiI8259MaskTable[ecx*4]; get pic masks for the new irql
        or      eax, PCR[PcIDR]         ; mask irqs which are disabled
        SET_8259_MASK                   ; set 8259 masks
kli02:
        mov     PCR[PcIrql], ecx        ; set the new irql
        mov     eax, PCR[PcIRR]         ; get SW interrupt request register
        mov     al, SWInterruptLookUpTable[eax] ; get the highest pending
                                        ; software interrupt level
        cmp     al, cl                  ; Is highest SW int level > irql?
        ja      Kli10                   ; yes, go simulate interrupt

kil03:  popfd                           ; restore flags, including ints
cPublicFpo 0,0
        fstRET    KfLowerIrql

if DBG
Kli99:
        mov     eax, dword ptr PCR[PcIrql]; old irql for debugging
        mov     dword ptr PCR[PcIrql],HIGH_LEVEL   ; avoid recursive error
        stdCall   _KeBugCheckEx,<IRQL_NOT_LESS_OR_EQUAL,eax,ecx,0,3>
        ; never returns
endif

;
;   When we come to Kli10, (eax) = soft interrupt index
;
;   Note Do NOT:
;
;   popfd
;   jmp         SWInterruptHandlerTable[eax*4]
;
;   We want to make sure interrupts are off after entering SWInterrupt
;   Handler.
;

align 4
cPublicFpo 1,1
Kli10:  call    SWInterruptHandlerTable[eax*4] ; SIMULATE INTERRUPT
        popfd                           ; restore flags, including ints
cPublicFpo 1,0
        fstRET    KfLowerIrql                             ; cRetURN

fstENDP KfLowerIrql

;++
;
;  KIRQL
;  FASTCALL
;  KfAcquireSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;     )
;
;  Routine Description:
;
;     This function raises to DISPATCH_LEVEL and then acquires a the
;     kernel spin lock.
;
;     In a UP hal spinlock serialization is accomplished by raising the
;     IRQL to DISPATCH_LEVEL.  The SpinLock is not used; however, for
;     debugging purposes if the UP hal is compiled with the NT_UP flag
;     not set (ie, MP) we take the SpinLock.
;
;  Arguments:
;
;     (ecx) = SpinLock - Supplies a pointer to an kernel spin lock.
;
;  Return Value:
;
;     OldIrql
;
;--

cPublicFastCall KfAcquireSpinLock,1
cPublicFpo 0,0

        mov     eax, PCR[PcIrql]                        ; (eax) = Old Irql
        mov     dword ptr PCR[PcIrql], DISPATCH_LEVEL   ; set new irql

ifndef NT_UP
asl10:  ACQUIRE_SPINLOCK    ecx,<short asl20>
endif

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif
if DBG
        cmp     eax, DISPATCH_LEVEL     ; old > new?
        ja      short asl99             ; yes, go bugcheck
endif
        fstRET  KfAcquireSpinLock

ifndef NT_UP
asl20:  SPIN_ON_SPINLOCK    ecx,<short asl10>
endif

if DBG
cPublicFpo 2, 1
asl99:
        stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,ecx,DISPATCH_LEVEL,0,4>
endif
        fstRET    KfAcquireSpinLock
fstENDP KfAcquireSpinLock


;++
;
;  KIRQL
;  FASTCALL
;  KeAcquireSpinLockRaiseToSynch (
;     IN PKSPIN_LOCK SpinLock,
;     )
;
;  Routine Description:
;
;     This function acquires the SpinLock at SYNCH_LEVEL.  The function
;     is optmized for hoter locks (the lock is tested before acquired.
;     Any spin should occur at OldIrql; however, since this is a UP hal
;     we don't have the code for it)
;
;     In a UP hal spinlock serialization is accomplished by raising the
;     IRQL to SYNCH_LEVEL.  The SpinLock is not used; however, for
;     debugging purposes if the UP hal is compiled with the NT_UP flag
;     not set (ie, MP) we take the SpinLock.
;
;  Arguments:
;
;     (ecx) = SpinLock - Supplies a pointer to an kernel spin lock.
;
;  Return Value:
;
;     OldIrql
;
;--

cPublicFastCall KeAcquireSpinLockRaiseToSynch,1
cPublicFpo 0,0

        push    ecx
        mov     ecx, SYNCH_LEVEL
        fstCall KfRaiseIrql             ; Raise to SYNCH_LEVEL
        pop     ecx

ifndef NT_UP
asls10: ACQUIRE_SPINLOCK    ecx,<short asls20>
endif

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif
if DBG
        cmp     al, SYNCH_LEVEL         ; old > new?
        ja      short asls99            ; yes, go bugcheck
endif
        fstRET  KeAcquireSpinLockRaiseToSynch

ifndef NT_UP
asls20: SPIN_ON_SPINLOCK    ecx,<short asls10>
endif

if DBG
cPublicFpo 2, 1
asls99:
        stdCall _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,eax,DISPATCH_LEVEL,0,5>
        ; never returns
endif
        fstRET  KeAcquireSpinLockRaiseToSynch
fstENDP KeAcquireSpinLockRaiseToSynch


        PAGE
        SUBTTL "Release Kernel Spin Lock"
;++
;
;  VOID
;  FASTCALL
;  KfReleaseSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;     IN KIRQL       NewIrql
;     )
;
;  Routine Description:
;
;     This function releases a kernel spin lock and lowers to the new irql
;
;     In a UP hal spinlock serialization is accomplished by raising the
;     IRQL to DISPATCH_LEVEL.  The SpinLock is not used; however, for
;     debugging purposes if the UP hal is compiled with the NT_UP flag
;     not set (ie, MP) we use the SpinLock.
;
;
;  Arguments:
;
;     (ecx) = SpinLock  - Supplies a pointer to an executive spin lock.
;     (dl)  = NewIrql   - New irql value to set
;
;  Return Value:
;
;     None.
;
;--

align 16
cPublicFastCall KfReleaseSpinLock  ,2
cPublicFpo 0,1
        pushfd

ifndef NT_UP
        RELEASE_SPINLOCK    ecx         ; release it
endif
        movzx   ecx, dl                 ; (ecx) = NewIrql
        cmp     dword ptr PCR[PcIrql],DISPATCH_LEVEL ; Software level?
        cli
        jbe     short rsl02             ; no, go set 8259 hw

        mov     eax, KiI8259MaskTable[ecx*4]; get pic masks for the new irql
        or      eax, PCR[PcIDR]         ; mask irqs which are disabled
        SET_8259_MASK                   ; set 8259 masks
rsl02:
        mov     PCR[PcIrql], ecx
        mov     eax, PCR[PcIRR]         ; get SW interrupt request register
        mov     al, SWInterruptLookUpTable[eax] ; get the highest pending
                                        ; software interrupt level
        cmp     al, cl                  ; Is highest SW int level > irql?
        ja      short rsl20             ; yes, go simulate interrupt

        popfd
        fstRet  KfReleaseSpinLock       ; all done

align 4
rsl20:  call    SWInterruptHandlerTable[eax*4] ; SIMULATE INTERRUPT
        popfd                           ; restore flags, including ints
cPublicFpo 2,0
        fstRET  KfReleaseSpinLock       ; all done

fstENDP KfReleaseSpinLock


;++
;
;  VOID
;  FASTCALL
;  ExAcquireFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function acquire ownership of the FastMutex
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to the fast mutex
;
;  Return Value:
;
;     None.
;
;--

cPublicFastCall ExAcquireFastMutex,1
cPublicFpo 0,1

        push    ecx                             ; Save FastMutex
        mov     ecx, APC_LEVEL
        fstCall KfRaiseIrql                     ; Raise to APC_LEVEL
        pop     ecx                             ; (ecx) = FastMutex
cPublicFpo 0,0

if DBG
        pushfd
        cli                                     ; prevent swapcontext while
                                                ; snapping current thread.
        mov     edx, PCR[PcPrcb]
        mov     edx, [edx].PbCurrentThread      ; (edx) = Current Thread
        popfd

        cmp     [ecx].FmOwner, edx              ; Already owned by this thread?
        je      short afm98                     ; Yes, error
endif

   LOCK_DEC     dword ptr [ecx].FmCount         ; Get count
        jz      short afm_ret                   ; The owner? Yes, Done

        inc     dword ptr [ecx].FmContention

cPublicFpo 0,2
        push    ecx                             ; Save FastMutex
        push    eax                             ; Save OldIrql
        add     ecx, FmEvent                    ; Wait on Event
        stdCall _KeWaitForSingleObject,<ecx,WrExecutive,0,0,0>
        pop     eax
        pop     ecx
cPublicFpo 0,0

if DBG
        pushfd
        cli                                     ; prevent swapcontext while
                                                ; snapping current thread.
        mov     edx, PCR[PcPrcb]
        mov     edx, [edx].PbCurrentThread      ; (edx) = Current Thread
        popfd
endif

afm_ret:

if DBG
        mov     [ecx].FmOwner, edx              ; save owner in fast mutex
else
        ;
        ; Use esp to track the owning thread for debugging purposes.
        ; !thread from kd will find the owning thread.  Note that the
        ; owner isn't cleared on release, check if the mutex is owned
        ; first.
        ;

        mov	dword ptr [ecx].FmOwner, esp
endif

        mov     byte ptr [ecx].FmOldIrql, al    ; (al) = OldIrql
        fstRet  ExAcquireFastMutex

if DBG

        ; KeBugCheckEx(MUTEX_ALREADY_OWNED, FastMutex, CurrentThread, 0, 6)
        ; (never returns)

afm98:  stdcall _KeBugCheckEx,<MUTEX_ALREADY_OWNED,ecx,edx,0,6>
        fstRet  ExAcquireFastMutex

endif

fstENDP ExAcquireFastMutex

;++
;
;  BOOLEAN
;  FASTCALL
;  ExTryToAcquireFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function acquire ownership of the FastMutex
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to the fast mutex
;
;  Return Value:
;
;     Returns TRUE if the FAST_MUTEX was acquired; otherwise FALSE
;
;--

cPublicFastCall ExTryToAcquireFastMutex,1
cPublicFpo 0,1

        push    ecx                             ; Save FAST_MUTEX

        mov     ecx, APC_LEVEL
        fstCall KfRaiseIrql                     ; (al) = OldIrql

        pop     ecx                             ; (ecx) = FAST_MUTEX

cPublicFpo 0,0

        push    eax                             ; Save OldIrql

        mov     edx, 0                          ; Value to set
        mov     eax, 1                          ; Value to compare against
   LOCK_CMPXCHG dword ptr [ecx].FmCount, edx    ; Attempt to acquire

        jnz     short tam20                     ; didn't get it

        pop     dword ptr [ecx].FmOldIrql

if DBG
        pushfd
        cli                                     ; prevent swapcontext while
                                                ; snapping current thread.
        mov     edx, PCR[PcPrcb]
        mov     edx, [edx].PbCurrentThread      ; (edx) = Current Thread
        popfd
        mov     [ecx].FmOwner, edx              ; Save in Fast Mutex
else
        ;
        ; Use esp to track the owning thread for debugging purposes.
        ; !thread from kd will find the owning thread.  Note that the
        ; owner isn't cleared on release, check if the mutex is owned
        ; first.
        ;

        mov	dword ptr [ecx].FmOwner, esp
endif

        mov     eax, 1                          ; return TRUE
        fstRet  ExTryToAcquireFastMutex

tam20:  
        pop     ecx                             ; (ecx) = OldIrql
        fstCall KfLowerIrql                     ; restore OldIrql
        xor     eax, eax                        ; return FALSE
        YIELD
        fstRet  ExTryToAcquireFastMutex         ; all done

fstENDP ExTryToAcquireFastMutex


;++
;
;  VOID
;  FASTCALL
;  ExReleaseFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function releases ownership of the FastMutex
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to the fast mutex
;
;  Return Value:
;
;     None.
;
;--

cPublicFastCall ExReleaseFastMutex,1
cPublicFpo 0,0

if DBG
        pushfd
        cli                                     ; prevent swapcontext while
                                                ; snapping current thread.
        mov     edx, PCR[PcPrcb]
        mov     edx, [edx].PbCurrentThread      ; (edx) = CurrentThread
        popfd
        cmp     [ecx].FmOwner, edx              ; Owner == CurrentThread?
        jne     short rfm_threaderror           ; No, bugcheck

        or      byte ptr [ecx].FmOwner, 1       ; not the owner anymore
endif

        mov     al, byte ptr [ecx].FmOldIrql    ; (cl) = OldIrql

   LOCK_ADD     dword ptr [ecx].FmCount, 1  ; Remove our count
        xchg    ecx, eax                        ; (cl) = OldIrql
        js      short rfm05                     ; if < 0, set event
        jnz     @KfLowerIrql@4                  ; if != 0, don't set event

rfm05:  add     eax, FmEvent
        push    ecx
        stdCall _KeSetEventBoostPriority, <eax, 0>
        pop     ecx
        jmp     @KfLowerIrql@4

if DBG

        ; KeBugCheck(THREAD_NOT_MUTEX_OWNER, FastMutex, Thread, Owner, 7)
        ; (never returns)

rfm_threaderror:
        stdCall _KeBugCheckEx,<THREAD_NOT_MUTEX_OWNER,ecx,edx,[ecx].FmOwner,7>
        int     3

endif

fstENDP ExReleaseFastMutex


        page    ,132
        subttl  "Acquire Queued SpinLock"

;++
;
; KIRQL
; KeAcquireQueuedSpinLock (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )
;
; KIRQL
; KeAcquireQueuedSpinLockRaiseToSynch (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )
;
; VOID
; KeAcquireInStackQueuedSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; VOID
; KeAcquireInStackQueuedSpinLockRaiseToSynch (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; Routine Description:
;
;    This function raises the current IRQL to DISPATCH/SYNCH level
;    and acquires the specified queued spinlock.
;
; Arguments:
;
;    Number (ecx) - Supplies the queued spinlock number.
;
; Return Value:
;
;    The previous IRQL is returned as the function value.
;
;
; Routine Description:
;
;    The Kx versions use a LOCK_QUEUE_HANDLE structure rather than
;    LOCK_QUEUE structures in the PRCB.   Old IRQL is stored in the
;    LOCK_QUEUE_HANDLE.
;
; Arguments:
;
;    SpinLock   (ecx) Address of Actual Lock.
;    LockHandle (edx) Address of lock context.
;
; Return Value:
;
;   None.  Actually returns OldIrql because common code is used
;          for all implementations.
;
;--

        ; compile time assert sizeof(KSPIN_LOCK_QUEUE) == 8

        .errnz  (LOCK_QUEUE_HEADER_SIZE - 8)
align 16


; VOID
; KeAcquireInStackQueuedSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;

cPublicFastCall KeAcquireInStackQueuedSpinLock,2
cPublicFpo 0,0

ifndef NT_UP

        mov     [edx].LqhLock, ecx              ; save spin lock in lock handle
        mov     dword ptr [edx].LqhNext, 0      ; zero next pointer

endif

        push    DISPATCH_LEVEL                  ; raise to DISPATCH_LEVEL
aqsl0:
        pop     ecx
        push    edx                             ; save LockHandle
        fstCall KfRaiseIrql
        pop     edx                             ; restore lock handle
        mov     [edx].LqhOldIrql, al            ; save old IRQL in lock handle

ifndef NT_UP

        jmp     short aqslrs10                  ; continue in common code

else

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif

        fstRET  KeAcquireInStackQueuedSpinLock

endif

fstENDP KeAcquireInStackQueuedSpinLock


; VOID
; KeAcquireInStackQueuedSpinLockRaiseToSynch (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )

cPublicFastCall KeAcquireInStackQueuedSpinLockRaiseToSynch,2
cPublicFpo 0,0

ifndef NT_UP

        mov     [edx].LqhLock, ecx              ; save spin lock in lock handle
        mov     dword ptr [edx].LqhNext, 0      ; zero next pointer

endif

        push    SYNCH_LEVEL                     ; raise to SYNCH_LEVEL
        jmp     short aqsl0

fstENDP KeAcquireInStackQueuedSpinLockRaiseToSynch



; KIRQL
; KeAcquireQueuedSpinLockRaiseToSynch (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )

cPublicFastCall KeAcquireQueuedSpinLockRaiseToSynch,1
cPublicFpo 0,0

        push    ecx
        mov     ecx, SYNCH_LEVEL                ; Raise to SYNCH_LEVEL
        fstCall KfRaiseIrql
        pop     ecx

ifndef NT_UP

        jmp     short aqslrs                    ; continue in common code

else

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif

        fstRET  KeAcquireQueuedSpinLockRaiseToSynch

endif

fstENDP KeAcquireQueuedSpinLockRaiseToSynch


; KIRQL
; KeAcquireQueuedSpinLock (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )

cPublicFastCall KeAcquireQueuedSpinLock,1
cPublicFpo 0,0

        ; Get old IRQL and raise to DISPATCH_LEVEL

        mov     eax, PCR[PcIrql]
        mov     dword ptr PCR[PcIrql], DISPATCH_LEVEL

if DBG
        cmp     eax, DISPATCH_LEVEL
        ja      short aqsl
endif

ifndef NT_UP

aqslrs:
        ; Get address of Lock Queue entry

        mov     edx, PCR[PcPrcb]                ; get address of PRCB
        lea     edx, [edx+ecx*8].PbLockQueue    ; get &PRCB->LockQueue[Number]

        ; Get address of the actual lock.

aqslrs10:
        mov     ecx, [edx].LqLock
        push    eax                             ; save return value (old IRQL)
        mov     eax, edx                        ; save Lock Queue entry address

        ; Exchange the value of the lock with the address of this
        ; Lock Queue entry.

        xchg    [ecx], edx

        cmp     edx, 0                          ; check if lock is held
        jnz     short @f                        ; jiff held

        ; note: the actual lock address will be word aligned, we use
        ; the bottom two bits as indicators, bit 0 is LOCK_QUEUE_WAIT,
        ; bit 1 is LOCK_QUEUE_OWNER.

        or      ecx, LOCK_QUEUE_OWNER           ; mark self as lock owner
        mov     [eax].LqLock, ecx

        ; lock has been acquired, return.

aqsl20: pop     eax                             ; restore return value

endif

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif

        fstRET  KeAcquireQueuedSpinLock

ifndef NT_UP

@@:
        ; The lock is already held by another processor.  Set the wait
        ; bit in this processor's Lock Queue entry, then set the next
        ; field in the Lock Queue entry of the last processor to attempt
        ; to acquire the lock (this is the address returned by the xchg
        ; above) to point to THIS processor's lock queue entry.

        or      ecx, LOCK_QUEUE_WAIT            ; set lock bit
        mov     [eax].LqLock, ecx

        mov     [edx].LqNext, eax               ; set previous acquirer's
                                                ; next field.

        ; Wait.
@@:
        YIELD                                   ; fire avoidance.
        test    [eax].LqLock, LOCK_QUEUE_WAIT   ; check if still waiting
        jz      short aqsl20                    ; jif lock acquired
        jmp     short @b                        ; else, continue waiting

endif

if DBG

aqsl:   mov     edx, DISPATCH_LEVEL
        stdCall _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,eax,edx,ecx,8>
        int     3
        ; never returns

endif

fstENDP KeAcquireQueuedSpinLock


        page    ,132
        subttl  "Release Queued SpinLock"

;++
;
; VOID
; KeReleaseInStackQueuedSpinLock (
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; Routine Description:
;
;    This function releases a queued spinlock and lowers the IRQL to
;    its previous value.
;
;    This differs from KeReleaseQueuedSpinLock in that this version
;    uses a caller supplied lock context where that one uses a
;    predefined lock context in the processor's PRCB.
;
;    This version sets up a compatible register context and uses
;    KeReleaseQueuedSpinLock to do the actual work.
;
; Arguments:
;
;    LockHandle (ecx) - Address of Lock Queue Handle structure.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KeReleaseInStackQueuedSpinLock,1
cPublicFpo 0,0

ifndef NT_UP

        movzx   edx, byte ptr [ecx].LqhOldIrql  ; get old irql
        lea     eax, [ecx].LqhNext              ; get address of lock struct
        jmp     short rqsl10                    ; continue in common code

else

        movzx   ecx, byte ptr [ecx].LqhOldIrql  ; get old irql
        jmp     @KfLowerIrql@4                  ; returns directly to our caller

endif


fstENDP KeReleaseInStackQueuedSpinLock


;++
;
; VOID
; KeReleaseQueuedSpinLock (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number,
;     IN KIRQL                   OldIrql
;     )
;
; Routine Description:
;
;    This function releases a queued spinlock and lowers the IRQL to
;    its previous value.
;
; Arguments:
;
;    Number  (ecx) - Supplies the queued spinlock number.
;    OldIrql (dl)  - Supplies the IRQL value to lower to.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KeReleaseQueuedSpinLock,2
cPublicFpo 0,0

.errnz  (LOCK_QUEUE_OWNER - 2)                  ; error if not bit 1 for btr

ifndef NT_UP

        ; Get address of Lock Queue entry

        mov     eax, PCR[PcPrcb]                ; get address of PRCB
        lea     eax, [eax+ecx*8].PbLockQueue    ; get &PRCB->LockQueue[Number]

rqsl10:
        push    ebx                             ; need another register
cPublicFpo 0,1

        ; Clear the lock field in the Lock Queue entry.

        mov     ebx, [eax].LqNext
        mov     ecx, [eax].LqLock

        ; Quick check: If Lock Queue entry's Next field is not NULL,
        ; there is another waiter.  Don't bother with ANY atomic ops
        ; in this case.
        ;
        ; Note: test clears CF and sets ZF appropriately, the following
        ; btr sets CF appropriately for the owner check.

        test    ebx, ebx

        ; clear the "I am owner" bit in the Lock entry.

        btr     ecx, 1                          ; clear owner bit.

if DBG

        jnc     short   rqsl98                  ; bugcheck if was not set
                                                ; tests CF
endif

        mov     [eax].LqLock, ecx               ; clear lock bit in queue entry
        jnz     short rqsl40                    ; jif another processor waits
                                                ; tests ZF

        ; ebx contains zero here which will be used to set the new owner NULL

        push    eax                             ; save &PRCB->LockQueue[Number]
cPublicFpo 0,2

        ; Use compare exchange to attempt to clear the actual lock.
        ; If there are still no processors waiting for the lock when
        ; the compare exchange happens, the old contents of the lock
        ; should be the address of this lock entry (eax).

        lock cmpxchg [ecx], ebx                 ; store 0 if no waiters
        pop     eax                             ; restore lock queue address
cPublicFpo 0,1
        jnz     short rqsl60                    ; jif store failed

        ; The lock has been released.  Lower IRQL and return to caller.

rqsl20:
        pop     ebx                             ; restore ebx
cPublicFpo 0,0

endif

        movzx   ecx, dl                         ; IRQL is 1st param KfLowerIrql
        jmp     @KfLowerIrql@4                  ; returns directly to our caller

        fstRET  KeReleaseQueuedSpinLock

ifndef NT_UP

        ; Another processor is waiting on this lock.   Hand the lock
        ; to that processor by getting the address of its LockQueue
        ; entry, turning ON its owner bit and OFF its wait bit.

rqsl40: xor     [ebx].LqLock, (LOCK_QUEUE_OWNER+LOCK_QUEUE_WAIT)

        ; Done, the other processor now owns the lock, clear the next
        ; field in my LockQueue entry (to preserve the order for entering
        ; the queue again) and proceed to lower IRQL and return.

        mov     [eax].LqNext, 0
        jmp     short rqsl20


        ; We get here if another processor is attempting to acquire
        ; the lock but had not yet updated the next field in this
        ; processor's Queued Lock Next field.   Wait for the next
        ; field to be updated.

rqsl60: mov     ebx, [eax].LqNext
        test    ebx, ebx                        ; check if still 0
        jnz     short rqsl40                    ; jif Next field now set.
        YIELD                                   ; wait a bit
        jmp     short rqsl60                    ; continue waiting

if DBG

cPublicFpo 0,1

rqsl98: stdCall _KeBugCheckEx,<SPIN_LOCK_NOT_OWNED,ecx,eax,0,1>
        int     3                               ; so stacktrace works

endif

endif

fstENDP KeReleaseQueuedSpinLock

        page    ,132
        subttl  "Try to Acquire Queued SpinLock"

;++
;
; LOGICAL
; KeTryToAcquireQueuedSpinLock (
;     IN  KSPIN_LOCK_QUEUE_NUMBER Number,
;     OUT PKIRQL OldIrql
;     )
;
; LOGICAL
; KeTryToAcquireQueuedSpinLockRaiseToSynch (
;     IN  KSPIN_LOCK_QUEUE_NUMBER Number,
;     OUT PKIRQL OldIrql
;     )
;
; Routine Description:
;
;    This function raises the current IRQL to DISPATCH/SYNCH level
;    and attempts to acquire the specified queued spinlock.  If the
;    spinlock is already owned by another thread, IRQL is restored
;    to its previous value and FALSE is returned.
;
; Arguments:
;
;    Number  (ecx) - Supplies the queued spinlock number.
;    OldIrql (edx) - A pointer to the variable to receive the old
;                    IRQL.
;
; Return Value:
;
;    TRUE if the lock was acquired, FALSE otherwise.
;    N.B. ZF is set if FALSE returned, clear otherwise.
;
;--


align 16
cPublicFastCall KeTryToAcquireQueuedSpinLockRaiseToSynch,2

ifndef NT_UP

cPublicFpo 0,3
        pushfd

else

cPublicFpo 0,2

endif

        push    edx
        push    SYNCH_LEVEL
        jmp     short taqsl10

fstENDP KeTryToAcquireQueuedSpinLockRaiseToSynch

cPublicFastCall KeTryToAcquireQueuedSpinLock,2

ifndef NT_UP

cPublicFpo 0,3
        pushfd

else

cPublicFpo 0,2

endif

        push    edx
        push    DISPATCH_LEVEL
taqsl10:

ifndef NT_UP

        ; Attempt to get the lock with interrupts disabled, raising
        ; the priority in the interrupt controller only if acquisition
        ; is successful.


        ; Get address of Lock Queue entry

        cli                                     ; disable interrupts
        mov     edx, PCR[PcPrcb]                ; get address of PRCB
        lea     edx, [edx+ecx*8].PbLockQueue    ; get &PRCB->LockQueue[Number]

        ; Get address of the actual lock.

        mov     ecx, [edx].LqLock
        cmp     dword ptr [ecx], 0              ; check if already taken
        jnz     short taqsl60                   ; jif already taken
        xor     eax, eax                        ; comparison value (not locked)

        ; Store the Lock Queue entry address in the lock ONLY if the
        ; current lock value is 0.

        lock cmpxchg [ecx], edx
        jnz     short taqsl60

        ; Lock has been acquired.

        ; note: the actual lock address will be word aligned, we use
        ; the bottom two bits as indicators, bit 0 is LOCK_QUEUE_WAIT,
        ; bit 1 is LOCK_QUEUE_OWNER.

        or      ecx, LOCK_QUEUE_OWNER           ; mark self as lock owner
        mov     [edx].LqLock, ecx

endif

        pop     ecx                             ; IRQL to ecx for RaiseIrql

ifndef NT_UP
cPublicFpo 0,2
else
cPublicFpo 0,1
endif

        fstCall KfRaiseIrql                     ; Raise IRQL

        pop     edx
        mov     [edx], al                       ; save OldIrql

ifndef NT_UP

        popfd                                   ; restore interrupt state

endif

        xor     eax, eax
        or      eax, 1                          ; return TRUE

        fstRET  KeTryToAcquireQueuedSpinLock

ifndef NT_UP

taqsl60:
        ; The lock is already held by another processor.  Indicate
        ; failure to the caller.

        pop     eax                             ; pop new IRQL off stack
        pop     edx                             ; pop saved OldIrql address
        popfd                                   ; restore interrupt state
        xor     eax, eax                        ; return FALSE
        fstRET  KeTryToAcquireQueuedSpinLock

endif

fstENDP KeTryToAcquireQueuedSpinLock

    page    ,132
    subttl  "End System Interrupt"

;++
;
; VOID
; HalpEndSystemInterrupt
;    IN KIRQL NewIrql,
;    IN ULONG Vector
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    NewIrql - the new irql to be set.
;
;    Vector - Vector number of the interrupt
;
;    Note that esp+12 is the beginning of interrupt/trap frame and upon
;    entering to this routine the interrupts are off.
;
; Return Value:
;
;    None.
;
;--

HeiNewIrql      equ     [esp + 4]

cPublicProc _HalEndSystemInterrupt  ,2
cPublicFpo 2, 0

        movzx   ecx, byte ptr HeiNewIrql; get new irql value
        cmp     dword ptr PCR[PcIrql],DISPATCH_LEVEL ; Software level?
        jbe     short Hei02             ; no, go set 8259 hw

        mov     eax, KiI8259MaskTable[ecx*4]; get pic masks for the new irql
        or      eax, PCR[PcIDR]         ; mask irqs which are disabled
        SET_8259_MASK                   ; set 8259 masks

Hei02:
        mov     PCR[PcIrql], ecx        ; set the new irql
        mov     eax, PCR[PcIRR]         ; get SW interrupt request register
        mov     al, SWInterruptLookUpTable[eax] ; get the highest pending
                                        ; software interrupt level
        cmp     al, cl                  ; Is highest SW int level > irql?
        ja      short Hei10             ; yes, go simulate interrupt

        stdRET    _HalEndSystemInterrupt                             ; cRetURN

;   When we come to Hei10, (eax) = soft interrupt index

Hei10:  add     esp, 12                 ; esp = trap frame
        jmp     SWInterruptHandlerTable2[eax*4] ; SIMULATE INTERRUPT
                                        ; to the appropriate handler

stdENDP _HalEndSystemInterrupt

;++
;
; VOID
; HalpEndSoftwareInterrupt
;    IN KIRQL NewIrql,
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL from software interrupt
;    level to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    NewIrql - the new irql to be set.
;
;    Note that esp+8 is the beginning of interrupt/trap frame and upon
;    entering to this routine the interrupts are off.
;
; Return Value:
;
;    None.
;
;--

HesNewIrql      equ     [esp + 4]

cPublicProc _HalpEndSoftwareInterrupt  ,1
cPublicFpo 1, 0

        movzx   ecx, byte ptr HesNewIrql; get new irql value

        cmp     dword ptr PCR[PcIrql],DISPATCH_LEVEL ; Software level?
        jbe     short Hes02             ; no, go set 8259 hw

        mov     eax, KiI8259MaskTable[ecx*4]; get pic masks for the new irql
        or      eax, PCR[PcIDR]         ; mask irqs which are disabled
        SET_8259_MASK                   ; set 8259 masks

Hes02:
        mov     PCR[PcIrql], ecx        ; set the new irql
        mov     eax, PCR[PcIRR]         ; get SW interrupt request register
        mov     al, SWInterruptLookUpTable[eax] ; get the highest pending
                                        ; software interrupt level
        cmp     al, cl                  ; Is highest SW int level > irql?
        ja      short Hes10             ; yes, go simulate interrupt

        stdRET    _HalpEndSoftwareInterrupt                             ; cRetURN

;   When we come to Hes10, (eax) = soft interrupt index

Hes10:  add     esp, 8
        jmp     SWInterruptHandlerTable2[eax*4] ; SIMULATE INTERRUPT

                                        ; to the appropriate handler
stdENDP _HalpEndSoftwareInterrupt


        page ,132
        subttl  "Get current irql"

;++
;
; KIRQL
; KeGetCurrentIrql (VOID)
;
; Routine Description:
;
;    This routine returns to current IRQL.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    The current IRQL.
;
;--

cPublicProc _KeGetCurrentIrql   ,0
cPublicFpo 0, 0
        mov   eax, dword ptr PCR[PcIrql]   ; Current irql is in the PCR
        stdRET    _KeGetCurrentIrql
stdENDP _KeGetCurrentIrql


;++
;
; KIRQL
; HalpDisableAllInterrupts (VOID)
;
; Routine Description:
;
;   This routine is called during a system crash.  The hal needs all
;   interrupts disabled.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None - all interrupts are masked off
;
;--

cPublicProc _HalpDisableAllInterrupts,0
cPublicFpo 0, 0

    ;
    ; Raising to HIGH_LEVEL disables interrupts for the microchannel HAL
    ;

        mov     ecx, HIGH_LEVEL
        fstCall KfRaiseIrql
        stdRET  _HalpDisableAllInterrupts

stdENDP _HalpDisableAllInterrupts


;++
;
; VOID
; HalpReenableInterrupts (
;     IN KIRQL Irql
;     )
;
; Routine Description:
;
;   Restores irql level.
;
; Arguments:
;
;    Irql - Irql state to restore to.
;
; Return Value:
;
;    None
;
;--

HriNewIrql      equ     [esp + 4]

cPublicProc _HalpReenableInterrupts,1
cPublicFpo 1, 0

        movzx   ecx, byte ptr HriNewIrql
        fstCall KfLowerIrql

        stdRET  _HalpReenableInterrupts

stdENDP _HalpReenableInterrupts

        page ,132
        subttl  "Interrupt Controller Chip Initialization"
;++
;
; VOID
; HalpInitializePICs (
;    BOOLEAN EnableInterrupts
;    )
;
; Routine Description:
;
;    This routine sends the 8259 PIC initialization commands and
;    masks all the interrupts on 8259s.
;
; Arguments:
;
;    EnableInterrupts - If this is true, then this function will
;                       explicitly enable interrupts at the end,
;                       as it always did in the past.  If this
;                       is false, then it will preserve the interrupt
;                       flag.
;
; Return Value:
;
;    None.
;
;--
EnableInterrupts equ [esp + 0ch]

cPublicProc _HalpInitializePICs       ,1

        push    esi                             ; save caller's esi
        pushfd
        cli                                     ; disable interrupt

        lea     esi, PICsInitializationString

        test    _HalpBusType, MACHINE_TYPE_MCA
        jz      short Hip00

; Is this a PS2 or PS700 series machine?

        in      al, 07fh                        ; get PD700 ID byte
        and     al, 0F0h                        ; Mask high nibble
        cmp     al, 0A0h                        ; Is the ID Ax?
        jz      short Hip00
        cmp     al, 090h                        ; Or an 9X?
        jz      short Hip00                     ; Yes, it's a 700

        lea     esi, PS2PICsInitializationString
Hip00:
        lodsw                                   ; (AX) = PIC port 0 address
Hip10:  movzx   edx, ax
        outsb                                   ; output ICW1
        IODelay
        inc     edx                             ; (DX) = PIC port 1 address
        outsb                                   ; output ICW2
        IODelay
        outsb                                   ; output ICW3
        IODelay
        outsb                                   ; output ICW4
        IODelay
        mov     al, 0FFH                        ; mask all 8259 irqs
        out     dx,al                           ; write mask to PIC
        lodsw
        cmp     ax, 0                           ; end of init string?
        jne     short Hip10                     ; go init next PIC

        mov     al, EnableInterrupts
        .if     (al != 0)
        or      [esp], EFLAGS_INTERRUPT_MASK    ; enable interrupts
        .endif
        popfd
        pop     esi                             ; restore caller's esi
        stdRET    _HalpInitializePICs
stdENDP _HalpInitializePICs


_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\mpclock.asm ===
;
; Include code from halmps
; This is a cpp style symbolic link

ACPI_HAL equ 1
MMTIMER equ 1
	
include ..\..\halmps\i386\mpclock.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\mpprofil.asm ===
;
; Include code from halmps
; This is a cpp style symbolic link

MMTIMER equ 1

include ..\..\halmps\i386\mpprofil.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\mpspin.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halmps\i386\mpspin.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\mpipi.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

ACPI_HAL equ 1

include ..\..\halmps\i386\mpipi.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\mpirql.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halmps\i386\mpirql.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\mpconfig.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halmps\i386\mpconfig.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\mpsproca.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halmps\i386\mpsproca.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\mpswint.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halmps\i386\mpswint.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\mpapic\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\acpidtct.c ===
//
// This file simply includes the common sources from the current HAL
// directory. When the structure is finally changed, the real file should
// be in this directory.
//

#include "..\acpidtct.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\xxioacc.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\xxioacc.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\rangesup.c ===
//
// This file simply includes the common sources from the current HAL
// directory. When the structure is finally changed, the real file should
// be in this directory.
//

#include "..\rangesup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\xxbiosa.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\xxbiosa.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\mpsysint.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halmps\i386\mpsysint.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\pmrtc.asm ===
title  "ACPI Real Time Clock Functions"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    pmclock.asm
;
; Abstract:
;
;    This module implements the code for ACPI-related RTC
;    functions.
;
; Author:
;
;    Jake Oshins (jakeo) March 28, 1997
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;    Split from pmclock.asm due to PIIX4 bugs.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include mac386.inc
include i386\ix8259.inc
include i386\ixcmos.inc
include xxacpi.h

        .list

        extrn   _HalpFixedAcpiDescTable:DWORD
        EXTRNP  _DbgBreakPoint,0,IMPORT
        EXTRNP  _HalpAcquireCmosSpinLock  ,0
        EXTRNP  _HalpReleaseCmosSpinLock  ,0
        extrn   _HalpRtcRegA:BYTE
        extrn   _HalpRtcRegB:BYTE
        extrn   _HalpCmosCenturyOffset:DWORD

INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
;   VOID
;   HalpInitializeCmos(
;       VOID
;       )
;
;   This routine reads CMOS and initializes globals required for
;   CMOS access, such as the location of the century byte.
;
;--

cPublicProc _HalpInitializeCmos,0
cPublicFpo 0,0        

        ;
        ; If the century byte is filled in, use it.
        ;
        
        movzx   eax, byte ptr [RTC_CENTURY]
        or      al, al
        jnz     short @f
        
        ;
        ; Assume default
        ;
        mov     eax, RTC_OFFSET_CENTURY

@@:
        mov     _HalpCmosCenturyOffset, eax
        
        stdRET  _HalpInitializeCmos

stdENDP _HalpInitializeCmos

INIT   ends

_TEXT$03   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;   NTSTATUS
;   HalpSetWakeAlarm (
;       IN ULONGLONG    WakeSystemTime,
;       IN PTIME_FIELDS WakeTimeFields OPTIONAL
;       )
;   /*++
;
;   Routine Description:
;
;       This routine sets the real-time clock's alarm to go
;       off at a specified time in the future and programs
;       the ACPI chipset so that this wakes the computer.
;
;   Arguments:
;
;       WakeSystemTime - amount of time that passes before we wake
;       WakeTimeFields - time to wake broken down into TIME_FIELDS
;
;   Return Value:
;
;       status
;
;   --*/
WakeSystemTime  equ [esp + 4]
WakeTimeFields  equ [esp + 12]

cPublicProc _HalpSetWakeAlarm, 3
cPublicFpo 3, 0

if DBG
hswawait0:
        mov     ecx, 100
hswawait:
        push    ecx
else
hswawait:
endif
        stdCall   _HalpAcquireCmosSpinLock
        mov     ecx, 100
        align   4
hswa00: mov     al, 0Ah                 ; Specify register A
        CMOS_READ                       ; (al) = CMOS register A
        test    al, CMOS_STATUS_BUSY    ; Is time update in progress?
        jz      short hswa10            ; if z, no, go write CMOS time
        loop    short hswa00            ; otherwise, try again.

;
; CMOS is still busy. Try again ...
;

        stdCall _HalpReleaseCmosSpinLock
if DBG
        pop     ecx
        loop    short hswawait
        stdCall _DbgBreakPoint
        jmp     short hswawait0
else
        jmp     short hswawait
endif
        align   4
if DBG
hswa10:
        pop     ecx
else
hswa10:
endif
        mov     edx, WakeTimeFields     ; (edx)-> TIME_FIELDS structure

        mov     al, [edx].TfSecond      ; Read second in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_SECOND_ALARM
        CMOS_WRITE

        mov     al, [edx].TfMinute      ; Read minute in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_MINUTE_ALARM
        CMOS_WRITE

        mov     al, [edx].TfHour        ; Read Hour in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_HOUR_ALARM
        CMOS_WRITE

        ; test to see if RTC_DAY_ALRM is supported
        mov     cl, byte ptr [RTC_DAY_ALRM]
        or      cl, cl
        jz      hswa20

        mov     al, [edx].TfDay         ; Read day in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, cl
        CMOS_WRITE

        ; test to see if RTC_MON_ALRM is supported
        mov     cl, byte ptr [RTC_MON_ALRM]
        or      cl, cl
        jz      hswa20

        mov     al, [edx].TfMonth       ; Read month in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, cl
        CMOS_WRITE

;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.
;
hswa20:
        mov     ax, 0bh
        CMOS_READ
        and     al, REGISTER_B_ENABLE_PERIODIC_INTERRUPT or 1
        mov     ah, al
        or      ah, REGISTER_B_ENABLE_ALARM_INTERRUPT or REGISTER_B_24HOUR_MODE
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize


        stdCall   _HalpReleaseCmosSpinLock

        xor     eax, eax                ; return STATUS_SUCCESS
        stdRET  _HalpSetWakeAlarm
stdENDP _HalpSetWakeAlarm

_TEXT$03   ends

PAGELK   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; HalpSetClockBeforeSleep (
;    VOID
;    )
;
; Routine Description:
;
;    This routine sets the RTC such that it will not generate
;    periodic interrupts while the machine is sleeping, as this
;    could be interpretted as an RTC wakeup event.
;
; Arguments:
;
; Return Value:
;
;    None
;
;--
cPublicProc _HalpSetClockBeforeSleep, 0
cPublicFpo 0, 0

        stdCall   _HalpAcquireCmosSpinLock

        mov     al, 0ah
        CMOS_READ
        mov     _HalpRtcRegA, al        ; save RTC Register A

        or      al, al
        jnz     @f                      ; TEMP - debug stop
    int 3                               ; looking for reg-a corruption
@@:

        mov     al, 0bh
        CMOS_READ
        and     al, not REGISTER_B_ENABLE_PERIODIC_INTERRUPT
        mov     _HalpRtcRegB, al        ; save RTC Register B
        or      al, REGISTER_B_24HOUR_MODE
        mov     ah, al
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize


        stdCall   _HalpReleaseCmosSpinLock

        stdRET  _HalpSetClockBeforeSleep
stdENDP _HalpSetClockBeforeSleep


;++
;
; VOID
; HalpSetClockAfterSleep (
;    VOID
;    )
;
; Routine Description:
;
;    This routine sets the RTC back to the way it was
;    before a call to HalpSetClockBeforeSleep.
;
; Arguments:
;
; Return Value:
;
;    None
;
;--
cPublicProc _HalpSetClockAfterSleep, 0
cPublicFpo 0, 0

        stdCall   _HalpAcquireCmosSpinLock

        mov     ah, _HalpRtcRegA        ; restore RTC Register A
        mov     al, 0ah
        CMOS_WRITE

        mov     ah, _HalpRtcRegB        ; restore RTC Register B
        and     ah, not REGISTER_B_ENABLE_ALARM_INTERRUPT
        or      ah, REGISTER_B_24HOUR_MODE
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize

        stdCall   _HalpReleaseCmosSpinLock

        stdRET  _HalpSetClockAfterSleep
stdENDP _HalpSetClockAfterSleep

PAGELK   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\pmtimer.asm ===
title  "ACPI Timer Functions"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    pmtimer.asm
;
; Abstract:
;
;    This module implements the code for ACPI-related timer
;    functions.
;
; Author:
;
;    Jake Oshins (jakeo) March 28, 1997
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;    Split from pmclock.asm due to PIIX4 bugs.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include mac386.inc
include i386\ix8259.inc
include i386\ixcmos.inc
include xxacpi.h

        .list

        extrn   _HalpFixedAcpiDescTable:DWORD
        extrn   _HalpPiix4:byte
        extrn   _HalpNextMSRate:DWORD
	extrn   _PMTimerFreq:DWORD
if DBG
        extrn   _LastKQPCValue:DWORD
endif        
        
;
; ==== Values used for ACPI Clock ====
;


_DATA   SEGMENT  DWORD PUBLIC 'DATA'

MSBMASK24       equ     00800000h
MSBMASK32       equ     80000000h

CurrentTimePort equ     0
TimeLow         equ     4
TimeHigh2       equ     8
TimeHigh1       equ     12
MsbMask         equ     16
BiasLow         equ     20
BiasHigh        equ     24
UpperBoundLow   equ     28
UpperBoundHigh2 equ     32
UpperBoundHigh1 equ     36

        public _TimerInfo
_TimerInfo       dd      0,0,0,0,MSBMASK24,0,0,0,2,2

        public _QueryTimer
_QueryTimer      dd offset FLAT:@HalpQueryPerformanceCounter

if 0
;
; The UpperBoundTable contains the values which should be added 
; to the current counter value to ensure that the upper bound is
; reasonable.  Values listed here are for all the 15 possible
; timer tick lengths.  The unit is "PM Timer Ticks" and the
; value corresponds to the number of ticks that will pass in
; roughly two timer ticks at this rate.
;
UpperBoundTable dd      14000           ;  1 ms
                dd      28600           ;  2 ms
                dd      43200           ;  3 ms
                dd      57200           ;  4 ms
                dd      71600           ;  5 ms
                dd      86000           ;  6 ms
                dd      100200          ;  7 ms
                dd      114600          ;  8 ms
                dd      128800          ;  9 ms
                dd      143400          ; 10 ms
                dd      157400          ; 11 ms
                dd      171800          ; 12 ms
                dd      186200          ; 13 ms
                dd      200400          ; 14 ms
                dd      214800          ; 15 ms
endif

if DBG
TicksPassed     dd      0,0

        public _TimerPerf, _TimerPerfIndex
_TimerPerf db 4096 dup(0)        

RawRead0        equ     0
RawRead1        equ     4
AdjustedLow0    equ     8
AdjustedHigh0   equ     12
AdjustedLow1    equ     16
AdjustedHigh1   equ     20
TITL            equ     24
TITH            equ     28
UBL             equ     32
UBH             equ     36
ReturnedLow     equ     40
ReturnedHigh    equ     44
ReadCount       equ     48
TickMin         equ     52
TickCount       equ     56
TickNewUB       equ     60
TimerPerfBytes  equ     64

_TimerPerfIndex dd      0

endif

_DATA   ends

_TEXT$03   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Query Performance Counter"
;++
;
; VOID
; HalCalibratePerformanceCounter (
;     IN LONG volatile *Number,
;     IN ULONGLONG NewCount
;     )
;
; /*++
;
; Routine Description:
;
;     This routine resets the performance counter value for the current
;     processor to zero. The reset is done such that the resulting value
;     is closely synchronized with other processors in the configuration.
;
; Arguments:
;
;     Number - Supplies a pointer to count of the number of processors in
;     the configuration.
;
;     NewCount - Supplies the value to synchronize the counter too
;
; Return Value:
;
;     None.
;--
cPublicProc _HalpPmTimerCalibratePerfCount, 3
cPublicFpo 3,1
        push    edi
        mov     edi, [esp+8]                    ; ponter to context

        cmp     byte ptr PCR[PcNumber], 0       ; only execute on one processor
        jnz     short hcp_50                    ; if not boot processor, wait

        mov     eax, _QueryTimer                ; move current counter into edx:eax
        call    eax

        mov     ecx, [esp+12]                   ; compute how far current count
        sub     ecx, eax                        ; is from target count
        mov     eax, [esp+16]
        sbb     eax, edx

        mov     _TimerInfo.BiasLow, ecx         ; replace bias
        mov     _TimerInfo.BiasHigh, eax

hcp_50:
    lock dec    dword ptr [edi]                 ; count down

@@:     YIELD
        cmp     dword ptr [edi], 0              ; wait for all processors to signal
        jnz     short @b

        pop     edi
        stdRET    _HalpPmTimerCalibratePerfCount

stdENDP _HalpPmTimerCalibratePerfCount

        page ,132
        subttl  "Query Performance Counter"
;++
;
; LARGE_INTEGER
; FASTCALL
; HalpQueryPerformanceCounter(
;     VOID
;     )
;
; Routine Description:
;
;     This function is a simplified form of HalpAcpiTimerQueryPerfCount
;     meant to be used internally by the HAL.
;
cPublicFastCall HalpQueryPerformanceCounter,0
cPublicFpo 0, 2

        push    ebx
        push    esi

        ;
        ; Snap current times
        ;

kqpc10: YIELD
        mov     esi, _TimerInfo.TimeHigh2
        mov     ebx, _TimerInfo.TimeLow

        cmp     esi, _TimerInfo.TimeHigh1
        jne     short kqpc10        ; Loop until consistent copy read

        mov     edx, _TimerInfo.CurrentTimePort
        in      eax, dx

        ;
        ; See if h/w MSb matches s/w copy
        ;

        mov     ecx, _TimerInfo.MsbMask
        mov     edx, eax
        xor     edx, ebx
        and     edx, ecx            ; Isolate MSb match or mismatch

        ;
        ; Strip high hardware bit
        ;
        
        not     ecx
        and     eax, ecx
        not     ecx
        
        ;
        ; merge low bits
        ;

        dec     ecx                 
        not     ecx                 
        and     ebx, ecx
        or      eax, ebx
        
        ;
        ; If there was a mismatch, add a tick
        ;

        add     eax, edx
        adc     esi, 0
        
        mov     edx, esi                ; get the top-half of the return value

        pop     esi
        pop     ebx
        fstRET    HalpQueryPerformanceCounter
fstENDP HalpQueryPerformanceCounter


;++
;
; LARGE_INTEGER
; HalpPmTimerQueryPerfCount (
;    OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
;    )
;
; Routine Description:
;
;    This routine returns current 64-bit performance counter and,
;    optionally, the Performance Frequency.
;
;    N.B. The performace counter returned by this routine is
;    not necessary the value when this routine is just entered.
;    The value returned is actually the counter value at any point
;    between the routine is entered and is exited.
;
; Arguments:
;
;    PerformanceFrequency [TOS+4] - optionally, supplies the address
;        of a variable to receive the performance counter frequency.
;
; Return Value:
;
;    Current value of the performance counter will be returned.
;
;--

KqpcFrequency   EQU     [esp+8]     ; User supplied Performance Frequence

cPublicProc _HalpPmTimerQueryPerfCount, 1
.FPO (0, 1, 0, 1, 0, 0) 

        push    esi
        
        mov     eax, _QueryTimer
        call    eax

if 0
        ;
        ; Check to see if the timer ever reports time moving backwards
        ;
@@:        
        mov     esi, [_LastKQPCValue+8]
        mov     ecx, [_LastKQPCValue]
        cmp     esi, [_LastKQPCValue+4]
        jne     short @b
        
        cmp     edx, esi        ; check for rollover
        jl      short @f        

        sub     ecx, eax
        sbb     esi, edx
        jng     short @f
        int 3
@@:     
        mov     [_LastKQPCValue+4], edx
        mov     [_LastKQPCValue], eax
        mov     [_LastKQPCValue+8], edx
endif        

        ;
        ; Apply bias to time
        ;

        mov     ecx, _TimerInfo.BiasLow
        mov     esi, _TimerInfo.BiasHigh
        add     eax, ecx
        adc     edx, esi

        mov     ecx, KqpcFrequency
        or      ecx, ecx
        jnz     short kqpc20

	pop esi
	
        stdRET  _HalpPmTimerQueryPerfCount

kqpc20: mov     esi, _PMTimerFreq 
	mov     [ecx], esi  ; Hertz of PM timer
        mov     [ecx+4], 0
	pop     esi
        stdRET  _HalpPmTimerQueryPerfCount

stdENDP _HalpPmTimerQueryPerfCount

;++
;
; VOID
; HalAcpiTimerCarry (
;    VOID
;    )
;
; Routine Description:
;
;    This routine is called to service the PM timer carry interrupt
;
;    N.B. This function is called at interrupt time and assumes the
;    caller clears the interrupt
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None
;
;--


cPublicProc _HalAcpiTimerCarry, 0
cPublicFpo 0, 1

        push    ebx

        ;
        ; Get current time from h/w
        ;

        mov     edx, _TimerInfo.CurrentTimePort
        in      eax, dx
        mov     ebx, eax

        mov     ecx, _TimerInfo.MsbMask
        mov     eax, _TimerInfo.TimeLow
        mov     edx, _TimerInfo.TimeHigh2

        ;
        ; Add one tick
        ;

        add     eax, ecx
        adc     edx, 0

        ;
        ; MSb of h/w should now match s/w.  If not, add another tick
        ; to get them back in sync.  (debugger might knock them
        ; out of sync)
        ;

        xor     ebx, eax
        and     ebx, ecx
        add     eax, ebx
        adc     edx, 0

        ;
        ; Store in reverse order of code which reads it
        ;

        mov     _TimerInfo.TimeHigh1, edx
        mov     _TimerInfo.TimeLow, eax
        mov     _TimerInfo.TimeHigh2, edx

        pop     ebx
        stdRET  _HalAcpiTimerCarry
stdENDP _HalAcpiTimerCarry

;++
;
; VOID
; HalAcpiBrokenPiix4TimerCarry (
;    VOID
;    )
;
; Routine Description:
;
;    This routine does nothing.  When we are using the Broken Piix4 
;    Code (TM), we are guaranteed to have examined the timer many times
;    since the last rollover.  So we don't need to do any bookkeeping
;    here.
;
;    N.B. This function is called at interrupt time and assumes the
;    caller clears the interrupt
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None
;
;--
cPublicProc _HalAcpiBrokenPiix4TimerCarry, 0
        stdRET  _HalAcpiBrokenPiix4TimerCarry
stdENDP _HalAcpiBrokenPiix4TimerCarry

_TEXT$03   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halacpi\i386\pmstall.asm ===
title  "Stall Execution Support"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixstall.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process the
;    interval clock interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;
;       Add KiSetProfileInterval, KiStartProfileInterrupt,
;       KiStopProfileInterrupt procedures.
;       KiProfileInterrupt ISR.
;       KiProfileList, KiProfileLock are delcared here.
;
;   shielint 10-Dec-90
;       Add performance counter support.
;       Move system clock to irq8, ie we now use RTC to generate system
;         clock.  Performance count and Profile use timer 1 counter 0.
;         The interval of the irq0 interrupt can be changed by
;         KiSetProfileInterval.  Performance counter does not care about the
;         interval of the interrupt as long as it knows the rollover count.
;       Note: Currently I implemented 1 performance counter for the whole
;       i386 NT.
;
;   John Vert (jvert) 11-Jul-1991
;       Moved from ke\i386 to hal\i386.  Removed non-HAL stuff
;
;   shie-lin tzong (shielint) 13-March-92
;       Move System clock back to irq0 and use RTC (irq8) to generate
;       profile interrupt.  Performance counter and system clock use time1
;       counter 0 of 8254.
;
;   Landy Wang (corollary!landy) 04-Dec-92
;       Created this module by moving routines from ixclock.asm to here.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
include i386\ixcmos.inc
include xxacpi.h
        .list

        EXTRNP  _KeBugCheckEx,5,IMPORT
        EXTRNP  _DbgBreakPoint,0,IMPORT
        EXTRNP  _HalpAcquireCmosSpinLock  ,0
        EXTRNP  _HalpReleaseCmosSpinLock  ,0
        extrn   _HalpFixedAcpiDescTable:DWORD
        extrn   _QueryTimer:DWORD
	extrn   _PMTimerFreq:DWORD
        
_DATA   SEGMENT  DWORD PUBLIC 'DATA'

MinimumLoopQuantum      equ     42
MinimumLoopCount        dd      MinimumLoopQuantum
KqpcStallCount          db      0
	
; temptemp
if DBG
HalpAcpiStallIns        dd      0
endif

_DATA   ends

INIT    SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Initialize Stall Execution Counter"
;++
;
; VOID
; HalpInitializeStallExecution (
;    IN CCHAR ProcessorNumber
;    )
;
; Routine Description:
;
;    This routine is obsolete in this HAL.
;
; Arguments:
;
;    ProcessorNumber - Processor Number
;
; Return Value:
;
;    None.
;
;--

cPublicProc _HalpInitializeStallExecution     ,1
        stdRET    _HalpInitializeStallExecution
stdENDP _HalpInitializeStallExecution

        page ,132
        subttl  "Stall Execution"

cPublicProc _HalpRemoveFences
        mov     word ptr fence1, 0c98bh
        stdRET    _HalpRemoveFences
stdENDP _HalpRemoveFences

INIT   ends

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; HalpAcpiTimerStallExecProc(
;    IN ULONG MicroSeconds
;    )
;
; Routine Description:
;
;    This function stalls execution for the specified number of microseconds.
;    KeStallExecutionProcessor
;
; Arguments:
;
;    MicroSeconds - Supplies the number of microseconds that execution is to be
;        stalled.
;
; Return Value:
;
;    None.
;
; Comments:
;    
;    edi     - total ticks elapsed
;    ebx:esi - starting time, in ticks
;
;--

Target           equ [ebp + 8]
cyclesStalled    equ [ebp - 4]

MASK24           equ 0ff000000h
BIT24            equ 001000000h

cPublicProc _HalpAcpiTimerStallExecProc       ,1
cPublicFpo 1, 5

;
; Issue a CPUID to implement a "fence"
;
        push    ebp
        mov     ebp, esp
        sub     esp, 4                          ; make room for locals        
        push    ebx                             ; cpuid uses eax, ebx, ecx, edx
        push    esi
        push    edi

        xor     eax, eax                        ; Processor zero
        
    .586p
fence1: cpuid
    .386p

        xor     edi, edi                        ; zero total stall count
        
        mov     eax, Target
        
        or      eax, eax
        jz      aese10                          ; return if no loop needed

        ; 'Target' starts out as the argument of the function.
        ; It is in uSeconds.  We convert to timer ticks.
        mov     ebx, _PMTimerFreq
        mul     ebx
        mov     ebx, 1000000
        div     ebx
	sub     eax, 1		                ; fudge factor
	
	mov     Target, eax
        
        mov     eax, _QueryTimer                ; move current counter into edx:eax
        call    eax
        
        mov     esi, eax                        ; record the starting tick count
        mov     ebx, edx

if DBG        
        inc     HalpAcpiStallIns
endif        
        mov     cyclesStalled, 0
        mov     eax, MinimumLoopCount
        
AcpiLoop:
        add     cyclesStalled, eax              ; update total cycles stalled
ALIGN 16
        YIELD
        jmp     short aese05

ALIGN 16
        YIELD
aese05: sub     eax, 1                          ; (eax) = (eax) - 1
        jnz     short aese05

        ;
        ; Now figure out if we have to loop again
        ;
        mov     eax, _QueryTimer                ; move current counter into edx:eax
        call    eax
        
        sub     eax, esi                        ; get actual elapsed ticks
        sbb     edx, ebx                        ; check to see that the upper 32 bits agrees
        
if 0        
        jnl     short @f
        int 3                                   ; time seems to have gone backwards
@@:        
endif        
        
        jz      short aese06
        ;
        ; If the upper 32 bits doesn't agree, then something, perhaps the debugger,
        ; has caused time to slip a whole lot.  Just fix up the bottom 32-bits to
        ; reflect a large time slip to make the math simpler.
        ;
        
        mov     eax, 7fffffffh
aese06:
        
        ; edx:eax now contains the number of timer ticks elapsed
        
        cmp     eax, 3                          ; if 1 less than 1uS elapsed, loop some more
        jge     short aese09
        
        add     MinimumLoopCount, MinimumLoopQuantum
        mov     eax, MinimumLoopCount
        jmp     short AcpiLoop                  ; loop some more
        
aese09: mov     edi, eax                        ; edi <- total number of ticks elapsed
                
if DBG        
        or      edi, edi                        ; if the total elapsed ticks is still 0,
        jz      short aese20                    ; the timer hardware is broken.  Bugcheck.
endif        
        
        ; if we have waited long enough, quit
        cmp     edi, Target
        jge     short aese10
        
        ; calculate remaining wait
        push    ebx
        mov     ebx, Target
        sub     ebx, edi                        ; ebx <- remaining ticks
        
        mov     eax, cyclesStalled
        mul     ebx                             ; multiply by number of ticks remaining to wait
        and     edx, 011b                       ; chop edx so that we don't overflow
        div     edi                             ; divide by the number of ticks we have waited
	inc     eax		                ; Never zero!
        pop     ebx
@@:     jmp     AcpiLoop

aese10:
        ;
        ; Knock down MinimumLoopCount once every 0x100 calls to this
        ; function so that we don't accidentally stall for very
        ; large amounts of time.
        ;
        
        inc     KqpcStallCount
        .if ((KqpcStallCount == 0) && (MinimumLoopCount > MinimumLoopQuantum))
        mov     eax, MinimumLoopCount
        sub     eax, MinimumLoopQuantum
        mov     MinimumLoopCount, eax
        .endif

        pop     edi
        pop     esi
        pop     ebx
        mov     esp, ebp
        pop     ebp
        stdRET    _HalpAcpiTimerStallExecProc
        
if DBG
aese20:
        mov     eax, 0a5h
        mov     ebx, 020000h
        xor     esi, esi
        xor     edi, edi
        stdCall _KeBugCheckEx, <eax, ebx, edx, esi, edi>
        jmp     short aese10
endif        
        
stdENDP _HalpAcpiTimerStallExecProc

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\bushnd.c ===
//
// This file simply includes the common sources from the current HAL
// directory. When the structure is finally changed, the real file should
// be in this directory.
//

#include "..\bushnd.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\hals\halia64\ia64\dsdtaml.h ===
UCHAR GambitDSDT[] = {
	(UCHAR)0x44, (UCHAR)0x53, (UCHAR)0x44, (UCHAR)0x54, (UCHAR)0xd6, (UCHAR)0x2, (UCHAR)0, (UCHAR)0, 
	(UCHAR)0x1, (UCHAR)0xee, (UCHAR)0x49, (UCHAR)0x6e, (UCHAR)0x74, (UCHAR)0x65, (UCHAR)0x6c, (UCHAR)0, 
	(UCHAR)0x4c, (UCHAR)0x69, (UCHAR)0x6f, (UCHAR)0x6e, (UCHAR)0x53, (UCHAR)0x44, (UCHAR)0x56, (UCHAR)0, 
	(UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0x4d, (UCHAR)0x53, (UCHAR)0x46, (UCHAR)0x54, 
	(UCHAR)0x4, (UCHAR)0, (UCHAR)0, (UCHAR)0x1, (UCHAR)0x10, (UCHAR)0x13, (UCHAR)0x5c, (UCHAR)0x5f, 
	(UCHAR)0x50, (UCHAR)0x52, (UCHAR)0x5f, (UCHAR)0x5b, (UCHAR)0x83, (UCHAR)0xb, (UCHAR)0x43, (UCHAR)0x50, 
	(UCHAR)0x55, (UCHAR)0x30, (UCHAR)0, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0, 
	(UCHAR)0x5b, (UCHAR)0x80, (UCHAR)0x4c, (UCHAR)0x44, (UCHAR)0x53, (UCHAR)0x5f, (UCHAR)0x1, (UCHAR)0xb, 
	(UCHAR)0x2b, (UCHAR)0x80, (UCHAR)0xa, (UCHAR)0x1, (UCHAR)0x5b, (UCHAR)0x81, (UCHAR)0x10, (UCHAR)0x4c, 
	(UCHAR)0x44, (UCHAR)0x53, (UCHAR)0x5f, (UCHAR)0x1, (UCHAR)0x53, (UCHAR)0x4d, (UCHAR)0x46, (UCHAR)0x5a, 
	(UCHAR)0x1, (UCHAR)0x4c, (UCHAR)0x50, (UCHAR)0x4f, (UCHAR)0x4c, (UCHAR)0x1, (UCHAR)0x10, (UCHAR)0x22, 
	(UCHAR)0x5f, (UCHAR)0x47, (UCHAR)0x50, (UCHAR)0x45, (UCHAR)0x14, (UCHAR)0x1c, (UCHAR)0x5f, (UCHAR)0x4c, 
	(UCHAR)0x30, (UCHAR)0x42, (UCHAR)0, (UCHAR)0x80, (UCHAR)0x4c, (UCHAR)0x50, (UCHAR)0x4f, (UCHAR)0x4c, 
	(UCHAR)0x4c, (UCHAR)0x50, (UCHAR)0x4f, (UCHAR)0x4c, (UCHAR)0x86, (UCHAR)0x5c, (UCHAR)0x2e, (UCHAR)0x5f, 
	(UCHAR)0x53, (UCHAR)0x42, (UCHAR)0x5f, (UCHAR)0x4c, (UCHAR)0x49, (UCHAR)0x44, (UCHAR)0x5f, (UCHAR)0xa, 
	(UCHAR)0x80, (UCHAR)0x10, (UCHAR)0x4e, (UCHAR)0x24, (UCHAR)0x5c, (UCHAR)0x5f, (UCHAR)0x53, (UCHAR)0x42, 
	(UCHAR)0x5f, (UCHAR)0x5b, (UCHAR)0x82, (UCHAR)0x29, (UCHAR)0x4c, (UCHAR)0x49, (UCHAR)0x44, (UCHAR)0x5f, 
	(UCHAR)0x8, (UCHAR)0x5f, (UCHAR)0x48, (UCHAR)0x49, (UCHAR)0x44, (UCHAR)0xc, (UCHAR)0x41, (UCHAR)0xd0, 
	(UCHAR)0xc, (UCHAR)0xd, (UCHAR)0x14, (UCHAR)0x19, (UCHAR)0x5f, (UCHAR)0x4c, (UCHAR)0x49, (UCHAR)0x44, 
	(UCHAR)0, (UCHAR)0x70, (UCHAR)0xd, (UCHAR)0x4c, (UCHAR)0x49, (UCHAR)0x44, (UCHAR)0x20, (UCHAR)0x53, 
	(UCHAR)0x54, (UCHAR)0x41, (UCHAR)0x54, (UCHAR)0x45, (UCHAR)0, (UCHAR)0x5b, (UCHAR)0x31, (UCHAR)0xa4, 
	(UCHAR)0x4c, (UCHAR)0x50, (UCHAR)0x4f, (UCHAR)0x4c, (UCHAR)0x5b, (UCHAR)0x82, (UCHAR)0x4a, (UCHAR)0x21, 
	(UCHAR)0x50, (UCHAR)0x43, (UCHAR)0x49, (UCHAR)0x30, (UCHAR)0x8, (UCHAR)0x5f, (UCHAR)0x48, (UCHAR)0x49, 
	(UCHAR)0x44, (UCHAR)0xc, (UCHAR)0x41, (UCHAR)0xd0, (UCHAR)0xa, (UCHAR)0x3, (UCHAR)0x8, (UCHAR)0x5f, 
	(UCHAR)0x41, (UCHAR)0x44, (UCHAR)0x52, (UCHAR)0xa, (UCHAR)0, (UCHAR)0x8, (UCHAR)0x5f, (UCHAR)0x50, 
	(UCHAR)0x52, (UCHAR)0x54, (UCHAR)0x12, (UCHAR)0x43, (UCHAR)0xe, (UCHAR)0x10, (UCHAR)0x12, (UCHAR)0xd, 
	(UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x4, (UCHAR)0, (UCHAR)0xa, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0, (UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, 
	(UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x4, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x1, (UCHAR)0xa, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0xa, (UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, 
	(UCHAR)0x4, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x2, (UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x14, 
	(UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x4, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0x3, (UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x1e, (UCHAR)0x12, (UCHAR)0xd, 
	(UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x5, (UCHAR)0, (UCHAR)0xa, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x1, (UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, 
	(UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x5, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x1, (UCHAR)0xa, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0xb, (UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, 
	(UCHAR)0x5, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x2, (UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x15, 
	(UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x5, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0x3, (UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x1f, (UCHAR)0x12, (UCHAR)0xd, 
	(UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x6, (UCHAR)0, (UCHAR)0xa, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x2, (UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, 
	(UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x6, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x1, (UCHAR)0xa, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0xc, (UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHA