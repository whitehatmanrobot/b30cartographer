ase TokenType.Keyword_UNION:
							case TokenType.Keyword_WHERE:
							case TokenType.Null:
								
							case TokenType.Other_Comma:
								parserState = (TokenType.Other_Comma == token.Type) ? PARSERSTATE.FROM : PARSERSTATE.DONE;
								AddTable(currentPart, namePart, alias);
								currentPart = -1;
								alias = Token.Null;
								break;

							default:
								throw ADP.SyntaxErrorExpectedCommaAfterTable();
						}
						break;


					default:
						Debug.Assert (false, "no state defined!!!!we should never be here!!!");
						throw ADP.InvalidOperation(Res.GetString(Res.ADP_SQLParserInternalError));
 				}
				
				lastTokenType = token.Type;

				match = match.NextMatch();
				token = TokenFromMatch(match);
			}
		}
    
		static internal Token TokenFromMatch(Match match)
		{
			// No matches? we must be at the end of the string!
			if ((null == match) || (Match.Empty == match) || (!match.Success))
				return Token.Null;

			if (match.Groups[_identifierGroup].Success)
				return new Token(TokenType.Identifier,			match.Groups[_identifierGroup].Value);

			if (match.Groups[_quotedidentifierGroup].Success)
				return new Token(TokenType.QuotedIdentifier,	match.Groups[_quotedidentifierGroup].Value);

			if (match.Groups[_stringGroup].Success)
				return new Token(TokenType.String,				match.Groups[_stringGroup].Value);

			if (match.Groups[_otherGroup].Success)
			{
				string		value = match.Groups[_otherGroup].Value.ToLower(CultureInfo.InvariantCulture);
				TokenType	key = TokenType.Other;

				switch (value[0])
				{
					case ',': key = TokenType.Other_Comma;		break;
					case '.': key = TokenType.Other_Period;		break;
					case '(': key = TokenType.Other_LeftParen;	break;
					case ')': key = TokenType.Other_RightParen;	break;
					case '*': key = TokenType.Other_Star;		break;
				}
				return new Token(key, match.Groups[_otherGroup].Value);
			}

			if (match.Groups[_keywordGroup].Success) 
			{
				string		value = match.Groups[_keywordGroup].Value.ToLower(CultureInfo.InvariantCulture);
				int			length = value.Length;
				TokenType	key = TokenType.Keyword;
				
				switch (length)
				{
					case 2:
						if ("as" == value) 			{ key = TokenType.Keyword_AS;		break; }
						break;
					
					case 3:
						if ("for" == value) 		{ key = TokenType.Keyword_FOR;		break; }
						if ("all" == value) 		{ key = TokenType.Keyword_ALL;		break; }
						if ("top" == value) 		{ key = TokenType.Keyword_TOP;		break; }
						break;
					case 4:
						if ("from" == value) 		{ key = TokenType.Keyword_FROM;		break; }
						if ("into" == value) 		{ key = TokenType.Keyword_INTO;		break; }
						break;
					case 5:
						if ("where" == value) 		{ key = TokenType.Keyword_WHERE;	break; }
						if ("group" == value) 		{ key = TokenType.Keyword_GROUP;	break; }
						if ("order" == value) 		{ key = TokenType.Keyword_ORDER;	break; }
						if ("union" == value) 		{ key = TokenType.Keyword_UNION;	break; }
						if ("minus" == value) 		{ key = TokenType.Keyword_MINUS;	break; }
						break;
				
					case 6:
						if ("select" == value) 		{ key = TokenType.Keyword_SELECT;	break; }
						if ("having" == value) 		{ key = TokenType.Keyword_HAVING;	break; }
						break;

					case 7:
						if ("compute" == value) 	{ key = TokenType.Keyword_COMPUTE;	break; }
						break;

					case 8:
						if ("distinct" == value) 	{ key = TokenType.Keyword_DISTINCT;	break; }
						break;

					case 9:
						if ("intersect" == value) 	{ key = TokenType.Keyword_INTERSECT;break; }
						break;
				}

				if (TokenType.Keyword != key)
					return new Token(key, value);

				Debug.Assert(TokenType.Keyword != key, "unrecognized keyword: TokenFromMatch not in sync with regex pattern");
			}
			else
			{
				Debug.Assert(false, "unrecognized pattern: TokenFromMatch not in sync with regex pattern");
			}
			return Token.Null;
		}

		//	compares the two values in catalog order, taking into account
		//	quoting rules, and case-sensitivity rules, and returns true if
		//	they match.
		abstract protected bool CatalogMatch(
			string	valueA,
			string	valueB
			);
		
		//	Called after the table and column information is completed to
		//	identify which columns in the select-list are key columns for
		//	their table.
		abstract protected void GatherKeyColumns(
				DBSqlParserTable table
				);

		//	Called to get a column list for the table specified.
		abstract protected DBSqlParserColumnCollection GatherTableColumns(
			DBSqlParserTable table
			);
			
	}
}


/*
		[STAThread]
		static void Main(string[] args)
		{
			DBSqlParser	parser	= new DBSqlParser(
			 			"[a-zA-Z_#$]",
			 			"[a-zA-Z0-9_#$]",
			 			"\"",
			 			"([^\"]|\"\")*",
			 			"\"",
						"(" + "'" + "([^']|'')*" + "'" + ")"
						);

			parser.Parse("select 'this is a test' a from dual");
			parser.Parse("select (2 + count(empno)) a from scott.emp");
			parser.Parse("select empno + (2 + abs(empno)) \"Test a\" from scott.emp");
			parser.Parse("select empno + (2 + abs(empno)) \"Test a\" from scott.emp \"table1\", scott.dept \"table 2\"");
			parser.Parse("select select scott.emp.ename \"Test a\" from scott.emp");
			parser.Parse("select \"SCOTT\".emp.empno \"Test a\" from scott.emp");
			parser.Parse("select \"SCOTT\".\"EMP\".empno \"Test a\" from scott.emp");
			parser.Parse("select \"SCOTT\".\"EMP\".\"EMPNO\" \"Test a B\" from scott.emp");
			parser.Parse("select \"Database\".\"Schema\".\"Table\".* from scott.emp \"Test a B\", scott.dept");
			parser.Parse("select Scott.\"EMP\".\"EMPNO\" \"Test a B\" from scott.emp");
			parser.Parse("select Scott.Emp.\"EMPNO\" \"Test a B\" from scott.emp");
			parser.Parse("select aa.b, c.d e, f.g.h i, j.k.l.m n from o p, q.r s, t.u.v w where");
			parser.Parse("select 2 + 1 a from scott.emp");
			parser.Parse("select 2 + 1 a from dual");
			parser.Parse("select empno + 2 a from scott.emp");
			parser.Parse("select empno + 2 from scott.emp");
			parser.Parse("select 2 + empno a from scott.emp");
			select "Foo".*, "Foo".empNO eno from scott.emp "Foo"
		}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\namevaluepair.cs ===
//------------------------------------------------------------------------------
// <copyright file="NameValuePair.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OracleClient {

    [Serializable]
    sealed internal class NameValuePair {
        readonly private string _name;
        readonly private string _value;
        private NameValuePair _next;

        public NameValuePair(string name, string value) {
            if (ADP.IsEmpty(name)) {
                throw ADP.Argument("name");
            }
            _name = name;
            _value = value;
        }

        public NameValuePair(string name, string value, NameValuePair next) : this(name, value) {
            _next = next;
        }

        public string Name {
            get {
                return _name;
            }
        }
        public string Value {
            get {
                return _value;
            }
        }
        public NameValuePair Next {
            get {
                return _next;
            }
            set {
                if (null == _next) { _next = value; }
                else { throw new InvalidOperationException(); }
            }
        }

        public NameValuePair Clone() {
            return new NameValuePair(_name, _value);
        }

        /*public NameValuePair Find(string name) {
            for(NameValuePair pair = this; pair != null; pair = pair.Next) {
                if (pair._name == name) {
                    return pair;
                }
            }
            return null;
        }*/

        /*override public string ToString() {
            return ADP.StrEmpty;
        }*/
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\nativebuffer.cs ===
//----------------------------------------------------------------------
// <copyright file="NativeBuffer.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Data.SqlTypes;
	using System.Diagnostics;
	using System.IO;
	using System.Runtime.InteropServices;


	//----------------------------------------------------------------------
	// NativeBuffer
	//
	//	this class manages a buffer of native memory, including marshalling
	//	the data types that we support to and from it.
	//
	abstract internal class NativeBuffer
	{
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Fields 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
		private IntPtr	_buffer;			// pointer to native memory
		private int	    _bufferLength;		// length of a single element
		private int		_numberOfRows;		// maximum number of elements in the array
		private int		_currentOffset;		// offset to the current element
		private bool	_ready;				// only true when we've got something in the buffer
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Constructors 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		public NativeBuffer (int initialsize) 
		{
			_buffer		  = IntPtr.Zero;
			_bufferLength = initialsize;
			_numberOfRows = 1;
		}

		~NativeBuffer() 
		{
			Dispose(false);
		}
		

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		internal bool CurrentPositionIsValid
		{
			get {
				bool value = _currentOffset >= 0 && _currentOffset < (_numberOfRows * _bufferLength); 
				GC.KeepAlive(this);	// FXCOP
				return value;
			}
		}
		
		internal int NumberOfRows 
		{
			get { return _numberOfRows; }
			set { 
				Debug.Assert (_numberOfRows > 0, "invalid capacity?");
				_numberOfRows = value;
			}
		}

		internal int Length 
		{
			get {
				int value = _bufferLength;
				GC.KeepAlive(this);	// FXCOP
				return value;
			}
			set {
				// Check if we need to grow the buffer (no action otherwise)
				if (_bufferLength < value) 
				{
					int capacity = value * _numberOfRows;
					
					// Check if there is already memory associated with this object. 
					// If not get_Ptr will take care of that.
					if (IntPtr.Zero != _buffer) 
					{
						IntPtr newBuffer = Marshal.ReAllocCoTaskMem(_buffer, capacity);						
						_buffer = newBuffer;
					}
					_bufferLength = value;
				}
				GC.KeepAlive(this);	// FXCOP
			}
		}

		internal HandleRef Ptr 
		{
			get {
				HandleRef result = PtrOffset(0); 
				return result;
			}
		}

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		internal void Dispose() 
		{
			Dispose(true);            
			GC.SuppressFinalize(this);
		}

		internal void Dispose(bool disposing) 
		{
			IntPtr buf = _buffer;
			_buffer = IntPtr.Zero;
			
			if (buf != IntPtr.Zero) 
			{
				Marshal.FreeCoTaskMem(buf);
			}
			GC.KeepAlive(this);	// FXCOP
		}

		internal void MoveFirst()
		{
			_currentOffset=0;	 // Position at the first element in the array...
			_ready = true;
		}
		
		internal bool MoveNext()
		{
			if (!_ready)
				return false;

			_currentOffset += _bufferLength;

			if (_currentOffset >= (_numberOfRows * _bufferLength))
				return false;

			GC.KeepAlive(this);	// FXCOP
 			return true;
		}
		
		internal bool MovePrevious()
		{
			if (!_ready)
				return false;

			if (_currentOffset <= -_bufferLength)	// allow positioning before the first element (for HasRows support)...
				return false;

			_currentOffset -= _bufferLength;

			GC.KeepAlive(this);	// FXCOP
 			return true;
		}
		
		internal HandleRef PtrOffset(int offset)
		{
			// If there is no real memory associated with this NativeBuffer object 
			// we will allocate native memory and assign it to this object.
			if (_buffer == IntPtr.Zero) 
			{
//	Debug.Assert (_bufferLength != 0x1e, "DEBUG THIS!");
				_buffer = Marshal.AllocCoTaskMem((_numberOfRows * _bufferLength));
				SafeNativeMethods.ZeroMemory(_buffer, Math.Min(64, _bufferLength));
			}

			Debug.Assert (_currentOffset >= 0, "positioned before first row?");

			if (_currentOffset < 0)
				return ADP.NullHandleRef;	// this will probably cause a null reference exception, but it's better than walking over someone else's memory...

			IntPtr resultPtr;
			
			// Adjust for the current element...
			if (4 == IntPtr.Size)
				resultPtr = new IntPtr(_buffer.ToInt32() + _currentOffset + offset);
			else {
				Debug.Assert (8 == IntPtr.Size, "Are you happy Ed?");			
				resultPtr = new IntPtr(_buffer.ToInt64() + (Int64)(_currentOffset + offset));
			}
			HandleRef result = new HandleRef(this, resultPtr);
			GC.KeepAlive(this);
			return result;
		}
	}

	
	sealed internal class NativeBuffer_Exception : NativeBuffer {
		internal NativeBuffer_Exception(int initialsize) : base(initialsize) {}
	}

	sealed internal class NativeBuffer_LongColumnData : NativeBuffer {
		internal NativeBuffer_LongColumnData(int initialsize) : base(initialsize) {}
	}

	sealed internal class NativeBuffer_ParameterBuffer : NativeBuffer {
		internal NativeBuffer_ParameterBuffer(int initialsize) : base(initialsize) {
			SafeNativeMethods.ZeroMemory(Ptr.Handle,  Length);
		}
	}

	sealed internal class NativeBuffer_RowBuffer : NativeBuffer {
		internal NativeBuffer_RowBuffer(int initialsize) : base(initialsize) {}
	}

	sealed internal class NativeBuffer_ScratchBuffer : NativeBuffer {
		internal NativeBuffer_ScratchBuffer(int initialsize) : base(initialsize) {}
	}

	sealed internal class NativeBuffer_ServerVersion : NativeBuffer {
		internal NativeBuffer_ServerVersion(int initialsize) : base(initialsize) {}
	}



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\externdll.cs ===
//----------------------------------------------------------------------
// <copyright file="ExternDll.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
 	sealed internal class ExternDll 
	{
		internal const string Kernel32	 = "kernel32.dll";
		internal const string OciDll	 = "oci.dll";
#if USEORAMTS
		internal const string OraMtsDll  = "oramts.dll";
#else //!USEORAMTS
 		internal const string MtxOciDll  = "mtxoci.dll";
#endif //!USEORAMTS
 		internal const string MtxOci8Dll = "mtxoci8.dll";
 	};

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\adapterutil.cs ===
//------------------------------------------------------------------------------
// <copyright file="AdapterUtil.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OracleClient {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Data;
    using System.Data.Common;
    using System.Data.SqlTypes;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Security.Permissions;
    using System.Text;
    using System.Threading;
    using System.Security;
    using System.Runtime.Serialization;
    using Microsoft.Win32;

#if DEBUG
    using System.Data.OleDb;
    using System.Data.SqlClient;
#endif

    sealed internal class ADP {
        // The class ADP defines the exceptions that are specific to the Adapters.
		

        // The class contains functions that take the proper informational variables and then construct
        // the appropriate exception with an error string obtained from the resource Framework.txt.
        // The exception is then returned to the caller, so that the caller may then throw from its
        // location so that the catcher of the exception will have the appropriate call stack.
        // This class is used so that there will be compile time checking of error messages.
        // The resource Framework.txt will ensure proper string text based on the appropriate
        // locale.


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Traced Exception Constructors
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
        static internal Exception TraceException(Exception e) {
#if DEBUG
            Debug.Assert(null != e, "TraceException: null Exception");
            if (AdapterSwitches.DataError.TraceError) {
                if (null != e) {
                    Debug.WriteLine(e.ToString());
                }
                if (AdapterSwitches.DataError.TraceVerbose) {
                    Debug.WriteLine(Environment.StackTrace);
                }
            }
#endif
            return e;
        }


		static internal Exception Argument()
			{ return TraceException(new ArgumentException()); }
		
        static internal Exception Argument(string error) 
        	{ return TraceException(new ArgumentException(error)); }
        
        static internal Exception Argument(string error, Exception inner) 
        	{ return TraceException(new ArgumentException(error, inner)); }
        
        static internal Exception Argument(string error, string parameter) 
        	{ return TraceException(new ArgumentException(error, parameter)); }
        
        static internal Exception ArgumentNull(string parameter) 
        	{ return TraceException(new ArgumentNullException(parameter)); }
        
        static internal Exception ArgumentOutOfRange(string error) 
        	{ return TraceException(new ArgumentOutOfRangeException(error)); }
        
		static internal Exception ArgumentOutOfRange(string argName, string message)
			{ return TraceException(new ArgumentOutOfRangeException(argName, message)); }

        static internal Exception DataProvider(string error) 
        	{ return TraceException(new InvalidOperationException(error)); }

        static internal Exception IndexOutOfRange(string error) 
        	{ return TraceException(new IndexOutOfRangeException(error)); }
        
        static internal Exception InvalidCast() 
        	{ return TraceException(new InvalidCastException()); }
        
        static internal Exception InvalidCast(string error) 
        	{ return TraceException(new InvalidCastException(error)); }        

        static internal Exception InvalidOperation(string error) 
        	{ return TraceException(new InvalidOperationException(error)); }
        
        static internal Exception InvalidOperation(string error, Exception inner) 
        	{ return TraceException(new InvalidOperationException(error, inner)); }
        
        static internal Exception NullReference(string error) 
        	{ return TraceException(new NullReferenceException(error)); }
        
        static internal Exception NotSupported() 
        	{ return TraceException(new NotSupportedException()); }
        
		static internal Exception NotSupported(string message)
			{ return TraceException(new NotSupportedException(message)); }
		
        static internal Exception ObjectDisposed(string name) 
        	{ return TraceException(new ObjectDisposedException(name)); }

        static internal Exception OracleError(OciHandle errorHandle, int rc, NativeBuffer scratchpad)
        	{ return TraceException(new OracleException(errorHandle, rc, scratchpad)); }

        static internal Exception Overflow(string error) 
        	{ return TraceException(new OverflowException(error)); }
        
		static internal Exception Simple(string message)
			{ return TraceException(new Exception(message)); }
		

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Provider Specific Exceptions
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		static internal Exception BadBindValueType(Type valueType, OracleType oracleType)
			{ return InvalidCast(Res.GetString(Res.ADP_BadBindValueType, valueType.ToString(), oracleType.ToString(CultureInfo.CurrentCulture))); }

		static internal Exception BadOracleClientVersion()
			{ return Simple(Res.GetString(Res.ADP_BadOracleClientVersion)); }

		static internal Exception BufferExceeded()
			{ return ArgumentOutOfRange(Res.GetString(Res.ADP_BufferExceeded)); }

		static internal Exception CannotDeriveOverloaded()
			{ return InvalidOperation(Res.GetString(Res.ADP_CannotDeriveOverloaded)); }

#if EVERETT
		static internal Exception CannotOpenLobWithDifferentMode(OracleLobOpenMode newmode, OracleLobOpenMode current)
			{ return InvalidOperation(Res.GetString(Res.ADP_CannotOpenLobWithDifferentMode, newmode.ToString(CultureInfo.CurrentCulture), current.ToString(CultureInfo.CurrentCulture))); }
#endif //EVERETT

		static internal Exception ChangeDatabaseNotSupported()
			{ return NotSupported(Res.GetString(Res.ADP_ChangeDatabaseNotSupported)); }

		static internal Exception ClosedConnectionError()
			{ return InvalidOperation(Res.GetString(Res.ADP_ClosedConnectionError)); }

		static internal Exception ClosedDataReaderError()
			{ return InvalidOperation(Res.GetString(Res.ADP_ClosedDataReaderError)); }

        static internal Exception CommandTextRequired(string method) 
        	{ return InvalidOperation(Res.GetString(Res.ADP_CommandTextRequired, method)); }

        static internal Exception ConnectionAlreadyOpen(ConnectionState state)
        	{ return InvalidOperation(Res.GetString(Res.ADP_ConnectionAlreadyOpen, state.ToString(CultureInfo.CurrentCulture))); }

        static internal Exception ConnectionRequired(string method) 
        	{ return InvalidOperation(Res.GetString(Res.ADP_ConnectionRequired, method)); }
        
        static internal Exception ConnectionStringSyntax(int index) 
        	{ return Argument(Res.GetString(Res.ADP_ConnectionStringSyntax, index)); }
        
		static internal Exception CouldNotAttachToTransaction(string method, int rc)
			{ return Simple(Res.GetString(Res.ADP_CouldNotAttachToTransaction, rc.ToString("X", CultureInfo.CurrentCulture), method)); }

		static internal Exception CouldNotCreateEnvironment(int rc)
			{ return Simple(Res.GetString(Res.ADP_CouldNotCreateEnvironment, rc.ToString(CultureInfo.CurrentCulture))); }

        static internal Exception DataIsNull() 
        	{ return InvalidOperation(Res.GetString(Res.ADP_DataIsNull)); }

        static internal Exception DataReaderNoData() 
        	{ return InvalidOperation(Res.GetString(Res.ADP_DataReaderNoData)); }
        
        static internal Exception DeriveParametersNotSupported(IDbCommand value)
	        { return DataProvider(Res.GetString(Res.ADP_DeriveParametersNotSupported, value.GetType().Name, value.CommandType.ToString(CultureInfo.CurrentCulture))); }

		static internal Exception DistribTxRequiresOracle9i() 
        	{ return InvalidOperation(Res.GetString(Res.ADP_DistribTxRequiresOracle9i)); }

		static internal Exception DistribTxRequiresOracleServicesForMTS(Exception inner) 
        	{ return InvalidOperation(Res.GetString(Res.ADP_DistribTxRequiresOracleServicesForMTS), inner); }

		static internal Exception DynamicSQLJoinUnsupported() 
        	{ return InvalidOperation(Res.GetString(Res.ADP_DynamicSQLJoinUnsupported)); }
        
        static internal Exception DynamicSQLNoTableInfo() 
        	{ return InvalidOperation(Res.GetString(Res.ADP_DynamicSQLNoTableInfo)); }
       
        static internal Exception DynamicSQLNoKeyInfo(string command) 
        	{ return InvalidOperation(Res.GetString(Res.ADP_DynamicSQLNoKeyInfo, command)); }
        
        static internal Exception DynamicSQLNestedQuote(string name, string quote) 
        	{ return InvalidOperation(Res.GetString(Res.ADP_DynamicSQLNestedQuote, name, quote)); }
        
		static internal Exception InputRefCursorNotSupported(string parameterName)
        	{ return InvalidOperation(Res.GetString(Res.ADP_InputRefCursorNotSupported, parameterName)); }
        
		static internal Exception InternalPoolerError(int internalError)
        	{ return Simple(Res.GetString(Res.ADP_InternalPoolerError, internalError)); }
			
#if POSTEVERETT
		static internal Exception InvalidCatalogLocation(CatalogLocation catalogLocation)
        	{ return Argument(Res.GetString(Res.ADP_InvalidCatalogLocation, ((int) catalogLocation).ToString(CultureInfo.CurrentCulture))); }
#endif //POSTEVERETT

		static internal Exception InvalidCommandType(CommandType cmdType)
        	{ return Argument(Res.GetString(Res.ADP_InvalidCommandType, ((int) cmdType).ToString(CultureInfo.CurrentCulture))); }

        static internal Exception InvalidConnectionOptionLength(string key, int maxLength) 
        	{ return Argument(Res.GetString(Res.ADP_InvalidConnectionOptionLength, key, maxLength)); }
			
        static internal Exception InvalidConnectionOptionValue(string key) 
	        { return Argument(Res.GetString(Res.ADP_InvalidConnectionOptionValue, key)); }

        static internal Exception InvalidConnectionOptionValue(string key, Exception inner) 
        	{ return Argument(Res.GetString(Res.ADP_InvalidConnectionOptionValue, key), inner); }

        static internal Exception InvalidDataLength(long length) 
        	{ return IndexOutOfRange(Res.GetString(Res.ADP_InvalidDataLength, length.ToString(CultureInfo.CurrentCulture))); }

        static internal Exception InvalidDataRowVersion(DataRowVersion value) 
        	{ return Argument(Res.GetString(Res.ADP_InvalidDataRowVersion, ((int)value).ToString(CultureInfo.CurrentCulture))); }

		static internal Exception InvalidDataType(TypeCode tc)
            { return Argument(Res.GetString(Res.ADP_InvalidDataType, tc.ToString(CultureInfo.CurrentCulture))); }

		static internal Exception InvalidDataTypeForValue(Type dataType, TypeCode tc)
            { return Argument(Res.GetString(Res.ADP_InvalidDataTypeForValue, dataType.ToString(), tc.ToString(CultureInfo.CurrentCulture))); }

        static internal Exception InvalidDbType(DbType dbType)
        	{ return ArgumentOutOfRange(Res.GetString(Res.ADP_InvalidDbType, dbType.ToString(CultureInfo.CurrentCulture))); }

        static internal Exception InvalidDestinationBufferIndex(int maxLen, int dstOffset) 
        	{ return ArgumentOutOfRange(Res.GetString(Res.ADP_InvalidDestinationBufferIndex, maxLen.ToString(CultureInfo.CurrentCulture), dstOffset.ToString(CultureInfo.CurrentCulture))); }
        	
        static internal Exception InvalidMinMaxPoolSizeValues() 
        	{ return Argument(Res.GetString(Res.ADP_InvalidMinMaxPoolSizeValues)); }
  
        static internal Exception InvalidOffsetValue(int value) 
        	{ return Argument(Res.GetString(Res.ADP_InvalidOffsetValue, value.ToString(CultureInfo.CurrentCulture))); }
      
        static internal Exception InvalidOracleType(OracleType oracleType)
        	{ return ArgumentOutOfRange(Res.GetString(Res.ADP_InvalidOracleType, oracleType.ToString(CultureInfo.CurrentCulture))); }
        
        static internal Exception InvalidParameterDirection(ParameterDirection value) 
        	{ return Argument(Res.GetString(Res.ADP_InvalidParameterDirection, ((int)value).ToString(CultureInfo.CurrentCulture))); }

        static internal Exception InvalidSeekOrigin(SeekOrigin origin)
        	{ return Argument(Res.GetString(Res.ADP_InvalidSeekOrigin, origin.ToString(CultureInfo.CurrentCulture))); }
        
        static internal Exception InvalidSizeValue(int value) 
        	{ return Argument(Res.GetString(Res.ADP_InvalidSizeValue, value.ToString(CultureInfo.CurrentCulture))); }

        static internal Exception InvalidStatementType(StatementType value)
        	{ return Argument(Res.GetString(Res.ADP_InvalidStatementType, ((int)value).ToString(CultureInfo.CurrentCulture))); }

        static internal Exception InvalidSourceBufferIndex(int maxLen, long srcOffset) 
        	{ return ArgumentOutOfRange(Res.GetString(Res.ADP_InvalidSourceBufferIndex, maxLen.ToString(CultureInfo.CurrentCulture), srcOffset.ToString(CultureInfo.CurrentCulture))); }
        	
        static internal Exception InvalidSourceOffset(string argName, long minValue, long maxValue) 
        	{ return ArgumentOutOfRange(argName, Res.GetString(Res.ADP_InvalidSourceOffset, minValue.ToString(CultureInfo.CurrentCulture), maxValue.ToString(CultureInfo.CurrentCulture))); }
        	
        static internal Exception InvalidUpdateRowSource(int rowsrc) 
        	{ return Argument(Res.GetString(Res.ADP_InvalidUpdateRowSource, rowsrc.ToString(CultureInfo.CurrentCulture))); }

        static internal Exception KeywordNotSupported(string keyword) 
        	{ return Argument(Res.GetString(Res.ADP_KeywordNotSupported, keyword)); }
        
		static internal Exception LobAmountExceeded(string argName)
			{ return ArgumentOutOfRange(argName, Res.GetString(Res.ADP_LobAmountExceeded)); }

		static internal Exception LobAmountMustBeEven(string argName)
			{ return ArgumentOutOfRange(argName, Res.GetString(Res.ADP_LobAmountMustBeEven)); }

		static internal Exception LobPositionMustBeEven()
			{ return InvalidOperation(Res.GetString(Res.ADP_LobPositionMustBeEven)); }

        static internal Exception LobWriteInvalidOnNull ()
        	{ return InvalidOperation(Res.GetString(Res.ADP_LobWriteInvalidOnNull)); }

        static internal Exception LobWriteRequiresTransaction() 
        	{ return InvalidOperation(Res.GetString(Res.ADP_LobWriteRequiresTransaction)); }
        
		static internal Exception MissingSourceCommand() 
        	{ return InvalidOperation(Res.GetString(Res.ADP_MissingSourceCommand)); }
        
        static internal Exception MissingSourceCommandConnection() 
        	{ return InvalidOperation(Res.GetString(Res.ADP_MissingSourceCommandConnection)); }
        
		static internal Exception MustBePositive(string argName)
			{ return ArgumentOutOfRange(argName, Res.GetString(Res.ADP_MustBePositive)); }

#if EVERETT
		static internal Exception MustInstallNewMtxOciDistribTx() 
			{ return InvalidOperation(Res.GetString(Res.ADP_MustInstallNewMtxOciDistribTx)); }

		static internal Exception MustInstallNewMtxOciLONG() 
			{ return InvalidOperation(Res.GetString(Res.ADP_MustInstallNewMtxOciLONG)); }
#else //!EVERETT
		static internal Exception MustInstallNewMtxOci() 
			{ return InvalidOperation(Res.GetString(Res.ADP_MustInstallNewMtxOci)); }
#endif //!EVERETT

#if POSTEVERETT
        static internal Exception NoCatalogLocationChange() 
        	{ return InvalidOperation(Res.GetString(Res.ADP_NoCatalogLocationChange)); }
#endif //POSTEVERETT

		static internal Exception NoCommandText()
			{ return InvalidOperation(Res.GetString(Res.ADP_NoCommandText)); }

		static internal Exception NoConnectionString()
			{ return InvalidOperation(Res.GetString(Res.ADP_NoConnectionString)); }

		static internal Exception NoData()
			{ return InvalidOperation(Res.GetString(Res.ADP_NoData)); }

		static internal Exception NoLocalTransactionInDistributedContext()
			{ return InvalidOperation(Res.GetString(Res.ADP_NoLocalTransactionInDistributedContext)); }

		static internal Exception NoOptimizedDirectTableAccess()
        	{ return Argument(Res.GetString(Res.ADP_NoOptimizedDirectTableAccess)); }

		static internal Exception NoParallelTransactions()
        	{ return InvalidOperation(Res.GetString(Res.ADP_NoParallelTransactions)); }

        static internal Exception NoQuoteChange() 
        	{ return InvalidOperation(Res.GetString(Res.ADP_NoQuoteChange)); }

        internal const string ConnectionString = "ConnectionString";

        static internal Exception OpenConnectionPropertySet(string property) {
            return InvalidOperation(Res.GetString(Res.ADP_OpenConnectionPropertySet, property));
        }
        static internal Exception OpenConnectionRequired(string method, ConnectionState state) 
        	{ return InvalidOperation(Res.GetString(Res.ADP_OpenConnectionRequired, method, "ConnectionState", state.ToString(CultureInfo.CurrentCulture))); }
        	
        static internal Exception OperationFailed(string method, int rc)
        	{ return Simple(Res.GetString(Res.ADP_OperationFailed, method, rc)); }
        	
        static internal Exception OperationResultedInOverflow()
        	{ return Overflow(Res.GetString(Res.ADP_OperationResultedInOverflow)); }

#if EVERETT
        static internal Exception ParametersIsNotParent(Type parameterType, string parameterName, IDataParameterCollection collection) 
        	{ return Argument(Res.GetString(Res.ADP_CollectionIsNotParent, parameterType.Name, "ParameterName", parameterName, collection.GetType().Name)); }

        static internal Exception ParametersIsParent(Type parameterType, string parameterName, IDataParameterCollection collection) 
        	{ return Argument(Res.GetString(Res.ADP_CollectionIsNotParent, parameterType.Name, "ParameterName", parameterName, collection.GetType().Name)); }
#endif //EVERETT
		static internal Exception ParameterIsNull(string argname)
			{ return ArgumentNull(argname); }

		static internal Exception ParameterNameNotFound(string parameterName)
			{ return IndexOutOfRange(Res.GetString(Res.ADP_ParameterNameNotFound, parameterName)); }

		static internal Exception ParameterNotFound()
			{ return Argument(Res.GetString(Res.ADP_ParameterNotFound)); }

		static internal Exception ParameterIndexOutOfRange(int index)
			{ return IndexOutOfRange(Res.GetString(Res.ADP_ParameterIndexOutOfRange, index)); }

		static internal Exception ParameterSizeIsTooLarge(string parameterName)
			{ return Simple(Res.GetString(Res.ADP_ParameterSizeIsTooLarge, parameterName)); }

		static internal Exception ParameterSizeIsMissing(string parameterName, Type dataType)
			{ return Simple(Res.GetString(Res.ADP_ParameterSizeIsMissing, parameterName, dataType.Name)); }

#if EVERETT
		static internal Exception PleaseUninstallTheBeta()
			{ return InvalidOperation(Res.GetString(Res.ADP_PleaseUninstallTheBeta)); }
#endif //EVERETT

		static internal Exception PooledOpenTimeout() 
            { return InvalidOperation(Res.GetString(Res.ADP_PooledOpenTimeout)); }

		static internal Exception ReadOnlyLob()
			{ return NotSupported(Res.GetString(Res.ADP_ReadOnlyLob)); }

		static internal Exception SeekBeyondEnd()
			{ return ArgumentOutOfRange(Res.GetString(Res.ADP_SeekBeyondEnd)); }

		static internal Exception SQLParserInternalError() 
			{ return TraceException(InvalidOperation(Res.GetString(Res.ADP_SQLParserInternalError))); }

		static internal Exception SyntaxErrorExpectedCommaAfterColumn() 
			{ return TraceException(InvalidOperation(Res.GetString(Res.ADP_SyntaxErrorExpectedCommaAfterColumn))); }
		
		static internal Exception SyntaxErrorExpectedCommaAfterTable() 
			{ return TraceException(InvalidOperation(Res.GetString(Res.ADP_SyntaxErrorExpectedCommaAfterTable))); }
		
		static internal Exception SyntaxErrorExpectedIdentifier() 
			{ return TraceException(InvalidOperation(Res.GetString(Res.ADP_SyntaxErrorExpectedIdentifier))); }
			
		static internal Exception SyntaxErrorExpectedNextPart() 
			{ return TraceException(InvalidOperation(Res.GetString(Res.ADP_SyntaxErrorExpectedNextPart))); }
		
		static internal Exception SyntaxErrorMissingParenthesis() 
			{ return TraceException(InvalidOperation(Res.GetString(Res.ADP_SyntaxErrorMissingParenthesis))); }
		
		static internal Exception SyntaxErrorTooManyNameParts() 
			{ return TraceException(InvalidOperation(Res.GetString(Res.ADP_SyntaxErrorTooManyNameParts))); }
		
		static internal Exception SyntaxErrorUnexpectedFrom() 
			{ return TraceException(InvalidOperation(Res.GetString(Res.ADP_SyntaxErrorUnexpectedFrom))); }

		static internal Exception TransactionCompleted()
         	{ return InvalidOperation(Res.GetString(Res.ADP_TransactionCompleted)); }
        
		static internal Exception TransactionConnectionMismatch() 
        	{ return InvalidOperation(Res.GetString(Res.ADP_TransactionConnectionMismatch)); }
        
		static internal Exception TransactionPresent() 
          	{ return InvalidOperation(Res.GetString(Res.ADP_TransactionPresent)); }
          
        static internal Exception TransactionRequired() 
        	{ return InvalidOperation(Res.GetString(Res.ADP_TransactionRequired_Execute)); }
        
		static internal Exception TypeNotSupported(OCI.DATATYPE ociType)
			{ return NotSupported(Res.GetString(Res.ADP_TypeNotSupported, ociType.ToString(CultureInfo.CurrentCulture))); }

		static internal Exception UnknownDataTypeCode(Type dataType, TypeCode tc)
			{ return Simple(Res.GetString(Res.ADP_UnknownDataTypeCode, dataType.ToString(), tc.ToString(CultureInfo.CurrentCulture))); }

        static internal Exception UnsupportedIsolationLevel()
        	{ return Argument(Res.GetString(Res.ADP_UnsupportedIsolationLevel)); }

		static internal Exception WrongArgumentType(string argname, Type typeName)
			{ return InvalidCast(Res.GetString(Res.ADP_WrongArgumentType, argname, typeName.ToString())); }

        static internal Exception InvalidXMLBadVersion() 
        	{ return Argument(Res.GetString(Res.ADP_InvalidXMLBadVersion)); }
        
        static internal Exception NotAPermissionElement() 
        	{ return Argument(Res.GetString(Res.ADP_NotAPermissionElement)); }
        
        static internal Exception WrongType(Type type) 
        	{ return Argument(Res.GetString(Res.ADP_WrongType, type.FullName)); }

        
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Helper Functions
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
        static public void CheckArgumentLength(string value, string parameterName) {
            CheckArgumentNull(value, parameterName);
            if (0 == value.Length) {
                throw Argument("0 == "+parameterName+".Length", parameterName);
            }
        }
        static public void CheckArgumentLength(Array value, string parameterName) {
            CheckArgumentNull(value, parameterName);
            if (0 == value.Length) {
                throw Argument("0 == "+parameterName+".Length", parameterName);
            }
        }
        static public void CheckArgumentNull(object value, string parameterName) {
            if (null == value) {
                throw ArgumentNull(parameterName);
            }
        }

		static public void ClearArray(char[] array, int start, int length) {
			Array.Clear(array, start, length);
        }

		static public void ClearArray(ref byte[] array) {
			if (null != array) {
				Array.Clear(array, 0, array.Length);
				array = null;
			}
        }

		static public void ClearArray(ref char[] array) {
			if (null != array) {
				ClearArray(array, 0, array.Length);
				array = null;
			}
        }

		static public void CopyChars(char[] src, int srcOffset, char[] dst, int dstOffset, int length) {
			Buffer.BlockCopy(src, CharSize*srcOffset, dst, CharSize*dstOffset, CharSize*length);
        }

        static internal bool IsDirection(IDataParameter value, ParameterDirection condition) {
            return (condition == (condition & value.Direction));
        }
        static internal bool IsDirection(ParameterDirection value, ParameterDirection condition) {
            return (condition == (condition & value));
        }

        static internal bool IsEmpty(string str) {
            return ((null == str) || (0 == str.Length));
        }

        static internal bool IsEmpty(string[] array) {
            return ((null == array) || (0 == array.Length));
        }

        static internal bool IsNull(object value) {
            return ((null == value) || Convert.IsDBNull(value) || ((value is INullable) && (value as INullable).IsNull));
        }

#if OLEDB
        static internal string GetFullPath(string filename) { // MDAC 77686
            try { // try-filter-finally so and catch-throw
                FileIOPermission fiop = new FileIOPermission(PermissionState.None);
                fiop.AllFiles = FileIOPermissionAccess.PathDiscovery;
                fiop.Assert();
                try {
                    return Path.GetFullPath(filename);
                }
                finally { // RevertAssert w/ catch-throw
                    FileIOPermission.RevertAssert();
                }
            }
            catch { // MDAC 80973, 81286
                throw;
            }
        }
        
        static internal object LocalMachineRegistryValue(string subkey, string queryvalue) { // MDAC 77697
            try { // try-filter-finally so and catch-throw
                (new RegistryPermission(RegistryPermissionAccess.Read, "HKEY_LOCAL_MACHINE\\" + subkey)).Assert(); // MDAC 62028
                try {
                    using(RegistryKey key = Registry.LocalMachine.OpenSubKey(subkey, false)) {
                        return ((null != key) ? key.GetValue(queryvalue) : null);
                    }
                }
                finally { // RevertAssert w/ catch-throw
                    RegistryPermission.RevertAssert();
                }
            }
            catch { // Prevent exception filters from running in our space
                throw;// MDAC 80973, 81286
            }
        }
#endif //OLEDB

        static internal readonly int CharSize = System.Text.UnicodeEncoding.CharSize;

        static internal readonly byte[] EmptyByteArray = new Byte[0];

        internal const CompareOptions compareOptions = CompareOptions.IgnoreKanaType | CompareOptions.IgnoreWidth | CompareOptions.IgnoreCase;

#if ALLOWTRACING
 		static internal bool _traceObjectPoolActivity = AdapterSwitches.ObjectPoolActivity.Enabled;
 
		static internal void TraceObjectPoolActivity(string eventName, DBPooledObject pooledObject) {
			if (_traceObjectPoolActivity) {
	            Debug.WriteLine(String.Format("*** {0,-24} svcctx=0x{1}", 
									            	eventName, 
									            	((IntPtr)((OracleInternalConnection)pooledObject).ServiceContextHandle.Handle).ToInt64().ToString("x")
									            	));
			}
		}
 
		static internal void TraceObjectPoolActivity(string eventName, DBPooledObject pooledObject, Guid guid) {
			if (_traceObjectPoolActivity) {
	            Debug.WriteLine(String.Format("*** {0,-24} svcctx=0x{1} guid={2}", 
										            	eventName, 
										            	((IntPtr)((OracleInternalConnection)pooledObject).ServiceContextHandle.Handle).ToInt64().ToString("x"),
										            	guid
										            	));
			}
		}
#endif //ALLOWTRACING

#if DEBUG
        static internal void DebugWriteLine(string value) {
            if (null == value) {
                return;
            }
            int index;
            int length = value.Length - 512;
            for (index = 0; index < length; index += 512) {
                Debug.Write(value.Substring(index, 512));
            }
            Debug.WriteLine(value.Substring(index, value.Length - index));
        }

        static internal void TraceDataTable(string prefix, DataTable dataTable) {
            Debug.Assert(null != dataTable, "TraceDataTable: null DataTable");

            bool flag = (null == dataTable.DataSet);
            if (flag) {
                (new DataSet()).Tables.Add(dataTable);
            }
            TraceDataSet(prefix, dataTable.DataSet);

            if (flag) {
                dataTable.DataSet.Tables.Remove(dataTable);
            }
        }

        static internal void TraceDataSet(string prefix, DataSet dataSet) {
            Debug.Assert(null != dataSet, "TraceDataSet: null DataSet");
            System.IO.StringWriter sw = new System.IO.StringWriter();
            System.Xml.XmlTextWriter xmlTextWriter = new System.Xml.XmlTextWriter(sw);
            xmlTextWriter.Formatting = System.Xml.Formatting.Indented;

            dataSet.WriteXmlSchema(sw);
            sw.WriteLine();
            dataSet.WriteXml(xmlTextWriter, XmlWriteMode.DiffGram);
            sw.WriteLine();

            ADP.DebugWriteLine(prefix);
            ADP.DebugWriteLine(sw.ToString());
        }
#endif // DEBUG

        static internal DataRow[] SelectRows(DataTable dataTable, DataViewRowState rowStates) {
            // equivalent to but faster than 'return dataTable.Select("", "", rowStates);'
            int count = 0;
            DataRowCollection rows = dataTable.Rows;
            int rowCount = rows.Count;
            for (int i = 0; i < rowCount; ++i) {
                if (0 != ((int)rowStates & (int) rows[i].RowState)) {
                    count++;
                }
            }
            DataRow[] dataRows = new DataRow[count];

            if (0 < count) {
                int index = 0;
                for (int i = 0; index < count; ++i) {
                    if (0 != ((int)rowStates & (int) rows[i].RowState)) {
                        dataRows[index++] = rows[i];
                    }
                }
            }
            Debug.Assert(null != dataRows, "SelectRows: null return value");
            return dataRows;
        }

        static internal int SrcCompare(string strA, string strB) { // this is null safe
            return CultureInfo.CurrentCulture.CompareInfo.Compare(strA, strB, CompareOptions.None);
        }

        static internal int DstCompare(string strA, string strB) { // this is null safe
            return CultureInfo.CurrentCulture.CompareInfo.Compare(strA, strB, ADP.compareOptions);
        }

		static internal readonly String StrEmpty = ""; // String.Empty

		static internal readonly HandleRef NullHandleRef = new HandleRef(null, IntPtr.Zero);

        static internal void BuildSchemaTableInfoTableNames(string[] columnNameArray) {
            int length = columnNameArray.Length;
            Hashtable hash = new Hashtable(length);

            int startIndex = length; // lowest non-unique index
            for (int i = length - 1; 0 <= i; --i) {
                string columnName = columnNameArray[i];
                if ((null != columnName) && (0 < columnName.Length)) {
                    columnName = columnName.ToLower(CultureInfo.InvariantCulture);
                    if (hash.Contains(columnName)) {
                        startIndex = Math.Min(startIndex, (int) hash[columnName]);
                    }
                    hash[columnName] = i;
                }
                else {
                    columnNameArray[i] = ADP.StrEmpty; // MDAC 66681
                    startIndex = i;
                }
            }
            int uniqueIndex = 1;
            for (int i = startIndex; i < length; ++i) {
                string columnName = columnNameArray[i];
                if (0 == columnName.Length) { // generate a unique name
                    columnNameArray[i] = "Column";
                    uniqueIndex = GenerateUniqueName(hash, ref columnNameArray[i], i, uniqueIndex);
                }
                else {
                    columnName = columnName.ToLower(CultureInfo.InvariantCulture);
                    if (i != (int) hash[columnName]) {
                        GenerateUniqueName(hash, ref columnNameArray[i], i, 1); // MDAC 66718
                    }
                }
            }
        }

        static private int GenerateUniqueName(Hashtable hash, ref string columnName, int index, int uniqueIndex) {
            for (;; ++uniqueIndex) {
                string uniqueName = columnName + uniqueIndex.ToString(CultureInfo.CurrentCulture);
                string lowerName = uniqueName.ToLower(CultureInfo.InvariantCulture); // MDAC 66978
                if (!hash.Contains(lowerName)) {

                    columnName = uniqueName;
                    hash.Add(lowerName, index);
                    break;
                }
            }
            return uniqueIndex;
        }

#if DEBUG
        // exists to ensure that we don't accidently modify read-only hashtables
        sealed private class ProtectedHashtable : Hashtable {

            internal ProtectedHashtable(int size) : base(size) {
            }

            override public object this[object key] {
                set {
                    ReadOnly();
                }
            }
            override public void Add(object key, object value) {
                ReadOnly();
            }
            override public void Clear() {
                ReadOnly();
            }
            override public void Remove(object key) {
                ReadOnly();
            }
            internal void AddInternal(object key, object value) {
                base.Add(key, value);
            }
            private void ReadOnly() {
                Debug.Assert(false, "debug internal readonly hashtable protection");
                throw new InvalidOperationException("debug internal readonly hashtable protection");
            }
        }

        static internal Hashtable ProtectHashtable(Hashtable value) {
            ProtectedHashtable hash = new ProtectedHashtable(value.Count);
            foreach(DictionaryEntry entry in value) {
                hash.AddInternal(entry.Key, entry.Value);
            }
            return hash;
        }
#endif //DEBUG

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\interlockedstack.cs ===
//------------------------------------------------------------------------------
// <copyright file="InterlockedStack.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OracleClient
{
    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Threading;

    sealed internal class InterlockedStack 
    {
        private readonly Stack	_stack = new Stack();
        private int				_stackCount;
        
        internal InterlockedStack() { }

        internal int Count
    	{
    		get { return _stackCount; }
    	}
        
        internal void Push(Object o)
        {
            Debug.Assert(o != null, "Trying to push null on stack!");
        
            lock(_stack.SyncRoot) {
                _stack.Push(o);
                _stackCount = _stack.Count;
            }
        }
        
        internal Object Pop()
        {
            lock(_stack.SyncRoot) {
                if (_stack.Count > 0) {
                    object obj = _stack.Pop();
                    _stackCount = _stack.Count;
                    return obj;
                }
                else {
                    return null;
                }
            }   
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\common\namevaluepermission.cs ===
//------------------------------------------------------------------------------
// <copyright file="NameValuePermission.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OracleClient {

    using System.Collections;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Globalization;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;

    [Serializable] // MDAC 83147
    sealed internal class NameValuePermission : IComparable {
        // reused as both key and value nodes
        // key nodes link to value nodes
        // value nodes link to key nodes
        private string _value;

        // value node with (null != _restrictions) are allowed to match connection strings
        private DBConnectionString _entry;

        private NameValuePermission[] _tree; // with branches

        static internal readonly NameValuePermission Default = null;// = new NameValuePermission(String.Empty, new string[] { "File Name" }, KeyRestrictionBehavior.AllowOnly);

        internal NameValuePermission() { // root node
        }

        private NameValuePermission(string keyword) {
            _value = keyword;
       }

        private NameValuePermission(string value, DBConnectionString entry) {
            _value = value;
            _entry = entry;
        }

        private NameValuePermission(NameValuePermission permit) { // deep-copy
            _value = permit._value;
            _entry = permit._entry;
            _tree = permit._tree;
            if (null != _tree) {
                NameValuePermission[] tree = (_tree.Clone() as NameValuePermission[]);
                int length = tree.Length;
                for(int i = 0; i < length; ++i) {
                    tree[i] = tree[i].Copy(); // deep copy
                }
                _tree = tree;
            }
        }

        int IComparable.CompareTo(object a) {
            return DBConnectionString.invariantComparer.Compare(_value, (a as NameValuePermission)._value);
        }

        static internal void AddEntry(NameValuePermission kvtree, ArrayList entries, DBConnectionString entry) {
            Debug.Assert(null != entry, "null DBConnectionString");

            if (null != entry.KeyChain) {
                for(NameValuePair keychain = entry.KeyChain; null != keychain; keychain = keychain.Next) {
                    NameValuePermission kv;

                    kv = kvtree.CheckKeyForValue(keychain.Name);
                    if (null == kv) {
                        kv = new NameValuePermission(keychain.Name);
                        kvtree.Add(kv); // add directly into live tree
                    }
                    kvtree = kv;

                    kv = kvtree.CheckKeyForValue(keychain.Value);
                    if (null == kv) {
                        DBConnectionString insertValue = ((null != keychain.Next) ? null : entry);
                        kv = new NameValuePermission(keychain.Value, insertValue);
                        kvtree.Add(kv); // add directly into live tree
                        if (null != insertValue) {
                            entries.Add(insertValue);
                        }
                    }
                    else if (null == keychain.Next) { // shorter chain potential
                        if (null != kv._entry) {
                            entries.Remove(kv._entry);
                            kv._entry = kv._entry.MergeIntersect(entry); // union new restrictions into existing tree
                        }
                        else {
                            kv._entry = entry;
                        }
                        entries.Add(kv._entry);
                    }
                    kvtree = kv;
                }
            }
            else { // global restrictions, MDAC 84443
                DBConnectionString kentry = kvtree._entry;
                if (null != kentry) {
                    entries.Remove(kentry);
                    kvtree._entry = kentry.MergeIntersect(entry);
                }
                else {
                    kvtree._entry = entry;
                }
                entries.Add(kvtree._entry);
            }
        }

        internal void Intersect(ArrayList entries, NameValuePermission target) {
            if (null == target) {
                _tree = null;
                _entry = null;
            }
            else {
                if (null != _entry) {
                    entries.Remove(_entry);
                    _entry = _entry.MergeIntersect(target._entry);
                    entries.Add(_entry);
                }
                else if (null != target._entry) {
                    _entry = target._entry.MergeIntersect(null);
                    entries.Add(_entry);
                }

                if (null != _tree) {
                    int count = _tree.Length;
                    for(int i = 0; i < _tree.Length; ++i) {
                        NameValuePermission kvtree = target.CheckKeyForValue(_tree[i]._value);
                        if (null != kvtree) { // does target tree contain our value
                            _tree[i].Intersect(entries, kvtree);
                        }
                        else {
                            _tree[i] = null;
                            --count;
                        }
                    }
                    if (0 == count) {
                        _tree = null;
                    }
                    else if (count < _tree.Length) {
                        NameValuePermission[] kvtree = new NameValuePermission[count];
                        for (int i = 0, j = 0; i < _tree.Length; ++i) {
                            if(null != _tree[i]) {
                                kvtree[j++] = _tree[i];
                            }
                        }
                    }
                }
            }
        }

        private void Add(NameValuePermission permit) {
            NameValuePermission[] tree = _tree;
            int length = ((null != tree) ? tree.Length : 0);
            NameValuePermission[] newtree = new NameValuePermission[1+length];
            for(int i = 0; i < length; ++i) {
                newtree[i] = tree[i];
            }
            newtree[length] = permit;
            Array.Sort(newtree);
            _tree = newtree;
        }

#if DATAPERMIT
        internal void DebugDump(string depth) {
            Debug.WriteLine(depth + "<" + _value + ">");
            if (null != _tree) {
                for(int i = 0; i < _tree.Length; ++i) {
                    _tree[i].DebugDump(depth+"-");
                }
            }
        }
#endif

        internal bool CheckValueForKeyPermit(DBConnectionString parsetable) {
            if (null == parsetable) {
                return false;
            }

            bool hasMatch = false;
            NameValuePermission[] keytree = _tree; // _tree won't mutate but Add will replace it
            if (null != keytree) {

                // which key do we follow the key-value chain on
                for (int i = 0; i < keytree.Length; ++i) {
                    NameValuePermission permitKey = keytree[i];
                    string keyword = permitKey._value;
#if DATAPERMIT
                    Debug.WriteLine("DBDataPermission keyword: <" + keyword + ">");
#endif
#if DEBUG
                    Debug.Assert(null == permitKey._entry, "key member has no restrictions");
#endif
                    if (parsetable.Contains(keyword)) {
                        string valueInQuestion = (string) parsetable[keyword];

                        // keyword is restricted to certain values
                        NameValuePermission permitValue = permitKey.CheckKeyForValue(valueInQuestion);
                        if (null != permitValue) {
                            //value does match - continue the chain down that branch
                            if (permitValue.CheckValueForKeyPermit(parsetable)) {
                                hasMatch = true;
                            }
                            else {
#if DATAPERMIT
                                Debug.WriteLine("DBDataPermission failed branch checking");
#endif
                                return false;
                            }
                        }
                        else { // value doesn't match to expected values - fail here
#if DATAPERMIT
                            Debug.WriteLine("DBDataPermission failed to match expected value");
#endif
                            return false;
                        }
                    }
                    // else try next keyword
                }
                // partial chain match, either leaf-node by shorter chain or fail mid-chain if (null == _restrictions)
            }
#if DATAPERMIT
            else {
                Debug.WriteLine("leaf node");
            }
#endif
            DBConnectionString entry = _entry;
            if (null != entry) {
                return entry.IsSubsetOf(parsetable);
            }
#if DATAPERMIT
            Debug.WriteLine("DBDataPermission failed on non-terminal node");
#endif
            return hasMatch; // mid-chain failure
        }

        private NameValuePermission CheckKeyForValue(string keyInQuestion) {
            NameValuePermission[] valuetree = _tree; // _tree won't mutate but Add will replace it
            if (null != valuetree) {
                for (int i = 0; i < valuetree.Length; ++i) {
                    NameValuePermission permitValue = valuetree[i];
#if DATAPERMIT
                    Debug.WriteLine("DBDataPermission value: <" + permitValue._value  + ">");
#endif
                    if (0 == ADP.DstCompare(keyInQuestion, permitValue._value)) {
                        return permitValue;
                    }
                }
            }            
            return null;
        }

        internal NameValuePermission Copy() {
            return new NameValuePermission(this);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\ocihandle.cs ===
//----------------------------------------------------------------------
// <copyright file="OciHandle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
    using System;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    //----------------------------------------------------------------------
    // OciHandle
    //
    //  Class to manage the lifetime of Oracle Call Interface handles, and
    //  to simplify a number of handle-related operations
    //
    abstract internal class OciHandle
    {
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Fields 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        
        private OciHandle          _parentOciHandle;   // the parent of this handle;
        private IntPtr              _handle;            // Actual OCI Handle
        private readonly OCI.HTYPE  _handleType;        // type of the handle (needed for various operations)
        private bool                _unicode;           // true when the (parent) environment handle was initialized for unicode data
        protected bool              _transacted;        // true when the (parent) environment handle was created for a distributed transaction.
    
        
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Constructors 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////

        // Empty constructor
        protected OciHandle() 
        {
            _handle = IntPtr.Zero;
        }

        // Construct from an external handle and type
        protected OciHandle(
            OciHandle   parentOciHandle,
            OCI.HTYPE   handleType,
            IntPtr      handle
            )
        {
            if (OCI.HTYPE.OCI_HTYPE_ENV != handleType && null == parentOciHandle)
            {
                Debug.Assert(false, "non-environment handle must have a parent");
            }
            else if (OCI.HTYPE.OCI_HTYPE_ENV == handleType && null != parentOciHandle)
            {
                Debug.Assert(false, "environment handle must not have a parent");
            }
            _parentOciHandle= parentOciHandle;
            _handleType     = handleType;
            _handle         = handle;

            if (null != _parentOciHandle)
                _unicode = parentOciHandle._unicode;
            else 
                _unicode = false;

//          Console.WriteLine(String.Format("OracleClient:     Wrap handle=0x{0,-8:x} parent=0x{2,-8:x} type={1}", handle, handleType, (null != parentOciHandle ) ? parentOciHandle.Handle : IntPtr.Zero));
        }

        // Construct from an external handle and type
        protected OciHandle(
            OciHandle   parentOciHandle,
            OCI.HTYPE   handleType,
            IntPtr      handle,
            bool        unicode
            ) : this (parentOciHandle, handleType, handle)
        {
            _unicode = unicode;
        }

        // Construct by allocating a new handle as a child of the specified parent handle
        protected OciHandle(
            OciHandle   parentOciHandle,
            OCI.HTYPE   handleType
            )
        {
            int rc;
            
            _parentOciHandle= parentOciHandle;
            _handleType     = handleType;
            _unicode        = parentOciHandle._unicode;

            if (_handleType < OCI.HTYPE.OCI_DTYPE_FIRST)
            {   
                rc = TracedNativeMethods.OCIHandleAlloc(
                                        parentOciHandle,
                                        out _handle,
                                        _handleType,
                                        0,
                                        ADP.NullHandleRef);
            }
            else
            {
                rc = TracedNativeMethods.OCIDescriptorAlloc(
                                        parentOciHandle,
                                        out _handle,
                                        _handleType,
                                        0,
                                        ADP.NullHandleRef);
            }
        
            if (0 != rc || IntPtr.Zero == _handle)
                throw ADP.OperationFailed("OCIDescriptorAllocate", rc);

//          Console.WriteLine(String.Format("OracleClient: Allocate handle=0x{0,-8:x} parent=0x{2,-8:x} type={1}", _handle, _handleType, (null != parentOciHandle ) ? parentOciHandle.Handle : IntPtr.Zero));
        }

        ~OciHandle()
        {
            Dispose(false);
        }
        

        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Properties 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////

        internal HandleRef Handle
        {
            get { 
                HandleRef value = new HandleRef(this, _handle);
                GC.KeepAlive(this);
                return value; 
            }
        }

        internal OCI.HTYPE HandleType
        {
            get {
                OCI.HTYPE value = _handleType;
                GC.KeepAlive(this);
                return value; 
            }
        }

        internal bool IsAlive
        {
            //  Determines whether the handle is alive enough that we can do
            //  something with it.  Basically, if the chain of parents are alive,
            //  we're OK.  When the entire connection, command and data reader go
            //  out of scope at the same time, there is no control over the order
            //  in which they're finalized, so we might have an environment handle
            //  that has already been freed.
            //
            // TODO: consider keeping the environment handle instead of the parent, since it appears that we only need to check it, and we don't really want to walk up the chain all the time.
            //
            get 
            {
                // If we're not an environment handle and our parent is dead, then
                // we can automatically dispose of ourself, because we're dead too.
                if ((_handleType != OCI.HTYPE.OCI_HTYPE_ENV) && (null != _parentOciHandle && !_parentOciHandle.IsAlive))
                    Dispose(true);

                bool value = (IntPtr.Zero != _handle);
                GC.KeepAlive(this);
                return value; 
            }
        
        }

        internal bool IsUnicode
        {
            get { return _unicode; }
        }


        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Methods 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////

        internal OciHandle CreateOciHandle(
            OCI.HTYPE   handleType
            )
        {
            //  Constructs a new handle of the type requested, with this handle
            //  as it's parent.  Basically, creates a new handle using the
            //  constructor that does all the work.
            switch (handleType)
            {
            case OCI.HTYPE.OCI_HTYPE_ERROR:     return new OciErrorHandle(this);
            case OCI.HTYPE.OCI_HTYPE_SERVER:    return new OciServerHandle(this);
            case OCI.HTYPE.OCI_HTYPE_SVCCTX:    return new OciServiceContextHandle(this);
            case OCI.HTYPE.OCI_HTYPE_SESSION:   return new OciSessionHandle(this);
            case OCI.HTYPE.OCI_HTYPE_STMT:      return new OciStatementHandle(this);

            default:
                Debug.Assert(false, "Unexpected OCI Handle Type requested:"+handleType.ToString("G"));
                return null;
            }
        }

        internal void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        private void Dispose(bool disposing)
        {
            HandleRef   localHandle       = Handle;
            OciHandle   localParentHandle = _parentOciHandle;

            try 
            {
                try 
                {
                    _parentOciHandle = null;
                    _handle = IntPtr.Zero;
                }
                finally
                {
                    // BIND, DEFINE and PARAM handles cannot be freed; they go away automatically
                    // (but you'll have to ask Oracle how...)
                    if (OCI.HTYPE.OCI_HTYPE_BIND   != _handleType
                     && OCI.HTYPE.OCI_HTYPE_DEFINE != _handleType
                     && OCI.HTYPE.OCI_DTYPE_PARAM  != _handleType
                     && IntPtr.Zero != localHandle.Handle
                     && !_transacted)
                    {
                        if (_handleType == OCI.HTYPE.OCI_HTYPE_ENV || (null != localParentHandle && localParentHandle.IsAlive))
                        {
                            // DEVNOTE: the finalizer creates a race condition: it is possible
                            //          for both this handle and it's parent to be finalized
                            //          concurrently.  If the parent handle is freed before we
                            //          free this handle, Oracle will AV when we actually get
                            //          to free it.  We put a try/catch around this to avoid
                            //          the unhandled AV in the race condition, but we can't do
                            //          much about cdb, which always breaks on the AV because 
                            //          it thinks its an unhandled exception, even though it's
                            //          being handled in managed code.
                            try
                            {
                                if (ExtraDispose(localHandle, _handleType)) {
                                    if (_handleType < OCI.HTYPE.OCI_DTYPE_FIRST)
                                        TracedNativeMethods.OCIHandleFree(localHandle, _handleType);
                                    else
                                        TracedNativeMethods.OCIDescriptorFree(localHandle, _handleType);
                                }
                            }
                            catch (NullReferenceException e)
                            {
                                ADP.TraceException(e);
                            }
                        }
                    }
                }
            }
            catch // Prevent exception filters from running in our space
            {
                throw;
            }
            GC.KeepAlive(this);
        }

        virtual protected bool ExtraDispose(HandleRef localHandle, OCI.HTYPE handleType) {
            //  Override this method to perform extra work when the handle is being 
            //  disposed -- don't touch other managed objects, however.  

            //  Return true if you wan't to force the handle to be freed, false if you've
            //  already handled it.
            return true;
        }

        //  Wrap the OCIAttrGet calls.  We do not expect OCIAttrGet to fail,
        //  so we will throw if it does.  There are multiple overloads here,
        //  one for each type of parameter that Oracle supports

        internal void GetAttribute(
                OCI.ATTR    attribute,
                out byte    value,
                OciHandle   errorHandle
                )
        {
            int zero = 0;
            int rc = TracedNativeMethods.OCIAttrGet( this, out value, out zero, attribute, errorHandle );

            if (0 != rc)
                OracleException.Check(errorHandle, rc);
            
            GC.KeepAlive(this);
        }
                
        internal void GetAttribute(
                OCI.ATTR    attribute,
                out short   value,
                OciHandle   errorHandle
                )
        {
            int zero = 0;
            int rc = TracedNativeMethods.OCIAttrGet( this, out value, out zero, attribute, errorHandle );

            if (0 != rc)
                OracleException.Check(errorHandle, rc);
            
            GC.KeepAlive(this);
        }
                
        internal void GetAttribute(
                OCI.ATTR    attribute,
                out int     value,
                OciHandle   errorHandle
                )
        {
            int zero = 0;
            int rc = TracedNativeMethods.OCIAttrGet( this, out value, out zero, attribute, errorHandle );

            if (0 != rc)
                OracleException.Check(errorHandle, rc);
            
            GC.KeepAlive(this);
        }

        internal void GetAttribute(
                OCI.ATTR    attribute,
                out string  value,
                OciHandle   errorHandle,
                OracleConnection    connection
                )
        {
            IntPtr  tempptr;
            int     tempub4;
            int rc = TracedNativeMethods.OCIAttrGet( this, out tempptr, out tempub4, attribute, errorHandle );

            if (0 != rc)
                OracleException.Check(errorHandle, rc);

            value = connection.GetString(tempptr, tempub4, false);
            
            GC.KeepAlive(this);
        }
                
        internal OciHandle GetDescriptor(
                int         i,
                OciHandle   errorHandle
                )
        {
            //  Wraps the OCIParamGet call. We do not expect it to fail, so we 
            //  will throw if it does.
            
            IntPtr  paramdesc;
            int     rc = TracedNativeMethods.OCIParamGet(
                                            this,       
                                            errorHandle,
                                            out paramdesc,
                                            i+1
                                            );

            if (0 != rc)
                OracleException.Check(errorHandle, rc);

            OciHandle result = new OciParameterDescriptor(this, paramdesc);         
            GC.KeepAlive(this);
            return result;
        }               

        internal OciHandle GetRowid(
                OciHandle       environmentHandle,
                OciHandle       errorHandle
                )
        {
            OciHandle rowidHandle = new OciRowidDescriptor(environmentHandle);
    
            int zero = 0;
            int rc = TracedNativeMethods.OCIAttrGet( this, rowidHandle, out zero, OCI.ATTR.OCI_ATTR_ROWID, errorHandle );

            if ((int)OCI.RETURNCODE.OCI_NO_DATA == rc)
                SafeDispose(ref rowidHandle);
            else if (0 != rc)
                OracleException.Check(errorHandle, rc);

            GC.KeepAlive(this);
            return rowidHandle;
        }

        internal byte[] GetBytes(string value)
        {
            byte[]  result;
            int     valueLength = value.Length;
            
            if (_unicode)
            {
                result = new byte[valueLength * ADP.CharSize];
                GetBytes(value.ToCharArray(), 0, valueLength, result, 0);
            }
            else
            {
                byte[]  temp        = new byte[valueLength * 4];    // one Unicode character can map to up to 4 bytes
                int     tempLength  = GetBytes(value.ToCharArray(), 0, valueLength, temp, 0);
                    
                result = new byte[tempLength];
                
                Buffer.BlockCopy(temp, 0, result, 0, tempLength);
            }
            
            return result;
        }

        internal int GetBytes(char[] chars, int charIndex, int charCount,
            byte[] bytes, int byteIndex) 
        {
            int byteCount;
            
            if (_unicode)
            {
                byteCount = charCount * ADP.CharSize;
                Buffer.BlockCopy(chars, charIndex*ADP.CharSize, bytes, byteIndex, byteCount);
            }
            else
            {
                OciHandle   ociHandle;
                
                if (OCI.HTYPE.OCI_HTYPE_ENV == _handleType)
                    ociHandle = this;
                else
                {
                    Debug.Assert(OCI.HTYPE.OCI_HTYPE_ENV == _parentOciHandle._handleType, "why is the parent handle not an environment handle?");
                    ociHandle = _parentOciHandle;
                }
            
                GCHandle    charsHandle = new GCHandle();
                GCHandle    bytesHandle = new GCHandle();

                int rc;

                try
                {
                    try 
                    {
                        charsHandle = GCHandle.Alloc(chars, GCHandleType.Pinned);
                        
                        IntPtr      charsPtr    = new IntPtr((long)charsHandle.AddrOfPinnedObject() + charIndex);
                        IntPtr      bytesPtr;

                        if (null == bytes)
                        {
                            bytesPtr    = IntPtr.Zero;
                            byteCount   = 0;
                        }
                        else
                        {
                            bytesHandle = GCHandle.Alloc(bytes, GCHandleType.Pinned);
                            bytesPtr    = new IntPtr((long)bytesHandle.AddrOfPinnedObject() + byteIndex);
                            byteCount   = bytes.Length-byteIndex;
                        }

                        rc = UnsafeNativeMethods.OCIUnicodeToCharSet(
                                                    ociHandle.Handle,
                                                    bytesPtr,
                                                    byteCount,
                                                    charsPtr,
                                                    charCount,
                                                    out byteCount
                                                    );
                    }
                    finally
                    {
                        charsHandle.Free();
                        
                        if (bytesHandle.IsAllocated)
                            bytesHandle.Free();
                    }

                    if (0 != rc)
                        throw ADP.OperationFailed("OCIUnicodeToCharSet", rc);
                    
                }
                catch // Prevent exception filters from running in our space
                {
                    throw;
                }
            }
            
            GC.KeepAlive(this);
            return byteCount;
        }

        internal int GetChars(byte[] bytes, int byteIndex, int byteCount, 
                char[] chars, int charIndex) 
        {
            int charCount;
            
            if (_unicode)
            {
                Debug.Assert(0 == (byteCount & 0x1), "Odd Number of Unicode Bytes?");
                charCount = byteCount / ADP.CharSize;
                Buffer.BlockCopy(bytes, byteIndex, chars, charIndex*ADP.CharSize, byteCount);
            }
            else
            {
                OciHandle   ociHandle;
                
                if (OCI.HTYPE.OCI_HTYPE_ENV == _handleType)
                    ociHandle = this;
                else
                {
                    Debug.Assert(OCI.HTYPE.OCI_HTYPE_ENV == _parentOciHandle._handleType, "why is the parent handle not an environment handle?");
                    Debug.Assert(null != _parentOciHandle,                                "why is the parent handle null?");
                    ociHandle = _parentOciHandle;
                }
            
                GCHandle    bytesHandle = new GCHandle();
                GCHandle    charsHandle = new GCHandle();

                int rc;

                try
                {
                    try 
                    {
                        bytesHandle = GCHandle.Alloc(bytes, GCHandleType.Pinned);
                        
                        IntPtr      bytesPtr    = new IntPtr((long)bytesHandle.AddrOfPinnedObject() + byteIndex);
                        IntPtr      charsPtr;

                        if (null == chars)
                        {
                            charsPtr    = IntPtr.Zero;
                            charCount   = 0;
                        }
                        else
                        {
                            charsHandle = GCHandle.Alloc(chars, GCHandleType.Pinned);
                            charsPtr    = new IntPtr((long)charsHandle.AddrOfPinnedObject() + charIndex);
                            charCount   = chars.Length-charIndex;
                        }

                        rc = UnsafeNativeMethods.OCICharSetToUnicode(
                                                    ociHandle.Handle,
                                                    charsPtr,
                                                    charCount,
                                                    bytesPtr,
                                                    byteCount,
                                                    out charCount
                                                    );
                    }
                    finally
                    {
                        bytesHandle.Free();
                        
                        if (charsHandle.IsAllocated)
                            charsHandle.Free();
                    }

                    if (0 != rc)
                        throw ADP.OperationFailed("OCICharSetToUnicode", rc);
                    
                }
                catch // Prevent exception filters from running in our space
                {
                    throw;
                }
            }

            GC.KeepAlive(this);
            return charCount;
        }


        internal string PtrToString(IntPtr buf)
        {
            string result;
            
            if (_unicode)
                result = Marshal.PtrToStringUni(buf);
            else
                result = Marshal.PtrToStringAnsi(buf);

            return result;
        }

#if DEBUG
        internal string PtrToString(IntPtr buf, int len)
        {
            string result;
            
            if (_unicode)
                result = Marshal.PtrToStringUni(buf, len);
            else
                result = Marshal.PtrToStringAnsi(buf, len);

            return result;
        }
#endif //DEBUG
        internal static void SafeDispose(ref OciHandle ociHandle)
        {
            //  Safely disposes of the handle (even if it is already null) and
            //  then nulls it out.
            if (null != ociHandle)
                ociHandle.Dispose();
            
            ociHandle = null;
        }
            
        //  Wrap the OCIAttrSet calls.  We do not expect OCIAttrSet to fail,
        //  so we will throw if it does.  There are multiple overloads here,
        //  one for each type of parameter that Oracle supports
        internal void SetAttribute(
                OCI.ATTR    attribute,
                int         value,
                OciHandle   errorHandle
                )
        {
            int rc = TracedNativeMethods.OCIAttrSet(
                        this,           // trgthndlp/trghndltyp
                        ref value,      // attributep
                        0,              // size
                        attribute,      // attrtype
                        errorHandle     // errhp
                        );

            if (0 != rc)
                OracleException.Check(errorHandle, rc);

            GC.KeepAlive(this);
        }
                
        internal void SetAttribute(
                OCI.ATTR    attribute,
                OciHandle   value,
                OciHandle   errorHandle
                )
        {
            int rc = TracedNativeMethods.OCIAttrSet(
                        this,           // trgthndlp/trghndltyp
                        value,          // attributep
                        0,              // size
                        attribute,      // attrtype
                        errorHandle     // errhp
                        );

            if (0 != rc)
                OracleException.Check(errorHandle, rc);

            GC.KeepAlive(this);
        }
                
        internal void SetAttribute(
                OCI.ATTR    attribute,
                string      value,
                OciHandle   errorHandle
                )
        {
            int     valueLengthAsChars = value.Length;
            byte[]  valueAsBytes = new byte[valueLengthAsChars * 4];
            int     valueLengthAsBytes = GetBytes(value.ToCharArray(), 0, valueLengthAsChars, valueAsBytes, 0);
        
            int rc = TracedNativeMethods.OCIAttrSet(
                        this,               // trgthndlp/trghndltyp
                        valueAsBytes,       // attributep
                        valueLengthAsBytes, // size
                        attribute,          // attrtype
                        errorHandle         // errhp
                        );

            if (0 != rc)
                OracleException.Check(errorHandle, rc);

            GC.KeepAlive(this);
        }

        internal void SetOciHandle(IntPtr value)
        {
            Debug.Assert (IntPtr.Zero != value, "handles must be non-zero!"); 
            _handle = value; 
            GC.KeepAlive(this);
        }

        public static implicit operator HandleRef(OciHandle x) 
        {
            HandleRef result = x.Handle;
            return result;
        }
    }

    sealed internal class OciBindHandle : OciHandle {
        internal OciBindHandle(OciHandle parent, IntPtr value) : base(parent, OCI.HTYPE.OCI_HTYPE_BIND, value) {}
    };

    sealed internal class OciDefineHandle : OciHandle {
        internal OciDefineHandle(OciHandle parent, IntPtr value) : base(parent, OCI.HTYPE.OCI_HTYPE_DEFINE, value) {}
    };
    
    sealed internal class OciEnvironmentHandle : OciHandle {
        HandleRef   _errorHandle = ADP.NullHandleRef;
        HandleRef   _serverHandle = ADP.NullHandleRef;
        
        internal OciEnvironmentHandle(IntPtr value, bool unicode) : this( value, unicode, false ) {}
        internal OciEnvironmentHandle(IntPtr value, bool unicode, bool transacted) : base(null, OCI.HTYPE.OCI_HTYPE_ENV, value, unicode) 
            { base._transacted = transacted; }
        
        override protected bool ExtraDispose(HandleRef localHandle, OCI.HTYPE handleType) {
            int rc;
            if (IntPtr.Zero != _serverHandle.Handle) {
                rc = TracedNativeMethods.OCIServerDetach(
                                            _serverHandle,          // srvhp
                                            _errorHandle,           // errhp
                                            OCI.MODE.OCI_DEFAULT    // mode
                                            );

                if (0 != rc) {
                    Debug.WriteLine(String.Format("OracleClient: OCIServerDetach(0x{0,-8:x} failed: rc={1:d}", localHandle.Handle, rc));
                    Debug.Assert(false, "OCIServerDetach failed");
                }
                rc = TracedNativeMethods.OCIHandleFree(_serverHandle, OCI.HTYPE.OCI_HTYPE_SERVER);
            }
            if (IntPtr.Zero != _errorHandle.Handle)
                rc = TracedNativeMethods.OCIHandleFree(_errorHandle, OCI.HTYPE.OCI_HTYPE_ERROR);
            
            rc = TracedNativeMethods.OCIHandleFree(localHandle, handleType);
            GC.KeepAlive(this);
            return false;   // don't bother with the default clean up, we already did it.
        }

        internal void SetExtraInfo(OciErrorHandle errorHandle, OciServerHandle serverHandle) {
            _errorHandle  = new HandleRef(this, errorHandle.Handle.Handle); // OciHandle->HandleRef->IntPtr
            errorHandle.SetExternalOwnership();
            
            _serverHandle = new HandleRef(this, serverHandle.Handle.Handle);// OciHandle->HandleRef->IntPtr
            serverHandle.SetExternalOwnership();
        }
    };
        
    sealed internal class OciErrorHandle : OciHandle {
        bool _needsCleanup = true;
        
        internal OciErrorHandle(OciHandle parent) : base(parent, OCI.HTYPE.OCI_HTYPE_ERROR) {}
        
        override protected bool ExtraDispose(HandleRef localHandle, OCI.HTYPE handleType) {
            return _needsCleanup;
        }

        internal void SetExternalOwnership() {
            _needsCleanup = false;
        }
    };
    
    sealed internal class OciServerHandle : OciHandle {
        bool _needsCleanup = true;
        
        internal OciServerHandle(OciHandle parent) : base(parent, OCI.HTYPE.OCI_HTYPE_SERVER) {}
        
        override protected bool ExtraDispose(HandleRef localHandle, OCI.HTYPE handleType) {
            return _needsCleanup;
        }
 
        internal void SetExternalOwnership() {
            _needsCleanup = false;
        }
   };
    
    sealed internal class OciServiceContextHandle : OciHandle {
        internal OciServiceContextHandle(OciHandle parent) : base(parent, OCI.HTYPE.OCI_HTYPE_SVCCTX) {}
        internal OciServiceContextHandle(OciHandle parent, IntPtr value, bool transacted) : base(parent, OCI.HTYPE.OCI_HTYPE_SVCCTX, value)
            { base._transacted = transacted; }
    };
    
    sealed internal class OciSessionHandle : OciHandle {
        internal OciSessionHandle(OciHandle parent) : base(parent, OCI.HTYPE.OCI_HTYPE_SESSION) {}
    };
    
    sealed internal class OciStatementHandle : OciHandle {
        internal OciStatementHandle(OciHandle parent) : base(parent, OCI.HTYPE.OCI_HTYPE_STMT) {}
    };

    sealed internal class OciLobDescriptor : OciHandle {
        internal OciLobDescriptor(OciHandle parent) : base(parent, OCI.HTYPE.OCI_DTYPE_LOB) {}
    };
    
    sealed internal class OciFileDescriptor : OciHandle {
        internal OciFileDescriptor(OciHandle parent) : base(parent, OCI.HTYPE.OCI_DTYPE_FILE) {}
    };
    
    sealed internal class OciParameterDescriptor : OciHandle {
        internal OciParameterDescriptor(OciHandle parent, IntPtr value) : base(parent, OCI.HTYPE.OCI_DTYPE_PARAM, value) {}
    };
    
    sealed internal class OciRowidDescriptor : OciHandle {
        internal OciRowidDescriptor(OciHandle parent) : base(parent, OCI.HTYPE.OCI_DTYPE_ROWID) {}
    };

        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oraclebinary.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleBinary.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Data.SqlTypes;
	using System.Diagnostics;
	using System.Globalization;
	using System.Runtime.InteropServices;
	using System.Text;

	//----------------------------------------------------------------------
	// OracleBinary
	//
	//	This class implements support for Oracle's RAW and LONGRAW internal
	//	data types.  It should simply be a wrapper class around a CLS Byte 
	//	Array data type, with the appropriate internal constructors to allow
	//	data values to be set from the data reader.
	//
    /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary"]/*' />
    [StructLayout(LayoutKind.Sequential)]
	public struct OracleBinary : IComparable, INullable
	{
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Fields
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
		private byte[] _value;	

        /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.Null"]/*' />
        public static readonly OracleBinary Null = new OracleBinary(true);

		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Constructors
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		// (internal) Construct from nothing -- the value will be null
		private OracleBinary(bool isNull)
		{	
			_value = (isNull) ? null : new byte[0];
		}

        /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.OracleBinary2"]/*' />
		public OracleBinary (byte[] b)  
		{
			_value = (null == b) ? b : (byte[])(b.Clone());
		}

        // (internal) construct from a row/parameter binding
		internal OracleBinary(
					NativeBuffer 		buffer,
					int					valueOffset,
					int					lengthOffset,
					MetaType			metaType)
		{
			int	 valueLength = GetLength(buffer, lengthOffset, metaType);
			
			_value = new byte[valueLength];

			GetBytes(buffer, 
					valueOffset, 
					metaType,
					0,
					_value,
					0,
					valueLength);
		}


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.IsNull"]/*' />
		public bool IsNull 
		{
			get { return (null == _value);}
		}

        /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.Length"]/*' />
        public int Length {
            get {
				if (IsNull)
	    			throw ADP.DataIsNull();
	    			
                return _value.Length;
            }
        }

        /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.Value"]/*' />
        public byte[] Value
        {
            get {
            	if (IsNull)
	    			throw ADP.DataIsNull();
    			
            	return (byte[])(_value.Clone()); 
            }           
        }

		/// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.this"]/*' />
		public byte this[int index] {
			get {
				if (IsNull)
	    			throw ADP.DataIsNull();

				return _value[index];
			}
		}
		
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.CompareTo"]/*' />
		public int CompareTo(
		  	object obj
			)
		{
			if (obj.GetType() == typeof(OracleBinary))
			{
	            OracleBinary b = (OracleBinary)obj;

	            // If both values are Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return b.IsNull ? 0  : -1;

                if (b.IsNull)
                    return 1;

				// Neither value is null, do the comparison.
				int result = PerformCompareByte(_value, b._value);
				return result;
			}

			// Wrong type!
			throw ADP.Argument();
		}

 		/// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.Equals"]/*' />
        public override bool Equals(object value) 
        {
            if (value is OracleBinary)
            	return (this == (OracleBinary)value).Value;
            else
                return false;
        }

		static internal int GetBytes(
					NativeBuffer 		buffer,
					int					valueOffset,
					MetaType			metaType,
					int					sourceOffset,
					byte[]				destinationBuffer,
					int					destinationOffset,
					int					byteCount
					)
		{
			// This static method allows the GetBytes type getter to do it's job
			// without having to marshal the entire value into managed space.
			HandleRef	sourceBuffer;
			
			if (!metaType.IsLong)
				sourceBuffer = buffer.PtrOffset(valueOffset+sourceOffset);
			else
			{
				// Long values are bound out-of-line, which means we have
				// to do this the hard way...
				sourceBuffer = buffer.PtrOffset(valueOffset);
				IntPtr longBuffer = Marshal.ReadIntPtr((IntPtr)sourceBuffer);

				if (0 != sourceOffset)
					longBuffer = new IntPtr(longBuffer.ToInt64() + (long)sourceOffset);

				HandleRef newSourceBuffer = new HandleRef(sourceBuffer.Wrapper, longBuffer);
				sourceBuffer = newSourceBuffer;
			}

			Marshal.Copy((IntPtr)sourceBuffer, destinationBuffer, destinationOffset, byteCount );
			GC.KeepAlive(sourceBuffer);
			return byteCount;
		}

		static internal int GetLength(
					NativeBuffer 		buffer,
					int					lengthOffset,
					MetaType			metaType
					)
		{
			// Get the length of the data bound
			int length;

			HandleRef	lengthBuffer = buffer.PtrOffset(lengthOffset);

			// Oracle only will write two bytes of length, but LONG data types
			// can exceed that amount; our piecewise callbacks will write a
			// full DWORD of length, so we need to get the full length for them,
			// but if we do that for all the other types, we'll be reading 
			// un-initialized memory and bad things happen.
			if (metaType.IsLong)
				length = Marshal.ReadInt32((IntPtr)lengthBuffer);
			else
				length = (int)Marshal.ReadInt16((IntPtr)lengthBuffer);

			return length;
		}

		/// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.GetHashCode"]/*' />
        public override int GetHashCode() 
        {
            return IsNull ? 0 : _value.GetHashCode();
        }

		static internal int MarshalToNative(object value, int offset, int size, HandleRef buffer, OCI.DATATYPE ociType)
		{
			byte[] from;
			
			if ( value is OracleBinary )
				from = ((OracleBinary)value)._value;
			else
				from = (byte[])value;

			int ociBytes = from.Length - offset;
			int adjust = 0;
			IntPtr to = (IntPtr)buffer;

			if (0 != size)
				ociBytes = Math.Min(ociBytes, size);

			if ( OCI.DATATYPE.LONGVARRAW == ociType )
			{
				Marshal.WriteInt32(to, ociBytes);
				adjust = 4;
				to = new IntPtr(to.ToInt64() + adjust);
			}
			else
				Debug.Assert (short.MaxValue >= ociBytes, "invalid size for non-LONG data?");
				
			Marshal.Copy( from, offset, to, ociBytes);
			return ociBytes + adjust;
		}

        private static int PerformCompareByte(byte[] x, byte[] y) 
        {
            int len1 = x.Length;
            int len2 = y.Length;

            bool fXShorter = (len1 < len2);
            // the smaller length of two arrays
            int len = (fXShorter) ? len1 : len2;
            int i;

            for (i = 0; i < len; i ++) {
                if (x[i] != y[i]) {
                    if (x[i] < y[i])
                        return -1;
                    else
                        return +1;
                }
            }

            if (len1 == len2)
                return 0;
            else {
                // if the remaining bytes are all zeroes, they are still equal.

                byte bZero = (byte)0;

                if (fXShorter) {
                    // array X is shorter
                    for (i = len; i < len2; i ++) {
                        if (y[i] != bZero)
                            return -1;
                    }
                }
                else {
                    // array Y is shorter
                    for (i = len; i < len1; i ++) {
                        if (x[i] != bZero)
                            return +1;
                    }
                }

                return 0;
            }
        }
		
// TODO: decide if we want to support Parse() and ToString()
/*

		private static readonly string hexDigits = "0123456789abcdef";
		
        /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.Parse"]/*' />
		public static OracleBinary Parse(string s)
		{
			if ((s.Length & 0x1) != 0)
				throw ADP.Argument("must be even-length string");

			char[]	c = s.ToCharArray();
			byte[]	b = new byte[s.Length / 2];

			for (int i = 0; i < s.Length; i += 2)
			{
				int h = hexDigits.IndexOf(Char.ToLower(c[i]));
				int l = hexDigits.IndexOf(Char.ToLower(c[i+1]));

				if (h < 0 || l < 0)
					throw ADP.Argument("must be a string with hexidecimal digits");
				
				b[i/2] = (byte)((h << 4) & l);
			}

			OracleBinary	result = new OracleBinary(b);
			
			return new OracleBinary(b);
		}

        /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.ToString"]/*' />
		public override string ToString()
		{
			if (IsNull)
				return Res.GetString(Res.SqlMisc_NullString);

			StringBuilder s = new StringBuilder();

			foreach (byte b in _value)
			{
				s.Append(String.Format("{0,-2:x2}", b));
			}
			string result = s.ToString();
			return result;
		}
*/


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Operators 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
        // Alternative method for operator +
        /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.Concat"]/*' />
        public static OracleBinary Concat(OracleBinary x, OracleBinary y)
        {
            return (x + y);
        }

        // Alternative method for operator ==
        /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.Equals1"]/*' />
        public static OracleBoolean Equals(OracleBinary x, OracleBinary y)
        {
            return (x == y);
        }

        // Alternative method for operator >
        /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.GreaterThan"]/*' />
        public static OracleBoolean GreaterThan(OracleBinary x, OracleBinary y)
        {
            return (x > y);
        }

        // Alternative method for operator >=
        /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.GreaterThanOrEqual"]/*' />
        public static OracleBoolean GreaterThanOrEqual(OracleBinary x, OracleBinary y)
        {
            return (x >= y);
        }

        // Alternative method for operator <
        /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.LessThan"]/*' />
        public static OracleBoolean LessThan(OracleBinary x, OracleBinary y)
        {
            return (x < y);
        }

        // Alternative method for operator <=
        /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.LessThanOrEqual"]/*' />
        public static OracleBoolean LessThanOrEqual(OracleBinary x, OracleBinary y)
        {
            return (x <= y);
        }

        // Alternative method for operator !=
        /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.NotEquals"]/*' />
        public static OracleBoolean NotEquals(OracleBinary x, OracleBinary y)
        {
            return (x != y);
        }

 		/// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.operatorOracleBinary"]/*' />
        public static implicit operator OracleBinary(byte[] b) 
        {
          	return new OracleBinary(b);
        }
 		
 		/// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.operatorBytearr"]/*' />
        public static explicit operator Byte[](OracleBinary x) 
        {
        	return x.Value;
        }



        /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.operator+"]/*' />
        public static OracleBinary operator+	(OracleBinary x, OracleBinary y) 
		{
			if (x.IsNull || y.IsNull)
			    return Null;

			byte[]	newValue = new byte[x._value.Length + y._value.Length];
			x._value.CopyTo(newValue, 0);
			y._value.CopyTo(newValue, x.Value.Length);

			OracleBinary	result = new OracleBinary(newValue);
			return result;
		}
        
		/// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.operatorEQ"]/*' />
        public static OracleBoolean operator==	(OracleBinary x, OracleBinary y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) == 0);
        }

		/// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.operatorGT"]/*' />
		public static OracleBoolean operator>	(OracleBinary x, OracleBinary y)
		{
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) > 0);
		}

        /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.operatorGE"]/*' />
        public static OracleBoolean operator>=	(OracleBinary x, OracleBinary y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) >= 0);
        }

        /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.operatorLT"]/*' />
        public static OracleBoolean operator<	(OracleBinary x, OracleBinary y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) < 0);
        }

        /// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.operatorLE"]/*' />
        public static OracleBoolean operator<=	(OracleBinary x, OracleBinary y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) <= 0);
        }

 		/// <include file='doc\OracleBinary.uex' path='docs/doc[@for="OracleBinary.operatorNE"]/*' />
		public static OracleBoolean operator!=	(OracleBinary x, OracleBinary y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) != 0);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\metatype.cs ===
//----------------------------------------------------------------------
// <copyright file="MetaType.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Data;

	//----------------------------------------------------------------------
	// MetaType
	//
	//	this class defines the types of data that may be bound to Oracle,
	//	along with the base CLS type and other information that is necessary
	//	for parameter binding to work properly.
	//
	sealed internal class MetaType
	{
		internal const int		LongMax			= Int32.MaxValue;
		
		private const string	N_BFILE			= "BFILE";
		private const string	N_BLOB			= "BLOB";
		private const string	N_CHAR			= "CHAR";
		private const string	N_CLOB			= "CLOB";
		private const string	N_DATE			= "DATE";
		private const string	N_FLOAT			= "FLOAT";
		private const string	N_INTEGER		= "INTEGER";
		private const string	N_INTERVALYM	= "INTERVAL YEAR TO MONTH";			// Oracle9i only
		private const string	N_INTERVALDS	= "INTERVAL DAY TO SECOND";			// Oracle9i only
		private const string	N_LONG			= "LONG";
		private const string	N_LONGRAW		= "LONG RAW";
		private const string	N_NCHAR			= "NCHAR";
		private const string	N_NCLOB			= "NCLOB";
		private const string	N_NUMBER		= "NUMBER";
		private const string	N_NVARCHAR2		= "NVARCHAR2";
		private const string	N_RAW			= "RAW";
		private const string	N_REFCURSOR		= "REF CURSOR";
		private const string	N_ROWID			= "ROWID";
		private const string	N_TIMESTAMP		= "TIMESTAMP";						// Oracle9i only
		private const string	N_TIMESTAMPLTZ	= "TIMESTAMP WITH LOCAL TIME ZONE";	// Oracle9i only
		private const string	N_TIMESTAMPTZ	= "TIMESTAMP WITH TIME ZONE";		// Oracle9i only
		private const string	N_UNSIGNEDINT	= "UNSIGNED INTEGER";
		private const string	N_VARCHAR2		= "VARCHAR2";
		


		static readonly MetaType[]	dbTypeMetaType;
		static readonly MetaType[]	oracleTypeMetaType;
		
		static internal readonly MetaType	oracleTypeMetaType_LONGVARCHAR;
		static internal readonly MetaType	oracleTypeMetaType_LONGVARRAW;
		static internal readonly MetaType	oracleTypeMetaType_LONGNVARCHAR;


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Fields
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		private readonly DbType				_dbType;
		private readonly OracleType			_oracleType;
		private readonly OCI.DATATYPE		_ociType;
		private	readonly Type				_convertToType;
		private readonly Type				_noConvertType;
		private readonly int				_bindSize;
		private readonly int				_maxBindSize;
		private readonly string				_dataTypeName;
		private readonly bool				_isCharacterType;
		private readonly bool				_isLob;
		private readonly bool				_isLong;
		private readonly bool				_usesNationalCharacterSet;


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Constructors
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		static MetaType()
		{
			// Meta data for DbTypes
			dbTypeMetaType = new MetaType[((int)DbType.StringFixedLength)+1];
			
			//																	    DbType						 OracleType						OciType				  		DataTypeName	BaseType			NoConvertType	  BindSize	MaxBindSize	UsesNationalCharacterSet)
			dbTypeMetaType[(int)DbType.AnsiString]					= new MetaType (DbType.AnsiString,			 OracleType.VarChar,			OCI.DATATYPE.VARCHAR2,		N_VARCHAR2,		typeof(string),		typeof(OracleString),	 0,	4000,		false);
			dbTypeMetaType[(int)DbType.Binary]						= new MetaType (DbType.Binary, 				 OracleType.Raw,				OCI.DATATYPE.RAW,			N_RAW,			typeof(byte[]),		typeof(OracleBinary),	 0,	2000,		false);
			dbTypeMetaType[(int)DbType.Byte]						= new MetaType (DbType.Byte, 				 OracleType.Byte,				OCI.DATATYPE.UNSIGNEDINT,	N_UNSIGNEDINT,	typeof(Byte),		typeof(Byte),			 1,	   1,		false);
			dbTypeMetaType[(int)DbType.Boolean]						= new MetaType (DbType.Boolean, 			 OracleType.Byte,				OCI.DATATYPE.UNSIGNEDINT,	N_UNSIGNEDINT,	typeof(Byte),		typeof(Byte),			 1,	   1,		false);
			dbTypeMetaType[(int)DbType.Currency]					= new MetaType (DbType.Currency, 			 OracleType.Number,				OCI.DATATYPE.VARNUM,		N_NUMBER,		typeof(Decimal),	typeof(OracleNumber),	22,	  22,		false);
			dbTypeMetaType[(int)DbType.Date]						= new MetaType (DbType.Date, 				 OracleType.DateTime,			OCI.DATATYPE.DATE,			N_DATE,			typeof(DateTime),	typeof(OracleDateTime),	 7,	   7,		false);
			dbTypeMetaType[(int)DbType.DateTime]					= new MetaType (DbType.DateTime,			 OracleType.DateTime,			OCI.DATATYPE.DATE,			N_DATE,			typeof(DateTime),	typeof(OracleDateTime),	 7,	   7,		false);
			dbTypeMetaType[(int)DbType.Decimal]						= new MetaType (DbType.Decimal,				 OracleType.Number,				OCI.DATATYPE.VARNUM,		N_NUMBER,		typeof(Decimal),	typeof(OracleNumber),	22,	  22,		false);
			dbTypeMetaType[(int)DbType.Double]						= new MetaType (DbType.Double,				 OracleType.Double,				OCI.DATATYPE.FLOAT,			N_FLOAT,		typeof(double),		typeof(double),			 8,	   8,		false);
			dbTypeMetaType[(int)DbType.Guid]						= new MetaType (DbType.Guid,				 OracleType.Raw,				OCI.DATATYPE.RAW,			N_RAW,			typeof(byte[]),		typeof(OracleBinary),	16,	  16,		false);
			dbTypeMetaType[(int)DbType.Int16]						= new MetaType (DbType.Int16,				 OracleType.Int16,				OCI.DATATYPE.INTEGER,		N_INTEGER,		typeof(short),		typeof(short),			 2,	   2,		false);
			dbTypeMetaType[(int)DbType.Int32]						= new MetaType (DbType.Int32,				 OracleType.Int32,				OCI.DATATYPE.INTEGER,		N_INTEGER,		typeof(int),		typeof(int),			 4,	   4,		false);
			dbTypeMetaType[(int)DbType.Int64]						= new MetaType (DbType.Int64,				 OracleType.Number,				OCI.DATATYPE.VARNUM,		N_NUMBER,		typeof(Decimal),	typeof(OracleNumber),	22,	  22,		false);
			dbTypeMetaType[(int)DbType.Object]						= new MetaType (DbType.Object,				 OracleType.Blob,				OCI.DATATYPE.BLOB,			N_BLOB,			typeof(object),		typeof(OracleLob),		 4,	   4,		false);
			dbTypeMetaType[(int)DbType.SByte]						= new MetaType (DbType.SByte,				 OracleType.SByte,				OCI.DATATYPE.INTEGER,		N_INTEGER,		typeof(sbyte),		typeof(sbyte),			 1,	   1,		false);
			dbTypeMetaType[(int)DbType.Single]						= new MetaType (DbType.Single,				 OracleType.Float,				OCI.DATATYPE.FLOAT,			N_FLOAT,		typeof(float),		typeof(float),			 4,	   4,		false);
			dbTypeMetaType[(int)DbType.String]						= new MetaType (DbType.String,				 OracleType.NVarChar,			OCI.DATATYPE.VARCHAR2,		N_NVARCHAR2,	typeof(string),		typeof(OracleString),	 0,	4000,		true);
			dbTypeMetaType[(int)DbType.Time]						= new MetaType (DbType.Time, 				 OracleType.DateTime,			OCI.DATATYPE.DATE,			N_DATE,			typeof(DateTime),	typeof(OracleDateTime),	 7,	   7,		false);
			dbTypeMetaType[(int)DbType.UInt16]						= new MetaType (DbType.UInt16, 				 OracleType.UInt16,				OCI.DATATYPE.UNSIGNEDINT,	N_UNSIGNEDINT,	typeof(UInt16),		typeof(UInt16),			 2,	   2,		false);
			dbTypeMetaType[(int)DbType.UInt32]						= new MetaType (DbType.UInt32, 				 OracleType.UInt32,				OCI.DATATYPE.UNSIGNEDINT,	N_UNSIGNEDINT,	typeof(UInt32),		typeof(UInt32),			 4,	   4,		false);
			dbTypeMetaType[(int)DbType.UInt64]						= new MetaType (DbType.UInt64, 				 OracleType.Number,				OCI.DATATYPE.VARNUM,	 	N_NUMBER,		typeof(Decimal),	typeof(OracleNumber),	22,	  22,		false);
			dbTypeMetaType[(int)DbType.VarNumeric]					= new MetaType (DbType.VarNumeric, 			 OracleType.Number,				OCI.DATATYPE.VARNUM,	 	N_NUMBER,		typeof(Decimal),	typeof(OracleNumber),	22,	  22,		false);
			dbTypeMetaType[(int)DbType.AnsiStringFixedLength]		= new MetaType (DbType.AnsiStringFixedLength,OracleType.Char,				OCI.DATATYPE.CHAR,			N_CHAR,			typeof(string),		typeof(OracleString),	 0,	2000,		false);
			dbTypeMetaType[(int)DbType.StringFixedLength]			= new MetaType (DbType.StringFixedLength,	 OracleType.NChar,				OCI.DATATYPE.CHAR,			N_NCHAR,		typeof(string),		typeof(OracleString),	 0,	2000,		true);

			// Meta data for OracleTypes
			oracleTypeMetaType = new MetaType[((int)OracleType.Double)+1];
			
			//																	    DbType						 OracleType						OciType				  		DataTypeName	BaseType			NoConvertType	  BindSize	MaxBindSize	UsesNationalCharacterSet)
			oracleTypeMetaType[(int)OracleType.BFile]				= new MetaType (DbType.Binary,				 OracleType.BFile,				OCI.DATATYPE.BFILE,			N_BFILE,		typeof(byte[]),		typeof(OracleBFile),	 4,	   4,		false);
			oracleTypeMetaType[(int)OracleType.Blob]				= new MetaType (DbType.Binary,				 OracleType.Blob,				OCI.DATATYPE.BLOB,			N_BLOB,			typeof(byte[]),		typeof(OracleLob),		 4,	   4,		false);
			oracleTypeMetaType[(int)OracleType.Char]				= dbTypeMetaType[(int)DbType.AnsiStringFixedLength];
			oracleTypeMetaType[(int)OracleType.Clob]				= new MetaType (DbType.AnsiString,			 OracleType.Clob,				OCI.DATATYPE.CLOB,			N_CLOB,			typeof(string),		typeof(OracleLob),		 4,	   4,		false);
			oracleTypeMetaType[(int)OracleType.Cursor]				= new MetaType (DbType.Object,				 OracleType.Cursor,				OCI.DATATYPE.RSET,			N_REFCURSOR,	typeof(object),		typeof(object),			 4,	   4,		false);
			oracleTypeMetaType[(int)OracleType.DateTime]			= dbTypeMetaType[(int)DbType.DateTime];
			oracleTypeMetaType[(int)OracleType.IntervalYearToMonth]	= new MetaType (DbType.Int32,				 OracleType.IntervalYearToMonth,OCI.DATATYPE.INT_INTERVAL_YM,N_INTERVALYM,	typeof(int),		typeof(OracleMonthSpan), 5,	   5,		false);
			oracleTypeMetaType[(int)OracleType.IntervalDayToSecond]	= new MetaType (DbType.Object,				 OracleType.IntervalDayToSecond,OCI.DATATYPE.INT_INTERVAL_DS,N_INTERVALDS,	typeof(TimeSpan),	typeof(OracleTimeSpan),	11,	  11,		false);
			oracleTypeMetaType[(int)OracleType.LongRaw]				= new MetaType (DbType.Binary,				 OracleType.LongRaw,			OCI.DATATYPE.LONGRAW,		N_LONGRAW,		typeof(byte[]),		typeof(OracleBinary),LongMax,32700,		false);
			oracleTypeMetaType[(int)OracleType.LongVarChar]			= new MetaType (DbType.AnsiString,			 OracleType.LongVarChar,		OCI.DATATYPE.LONG,			N_LONG,			typeof(string),		typeof(OracleString),LongMax,32700,		false);
			oracleTypeMetaType[(int)OracleType.NChar]				= dbTypeMetaType[(int)DbType.StringFixedLength];
			oracleTypeMetaType[(int)OracleType.NClob]				= new MetaType (DbType.String,				 OracleType.NClob,				OCI.DATATYPE.CLOB,			N_NCLOB,		typeof(string),		typeof(OracleLob),		 4,	   4,		true);
			oracleTypeMetaType[(int)OracleType.Number]				= dbTypeMetaType[(int)DbType.VarNumeric];
			oracleTypeMetaType[(int)OracleType.NVarChar]			= dbTypeMetaType[(int)DbType.String];
			oracleTypeMetaType[(int)OracleType.Raw]					= dbTypeMetaType[(int)DbType.Binary];
			oracleTypeMetaType[(int)OracleType.RowId]				= new MetaType (DbType.AnsiString,			 OracleType.RowId,				OCI.DATATYPE.VARCHAR2,		N_ROWID,		typeof(string),		typeof(OracleString), 3950,	 3950,		false);
			oracleTypeMetaType[(int)OracleType.Timestamp]			= new MetaType (DbType.DateTime,			 OracleType.Timestamp,			OCI.DATATYPE.INT_TIMESTAMP,	N_TIMESTAMP,	typeof(DateTime),	typeof(OracleDateTime),	11,	  11,		false);
			oracleTypeMetaType[(int)OracleType.TimestampLocal]		= new MetaType (DbType.DateTime,			 OracleType.TimestampLocal,		OCI.DATATYPE.INT_TIMESTAMP_LTZ,N_TIMESTAMPLTZ,typeof(DateTime),	typeof(OracleDateTime),	11,	  11,		false);
			oracleTypeMetaType[(int)OracleType.TimestampWithTZ]		= new MetaType (DbType.DateTime,			 OracleType.TimestampWithTZ,	OCI.DATATYPE.INT_TIMESTAMP_TZ,N_TIMESTAMPTZ,typeof(DateTime),	typeof(OracleDateTime),	13,	  13,		false);
			oracleTypeMetaType[(int)OracleType.VarChar]				= dbTypeMetaType[(int)DbType.AnsiString];
			oracleTypeMetaType[(int)OracleType.Byte]				= dbTypeMetaType[(int)DbType.Byte];
			oracleTypeMetaType[(int)OracleType.UInt16]				= dbTypeMetaType[(int)DbType.UInt16];
			oracleTypeMetaType[(int)OracleType.UInt32]				= dbTypeMetaType[(int)DbType.UInt32];
			oracleTypeMetaType[(int)OracleType.SByte]				= dbTypeMetaType[(int)DbType.SByte];
			oracleTypeMetaType[(int)OracleType.Int16]				= dbTypeMetaType[(int)DbType.Int16];
			oracleTypeMetaType[(int)OracleType.Int32]				= dbTypeMetaType[(int)DbType.Int32];
			oracleTypeMetaType[(int)OracleType.Float]				= dbTypeMetaType[(int)DbType.Single];
			oracleTypeMetaType[(int)OracleType.Double]				= dbTypeMetaType[(int)DbType.Double];

			oracleTypeMetaType_LONGVARCHAR 							= new MetaType (DbType.AnsiString,			 OracleType.VarChar,			OCI.DATATYPE.LONGVARCHAR,	N_VARCHAR2,		typeof(string),		typeof(OracleString),	 0,	LongMax, false);
			oracleTypeMetaType_LONGVARRAW	 						= new MetaType (DbType.Binary, 				 OracleType.Raw,				OCI.DATATYPE.LONGVARRAW,	N_RAW,			typeof(byte[]),		typeof(OracleBinary),	 0,	LongMax, false);
			oracleTypeMetaType_LONGNVARCHAR 						= new MetaType (DbType.String,				 OracleType.NVarChar,			OCI.DATATYPE.LONGVARCHAR,	N_NVARCHAR2,	typeof(string),		typeof(OracleString),	 0,	LongMax, true);
		}

		public MetaType(
					DbType			dbType,
					OracleType		oracleType,
					OCI.DATATYPE	ociType,
					string			dataTypeName,
					Type			convertToType,
					Type			noConvertType,
					int				bindSize,
					int				maxBindSize,
					bool			usesNationalCharacterSet
					)
		{
			_dbType			= dbType;
			_oracleType		= oracleType;
			_ociType		= ociType;
			_convertToType	= convertToType;
			_noConvertType	= noConvertType;
			_bindSize		= bindSize;
			_maxBindSize	= maxBindSize;
			_dataTypeName	= dataTypeName;
			_usesNationalCharacterSet		= usesNationalCharacterSet;

			switch (oracleType)
			{
			case OracleType.Char:
			case OracleType.NChar:
			case OracleType.VarChar:
			case OracleType.NVarChar:
			case OracleType.LongVarChar:
			case OracleType.Clob:
			case OracleType.NClob:
				_isCharacterType = true;
				break;
			}

			switch (oracleType)
			{
			case OracleType.LongVarChar:
			case OracleType.LongRaw:
				_isLong = true;
				break;
			}

			switch (oracleType)
			{
			case OracleType.BFile:
			case OracleType.Blob:
			case OracleType.Clob:
			case OracleType.NClob:
				_isLob = true;
				break;
			}
		}


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        internal Type BaseType 						{ get { return _convertToType; } }
        internal int BindSize 						{ get { return _bindSize; } }
        internal string DataTypeName				{ get { return _dataTypeName; } }
        internal DbType DbType						{ get { return _dbType; } }
        internal bool IsCharacterType				{ get { return _isCharacterType; } }
        internal bool IsLob							{ get { return _isLob; } }
        internal bool IsLong							{ get { return _isLong; } }
        internal bool IsVariableLength				{ get { return (0 == _bindSize || LongMax == _bindSize); } }
        internal int MaxBindSize						{ get { return _maxBindSize; } }
        internal Type NoConvertType				{ get { return _noConvertType; } }
        internal OCI.DATATYPE OciType 				{ get { return _ociType; } }
        internal OracleType OracleType				{ get { return _oracleType; } }
        internal bool UsesNationalCharacterSet	{ get { return _usesNationalCharacterSet; } }
		

		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        static internal MetaType GetDefaultMetaType() 
        {
        	return dbTypeMetaType[(int)DbType.AnsiString];
		}

        static internal MetaType GetMetaTypeForObject(object value) 
        {
            Type dataType;

            if (value is Type) 
            {
                dataType = (Type)value;                
            }
            else 
            {
                dataType = value.GetType();
            }
            
            switch (Type.GetTypeCode(dataType)) 
            {
			case TypeCode.Empty:	throw ADP.InvalidDataType(TypeCode.Empty);
			case TypeCode.DBNull:	throw ADP.InvalidDataType(TypeCode.DBNull);
			case TypeCode.Boolean:	return dbTypeMetaType[(int)DbType.Boolean];
			case TypeCode.Char:		return dbTypeMetaType[(int)DbType.Byte];
			case TypeCode.SByte:	return dbTypeMetaType[(int)DbType.SByte];
			case TypeCode.Byte:		return dbTypeMetaType[(int)DbType.Byte];
			case TypeCode.Int16:	return dbTypeMetaType[(int)DbType.Int16];
			case TypeCode.UInt16:	return dbTypeMetaType[(int)DbType.UInt16];
			case TypeCode.Int32:	return dbTypeMetaType[(int)DbType.Int32];
			case TypeCode.UInt32:	return dbTypeMetaType[(int)DbType.UInt32];
			case TypeCode.Int64:	return dbTypeMetaType[(int)DbType.Int64];
			case TypeCode.UInt64:	return dbTypeMetaType[(int)DbType.UInt64];
			case TypeCode.Single:	return dbTypeMetaType[(int)DbType.Single];
			case TypeCode.Double:	return dbTypeMetaType[(int)DbType.Double];
			case TypeCode.Decimal:	return dbTypeMetaType[(int)DbType.Decimal];
			case TypeCode.DateTime:	return dbTypeMetaType[(int)DbType.DateTime];
			case TypeCode.String:	return dbTypeMetaType[(int)DbType.AnsiString];

			case TypeCode.Object:
                if (dataType == typeof(System.Byte[]))	return dbTypeMetaType[(int)DbType.Binary];
                if (dataType == typeof(System.Guid))	return dbTypeMetaType[(int)DbType.Guid];
                if (dataType == typeof(System.Object))	throw ADP.InvalidDataTypeForValue(dataType, Type.GetTypeCode(dataType));
                
                if (dataType == typeof(OracleBFile))	return oracleTypeMetaType[(int)OracleType.BFile];
                if (dataType == typeof(OracleBinary))	return oracleTypeMetaType[(int)OracleType.Raw];
                if (dataType == typeof(OracleDateTime))	return oracleTypeMetaType[(int)OracleType.DateTime];
                if (dataType == typeof(OracleNumber))	return oracleTypeMetaType[(int)OracleType.Number];
                if (dataType == typeof(OracleString))	return oracleTypeMetaType[(int)OracleType.VarChar];

                if (dataType == typeof(OracleLob))
                {
                	OracleLob lob = (OracleLob) value;

                	switch (lob.LobType)
            		{
            		case OracleType.Blob:	return oracleTypeMetaType[(int)OracleType.Blob];
            		case OracleType.Clob:	return oracleTypeMetaType[(int)OracleType.Clob];
            		case OracleType.NClob:	return oracleTypeMetaType[(int)OracleType.NClob];
            		}
                }
                
                throw ADP.UnknownDataTypeCode(dataType, Type.GetTypeCode(dataType));
                
			default:				throw ADP.UnknownDataTypeCode(dataType, Type.GetTypeCode(dataType));
			}
        }

        static internal MetaType GetMetaTypeForType(DbType dbType) 
        {
	        if ((int)dbType < 0 || ((int)dbType) > (int)DbType.StringFixedLength)
	        	throw ADP.InvalidDbType(dbType);
	        
        	return dbTypeMetaType[(int)dbType];
		}
        static internal MetaType GetMetaTypeForType(OracleType oracleType) 
        {
	        if ((int)oracleType < 1 || (((int)oracleType)-1) > (int)OracleType.Double)
	        	throw ADP.InvalidOracleType(oracleType);
	        
        	return oracleTypeMetaType[(int)oracleType];
		}		
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oci.cs ===
//----------------------------------------------------------------------
// <copyright file="Oci.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Diagnostics;
	using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
	using System.Text;

	//----------------------------------------------------------------------
	// OCI
	//
	//	Contains the enumerations/declarations and wrapper methods for all 
	//	the Oracle Call Interface items we use in the provider
	//
	sealed internal class OCI 
	{
		// Attribute Types
		internal enum PATTR 	// parameter attributes, used for tracing only
		{
			OCI_ATTR_DATA_SIZE			= 1,	// maximum size of the data 
			OCI_ATTR_DATA_TYPE			= 2,	// the SQL type of the column/argument 
			OCI_ATTR_DISP_SIZE			= 3,	// the display size 
			OCI_ATTR_NAME				= 4,	// the name of the column/argument 
			OCI_ATTR_PRECISION			= 5,	// precision if number type 
			OCI_ATTR_SCALE				= 6,	// scale if number type 
			OCI_ATTR_IS_NULL			= 7,	// is it null ? 
		};
		
		internal enum ATTR
		{
			OCI_ATTR_FNCODE						= 1,	// the OCI function code
			OCI_ATTR_OBJECT						= 2,	// is the environment initialized in object mode
			OCI_ATTR_NONBLOCKING_MODE			= 3,	// non blocking mode
			OCI_ATTR_SQLCODE					= 4,	// the SQL verb
			OCI_ATTR_ENV						= 5,	// the environment handle
			OCI_ATTR_SERVER						= 6,	// the server handle
			OCI_ATTR_SESSION					= 7,	// the user session handle
			OCI_ATTR_TRANS						= 8,	// the transaction handle
			OCI_ATTR_ROW_COUNT					= 9,	// the rows processed so far
			OCI_ATTR_SQLFNCODE					= 10,	// the SQL verb of the statement
			OCI_ATTR_PREFETCH_ROWS				= 11,	// sets the number of rows to prefetch
			OCI_ATTR_NESTED_PREFETCH_ROWS		= 12,	// the prefetch rows of nested table
			OCI_ATTR_PREFETCH_MEMORY			= 13,	// memory limit for rows fetched
			OCI_ATTR_NESTED_PREFETCH_MEMORY		= 14,	// memory limit for nested rows
			OCI_ATTR_CHAR_COUNT					= 15,	// this specifies the bind and define size in characters
			OCI_ATTR_PDSCL						= 16,	// packed decimal scale
			OCI_ATTR_FSPRECISION				= OCI_ATTR_PDSCL,
														// fs prec for datetime data types
			OCI_ATTR_PDPRC						= 17,	// packed decimal format
			OCI_ATTR_LFPRECISION				= OCI_ATTR_PDPRC,
														// fs prec for datetime data types
			OCI_ATTR_PARAM_COUNT				= 18,	// number of column in the select list
			OCI_ATTR_ROWID						= 19,	// the rowid
			OCI_ATTR_CHARSET					= 20,	// the character set value
			OCI_ATTR_NCHAR						= 21,	// NCHAR type
			OCI_ATTR_USERNAME					= 22,	// username attribute
			OCI_ATTR_PASSWORD					= 23,	// password attribute
			OCI_ATTR_STMT_TYPE					= 24,	// statement type
			OCI_ATTR_INTERNAL_NAME				= 25,	// user friendly global name
			OCI_ATTR_EXTERNAL_NAME				= 26,	// the internal name for global txn
			OCI_ATTR_XID						= 27,	// XOPEN defined global transaction id
			OCI_ATTR_TRANS_LOCK					= 28,	//
			OCI_ATTR_TRANS_NAME					= 29,	// string to identify a global transaction
			OCI_ATTR_HEAPALLOC					= 30,	// memory allocated on the heap
			OCI_ATTR_CHARSET_ID					= 31,	// Character Set ID
			OCI_ATTR_CHARSET_FORM				= 32,	// Character Set Form
			OCI_ATTR_MAXDATA_SIZE				= 33,	// Maximumsize of data on the server
			OCI_ATTR_CACHE_OPT_SIZE				= 34,	// object cache optimal size
			OCI_ATTR_CACHE_MAX_SIZE				= 35,	// object cache maximum size percentage
			OCI_ATTR_PINOPTION					= 36,	// object cache default pin option
			OCI_ATTR_ALLOC_DURATION				= 37,	// object cache default allocation duration
			OCI_ATTR_PIN_DURATION				= 38,	// object cache default pin duration
			OCI_ATTR_FDO						= 39,	// Format Descriptor object attribute
			OCI_ATTR_POSTPROCESSING_CALLBACK	= 40,	// Callback to process outbind data
			OCI_ATTR_POSTPROCESSING_CONTEXT		= 41,	// Callback context to process outbind data
			OCI_ATTR_ROWS_RETURNED				= 42,	// Number of rows returned in current iter - for Bind handles
			OCI_ATTR_FOCBK						= 43,	// Failover Callback attribute
			OCI_ATTR_IN_V8_MODE					= 44,	// is the server/service context in V8 mode
			OCI_ATTR_LOBEMPTY					= 45,	// empty lob ?
			OCI_ATTR_SESSLANG					= 46,	// session language handle

			OCI_ATTR_VISIBILITY					= 47,	// visibility
			OCI_ATTR_RELATIVE_MSGID				= 48,	// relative message id
			OCI_ATTR_SEQUENCE_DEVIATION			= 49,	// sequence deviation

			OCI_ATTR_CONSUMER_NAME				= 50,	// consumer name
			OCI_ATTR_DEQ_MODE					= 51,	// dequeue mode
			OCI_ATTR_NAVIGATION					= 52,	// navigation
			OCI_ATTR_WAIT						= 53,	// wait
			OCI_ATTR_DEQ_MSGID					= 54,	// dequeue message id

			OCI_ATTR_PRIORITY					= 55,	// priority
			OCI_ATTR_DELAY						= 56,	// delay
			OCI_ATTR_EXPIRATION					= 57,	// expiration
			OCI_ATTR_CORRELATION				= 58,	// correlation id
			OCI_ATTR_ATTEMPTS					= 59,	// # of attempts
			OCI_ATTR_RECIPIENT_LIST				= 60,	// recipient list
			OCI_ATTR_EXCEPTION_QUEUE			= 61,	// exception queue name
			OCI_ATTR_ENQ_TIME					= 62,	// enqueue time (only OCIAttrGet)
			OCI_ATTR_MSG_STATE					= 63,	// message state (only OCIAttrGet)

			OCI_ATTR_AGENT_NAME					= 64,	// agent name
			OCI_ATTR_AGENT_ADDRESS				= 65,	// agent address
			OCI_ATTR_AGENT_PROTOCOL				= 66,	// agent protocol

			OCI_ATTR_SENDER_ID					= 68,	// sender id
			OCI_ATTR_ORIGINAL_MSGID				= 69,	// original message id

			OCI_ATTR_QUEUE_NAME					= 70,	// queue name
			OCI_ATTR_NFY_MSGID					= 71,	// message id
			OCI_ATTR_MSG_PROP					= 72,	// message properties

			OCI_ATTR_NUM_DML_ERRORS				= 73,	// num of errs in array DML
			OCI_ATTR_DML_ROW_OFFSET				= 74,	// row offset in the array

			OCI_ATTR_DATEFORMAT					= 75,	// default date format string
			OCI_ATTR_BUF_ADDR					= 76,	// buffer address
			OCI_ATTR_BUF_SIZE					= 77,	// buffer size
			OCI_ATTR_DIRPATH_MODE				= 78,	// mode of direct path operation
			OCI_ATTR_DIRPATH_NOLOG				= 79,	// nologging option
			OCI_ATTR_DIRPATH_PARALLEL			= 80,	// parallel (temp seg) option
			OCI_ATTR_NUM_ROWS					= 81,	// number of rows in column array
														// NOTE that OCI_ATTR_NUM_COLS is a column array attribute too.

			OCI_ATTR_COL_COUNT					= 82,	// columns of column array processed so far.
			OCI_ATTR_STREAM_OFFSET				= 83,	// str off of last row processed
			OCI_ATTR_SHARED_HEAPALLOC			= 84,	// Shared Heap Allocation Size

			OCI_ATTR_SERVER_GROUP				= 85,	// server group name

			OCI_ATTR_MIGSESSION					= 86,	// migratable session attribute

			OCI_ATTR_NOCACHE					= 87,	// Temporary LOBs

			OCI_ATTR_MEMPOOL_SIZE				= 88,	// Pool Size
			OCI_ATTR_MEMPOOL_INSTNAME			= 89,	// Instance name
			OCI_ATTR_MEMPOOL_APPNAME			= 90,	// Application name
			OCI_ATTR_MEMPOOL_HOMENAME			= 91,	// Home Directory name
			OCI_ATTR_MEMPOOL_MODEL				= 92,	// Pool Model (proc,thrd,both)
			OCI_ATTR_MODES						= 93,	// Modes

			OCI_ATTR_SUBSCR_NAME				= 94,	// name of subscription
			OCI_ATTR_SUBSCR_CALLBACK			= 95,	// associated callback
			OCI_ATTR_SUBSCR_CTX					= 96,	// associated callback context
			OCI_ATTR_SUBSCR_PAYLOAD				= 97,	// associated payload
			OCI_ATTR_SUBSCR_NAMESPACE			= 98,	// associated namespace

			OCI_ATTR_PROXY_CREDENTIALS			= 99,	// Proxy user credentials
			OCI_ATTR_INITIAL_CLIENT_ROLES		= 100,	// Initial client role list

			OCI_ATTR_UNK						= 101,	// unknown attribute
			OCI_ATTR_NUM_COLS					= 102,	// number of columns
			OCI_ATTR_LIST_COLUMNS				= 103,	// parameter of the column list
			OCI_ATTR_RDBA						= 104,	// DBA of the segment header
			OCI_ATTR_CLUSTERED					= 105,	// whether the table is clustered
			OCI_ATTR_PARTITIONED				= 106,	// whether the table is partitioned
			OCI_ATTR_INDEX_ONLY					= 107,	// whether the table is index only
			OCI_ATTR_LIST_ARGUMENTS				= 108,	// parameter of the argument list
			OCI_ATTR_LIST_SUBPROGRAMS			= 109,	// parameter of the subprogram list
			OCI_ATTR_REF_TDO					= 110,	// REF to the type descriptor
			OCI_ATTR_LINK						= 111,	// the database link name
			OCI_ATTR_MIN						= 112,	// minimum value
			OCI_ATTR_MAX						= 113,	// maximum value
			OCI_ATTR_INCR						= 114,	// increment value
			OCI_ATTR_CACHE						= 115,	// number of sequence numbers cached
			OCI_ATTR_ORDER						= 116,	// whether the sequence is ordered
			OCI_ATTR_HW_MARK					= 117,	// high-water mark
			OCI_ATTR_TYPE_SCHEMA				= 118,	// type's schema name
			OCI_ATTR_TIMESTAMP					= 119,	// timestamp of the object
			OCI_ATTR_NUM_ATTRS					= 120,	// number of sttributes
			OCI_ATTR_NUM_PARAMS					= 121,	// number of parameters
			OCI_ATTR_OBJID						= 122,	// object id for a table or view
			OCI_ATTR_PTYPE						= 123,	// type of info described by
			OCI_ATTR_PARAM						= 124,	// parameter descriptor
			OCI_ATTR_OVERLOAD_ID				= 125,	// overload ID for funcs and procs
			OCI_ATTR_TABLESPACE					= 126,	// table name space
			OCI_ATTR_TDO						= 127,	// TDO of a type
			OCI_ATTR_LTYPE						= 128,	// list type
			OCI_ATTR_PARSE_ERROR_OFFSET			= 129,	// Parse Error offset
			OCI_ATTR_IS_TEMPORARY				= 130,	// whether table is temporary
			OCI_ATTR_IS_TYPED					= 131,	// whether table is typed
			OCI_ATTR_DURATION					= 132,	// duration of temporary table
			OCI_ATTR_IS_INVOKER_RIGHTS			= 133,	// is invoker rights
			OCI_ATTR_OBJ_NAME					= 134,	// top level schema obj name
			OCI_ATTR_OBJ_SCHEMA					= 135,	// schema name
			OCI_ATTR_OBJ_ID						= 136,	// top level schema object id

			OCI_ATTR_DIRPATH_SORTED_INDEX		= 137,	// index that data is sorted on

			OCI_ATTR_DIRPATH_INDEX_MAINT_METHOD = 138,	// direct path index maint method (see oci8dp.h)

			// parallel load: db file, initial and next extent sizes

			OCI_ATTR_DIRPATH_FILE				= 139,	// DB file to load into
			OCI_ATTR_DIRPATH_STORAGE_INITIAL	= 140,	// initial extent size
			OCI_ATTR_DIRPATH_STORAGE_NEXT		= 141,	// next extent size

			OCI_ATTR_TRANS_TIMEOUT				= 142,	// transaction timeout
			OCI_ATTR_SERVER_STATUS				= 143,	// state of the server hdl
			OCI_ATTR_STATEMENT					= 144,	// statement txt in stmt hdl

			OCI_ATTR_NO_CACHE					= 145,	// statement should not be executed in cache
			OCI_ATTR_RESERVED_1					= 146,	// reserved for internal use
			OCI_ATTR_SERVER_BUSY				= 147,	// call in progress on server?

			OCI_ATTR_MAXCHAR_SIZE      			= 163,  // max char size of data on the server

			OCI_ATTR_ENV_CHARSET_ID             = 207,	// charset id in env
			OCI_ATTR_ENV_NCHARSET_ID            = 208,	// ncharset id in env
			OCI_ATTR_ENV_UTF16                  = 209,	// is env in utf16 mode?

			OCI_ATTR_DATA_SIZE			= 1,	// maximum size of the data 
			OCI_ATTR_DATA_TYPE			= 2,	// the SQL type of the column/argument 
			OCI_ATTR_DISP_SIZE			= 3,	// the display size 
			OCI_ATTR_NAME				= 4,	// the name of the column/argument 
			OCI_ATTR_PRECISION			= 5,	// precision if number type 
			OCI_ATTR_SCALE				= 6,	// scale if number type 
			OCI_ATTR_IS_NULL			= 7,	// is it null ? 

		};


		// CharsetID for 2 byte unicode...
		internal static readonly short OCI_UCS2ID	= 1000;
		internal static readonly short OCI_UTF16ID	= 1000;
		
		// CHAR/NCHAR/VARCHAR2/NVARCHAR2/CLOB/NCLOB char set "form" information
		internal enum CHARSETFORM : byte 
		{
			SQLCS_IMPLICIT	= 1,	// for CHAR, VARCHAR2, CLOB w/o a specified set
			SQLCS_NCHAR		= 2,	// for NCHAR, NCHAR VARYING, NCLOB
			SQLCS_EXPLICIT	= 3,	// for CHAR, etc, with "CHARACTER SET ..." syntax
			SQLCS_FLEXIBLE	= 4,	// ffor PL/SQL "flexible" parameters
			SQLCS_LIT_NULL	= 5,	// for typecheck of NULL and empty_clob() lits
		};

		// Credential Types
		internal enum CRED 
		{
			OCI_CRED_RDBMS	= 1,	// database username/password
			OCI_CRED_EXT	= 2,	// externally provided credentials
			OCI_CRED_PROXY	= 3,	// proxy authentication
		};
	
		// Data Types
		internal enum DATATYPE : short 
		{
			VARCHAR2	= 1,
			NUMBER      = 2,
			INTEGER     = 3,
			FLOAT       = 4,
			STRING		= 5,
			VARNUM		= 6,
			LONG        = 8,
//			VARCHAR	 	= 9,			// deprecated -- use VARCHAR2
			ROWID       = 11,
			DATE        = 12,
			VARRAW      = 15,
			RAW         = 23,
			LONGRAW     = 24,
			UNSIGNEDINT = 68,
			LONGVARCHAR	= 94,
			LONGVARRAW	= 95,
			CHAR        = 96,
			CHARZ       = 97,
			CURSOR		= 102,
			ROWID_DESC	= 104,			// New in Oracle 8 -- rowid descriptor
			MLSLABEL	= 105,

			USERDEFINED	= 108,			// New in Oracle 8
			REF			= 110,			// New in Oracle 8
			CLOB		= 112,			// New in Oracle 8
			BLOB		= 113,			// New in Oracle 8
			BFILE		= 114,			// New in Oracle 8
			RSET		= 116,          // New in Oracle 8 used instead of CURSOR for result sets

			OCIDATE		= 156,

			INT_TIMESTAMP		= 180,	// New in Oracle 9i -- internal representation
			INT_TIMESTAMP_TZ	= 181,	// New in Oracle 9i -- internal representation
			INT_TIMESTAMP_LTZ	= 231,	// New in Oracle 9i -- internal representation
			INT_INTERVAL_YM		= 182,	// New in Oracle 9i -- internal representation
			INT_INTERVAL_DS		= 183,	// New in Oracle 9i -- internal representation
			
			ANSIDATE	= 184,			// New in Oracle 9i
			TIME		= 185,			// New in Oracle 9i
			TIME_TZ		= 186,			// New in Oracle 9i
			TIMESTAMP	= 187,			// New in Oracle 9i
			TIMESTAMP_TZ= 188,			// New in Oracle 9i
			INTERVAL_YM	= 189,			// New in Oracle 9i
			INTERVAL_DS	= 190,			// New in Oracle 9i
			TIMESTAMP_LTZ=232,			// New in Oracle 9i

			UROWID		= 208,			// New in Oracle 8.1.6
			PLSQLRECORD	= 250,
			PLSQLTABLE	= 251,
		};

		// return value(s) for OCIDateCheck valid argument
		[Flags()]
		internal enum DATEVALIDFLAG
		{
			OCI_DATE_INVALID_DAY			= 0x1,			// Bad day
			OCI_DATE_DAY_BELOW_VALID		= 0x2,			// Bad DAy Low/high bit (1=low)
			OCI_DATE_INVALID_MONTH			= 0x4,			// Bad MOnth
			OCI_DATE_MONTH_BELOW_VALID		= 0x8,			// Bad MOnth Low/high bit (1=low)
			OCI_DATE_INVALID_YEAR			= 0x10,			// Bad YeaR
			OCI_DATE_YEAR_BELOW_VALID		= 0x20,			// Bad YeaR Low/high bit (1=low)
			OCI_DATE_INVALID_HOUR			= 0x40,			// Bad HouR
			OCI_DATE_HOUR_BELOW_VALID		= 0x80,			// Bad HouR Low/high bit (1=low)
			OCI_DATE_INVALID_MINUTE			= 0x100,		// Bad MiNute
			OCI_DATE_MINUTE_BELOW_VALID		= 0x200,		// Bad MiNute Low/high bit (1=low)
			OCI_DATE_INVALID_SECOND			= 0x400,		// Bad SeCond
			OCI_DATE_SECOND_BELOW_VALID		= 0x800,		// Bad second Low/high bit (1=low)
			OCI_DATE_DAY_MISSING_FROM_1582	= 0x1000,		// Day is one of those "missing" from 1582
			OCI_DATE_YEAR_ZERO				= 0x2000,		// Year may not equal zero
			OCI_DATE_INVALID_FORMAT			= 0x8000,		// Bad date format input
		};

		// Object Durations
		internal enum DURATION : short 
		{
			OCI_DURATION_BEGIN		= 10,						// beginning sequence of duration
			OCI_DURATION_NULL		= (OCI_DURATION_BEGIN-1),	// null duration
			OCI_DURATION_DEFAULT	= (OCI_DURATION_BEGIN-2),	// default
			OCI_DURATION_NEXT 		= (OCI_DURATION_BEGIN-3),	// next special duration
			OCI_DURATION_SESSION	= (OCI_DURATION_BEGIN),		// the end of user session
			OCI_DURATION_TRANS		= (OCI_DURATION_BEGIN+1),	// the end of user transaction

			OCI_DURATION_CALL		= (OCI_DURATION_BEGIN+2),	// the end of user client/server call
			OCI_DURATION_STATEMENT	= (OCI_DURATION_BEGIN+3),
			OCI_DURATION_CALLOUT 	= (OCI_DURATION_BEGIN+4),	// This is to be used only during callouts.  It is similar to that of OCI_DURATION_CALL, but lasts only for the duration of a callout. Its heap is from PGA
			OCI_DURATION_LAST		= OCI_DURATION_CALLOUT, 	// last of predefined duration
		};		

		// Scrollable Cursor Options
		internal enum FETCH : short
		{
			OCI_FETCH_NEXT		= 0x02,	// next row
			OCI_FETCH_FIRST		= 0x04,	// first row of the result set
			OCI_FETCH_LAST		= 0x08,	// the last row of the result set
			OCI_FETCH_PRIOR		= 0x10,	// the previous row relative to current
			OCI_FETCH_ABSOLUTE	= 0x20,	// absolute offset from first
			OCI_FETCH_RELATIVE	= 0x40,	// offset relative to current
		};

		// Handle and Descriptor Types
		internal enum HTYPE
		{
			OCI_HTYPE_ENV					= 1,	// environment handle
			OCI_HTYPE_ERROR					= 2,	// error handle
			OCI_HTYPE_SVCCTX				= 3,	// service handle
			OCI_HTYPE_STMT					= 4,	// statement handle
			OCI_HTYPE_BIND					= 5,	// bind handle
			OCI_HTYPE_DEFINE				= 6,	// define handle
			OCI_HTYPE_DESCRIBE				= 7,	// describe handle
			OCI_HTYPE_SERVER				= 8,	// server handle
			OCI_HTYPE_SESSION				= 9,	// authentication handle
			OCI_HTYPE_TRANS					= 10,	// transaction handle
			OCI_HTYPE_COMPLEXOBJECT			= 11,	// complex object retrieval handle
			OCI_HTYPE_SECURITY				= 12,	// security handle
			OCI_HTYPE_SUBSCRIPTION			= 13,	// subscription handle
			OCI_HTYPE_DIRPATH_CTX			= 14,	// direct path context
			OCI_HTYPE_DIRPATH_COLUMN_ARRAY	= 15,	// direct path column array
			OCI_HTYPE_DIRPATH_STREAM		= 16,	// direct path stream
			OCI_HTYPE_PROC					= 17,	// process handle

			// descriptor values range from 50 - 255
			OCI_DTYPE_FIRST					= 50,	// start value of descriptor type 
			OCI_DTYPE_LOB					= 50,	// lob  locator 
			OCI_DTYPE_SNAP					= 51,	// snapshot descriptor 
			OCI_DTYPE_RSET					= 52,	// result set descriptor 
			OCI_DTYPE_PARAM					= 53,	// a parameter descriptor obtained from ocigparm 
			OCI_DTYPE_ROWID					= 54,	// rowid descriptor 
			OCI_DTYPE_COMPLEXOBJECTCOMP		= 55,	// complex object retrieval descriptor 
			OCI_DTYPE_FILE					= 56,	// File Lob locator 
			OCI_DTYPE_AQENQ_OPTIONS			= 57,	// enqueue options 
			OCI_DTYPE_AQDEQ_OPTIONS			= 58,	// dequeue options 
			OCI_DTYPE_AQMSG_PROPERTIES		= 59,	// message properties 
			OCI_DTYPE_AQAGENT				= 60,	// aq agent 
			OCI_DTYPE_LOCATOR				= 61,	// LOB locator 
			OCI_DTYPE_INTERVAL_YM			= 62,	// Interval year month 
			OCI_DTYPE_INTERVAL_DS			= 63,	// Interval day second 
			OCI_DTYPE_AQNFY_DESCRIPTOR		= 64,	// AQ notify descriptor 
			OCI_DTYPE_DATE					= 65,	// Date 
			OCI_DTYPE_TIME					= 66,	// Time 
			OCI_DTYPE_TIME_TZ				= 67,	// Time with timezone 
			OCI_DTYPE_TIMESTAMP				= 68,	// Timestamp 
			OCI_DTYPE_TIMESTAMP_TZ			= 69,	// Timestamp with timezone 
			OCI_DTYPE_TIMESTAMP_LTZ			= 70,	// Timestamp with local tz 
			OCI_DTYPE_UCB					= 71,	// user callback descriptor 
			OCI_DTYPE_LAST					= 71,	// last value of a descriptor type 
		};

		// Values for Oracle's indicator variable
		internal enum INDICATOR
		{
			TOOBIG	= -2,		// length of column value is more than 64K
			ISNULL	= -1,		// Column value is NULL
			OK		= 0,		// Column is not null is not truncated
		};

		// Values for OCILobFreeBuffer
		internal enum LOB_BUFFER
		{
			OCI_LOB_BUFFER_FREE = 1,
			OCI_LOB_BUFFER_NOFREE = 2,
		};

		// Various Modes
		[Flags()]
		internal enum MODE 
		{
			OCI_DEFAULT		= 0x00,		// the default value for parameters	and	attributes

			// Modes for OCIEnvInit / OCIEnvCreate 
			OCI_THREADED	= 0x01,		// the application is in threaded environment
			OCI_OBJECT		= 0x02,		// the application is in object	environment
			OCI_EVENTS		= 0x04,		// the application is enabled for events
//			OCI_RESERVED1	= 0x08,		// Reserved	for	internal use
			OCI_SHARED		= 0x10,		// the application is in shared	mode
//			OCI_RESERVED2	= 0x20,		// Reserved	for	internal use
		
			OCI_NO_UCB		= 0x40,		// No user callback	called during init (OCIEnvCreate only)
			OCI_NO_MUTEX	= 0x80,		// the environment handle will not be protected	by a mutex internally (OCIEnvCreate only)

			OCI_SHARED_EXT	= 0x100,	// Used	for	shared forms
			OCI_CACHE		= 0x200,	// used	by iCache
			OCI_NO_CACHE	= 0x400,	// turn	off	iCache mode, used by iCache
			OCI_UTF16       = 0x4000,	// mode for all UTF16 metadata

			// Authentication Modes
			OCI_MIGRATE		= 0x0001,	// migratable auth context
			OCI_SYSDBA		= 0x0002,	// for SYSDBA authorization
			OCI_SYSOPER		= 0x0004,	// for SYSOPER authorization
			OCI_PRELIM_AUTH	= 0x0008,	// for preliminary authorization
			OCIP_ICACHE		= 0x0010,	// Private OCI cache mode to notify cache db

			// Execution Modes	
			OCI_BATCH_MODE				= 0x01,		// batch the oci statement for execution
			OCI_EXACT_FETCH				= 0x02,		// fetch the exact rows specified
			OCI_KEEP_FETCH_STATE		= 0x04,		// unused
			OCI_SCROLLABLE_CURSOR		= 0x08,		// cursor scrollable
			OCI_DESCRIBE_ONLY			= 0x10,		// only describe the statement
			OCI_COMMIT_ON_SUCCESS		= 0x20,		// commit, if successful execution
			OCI_NON_BLOCKING			= 0x40,		// non-blocking
			OCI_BATCH_ERRORS			= 0x80,		// batch errors in array dmls
			OCI_PARSE_ONLY				= 0x100,	// only parse the statement
//			OCI_EXACT_FETCH_RESERVED_1	= 0x200,	// reserved for internal use
			OCI_SHOW_DML_WARNINGS		= 0x400,	// return OCI_SUCCESS_WITH_INFO for del/upd with no where clause

			// Bind and Define Options
			OCI_SB2_IND_PTR				= 0x01,		// unused
			OCI_DATA_AT_EXEC			= 0x02,		// data at execute time
			OCI_DYNAMIC_FETCH			= 0x02,		// fetch dynamically
			OCI_PIECEWISE				= 0x04,		// piecewise DMLs or fetch
//			OCI_DEFINE_RESERVED_1		= 0x08,		// reserved for internal use
//			OCI_BIND_RESERVED_2			= 0x10,		// reserved for internal use
//			OCI_DEFINE_RESERVED_2		= 0x20,		// reserved for internal use
		};

		// LOB Open Modes
		internal enum LOBMODE : byte 
		{
			// FILE open modes
			OCI_FILE_READONLY = 1,

			// LOB open modes
			OCI_LOB_READONLY = 1,
			OCI_LOB_READWRITE = 2,
		};

		// Temporary LOB Types
		internal enum LOBTYPE : byte 
		{
			OCI_TEMP_BLOB = 1,
			OCI_TEMP_CLOB = 2,
		};

		// Piece Definitions
		internal enum PIECE : byte 
		{
			OCI_ONE_PIECE		= 0, 			// one piece
			OCI_FIRST_PIECE		= 1, 			// the first piece
			OCI_NEXT_PIECE		= 2, 			// the next of many pieces
			OCI_LAST_PIECE		= 3, 			// the last piece
		};

		// Error Return Values
		internal enum RETURNCODE 
		{
			OCI_CONTINUE			= -24200,	// Continue with the body of the OCI function
			OCI_STILL_EXECUTING		= -3123,	// OCI would block error
			OCI_INVALID_HANDLE		= -2,		// maps to SQL_INVALID_HANDLE
			OCI_ERROR				= -1,		// maps to SQL_ERROR
			OCI_SUCCESS				= 0,		// maps to SQL_SUCCESS of SAG CLI
			OCI_SUCCESS_WITH_INFO	= 1,		// maps to SQL_SUCCESS_WITH_INFO
			OCI_NEED_DATA			= 99,		// maps to SQL_NEED_DATA
			OCI_NO_DATA				= 100,		// maps to SQL_NO_DATA
			OCI_RESERVED_FOR_INT_USE= 200,		// reserved for internal use
		};

		// Sign Types for OCINumberToInt
		internal enum SIGN 
		{
			OCI_NUMBER_UNSIGNED	= 0, // Unsigned type
			OCI_NUMBER_SIGNED	= 2, // Signed type
		};
		
		// Statement Types
		internal enum STMT 
		{
			OCI_STMT_SELECT		= 1,	// select statement 
			OCI_STMT_UPDATE		= 2,	// update statement 
			OCI_STMT_DELETE		= 3,	// delete statement 
			OCI_STMT_INSERT		= 4,	// Insert Statement 
			OCI_STMT_CREATE		= 5,	// create statement 
			OCI_STMT_DROP		= 6,	// drop statement 
			OCI_STMT_ALTER		= 7,	// alter statement 
			OCI_STMT_BEGIN		= 8,	// begin ... (pl/sql statement)
			OCI_STMT_DECLARE	= 9,	// declare .. (pl/sql statement ) 
		};

		// Parsing Syntax Types
		internal enum SYNTAX 
		{
			OCI_NTV_SYNTAX	= 1, // Use what so ever is the native lang of server
			OCI_V7_SYNTAX	= 2, // V815 language - for backwards compatibility
			OCI_V8_SYNTAX	= 3, // V815 language - for backwards compatibility
		};

		sealed internal class Callback
		{

		//----------------------------------------------------------------------
		// OCICallbackDefine
		//
		//	Callback routine for Dynamic Binding column values from Oracle: save
		//	data Oracle provides in a buffer
		//
		internal delegate int OCICallbackDefine(
						IntPtr		octxp,
						IntPtr		defnp,
						int			iter,
						IntPtr	bufpp,	// dvoid**
						IntPtr	alenp,	// ub4**
						IntPtr piecep,	// ub1*
						IntPtr	indp,	// dvoid**
						IntPtr	rcodep	// ub2**
						);
		
		}

		static int 	_clientVersion = 0;
#if !USEORAMTS
		static bool	_newMtxOciInstalled;
#endif //!USEORAMTS
		static bool	_newMtxOci8Installed;

		// To fix bug 87290, we need to do a Pre-LoadLibrary for MTxOCI8.dll, but we want
		// to make sure that we release the reference that the LoadLibrary call creates
		// when our assembly is unloaded.  We solve that by creating a static variable
		// of a class that will hold on to the hModule returned and call FreeLibrary when
		// it's Finalized.
		sealed internal class ModuleReference 
		{
			private HandleRef _hModule;
			
			public ModuleReference(IntPtr hModule) 
			{
				_hModule = new HandleRef(this, hModule);
			}

			~ModuleReference() 
			{
				IntPtr hModule = _hModule.Handle;
				if (IntPtr.Zero != hModule)
					SafeNativeMethods.FreeLibrary(hModule);
			}
		}			

		static private ModuleReference MTxOCI8_Reference;	// Static reference -- will be finalized when the app is unloaded.

        private static string GetRuntimeDirectory()
    	{
    		string value = null;
    		
            try 
            {
	            (new FileIOPermission(PermissionState.Unrestricted)).Assert();
	            try 
	            { 
					value = System.Runtime.InteropServices.RuntimeEnvironment.GetRuntimeDirectory();
	            }
	            finally 
	            {
	                CodeAccessPermission.RevertAssert();
	            }
            }
            catch // Prevent exception filters from running in our space
            {
            	throw;
            }
            return value;
    	}
		
		static OCI()
		{	
			int clientVersion = 0;

			// To fix bug 87290, we need to Pre-LoadLibrary the MTxOCI8.dll from the runtime
			// directory so that it can be found by PInvoke when our component is GAC'd
			StringBuilder sb = new StringBuilder(GetRuntimeDirectory());
			sb.Append(@"\");
			sb.Append(ExternDll.MtxOci8Dll);

			string	pathToMTxOci8Dll = sb.ToString();

			IntPtr hModule = SafeNativeMethods.LoadLibraryExA(pathToMTxOci8Dll, IntPtr.Zero, 0);

			if (IntPtr.Zero == hModule)
				_newMtxOci8Installed = false;
			else
			{
				MTxOCI8_Reference = new ModuleReference(hModule);
	
				try {
					UnsafeNativeMethods.MTxOciGetOracleVersion(ref clientVersion);
					_newMtxOci8Installed = true;
				}
				catch (DllNotFoundException e)
				{
					ADP.TraceException(e);
	 				
					// MTxOci8 wasn't found, so we must not have gotten it installed.  Since 
					// this may be a common case, we'll just presume that they have Oracle8i
					// installed.
					clientVersion = 81;
				}
	#if EVERETT
				catch (EntryPointNotFoundException e)
				{
					ADP.TraceException(e);
	 				
					// MTxOciGetOracleVersion wasn't found, so we must have loaded the beta 
					// version instead of the release version.  We want to tell the user that
					// this is the case, however, so they can correct it.
					throw ADP.PleaseUninstallTheBeta();
				}
	#endif //EVERETT
			}
				
			if (81 > clientVersion)
				throw ADP.BadOracleClientVersion();

			_clientVersion = clientVersion;

#if !USEORAMTS
			int mtxOciVersion = 0;

			UnsafeNativeMethods.MTxOciGetVersion(out mtxOciVersion);

			_newMtxOciInstalled = (1 < mtxOciVersion);
#endif //!USEORAMTS
		}

		static internal bool ClientVersionAtLeastOracle9i
		{
			get { return 90 <= _clientVersion; }
		}

#if !USEORAMTS
		static internal bool IsNewMtxOciInstalled
		{
			get { return _newMtxOciInstalled; }
		}
#endif //!USEORAMTS

		static internal bool IsNewMtxOci8Installed
		{
			get { return _newMtxOci8Installed; }
		}
	};
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\ociloblocator.cs ===
//----------------------------------------------------------------------
// <copyright file="OciLobLocator.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Data.SqlTypes;
	using System.Diagnostics;
	using System.Globalization;
	using System.IO;
	using System.Runtime.InteropServices;
	using System.Text;
	using System.Threading;

	sealed internal class OciLobLocator
	{
		private OracleConnection	_connection;			// the connection the lob is attached to
		private int					_connectionCloseCount;	// The close count of the connection; used to decide if we're zombied
        private OracleType			_lobType;				// the underlying data type of the LOB locator
		private OciHandle			_descriptor;			// the lob/file descriptor.
		private int					_cloneCount;			// the number of clones of this object -- used to know when we can close the lob/bfile.
		private int					_openMode;				// zero when not opened, otherwise, it's the value of OracleLobOpenMode

		internal OciLobLocator(OracleConnection connection, OracleType lobType)
		{
			_connection				= connection;
 			_connectionCloseCount	= connection.CloseCount;
			_lobType 				= lobType;
 			_cloneCount				= 1;
		
			switch (lobType)
			{
			case OracleType.Blob:
			case OracleType.Clob:
			case OracleType.NClob:
				_descriptor = new OciLobDescriptor(connection.EnvironmentHandle);
				break;
			case OracleType.BFile:
				_descriptor = new OciFileDescriptor(connection.EnvironmentHandle);
				break;

			default:
				Debug.Assert(false, "Invalid lobType");
				break;
			}
		}

		internal OracleConnection Connection 
		{
			get { return _connection; }
		}

		internal bool ConnectionIsClosed 
		{
			//	returns TRUE when the parent connection object has been closed
			get { return (null == _connection) || (_connectionCloseCount != _connection.CloseCount); }
		}
		
		internal OciHandle ErrorHandle 
		{
			//	Every OCI call needs an error handle, so make it available 
			//	internally.
			get { return Connection.ErrorHandle; }
		}

		internal HandleRef Handle
		{
			get { return Descriptor.Handle; }
		}

		internal OciHandle Descriptor
		{
			get { return _descriptor; }
		}

		public OracleType LobType
		{
			get { return _lobType; }
		}
		
		internal OciHandle ServiceContextHandle
		{
			//	You need to provide the service context handle to things like the
			//	OCI execute call so a statement handle can be associated with a
			//	connection.  Better make it available internally, then.

			get { return Connection.ServiceContextHandle; }
		}

		internal OciLobLocator Clone()
		{
			Interlocked.Increment(ref _cloneCount);
			return this;
		}
		
		internal void Dispose()
		{
			int cloneCount = Interlocked.Decrement(ref _cloneCount);

			if (0 == cloneCount)
 			{
				if (0 != _openMode && !ConnectionIsClosed)
				{
	 				ForceClose();
				}
				OciHandle.SafeDispose(ref _descriptor);
				GC.KeepAlive(this);
				_connection = null;
			}
		}

		internal void ForceClose()
		{
			if (0 != _openMode)
			{
				int rc = TracedNativeMethods.OCILobClose(
										ServiceContextHandle,
										ErrorHandle,
										Descriptor
										);
				if (0 != rc)
					Connection.CheckError(ErrorHandle, rc);

				_openMode = 0;
			}
		}

		internal void ForceOpen()
		{
			if (0 != _openMode)
			{
				int rc = TracedNativeMethods.OCILobOpen(
											ServiceContextHandle,
											ErrorHandle,
											Descriptor,
											(byte)_openMode
											);
				if (0 != rc)
				{
					_openMode = 0; // failure means we didn't really open it.
					Connection.CheckError(ErrorHandle, rc);
				}
			}
		}
		
		internal void Open (OracleLobOpenMode mode)
		{
			OracleLobOpenMode openMode = (OracleLobOpenMode)Interlocked.CompareExchange(ref _openMode, (int)mode, 0);
			if (0 == openMode) 
				ForceOpen();
#if EVERETT
			else if (mode != openMode)
				throw ADP.CannotOpenLobWithDifferentMode(mode, openMode);
#endif //EVERETT
		}
		
		internal static void SafeDispose(ref OciLobLocator locator)
		{
			//	Safely disposes of the handle (even if it is already null) and
			//	then nulls it out.
			if (null != locator)
				locator.Dispose();
			
			locator = null;
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\ocienlistcontext.cs ===
//----------------------------------------------------------------------
// <copyright file="OciEnlistContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

#if USEORAMTS

namespace System.Data.OracleClient
{
	using System;
	using System.Diagnostics;
	using System.EnterpriseServices;
	using System.Runtime.InteropServices;

	sealed internal class OciEnlistContext
	{
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Fields 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
		private IntPtr			_enlistContext;
		private OciHandle		_serviceContextHandle;
		private ITransaction	_transaction;
	
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Constructors 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
		internal OciEnlistContext(
			string		userName,
			string		password,
			string		serverName,
			OciHandle	serviceContextHandle,
			OciHandle	errorHandle)
		{
			_enlistContext = IntPtr.Zero;
			_serviceContextHandle = serviceContextHandle;
			
			int rc = 0;

			try {
				rc = TracedNativeMethods.OraMTSEnlCtxGet(userName, password, serverName, _serviceContextHandle, errorHandle, 0, out _enlistContext);
			}
			catch (DllNotFoundException e)
			{
				ADP.DistribTxRequiresOracleServicesForMTS(e);
			}

			if (0 != rc)
				OracleException.Check(errorHandle, rc);
		}
		
		~OciEnlistContext()
		{
			Dispose(false);
		}
        

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		internal HandleRef Handle
		{
			get { 
				HandleRef value = new HandleRef(this, _enlistContext);
				GC.KeepAlive(this);
				return value; 
			}
		}

		internal bool IsAlive
		{
			//	Determines whether the handle is alive enough that we can do
			//	something with it.  Basically, if the chain of parents are alive,
			//	we're OK.  When the entire connection, command and data reader go
			//	out of scope at the same time, there is no control over the order
			//	in which they're finalized, so we might have an environment handle
			//	that has already been freed.
			//
			// TODO: consider keeping the environment handle instead of the parent, since it appears that we only need to check it, and we don't really want to walk up the chain all the time.
			//
			get 
			{
				// If we're not an environment handle and our parent is dead, then
				// we can automatically dispose of ourself, because we're dead too.
				if (!_serviceContextHandle.IsAlive)
					Dispose(true);

				bool value = (IntPtr.Zero != _enlistContext);
				GC.KeepAlive(this);
				return value; 
			}
		}


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		internal void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}
		private void Dispose(bool disposing)
		{
			HandleRef	localEnlistContextHandle = Handle;
			OciHandle	localParentHandle = _serviceContextHandle;

			try 
			{
				try 
				{
					_serviceContextHandle = null;
					_enlistContext = IntPtr.Zero;
				}
				finally
				{
					// BIND, DEFINE and PARAM handles cannot be freed; they go away automatically
					// (but you'll have to ask Oracle how...)
					if (IntPtr.Zero != localEnlistContextHandle.Handle)
					{
						if (null != localParentHandle && localParentHandle.IsAlive)
						{
							// DEVNOTE: the finalizer creates a race condition: it is possible
							//			for both this handle and it's parent to be finalized
							//			concurrently.  If the parent handle is freed before we
							//			free this handle, Oracle will AV when we actually get
							//			to free it.  We put a try/catch around this to avoid
							//			the unhandled AV in the race condition, but we can't do
							//			much about cdb, which always breaks on the AV because 
							//			it thinks its an unhandled exception, even though it's
							//			being handled in managed code.
							try
							{
								TracedNativeMethods.OraMTSEnlCtxRel(localEnlistContextHandle);
							}
							catch (NullReferenceException e)
							{
								ADP.TraceException(e);
							}
						}
					}
				}
			}
            catch // Prevent exception filters from running in our space
        	{
	        	throw;
        	}
			GC.KeepAlive(this);
		}

		internal void Join(ITransaction transaction)
		{
			int rc = TracedNativeMethods.OraMTSJoinTxn(Handle, transaction);
				
			if (0 != rc)
				OracleException.Check(rc);

			_transaction = transaction;
		}
		
		internal static void SafeDispose(ref OciEnlistContext ociEnlistContext)
		{
			//	Safely disposes of the handle (even if it is already null) and
			//	then nulls it out.
			if (null != ociEnlistContext)
				ociEnlistContext.Dispose();
			
			ociEnlistContext = null;
		}
	}
}
#endif //USEORAMTS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracleboolean.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleBoolean.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Diagnostics;
	using System.Runtime.InteropServices;
	using System.Globalization;

	//----------------------------------------------------------------------
	// OracleBoolean
	//
	//	This class implements support for comparisons of other Oracle type
	//	classes that may be null; there is no Boolean data type in oracle
	//	that this maps too; it's merely a convenience class.
	//
    /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean"]/*' />
    [StructLayout(LayoutKind.Sequential)]
	public struct OracleBoolean : IComparable
	{
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Fields
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
        private byte _value;		// value: 1 (true), 2 (false), 0 (unknown/Null) (see below)

        private const byte x_Null   = 0;
        private const byte x_True   = 1;
        private const byte x_False  = 2;

        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.False"]/*' />
        public static readonly OracleBoolean False = new OracleBoolean(false);

        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.Null"]/*' />
        public static readonly OracleBoolean Null = new OracleBoolean(0, true);

        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.One"]/*' />
        public static readonly OracleBoolean One = new OracleBoolean(1);
	
        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.True"]/*' />
        public static readonly OracleBoolean True = new OracleBoolean(true);

        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.Zero"]/*' />
        public static readonly OracleBoolean Zero = new OracleBoolean(0);

		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Constructors
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		// Construct a non-null boolean from a boolean value
        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.OracleBoolean1"]/*' />
		public OracleBoolean(bool value)
		{	
            this._value = (byte)(value ? x_True : x_False);
		}

		// Construct a non-null boolean from a specific value
        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.OracleBoolean2"]/*' />
        public OracleBoolean(int value) : this(value, false) {}

 		// Construct a potentially null boolean from a specific value
 		private OracleBoolean(int value, bool isNull) 
        {
            if (isNull)
                this._value = x_Null;
            else
                this._value = (value != 0) ? x_True : x_False;
        }

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        private byte ByteValue
        {
        	get { return _value; }
        }
        
        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.IsFalse"]/*' />
		public bool IsFalse 
		{
			get { return _value == x_False; }
		}

        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.IsNull"]/*' />
		public bool IsNull 
		{
			get { return _value == x_Null; }
		}

        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.IsTrue"]/*' />
		public bool IsTrue 
		{
			get { return _value == x_True; }
		}

        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.Value"]/*' />
        public bool Value 
        {
            get
            {
                switch (_value) 
            	{
                case x_True:
                    return true;

                case x_False:
                    return false;

                default:
	    			throw ADP.DataIsNull();
                }
            }           
        }


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		//----------------------------------------------------------------------
		// IComparable.CompareTo()
		//
        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.CompareTo"]/*' />
		public int CompareTo(
		  	object obj
			)
		{
            if (obj is OracleBoolean) 
            {
                OracleBoolean i = (OracleBoolean)obj;

                // If both Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return i.IsNull ? 0  : -1;
                else if (i.IsNull)
                    return 1;

                if (this.ByteValue < i.ByteValue) return -1;
                if (this.ByteValue > i.ByteValue) return 1;
                return 0;
            }
			throw ADP.Argument();
		}

		//----------------------------------------------------------------------
		// Object.Equals()
		//
 		/// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.Equals"]/*' />
        public override bool Equals(object value) 
        {
            if (value is OracleBoolean)
            {
	            OracleBoolean i = (OracleBoolean)value;

	            if (i.IsNull || IsNull)
	                return (i.IsNull && IsNull);
	            else
	                return (this == i).Value;
            }
			return false;
       }

		//----------------------------------------------------------------------
		// Object.GetHashCode()
		//
 		/// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.GetHashCode"]/*' />
        public override int GetHashCode() 
        {
            return IsNull ? 0 : _value.GetHashCode();
        }

		//----------------------------------------------------------------------
		// Object.Parse()
		//
        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.Parse"]/*' />
		public static OracleBoolean Parse(string s)
		{
            OracleBoolean ret;
            try 
            {
                ret = new OracleBoolean(Int32.Parse(s));
            }
            catch (Exception)
            {
                ret = new OracleBoolean(Boolean.Parse(s));
            }
            return ret;
		}
		
		//----------------------------------------------------------------------
		// Object.ToString()
		//
        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.ToString"]/*' />
		public override string ToString()
		{
			if (IsNull)
				return Res.GetString(Res.SqlMisc_NullString);
			
			return Value.ToString(CultureInfo.CurrentCulture);
		}


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Operators 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
        // Alternative method for operator &
        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.And"]/*' />
        public static OracleBoolean And(OracleBoolean x, OracleBoolean y)
        {
            return (x & y);
        }

        // Alternative method for operator ==
        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.Equals1"]/*' />
        public static OracleBoolean Equals(OracleBoolean x, OracleBoolean y)
        {
            return (x == y);
        }

        // Alternative method for operator !=
        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.NotEquals"]/*' />
        public static OracleBoolean NotEquals(OracleBoolean x, OracleBoolean y)
        {
            return (x != y);
        }
        
        // Alternative method for operator ~
        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.OnesComplement"]/*' />
        public static OracleBoolean OnesComplement(OracleBoolean x)
        {
            return (~x);
        }

        // Alternative method for operator |
        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.Or"]/*' />
        public static OracleBoolean Or(OracleBoolean x, OracleBoolean y)
        {
            return (x | y);
        }

        // Alternative method for operator ^
        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.Xor"]/*' />
        public static OracleBoolean Xor(OracleBoolean x, OracleBoolean y)
        {
            return (x ^ y);
        }

        // Implicit conversion from bool to OracleBoolean
        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.operatorOracleBoolean1"]/*' />
        public static implicit operator OracleBoolean(bool x)
        {
            return new OracleBoolean(x);
        }

        // Explicit conversion from string to OracleBoolean
        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.operatorOracleBoolean2"]/*' />
        public static explicit operator OracleBoolean(string x) 
        {
            return OracleBoolean.Parse(x);
        }

        // Explicit conversion from OracleNumber to OracleBoolean
        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.operatorOracleBoolean3"]/*' />
        public static explicit operator OracleBoolean(OracleNumber x)
        {
            return x.IsNull ? Null : new OracleBoolean(x.Value != Decimal.Zero);
        }

        // Explicit conversion from OracleBoolean to bool. Throw exception if x is Null.
        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.operatorbool"]/*' />
        public static explicit operator bool(OracleBoolean x) 
        {
            return x.Value;
        }


		//----------------------------------------------------------------------
	    // Unary operators
		//----------------------------------------------------------------------

        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.operator!"]/*' />
        public static OracleBoolean operator!	(OracleBoolean x) 
        {
            switch (x._value) 
            {
                case x_True:
                    return OracleBoolean.False;

                case x_False:
                    return OracleBoolean.True;

                default:
                    Debug.Assert(x._value == x_Null);
                    return OracleBoolean.Null;
            }
        }

        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.operator~"]/*' />
        public static OracleBoolean operator~	(OracleBoolean x)
        {
            return (!x);
        }

        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.operatortrue"]/*' />
        public static bool operator true		(OracleBoolean x)
        {
            return x.IsTrue;
        }

        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.operatorfalse"]/*' />
        public static bool operator false		(OracleBoolean x)
        {
            return x.IsFalse;
        }

        
		//----------------------------------------------------------------------
		// Binary operators
		//----------------------------------------------------------------------

        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.operatorAND"]/*' />
        public static OracleBoolean operator&	(OracleBoolean x, OracleBoolean y)
        {
            if (x._value == x_False || y._value == x_False)
                return OracleBoolean.False;
            else if (x._value == x_True && y._value == x_True)
                return OracleBoolean.True;
            else
                return OracleBoolean.Null;
        }

        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.operatorEQ"]/*' />
        public static OracleBoolean operator==	(OracleBoolean x, OracleBoolean y) 
        {
            return(x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x._value == y._value);
        }

        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.operatorNE"]/*' />
        public static OracleBoolean operator!=	(OracleBoolean x, OracleBoolean y) 
        {
            return ! (x == y);
        }

        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.operatorOR"]/*' />
        public static OracleBoolean operator|	(OracleBoolean x, OracleBoolean y)
        {
            if (x._value == x_True || y._value == x_True)
                return OracleBoolean.True;
            else if (x._value == x_False && y._value == x_False)
                return OracleBoolean.False;
            else
                return OracleBoolean.Null;
        }

        /// <include file='doc\OracleBoolean.uex' path='docs/doc[@for="OracleBoolean.operatorXOR"]/*' />
        public static OracleBoolean operator^	(OracleBoolean x, OracleBoolean y) 
        {
            return(x.IsNull || y.IsNull) ? Null : new OracleBoolean(x._value != y._value);
        }
        
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oraclebfile.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleBFile.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Data.SqlTypes;
	using System.Diagnostics;
	using System.Globalization;
	using System.IO;
	using System.Runtime.InteropServices;
	using System.Text;
	
	//----------------------------------------------------------------------
	// OracleBFile
	//
	//	This class is derived from the OracleLob type class, and implements
	//	the additional methods necessary to support Oracle's BFILE internal
	//	data type.  Note that Oracle does not allow writing to a BFILE data
	//	type.
	//
    /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile"]/*' />
	sealed public class OracleBFile : Stream, ICloneable, IDisposable, INullable
	{
		private OracleLob	_lob;
		private	string		_fileName;
		private string		_directoryAlias;


        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.Null"]/*' />
        static public new readonly OracleBFile Null = new OracleBFile();
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Constructors
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		// (internal) Construct a null lob
		internal OracleBFile()
		{
			_lob = OracleLob.Null;
		}
		

 		// (internal) Construct from a data reader buffer
		internal OracleBFile(OciLobLocator lobLocator) 
 		{
			_lob = new OracleLob(lobLocator);
		}

		// (internal) Construct from an existing BFile object (copy constructor)
		internal OracleBFile(OracleBFile bfile)
		{
			this._lob 				= (OracleLob)bfile._lob.Clone();
			this._fileName			= bfile._fileName;
			this._directoryAlias	= bfile._directoryAlias;
		}

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.CanRead"]/*' />
		public override bool CanRead
		{
			get 
			{
				if (IsNull)
					return true;

				return !IsDisposed;
			}
		}

        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.CanSeek"]/*' />
		public override bool CanSeek
		{
			get 
			{
				if (IsNull)
					return true;

				return !IsDisposed;
			}
		}

        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.CanWrite"]/*' />
		public override bool CanWrite
		{
			get { return false; }
		}

        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.Connection"]/*' />
		public OracleConnection Connection 
		{
			get 
			{ 
				AssertInternalLobIsValid();
				return _lob.Connection; 
			}
		}
        
		internal OciHandle Descriptor
		{
			get { return LobLocator.Descriptor; }
		}
		
        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.DirectoryName"]/*' />
		public string DirectoryName
		{
			// TODO: should probably call this DirectoryAlias, since that's what it really is.  
			
			// DEVNOTE:	OCI doesn't provide a simple API to get the name from the alias, but you could 
			//			execute the SQL Query:
			//
			//				select directory_path from all_directories where directory_name = 'directoryAlias' 
			//
			//			And you would get the name.  It isn't clear if directory aliases are unique across
			//			all users, however.  
			get 
			{
				AssertInternalLobIsValid();

				if (IsNull)
					return String.Empty;
				
				if (null == _directoryAlias)
					GetNames();

				return _directoryAlias;
			}
		}

        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.FileExists"]/*' />
		public bool FileExists
		{
			get 
			{
				AssertInternalLobIsValid();

				if (IsNull)
					return false;
				
				_lob.AssertConnectionIsOpen();
			
				int flag;
				int rc = TracedNativeMethods.OCILobFileExists(
											ServiceContextHandle,
											ErrorHandle,
											Descriptor,
											out flag
											);
				if (0 != rc)
					Connection.CheckError(ErrorHandle, rc);

				return (flag != 0);
			}
		}

        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.FileName"]/*' />
		public string FileName
		{
			get 
			{
				AssertInternalLobIsValid();

				if (IsNull)
					return String.Empty;
				
				if (null == _fileName)
					GetNames();

				return _fileName;
			}
		}

        internal OciHandle ErrorHandle 
		{
			get 
			{ 
				Debug.Assert(null != _lob, "_lob is null?");
				return _lob.ErrorHandle; 
			}
		}

		private bool IsDisposed 
		{
			get { return (null == _lob);}
		}

        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.IsNull"]/*' />
		public bool IsNull 
		{
			get { return (OracleLob.Null == _lob); }
		}

        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.Length"]/*' />
		public override long Length
		{
			get {
				AssertInternalLobIsValid();

				if (IsNull)
					return 0;
				
				long value = _lob.Length;
				return value;
			}
		}

		internal OciLobLocator LobLocator
		{
			get { return _lob.LobLocator; }
		}

        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.Position"]/*' />
		public override long Position
		{
			get 
			{ 
				AssertInternalLobIsValid();

				if (IsNull)
					return 0;
				
				return _lob.Position; 
			}
			set 
			{ 
				AssertInternalLobIsValid();

				if (!IsNull)
					_lob.Position = value; 
			}
		}

		internal OciHandle ServiceContextHandle
		{
			get 
			{ 
				Debug.Assert(null != _lob, "_lob is null?");
				return _lob.ServiceContextHandle; 
			}
		}

        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.Value"]/*' />
        public object Value
        {
			get 
			{
				AssertInternalLobIsValid();

				if (IsNull)
					return DBNull.Value;
				
				EnsureLobIsOpened();
				object value = _lob.Value;
				return value;
			}
		}


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
		internal void AssertInternalLobIsValid()
		{
			if (IsDisposed)
				throw ADP.ObjectDisposed("OracleBFile");
		}

        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.Clone"]/*' />
		public object Clone() 
		{
            OracleBFile clone = new OracleBFile(this);
            return clone;
		}
		
        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.CopyTo1"]/*' />
		public long CopyTo (OracleLob destination)
		{
			// Copies the entire lob to a compatible lob, starting at the beginning of the target array.
			return CopyTo (0, destination, 0, Length);
		}
		
        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.CopyTo2"]/*' />
		public long CopyTo (
						OracleLob destination, 
						long destinationOffset
						)
		{
			// Copies the entire lob to a compatible lob, starting at the specified offset of the target array.
			return CopyTo (0, destination, destinationOffset, Length);
		}
		
		
        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.CopyTo3"]/*' />
		public long CopyTo (
						long sourceOffset,
						OracleLob destination, 
						long destinationOffset,
						long amount
						)
		{
			// Copies a range of elements from the lob to a compatible lob, starting at the specified index of the target array.
			AssertInternalLobIsValid();

			if (null == destination)
				throw ADP.ArgumentNull("destination");

			if (destination.IsNull)
				throw ADP.LobWriteInvalidOnNull();
			
			if (_lob.IsNull)
				return 0;

			_lob.AssertConnectionIsOpen();			

			_lob.AssertAmountIsValid(amount,			"amount");
			_lob.AssertAmountIsValid(sourceOffset,		"sourceOffset");
			_lob.AssertAmountIsValid(destinationOffset,	"destinationOffset");

			_lob.AssertTransactionExists();

			int rc;

			_lob.EnsureBuffering(false);
			destination.EnsureBuffering(false);
			
			long dataCount = Math.Min(Length - sourceOffset, amount);
			long dstOffset = destinationOffset + 1;	// Oracle is 1 based, we are zero based.
			long srcOffset = sourceOffset + 1;			// Oracle is 1 based, we are zero based.

			if (0 >= dataCount)
				return 0;
			
			rc = TracedNativeMethods.OCILobLoadFromFile(
									ServiceContextHandle,
									ErrorHandle,
									destination.Descriptor,
									Descriptor,
									(UInt32)dataCount,
									(UInt32)dstOffset,	
									(UInt32)srcOffset
									);
			if (0 != rc)
				Connection.CheckError(ErrorHandle, rc);
			
			// DEVNOTE: Oracle must not do partial copies, because their API doesn't tell you how many bytes were copied.
			return dataCount;	
		}
		
        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.Dispose1"]/*' />
		public void Dispose() 
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing) 
		{
			if (disposing)
			{
				OracleLob lob = _lob;

				if (null != lob)
					lob.Dispose();
			}
			
			_lob = null;
			_fileName = null;
			_directoryAlias = null;
 		}

		private void EnsureLobIsOpened()
		{
			LobLocator.Open(OracleLobOpenMode.ReadOnly); 
		}

	    /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.Flush"]/*' />
		public override void Flush ()	{}
		
        internal void GetNames()
		{
			_lob.AssertConnectionIsOpen();

			int				charSize = (Connection.EnvironmentHandle.IsUnicode) ? 2 : 1;
			short			directoryAliasLength = (short)(charSize * 30);
			short			fileAliasLength 	 = (short)(charSize * 255);
			NativeBuffer	buffer = Connection.ScratchBuffer;

			Debug.Assert (buffer.Length > (directoryAliasLength + fileAliasLength), "connection's scratch buffer is too small");
			
			HandleRef		directoryAlias 	= buffer.Ptr;
			HandleRef		fileAlias 		= buffer.PtrOffset(directoryAliasLength);
			
			int rc = TracedNativeMethods.OCILobFileGetName(
										Connection.EnvironmentHandle,
										ErrorHandle,
										Descriptor,
										directoryAlias,
										ref directoryAliasLength,
										fileAlias,
										ref fileAliasLength
										);
			if (0 != rc)
				Connection.CheckError(ErrorHandle, rc);

			_directoryAlias	= Connection.GetString((IntPtr)directoryAlias,	directoryAliasLength,	false);
			_fileName		= Connection.GetString((IntPtr)fileAlias,		fileAliasLength, 		false);
			GC.KeepAlive(buffer);
		}

	    /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.Read"]/*' />
		public override int Read (
						byte[] buffer, 
						int offset, 
						int count
						)
		{
			AssertInternalLobIsValid();

			if (!IsNull)
				EnsureLobIsOpened();
			
			int result = _lob.Read(buffer, offset, count);
			return result;
		}
		
        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OraOracleBFilecleLob.Seek"]/*' />
		public override long Seek (
						long offset, 
						SeekOrigin origin
						)
		{
			AssertInternalLobIsValid();
			long result = _lob.Seek(offset, origin);
			return result;
		}
		
        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.SetFileName"]/*' />
		public void SetFileName (
			string	directory,
			string	file
			)
		{
			AssertInternalLobIsValid();

			if (!IsNull)
			{
				_lob.AssertConnectionIsOpen();
				_lob.AssertTransactionExists();

				LobLocator.ForceClose();	 // MDAC 86200: must be closed or the ForceOpen below will leak opens...
				
				IntPtr newHandle = (IntPtr)LobLocator.Handle;
				
				int rc = TracedNativeMethods.OCILobFileSetName(
											Connection.EnvironmentHandle,
											ErrorHandle,
											ref newHandle,
											directory,
											(short)directory.Length,
											file,
											(short)file.Length
											);

				if (0 != rc)
					Connection.CheckError(ErrorHandle, rc);

				LobLocator.ForceOpen();	 // SetFileName automatically closes the BFILE on the server, we reopen it
				
				Debug.Assert ((IntPtr)LobLocator.Handle == newHandle, "OCILobFileSetName changed the handle!");	 // Should never happen...
				Descriptor.SetOciHandle(newHandle);	// ...but just in case.

				_fileName = null;
				_directoryAlias = null;
				_lob.Position = 0;
			}
        }
        
        /// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.SetLength"]/*' />
		public override void SetLength (long value)
		{
			AssertInternalLobIsValid();
			throw ADP.ReadOnlyLob();
		}	
		
		/// <include file='doc\OracleBFile.uex' path='docs/doc[@for="OracleBFile.Write"]/*' />
		public override void Write (
						byte[] buffer, 
						int offset, 
						int count
						)
		{
			AssertInternalLobIsValid();
  			throw ADP.ReadOnlyLob();
        }
      
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oraclecolumn.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleColumn.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
    using System;
    using System.Data;
    using System.Diagnostics;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Text;

    //----------------------------------------------------------------------
    // OracleColumn
    //
    //  Contains all the information about a single column in a result set,
    //  and implements the methods necessary to describe column to Oracle
    //  and to extract the column data from the native buffer used to fetch
    //  it.
    //
    sealed internal class OracleColumn 
    {
        static internal readonly int ChunkSize = 8192;      // TODO: pick an optimal chunk size; but we'll start with 8K for now
        
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Fields
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        
        private OciHandle       _describeHandle;        // the Describe handle
        private int             _ordinal;               // the ordinal position in the rowset (0..n-1)
        private string          _columnName;            // the name of the column

        private MetaType        _metaType;
        private byte            _precision;             // precision of the column (OracleNumber only)
        private byte            _scale;                 // scale of the column (OracleNumber only)
        private int             _size;                  // how many bytes we need in the row buffer
        private bool            _isNullable;            // whether the value is nullable or not.

        private int             _indicatorOffset;       // offset from the start of the row buffer to the indicator binding (see OCI.INDICATOR)
        private int             _lengthOffset;          // offset from the start of the row buffer to the length binding
        private int             _valueOffset;           // offset from the start of the row buffer to the value binding

        private NativeBuffer    _rowBuffer;             // the row buffer we're bound to (reused for all rows fetched)
        private NativeBuffer    _longBuffer;            // the out-of-line buffer used for piecewise binding; must be reset for each new fetch.
        private int             _longLength;            // the length of the data we actually fetched into _longBuffer
        private int             _longCurrentOffset;     // the current offset we're reading at in _longBuffer
        private int             _longNextOffset;        // the offset to the end of this chunk in _longBuffer
        private OCI.Callback.OCICallbackDefine _callback;
                                                        // the piecewise binding callback for this column

        private OciLobLocator   _lobLocator;            // the descriptor allocated for LOB columns
        
        private OracleConnection _connection;           // the connection the column is on (LOB columns only)
        private int             _connectionCloseCount;  // The close count of the connection; used to decide if we're zombied
        
        private bool            _bindAsUCS2;            // true whenever we're binding character data as Unicode...

        
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Constructors
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////

        // Construct by getting the specified describe handle from the specified statement handle
        internal OracleColumn(
                    OciHandle           statementHandle,
                    int                 ordinal,
                    OciHandle           errorHandle,
                    OracleConnection    connection
                    )
        {
            _ordinal                = ordinal;
            _describeHandle         = statementHandle.GetDescriptor(_ordinal, errorHandle);;
            _connection             = connection;
            _connectionCloseCount   = connection.CloseCount;
        }


        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Properties 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////

        internal string     ColumnName      { get { return _columnName; } }
        internal bool       IsNullable      { get { return _isNullable; } }
        internal bool       IsLob           { get { return _metaType.IsLob; } }
        internal bool       IsLong          { get { return _metaType.IsLong; } }
        internal OracleType OracleType      { get { return _metaType.OracleType; } }
        internal int        Ordinal         { get { return _ordinal; } }
        internal byte       Precision       { get { return _precision; } }
        internal byte       Scale           { get { return _scale; } }
        internal int        Size            { get { return (_bindAsUCS2 && !_metaType.IsLong)?_size/2:_size; } }    // This is the value used for the SchemaTable, which must be Chars...
        
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Methods 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////

        private int _callback_GetColumnPiecewise(
                        IntPtr      octxp,
                        IntPtr      defnp,
                        int         iter,
                        IntPtr      bufpp,  // dvoid**
                        IntPtr      alenp,  // ub4**
                        IntPtr      piecep, // ub1*
                        IntPtr      indpp,  // dvoid**
                        IntPtr      rcodep  // ub2**
                        )
        {
            //  Callback routine for Dynamic Binding column values from Oracle: tell
            //  Oracle where to stuff the data.

            int thisChunkSize;
            
            // TODO: Consider creating a StringBuilder-like class (BlobBuilder?) that can store chunks of allocations, instead of a single buffer being re-allocated.

            if (null == _longBuffer)
            {
                _longBuffer = new NativeBuffer_LongColumnData(ChunkSize);
                _longCurrentOffset = 0;
            }

            if (0 == _longNextOffset)
                thisChunkSize = _longBuffer.Length;      // first read: fill the existing buffer
            else
                thisChunkSize = ChunkSize;
        
            _longCurrentOffset  = _longNextOffset;
            _longNextOffset     = _longCurrentOffset + thisChunkSize;
            _longBuffer.Length  = _longNextOffset;

            HandleRef buffer = _longBuffer.Ptr;
//Debug.WriteLine(((IntPtr)buffer).ToInt32());
    
            // Stuff the longBuffer into the rowBuffer so we can get use it 
            // in the type getters later (this also verifies that the allocation
            // has occured)
            Marshal.WriteIntPtr((IntPtr)_rowBuffer.PtrOffset(_valueOffset), (IntPtr)buffer);
            
            Marshal.WriteIntPtr(alenp,  (IntPtr)_rowBuffer.PtrOffset(_lengthOffset));       // *alenp
            if (-1 != _indicatorOffset) {
                Marshal.WriteIntPtr(indpp,  (IntPtr)_rowBuffer.PtrOffset(_indicatorOffset));    // *indpp
            }
            else {
                Marshal.WriteIntPtr(indpp,  IntPtr.Zero);    // *indpp
            }
            Marshal.WriteIntPtr(bufpp,  (IntPtr)_longBuffer.PtrOffset(_longCurrentOffset)); // *bufpp

            Marshal.WriteInt32 ((IntPtr)_rowBuffer.PtrOffset(_lengthOffset),thisChunkSize); // **alenp      

            GC.KeepAlive(this);
            return (int)OCI.RETURNCODE.OCI_CONTINUE;
        }
    
        internal void Bind(
                        OciHandle       statementHandle,
                        NativeBuffer    buffer,
                        OciHandle       errorHandle,
                        int             rowBufferLength
                        )
        {
            //  Binds the buffer for the column to the statement handle specified.

            OciHandle       defineHandle = null;
            IntPtr          h;
            OCI.MODE        mode = OCI.MODE.OCI_DEFAULT;
            int             bindSize;
            OCI.DATATYPE    ociType = _metaType.OciType;

            _rowBuffer = buffer;

            if (_metaType.IsLong)
            {
                mode     = OCI.MODE.OCI_DYNAMIC_FETCH;
                bindSize = Int32.MaxValue;
            }
            else
            {
                bindSize = _size;
            }

            HandleRef indicatorLocation = ADP.NullHandleRef;
            HandleRef lengthLocation    = ADP.NullHandleRef;
            HandleRef valueLocation     = _rowBuffer.PtrOffset(_valueOffset);

            if (-1 != _indicatorOffset)
                indicatorLocation = _rowBuffer.PtrOffset(_indicatorOffset);
                
            if (-1 != _lengthOffset && !_metaType.IsLong)
                lengthLocation = _rowBuffer.PtrOffset(_lengthOffset);

            try 
            {
                try
                {
                    int rc = TracedNativeMethods.OCIDefineByPos(
                                                statementHandle,            // hndlp
                                                out h,                      // defnpp
                                                errorHandle,                // errhp
                                                _ordinal+1,                 // position
                                                valueLocation,              // valuep
                                                bindSize,                   // value_sz
                                                ociType,                    // htype
                                                indicatorLocation,          // indp,
                                                lengthLocation,             // rlenp,
                                                ADP.NullHandleRef,          // rcodep,
                                                mode                        // mode
                                                );
                    if (rc != 0)
                        _connection.CheckError(errorHandle, rc);

                    defineHandle = new OciDefineHandle(statementHandle, h);

                    if (0 != rowBufferLength)
                    {
                        int valOffset = rowBufferLength;
                        int indOffset = (-1 != _indicatorOffset) ? rowBufferLength : 0;
                        int lenOffset = (-1 != _lengthOffset && !_metaType.IsLong) ? rowBufferLength : 0;
                        
                        rc = TracedNativeMethods.OCIDefineArrayOfStruct(
                                                    defineHandle,
                                                    errorHandle,
                                                    valOffset,
                                                    indOffset,
                                                    lenOffset,
                                                    0    // never use rcodep above...
                                                    );
                        if (rc != 0)
                            _connection.CheckError(errorHandle, rc);
                    }

                    if (!_connection.UnicodeEnabled)
                    {
                        if (_metaType.UsesNationalCharacterSet)
                        {
                            Debug.Assert(!_metaType.IsLong, "LONG data may never be bound as NCHAR");
                            // NOTE:    the order is important here; setting charsetForm will 
                            //          reset charsetId (I found this out the hard way...)
                            defineHandle.SetAttribute(OCI.ATTR.OCI_ATTR_CHARSET_FORM, (int)OCI.CHARSETFORM.SQLCS_NCHAR, errorHandle);
                        } 
                        if (_bindAsUCS2)
                        {
                            // NOTE:    the order is important here; setting charsetForm will 
                            //          reset charsetId (I found this out the hard way...)
                            defineHandle.SetAttribute(OCI.ATTR.OCI_ATTR_CHARSET_ID, OCI.OCI_UCS2ID, errorHandle);
                        }
                    }
                    if (_metaType.IsLong)
                    {
                        // Initialize the longBuffer in the rowBuffer to null
                        Marshal.WriteIntPtr((IntPtr)_rowBuffer.PtrOffset(_valueOffset), IntPtr.Zero);

                        if (null != _longBuffer)
                        {
                            _longBuffer.Dispose();
                            _longBuffer = null;
                        }

                        // We require MTxOCI8 to be in the path somewhere for us to handle LONG data
                        if (!OCI.IsNewMtxOci8Installed)
#if EVERETT
                            throw ADP.MustInstallNewMtxOciLONG();
#else //!EVERETT
                            throw ADP.MustInstallNewMtxOci();
#endif //!EVERETT
                        _callback = new OCI.Callback.OCICallbackDefine(_callback_GetColumnPiecewise);
                        
                        rc = TracedNativeMethods.MTxOciDefineDynamic(
                                                    defineHandle,       // defnp
                                                    errorHandle,        // errhp
                                                    ADP.NullHandleRef,  // dvoid *octxp,
                                                    _callback           // OCICallbackDefine ocbfp
                                                    );
                        if (rc != 0)
                            _connection.CheckError(errorHandle, rc);
                    }
                }
                finally
                {
                    // We don't need this any longer, get rid of it.
                    OciHandle.SafeDispose(ref defineHandle);
                }
            }
            catch // Prevent exception filters from running in our space
            {
                throw;
            }
        }
        
        internal bool Describe(
                        ref int     offset,
                        OracleConnection connection,
                        OciHandle   errorHandle
                        )
        {
            //  Gets all of the column description information from the describe
            //  handle.  In addition, we'll determine the position of the column
            //  in the rowbuffer, based upon the offset parameter, which is passed
            //  by ref so we can adjust the end position accordingly.
            
            short           tempub2;
            byte            tempub1;
            OCI.DATATYPE    ociType;
            bool            needSize = false;
            bool            cannotPrefetch = false;
            
            _describeHandle.GetAttribute(OCI.ATTR.OCI_ATTR_NAME,        out _columnName,errorHandle, _connection);
            _describeHandle.GetAttribute(OCI.ATTR.OCI_ATTR_DATA_TYPE,   out tempub2,    errorHandle);
            _describeHandle.GetAttribute(OCI.ATTR.OCI_ATTR_IS_NULL,     out tempub1,    errorHandle);

            _isNullable = (0 != tempub1);

            ociType = (OCI.DATATYPE)tempub2;

            switch (ociType)
            {
                case OCI.DATATYPE.CHAR:
                case OCI.DATATYPE.VARCHAR2:
                    _describeHandle.GetAttribute(OCI.ATTR.OCI_ATTR_DATA_SIZE,   out _size,      errorHandle);
                    _describeHandle.GetAttribute(OCI.ATTR.OCI_ATTR_CHARSET_FORM,out tempub1,    errorHandle);

                    _bindAsUCS2 = connection.ServerVersionAtLeastOracle8;

                    if (OCI.CHARSETFORM.SQLCS_NCHAR == (OCI.CHARSETFORM)tempub1)
                    {
                        _metaType = MetaType.GetMetaTypeForType((OCI.DATATYPE.CHAR == ociType) ? OracleType.NChar : OracleType.NVarChar);

                        if (!connection.ServerVersionAtLeastOracle9i)
                            _size *= ADP.CharSize;  // Servers prior to 9i report the number of characters, not the number of bytes.
                    }
                    else
                    {
                        _metaType = MetaType.GetMetaTypeForType((OCI.DATATYPE.CHAR == ociType) ? OracleType.Char  : OracleType.VarChar);

                        if (_bindAsUCS2) {
                            _size *= ADP.CharSize;      // All servers report the number of characters.
                        }
                    }
                    needSize    = true;
                    break;

                case OCI.DATATYPE.DATE:
                    _metaType   = MetaType.GetMetaTypeForType(OracleType.DateTime);
                    _size       = _metaType.BindSize;
                    break;
                
                case OCI.DATATYPE.TIMESTAMP:
                    _metaType   = MetaType.GetMetaTypeForType(OracleType.Timestamp);
                    _size       = _metaType.BindSize;
                    break;
                
                case OCI.DATATYPE.TIMESTAMP_LTZ:
                    _metaType   = MetaType.GetMetaTypeForType(OracleType.TimestampLocal);
                    _size       = _metaType.BindSize;
                    break;

                case OCI.DATATYPE.TIMESTAMP_TZ:
                    _metaType   = MetaType.GetMetaTypeForType(OracleType.TimestampWithTZ);
                    _size       = _metaType.BindSize;
                    break;
                
                case OCI.DATATYPE.INTERVAL_YM:
                    _metaType   = MetaType.GetMetaTypeForType(OracleType.IntervalYearToMonth);
                    _size       = _metaType.BindSize;
                    break;
                    
                case OCI.DATATYPE.INTERVAL_DS:
                    _metaType   = MetaType.GetMetaTypeForType(OracleType.IntervalDayToSecond);
                    _size       = _metaType.BindSize;
                    break;
                    
                case OCI.DATATYPE.NUMBER:
                    _metaType   = MetaType.GetMetaTypeForType(OracleType.Number);
                    _size       = _metaType.BindSize;
 
                    _describeHandle.GetAttribute(OCI.ATTR.OCI_ATTR_PRECISION,   out _precision, errorHandle);
                    _describeHandle.GetAttribute(OCI.ATTR.OCI_ATTR_SCALE,       out _scale,     errorHandle);
                    break;
                
                case OCI.DATATYPE.RAW:
                    _metaType   = MetaType.GetMetaTypeForType(OracleType.Raw);
                    _describeHandle.GetAttribute(OCI.ATTR.OCI_ATTR_DATA_SIZE,   out _size,      errorHandle);
                    needSize    = true;
                    break;

                case OCI.DATATYPE.ROWID:
                case OCI.DATATYPE.ROWID_DESC:
                case OCI.DATATYPE.UROWID:
                    _metaType   = MetaType.GetMetaTypeForType(OracleType.RowId);
                    _size       = _metaType.BindSize;
                    if (connection.UnicodeEnabled)
                    {
                        _bindAsUCS2 = true;
                        _size *= 2; // Since Oracle reported the number of characters and UCS2 characters are two bytes each, have to adjust the buffer size
                    }
                    needSize    = true;
                    break;
                    
                case OCI.DATATYPE.BFILE:
                    _metaType   = MetaType.GetMetaTypeForType(OracleType.BFile);
                    _size       = _metaType.BindSize;
                    cannotPrefetch = true;
                    break;
                    
                case OCI.DATATYPE.BLOB:
                    _metaType   = MetaType.GetMetaTypeForType(OracleType.Blob);
                    _size       = _metaType.BindSize;
                    cannotPrefetch = true;
                    break;
                    
                case OCI.DATATYPE.CLOB:
                    _describeHandle.GetAttribute(OCI.ATTR.OCI_ATTR_CHARSET_FORM,    out tempub1,    errorHandle);
                    _metaType   = MetaType.GetMetaTypeForType((OCI.CHARSETFORM.SQLCS_NCHAR == (OCI.CHARSETFORM)tempub1) ? OracleType.NClob : OracleType.Clob);
                    _size       = _metaType.BindSize;
                    cannotPrefetch = true;
                    break;
                    
                case OCI.DATATYPE.LONG:
                    _metaType   = MetaType.GetMetaTypeForType(OracleType.LongVarChar);
                    _size       = _metaType.BindSize;
                    needSize    = true;
                    cannotPrefetch = true;
                    _bindAsUCS2 = connection.ServerVersionAtLeastOracle8;       // MDAC #79471 - Oracle7 servers don't do Unicode
                    break;

                case OCI.DATATYPE.LONGRAW:
                    _metaType   = MetaType.GetMetaTypeForType(OracleType.LongRaw);
                    _size       = _metaType.BindSize;
                    needSize    = true;
                    cannotPrefetch = true;
                    break;
                    
                default:
                    throw ADP.TypeNotSupported(ociType);
            }

            // Fill in the buffer offsets, while we're at it. We lay out
            // the buffer as follows:
            //
            //      indicator   0-3
            //      length      4-7
            //      data        8-...
            //
            if (_isNullable)
            {
                _indicatorOffset= offset;   offset += 4;
            }
            else
                _indicatorOffset = -1;
            
            if (needSize)
            {
                _lengthOffset   = offset;   offset += 4;
            }
            else
                _lengthOffset = -1;

            _valueOffset    = offset;
            
            if (OCI.DATATYPE.LONG == ociType
             || OCI.DATATYPE.LONGRAW == ociType)
                offset += IntPtr.Size;
            else
                offset += _size;

            offset = (offset + 3) & ~0x3;   // DWORD align, please.

            // We don't need this any longer, get rid of it.
            OciHandle.SafeDispose(ref _describeHandle);

            return cannotPrefetch;
        }

        internal void Dispose()
        {
            if (null != _longBuffer)
            {
                _longBuffer.Dispose();
            }
            _longBuffer = null;
            OciLobLocator.SafeDispose(ref _lobLocator);
            OciHandle.SafeDispose(ref _describeHandle);
            _columnName     = null;
            _metaType       = null;
            _longBuffer     = null;
            _lobLocator     = null;
            _callback       = null;
            _connection     = null;
        }

        internal void FixupLongValueLength(
                NativeBuffer    buffer
                )
        {
            if (null != _longBuffer)
            {
                Debug.Assert(_metaType.IsLong, "dangling long buffer?");
                
                // Determine the actual length of the LONG/LONG RAW data read, if we
                // haven't done so already.
                if (-1 == _longLength)
                {
                    // Our "piecewise" fetching of LONG/LONG RAW data will extend the
                    // buffer by a chunk, and ask Oracle to fill it.  We only know how
                    // much data was read until after the fetch call returns, and then
                    // we only know how much of the last chunk was filled in.  SO: we
                    // get the length value from the row buffer, which contains how much
                    // data was read into the last chunk, then we get the buffer size and
                    // compute the full length of the data.

                    int lastChunkActualLength = Marshal.ReadInt32((IntPtr)buffer.PtrOffset(_lengthOffset));
                    
                    _longLength = _longCurrentOffset + lastChunkActualLength;
                
                    // Of course, we have to convert for character data to number of 
                    // Unicode Characters read, not number of bytes
                    if (_bindAsUCS2)
                    {
                        Debug.Assert(0 == (_longLength & 0x1), "odd length unicode data?");
                        _longLength /= 2;
                    }
                    
                    Debug.Assert(_longLength >= 0, "invalid size for LONG data?");

                    // Finally, we write the length back to the row buffer so we don't
                    // have to have two code paths to construct the managed object.
                    Marshal.WriteInt32((IntPtr)buffer.PtrOffset(_lengthOffset), _longLength);
                }               
            }
        }
        
        internal string GetDataTypeName()
        {
            //  Returns the name of the back-end data type.
            return _metaType.DataTypeName;
        }

        internal Type GetFieldType()
        {
            //  Returns the actual type that the column is.
            return _metaType.BaseType;
        }
        
        internal object GetValue(NativeBuffer buffer)
        {
            //  Returns an object that contains the value of the column in the
            //  specified row buffer.  This method returns CLS-typed objects.
            
            if (IsDBNull(buffer))
                return DBNull.Value;

//Debug.WriteLine(String.Format("{0}: {1}", _columnName, Marshal.ReadInt16(buffer.Ptr, _indicatorOffset+2)));

            switch (_metaType.OciType)
            {
                case OCI.DATATYPE.BFILE:
                {
                    object value;
                    using (OracleBFile bfile = GetOracleBFile(buffer)) {
                        value = bfile.Value;    // reading the LOB is MUCH more expensive than constructing an object we'll throw away
                    }           
                    return value;
                }

                case OCI.DATATYPE.RAW:
                case OCI.DATATYPE.LONGRAW:
                {
                    long    length = GetBytes(buffer, 0, null, 0, 0);
                    byte[]  value  = new byte[length];
                    GetBytes( buffer, 0, value, 0, (int)length );
                    return value;
                }
                    
                case OCI.DATATYPE.DATE:
                case OCI.DATATYPE.INT_TIMESTAMP:
                case OCI.DATATYPE.INT_TIMESTAMP_TZ:
                case OCI.DATATYPE.INT_TIMESTAMP_LTZ:
                    return GetDateTime( buffer );
                    
                case OCI.DATATYPE.BLOB:
                case OCI.DATATYPE.CLOB:
                {
                    object value;
                    using (OracleLob lob = GetOracleLob(buffer)) { 
                        value = lob.Value;  // reading the LOB is MUCH more expensive than constructing an object we'll throw away
                    }           
                    return value;
                }
                    
                case OCI.DATATYPE.INT_INTERVAL_YM:
                    return GetInt32( buffer );
                    
                case OCI.DATATYPE.VARNUM:
                    return GetDecimal( buffer );

                case OCI.DATATYPE.CHAR:
                case OCI.DATATYPE.VARCHAR2:
                case OCI.DATATYPE.LONG:                 
                    return GetString( buffer );

                case OCI.DATATYPE.INT_INTERVAL_DS:
                    return GetTimeSpan( buffer );
            }
            throw ADP.TypeNotSupported(_metaType.OciType);
        }
        
        internal object GetOracleValue(NativeBuffer buffer)
        {
            //  Returns an object that contains the value of the column in the
            //  specified row buffer.  This method returns Oracle-typed objects.

//Debug.WriteLine(String.Format("{0}: {1}", _columnName, Marshal.ReadInt16(buffer.Ptr, _indicatorOffset+2)));
            
            switch (_metaType.OciType)
            {
                case OCI.DATATYPE.BFILE:
                    return GetOracleBFile( buffer );

                case OCI.DATATYPE.RAW:
                case OCI.DATATYPE.LONGRAW:
                    return GetOracleBinary( buffer );
                    
                case OCI.DATATYPE.DATE:
                case OCI.DATATYPE.INT_TIMESTAMP:
                case OCI.DATATYPE.INT_TIMESTAMP_TZ:
                case OCI.DATATYPE.INT_TIMESTAMP_LTZ:
                    return GetOracleDateTime( buffer );

                case OCI.DATATYPE.BLOB:
                case OCI.DATATYPE.CLOB:
                    return GetOracleLob( buffer );
                    
                case OCI.DATATYPE.INT_INTERVAL_YM:
                    return GetOracleMonthSpan( buffer );
                    
                case OCI.DATATYPE.VARNUM:
                    return GetOracleNumber( buffer );

                case OCI.DATATYPE.CHAR:
                case OCI.DATATYPE.VARCHAR2:
                case OCI.DATATYPE.LONG:                 
                    return GetOracleString( buffer );

                case OCI.DATATYPE.INT_INTERVAL_DS:
                    return GetOracleTimeSpan( buffer );
            }
            throw ADP.TypeNotSupported(_metaType.OciType);
        }


        //----------------------------------------------------------------------
        // Get<type>
        //
        //  Returns an the value of the column in the specified row buffer as
        //  the appropriate type
        //
        internal long GetBytes(
                        NativeBuffer buffer, 
                        long fieldOffset,
                        byte[] destinationBuffer,
                        int destinationOffset,
                        int length
                        ) 
        {
            if (length < 0) // MDAC 71007
                throw ADP.InvalidDataLength(length);

            if ((destinationOffset < 0) || (null != destinationBuffer && destinationOffset >= destinationBuffer.Length)) // MDAC 71013
                throw ADP.InvalidDestinationBufferIndex(destinationBuffer.Length, destinationOffset);

            if (0 > fieldOffset || UInt32.MaxValue < fieldOffset)
                throw ADP.InvalidSourceOffset("fieldOffset", 0, UInt32.MaxValue);

            int byteCount;

            if (IsLob)
            {
                OracleType  lobType = _metaType.OracleType;

                if (OracleType.Blob != lobType && OracleType.BFile != lobType)
                    throw ADP.InvalidCast();
                
                if (IsDBNull(buffer))
                    throw ADP.DataReaderNoData();

                using (OracleLob lob = new OracleLob(_lobLocator))
                {
                    uint valueLength = (uint)lob.Length;
                    uint sourceOffset = (uint) fieldOffset;
                    
                    if (sourceOffset > valueLength) // MDAC 72830
                        throw ADP.InvalidSourceBufferIndex((int)valueLength, (int)sourceOffset);
                    
                    byteCount = (int)(valueLength - sourceOffset);

                    if (null != destinationBuffer)
                    {
                        byteCount = Math.Min(byteCount, length);

                        if (0 < byteCount)
                        {
                            lob.Seek(sourceOffset,SeekOrigin.Begin);
                            lob.Read(destinationBuffer, destinationOffset, byteCount);
                        }
                    }
                }
            }
            else
            {
                if (OracleType.Raw != OracleType && OracleType.LongRaw != OracleType)
                    throw ADP.InvalidCast();
                
                if (IsDBNull(buffer))
                    throw ADP.DataReaderNoData();

                FixupLongValueLength(buffer);

                int valueLength = OracleBinary.GetLength(buffer, _lengthOffset, _metaType);
                int sourceOffset = (int) fieldOffset;
                
                byteCount = valueLength - sourceOffset;

                if (null != destinationBuffer)
                {
                    byteCount = Math.Min(byteCount, length);

                    if (0 < byteCount)
                        OracleBinary.GetBytes(buffer, 
                            _valueOffset, 
                            _metaType,
                            sourceOffset,
                            destinationBuffer,
                            destinationOffset,
                            byteCount);
                }
            }
            return Math.Max(0,byteCount);
        }
 
        internal long GetChars(
                        NativeBuffer buffer, 
                        long fieldOffset,
                        char[] destinationBuffer,
                        int destinationOffset,
                        int length
                        ) 
        {
            if (length < 0) // MDAC 71007
                throw ADP.InvalidDataLength(length);

            if ((destinationOffset < 0) || (null != destinationBuffer && destinationOffset >= destinationBuffer.Length)) // MDAC 71013
                throw ADP.InvalidDestinationBufferIndex(destinationBuffer.Length, destinationOffset);
            
            if (0 > fieldOffset || UInt32.MaxValue < fieldOffset)
                throw ADP.InvalidSourceOffset("fieldOffset", 0, UInt32.MaxValue);

            int charCount;

            if (IsLob)
            {
                OracleType  lobType = _metaType.OracleType;

                if (OracleType.Clob     != lobType 
                 && OracleType.NClob    != lobType 
                 && OracleType.BFile    != lobType)
                    throw ADP.InvalidCast();
                
                if (IsDBNull(buffer))
                    throw ADP.DataReaderNoData();

                using (OracleLob lob = new OracleLob(_lobLocator))
                {
                    string s = (string)lob.Value;
                    
                    int valueLength = s.Length;
                    int sourceOffset = (int) fieldOffset;
                    
                    if (sourceOffset < 0) // MDAC 72830
                        throw ADP.InvalidSourceBufferIndex(valueLength, sourceOffset);

                    charCount = (int)(valueLength - sourceOffset);

                    if (null != destinationBuffer)
                    {
                        charCount = Math.Min(charCount, length);

                        if (0 < charCount)
                        {
                            char[]  result = s.ToCharArray(sourceOffset, charCount);
                            Buffer.BlockCopy(result, 0, destinationBuffer, destinationOffset, charCount);
                        }
                    }
                }
            }
            else
            {
                if (OracleType.Char         != OracleType 
                 && OracleType.VarChar      != OracleType 
                 && OracleType.LongVarChar  != OracleType
                 && OracleType.NChar        != OracleType 
                 && OracleType.NVarChar     != OracleType)
                    throw ADP.InvalidCast();
                
                if (IsDBNull(buffer))
                    throw ADP.DataReaderNoData();

                FixupLongValueLength(buffer);

                int valueLength = OracleString.GetLength(buffer, _lengthOffset, _metaType);
                int sourceOffset = (int) fieldOffset;
                
                charCount = valueLength - sourceOffset;

                if (null != destinationBuffer)
                {
                    charCount = Math.Min(charCount, length);

                    if (0 < charCount)
                        OracleString.GetChars(buffer, 
                                                _valueOffset,
                                                _lengthOffset,
                                                _metaType,
                                                _connection,
                                                _bindAsUCS2,
                                                sourceOffset,
                                                destinationBuffer,
                                                destinationOffset,
                                                charCount);
                }

            }
            return Math.Max(0,charCount);
        }
        
        internal DateTime GetDateTime(NativeBuffer buffer)
        {
            if (IsDBNull(buffer))
                throw ADP.DataReaderNoData();

            if (typeof(DateTime) != _metaType.BaseType)
                throw ADP.InvalidCast();

            Debug.Assert(null == _longBuffer, "dangling long buffer?");
            
            DateTime result = OracleDateTime.MarshalToDateTime(buffer, _valueOffset, _metaType, _connection);
            return result;
        }

        internal decimal GetDecimal(NativeBuffer buffer)
        {
            if (typeof(decimal) != _metaType.BaseType)
                throw ADP.InvalidCast();

            if (IsDBNull(buffer))
                throw ADP.DataReaderNoData();

            Debug.Assert(null == _longBuffer, "dangling long buffer?");
            
            decimal result = OracleNumber.MarshalToDecimal(buffer, _valueOffset, _connection);
            return result;
        }

        internal double GetDouble(NativeBuffer buffer)
        {
            if (typeof(decimal) != _metaType.BaseType)
                throw ADP.InvalidCast();

            if (IsDBNull(buffer))
                throw ADP.DataReaderNoData();

            Debug.Assert(null == _longBuffer, "dangling long buffer?");
            
            decimal decimalValue = OracleNumber.MarshalToDecimal(buffer, _valueOffset, _connection);
            double result = (double)decimalValue;
            return result;
        }

        internal float GetFloat(NativeBuffer buffer)
        {
            if (typeof(decimal) != _metaType.BaseType)
                throw ADP.InvalidCast();

            if (IsDBNull(buffer))
                throw ADP.DataReaderNoData();

            Debug.Assert(null == _longBuffer, "dangling long buffer?");
            
            decimal decimalValue = OracleNumber.MarshalToDecimal(buffer, _valueOffset, _connection);
            float result = (float)decimalValue;
            return result;
        }

        internal int GetInt32(NativeBuffer buffer)
        {
            if (typeof(int) != _metaType.BaseType
             && typeof(decimal) != _metaType.BaseType)
                throw ADP.InvalidCast();

            if (IsDBNull(buffer))
                throw ADP.DataReaderNoData();

            Debug.Assert(null == _longBuffer, "dangling long buffer?");

            int result;
            
            if (typeof(int) == _metaType.BaseType)
                result = OracleMonthSpan.MarshalToInt32(buffer, _valueOffset);
            else
                result = OracleNumber.MarshalToInt32(buffer, _valueOffset, _connection);
            
            return result;
        }

        internal Int64 GetInt64(NativeBuffer buffer)
        {
            if (typeof(decimal) != _metaType.BaseType)
                throw ADP.InvalidCast();

            if (IsDBNull(buffer))
                throw ADP.DataReaderNoData();

            Debug.Assert(null == _longBuffer, "dangling long buffer?");

            Int64 result = OracleNumber.MarshalToInt64(buffer, _valueOffset, _connection);
            
            return result;
        }

        internal string GetString(NativeBuffer buffer)
        {
            if (IsLob)
            {
                OracleType  lobType = _metaType.OracleType;

                if (OracleType.Clob != lobType && OracleType.NClob != lobType && OracleType.BFile != lobType)
                    throw ADP.InvalidCast();
                
                if (IsDBNull(buffer))
                    throw ADP.DataReaderNoData();

                string result;
                
                using (OracleLob lob = new OracleLob(_lobLocator))
                {
                    result = (string)lob.Value;
                }
                return result;
            }
            else
            {
                if (typeof(string) != _metaType.BaseType)
                    throw ADP.InvalidCast();

                if (IsDBNull(buffer))
                    throw ADP.DataReaderNoData();

                FixupLongValueLength(buffer);
                
                string result = OracleString.MarshalToString(buffer, _valueOffset, _lengthOffset, _metaType, _connection, _bindAsUCS2, false);
                return result;
            }
        }
        
        internal TimeSpan GetTimeSpan(NativeBuffer buffer)
        {
            if (typeof(TimeSpan) != _metaType.BaseType)
                throw ADP.InvalidCast();

            if (IsDBNull(buffer))
                throw ADP.DataReaderNoData();

            Debug.Assert(null == _longBuffer, "dangling long buffer?");
            
            TimeSpan result = OracleTimeSpan.MarshalToTimeSpan(buffer, _valueOffset);
            return result;
        }

        internal OracleBFile GetOracleBFile(NativeBuffer buffer)
        {
            Debug.Assert(null == _longBuffer, "dangling long buffer?");
            
            if (typeof(OracleBFile) != _metaType.NoConvertType)
                throw ADP.InvalidCast();

            if (IsDBNull(buffer))
                return OracleBFile.Null;

            OracleBFile result = new OracleBFile(_lobLocator);
            return result;
        }

        internal OracleBinary GetOracleBinary(NativeBuffer buffer)
        {
            if (typeof(OracleBinary) != _metaType.NoConvertType)
                throw ADP.InvalidCast();

            FixupLongValueLength(buffer);
            
            if (IsDBNull(buffer))
                return OracleBinary.Null;

            OracleBinary result = new OracleBinary(buffer, _valueOffset, _lengthOffset, _metaType);
            return result;
        }
        
        internal OracleDateTime GetOracleDateTime(NativeBuffer buffer)
        {
            if (typeof(OracleDateTime) != _metaType.NoConvertType)
                throw ADP.InvalidCast();

            if (IsDBNull(buffer))
                return OracleDateTime.Null;

            Debug.Assert(null == _longBuffer, "dangling long buffer?");
            
            OracleDateTime result = new OracleDateTime(buffer, _valueOffset, _metaType, _connection);
            return result;
        }

        internal OracleLob GetOracleLob(NativeBuffer buffer)
        {
            if (typeof(OracleLob) != _metaType.NoConvertType)
                throw ADP.InvalidCast();

            if (IsDBNull(buffer))
                return OracleLob.Null;

            Debug.Assert(null == _longBuffer, "dangling long buffer?");
            
            OracleLob result = new OracleLob(_lobLocator);
            return result;
        }

        internal OracleMonthSpan GetOracleMonthSpan(NativeBuffer buffer)
        {
            if (typeof(OracleMonthSpan) != _metaType.NoConvertType)
                throw ADP.InvalidCast();

            if (IsDBNull(buffer))
                return OracleMonthSpan.Null;

            Debug.Assert(null == _longBuffer, "dangling long buffer?");
            
            OracleMonthSpan result = new OracleMonthSpan(buffer, _valueOffset);
            return result;
        }

        internal OracleNumber GetOracleNumber(NativeBuffer buffer)
        {
            if (typeof(OracleNumber) != _metaType.NoConvertType)
                throw ADP.InvalidCast();

            if (IsDBNull(buffer))
                return OracleNumber.Null;

            Debug.Assert(null == _longBuffer, "dangling long buffer?");
            
            OracleNumber result = new OracleNumber(buffer, _valueOffset);
            return result;
        }

        internal OracleString GetOracleString(NativeBuffer buffer)
        {
            if (typeof(OracleString) != _metaType.NoConvertType)
                throw ADP.InvalidCast();

            if (IsDBNull(buffer))
                return OracleString.Null;

            FixupLongValueLength(buffer);
            
            OracleString result = new OracleString(buffer, _valueOffset, _lengthOffset, _metaType, _connection, _bindAsUCS2, false);
            return result;
        }

        internal OracleTimeSpan GetOracleTimeSpan(NativeBuffer buffer)
        {
            if (typeof(OracleTimeSpan) != _metaType.NoConvertType)
                throw ADP.InvalidCast();

            if (IsDBNull(buffer))
                return OracleTimeSpan.Null;

            Debug.Assert(null == _longBuffer, "dangling long buffer?");
            
            OracleTimeSpan result = new OracleTimeSpan(buffer, _valueOffset);
            return result;
        }

        internal bool IsDBNull(
                NativeBuffer    buffer
                )
        {
            //  Returns true if the column value in the buffer is null.
            return (_isNullable && Marshal.ReadInt16((IntPtr)buffer.Ptr, _indicatorOffset) == (Int16)OCI.INDICATOR.ISNULL);
        }

        internal void Rebind(OracleConnection connection)
        {
            //  Here's the hook that gets called whenever we're about to fetch
            //  a new row, allowing us to reset any information that we shouldn't
            //  carry forward.
            
            switch (_metaType.OciType)
            {
            case OCI.DATATYPE.LONG:
            case OCI.DATATYPE.LONGRAW:
                Marshal.WriteInt32((IntPtr)_rowBuffer.PtrOffset(_lengthOffset), 0);
                _longLength = -1;       // reset the length to unknown;
                _longCurrentOffset  = 0;
                _longNextOffset     = 0;
                break;

            case OCI.DATATYPE.BLOB:
            case OCI.DATATYPE.CLOB:
            case OCI.DATATYPE.BFILE:
                OciLobLocator.SafeDispose(ref _lobLocator);
                _lobLocator = new OciLobLocator(connection, _metaType.OracleType);
                Marshal.WriteIntPtr((IntPtr)_rowBuffer.PtrOffset(_valueOffset), (IntPtr)_lobLocator.Handle);
                break;
            }
        }
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracleconnectionpoolcontrol.cs ===
//------------------------------------------------------------------------------
// <copyright file="OracleConnectionPoolControl.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OracleClient
{
    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.Runtime.Remoting;
    using System.Threading;
    using System.Security;
    using System.Security.Permissions;
    using System.Security.Principal;

    sealed internal class OracleConnectionPoolControl : DBObjectPoolControl {
        // connection options hashtable
        private OracleConnectionString _connectionOptions;

        // lifetime variables
        private bool     _fCheckLifetime;
        private TimeSpan _lifetime;

        public OracleConnectionPoolControl(String key, OracleConnectionString connectionOptions) : base(key)
        {
            // CreationTimeout is in milliseconds, Connection Timeout is in seconds
//          CreationTimeout     = (connectionOptions.ConnectTimeout) * 1000;
            MaxPool             = connectionOptions.MaxPoolSize;
            MinPool             = connectionOptions.MinPoolSize;
            TransactionAffinity = connectionOptions.Enlist;

            _connectionOptions = connectionOptions;

            int lifetime = connectionOptions.ConnectionLifeTime;

            // Initialize the timespan class for the pool control, if it's not zero.
            // If it was zero - that means infinite lifetime.
            if (lifetime != 0)
            {
                _fCheckLifetime = true;
                _lifetime       = new TimeSpan(0, 0, lifetime);
            }
        }

        public override DBPooledObject CreateObject(DBObjectPool p)
        {
            return (new OracleInternalConnection(_connectionOptions, p, _fCheckLifetime, _lifetime ));
        }

        public override void DestroyObject(DBObjectPool p, DBPooledObject con)
        {
            con.Close();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracleconnection.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleConnection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.Data;
	using System.Diagnostics;
	using System.EnterpriseServices;
    using System.Globalization;
	using System.Runtime.InteropServices;
    using System.Security;
	using System.Threading;
	using System.Text;

	//----------------------------------------------------------------------
	// OracleConnection
	//
	//	Implements the Oracle Connection object, which connects
	//	to the Oracle server
	//
#if V2
//	sealed public class OracleConnection : DBConnection, ICloneable, IDbConnection 
#else
    /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection"]/*' />
    [
    DefaultEvent("InfoMessage")
    ]
	sealed public class OracleConnection : Component, ICloneable, IDbConnection 
#endif
	{
        static private readonly object EventInfoMessage = new object();
        static private readonly object EventStateChange = new object();

		internal enum TransactionState
		{
			AutoCommit,			// We're currently in autocommit mode
			LocalStarted,		// Local transaction has been started, but not committed
			GlobalStarted,		// We're in a distributed (MTS) transaction
		};

		static private PermissionSet _OraclePermission;

        static internal PermissionSet OraclePermission {
            get {
                PermissionSet permission = _OraclePermission;
                if (null == permission) {
                    _OraclePermission = permission = OracleConnectionString.CreatePermission(null);
                }
                return permission;
            }
        }


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Fields 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
		private ConnectionState	        _state;						// connection state (required for IDbConnection)
		private int						_closeCount;				// used to distinguish between different uses of this object, so we don't have to have a list of it's children

		private OracleConnectionString	_parsedConnectionString;

		private OracleInternalConnection _internalConnection;

		private WeakReference			_transaction;

        private bool                	_hidePassword;				// true when we should remove the password from the connection string before returning it
		private bool					_hasStateChangeHandler;
		private TimeSpan				_serverTimeZoneAdjustment = TimeSpan.MinValue;

		private NativeBuffer			_scratchBuffer;				// for miscellaneous uses, like error handling, version strings, BFILE names..
		private Encoding				_encodingDatabase;			// will encode/decode CHAR/VARCHAR/CLOB strings
		private Encoding				_encodingNational;			// will encode/decode NCHAR/NVARCHAR/NCLOB strings
	
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Constructors 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        // Construct an "empty" connection
        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.OracleConnection1"]/*' />
		public OracleConnection()
		{
			GC.SuppressFinalize(this); // scaling performance because of ~Component
		}

        // Construct from a connection string
        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.OracleConnection2"]/*' />
		public OracleConnection( String connectionString ) : this ()
		{
			ConnectionString = connectionString;
		}
        

		// (internal) Construct from an existing Connection object (copy constructor)
		internal OracleConnection( OracleConnection connection ) : this ()
		{
			_state					= ConnectionState.Closed;
			_hidePassword			= connection._hidePassword;			
            _parsedConnectionString = connection._parsedConnectionString;
		}
        

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		internal int CloseCount
		{
			//	We use the _closeCount to avoid having to know about all our 
			//	children; instead of keeping a collection of all the objects that
			//	would be affected by a close, we simply increment the _closeCount
			//	and have each of our children check to see if they're "orphaned"
			get { return _closeCount; }
		}

        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.ConnectionString"]/*' />
        [
        OracleCategory(Res.OracleCategory_Data),
        DefaultValue(""),
        RecommendedAsConfigurable(true),
        RefreshProperties(RefreshProperties.All),
        OracleDescription(Res.OracleConnection_ConnectionString),
#if EVERETT
 		Editor("Microsoft.VSDesigner.Data.Oracle.Design.OracleConnectionStringEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
#endif //EVERETT
		]
		public string ConnectionString 
		{
			// We always parse this on set, because there isn't really a good reason not
			// to; there are too many validations and such that need to be done and there
			// isn't really a reason to delay the inevitable. The few times that consumers
			// set this twice (because they change there mind) isn't really a good reason
			// to delay it either.
			get 
			{
                bool hidePassword = _hidePassword;
                OracleConnectionString parsedConnectionString = _parsedConnectionString;
                return ((null != parsedConnectionString) ? parsedConnectionString.GetConnectionString(hidePassword) : "");
			}
			set 
			{
				lock (this) 
				{
	                if (ConnectionState.Closed != _state)
	                    throw ADP.OpenConnectionPropertySet(ADP.ConnectionString);

	                _parsedConnectionString = OracleConnectionString.ParseString(value);
	                _hidePassword = false;
                }
			}
		}

        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.ConnectionTimeout"]/*' />
		int IDbConnection.ConnectionTimeout 
		{
			//	Oracle has no discernable or settable connection timeouts, so this
			//	is being hidden from the user and we always return zero.  (We have
			//	to implement this because IDbConnection requires it)
			get { return 0; }
		}

        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.Database"]/*' />
		string IDbConnection.Database 
		{
	 		//	Oracle has no notion of a "database", so this is being hidden from
	 		//	the user and we always returns the empty string.  (We have to implement
	 		//	this because IDbConnection requires it)
			get { return String.Empty; }
		}

        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.DataSource"]/*' />
        [
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        OracleDescription(Res.OracleConnection_DataSource),
        ]
		public string DataSource
		{
			get 
			{ 
                OracleConnectionString parsedConnectionString = _parsedConnectionString;
                string value = "";
                
                if (null != parsedConnectionString) 
					value = parsedConnectionString.DataSource;

				return value;
			}
 		}

		internal OciHandle EnvironmentHandle
		{
			//	Every handle is allocated from the environment handle in some way,
			//	so we have to provide access to it internally.
			get
			{
				Debug.Assert (ConnectionState.Closed != _state, "attempting to access a closed connection's handles");
				return (null != _internalConnection) ? _internalConnection.EnvironmentHandle : null; 
			}
		}

		internal OciHandle ErrorHandle 
		{
			//	Every OCI call needs an error handle, so make it available 
			//	internally.
			get
			{
				Debug.Assert (ConnectionState.Closed != _state, "attempting to access a closed connection's handles");
				return (null != _internalConnection) ? _internalConnection.ErrorHandle : null; 
			}
		}

		internal bool HasTransaction 
		{
			get
			{
				TransactionState transactionState = TransState;
				
				bool result = ((TransactionState.LocalStarted == transactionState) || (TransactionState.GlobalStarted == transactionState));
				return result;
			}
		}

		internal NativeBuffer ScratchBuffer
       	{
            get 
            {
            	NativeBuffer scratchBuffer = _scratchBuffer;
                if (null == scratchBuffer)
                {
                	scratchBuffer = new NativeBuffer_ScratchBuffer(3970);		// 3970 is the maximum size of a persisted universal rowid
                	_scratchBuffer = scratchBuffer;
                }

                return scratchBuffer;
        	}
		}

		// TODO: consider exposing this?
        internal TimeSpan ServerTimeZoneAdjustmentToUTC
       	{
            get 
            {
                if (ConnectionState.Open != _state)
	                throw ADP.ClosedConnectionError();

            	if (! ServerVersionAtLeastOracle9i )
            		return TimeSpan.Zero;			// Oracle8i doesn't have server timezones.

            	if (TimeSpan.MinValue == _serverTimeZoneAdjustment)
        		{
	        		OracleCommand tempCommand;
    				tempCommand = CreateCommand();
        			tempCommand.Transaction = Transaction;
					tempCommand.CommandText = "select tz_offset(dbtimezone) from dual";

					string adjust = ((string)tempCommand.ExecuteScalar());
					int tzh = Int32.Parse(adjust.Substring(0,3));	// -hh
					int tzm = Int32.Parse(adjust.Substring(4,2));	// mm

					_serverTimeZoneAdjustment = new TimeSpan(tzh, tzm, 0);
        		}
                return _serverTimeZoneAdjustment;
            }
        }

        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.ServerVersion"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        OracleDescription(Res.OracleConnection_ServerVersion)
        ]
        public string ServerVersion 
       	{
            get 
            {
                if (ConnectionState.Open != _state
				 || null == _internalConnection)
	                throw ADP.ClosedConnectionError();

				return _internalConnection.ServerVersion;
            }
        }

        internal bool ServerVersionAtLeastOracle8
    	{
    		get { return (ServerVersionNumber >= 0x800000000L); }
    	}
        
        internal bool ServerVersionAtLeastOracle8i
    	{
    		get { return (ServerVersionNumber >= 0x801000000L); }
    	}
        
        internal bool ServerVersionAtLeastOracle9i
    	{
    		get { return (ServerVersionNumber >= 0x900000000L); }
    	}

        internal long ServerVersionNumber
    	{
	    	get 
	    	{
                if (ConnectionState.Open != _state
				 || null == _internalConnection)
	                throw ADP.ClosedConnectionError();

				return _internalConnection.ServerVersionNumber;
	    	}
    	}

		internal OciHandle ServiceContextHandle
		{
			//	You need to provide the service context handle to things like the
			//	OCI execute call so a statement handle can be associated with a
			//	connection.  Better make it available internally, then.
			get 
			{
				Debug.Assert (ConnectionState.Closed != _state, "attempting to access a closed connection's handles");
				return (null != _internalConnection) ? _internalConnection.ServiceContextHandle : null; 
			}
		}

		internal OciHandle SessionHandle
		{
			//	You need to provide the session handle to a few OCI calls.  Better 
			//	make it available internally, then.
			get 
			{
				Debug.Assert (ConnectionState.Closed != _state, "attempting to access a closed connection's handles");
				return (null != _internalConnection) ? _internalConnection.SessionHandle : null; 
			}
		}

        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.State"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        OracleDescription(Res.OracleConnection_State)
        ]
		public ConnectionState State 
		{
			get { return _state; }
		}
		
		internal OracleTransaction Transaction
		{
			//	In oracle, the session object controls the transaction so we keep
			//	the transaction state here as well.
			get {
				if (_transaction != null && _transaction.IsAlive)
				{
					if (null != ((OracleTransaction)_transaction.Target).Connection)
						return (OracleTransaction)_transaction.Target;

					_transaction.Target = null;
				}

				return null;
			}
			set { 
		        if (_transaction != null) 
		            _transaction.Target = (OracleTransaction)value; 
		        else
		            _transaction = new WeakReference((OracleTransaction)value);
			}
		}

		internal TransactionState TransState
		{
			//	In oracle, the session object controls the transaction so we keep
			//	the transaction state here as well.
			get { return _internalConnection.TransState; }
			set { _internalConnection.TransState = value; }
		}

		internal bool UnicodeEnabled
		{	
			get { return OCI.ClientVersionAtLeastOracle9i && (null == EnvironmentHandle || EnvironmentHandle.IsUnicode); }
		}


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.BeginTransaction1"]/*' />
		IDbTransaction IDbConnection.BeginTransaction() 
		{
			return BeginTransaction();
		}

        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.BeginTransaction3"]/*' />
		IDbTransaction IDbConnection.BeginTransaction(IsolationLevel il) 
		{
			return BeginTransaction(il);
		}		
		
        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.BeginTransaction2"]/*' />
		public OracleTransaction BeginTransaction() 
		{
			OracleConnection.OraclePermission.Demand();
			
            if (ConnectionState.Open != _state)
                throw ADP.ClosedConnectionError();
				
			if (TransactionState.AutoCommit != TransState)
				throw ADP.NoParallelTransactions();

			OracleTransaction newTransaction = new OracleTransaction(this);
			Transaction = newTransaction;
			return newTransaction; 
		}
		
        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.BeginTransaction4"]/*' />
		public OracleTransaction BeginTransaction(IsolationLevel il) 
		{
			OracleConnection.OraclePermission.Demand();
			
            if (ConnectionState.Open != _state)
                throw ADP.ClosedConnectionError();
				
			if (TransactionState.AutoCommit != TransState)
				throw ADP.NoParallelTransactions();
				
			OracleTransaction newTransaction = new OracleTransaction(this, il);
			Transaction = newTransaction;
			return newTransaction; 
		}
		
        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.ChangeDatabase"]/*' />
		void IDbConnection.ChangeDatabase(String value) 
		{
	 		//	Oracle has no notion of a "database", so this is being hidden from
	  		//	the user and we always throw.  (We have to implement this because 
	  		//	IDbConnection requires it)
			throw ADP.ChangeDatabaseNotSupported();
		}

		internal void CheckError(OciHandle errorHandle, int rc)
        {
        	// Check the return code and perform the appropriate handling; either
        	// throwing the exception or posting a warning message.
        	switch ((OCI.RETURNCODE)rc)
        	{
       		case OCI.RETURNCODE.OCI_ERROR:				// -1: Bad programming by the customer.
	        	throw ADP.OracleError(errorHandle, rc, ScratchBuffer); 

			case OCI.RETURNCODE.OCI_INVALID_HANDLE:		// -2: Bad programming on my part.
				throw ADP.InvalidOperation(Res.GetString(Res.ADP_InternalError, rc));

			case OCI.RETURNCODE.OCI_SUCCESS_WITH_INFO:	// 1: Information Message
				OracleException				infoMessage 	 = new OracleException(errorHandle, rc, ScratchBuffer);
				OracleInfoMessageEventArgs	infoMessageEvent = new OracleInfoMessageEventArgs(infoMessage);
				OnInfoMessage(infoMessageEvent);
				break;

			default:
				if (rc < 0 || rc == (int)OCI.RETURNCODE.OCI_NEED_DATA)
					throw ADP.Simple(Res.GetString(Res.ADP_UnexpectedReturnCode, rc.ToString(CultureInfo.CurrentCulture)));
				
				Debug.Assert(false, "Unexpected return code: " + rc);	 // shouldn't be here for any reason.
 				break;
        	}
		}

        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.Clone"]/*' />
        /// <internalonly/>
        object ICloneable.Clone() 
		{
			// We provide a clone that is closed; it would be very bad to hand out the
			// same handles again; instead they can do their own open and get their
			// own handles.

            OracleConnection clone = new OracleConnection(this);
            return clone;
		}

		internal void Cleanup(bool disposing, bool silent) 
		{
			//	Cleanup the connection as best we can, releasing as many objects
			//	as we can.  We use this when we fail to connect completely, when
			//	we are closing the connection, and when we're disposing of this
			//	object.

			bool fireEvent = false;

			_serverTimeZoneAdjustment = TimeSpan.MinValue;

			// Increment the close counter so the child objects can know when their
			// connection is toast (or being re-used)
			Interlocked.Increment(ref _closeCount);

			// If we're not disposing, it's because we went out of scope, and we're
			// being garbage collected.  We shouldn't touch any managed objects
			// or bad things can happen.
			if (disposing)
			{
				// We need to "dispose" of the internal connection object, either
				// by returning it to the pool (if it came from one) or by closing it
				// outright.
			    if (null != _internalConnection)
			    {
			    	if (null == _internalConnection.Pool)
			    	{
			    		// We just close the connection; there is no need to rollback
			    		// here because Oracle will do it for us.
			    		_internalConnection.Close();
			    	}
			    	else
			    	{
			    		// Before we return the connection to the pool, we rollback any 
			    		// active transaction that may have been created.  Note that we
			    		// don't bother with distributed transactions because we don't 
			    		// want to them back (it's handled by the TM).  We also don't 
			    		// worry about implicit transactions (like "select...for update") 
			    		// because we don't want to take the performance hit of the server 
			    		// round-trip when it isn't very likely.
						if (TransactionState.LocalStarted == TransState)
						{
							// On the off chance that we have some failure during rollback
							// we just eat it and make sure that the connection is doomed.
							try 
							{		
								Rollback();		
							}
							catch (Exception e)
							{
								ADP.TraceException(e);								
								_internalConnection.DoomThisConnection();
							}
						}
						OracleConnectionPoolManager.ReturnPooledConnection(_internalConnection, this);
			    	}
			    	
					_internalConnection = null;
				}

				if (null != _scratchBuffer)
				{
			   		_scratchBuffer.Dispose();
			   		_scratchBuffer = null;
				}

				// Mark this connection as closed
			    if (_state != ConnectionState.Closed)
			    {
					_state = ConnectionState.Closed;
					fireEvent = true;
			    }

		    	_encodingDatabase = null;
		    	_encodingNational = null;
		    	
			    if (fireEvent && !silent)
					OnStateChange(ConnectionState.Open, ConnectionState.Closed);                
			}
 		}

        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.Close"]/*' />
		public void Close() 
		{
			Cleanup(true, false);
 		}

		private void CloseInternal() 
		{
			Cleanup(true, true);
 		}

		internal void Commit()
		{
			if (null != _internalConnection)
				_internalConnection.Commit();
		}

        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.CreateCommand1"]/*' />
		IDbCommand IDbConnection.CreateCommand() 
		{
			return CreateCommand();
		}
		
        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.CreateCommand2"]/*' />
		public OracleCommand CreateCommand() 
		{
			OracleCommand cmd = new OracleCommand();
			cmd.Connection = this;
			return cmd;
		}

        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.Dispose"]/*' />
		override protected void Dispose(bool disposing) 
		{
			_parsedConnectionString = null;
			
			Cleanup(disposing, false);

			base.Dispose(disposing);
		}

        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.EnlistDistributedTransaction"]/*' />
        public void EnlistDistributedTransaction(ITransaction distributedTransaction)	// MDAC 82856
        {        	
        	OracleConnectionString 	parsedConnectionString = _parsedConnectionString;	// prevent race condition
        	ConnectionState			state = _state;
        	
        	//(new NamedPermissionSet("FullTrust")).Demand();	// SECURITY: Need this if we ever become semi-trusted.
        	OraclePermission.Demand();

             switch (state) {
                case ConnectionState.Closed:
                    throw ADP.ClosedConnectionError();
                    
                case ConnectionState.Open:
                    // Since in Oracle-land, the connection flows from the transaction and we don't 
                    // have a way to enlist a connection in a distributed transaction, we simply
                    // close the existing connection and open a new, transacted, one.  
                    
                    // What this means is that we'll rollback any existing local transaction, so we 
                    // need to make sure that there isn't a local transaction before we close the 
                    // connection.  Of course, if the local transaction is dead, we can roll it back
                    // first.
                    RollbackDeadTransaction();
                    
                    if (HasTransaction)
                        throw ADP.TransactionPresent();

					// Now silently close the current connection, and reopen a new distributed 
					// connection.
					if (null != distributedTransaction)
					{
						CloseInternal();
						OpenInternal(parsedConnectionString, (object)distributedTransaction);
					}
                    break;
                default:
                    Debug.Assert(false, "Invalid Connection State in OracleConnection.EnlistDistributedTransaction)");
                    break;
            }
        }

		internal byte[] GetBytes(string value, int offset, int size, bool useNationalCharacterSet)
		{
			// Return a byte array containing the value in the appropriate
			// character set form.
			Encoding	encoding = (useNationalCharacterSet) ? _encodingNational : _encodingDatabase;
			byte[] result;
			
			string		fromValue;

			if (0 == offset && 0 == size)
				fromValue = value;
			else if (0 == size || (offset+size) > value.Length)
				fromValue = value.Substring(offset);
			else
				fromValue = value.Substring(offset,size);
			
			result = encoding.GetBytes(fromValue);
			return result;
		}

		internal string GetString(IntPtr buffer, int length, bool useNationalCharacterSet)
		{
			byte[]	temp = new byte[length];
			Marshal.Copy(buffer, temp, 0, length);

			string	result;
			
			if (useNationalCharacterSet)
				result = _encodingNational.GetString(temp);
			else
				result = _encodingDatabase.GetString(temp);
			
			return result;
		}

		/// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.Open"]/*' />
		public void Open()
		{
            OracleConnectionString parsedConnectionString = _parsedConnectionString;

            OracleConnectionString.Demand(parsedConnectionString);
            		    
            if (ConnectionState.Closed != _state)
                throw ADP.ConnectionAlreadyOpen(_state);	

			OpenInternal(parsedConnectionString, null);

            OnStateChange(ConnectionState.Closed, ConnectionState.Open);
		}

		/// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.Open"]/*' />
		private void OpenInternal(OracleConnectionString parsedConnectionString, object transact)
		{
			bool isInTransaction;

			try 
			{
				try 
				{
					if (null == parsedConnectionString)
						throw ADP.NoConnectionString();

					_state = ConnectionState.Connecting;

					if (false == parsedConnectionString.Pooling || null != transact)
			            _internalConnection = new OracleInternalConnection(parsedConnectionString, transact);
					else
					{
#if ALLOWTRACING
						if (ADP._traceObjectPoolActivity) 
						{
							if (ContextUtil.IsInTransaction) 
								Debug.WriteLine("Getting Pooled Connection For TransactionId=" + ContextUtil.TransactionId + " ContextId=" + ContextUtil.ContextId);
							else
								Debug.WriteLine("Getting Pooled Connection without Transaction Context");
						}
#endif //ALLOWTRACING
				        _internalConnection = OracleConnectionPoolManager.GetPooledConnection(
				        															parsedConnectionString.EncryptedActualConnectionString,
				        															parsedConnectionString,
				        															this,
				        															out isInTransaction
				        															);

#if USEORAMTS
						// Note that we'll only have a non-null transact object when we are manually
						// enlisted -- automatically enlisted connections take a different path.
						_internalConnection.ManualEnlistedTransaction = (ITransaction)transact;
#endif //USEORAMTS
					}
					
                    _hidePassword = true;
					_state = ConnectionState.Open;
					_parsedConnectionString = parsedConnectionString;

					if (UnicodeEnabled)
						_encodingDatabase	= System.Text.Encoding.Unicode;	// for environments initialized in UTF16 mode, we can use straight Unicode
					else if (ServerVersionAtLeastOracle8i)
						_encodingDatabase	= new OracleEncoding(this);		// for Oracle8i or greater we'll use Oracle's conversion routines.
					else
						_encodingDatabase	= System.Text.Encoding.Default;	// anything prior to Oracle8i doesn't work with Oracle's conversion routines.

					_encodingNational	= System.Text.Encoding.Unicode;		// we use Unicode for the NCHAR/NVARCHAR/NCLOB and let Oracle perform the conversion automatically.
				}
				finally
				{
					if (ConnectionState.Open != _state)
					{
						Cleanup(true, true);
					}
				}
			}
            catch // Prevent exception filters from running in our space
			{
				throw;
			}
		}

		internal void Rollback()
		{
			if (null != _internalConnection)
				_internalConnection.Rollback();

			if (null != _transaction)
				_transaction.Target = null;
		}

 		internal void RollbackDeadTransaction()
    	{
    		// If our transaction has gone out of scope and has been GC'd, then we
    		// have to roll back the transaction.
    		if (null != _transaction && !_transaction.IsAlive)
				Rollback();
     	}
        
#if V2
		// DEVNOTE: these were copied from the DBConnection object, which we should derive from in V2
#else
        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.InfoMessage"]/*' />
        [
        OracleCategory(Res.OracleCategory_InfoMessage),
        OracleDescription(Res.OracleConnection_InfoMessage)
        ]
        public event OracleInfoMessageEventHandler InfoMessage {
            add {
                Events.AddHandler(EventInfoMessage, value);
            }
            remove {
                Events.RemoveHandler(EventInfoMessage, value);
            }
        }

        private void OnInfoMessage(OracleInfoMessageEventArgs infoMessageEvent) {
            OracleInfoMessageEventHandler handler = (OracleInfoMessageEventHandler) Events[EventInfoMessage];
            if (null != handler) {
                handler(this, infoMessageEvent);
            }
        }


        /// <include file='doc\OracleConnection.uex' path='docs/doc[@for="OracleConnection.StateChange"]/*' />
        [
        OracleCategory(Res.OracleCategory_StateChange),
        OracleDescription(Res.OracleConnection_StateChange)
        ]
        public event StateChangeEventHandler StateChange {
            add {
                _hasStateChangeHandler = true;
                Events.AddHandler(EventStateChange, value);
            }
            remove {
                Events.RemoveHandler(EventStateChange, value);
            }
        }

        private void OnStateChange(StateChangeEventArgs stateChangeEvent) {
            StateChangeEventHandler handler = (StateChangeEventHandler) Events[EventStateChange];
            if (null != handler) {
                handler(this, stateChangeEvent);
            }
        }

        private void OnStateChange(ConnectionState originalState, ConnectionState currentState) {
            if (_hasStateChangeHandler) {
                OnStateChange(new StateChangeEventArgs(originalState, currentState));
            }
        }
#endif //V2
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oraclecommand.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleCommand.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Data;
    using System.Data.SqlTypes;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Text;

    //----------------------------------------------------------------------
    // OracleCommand
    //
    //  Implements the IDbCommand interface
    //
    /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand"]/*' />
    [
    ToolboxItem(true),
#if EVERETT
    Designer("Microsoft.VSDesigner.Data.VS.OracleCommandDesigner, " + AssemblyRef.MicrosoftVSDesigner)
#endif //EVERETT
    ]
    sealed public class OracleCommand : Component, ICloneable, IDbCommand 
    {
#if POSTEVERETT
        internal const int ExcludeOutputParametersInReader = 0x1000;
#endif //POSTEVERETT
        
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Fields
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////

        private OracleConnection    _connection;
        private string              _commandText;
        private CommandType         _commandType = CommandType.Text;

        private OciHandle           _preparedStatementHandle;
        private int                 _preparedAtCloseCount;  // The close count of the connection; used to decide if we're zombied
        
        private OracleParameterCollection    _parameterCollection;

        private bool                _designTimeInvisible;
        private UpdateRowSource     _updatedRowSource = UpdateRowSource.Both;

        private OCI.STMT            _statementType;         // set by the Execute method, so it's only valid after that.

        private OracleTransaction   _transaction;

#if V2
        // We may want to expose these in the future, but right now, we are doing our
        // own prefetching; we can choose to expose tuning knobs that look like Oracle's,
        // or we can choose to expose our own tuning knobs, or we can do nothing.
        private int                 _prefetchMemory = 0;    // by default, we won't limit how much memory we use for prefetching
        private int                 _prefetchRows = 1000;   // if you have more than this many rows, you may not care
#endif //V2
        
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Constructor
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////

        // Construct an "empty" command
        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.OracleCommand1"]/*' />
        public OracleCommand() : base() 
        {
            GC.SuppressFinalize(this);
        }
        

        // Construct a command from a command text
        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.OracleCommand2"]/*' />
        public OracleCommand(string commandText) : this() 
        {
            CommandText = commandText;
        }
        
        // Construct a command from a command text and a connection object
        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.OracleCommand3"]/*' />
        public OracleCommand(string commandText, OracleConnection connection) : this() 
        {
            CommandText = commandText;
            Connection = connection;
        }
        
        // Construct a command from a command text, a connection object and a transaction
        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.OracleCommand4"]/*' />
        public OracleCommand(string commandText, OracleConnection connection, OracleTransaction tx) : this() 
        {
            CommandText = commandText;
            Connection = connection;
            Transaction = tx;
        }

        // (internal) Construct from an existing Command object (copy constructor)
        internal OracleCommand(OracleCommand command) : this() 
        {
            // Copy each field.
            _connection             = command._connection;
            _commandText            = command._commandText;
            _commandType            = command._commandType;
            _designTimeInvisible    = command._designTimeInvisible;
            _updatedRowSource       = command._updatedRowSource;
            _transaction            = command._transaction;
#if V2
            _prefetchMemory         = command._prefetchMemory;
            _prefetchRows           = command._prefetchRows;
#endif //V2

            if (null != command._parameterCollection && 0 < command._parameterCollection.Count)
            {
                OracleParameterCollection parameters = Parameters;
                
                foreach(ICloneable parameter in command.Parameters) 
                {
                    parameters.Add(parameter.Clone());
                }
            }
        }


        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Properties 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.CommandText"]/*' />
        [
        OracleCategory(Res.OracleCategory_Data),
        DefaultValue(""),
        OracleDescription(Res.DbCommand_CommandText),
        RefreshProperties(RefreshProperties.All),
#if EVERETT
        Editor("Microsoft.VSDesigner.Data.Oracle.Design.OracleCommandTextEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
#endif //EVERETT
        ]
        public string CommandText 
        {
            get
            { 
                string commandText = _commandText;
                return (null != commandText) ? commandText : String.Empty;
            }
            set
            { 
                if (_commandText != value)
                    {
                    PropertyChanging();
                    _commandText = value; 
                    }
            }
        }

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.CommandTimeout"]/*' />
        int IDbCommand.CommandTimeout 
        {
            //  Oracle has no discernable or settable command timeouts, so this
            //  is being hidden from the user and we always return zero.  (We have
            //  to implement this because IDbCommand requires it)
            get { return 0; }
            set {}
        }

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.CommandType"]/*' />
        [
        OracleCategory(Res.OracleCategory_Data),
        DefaultValue(System.Data.CommandType.Text),
        OracleDescription(Res.DbCommand_CommandType),
        RefreshProperties(RefreshProperties.All)
        ]
        public CommandType CommandType 
        {
            get { return _commandType; }
            set
            { 
                if (_commandType != value)
                {
                    switch(value)
                    {
                    case CommandType.StoredProcedure:
                    case CommandType.Text:
                        PropertyChanging();
                        _commandType = value;
                        break;
                        
                    case CommandType.TableDirect:
                        throw ADP.NoOptimizedDirectTableAccess();

                    default:
                        throw ADP.InvalidCommandType(value);
                    }
                }
            }
        }

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.Connection1"]/*' />
        IDbConnection IDbCommand.Connection 
        {
            get { return Connection; }
            set { Connection = (OracleConnection)value; }
        }

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.Connection2"]/*' />
        [
        OracleCategory(Res.OracleCategory_Behavior),
        DefaultValue(null),
        OracleDescription(Res.DbCommand_Connection),
#if EVERETT
        Editor("Microsoft.VSDesigner.Data.Design.DbConnectionEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
#endif //EVERETT
        ]
        public OracleConnection Connection 
        {
            get { return _connection; }
            set
            {
                if (_connection != value)
                    {
                    PropertyChanging();                 
                    _connection = value;
                    }
            }
        }
        private bool ConnectionIsClosed 
        {
            //  TRUE when the parent connection object has been closed
            get
            {
                OracleConnection conn = Connection;
                return (null == conn) || (ConnectionState.Closed == conn.State);    
            }
        }

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.DesignTimeVisible"]/*' />
        [
        DefaultValue(true),
        DesignOnly(true),
        Browsable(false),
        ]
        public bool DesignTimeVisible
        {
            get { return !_designTimeInvisible; }
            set
            {
                _designTimeInvisible = !value;
                TypeDescriptor.Refresh(this);
            }
        }
        
        private OciHandle EnvironmentHandle 
        {
            //  Simplify getting the EnvironmentHandle
            get { return _connection.EnvironmentHandle; }
        }

        private OciHandle ErrorHandle 
        {
            //  Every OCI call needs an error handle, so make it available internally.
            get { return _connection.ErrorHandle; }
        }

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.Parameters1"]/*' />
        IDataParameterCollection IDbCommand.Parameters 
        {
            get { return Parameters; }
        }

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.Parameters2"]/*' />
        [
        OracleCategory(Res.OracleCategory_Data),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Content),
#if EVERETT
        OracleDescription(Res.DbCommand_Parameters)
#endif //EVERETT
        ]
        public OracleParameterCollection Parameters 
        {
            get 
            {
                if (null == _parameterCollection)
                {
                    _parameterCollection = new OracleParameterCollection();
                }
                return _parameterCollection;
            }
        }

#if V2
        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.PrefetchMemory"]/*' />
        public int PrefetchMemory 
        {
            get { return _prefetchMemory; }
            set { _prefetchMemory = value; }
        }

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.PrefetchRows"]/*' />
        public int PrefetchRows 
        {
            get { return _prefetchRows; }
            set { _prefetchRows = value; }
        }
#endif //V2

        private OciHandle ServiceContextHandle 
        {
            //  Simplify getting the ServiceContextHandle
            get { return _connection.ServiceContextHandle; }
        }

        private string StatementText 
        {
            //  Combine the CommandType and CommandText into the statement that
            //  needs to be passed to Oracle.
            get 
            {
                string statementText = null;

                if (null == _commandText || String.Empty == _commandText)
                    throw ADP.NoCommandText();
                
                switch(CommandType)
                {
                case CommandType.StoredProcedure:
                    {
                    StringBuilder builder = new StringBuilder();

                    builder.Append("begin ");

                    int     parameterCount = Parameters.Count;
                    int     parameterUsed = 0;
                    
                    // Look for the return value:
                    for (int i=0; i < parameterCount; ++i)
                    {
                        OracleParameter parameter = Parameters[i];
                        
                        if (ADP.IsDirection(parameter, ParameterDirection.ReturnValue))
                        {
                            builder.Append(":");
                            builder.Append(parameter.ParameterName);
                            builder.Append(" := ");
                        }
                    }

                    builder.Append(_commandText);

                    string  separator = "(";

                    for (int i=0; i < parameterCount; ++i)
                    {
                        OracleParameter parameter = Parameters[i];

                        if (ADP.IsDirection(parameter, ParameterDirection.ReturnValue))
                            continue;   // already did this one...

                        if ( !ADP.IsDirection(parameter, ParameterDirection.Output) && null == parameter.Value)
                            continue;   // don't include parameters where the user asks for the default value.
                        
                        // If the input-only parameter value is C# null, that's our "clue" that they
                        // wish to use the default value.
                        if (null != parameter.Value || ADP.IsDirection(parameter, ParameterDirection.Output))
                        {
                            builder.Append(separator);
                            separator = ", ";
                            parameterUsed++;

                            builder.Append(parameter.ParameterName);    // TODO: investigate the use of SourceColumn as the argument name in the CommandBuilder and here.
                            builder.Append("=>:");
                            builder.Append(parameter.ParameterName);
                        }
                    }

                    if (0 != parameterUsed)
                        builder.Append("); end;");
                    else
                        builder.Append("; end;");

                    statementText = builder.ToString();
                    }
                    break;

                case CommandType.Text:
                    statementText = _commandText;
                    break;

                default:
                    Debug.Assert(false, "command type of "+CommandType+" is not supported");
                    break;
                }
                return statementText; 
            }
        }

        internal OCI.STMT StatementType 
        {
            get { return _statementType; }
        }

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.Transaction"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        OracleDescription(Res.DbCommand_Transaction)
        ]
        public OracleTransaction Transaction {
            //  Apparently, Yukon intends to move transaction support to the command
            //  object and has requested that IDbCommand have a transaction property
            //  to support that.
            get {
                // if the transaction object has been zombied, just return null
                if ((null != _transaction) && (null == _transaction.Connection)) { // MDAC 72720
                    _transaction = null;
                }
                return _transaction;
            }
            set { _transaction = value; }
        }

        IDbTransaction IDbCommand.Transaction {
            get { return Transaction; }
            set { Transaction = (OracleTransaction) value; }
        }

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.UpdatedRowSource"]/*' />
        [
        OracleCategory(Res.OracleCategory_Behavior),
        DefaultValue(System.Data.UpdateRowSource.Both),
        OracleDescription(Res.DbCommand_UpdatedRowSource)
        ]
        public UpdateRowSource UpdatedRowSource
        {
            get 
            {
                return _updatedRowSource;
            }
            set 
            {
                switch(value) 
                {
                case UpdateRowSource.None:
                case UpdateRowSource.OutputParameters:
                case UpdateRowSource.FirstReturnedRecord:
                case UpdateRowSource.Both:
                    _updatedRowSource = value;
                    break;
                default:
                    throw ADP.InvalidUpdateRowSource((int) value);
                }
            }
        }



        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Methods 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////


        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.Cancel"]/*' />
        public void Cancel() 
        {
            // see if we have a connection
            if (null == _connection)
                throw ADP.ConnectionRequired("Cancel");
            
            // must have an open and available connection
            if (ConnectionState.Open != _connection.State)
                throw ADP.OpenConnectionRequired("Cancel", _connection.State);

            // According to EdTriou: Cancel is meant to cancel firehose cursors only,
            // not to cancel the execution of a statement.  Given that for Oracle, you
            // don't need to tell the server you don't want any more results, it would
            // seem that this is unnecessary, so I'm commenting it out until someone
            // comes up with a reason for it.
#if UNUSED
            int rc = TracedNativeMethods.OCIBreak(
                                        ServiceContextHandle.Handle,
                                        ErrorHandle.Handle
                                        );
                
            if (0 != rc)
                Connection.CheckError(ErrorHandle, rc);
#endif //
        }

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.Clone"]/*' />
        public object Clone() 
        {
            OracleCommand clone = new OracleCommand(this);
            return clone;
        }

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.CreateParameter1"]/*' />
        IDbDataParameter IDbCommand.CreateParameter() 
        {
            return CreateParameter();
        }

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.CreateParameter2"]/*' />
        public OracleParameter CreateParameter() 
        {
            return new OracleParameter();
        }

        internal void Execute(
                    OciHandle       statementHandle,
                    CommandBehavior behavior,
                    bool            needRowid,
                    out OciHandle   rowidDescriptor
                    ) 
        {
            ArrayList   temp;
            Execute(statementHandle, behavior, false, needRowid, out rowidDescriptor, out temp);
            Debug.Assert(null == temp, "created the parameter ordinal list when requested not to?");
        }
        
        internal void Execute(
                    OciHandle       statementHandle,
                    CommandBehavior behavior,
                    out ArrayList   refCursorParameterOrdinals
                    ) 
        {
            OciHandle   temp1;
            Execute(statementHandle, behavior, true, false, out temp1, out refCursorParameterOrdinals);
        }
        
        internal void Execute(
                    OciHandle       statementHandle,
                    CommandBehavior behavior,
                    bool            isReader,
                    bool            needRowid,
                    out OciHandle   rowidDescriptor,
                    out ArrayList   refCursorParameterOrdinals
                    ) 
        {
            //  common routine used to execute all statements
            
            if (ConnectionIsClosed)
                throw ADP.ClosedConnectionError();
            
            // throw if the connection is in a transaction but there is no
            // locally assigned transaction object
            if ((null == _transaction) && (null != Connection.Transaction))
                throw ADP.TransactionRequired();                

            // if we have a transaction, check to ensure that the active
            // connection property matches the connection associated with
            // the transaction
            if ((null != _transaction) && (null != _transaction.Connection) && (Connection != _transaction.Connection))
                throw ADP.TransactionConnectionMismatch();

            rowidDescriptor = null;

            // if the connection has a command but it went out of scope, we need
            // to roll it back.  We do this here instead of in the transaction
            // objects finalizer because it doesn't really matter when it gets 
            // done, just as long as it is before the next command executes, and
            // it's easier to do it in the command object, than in the object
            // that is being finalized.
            Connection.RollbackDeadTransaction();

            int                         rc = 0;
            NativeBuffer                parameterBuffer = null;
            short                       tempub2;
            int                         iterations;
            OracleParameterBinding[]    parameterBinding = null;
                
            refCursorParameterOrdinals = null;

            try 
            {
                try 
                {
                    // If we've already sent the statement to the server, then we don't need
                    // to prepare it again...
                    if (_preparedStatementHandle != statementHandle)
                    {
                        string statementText = StatementText;

                        rc = TracedNativeMethods.OCIStmtPrepare(
                                                statementHandle,
                                                ErrorHandle,
                                                statementText,
                                                statementText.Length,
                                                OCI.SYNTAX.OCI_NTV_SYNTAX,
                                                OCI.MODE.OCI_DEFAULT,
                                                Connection
                                                );
                        
                        if (0 != rc)
                            Connection.CheckError(ErrorHandle, rc);
                    }

                    // Figure out what kind of statement we're dealing with and pick the
                    // appropriate iteration count.
                    statementHandle.GetAttribute(OCI.ATTR.OCI_ATTR_STMT_TYPE, out tempub2, ErrorHandle);
                    _statementType = (OCI.STMT)tempub2;
                    
                    if (OCI.STMT.OCI_STMT_SELECT != _statementType)
                        iterations = 1;
                    else
                    {
                        iterations = 0;
                        
                        if (CommandBehavior.SingleRow != behavior)
                        {
        #if V2
                            int rows = PrefetchRows;
                            int memory = PrefetchMemory;

                            statementHandle.SetAttribute(OCI.ATTR.OCI_ATTR_PREFETCH_ROWS,   rows,   ErrorHandle);
                            statementHandle.SetAttribute(OCI.ATTR.OCI_ATTR_PREFETCH_MEMORY, memory, ErrorHandle);
        #else //!V2
                            // We're doing our own "prefetching" to avoid double copies, so we 
                            // need to turn off Oracle's or it won't really help.
                            statementHandle.SetAttribute(OCI.ATTR.OCI_ATTR_PREFETCH_ROWS,   0,  ErrorHandle);
                            statementHandle.SetAttribute(OCI.ATTR.OCI_ATTR_PREFETCH_MEMORY, 0,  ErrorHandle);
        #endif //!V2
                        }
                    }

                    // Pick the execution mode we need to use
                    OCI.MODE        executeMode = OCI.MODE.OCI_DEFAULT;

                    if (0 == iterations)
                    {
                        if (IsBehavior(behavior, CommandBehavior.SchemaOnly))
                        {
                            // If we're only supposed to "describe" the data columns for the rowset, then
                            // use the describe only execute mode
                            executeMode |= OCI.MODE.OCI_DESCRIBE_ONLY;
                        }
                    }
                    else
                    {
                        if (OracleConnection.TransactionState.AutoCommit == _connection.TransState)
                        {
                            // If we're in autocommit mode, then we have to tell Oracle to automatically
                            // commit the transaction it automatically created.
                            executeMode |= OCI.MODE.OCI_COMMIT_ON_SUCCESS;
                        }
                        else if (OracleConnection.TransactionState.GlobalStarted != _connection.TransState)
                        {
                            // If we're not in "auto commit mode" then we can presume that Oracle
                            // will automatically start a transaction, so we need to keep track
                            // of that.
                            _connection.TransState = OracleConnection.TransactionState.LocalStarted;
                        }
                    }

                    
                    // Bind all the parameter values, unless we're just looking for schema info
                    if (0 == (executeMode & OCI.MODE.OCI_DESCRIBE_ONLY))
                    {
                        if (null != _parameterCollection && _parameterCollection.Count > 0)
                        {
                            int parameterBufferLength = 0;
                            int length = _parameterCollection.Count;

                            parameterBinding = new OracleParameterBinding[length];
                            
                            for (int i = 0; i < length; ++i)
                            {
                                parameterBinding[i] = new OracleParameterBinding(this, _parameterCollection[i]);
                                parameterBinding[i].PrepareForBind( _connection, ref parameterBufferLength );

                                // If this is a ref cursor parameter that we're supposed to include
                                // in the data reader, then add it to our list of those.
                                if (isReader 
#if POSTEVERETT
                                    && 0 == ((int)behavior & ExcludeOutputParametersInReader)
#endif //POSTEVERETT
                                    && OracleType.Cursor == _parameterCollection[i].OracleType)
                                {
                                    if (null == refCursorParameterOrdinals)
                                        refCursorParameterOrdinals = new ArrayList();
                                    
                                    refCursorParameterOrdinals.Add(i);
                                }
                            }

                            parameterBuffer = new NativeBuffer_ParameterBuffer(parameterBufferLength);
                            
                            for (int i = 0; i < length; ++i)
                            {
                                parameterBinding[i].Bind( statementHandle, parameterBuffer, _connection );
                            }
                        }
                    }

                    // OK, now go ahead and execute
                    rc = TracedNativeMethods.OCIStmtExecute(
                                            ServiceContextHandle,   // svchp
                                            statementHandle,        // stmtp
                                            ErrorHandle,            // errhp
                                            iterations,             // iters
                                            0,                      // rowoff
                                            ADP.NullHandleRef,      // snap_in
                                            ADP.NullHandleRef,      // snap_out
                                            executeMode             // mode
                                            );

                    if (0 != rc)
                        Connection.CheckError(ErrorHandle, rc);

                    // and now, create the output parameter values
                    if (null != parameterBinding)
                    {
                        int length = parameterBinding.Length;
                        
                        for (int i = 0; i < length; ++i)
                        {
                            parameterBinding[i].PostExecute( parameterBuffer, _connection );
                            parameterBinding[i].Dispose();
                            parameterBinding[i] = null;
                        }
                        parameterBinding = null;
                    }

                    if (needRowid && 0 == (executeMode & OCI.MODE.OCI_DESCRIBE_ONLY))
                    {
                        switch (_statementType)
                        {
                            case OCI.STMT.OCI_STMT_UPDATE:
                            case OCI.STMT.OCI_STMT_DELETE:
                            case OCI.STMT.OCI_STMT_INSERT:
                                rowidDescriptor = statementHandle.GetRowid(EnvironmentHandle, ErrorHandle);
                                break;

                            default:
                                rowidDescriptor = null;
                                break;
                        }
                    }
                }
                finally
                {
                    if (null != parameterBuffer)
                    {
                        // We're done with these, get rid of them.
                        parameterBuffer.Dispose();
                        parameterBuffer = null;
                    }

                    // and now, create the output parameter values
                    if (null != parameterBinding)
                    {
                        int length = parameterBinding.Length;
                        
                        for (int i = 0; i < length; ++i)
                        {
                            if (null != parameterBinding[i]) 
                            {
                                parameterBinding[i].Dispose();
                                parameterBinding[i] = null;
                            }
                        }
                        parameterBinding = null;
                    }

                }
            }
            catch // Prevent exception filters from running in our space
            {
                throw;
            }
        }

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.ExecuteNonQuery"]/*' />
        public int ExecuteNonQuery() 
        {
            OracleConnection.OraclePermission.Demand();

            OciHandle   temp = null;
            int         result = ExecuteNonQueryInternal(false, out temp);
            OciHandle.SafeDispose(ref temp);    // shouldn't be necessary, but just in case...
            return result;
        }

        private int ExecuteNonQueryInternal(bool needRowid, out OciHandle rowidDescriptor)
        {
            OciHandle   statementHandle = null;
            int         rowcount = -1;

            try 
            {
                try 
                {
                    statementHandle = GetStatementHandle(); 
                    Execute( statementHandle, CommandBehavior.Default, needRowid, out rowidDescriptor );

                    if (OCI.STMT.OCI_STMT_SELECT != _statementType)
                        statementHandle.GetAttribute(OCI.ATTR.OCI_ATTR_ROW_COUNT, out rowcount, ErrorHandle);
                }
                finally
                {
                    if (null != statementHandle)
                        ReleaseStatementHandle(statementHandle);
                }
            }
            catch // Prevent exception filters from running in our space
            {
                throw;
            }
        
            return rowcount;
        }

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.ExecuteOracleNonQuery"]/*' />
        public int ExecuteOracleNonQuery(out OracleString rowid)
        {
            OracleConnection.OraclePermission.Demand();

            OciHandle   rowidDescriptor = null;
            int         result = ExecuteNonQueryInternal(true, out rowidDescriptor);
            rowid = GetPersistedRowid( Connection, rowidDescriptor );
            OciHandle.SafeDispose(ref rowidDescriptor);
            return result;
        }
        
        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.ExecuteOracleScalar"]/*' />
        public object ExecuteOracleScalar()
        {
            OracleConnection.OraclePermission.Demand();

            OciHandle   temp = null;
            object      result = ExecuteScalarInternal(false, false, out temp);
            OciHandle.SafeDispose(ref temp);    // shouldn't be necessary, but just in case...
            return result;
        }
        
        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.ExecuteReader1"]/*' />
        IDataReader IDbCommand.ExecuteReader() 
        {
            return ExecuteReader();
        }

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.ExecuteReader2"]/*' />
        public OracleDataReader ExecuteReader() 
        {
            return ExecuteReader(CommandBehavior.Default);
        }

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.ExecuteReader3"]/*' />
        IDataReader IDbCommand.ExecuteReader(CommandBehavior behavior)
        {
            return ExecuteReader(behavior);
        }

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.ExecuteReader4"]/*' />
        public OracleDataReader ExecuteReader(CommandBehavior behavior) 
        {
            OracleConnection.OraclePermission.Demand();

            OciHandle           statementHandle = null;;
            OracleDataReader    reader = null;
            ArrayList           refCursorParameterOrdinals = null;
            
            try 
            {
                try 
                {
                    statementHandle = GetStatementHandle();
                    
                    Execute( statementHandle, behavior, out refCursorParameterOrdinals);
                    

                    // We're about to handle the prepared statement handle (if there was one)
                    // to the data reader object; so we can't really hold on to it any longer.
                    if (statementHandle == _preparedStatementHandle)
                    {
                        // Don't dispose the handle, we still need it!  just make our reference to it null.
                        _preparedStatementHandle = null;
                        // TODO: see if we can avoid having to "unprepare" this command -- can the datareader put the statementHandle back when it's done?
                    }

                    if (null == refCursorParameterOrdinals)
                        reader = new OracleDataReader(this, statementHandle, StatementText, behavior);
                    else
                        reader = new OracleDataReader(this, refCursorParameterOrdinals, StatementText, behavior);
                }
                finally
                {
                    // if we didn't hand the statement to a reader, then release it
                    if (null != statementHandle && (null == reader ||null != refCursorParameterOrdinals))
                        ReleaseStatementHandle(statementHandle);
                }
            }
            catch // Prevent exception filters from running in our space
            {
                throw;
            }
            return reader;
        }
        
        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.ExecuteScalar"]/*' />
        public object ExecuteScalar() 
        {
            OracleConnection.OraclePermission.Demand();

            OciHandle   temp;
            object result = ExecuteScalarInternal(true, false, out temp);
            OciHandle.SafeDispose(ref temp);    // shouldn't be necessary, but just in case...
            return result;
        }

        private object ExecuteScalarInternal(
                                bool needCLStype, 
                                bool needRowid, 
                                out OciHandle rowidDescriptor
                                )
        {
            OciHandle   statementHandle = null;
            object      result = null;
            int         rc = 0;

            try 
            {
                try 
                {
                    statementHandle = GetStatementHandle();
                    
                    Execute( statementHandle, CommandBehavior.Default, needRowid, out rowidDescriptor );

                    if (OCI.STMT.OCI_STMT_SELECT == _statementType)
                    {
                        // We only care about one column; Oracle will handle the fact that the
                        // rest aren't define so don't bother allocating and gathering more column
                        // information than we need.
                        OracleColumn    column = new OracleColumn(statementHandle, 0, ErrorHandle, _connection);
                        NativeBuffer    columnBuffer = _connection.ScratchBuffer;
                        int             columnBufferLength = 0;

                        column.Describe(ref columnBufferLength, _connection, ErrorHandle);

                        if (columnBuffer.Length < columnBufferLength)
                            columnBuffer.Length = columnBufferLength;

                        column.Bind(statementHandle, columnBuffer, ErrorHandle, 0);
                        column.Rebind(_connection);

                        // Now fetch one row into the buffer we've provided
                        rc = TracedNativeMethods.OCIStmtFetch(
                                                statementHandle,            // stmtp
                                                ErrorHandle,                // errhp
                                                1,                          // crows
                                                OCI.FETCH.OCI_FETCH_NEXT,   // orientation
                                                OCI.MODE.OCI_DEFAULT        // mode
                                                );
                        if ((int)OCI.RETURNCODE.OCI_NO_DATA != rc)
                        {
                            if (0 != rc)
                                Connection.CheckError(ErrorHandle, rc);

                            
                            // Ask the column for the object value (we need to get the Value from
                            // the object to ensure that we have a URT type object, not an Oracle
                            // type object)
                            if (needCLStype)
                                result = column.GetValue(columnBuffer);
                            else
                                result = column.GetOracleValue(columnBuffer);
                        }                   
                        GC.KeepAlive(column);
                        GC.KeepAlive(columnBuffer);
                    }
                }
                finally
                {
                    if (null != statementHandle)
                        ReleaseStatementHandle(statementHandle);
                }
            }
            catch // Prevent exception filters from running in our space
            {
                throw;
            }
            return result;
        }
    
        static internal OracleString GetPersistedRowid(
                            OracleConnection    connection,
                            OciHandle   rowidHandle
                            )
        {
            //  This method returns an OracleString that holds the base64 string
            //  representation of the rowid, which can be persisted past the lifetime
            //  of this process.

            OracleString result = OracleString.Null;
            
            if (null == rowidHandle) 
                goto done;  // null if there isn't a rowid!

            OciHandle       errorHandle          = connection.ErrorHandle;
            NativeBuffer    rowidBuffer = connection.ScratchBuffer; 
            HandleRef       buffer = rowidBuffer.Ptr;
            int             rc;

            Debug.Assert(rowidBuffer.Length >= 3970, "scratchpad buffer is too small");
            
            if (OCI.ClientVersionAtLeastOracle9i)
            {
                short bufferLength = (short)rowidBuffer.Length;
                
                rc = TracedNativeMethods.OCIRowidToChar(rowidHandle,
                                                    buffer,
                                                    ref bufferLength,
                                                    errorHandle
                                                    );
                if (0 != rc)
                    connection.CheckError(errorHandle, rc);

                string stringValue = Marshal.PtrToStringAnsi((IntPtr)buffer, bufferLength); // ROWID's always come back as Ansi...

                result = new OracleString(stringValue);
            }
            else
            {
                OciHandle       environmentHandle    = connection.EnvironmentHandle;
                OciHandle       serviceContextHandle = connection.ServiceContextHandle;

                OciHandle       tempHandle = environmentHandle.CreateOciHandle(OCI.HTYPE.OCI_HTYPE_STMT);
                string          tempText = "begin :rowid := :rdesc; end;";
                int             rdescIndicatorOffset= 0;
                int             rdescLengthOffset   = 4;
                int             rdescValueOffset    = 8;
                int             rowidIndicatorOffset= 12;
                int             rowidLengthOffset   = 16;
                int             rowidValueOffset    = 20;

                try 
                {
                    try 
                    {
                        rc = TracedNativeMethods.OCIStmtPrepare(
                                                tempHandle,
                                                errorHandle,
                                                tempText,
                                                tempText.Length,
                                                OCI.SYNTAX.OCI_NTV_SYNTAX,
                                                OCI.MODE.OCI_DEFAULT,
                                                connection
                                                );
                        if (0 != rc)
                            connection.CheckError(errorHandle, rc);

                        IntPtr h1;
                        IntPtr h2;

                        // Need to clean these out, since we're re-using the scratch buffer, which
                        // the prepare uses to convert the statement text.
                        Marshal.WriteIntPtr((IntPtr)buffer, rdescValueOffset,       (IntPtr)rowidHandle.Handle);
                        Marshal.WriteInt32 ((IntPtr)buffer, rdescIndicatorOffset,   0);
                        Marshal.WriteInt32 ((IntPtr)buffer, rdescLengthOffset,      4);
                        Marshal.WriteInt32 ((IntPtr)buffer, rowidIndicatorOffset,   0);
                        Marshal.WriteInt32 ((IntPtr)buffer, rowidLengthOffset,      3950);

                        rc = TracedNativeMethods.OCIBindByName(
                                        tempHandle,
                                        out h1,
                                        errorHandle,
                                        "rowid",
                                        5,
                                        rowidBuffer.PtrOffset(rowidValueOffset),
                                        3950,
                                        OCI.DATATYPE.VARCHAR2,
                                        rowidBuffer.PtrOffset(rowidIndicatorOffset),
                                        rowidBuffer.PtrOffset(rowidLengthOffset),
                                        ADP.NullHandleRef,
                                        0,
                                        ADP.NullHandleRef,
                                        OCI.MODE.OCI_DEFAULT
                                        );
                        if (0 != rc)
                            connection.CheckError(errorHandle, rc);

                        rc = TracedNativeMethods.OCIBindByName(
                                        tempHandle,
                                        out h2,
                                        errorHandle,
                                        "rdesc",
                                        5,
                                        rowidBuffer.PtrOffset(rdescValueOffset),
                                        4,
                                        OCI.DATATYPE.ROWID_DESC,
                                        rowidBuffer.PtrOffset(rdescIndicatorOffset),
                                        rowidBuffer.PtrOffset(rdescLengthOffset),
                                        ADP.NullHandleRef,
                                        0,
                                        ADP.NullHandleRef,
                                        OCI.MODE.OCI_DEFAULT
                                        );
                        if (0 != rc)
                            connection.CheckError(errorHandle, rc);

                        rc = TracedNativeMethods.OCIStmtExecute(
                                                serviceContextHandle,   // svchp
                                                tempHandle,             // stmtp
                                                errorHandle,            // errhp
                                                1,                      // iters
                                                0,                      // rowoff
                                                ADP.NullHandleRef,      // snap_in
                                                ADP.NullHandleRef,      // snap_out
                                                OCI.MODE.OCI_DEFAULT    // mode
                                                );
                        
                        if (0 != rc)
                            connection.CheckError(errorHandle, rc);

                        if (Marshal.ReadInt16((IntPtr)buffer, rowidIndicatorOffset) == (Int16)OCI.INDICATOR.ISNULL)
                            goto done;

                        result = new OracleString(
                                                rowidBuffer, 
                                                rowidValueOffset, 
                                                rowidLengthOffset, 
                                                MetaType.GetMetaTypeForType(OracleType.RowId), 
                                                connection,
                                                false,   // it's not unicode!
                                                true
                                                );
                        GC.KeepAlive(rowidHandle);
                    }
                    finally 
                    {
                        OciHandle.SafeDispose(ref tempHandle);
                    }
                }
                catch // Prevent exception filters from running in our space
                {
                    throw;
                }
            }

        done:
            return result;
        }

        private OciHandle GetStatementHandle()
        {
            //  return either the prepared statement handle or a new one if nothign
            //  is prepared.
            
            if (ConnectionIsClosed)
                throw ADP.ClosedConnectionError();

            if (null != _preparedStatementHandle)
            {
                // When we prepare the statement, we keep track of it's closed
                // count; if the connection has been closed since we prepared, then
                // the statement handle is no longer valid and must be tossed.
                if (_connection.CloseCount == _preparedAtCloseCount)
                    return _preparedStatementHandle;
                
                _preparedStatementHandle.Dispose();
                _preparedStatementHandle = null;
            }
            return EnvironmentHandle.CreateOciHandle(OCI.HTYPE.OCI_HTYPE_STMT);
        }

        static internal bool IsBehavior(CommandBehavior value, CommandBehavior condition)
        {
            return (condition == (condition & value));
        }

        /// <include file='doc\OracleCommand.uex' path='docs/doc[@for="OracleCommand.Prepare"]/*' />
        public void Prepare() 
        {
            OracleConnection.OraclePermission.Demand();

            if (ConnectionIsClosed)
                throw ADP.ClosedConnectionError();
            
            if (CommandType.Text == CommandType)
            {
                OciHandle   preparedStatementHandle = GetStatementHandle();
                int         preparedAtCloseCount = _connection.CloseCount;
                string      statementText = StatementText;

                int rc = TracedNativeMethods.OCIStmtPrepare(
                                            preparedStatementHandle,
                                            ErrorHandle,
                                            statementText,
                                            statementText.Length,
                                            OCI.SYNTAX.OCI_NTV_SYNTAX,
                                            OCI.MODE.OCI_DEFAULT,
                                            Connection
                                            );
                
                if (0 != rc)
                    Connection.CheckError(ErrorHandle, rc);

                short   tempub2;
                
                preparedStatementHandle.GetAttribute(OCI.ATTR.OCI_ATTR_STMT_TYPE, out tempub2, ErrorHandle);
                _statementType = (OCI.STMT)tempub2;
                
                if (OCI.STMT.OCI_STMT_SELECT == _statementType) 
                {
                    rc = TracedNativeMethods.OCIStmtExecute(
                                        _connection.ServiceContextHandle,
                                                                    // svchp
                                        preparedStatementHandle,    // stmtp
                                        ErrorHandle,                // errhp
                                        0,                          // iters
                                        0,                          // rowoff
                                        ADP.NullHandleRef,          // snap_in
                                        ADP.NullHandleRef,          // snap_out
                                        OCI.MODE.OCI_DESCRIBE_ONLY  // mode
                                        );

                    if (0 != rc)
                        Connection.CheckError(ErrorHandle, rc);
                }

                if (preparedStatementHandle != _preparedStatementHandle)
                    OciHandle.SafeDispose(ref _preparedStatementHandle);
                
                _preparedStatementHandle = preparedStatementHandle;
                _preparedAtCloseCount = preparedAtCloseCount;
                
            }
            else if (null != _preparedStatementHandle)
            {
                OciHandle.SafeDispose(ref _preparedStatementHandle);
            }
        }

        private void PropertyChanging()
        {
            //  common routine used to get rid of a statement handle; it disposes
            //  of the handle unless it's the prepared handle
            
            if (null != _preparedStatementHandle)
            {
                _preparedStatementHandle.Dispose(); // the existing prepared statement is no longer valid
                _preparedStatementHandle = null;
            }
        }

        private void ReleaseStatementHandle (
                    OciHandle statementHandle
                    )
        {
            //  common routine used to get rid of a statement handle; it disposes
            //  of the handle unless it's the prepared handle
            
            if (_preparedStatementHandle != statementHandle)
            {
                OciHandle.SafeDispose(ref statementHandle);
            }
        }

    };
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oraclecategory.cs ===
//------------------------------------------------------------------------------
// <copyright file="OracleCategoryAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OracleClient {

    using System;
    using System.ComponentModel;   
    using System.Diagnostics;

    /// <include file='doc\OracleCategoryAttribute.uex' path='docs/doc[@for="OracleCategoryAttribute"]/*' />
    [AttributeUsage(AttributeTargets.All)]
    internal sealed class OracleCategoryAttribute : CategoryAttribute {

        /// <include file='doc\OracleCategoryAttribute.uex' path='docs/doc[@for="OracleCategoryAttribute.OracleCategoryAttribute"]/*' />
        public OracleCategoryAttribute(string category) : base(category) {
        }

        /// <include file='doc\OracleCategoryAttribute.uex' path='docs/doc[@for="OracleCategoryAttribute.GetLocalizedString"]/*' />
        protected override string GetLocalizedString(string value) {
            string localizedValue = Res.GetString(value);
            Debug.Assert(localizedValue != null, "All data category attributes should have localized strings.  Category '" + value + "' not found.");
            return localizedValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracleencoding.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleEncoding.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Diagnostics;
	using System.Runtime.InteropServices;
	using System.Text;

	//----------------------------------------------------------------------
	// OracleEncoding
	//
	//	Implements an Encoding Scheme that works with Oracle's conversions
	//	for the database character set.
	//
	sealed internal class OracleEncoding : Encoding
	{
		OracleConnection _connection;

		internal OciHandle Handle
		{
			get 
			{
		        OciHandle	ociHandle = _connection.SessionHandle;

		        if (null == ociHandle || IntPtr.Zero == (IntPtr)ociHandle.Handle)
		        	ociHandle = _connection.EnvironmentHandle;

				return ociHandle;
			}
		}
		
		public OracleEncoding(OracleConnection connection) : base()
		{
			_connection = connection;
		}
	
		public override int GetByteCount(char[] chars, int index, int count) 
		{
			int byteCount = GetBytes(chars, index, count, null, 0);
			return byteCount;
		}

		public override int GetBytes(char[] chars, int charIndex, int charCount,
            byte[] bytes, int byteIndex) 
		{
			OciHandle	ociHandle = Handle;
			int			byteCount = ociHandle.GetBytes(chars, charIndex, charCount, bytes, byteIndex);
			return byteCount;
        }

		public override int GetCharCount(byte[] bytes, int index, int count) 
		{
			int charCount = GetChars(bytes, index, count, null, 0);
			return charCount;
		}

		public override int GetChars(byte[] bytes, int byteIndex, int byteCount,
            char[] chars, int charIndex) 
		{
			OciHandle	ociHandle = Handle;
			int			charCount = ociHandle.GetChars(bytes, byteIndex, byteCount, chars, charIndex);
			return charCount;
		}

		public override int GetMaxByteCount(int charCount) 
		{
			return charCount * 4;
		}

		public override int GetMaxCharCount(int byteCount) 
		{
			return byteCount;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracledataadapter.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleDataAdapter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.ComponentModel;
	using System.Data;
	using System.Data.Common;

	//----------------------------------------------------------------------
	// OracleDataAdapter
	//
	//	Implements the Oracle Connection object, which connects
	//	to the Oracle server
	//
    /// <include file='doc\OracleDataAdapter.uex' path='docs/doc[@for="OracleDataAdapter"]/*' />
    [
    DefaultEvent("RowUpdated"),
#if EVERETT
    ToolboxItem("Microsoft.VSDesigner.Data.VS.OracleDataAdapterToolboxItem, " + AssemblyRef.MicrosoftVSDesigner),
    Designer("Microsoft.VSDesigner.Data.VS.OracleDataAdapterDesigner, " + AssemblyRef.MicrosoftVSDesigner)
#endif //EVERETT
    ]
	sealed public class OracleDataAdapter : DbDataAdapter, IDbDataAdapter
	{

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Fields 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
		private OracleCommand	_selectCommand;
		private OracleCommand	_insertCommand;
		private OracleCommand	_updateCommand;
		private OracleCommand	_deleteCommand;

        static internal readonly object EventRowUpdated  = new object(); 
        static internal readonly object EventRowUpdating = new object(); 

		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Constructors 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        // Construct an "empty" data adapter
        /// <include file='doc\OracleDataAdapter.uex' path='docs/doc[@for="OracleConnection.OracleDataAdapter1"]/*' />
		public OracleDataAdapter ()
		{
			GC.SuppressFinalize(this);
		}
		
        // Construct an adapter from a command
        /// <include file='doc\OracleDataAdapter.uex' path='docs/doc[@for="OracleConnection.OracleDataAdapter2"]/*' />
		public OracleDataAdapter (OracleCommand selectCommand) : this()
		{
			SelectCommand = selectCommand;
		}
        
        // Construct an adapter from a command text and a connection string
        /// <include file='doc\OracleDataAdapter.uex' path='docs/doc[@for="OracleConnection.OracleDataAdapter3"]/*' />
		public OracleDataAdapter (string selectCommandText, string selectConnectionString) : this()
		{
			SelectCommand 				= new OracleCommand();
			SelectCommand.Connection	= new OracleConnection(selectConnectionString);
			SelectCommand.CommandText	= selectCommandText;
		}
        
        // Construct an adapter from a command text and a connection 
        /// <include file='doc\OracleDataAdapter.uex' path='docs/doc[@for="OracleConnection.OracleDataAdapter4"]/*' />
		public OracleDataAdapter (string selectCommandText, OracleConnection selectConnection) : this()
		{
			SelectCommand 				= new OracleCommand();
			SelectCommand.Connection	= selectConnection;
			SelectCommand.CommandText	= selectCommandText;
		}
		

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleDataAdapter.uex' path='docs/doc[@for="OracleDataAdapter.DeleteCommand"]/*' />
        [
        OracleCategory(Res.OracleCategory_Update),
        DefaultValue(null),
        OracleDescription(Res.DbDataAdapter_DeleteCommand),
#if EVERETT
        Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
#endif //EVERETT
        ]
		public OracleCommand DeleteCommand
		{
			get { return _deleteCommand; }
			set { _deleteCommand = value; }
		}
		IDbCommand IDbDataAdapter.DeleteCommand 
		{
			get { return DeleteCommand; }
			set { DeleteCommand = (OracleCommand)value; }
		}

        /// <include file='doc\OracleDataAdapter.uex' path='docs/doc[@for="OracleDataAdapter.InsertCommand"]/*' />
        [
        OracleCategory(Res.OracleCategory_Update),
        DefaultValue(null),
        OracleDescription(Res.DbDataAdapter_InsertCommand),
#if EVERETT
        Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
#endif //EVERETT
        ]
		public OracleCommand InsertCommand
		{
			get { return _insertCommand; }
			set { _insertCommand = value; }
		}
		IDbCommand IDbDataAdapter.InsertCommand 
		{
			get { return InsertCommand; }
			set { InsertCommand = (OracleCommand)value; }
		}

        /// <include file='doc\OracleDataAdapter.uex' path='docs/doc[@for="OracleDataAdapter.SelectCommand"]/*' />
        [
        OracleCategory(Res.OracleCategory_Fill),
        DefaultValue(null),
        OracleDescription(Res.DbDataAdapter_SelectCommand),
#if EVERETT
        Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
#endif //EVERETT
        ]
		public OracleCommand SelectCommand
		{
			get { return _selectCommand; }
			set { _selectCommand = value; }
		}
		IDbCommand IDbDataAdapter.SelectCommand 
		{
			get { return SelectCommand; }
			set { SelectCommand = (OracleCommand)value; }
		}
		
        /// <include file='doc\OracleDataAdapter.uex' path='docs/doc[@for="OracleDataAdapter.UpdateCommand"]/*' />
        [
        OracleCategory(Res.OracleCategory_Update),
        DefaultValue(null),
        OracleDescription(Res.DbDataAdapter_UpdateCommand),
#if EVERETT
        Editor("Microsoft.VSDesigner.Data.Design.DBCommandEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor))
#endif //EVERETT
        ]
		public OracleCommand UpdateCommand
		{
			get { return _updateCommand; }
			set { _updateCommand = value; }
		}
		IDbCommand IDbDataAdapter.UpdateCommand 
		{
			get { return UpdateCommand; }
			set { UpdateCommand = (OracleCommand)value; }
		}
    

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleDataAdapter.uex' path='docs/doc[@for="OracleDataAdapter.CreateRowUpdatedEvent"]/*' />
		override protected RowUpdatedEventArgs CreateRowUpdatedEvent(
					DataRow dataRow, 
					IDbCommand command, 
					StatementType statementType, 
					DataTableMapping tableMapping
					) 
		{
            return new OracleRowUpdatedEventArgs(dataRow, command, statementType, tableMapping);
		}

        /// <include file='doc\OracleDataAdapter.uex' path='docs/doc[@for="OracleDataAdapter.CreateRowUpdatingEvent"]/*' />
		override protected RowUpdatingEventArgs CreateRowUpdatingEvent(
					DataRow dataRow, 
					IDbCommand command,
					StatementType statementType, 
					DataTableMapping tableMapping
					) 
		{
            return new OracleRowUpdatingEventArgs(dataRow, command, statementType, tableMapping);
		}

        /// <include file='doc\OracleDataAdapter.uex' path='docs/doc[@for="OracleDataAdapter.OnRowUpdated"]/*' />
		override protected void OnRowUpdated(RowUpdatedEventArgs value) 
		{
            OracleRowUpdatedEventHandler handler = (OracleRowUpdatedEventHandler) Events[EventRowUpdated];
            
            if ((null != handler) && (value is OracleRowUpdatedEventArgs)) 
            {
                handler(this, (OracleRowUpdatedEventArgs) value);
            }
		}

		/// <include file='doc\OracleDataAdapter.uex' path='docs/doc[@for="OracleDataAdapter.OnRowUpdating"]/*' />
		override protected void OnRowUpdating(RowUpdatingEventArgs value) 
		{
            OracleRowUpdatingEventHandler handler = (OracleRowUpdatingEventHandler) Events[EventRowUpdating];
            
            if ((null != handler) && (value is OracleRowUpdatingEventArgs)) 
            {
                handler(this, (OracleRowUpdatingEventArgs) value);
            }
		}
    

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Events 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
        /// <include file='doc\OracleDataAdapter.uex' path='docs/doc[@for="OracleDataAdapter.RowUpdated"]/*' />
        [
        OracleCategory(Res.OracleCategory_Update),
        OracleDescription(Res.DbDataAdapter_RowUpdated)
        ]
        public event OracleRowUpdatedEventHandler RowUpdated 
       	{
            add 	{ Events.AddHandler(   EventRowUpdated, value); }
            remove	{ Events.RemoveHandler(EventRowUpdated, value); }
        }

        /// <include file='doc\OracleDataAdapter.uex' path='docs/doc[@for="OracleDataAdapter.RowUpdating"]/*' />
        [
        OracleCategory(Res.OracleCategory_Update),
        OracleDescription(Res.DbDataAdapter_RowUpdating)
        ]
        public event OracleRowUpdatingEventHandler RowUpdating 
        {

            add {
                OracleRowUpdatingEventHandler handler = (OracleRowUpdatingEventHandler) Events[EventRowUpdating];

                // MDAC 58177, 64513
                // prevent someone from registering two different command builders on the adapter by
                // silently removing the old one
                if ((null != handler) && (value.Target is OracleCommandBuilder))
                {
                    OracleRowUpdatingEventHandler d = (OracleRowUpdatingEventHandler) OracleCommandBuilder.FindBuilder(handler);
                    
                    if (null != d) 
                        Events.RemoveHandler(EventRowUpdating, d);
                }
                Events.AddHandler(EventRowUpdating, value);
            }
            remove	{ Events.RemoveHandler(EventRowUpdating, value); }
        }
		
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracledescription.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataSysAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

#if V2
namespace System.DataAccess {
#else
namespace System.Data.OracleClient {
#endif
    using System;
    using System.ComponentModel;

    /// <include file='doc\OracleDescriptionAttribute.uex' path='docs/doc[@for="OracleDescriptionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.All)]
    sealed internal class OracleDescriptionAttribute : DescriptionAttribute {

        /// <include file='doc\OracleDescriptionAttribute.uex' path='docs/doc[@for="OracleDescriptionAttribute.OracleDescriptionAttribute"]/*' />
        public OracleDescriptionAttribute(string description) : base(description) {
            DescriptionValue = Res.GetString(base.Description);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracledatetime.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleDateTime.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Data.SqlTypes;
	using System.Diagnostics;
	using System.Globalization;
	using System.Runtime.InteropServices;

	//----------------------------------------------------------------------
	// OracleDateTime
	//
	//	This class implements support for Oracle's DATE internal data 
	//	type, which is really contains both Date and Time values (but
	//	doesn't contain fractional seconds).
	//
	//	It also implements support for the Oracle 9i 'TIMESTAMP', 
	//	'TIMESTAMP WITH LOCAL TIME ZONE' and 'TIMESTAMP WITH TIME ZONE'
	//	internal data types.
	//
    /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime"]/*' />
    [StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct OracleDateTime : IComparable, INullable
	{

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Fields
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		private byte[]	 _value;	// null == value is null; length(7) == date; length(11) == timestamp; length(13) == timestampwithtz

        private const byte x_DATE_Length   					= 7;
        private const byte x_TIMESTAMP_Length  				= 11;
        private const byte x_TIMESTAMP_WITH_TIMEZONE_Length = 13;

		private const int  FractionalSecondsPerTick	= 100;	


        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.MaxValue"]/*' />
        public static readonly OracleDateTime MaxValue = new OracleDateTime(DateTime.MaxValue);

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.MinValue"]/*' />
        public static readonly OracleDateTime MinValue = new OracleDateTime(DateTime.MinValue);
    
        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.Null"]/*' />
        public static readonly OracleDateTime Null = new OracleDateTime(true);
		
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Constructors
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		// Construct from nothing -- the value will be null
		private OracleDateTime(bool isNull)
		{	
			_value = null;
		}

		// Construct from System.DateTime type
        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.OracleDateTime1"]/*' />
		public OracleDateTime (DateTime dt)
		{
			_value = new byte[x_TIMESTAMP_Length];
			Pack (_value, dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second, (int)(dt.Ticks % TimeSpan.TicksPerSecond) * FractionalSecondsPerTick);
		}
		
        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.OracleDateTime2"]/*' />
		public OracleDateTime (Int64 ticks)
		{
			_value = new byte[x_TIMESTAMP_Length];
			DateTime 	dt = new DateTime(ticks);
			Pack (_value, dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second, (int)(dt.Ticks % TimeSpan.TicksPerSecond) * FractionalSecondsPerTick);
		}

		/// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.OracleDateTime3"]/*' />
		public OracleDateTime (int year, int month, int day)
 				: this (year, month, day, 0, 0, 0, 0) {}

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.OracleDateTime4"]/*' />
 		public OracleDateTime (int year, int month, int day, Calendar calendar)  
 				: this (year, month, day, 0, 0, 0, 0, calendar) {}

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.OracleDateTime5"]/*' />
		public OracleDateTime (int year, int month, int day, int hour, int minute, int second)  
 				: this (year, month, day, hour, minute, second, 0) {}

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.OracleDateTime6"]/*' />
		public OracleDateTime (int year, int month, int day, int hour, int minute, int second, Calendar calendar)  
 				: this (year, month, day, hour, minute, second, 0, calendar) {}

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.OracleDateTime7"]/*' />
		public OracleDateTime (int year, int month, int day, int hour, int minute, int second, int millisecond)
	 	{ 
			_value = new byte[x_TIMESTAMP_Length];
			Pack (_value, year, month, day, hour, minute, second, (int)(millisecond * TimeSpan.TicksPerMillisecond) * FractionalSecondsPerTick);
		}

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.OracleDateTime8"]/*' />
		public OracleDateTime (int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar)
	 	{ 
			_value = new byte[x_TIMESTAMP_Length];
			DateTime	dt = new DateTime(year, month, day, hour, minute, second, millisecond, calendar);
			Pack (_value, dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second, (int)(dt.Ticks % TimeSpan.TicksPerSecond) * FractionalSecondsPerTick);
		}

		// Copy constructor
        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.OracleDateTime9"]/*' />
		public OracleDateTime (OracleDateTime from)
		{
			_value = new byte[from._value.Length];
			from._value.CopyTo(_value, 0);
		}

        // (internal) construct from a row/parameter binding
		internal OracleDateTime(
					NativeBuffer 		buffer, 
					int					valueOffset,
					MetaType			metaType,
					OracleConnection 	connection)
		{
			_value = GetBytes(buffer, valueOffset, metaType, connection);
		}

		static private void Pack (
						byte[] dateval, 
						int year, 
						int month, 
						int day, 
						int hour, 
						int minute, 
						int second, 
						int fsecs)  
		{
			// DEVNOTE: undoubtedly, this is Intel byte order specific, but how 
			//			do I verify what Oracle needs on a non Intel machine?

			dateval[0] = (byte)((year / 100) + 100);
			dateval[1] = (byte)((year % 100) + 100);
			dateval[2] = (byte)(month);
			dateval[3] = (byte)(day);
			dateval[4] = (byte)(hour   + 1);
			dateval[5] = (byte)(minute + 1);
			dateval[6] = (byte)(second + 1);
			dateval[7] = (byte)((fsecs >> 24));
			dateval[8] = (byte)((fsecs >> 16) & 0xff);
			dateval[9] = (byte)((fsecs >>  8) & 0xff);
			dateval[10]= (byte)(fsecs & 0xff);
		}

		static private int Unpack (
						byte[] dateval, 
						out int year,
						out int month,
						out int day,
						out int hour,
						out int minute,
						out int second,
						out int fsec)
		{
			int tzh, tzm;
			
			// DEVNOTE: undoubtedly, this is Intel byte order specific, but how 
			//			do I verify what Oracle needs on a non Intel machine?
			
			year	=(((int)dateval[0] - 100) * 100) + ((int)dateval[1] - 100);
			month	= (int)dateval[2];
			day		= (int)dateval[3];
			hour	= (int)dateval[4] - 1;
			minute	= (int)dateval[5] - 1;
			second	= (int)dateval[6] - 1;

			if (x_DATE_Length == dateval.Length)
				fsec = tzh = tzm = 0;
			else
			{
				fsec = (int)dateval[7] << 24
					 | (int)dateval[8] << 16
					 | (int)dateval[9] <<  8
					 | (int)dateval[10]
					 ;
				if (x_TIMESTAMP_Length == dateval.Length)
					tzh = tzm = 0;
				else
				{
					tzh = dateval[11] - 20;					
					tzm = dateval[12] - 60;
				}
			}
			
			if (x_TIMESTAMP_WITH_TIMEZONE_Length == dateval.Length)
			{
				// DEVNOTE: I'm not really all that excited about the fact that I'm
				//			constructing a System.DateTime value to unpack, but if you 
				//			look at what is involved in adjusting the value for the 
				//			timezone, it turns into the same thing that DateTime does.

				DateTime utcValue = (new DateTime(year, month, day, hour, minute, second))
								  + (new TimeSpan(tzh, tzm, 0));

				year 	= utcValue.Year;
				month 	= utcValue.Month;
				day		= utcValue.Day;
				hour	= utcValue.Hour;
				minute	= utcValue.Minute;
				// Seconds and Fractional Seconds aren't affected by time zones (yet!)
			}
			return dateval.Length;
		}

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.IsNull"]/*' />
		public bool IsNull 
		{
			get { return (null == _value); }
		}

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.Value"]/*' />
        public DateTime Value
        {
            get
            {
            	if (IsNull)
	    			throw ADP.DataIsNull();

				DateTime result = ToDateTime(_value);
				return result;
            }           
        }

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.Year"]/*' />
        public int Year
        {
            get
            {
            	if (IsNull)
	    			throw ADP.DataIsNull();

	        	int year, month, day, hour, minute, second, fsec;

				Unpack( _value,	out year, out month, out day, out hour, out minute, out second, out fsec);
				return year;
            }           
        }

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.Month"]/*' />
        public int Month
        {
            get
            {
            	if (IsNull)
	    			throw ADP.DataIsNull();

	        	int year, month, day, hour, minute, second, fsec;

				Unpack( _value,	out year, out month, out day, out hour, out minute, out second, out fsec);
				return month;
            }           
        }

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.Day"]/*' />
        public int Day
        {
            get
            {
            	if (IsNull)
	    			throw ADP.DataIsNull();

	        	int year, month, day, hour, minute, second, fsec;

				Unpack( _value,	out year, out month, out day, out hour, out minute, out second, out fsec);
				return day;
            }           
        }

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.Hour"]/*' />
        public int Hour
        {
            get
            {
            	if (IsNull)
	    			throw ADP.DataIsNull();

	        	int year, month, day, hour, minute, second, fsec;

				Unpack( _value,	out year, out month, out day, out hour, out minute, out second, out fsec);
				return hour;
            }           
        }

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.Minute"]/*' />
        public int Minute
        {
            get
            {
            	if (IsNull)
	    			throw ADP.DataIsNull();

	        	int year, month, day, hour, minute, second, fsec;

				Unpack( _value,	out year, out month, out day, out hour, out minute, out second, out fsec);
				return minute;
            }           
        }

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.Second"]/*' />
        public int Second
        {
            get
            {
            	if (IsNull)
	    			throw ADP.DataIsNull();

	        	int year, month, day, hour, minute, second, fsec;

				Unpack( _value,	out year, out month, out day, out hour, out minute, out second, out fsec);
				return second;
            }           
        }

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.Millisecond"]/*' />
        public int Millisecond
        {
            get
            {
            	if (IsNull)
	    			throw ADP.DataIsNull();

	        	int year, month, day, hour, minute, second, fsec;

				Unpack( _value,	out year, out month, out day, out hour, out minute, out second, out fsec);
				
				int milliseconds = (int)((fsec / FractionalSecondsPerTick) /  TimeSpan.TicksPerMillisecond);
				return milliseconds;
            }           
        }


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.CompareTo"]/*' />
		public int CompareTo(
		  	object obj
			)
		{
			if (obj.GetType() == typeof(OracleDateTime))
			{
	            OracleDateTime odt = (OracleDateTime)obj;

	            // If both values are Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return odt.IsNull ? 0  : -1;

                if (odt.IsNull)
                    return 1;

				// Neither value is null, do the comparison, but take the Timezone into account.

	        	int year1, month1, day1, hour1, minute1, second1, fsec1;
	        	int year2, month2, day2, hour2, minute2, second2, fsec2;

				Unpack( _value,	    out year1, out month1, out day1, out hour1, out minute1, out second1, out fsec1);
	        	Unpack( odt._value, out year2, out month2, out day2, out hour2, out minute2, out second2, out fsec2);

				int delta;

				delta = (year1 - year2);		if (0 != delta) return delta;
				delta = (month1 - month2);		if (0 != delta) return delta;
				delta = (day1 - day2);			if (0 != delta) return delta;
				delta = (hour1 - hour2);		if (0 != delta) return delta;
				delta = (minute1 - minute2);	if (0 != delta) return delta;
				delta = (second1 - second2);	if (0 != delta) return delta;
				delta = (fsec1 - fsec2);		if (0 != delta) return delta;
				return 0;
			}

			// Wrong type!
			throw ADP.Argument();
		}

		/// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.Equals"]/*' />
        public override bool Equals(object value) 
        {
            if (value is OracleDateTime)
            	return (this == (OracleDateTime)value).Value;
            else
                return false;
        }

		static internal byte[] GetBytes(
					NativeBuffer 		buffer, 
					int					valueOffset,
					MetaType			metaType,
					OracleConnection 	connection)
		{
			// Static method to return the raw data bytes from the row/parameter
			// buffer, taking the binding type into account and adjusting it for 
			// the server time zones, as appropriate.
			
			int	ociBytes;
			OCI.DATATYPE ociType = metaType.OciType;

			switch (ociType)
			{
			case OCI.DATATYPE.DATE:
				ociBytes = x_DATE_Length;
				break;
				
			case OCI.DATATYPE.INT_TIMESTAMP:
				ociBytes = x_TIMESTAMP_Length;
				break;
				
			case OCI.DATATYPE.INT_TIMESTAMP_LTZ:
				ociBytes = x_TIMESTAMP_WITH_TIMEZONE_Length;
				break;
				
			default:
				Debug.Assert(OCI.DATATYPE.INT_TIMESTAMP_TZ == ociType, "unrecognized type");
				ociBytes = x_TIMESTAMP_WITH_TIMEZONE_Length;
				break;
			}

			byte[] result = new byte[ociBytes];
			Marshal.Copy((IntPtr)buffer.PtrOffset(valueOffset), result, 0, ociBytes);

			if (OCI.DATATYPE.INT_TIMESTAMP_LTZ == ociType)
			{
				TimeSpan tzadjust = connection.ServerTimeZoneAdjustmentToUTC;
				result[11] = (byte)(tzadjust.Hours   + 20);
				result[12] = (byte)(tzadjust.Minutes + 60);
			}

			return result;
		}

 		/// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.GetHashCode"]/*' />
        public override int GetHashCode() 
        {
            int retval = IsNull ? 0 : _value.GetHashCode();

            return retval;
        }

		static internal DateTime MarshalToDateTime(
					NativeBuffer 		buffer, 
					int					valueOffset,
					MetaType			metaType,
					OracleConnection 	connection)
		{
			byte[]	rawValue  = GetBytes(buffer, valueOffset, metaType, connection);
			DateTime result = ToDateTime(rawValue);
			return result;
		}

		static internal int MarshalToNative(object value, HandleRef buffer, OCI.DATATYPE ociType)
		{
			// TODO: probably need to enforce the correct calendar...
			// TODO: consider whether we need to adjust TIMESTAMP WITH LOCAL TIME ZONE based upon the server's time zone.
			
			byte[] from;
			
			if ( value is OracleDateTime )
				from = ((OracleDateTime)value)._value;
			else
			{
				DateTime dt = (DateTime)value;
				from = new byte[x_TIMESTAMP_Length];
				Pack (from, dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second, (int)(dt.Ticks % TimeSpan.TicksPerSecond) * FractionalSecondsPerTick);
			}
			
			int	ociBytes;

			switch (ociType)
			{
			case OCI.DATATYPE.INT_TIMESTAMP:
			case OCI.DATATYPE.INT_TIMESTAMP_LTZ:
				ociBytes = x_TIMESTAMP_Length;
				break;
				
			case OCI.DATATYPE.INT_TIMESTAMP_TZ:
				ociBytes = x_TIMESTAMP_WITH_TIMEZONE_Length;
				break;
				
			default:
				Debug.Assert(OCI.DATATYPE.DATE == ociType, "unrecognized type");
				ociBytes = x_DATE_Length;
				break;
			}

			Marshal.Copy(from, 0, (IntPtr)buffer, ociBytes);
			return ociBytes;
		}

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.Parse"]/*' />
		public static OracleDateTime Parse(string s)
		{
			// Rather than figure out which formats, etc, we just simplify our
			// life and convert this to a DateTime, which we can use to build 
			// the real Oracle Date from.
			DateTime datetime = DateTime.Parse(s);
			return new OracleDateTime(datetime);
		}

		static private DateTime ToDateTime(byte[] rawValue)
		{
        	int year, month, day, hour, minute, second, fsec;
        	int length = Unpack( rawValue, out year, out month, out day, out hour, out minute, out second, out fsec);

            DateTime result = new DateTime(year, month, day, hour, minute, second);

			if (length > x_DATE_Length && fsec > FractionalSecondsPerTick)
			{
				// DEVNOTE: Yes, there's a mismatch in the precision between Oracle,
				//			(which has 9 digits) and System.DateTime (which has 7
				//			digits);  All the other providers truncate the precision,
				//			so we do as well.
				result = result.AddTicks((long)fsec / FractionalSecondsPerTick);
			}
			return result;
		}
		
        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.ToString"]/*' />
		public override string ToString()
		{
			if (IsNull)
				return Res.GetString(Res.SqlMisc_NullString);
			
			string retval = Value.ToString(CultureInfo.CurrentCulture);
			return retval;
		}


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Operators 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
        // Alternative method for operator ==
        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.Equals1"]/*' />
        public static OracleBoolean Equals(OracleDateTime x, OracleDateTime y)
        {
            return (x == y);
        }

        // Alternative method for operator >
        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.GreaterThan"]/*' />
        public static OracleBoolean GreaterThan(OracleDateTime x, OracleDateTime y)
        {
            return (x > y);
        }

        // Alternative method for operator >=
        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.GreaterThanOrEqual"]/*' />
        public static OracleBoolean GreaterThanOrEqual(OracleDateTime x, OracleDateTime y)
        {
            return (x >= y);
        }

        // Alternative method for operator <
        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.LessThan"]/*' />
        public static OracleBoolean LessThan(OracleDateTime x, OracleDateTime y)
        {
            return (x < y);
        }

        // Alternative method for operator <=
        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.LessThanOrEqual"]/*' />
        public static OracleBoolean LessThanOrEqual(OracleDateTime x, OracleDateTime y)
        {
            return (x <= y);
        }

        // Alternative method for operator !=
        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.NotEquals"]/*' />
        public static OracleBoolean NotEquals(OracleDateTime x, OracleDateTime y)
        {
            return (x != y);
        }

 		/// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.operatorDateTime"]/*' />
        public static explicit operator DateTime(OracleDateTime x) 
        {
        	if (x.IsNull)
    			throw ADP.DataIsNull();
       			
            return x.Value;
        }

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.operatorOracleDateTime"]/*' />
        public static explicit operator OracleDateTime(string x) 
        {
            return OracleDateTime.Parse(x);
        }


		/// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.operatorEQ"]/*' />
        public static OracleBoolean operator==	(OracleDateTime x, OracleDateTime y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) == 0);
        }

		/// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.operatorGT"]/*' />
		public static OracleBoolean operator>	(OracleDateTime x, OracleDateTime y)
		{
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) > 0);
		}

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.operatorGE"]/*' />
        public static OracleBoolean operator>=	(OracleDateTime x, OracleDateTime y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) >= 0);
        }

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.operatorLT"]/*' />
        public static OracleBoolean operator<	(OracleDateTime x, OracleDateTime y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) < 0);
        }

        /// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.operatorLE"]/*' />
        public static OracleBoolean operator<=	(OracleDateTime x, OracleDateTime y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) <= 0);
        }

 		/// <include file='doc\OracleDateTime.uex' path='docs/doc[@for="OracleDateTime.operatorNE"]/*' />
		public static OracleBoolean operator!=	(OracleDateTime x, OracleDateTime y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) != 0);
        }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracleconnectionpoolmanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="OracleConnectionPoolManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OracleClient
{
    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.Runtime.Remoting;
    using System.Threading;
    using System.Security;
    using System.Security.Permissions;
    using System.Security.Principal;

    sealed internal class OracleConnectionPoolManager 
    {
        private static volatile DBObjectPoolManager _manager; // TODO:  MDAC 75795: must be volatile, double-checked locking problem

        private static void Init() 
        {
            lock(typeof(OracleConnectionPoolManager)) 
            {
                if (null == _manager)
                    _manager = new DBObjectPoolManager();
            }
        }

        internal static OracleInternalConnection GetPooledConnection(
        														string encryptedConnectionString,
        														OracleConnectionString options,
        														OracleConnection owningObject,
                                                                out bool isInTransaction) 
		{
            // If Init() has not been called, call it and set up the cached members
            if (null == _manager)
                Init();

            DBObjectPool pool = null;
            string		 userId = null;
            string		 poolKey;

			if (true == options.IntegratedSecurity)
            {
                // If using integrated security, find the pool based on the connection string 
                // postpended with the windows identity userId.  Otherwise, simply use the 
                // connection string.  This will guarantee anyone using integrated security will 
                // always be sent to the appropriate pool. 

                // If this throws, Open will abort.  Is there an issue here?  UNDONE BUGBUG
                // Will this fail on some platforms?
                userId = DBObjectPool.GetCurrentIdentityName();

                Debug.Assert(userId != null && userId != "", "OracleConnectionPoolManager: WindowsIdentity.Name returned empty string!");

                poolKey = userId + encryptedConnectionString;
            }
            else 
            {
                poolKey = encryptedConnectionString;
            }

			pool = _manager.FindPool(poolKey);

			if (null == pool) 
           	{
            	// If we didn't locate a pool, we need to create one.
            	
                OracleConnectionPoolControl poolControl;

                poolControl = new OracleConnectionPoolControl(poolKey, options); 
                poolControl.UserId = userId;
                
				pool = _manager.FindOrCreatePool(poolControl);
            }

            OracleInternalConnection con = (OracleInternalConnection)pool.GetObject(owningObject, out isInTransaction);

            // If GetObject() failed, the pool timeout occurred.
            if (con == null)
                throw ADP.PooledOpenTimeout();
                        
            return con;
        }

        public static void ReturnPooledConnection(OracleInternalConnection pooledConnection, OracleConnection owningObject) 
        {        	
            pooledConnection.Pool.PutObject(pooledConnection, owningObject);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracleconnectionstring.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleConnectionString.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient 
{

    using System;
    using System.Collections;
    using System.Data;
    using System.Data.Common;
    using System.Diagnostics;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Threading;
    using Microsoft.Win32;

    sealed internal class OracleConnectionString : DBConnectionString 
    {
    	sealed internal class DEFAULT 
    	{
	        internal const int    	Connection_Lifetime   = 0; // default of 0 means don't use
	        internal const string 	Data_Source           = "";
	        internal const bool   	Enlist                = true;
	        internal const bool		Integrated_Security   = false;
	        internal const int 		Max_Pool_Size         = 100;
	        internal const int   	Min_Pool_Size         = 0;
	        internal const string	Password              = "";
	        internal const bool  	Persist_Security_Info = false;
	        internal const bool  	Pooling               = true;
	        internal const bool		Unicode				  = false	;
	        internal const string	User_ID               = "";
        };

    	sealed internal class KEY 
    	{
    		internal const int	  Count = 10;		// count of Keys
    		
			internal const string Connection_Lifetime   = "connection lifetime";
			internal const string Data_Source           = "data source";
			internal const string Enlist                = "enlist";
			internal const string Integrated_Security   = "integrated security";
			internal const string Max_Pool_Size         = "max pool size";
			internal const string Min_Pool_Size         = "min pool size";
			internal const string Password              = "password";
			internal const string Persist_Security_Info = "persist security info";
			internal const string Pooling               = "pooling";
			internal const string Unicode				= "unicode";
			internal const string User_ID				= "user id";
        };

    	sealed internal class SYNONYM 
    	{
    		internal const int	  Count = 5;		// count of Synonyms

			internal const string SERVER             	= "server";					// data source
			internal const string Pwd                	= "pwd";					// password
			internal const string PERSISTSECURITYINFO	= "persistsecurityinfo";	// persist security info
 			internal const string UID                	= "uid";					// user id
			internal const string User               	= "user";					// user id
    	};


        static private Hashtable			_validKeyNamesAndSynonyms;
        static private Hashtable			_parsedConnectionStringCache;

        private readonly PermissionSet		_permission;

		private bool						_enlist;
		private bool						_integratedSecurity;
		private bool						_persistSecurityInfo;
		private bool						_pooling;
		private	bool						_unicode;

		private	int							_connectionLifeTime;
		private int							_maxPoolSize;
		private int							_minPoolSize;

		private	string						_dataSource;
		private string						_password;
		private string						_userId;
        
#if USECRYPTO
        private OracleConnectionString(string connectionString, string encyryptedConnectionString) : base(connectionString, encyryptedConnectionString, UdlSupport.ThrowIfFound)
#else
        private OracleConnectionString(string connectionString) : base(connectionString, UdlSupport.ThrowIfFound)
#endif
        {
            if (base.IsEmpty()) 
            {
                _integratedSecurity = DEFAULT.Integrated_Security;
                _enlist             = DEFAULT.Enlist;
                _persistSecurityInfo= DEFAULT.Persist_Security_Info;
                _pooling            = DEFAULT.Pooling;
                _unicode			= DEFAULT.Unicode;

                _connectionLifeTime	= DEFAULT.Connection_Lifetime;
                _maxPoolSize        = DEFAULT.Max_Pool_Size;
                _minPoolSize        = DEFAULT.Min_Pool_Size;

                _dataSource			= DEFAULT.Data_Source;
                _userId				= DEFAULT.User_ID;
                _password			= DEFAULT.Password;
            }
            _permission = CreatePermission(this);

        }

        private OracleConnectionString(OracleConnectionString value) : base(value, false) { // Clone
            _permission = value._permission;

            _enlist				= value._enlist;
            _integratedSecurity	= value._integratedSecurity;
            _persistSecurityInfo= value._persistSecurityInfo;
            _pooling			= value._pooling;
            _unicode			= value._unicode;

            _connectionLifeTime	= value._connectionLifeTime;
            _maxPoolSize		= value._maxPoolSize;
            _minPoolSize		= value._minPoolSize;

            _dataSource			= value._dataSource;
            _userId				= value._userId;
            _password			= value._password;
        }

        internal OracleConnectionString(string connectionString, string restrictions, KeyRestrictionBehavior behavior) : base(connectionString, restrictions, behavior) {
        }


        internal bool	Enlist 					{ get { return _enlist; } }
        internal bool	IntegratedSecurity	{ get { return _integratedSecurity; } }
//		internal bool	PersistSecurityInfo 	{ get { return _persistSecurityInfo; } }
        internal bool	Pooling 				{ get { return _pooling; } }
		internal bool	Unicode				{ get { return _unicode; } }

        internal int	ConnectionLifeTime	{ get { return _connectionLifeTime; } }
        internal int	MaxPoolSize			{ get { return _maxPoolSize; } }
        internal int	MinPoolSize			{ get { return _minPoolSize; } }

        internal string DataSource			{ get { return _dataSource; } }
        internal string UserId 				{ get { return _userId; } }
        internal string Password 			{ get { return _password; } }

        internal OracleConnectionString Clone() {
            return new OracleConnectionString(this);
        }

        static internal PermissionSet CreatePermission(OracleConnectionString constr) {
            OraclePermission p = new OraclePermission(constr);
            if (null == constr) {
                p.Add(ADP.StrEmpty, ADP.StrEmpty, KeyRestrictionBehavior.AllowOnly); // ExecuteOnly permission
            }
            PermissionSet permission;
            NamedPermissionSet fulltrust = new NamedPermissionSet("FullTrust"); // MDAC 83159
            fulltrust.Assert();
            try {
	            try {
	                permission = new PermissionSet(fulltrust);
	                permission.AddPermission(p);
	            }
	            finally {
	                CodeAccessPermission.RevertAssert();
	            }
            }
	        catch {
	        	throw;
	        }
            return permission;
        }
        
        static internal void Demand(OracleConnectionString parsedConnectionString) 
        {
            PermissionSet permission = ((null != parsedConnectionString) ? parsedConnectionString._permission : OracleConnection.OraclePermission);
            permission.Demand();
        }
        
		static private Hashtable GetParseSynonyms()
		{
            Hashtable hash = _validKeyNamesAndSynonyms;
            
            if (null == hash) 
            {
	            hash = new Hashtable(KEY.Count + SYNONYM.Count);
				hash.Add(KEY.Connection_Lifetime,	  KEY.Connection_Lifetime);
	  			hash.Add(KEY.Data_Source,             KEY.Data_Source);
	            hash.Add(KEY.Enlist,                  KEY.Enlist);
				hash.Add(KEY.Integrated_Security,     KEY.Integrated_Security);
	            hash.Add(KEY.Max_Pool_Size,           KEY.Max_Pool_Size);
	            hash.Add(KEY.Min_Pool_Size,           KEY.Min_Pool_Size);
				hash.Add(KEY.Password,                KEY.Password); 
	            hash.Add(KEY.Persist_Security_Info,   KEY.Persist_Security_Info);
	            hash.Add(KEY.Pooling,                 KEY.Pooling);
	            hash.Add(KEY.Unicode,                 KEY.Unicode);
	            hash.Add(KEY.User_ID,                 KEY.User_ID);
	            hash.Add(SYNONYM.SERVER,              KEY.Data_Source);
	            hash.Add(SYNONYM.Pwd,                 KEY.Password);
	            hash.Add(SYNONYM.PERSISTSECURITYINFO, KEY.Persist_Security_Info);
	            hash.Add(SYNONYM.UID,                 KEY.User_ID);
	            hash.Add(SYNONYM.User,                KEY.User_ID);
#if DEBUG
                hash = ADP.ProtectHashtable(hash);
#endif
                _validKeyNamesAndSynonyms = hash;
            }
            return hash;
        }

        override protected bool IsSensitiveOption(string keyname)
        {
            return (KEY.Password == keyname);
        }

        override protected string KeywordLookup(string keyname)
        {
            try {
                Hashtable lookup = GetParseSynonyms();
                return (string) lookup[keyname];
            }
            catch(Exception e) {
                ADP.TraceException(e);
                throw ADP.KeywordNotSupported(keyname);
            }
        }

        static internal OracleConnectionString ParseString(string connectionString) 
        {
            OracleConnectionString result = null;
            if (!ADP.IsEmpty(connectionString)) 
            {
	        	result = (OracleConnectionString)CacheQuery(connectionString, _parsedConnectionStringCache);
	            if (null == result) 
	            {
#if USECRYPTO
	                    string hashvalue = Crypto.ComputeHash(connectionString);
	                    result = (DBConnectionString.CacheQuery(hashvalue, _parsedConnectionStringCache) as OracleConnectionString);
	                    if (null == result) {
	                        result = new OracleConnectionString(connectionString, null);
#else
			            	result = new OracleConnectionString(connectionString);
#endif 
							if (result.ShouldCache()) 
							{
#if USECRYPTO
	                            if (!result.IsEncrypted) {
	                                hashvalue = connectionString;
	                            }
	                            CacheAdd(hashvalue,			result, ref _parsedConnectionStringCache);
#else
								CacheAdd(connectionString,	result, ref _parsedConnectionStringCache);
#endif
							}
#if USECRYPTO
	                    }
#endif
	           }
            }
            return result;
        }

        override protected string ValidateParse() 
        {
            _integratedSecurity = CheckConvertIntegratedSecurity();

            _enlist             = CheckConvertToBoolean(KEY.Enlist,					DEFAULT.Enlist);
            _persistSecurityInfo= CheckConvertToBoolean(KEY.Persist_Security_Info,	DEFAULT.Persist_Security_Info);
            _pooling            = CheckConvertToBoolean(KEY.Pooling,				DEFAULT.Pooling);
            _unicode            = CheckConvertToBoolean(KEY.Unicode,				DEFAULT.Unicode);

            _connectionLifeTime = CheckConvertToInt32(KEY.Connection_Lifetime,		DEFAULT.Connection_Lifetime);
            _maxPoolSize        = CheckConvertToInt32(KEY.Max_Pool_Size,			DEFAULT.Max_Pool_Size);
            _minPoolSize        = CheckConvertToInt32(KEY.Min_Pool_Size,			DEFAULT.Min_Pool_Size);

            _dataSource     	= CheckConvertToString(KEY.Data_Source,				DEFAULT.Data_Source);
            _userId           	= CheckConvertToString(KEY.User_ID,					DEFAULT.User_ID);
            _password         	= CheckConvertToString(KEY.Password,				DEFAULT.Password);

			if (_userId.Length > 30)
				throw ADP.InvalidConnectionOptionLength(KEY.User_ID, 30);

			if (_password.Length > 30)
				throw ADP.InvalidConnectionOptionLength(KEY.Password, 30);
			
			if (_dataSource.Length > 128)
				throw ADP.InvalidConnectionOptionLength(KEY.Data_Source, 128);		

            if (_connectionLifeTime < 0)
                throw ADP.InvalidConnectionOptionValue(KEY.Connection_Lifetime);

            if (_maxPoolSize < 1)
                throw ADP.InvalidConnectionOptionValue(KEY.Max_Pool_Size);

            if (_minPoolSize < 0)
                throw ADP.InvalidConnectionOptionValue(KEY.Min_Pool_Size);
            
            if (_maxPoolSize < _minPoolSize)
                throw ADP.InvalidMinMaxPoolSizeValues();

            return EncryptedActualConnectionString;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracledatareader.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleDataReader.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
    using System;
    using System.Collections;
    using System.Data;
    using System.Data.Common;
    using System.Data.SqlTypes;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    //----------------------------------------------------------------------
    // OracleDataReader
    //
    //  Contains all the information about a single column in a result set,
    //  and implements the methods necessary to describe column to Oracle
    //  and to extract the column data from the native buffer used to fetch
    //  it.
    //
    /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader"]/*' />
    sealed public class OracleDataReader : MarshalByRefObject, IDataReader, IEnumerable 
    {
        private const int _prefetchMemory = 65536;  // maximum amount of data to prefetch

        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Fields 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        
        private OracleConnection    _connection;
        private int                 _connectionCloseCount;  // The close count of the connection; used to decide if we're zombied
        
        private OciHandle           _statementHandle;       // the OCI statement handle we'll use to get data from; it must be non-null
                                                            // for the data reader to be considered open
                                                            
        private string              _statementText;         // the text of the statement we executed; in Oracle9i, you can ask for this from the Statement handle.
                                                            
        private OracleColumn[]      _columnInfo;
        private NativeBuffer        _buffer;
        private int                 _rowBufferLength;       // length of one buffered row.
        private int                 _rowsToPrefetch;        // maximum number of rows we should prefetch (fits into _prefetchMemory)

        private int                 _rowsTotal = 0;         // number of rows that we've fetched so far.
        private bool                _isLastBuffer;          // true when we're pre-fetching, and we got end of data from the fetch. (There are still rows in the buffer)


        private FieldNameLookup     _fieldNameLookup;       // optimizes searching by strings

        private DataTable           _schemaTable;

        private bool                _endOfData;             // true when we've reached the end of the results
        private bool                _closeConnectionToo;    // true when we're created with CommandBehavior.CloseConnection
        private bool                _keyInfoRequested;      // true when we're created with CommandBehavior.KeyInfo
        
        private byte                _hasRows;               // true when there is at least one row to be read.
        private const byte x_hasRows_Unknown = 0;
        private const byte x_hasRows_False   = 1;
        private const byte x_hasRows_True    = 2;
        
        private int                 _recordsAffected;

        private OracleDataReader[]  _refCursorDataReaders;
        private int                 _nextRefCursor;     
        
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Constructors 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        
        
        // Construct from a command and a statement handle
        internal OracleDataReader(
            OracleCommand   command, 
            OciHandle       statementHandle,
            string          statementText,
            CommandBehavior behavior
            )
        {
            _statementHandle        = statementHandle;

            _connection             = (OracleConnection)command.Connection;
            _connectionCloseCount   = _connection.CloseCount;
            _columnInfo             = null;
            
            if (OCI.STMT.OCI_STMT_SELECT == command.StatementType)
            {
                FillColumnInfo();
                
                _recordsAffected = -1;  // Don't know this until we read the last row

                if (OracleCommand.IsBehavior(behavior, CommandBehavior.SchemaOnly))
                    _endOfData = true;              
            }
            else 
            {
                _statementHandle.GetAttribute(OCI.ATTR.OCI_ATTR_ROW_COUNT, out _recordsAffected, ErrorHandle);              
                _endOfData = true;
                _hasRows = x_hasRows_False;
            }
                
            _statementText          = statementText;
            _closeConnectionToo     = (OracleCommand.IsBehavior(behavior, CommandBehavior.CloseConnection));    

            if (CommandType.Text == command.CommandType)
                _keyInfoRequested   = (OracleCommand.IsBehavior(behavior, CommandBehavior.KeyInfo));
        }
        
        internal OracleDataReader(
            OracleConnection    connection, 
            OciHandle           statementHandle
            )
        {
            _statementHandle        = statementHandle;
            _connection             = connection;
            _connectionCloseCount   = _connection.CloseCount;
            
            _recordsAffected        = -1;   // REF CURSORS must be a select statement, yes?

            FillColumnInfo();
        }

        // Construct from a command and an array of ref cursor parameter ordinals
        internal OracleDataReader(
            OracleCommand   command, 
            ArrayList       refCursorParameterOrdinals,
            string          statementText,
            CommandBehavior behavior
            )
        {
            _statementText          = statementText;
            _closeConnectionToo     = (OracleCommand.IsBehavior(behavior, CommandBehavior.CloseConnection));    

            if (CommandType.Text == command.CommandType)
                _keyInfoRequested   = (OracleCommand.IsBehavior(behavior, CommandBehavior.KeyInfo));

            // Copy the data reader(s) from the parameter collection;
            _refCursorDataReaders = new OracleDataReader[refCursorParameterOrdinals.Count];

            for (int i=0; i < refCursorParameterOrdinals.Count; i++)
            {
                int refCursorParameterOrdinal = (int)refCursorParameterOrdinals[i];
            
                _refCursorDataReaders[i] = (OracleDataReader)command.Parameters[refCursorParameterOrdinal].Value;
                command.Parameters[refCursorParameterOrdinal].Value = DBNull.Value;
            }

            // Set the first ref cursor as the result set
            _nextRefCursor = 0;
            NextResultInternal();
        }
        


        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Properties 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.Depth"]/*' />
        public int Depth 
        {
            get
            {
                AssertReaderIsOpen();
                return 0;       // TODO: consider how we would support object-relational "refs"
            }
        }

        private OciHandle ErrorHandle 
        {
            //  Every OCI call needs an error handle, so make it available 
            //  internally.
            get { return _connection.ErrorHandle; }
        }
        
#if POSTEVERETT
        private OciHandle EnvironmentHandle 
        {
            //  Simplify getting the EnvironmentHandle
            get { return _connection.EnvironmentHandle; }
        }
#endif //POSTEVERETT

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.FieldCount"]/*' />
        public int FieldCount 
        {
            get
            {
                AssertReaderIsOpen();

                if (null == _columnInfo)
                    return 0;
                
                return _columnInfo.Length;
            }
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.HasRows"]/*' />
        public bool HasRows {
            get {
                AssertReaderIsOpen();
                bool result = (x_hasRows_True == _hasRows);

                if (x_hasRows_Unknown == _hasRows)
                {
                    result = ReadInternal();

                    if (null != _buffer)
                        _buffer.MovePrevious(); // back up over the row in the buffer so the next read will return the row we read
                        
                    _hasRows = (result) ? x_hasRows_True : x_hasRows_False;
                }
                return result;
            }
        }
        
        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.IsClosed"]/*' />
        public bool IsClosed 
        {
            //  We rely upon the statement handle not being null as long as the 
            //  data reader is open; once the data reader is closed, the first 
            //  thing that happens is the statement handle is nulled out.
            get { return (null == _statementHandle) || (null == _connection) || (_connectionCloseCount != _connection.CloseCount); }
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.Item1"]/*' />
        public object this[int i] 
        {
            get { return GetValue(i); }
        }
    
        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.Item2"]/*' />
        public object this[string name] 
        {
            get { return GetValue(GetOrdinal(name)); }
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.RecordsAffected"]/*' />
        public int RecordsAffected 
        {
            get { return _recordsAffected; }
        }

#if POSTEVERETT
        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.Rowid"]/*' />
        /// <internalonly/>
        internal OracleString Rowid
        {
            get 
            {
                AssertReaderIsOpen();
                AssertReaderHasData();
                
                OciHandle rowidHandle = _statementHandle.GetRowid(EnvironmentHandle, ErrorHandle);

                // When asked for, we need to return the Rowid, but since we only have
                // the opaque descriptor, we need to get the base64 string that represents
                // it or we'll be unable to persist the value.
                return OracleCommand.GetPersistedRowid( _connection, rowidHandle );
            }
        }
#endif //POSTEVERETT

        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Methods 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////

        private void AssertReaderHasData() 
        {
            //  perform all the checks to make sure that the data reader is 
            //  not past the end of the data and not before the first row
            if (_endOfData || null == _buffer || !_buffer.CurrentPositionIsValid) 
                throw ADP.NoData();
        }
        
        private void AssertReaderIsOpen() 
        {
            //  perform all the checks to make sure that the data reader and it's
            //  connection are still open, and throw if they aren't
            
            if (null != _connection && (_connectionCloseCount != _connection.CloseCount))
                Close();

            if (null == _statementHandle)
                throw ADP.ClosedDataReaderError();
        
            if (null == _connection || ConnectionState.Open != _connection.State) 
                throw ADP.ClosedConnectionError();          
        }
        
        private object SetSchemaValue(string value) 
        {
             if (ADP.IsEmpty(value))
                return DBNull.Value;

             return value;
        }
        
        private void BuildSchemaTable() 
        {
            Debug.Assert(null == _schemaTable, "BuildSchemaTable: schema table already exists");
            Debug.Assert(null != _columnInfo, "BuildSchemaTable: no columnInfo");

            int             columnCount = FieldCount;
            OracleSqlParser parser;
            DBSqlParserColumnCollection parsedColumns = null;
            int parsedColumnsCount = 0;
 
            if (_keyInfoRequested)
            {
                parser = new OracleSqlParser();
                parser.Parse(_statementText, _connection);

                parsedColumns = parser.Columns;
                parsedColumnsCount = parsedColumns.Count;
            }


            DataTable schemaTable = new DataTable("SchemaTable");
            schemaTable.MinimumCapacity = columnCount;

            DataColumn name             = new DataColumn("ColumnName",       typeof(System.String));
            DataColumn ordinal          = new DataColumn("ColumnOrdinal",    typeof(System.Int32));
            DataColumn size             = new DataColumn("ColumnSize",       typeof(System.Int32));
            DataColumn precision        = new DataColumn("NumericPrecision", typeof(System.Int16));
            DataColumn scale            = new DataColumn("NumericScale",     typeof(System.Int16));

            DataColumn dataType         = new DataColumn("DataType",         typeof(System.Type));
            DataColumn oracleType       = new DataColumn("ProviderType",     typeof(System.Int32));

            DataColumn isLong           = new DataColumn("IsLong",           typeof(System.Boolean));
            DataColumn isNullable       = new DataColumn("AllowDBNull",      typeof(System.Boolean));
            DataColumn isAliased        = new DataColumn("IsAliased",        typeof(System.Boolean));
            DataColumn isExpression     = new DataColumn("IsExpression",     typeof(System.Boolean));
            DataColumn isKey            = new DataColumn("IsKey",            typeof(System.Boolean));
            DataColumn isUnique         = new DataColumn("IsUnique",         typeof(System.Boolean));
            
            DataColumn baseSchemaName   = new DataColumn("BaseSchemaName",   typeof(System.String));
            DataColumn baseTableName    = new DataColumn("BaseTableName",    typeof(System.String));
            DataColumn baseColumnName   = new DataColumn("BaseColumnName",   typeof(System.String));


            ordinal.DefaultValue = 0;
            isLong.DefaultValue = false;

            DataColumnCollection columns = schemaTable.Columns;

            columns.Add(name);
            columns.Add(ordinal);
            columns.Add(size);
            columns.Add(precision);
            columns.Add(scale);

            columns.Add(dataType);
            columns.Add(oracleType);

            columns.Add(isLong);
            columns.Add(isNullable);
            columns.Add(isAliased);
            columns.Add(isExpression);
            columns.Add(isKey);
            columns.Add(isUnique);

            columns.Add(baseSchemaName);
            columns.Add(baseTableName);
            columns.Add(baseColumnName);

            for (int i = 0; i < columnCount; ++i)
            {
                OracleColumn column = _columnInfo[i];

                DataRow newRow = schemaTable.NewRow();
                
                newRow[name]            = column.ColumnName;
                newRow[ordinal]         = column.Ordinal;

                if (column.IsLong | column.IsLob)
                    newRow[size]        = Int32.MaxValue;   //MDAC 82554
                else
                    newRow[size]        = column.Size;

                newRow[precision]       = column.Precision;
                newRow[scale]           = column.Scale;

                newRow[dataType]        = column.GetFieldType();
                newRow[oracleType]      = column.OracleType;
                
                newRow[isLong]          = column.IsLong | column.IsLob;
                newRow[isNullable]      = column.IsNullable;

                if (_keyInfoRequested && parsedColumnsCount == columnCount)
                {
                    DBSqlParserColumn parsedColumn = parsedColumns[i];
                    
                    newRow[isAliased]       = parsedColumn.IsAliased;
                    newRow[isExpression]    = parsedColumn.IsExpression;
                    newRow[isKey]           = parsedColumn.IsKey;
                    newRow[isUnique]        = parsedColumn.IsUnique;
                    newRow[baseSchemaName]  = SetSchemaValue(OracleSqlParser.CatalogCase(parsedColumn.SchemaName));
                    newRow[baseTableName]   = SetSchemaValue(OracleSqlParser.CatalogCase(parsedColumn.TableName));
                    newRow[baseColumnName]  = SetSchemaValue(OracleSqlParser.CatalogCase(parsedColumn.ColumnName));
                }
                else
                {
                    newRow[isAliased]       = DBNull.Value;     // don't know
                    newRow[isExpression]    = DBNull.Value;     // don't know
                    newRow[isKey]           = DBNull.Value;     // don't know
                    newRow[isUnique]        = DBNull.Value;     // don't know
                    newRow[baseSchemaName]  = DBNull.Value;     // don't know
                    newRow[baseTableName]   = DBNull.Value;     // don't know
                    newRow[baseColumnName]  = DBNull.Value;     // don't know
                }

                schemaTable.Rows.Add(newRow);
                newRow.AcceptChanges();
            }

            // mark all columns as readonly
            for (int i=0; i < columns.Count; i++) 
            {
                columns[i].ReadOnly = true;
            }

//          DataSet dataset = new DataSet();
//          dataset.Tables.Add(schemaTable);
//          Debug.WriteLine(dataset.GetXml());
//          dataset.Tables.Remove(schemaTable);
            _schemaTable = schemaTable;
        }

        private void Cleanup() 
        {
            // release everything; we can't do anything from here on out.

            if (null != _buffer)
            {
                _buffer.Dispose();
                _buffer = null;
            }

            if (null != _schemaTable)
            {
                _schemaTable.Dispose();
                _schemaTable = null;
            }
            
            _fieldNameLookup = null;

            if (null != _columnInfo)
            {
                // Only cleanup the column info when it's not the data reader
                // that owns all the ref cursor data readers; 
                if (null == _refCursorDataReaders)
                {
                    int i = _columnInfo.Length;

                    while (--i >= 0)
                    {
                        if (null != _columnInfo[i])
                        {
                            _columnInfo[i].Dispose();
                            _columnInfo[i] = null;
                        }
                    }
                }
                _columnInfo = null;
            }

        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.Close"]/*' />
        public void Close() 
        {
            // Note that we do this first, which triggers IsClosed to return true.
            OciHandle.SafeDispose(ref _statementHandle);
            
            Cleanup();

            if (null != _refCursorDataReaders)
            {
                int i = _refCursorDataReaders.Length;

                while (--i >= 0)
                {
                    OracleDataReader refCursorDataReader = _refCursorDataReaders[i];
                    _refCursorDataReaders[i] = null;

                    if (null != refCursorDataReader)
                        refCursorDataReader.Dispose();
                }
                _refCursorDataReaders = null;
            }
            
            // If we were asked to close the connection when we're closed, then we need to 
            // do that now.
            if (_closeConnectionToo && null != _connection)
                _connection.Close();

            _connection = null;
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.Dispose"]/*' />
        public void Dispose() 
        {
            Close();
        }

        internal void FillColumnInfo()
        {
            // Gather the column information for the statement handle
            
            int     columnCount;
            bool    cannotPrefetch = false;
            
            // Count the number of columns
            _statementHandle.GetAttribute(OCI.ATTR.OCI_ATTR_PARAM_COUNT, out columnCount, ErrorHandle);
            _columnInfo = new OracleColumn[columnCount];

            // Create column objects for each column, have them get their
            // descriptions and determine their location in a row buffer.
            _rowBufferLength = 0;
            for (int i = 0; i < columnCount; i++)
            {
                _columnInfo[i] = new OracleColumn(_statementHandle, i, ErrorHandle, _connection);
                if (_columnInfo[i].Describe(ref _rowBufferLength, _connection, ErrorHandle))
                    cannotPrefetch = true;
            }

            if (cannotPrefetch || 0 == _rowBufferLength)
                _rowsToPrefetch = 1;
            else
                _rowsToPrefetch = (_prefetchMemory + _rowBufferLength - 1) / _rowBufferLength;  // at least one row...

            Debug.Assert(1 <= _rowsToPrefetch, "bad prefetch rows value!");
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetDataTypeName"]/*' />
        public string GetDataTypeName(int i)
        {
            AssertReaderIsOpen();

            if (null == _columnInfo)
                throw ADP.NoData();
            
            return _columnInfo[i].GetDataTypeName();
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetEnumerator"]/*' />
        IEnumerator IEnumerable.GetEnumerator() 
        {
            return new DbEnumerator((IDataReader)this, _closeConnectionToo); 
        }
        
        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetFieldType"]/*' />
        public Type GetFieldType(int i)
        {
            AssertReaderIsOpen();
            
            if (null == _columnInfo)
                throw ADP.NoData();
            
            return _columnInfo[i].GetFieldType();
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetName"]/*' />
        public string GetName(int i)
        {
            AssertReaderIsOpen();
            
            if (null == _columnInfo)
                throw ADP.NoData();
            
            return _columnInfo[i].ColumnName;
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetOrdinal"]/*' />
        public int GetOrdinal(string name) 
        {
            AssertReaderIsOpen();
            
            if (null == _fieldNameLookup) 
            {
                if (null == _columnInfo) 
                    throw ADP.NoData();

                _fieldNameLookup = new FieldNameLookup(this, -1);
            }
            return _fieldNameLookup.GetOrdinal(name);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetSchemaTable"]/*' />
        public DataTable GetSchemaTable() 
        {
            AssertReaderIsOpen();
            
            if (null == _schemaTable) 
            {
                if (0 < FieldCount) 
                {
                     BuildSchemaTable();
                }
                else if (0 > FieldCount) 
                {
                    throw ADP.NoData();
                }
            }
            return _schemaTable;
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetValue"]/*' />
        public object GetValue(int i)
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            object value = _columnInfo[i].GetValue(_buffer);
            return value;
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetValues"]/*' />
        public int GetValues(object[] values) 
        {
            if (null == values)
                throw ADP.ArgumentNull("values");
            
            AssertReaderIsOpen();
            AssertReaderHasData();
            int copy = Math.Min(values.Length, FieldCount);
            for (int i = 0; i < copy; ++i) 
            {
                values[i] = _columnInfo[i].GetValue(_buffer);
            }
            return copy;
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetBoolean"]/*' />
        public bool GetBoolean(int i)
        {
            //  The Get<typename> methods all defer to the OracleColumn object 
            //  to perform the work.
            
            throw ADP.NotSupported();   // Oracle doesn't really have boolean values
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetByte"]/*' />
        public byte GetByte(int i)
        {
            throw ADP.NotSupported();   // Oracle doesn't really have single-byte values
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetBytes"]/*' />
        public long GetBytes(
                        int i,
                        long fieldOffset,
                        byte[] buffer2,
                        int bufferoffset,
                        int length
                        ) 
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].GetBytes(_buffer, fieldOffset, buffer2, bufferoffset, length);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetChar"]/*' />
        public char GetChar(int i)
        {
            throw ADP.NotSupported();   // Oracle doesn't really have single-char values
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetChars"]/*' />
        public long GetChars(
                        int i,
                        long fieldOffset,
                        char[] buffer2,
                        int bufferoffset,
                        int length
                        ) 
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].GetChars(_buffer, fieldOffset, buffer2, bufferoffset, length);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetData"]/*' />
        public IDataReader GetData(int i)
        {
            throw ADP.NotSupported();   // supporting nested tables require Object-Relational support, which we agreed we weren't doing
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetDateTime"]/*' />
        public DateTime GetDateTime(int i)
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].GetDateTime(_buffer);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetDecimal"]/*' />
        public decimal GetDecimal(int i)
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].GetDecimal(_buffer);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetDouble"]/*' />
        public double GetDouble(int i)
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].GetDouble(_buffer);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetFloat"]/*' />
        public float GetFloat(int i)
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].GetFloat(_buffer);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetGuid"]/*' />
        public Guid GetGuid(int i)
        {
            throw ADP.NotSupported();   // Oracle doesn't really have GUID values.
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetInt16"]/*' />
        public short GetInt16(int i)
        {
            throw ADP.NotSupported();   // Oracle doesn't really have GUID values.
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetInt32"]/*' />
        public int GetInt32(int i)
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].GetInt32(_buffer);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetInt64"]/*' />
        public long GetInt64(int i)
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].GetInt64(_buffer);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetString"]/*' />
        public string GetString(int i)
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].GetString(_buffer);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetTimeSpan"]/*' />
        public TimeSpan GetTimeSpan(int i)
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].GetTimeSpan(_buffer);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetOracleBFile"]/*' />
        public OracleBFile GetOracleBFile(int i)
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].GetOracleBFile(_buffer);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetOracleBinary"]/*' />
        public OracleBinary GetOracleBinary(int i)
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].GetOracleBinary(_buffer);
        }
        
        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetOracleDateTime"]/*' />
        public OracleDateTime GetOracleDateTime(int i)
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].GetOracleDateTime(_buffer);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetOracleLob"]/*' />
        public OracleLob GetOracleLob(int i)
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].GetOracleLob(_buffer);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetOracleMonthSpan"]/*' />
        public OracleMonthSpan GetOracleMonthSpan(int i)
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].GetOracleMonthSpan(_buffer);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetOracleNumber"]/*' />
        public OracleNumber GetOracleNumber(int i)
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].GetOracleNumber(_buffer);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetOracleString"]/*' />
        public OracleString GetOracleString(int i)
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].GetOracleString(_buffer);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetOracleTimeSpan"]/*' />
        public OracleTimeSpan GetOracleTimeSpan(int i)
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].GetOracleTimeSpan(_buffer);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetOracleValue"]/*' />
        public object GetOracleValue(int i)
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].GetOracleValue(_buffer);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.GetOracleValues"]/*' />
        public int GetOracleValues(object[] values) 
        {
            if (null == values)
                throw ADP.ArgumentNull("values");
            
            AssertReaderIsOpen();
            AssertReaderHasData();
            int copy = Math.Min(values.Length, FieldCount);
            for (int i = 0; i < copy; ++i) 
            {
                values[i] = GetOracleValue(i);
            }
            return copy;
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.IsDBNull"]/*' />
        public bool IsDBNull(int i)
        {
            AssertReaderIsOpen();
            AssertReaderHasData();
            return _columnInfo[i].IsDBNull(_buffer);
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.NextResult"]/*' />
        public bool NextResult() 
        {
            AssertReaderIsOpen();
            return NextResultInternal();
        }

        private bool NextResultInternal() 
        {
            Cleanup();

            if (null == _refCursorDataReaders || _nextRefCursor >= _refCursorDataReaders.Length)
            {
                _endOfData = true; // force current result to be done.
                _hasRows = x_hasRows_False;
                return false;
            }

            if (_nextRefCursor > 0)
            {
                _refCursorDataReaders[_nextRefCursor-1].Dispose();
                _refCursorDataReaders[_nextRefCursor-1] = null;
            }

            OciHandle oldStatementHandle = _statementHandle;
            _statementHandle        = _refCursorDataReaders[_nextRefCursor]._statementHandle;
            OciHandle.SafeDispose(ref oldStatementHandle);
            
            _connection             = _refCursorDataReaders[_nextRefCursor]._connection;
            _connectionCloseCount   = _refCursorDataReaders[_nextRefCursor]._connectionCloseCount;
            _hasRows                = _refCursorDataReaders[_nextRefCursor]._hasRows;
            _recordsAffected        = _refCursorDataReaders[_nextRefCursor]._recordsAffected;
            _columnInfo             = _refCursorDataReaders[_nextRefCursor]._columnInfo;
            _rowBufferLength        = _refCursorDataReaders[_nextRefCursor]._rowBufferLength;
            _rowsToPrefetch         = _refCursorDataReaders[_nextRefCursor]._rowsToPrefetch;
            
            _nextRefCursor++;
            _endOfData = false;
            _isLastBuffer = false;
            _rowsTotal = 0;
            return true;
        }

        /// <include file='doc\OracleDataReader.uex' path='docs/doc[@for="OracleDataReader.Read"]/*' />
        public bool Read() 
        {
            AssertReaderIsOpen();

            bool result = ReadInternal();

            if (result)
                _hasRows = x_hasRows_True;

            return result;
        }
    
        private bool ReadInternal() 
        {
            if (_endOfData)
                return false;

            int rc;
            int columnCount = _columnInfo.Length;
            int i;

            // Define each of the column buffers to Oracle, but only if it hasn't
            // been defined before.
            if (null == _buffer)
            {
                int templen = (_rowsToPrefetch > 1) ? _rowBufferLength : 0;  // Only tell oracle about the buffer length if we intend to fetch more rows

                NativeBuffer buffer = new NativeBuffer_RowBuffer(_rowBufferLength);
                buffer.NumberOfRows = _rowsToPrefetch;

                for (i = 0; i < columnCount; ++i)
                    _columnInfo[i].Bind(_statementHandle, buffer, ErrorHandle, templen);

                _buffer = buffer;
            }

            // If we still have more data in the buffers we've pre-fetched, then
            // we'll use it; we don't want to go to the server more than we absolutely
            // have to.
            if (_buffer.MoveNext())
                return true;

            // If we've read the last buffer, and we've exhausted it, then we're
            // really at the end of the data.
            if ( _isLastBuffer )
            {
                _endOfData = true;
                return false;
            }

            // Reset the buffer back to the beginning.
            _buffer.MoveFirst();

            // For LONG and LOB data, we have to do work to prepare for each row (that's
            // why we don't prefetch rows that have these data types)
            if (1 == _rowsToPrefetch)
            {
                for (i = 0; i < columnCount; ++i)
                    _columnInfo[i].Rebind(_connection);
            }

            // Now fetch the rows required.
            Debug.Assert(0 < _rowsToPrefetch, "fetching 0 rows will cancel the cursor");
            rc = TracedNativeMethods.OCIStmtFetch(
                                    _statementHandle,           // stmtp
                                    ErrorHandle,                // errhp
                                    _rowsToPrefetch,            // crows
                                    OCI.FETCH.OCI_FETCH_NEXT,   // orientation
                                    OCI.MODE.OCI_DEFAULT        // mode
                                    );

            // Keep track of how many rows we actually fetched so far.
            int previousRowsTotal = _rowsTotal;
            _statementHandle.GetAttribute(OCI.ATTR.OCI_ATTR_ROW_COUNT, out _rowsTotal, ErrorHandle);

            if (0 == rc)
                return true;

            if ((int)OCI.RETURNCODE.OCI_SUCCESS_WITH_INFO == rc) 
            {
                _connection.CheckError(ErrorHandle, rc);
                return true;
            }
            if ((int)OCI.RETURNCODE.OCI_NO_DATA == rc)
            {
                int rowsFetched = _rowsTotal - previousRowsTotal;

                if (0 == rowsFetched)
                {
                    if (0 == _rowsTotal)
                        _hasRows = x_hasRows_False;
                    
                    _endOfData = true;
                    return false;
                }
            
                _buffer.NumberOfRows = rowsFetched;
                _isLastBuffer = true;
                return true;
            }

            _endOfData = true;
            _connection.CheckError(ErrorHandle, rc);
            return false;
        }   
    };
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oraclecommandbuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="OracleCommandBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OracleClient {

    using System;
	using System.Collections;
	using System.ComponentModel;
	using System.Data;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Globalization;
    using System.Text;

    /// <include file='doc\OracleCommandBuilder.uex' path='docs/doc[@for="OracleCommandBuilder"]/*' />
    sealed public class OracleCommandBuilder : Component {
        private const string deleteCommandString = "DeleteCommand";
        private const string updateCommandString = "UpdateCommand";

        private const string DeleteFrom          = "DELETE FROM ";

        private const string InsertInto          = "INSERT INTO ";
        private const string DefaultValues       = " DEFAULT VALUES";
        private const string Values              = " VALUES ";

        private const string Update              = "UPDATE ";
        private const string Set                 = " SET ";

        private const string Where               = " WHERE ";

        private const string Comma               = ", ";
        private const string Equal               = " = ";
        private const string LeftParenthesis     = "(";
        private const string RightParenthesis    = ")";
        private const string NameSeparator       = ".";

        private const string IsNull              = " IS NULL";
        private const string EqualOne			 = " = 1";
        private const string And                 = " AND ";
        private const string Or                  = " OR ";

		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
        //
        // Fields
        //
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        private IDbDataAdapter          _dataAdapter;

        private IDbCommand              _insertCommand;
        private IDbCommand              _updateCommand;
        private IDbCommand              _deleteCommand;

        private MissingMappingAction    _missingMappingAction;

        private CommandBuilderBehavior  _behavior;

        private DataTable               _dbSchemaTable;
        private DBSchemaRow[]           _dbSchemaRows;
        private string[]                _sourceColumnNames;

        private string                  _quotedBaseTableName;

        private CatalogLocation 		_catalogLocation;
        private string 					_catalogSeparator;
        private string 					_schemaSeparator;
        
        // quote strings to use around SQL object names
        private string                  _quotePrefix;
        private string                  _quoteSuffix;

        private StringBuilder           _builder;

		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
        //
        // Constructor 
        //
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
//V2    /// <include file='doc\DBCommandBuilder.uex' path='docs/doc[@for="DBCommandBuilder.DBCommandBuilder1"]/*' />
//V2    public DBCommandBuilder() : base() { }


		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
        //
        // Properties 
        //
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

#if POSTEVERETT		
        internal CommandBuilderBehavior Behavior {
		    get { return _behavior; }
		    set { _behavior = value; }
		}
#endif //POSTEVERETT		

        internal CatalogLocation CatalogLocation { 
          // MDAC 79449
            get {
                return _catalogLocation;
            }
#if POSTEVERETT
            set {
                if (null != _dbSchemaTable) {
                    throw ADP.NoCatalogLocationChange();
                }
                switch(value) {
                case CatalogLocation.Start:
                case CatalogLocation.End:
                    _catalogLocation = value;
                    break;

                default:
                    throw ADP.InvalidCatalogLocation(value);
                }
            }
#endif //POSTEVERETT
        }

        internal string CatalogSeparator { 
          // MDAC 79449
            get {
                string catalogSeparator = _catalogSeparator;
                return (((null != catalogSeparator) && (0 < catalogSeparator.Length)) ? catalogSeparator : NameSeparator);
            }
#if POSTEVERETT
            set {
                if (null != _dbSchemaTable) {
                    throw ADP.NoCatalogLocationChange();
                }
                _catalogSeparator = value;
            }
 #endif //POSTEVERETT
       }
       
        private string QuotedBaseTableName {
            get {
                return _quotedBaseTableName;
            }
        }

        /// <include file='doc\OracleCommandBuilder.uex' path='docs/doc[@for="OracleCommandBuilder.QuotePrefix"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        OracleDescription(Res.OracleCommandBuilder_QuotePrefix)
        ]
        public string QuotePrefix {
            get {
                string quotePrefix = _quotePrefix;
                return ((null != quotePrefix) ? quotePrefix : ADP.StrEmpty);
            }
            set {
                if (null != _dbSchemaTable) {
                    throw ADP.NoQuoteChange();
                }
                _quotePrefix = value;
            }
        }

        /// <include file='doc\OracleCommandBuilder.uex' path='docs/doc[@for="OracleCommandBuilder.QuoteSuffix"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        OracleDescription(Res.OracleCommandBuilder_QuoteSuffix)
        ]
        public string QuoteSuffix {
            get {
                string quoteSuffix = _quoteSuffix;
                return ((null != quoteSuffix) ? quoteSuffix : ADP.StrEmpty);
            }
            set {
                if (null != _dbSchemaTable) {
                    throw ADP.NoQuoteChange();
                }
                _quoteSuffix = value;
            }
        }

        internal string SchemaSeparator { 
          // MDAC 79449
            get {
                string schemaSeparator = _schemaSeparator;
                return (((null != schemaSeparator) && (0 < schemaSeparator.Length)) ? schemaSeparator : NameSeparator);
            }
#if POSTEVERETT
            set {
                if (null != _dbSchemaTable) {
                    throw ADP.NoCatalogLocationChange();
                }
                _schemaSeparator = value;
            }
#endif //POSTEVERETT
        }

        //----------------------------------------------------------------------
        // DbDataAdapter
        //
        private IDbDataAdapter DbDataAdapter {
            get {
                return _dataAdapter;
            }
            set {
                _dataAdapter = value;
            }
        }
        //----------------------------------------------------------------------
        // {Insert,Update,Delete}Command
        //
        private IDbCommand InsertCommand {
            get { return _insertCommand; }
            set { _insertCommand = value; }
        }

        private IDbCommand UpdateCommand {
            get { return _updateCommand; }
            set { _updateCommand = value; }
        }

        private IDbCommand DeleteCommand {
            get { return _deleteCommand; }
            set { _deleteCommand = value; }
        }

        ////////////////////////////////////////////////////////////////////////
        //
        // Methods 
        //
        ////////////////////////////////////////////////////////////////////////

        //----------------------------------------------------------------------
        // BuildCache()
        //
        private void BuildCache(bool closeConnection) {
            // Don't bother building the cache if it's done already; wait for
            // the user to call RefreshSchema first.
            if (null != _dbSchemaTable) {
                return;
            }

            IDbCommand srcCommand = GetSelectCommand();

            IDbConnection connection = srcCommand.Connection;
            if (null == connection) {
                throw ADP.MissingSourceCommandConnection();
            }

            try {
	            try {
	                if (0 == (ConnectionState.Open & connection.State)) {
	                    connection.Open();
	                }
	                else {
	                    closeConnection = false;
	                }

	                DataTable schemaTable = null;
	                using(IDataReader dataReader = srcCommand.ExecuteReader(CommandBehavior.SchemaOnly | CommandBehavior.KeyInfo)) {
	                    schemaTable = dataReader.GetSchemaTable();
	                }
	                if (null == schemaTable) {
	                    throw ADP.DynamicSQLNoTableInfo();
	                }
	#if DEBUG
	                if (AdapterSwitches.DBCommandBuilder.TraceVerbose) {
	                    ADP.TraceDataTable("CommandBuilder", schemaTable);
	                }
	#endif
	                BuildInformation(schemaTable);

	                _dbSchemaTable = schemaTable;

	                int count = _dbSchemaRows.Length;

	                _sourceColumnNames = new string[count];
	                for (int i = 0; i < count; ++i) {
	                    if (null != _dbSchemaRows[i])
	                        _sourceColumnNames[i] = _dbSchemaRows[i].ColumnName;
	                    }

	                ADP.BuildSchemaTableInfoTableNames(_sourceColumnNames);
	            }
	            finally {
	                if (closeConnection) {
	                    connection.Close();
	                }
	            }
 			}
            catch { // Prevent exception filters from running in our space
	        	throw;
        	}
       }

        //----------------------------------------------------------------------
        // BuildInformation()
        //
        private void BuildInformation(DataTable schemaTable) {
            DBSchemaRow[] rows = DBSchemaRow.GetSortedSchemaRows(schemaTable); // MDAC 60609
            if ((null == rows) || (0 == rows.Length)) {
                throw ADP.DynamicSQLNoTableInfo();
            }

            string baseServerName = ""; // MDAC 72721, 73599
            string baseCatalogName = "";
            string baseSchemaName = "";
            string baseTableName = null;

            for (int i = 0; i < rows.Length; ++i) {
                DBSchemaRow row = rows[i];
                string tableName = row.BaseTableName;
                if ((null == tableName) || (0 == tableName.Length)) {
                    rows[i] = null;
                    continue;
                }

                string serverName = row.BaseServerName;
                string catalogName = row.BaseCatalogName;
                string schemaName = row.BaseSchemaName;
                if (null == serverName) {
                    serverName = "";
                }
                if (null == catalogName) {
                    catalogName = "";
                }
                if (null == schemaName) {
                    schemaName = "";
                }
                if (null == baseTableName) {
                    baseServerName = serverName;
                    baseCatalogName = catalogName;
                    baseSchemaName = schemaName;
                    baseTableName = tableName;
                }
                else if (  (0 != ADP.SrcCompare(baseTableName, tableName))
                        || (0 != ADP.SrcCompare(baseSchemaName, schemaName))
                        || (0 != ADP.SrcCompare(baseCatalogName, catalogName))
                        || (0 != ADP.SrcCompare(baseServerName, serverName))) {
                    throw ADP.DynamicSQLJoinUnsupported();
                }
            }
            if (0 == baseServerName.Length) {
                baseServerName = null;
            }
            if (0 == baseCatalogName.Length) {
                baseServerName = null;
                baseCatalogName = null;
            }
            if (0 == baseSchemaName.Length) {
                baseServerName = null;
                baseCatalogName = null;
                baseSchemaName = null;
            }
            if ((null == baseTableName) || (0 == baseTableName.Length)) {
                throw ADP.DynamicSQLNoTableInfo();
            }

            CatalogLocation location = CatalogLocation;
            string catalogSeparator = CatalogSeparator;
            string schemaSeparator = SchemaSeparator;

            string quotePrefix = QuotePrefix;
            string quoteSuffix = QuoteSuffix;

            if (!ADP.IsEmpty(quotePrefix) && (-1 != baseTableName.IndexOf(quotePrefix))) {
                throw ADP.DynamicSQLNestedQuote(baseTableName, quotePrefix);
            }
            if (!ADP.IsEmpty(quoteSuffix) && (-1 != baseTableName.IndexOf(quoteSuffix))) {
                throw ADP.DynamicSQLNestedQuote(baseTableName, quoteSuffix);
            }

            System.Text.StringBuilder builder = new System.Text.StringBuilder();

            if (CatalogLocation.Start == location) { 
              // MDAC 79449
	            if (null != baseServerName) {
                    builder.Append(quotePrefix);
                    builder.Append(baseServerName);
                    builder.Append(quoteSuffix);
                    builder.Append(catalogSeparator);
	            }
	            if (null != baseCatalogName) {
                    builder.Append(quotePrefix);
                    builder.Append(baseCatalogName);
                    builder.Append(quoteSuffix);
                    builder.Append(catalogSeparator);
                }
            }
            if (null != baseSchemaName) {
                builder.Append(quotePrefix);
                builder.Append(baseSchemaName);
                builder.Append(quoteSuffix);
                builder.Append(schemaSeparator);
            }
            builder.Append(quotePrefix);
            builder.Append(baseTableName);
            builder.Append(quoteSuffix);

            if (CatalogLocation.End == location) { 
              // MDAC 79449
                if (null != baseServerName) {
                    builder.Append(catalogSeparator);
                    builder.Append(quotePrefix);
                    builder.Append(baseServerName);
                    builder.Append(quoteSuffix);
                }
                if (null != baseCatalogName) {
                    builder.Append(catalogSeparator);
                    builder.Append(quotePrefix);
                    builder.Append(baseCatalogName);
                    builder.Append(quoteSuffix);
                }
            }
            _quotedBaseTableName = builder.ToString();

            _dbSchemaRows = rows;
        }

        //----------------------------------------------------------------------
        // BuildDeleteCommand()
        //
        private IDbCommand BuildDeleteCommand(DataTableMapping mappings, DataRow dataRow) {
            IDbCommand command = InitializeCommand(DeleteCommand);
            StringBuilder builder = GetStringBuilder();
            int             parameterCount  = 0;

            Debug.Assert (!ADP.IsEmpty(_quotedBaseTableName), "no table name");

            builder.Append(DeleteFrom);
            builder.Append(QuotedBaseTableName);

            parameterCount = BuildWhereClause(mappings, dataRow, builder, command, parameterCount, false);

            command.CommandText = builder.ToString();

            RemoveExtraParameters(command, parameterCount);
#if DEBUG
            if (AdapterSwitches.DBCommandBuilder.TraceInfo) {
                ADP.DebugWriteLine(command.CommandText);
            }
#endif
            DeleteCommand = command;
            return command;
        }

        //----------------------------------------------------------------------
        // BuildInsertCommand()
        //
        private IDbCommand BuildInsertCommand(DataTableMapping mappings, DataRow dataRow) {
            IDbCommand command = InitializeCommand(InsertCommand);
            StringBuilder builder = GetStringBuilder();
            int             parameterCount  = 0;
            string          nextSeparator   = LeftParenthesis;

            Debug.Assert (!ADP.IsEmpty(_quotedBaseTableName), "no table name");

            builder.Append(InsertInto);
            builder.Append(QuotedBaseTableName);

            // search for the columns in that base table, to be the column clause
            int length = _dbSchemaRows.Length;

            string[]    parameterName = new string[length];

            for (int i = 0; i < length; ++i) {
                DBSchemaRow row = _dbSchemaRows[i];

                if ( (null == row) || (0 == row.BaseColumnName.Length) || !IncludeInInsertValues(row) )
                    continue;

                object currentValue = null;
                string sourceColumn = _sourceColumnNames[i];

                // If we're building a statement for a specific row, then check the
                // values to see whether the column should be included in the insert
                // statement or not
                if ((null != mappings) && (null != dataRow)) {
                    DataColumn dataColumn = GetDataColumn(sourceColumn, mappings, dataRow);

                    if (null == dataColumn)
                        continue;

                    // Don't bother inserting if the column is readonly in both the data
                    // set and the back end.
                    if (row.IsReadOnly && dataColumn.ReadOnly)
                        continue;

                    currentValue = GetColumnValue(dataRow, dataColumn, DataRowVersion.Current);

                    // If the value is null, and the column doesn't support nulls, then
                    // the user is requesting the server-specified default value, so don't
                    // include it in the set-list.
                    if ( !row.AllowDBNull && (null == currentValue || Convert.IsDBNull(currentValue)) )
                        continue;
                }

                builder.Append(nextSeparator);
                nextSeparator = Comma;
                builder.Append(QuotedColumn(row.BaseColumnName));

                parameterName[parameterCount] = CreateParameterForValue(command,
                                                                        sourceColumn,
                                                                        DataRowVersion.Current,
                                                                        parameterCount,
                                                                        currentValue,
                                                                        row
                                                                        );
                parameterCount++;
                }

            if (0 == parameterCount)
                builder.Append(DefaultValues);
            else {
                builder.Append(RightParenthesis);
                builder.Append(Values);
                builder.Append(LeftParenthesis);

                builder.Append(parameterName[0]);
                for (int i = 1; i < parameterCount; ++i) {
                    builder.Append(Comma);
                    builder.Append(parameterName[i]);
                }

                builder.Append(RightParenthesis);
            }

            command.CommandText = builder.ToString();

            RemoveExtraParameters(command, parameterCount);
#if DEBUG
            if (AdapterSwitches.DBCommandBuilder.TraceInfo) {
                ADP.DebugWriteLine(command.CommandText);
            }
#endif
            InsertCommand = command;
            return command;
        }

        //----------------------------------------------------------------------
        // BuildUpdateCommand()
        //
        private IDbCommand BuildUpdateCommand(DataTableMapping mappings, DataRow dataRow) {
            IDbCommand command = InitializeCommand(UpdateCommand);
            StringBuilder builder = GetStringBuilder();
            int             parameterCount  = 0;
            string          nextSeparator   = Set;

            Debug.Assert (!ADP.IsEmpty(_quotedBaseTableName), "no table name");

            builder.Append(Update);
            builder.Append(QuotedBaseTableName);

            // search for the columns in that base table, to build the set clause
            int length = _dbSchemaRows.Length;
            for (int i = 0; i < length; ++i) {
                DBSchemaRow row = _dbSchemaRows[i];

                if ((null == row) || (0 == row.BaseColumnName.Length) || !IncludeInUpdateSet(row))
                    continue;

/*

// DEVNOTE: you can use this case statement to limit the data types you allow
//			in the statements, for testing purposes.

switch ((OracleType)row.DataRow["ProviderType", DataRowVersion.Default])
{
case OracleType.Char:
case OracleType.LongVarChar:
	continue;
}
*/

                object currentValue = null;
                string sourceColumn = _sourceColumnNames[i];

                // If we're building a statement for a specific row, then check the
                // values to see whether the column should be included in the update
                // statement or not
                if ((null != mappings) && (null != dataRow)) {
                    DataColumn  dataColumn = GetDataColumn(sourceColumn, mappings, dataRow);

                    if (null == dataColumn)
                        continue;

                    // Don't bother updating if the column is readonly in both the data
                    // set and the back end.
                    if (row.IsReadOnly && dataColumn.ReadOnly)
                        continue;

                    // Unless specifically directed to do so, we will not automatically update
                    // a column with it's original value, which means that we must determine
                    // whether the value has changed locally, before we send it up.
                    currentValue = GetColumnValue(dataRow, dataColumn, DataRowVersion.Current);

                    if (IsNotBehavior(CommandBuilderBehavior.UpdateSetSameValue)) {
                        object originalValue = GetColumnValue(dataRow, dataColumn, DataRowVersion.Original);

                        if ((originalValue == currentValue)
                                || ((null != originalValue) && originalValue.Equals(currentValue))) {
                            continue;
                        }
                    }
                }

                builder.Append(nextSeparator);
                nextSeparator = Comma;

                builder.Append(QuotedColumn(row.BaseColumnName));
                builder.Append(Equal);
                builder.Append(CreateParameterForValue(command,
                                                        sourceColumn,
                                                        DataRowVersion.Current,
                                                        parameterCount,
                                                        currentValue,
                                                        row
                                                        ));
                parameterCount++;
            }

            // It is an error to attempt an update when there's nothing to update;
            bool skipRow = (0 == parameterCount);

            parameterCount = BuildWhereClause(mappings, dataRow, builder, command, parameterCount, true);

            command.CommandText = builder.ToString();

            RemoveExtraParameters(command, parameterCount);
#if DEBUG
            if (AdapterSwitches.DBCommandBuilder.TraceInfo) {
                ADP.DebugWriteLine(command.CommandText);
            }
#endif
            UpdateCommand = command;
            return (skipRow) ? null : command;
        }

        //----------------------------------------------------------------------
        // BuildWhereClause()
        //
        private int BuildWhereClause(
                DataTableMapping mappings,
                DataRow          dataRow,
                StringBuilder    builder,
                IDbCommand       command,
                int              parameterCount,
                bool             isupdate
                )
        {
            string  beginNewCondition = string.Empty;
            int     length = _dbSchemaRows.Length;
            int     whereCount = 0;

            builder.Append(Where);
            builder.Append(LeftParenthesis);

            for (int i = 0; i < length; ++i) {
                DBSchemaRow row = _dbSchemaRows[i];

                if ( (null == row) || (0 == row.BaseColumnName.Length) || !IncludeInWhereClause(row, isupdate))
                    continue;

/*
// DEVNOTE: you can use this case statement to limit the data types you allow
//			in the statements, for testing purposes.

switch ((OracleType)row.DataRow["ProviderType", DataRowVersion.Default])
{
case OracleType.VarChar:
	continue;
}
*/
                builder.Append(beginNewCondition);
                beginNewCondition = And;

                object value = null;
                string sourceColumn = _sourceColumnNames[i];
                string baseColumnName = QuotedColumn(row.BaseColumnName);

                if ((null != mappings) && (null != dataRow))
                    value = GetColumnValue(dataRow, sourceColumn, mappings, DataRowVersion.Original);

                if ( !row.AllowDBNull ) {
                    //  (<baseColumnName> = ?)
                    builder.Append(LeftParenthesis);
                    builder.Append(baseColumnName);
                    builder.Append(Equal);
                    builder.Append(CreateParameterForValue(command,
                                                            sourceColumn,
                                                            DataRowVersion.Original,
                                                            parameterCount,
                                                            value,
                                                            row
                                                            ));
                    parameterCount++;
                    builder.Append(RightParenthesis);
                }
                else {
                    //  ((? = 1 AND <baseColumnName> IS NULL) OR (<baseColumnName> = ?))
                    builder.Append(LeftParenthesis);

                    builder.Append(LeftParenthesis);
                    builder.Append(CreateParameterForNullTest(command,
                                                            parameterCount,
                                                            value
                                                            ));
                    parameterCount++;
                    builder.Append(EqualOne);
					builder.Append(And);
                    builder.Append(baseColumnName);
                    builder.Append(IsNull);
                    builder.Append(RightParenthesis);

                    builder.Append(Or);

                    builder.Append(LeftParenthesis);
                    builder.Append(baseColumnName);
                    builder.Append(Equal);
                    builder.Append(CreateParameterForValue(command,
                                                            sourceColumn,
                                                            DataRowVersion.Original,
                                                            parameterCount,
                                                            value,
                                                            row
                                                            ));
                    parameterCount++;
                    builder.Append(RightParenthesis);

                    builder.Append(RightParenthesis);
                    }

                if (IncrementWhereCount(row))
                    whereCount++;

                }

            builder.Append(RightParenthesis);

            if (0 == whereCount)
                throw ADP.DynamicSQLNoKeyInfo(isupdate ? updateCommandString : deleteCommandString);

            return parameterCount;
        }

        //----------------------------------------------------------------------
        // CreateParameterForNullTest()
        //
        private string CreateParameterForNullTest(
                IDbCommand      command,
                int             parameterCount,
                object          value
                )
        {
            IDbDataParameter p = GetNextParameter(command, parameterCount);

            p.ParameterName = GetParameterName(1+parameterCount);
            p.Direction     = ParameterDirection.Input;
            p.Value         = (ADP.IsNull(value)) ? 1 : 0;
			p.DbType		= DbType.Int32;

            if (!command.Parameters.Contains(p)) {
                command.Parameters.Add(p);
            }

            return GetParameterPlaceholder(1+parameterCount);
        }

        //----------------------------------------------------------------------
        // CreateParameterForValue()
        //
        private string CreateParameterForValue(
                IDbCommand      command,
                string          sourceColumn,
                DataRowVersion  version,
                int             parameterCount,
                object          value,
                DBSchemaRow     row
                )
        {
            IDbDataParameter p = GetNextParameter(command, parameterCount);

            p.ParameterName = GetParameterName(1+parameterCount);
            p.Direction     = ParameterDirection.Input;
            p.SourceColumn  = sourceColumn;
            p.SourceVersion = version;
            p.Value         = value;
            p.Size          = 0; // don't specify parameter.Size so that we don't silently truncate to the metadata size

            if (0xff != (byte) row.Precision) {
                p.Precision = (byte) row.Precision;
            }
            if (0xff != (byte) row.Scale) {
                p.Scale = (byte) row.Scale;
            }

            ApplyParameterInfo(p, row.DataRow);

            if (!command.Parameters.Contains(p)) {
                command.Parameters.Add(p);
            }

            return GetParameterPlaceholder(1+parameterCount);
        }

        //----------------------------------------------------------------------
        // Dispose()
        //
        private void base_Dispose(bool disposing) {
	        // MDAC 65459
            if (disposing) {
            	// release mananged objects
                RefreshSchema();
                DbDataAdapter = null;
            }
            //release unmanaged objects

            base.Dispose(disposing); // notify base classes
        }

        //----------------------------------------------------------------------
        // GetSelectCommand()
        //
       	private IDbCommand GetSelectCommand() {
            IDbDataAdapter adapter = DbDataAdapter;
            if (null == adapter) {
                throw ADP.MissingSourceCommand();
            }
            if (0 == _missingMappingAction) {
                _missingMappingAction = adapter.MissingMappingAction;
            }
            IDbCommand select = ((null != adapter) ? adapter.SelectCommand : null);
            if (null == select) {
                throw ADP.MissingSourceCommand();
            }
            return select;
        }

        //----------------------------------------------------------------------
        // Get{Insert,Update,Delete}Command()
        //
        private IDbCommand base_GetInsertCommand()
        {
            BuildCache(true);
            BuildInsertCommand(null, null); 
            return InsertCommand;
        }

        private IDbCommand base_GetUpdateCommand() {
            BuildCache(true);
            BuildUpdateCommand(null, null);
            return UpdateCommand;
        }

        private IDbCommand base_GetDeleteCommand() {
            BuildCache(true);
            BuildDeleteCommand(null, null);
            return DeleteCommand;
        }

        //----------------------------------------------------------------------
        // FindBuilder()
        //
        static internal Delegate FindBuilder(MulticastDelegate mcd) {
            if (null != mcd) {
                Delegate[] d = mcd.GetInvocationList();
                for (int i = 0; i < d.Length; i++) {
                    if (d[i].Target is OracleCommandBuilder)
                        return d[i];
                }
            }

            return null;
        }

        //----------------------------------------------------------------------
        // GetColumnValue()
        //
        private object GetColumnValue(
                DataRow          row,
                String           columnName,
                DataTableMapping mappings,
                DataRowVersion   version
                )
        {
            return GetColumnValue(row, GetDataColumn(columnName, mappings, row), version);
        }

        private object GetColumnValue(
                DataRow         row,
                DataColumn      column,
                DataRowVersion  version
                )
        {
            if (null != column)
                return row[column, version];

            return null;
        }

        //----------------------------------------------------------------------
        // GetDataColumn()
        //
#if V2
        private DataColumn GetDataColumn(string columnName, DataTableMapping tablemapping, DataRow row) 
        {
            DataColumn column = null;
            if (!ADP.IsEmpty(columnName)) {
                column = tablemapping.GetDataColumn(columnName, null, row.Table, _missingMappingAction, MissingSchemaAction.Error);
            }
            return column;
        }
#else
        private DataColumn GetDataColumn(
                string           columnName, 
                DataTableMapping mappings, 
                DataRow          row
                ) 
        {
            if (!ADP.IsEmpty(columnName)) {
                DataColumnMapping columnMapping = mappings.GetColumnMappingBySchemaAction(
                                                                            columnName,
                                                                            _missingMappingAction);
                if (null != columnMapping)
                    return columnMapping.GetDataColumnBySchemaAction(row.Table, null, MissingSchemaAction.Error);
            }
            return null;
        }
#endif

        //----------------------------------------------------------------------
        // GetNextParameter()
        //
        static private IDbDataParameter GetNextParameter(IDbCommand command, int pcount) {
            if (pcount < command.Parameters.Count) {
                IDbDataParameter p = (IDbDataParameter) command.Parameters[pcount];
#if DEBUG
                if (AdapterSwitches.DBCommandBuilder.TraceVerbose) {
                    Debug.WriteLine("reusing " + p.GetType().Name + " " + p.ParameterName);
                }
#endif
                return p;
            }
            return (IDbDataParameter)command.CreateParameter();
        }

        //----------------------------------------------------------------------
        // GetStringBuilder()
        //
        private StringBuilder GetStringBuilder() {
            StringBuilder builder = _builder;
            if (null == builder) {
                builder = new StringBuilder();
                _builder = builder;
            }
            builder.Length = 0;
            return builder;
        }

        //----------------------------------------------------------------------
        // IncludeInInsertValues()
        //
        private bool IncludeInInsertValues(DBSchemaRow row) {
            return (!row.IsAutoIncrement && !row.IsHidden && !row.IsExpression && !row.IsRowVersion);
        }

        //----------------------------------------------------------------------
        // IncludeInUpdateSet()
        //
        private bool IncludeInUpdateSet(DBSchemaRow row) {
            return (!row.IsAutoIncrement && !row.IsRowVersion && !row.IsHidden);
        }

        //----------------------------------------------------------------------
        // IncludeInWhereClause()
        //
        private bool IncludeInWhereClause(DBSchemaRow row, bool isupdate) {
            if (isupdate) {
                if (IsBehavior(CommandBuilderBehavior.UseRowVersionInUpdateWhereClause))
                    return (row.IsRowVersion || row.IsKey || row.IsUnique) && !row.IsLong && !row.IsHidden;

                return ((IsNotBehavior(CommandBuilderBehavior.PrimaryKeyOnlyUpdateWhereClause) || row.IsKey || row.IsUnique)
                        && !row.IsLong && (row.IsKey || !row.IsRowVersion) && !row.IsHidden);
            }
            if (IsBehavior(CommandBuilderBehavior.UseRowVersionInDeleteWhereClause))
                return (row.IsRowVersion || row.IsKey || row.IsUnique) && !row.IsLong && !row.IsHidden;

            return ((IsNotBehavior(CommandBuilderBehavior.PrimaryKeyOnlyDeleteWhereClause) || row.IsKey || row.IsUnique)
                    && !row.IsLong && (row.IsKey || !row.IsRowVersion) && !row.IsHidden);
        }

        //----------------------------------------------------------------------
        // IncrementWhereCount()
        //
        private bool IncrementWhereCount(DBSchemaRow row) {
            return (row.IsKey || row.IsUnique);
        }

#if POSTEVERETT		
        //----------------------------------------------------------------------
        // InitializeCommand()
        //
 		private IDbCommand base_InitializeCommand(IDbCommand command) {
            if (null == command) {
                IDbCommand select = GetSelectCommand();
                command = select.Connection.CreateCommand();

                // the following properties are only initialized when the object is created
                // all other properites are reinitialized on every row
              /*command.Connection = select.Connection;*/ // initialized by CreateCommand
                command.CommandTimeout = select.CommandTimeout; 
                command.Transaction = select.Transaction;
            }
            command.CommandType      = CommandType.Text;
            command.UpdatedRowSource = UpdateRowSource.None; // no select or output parameters expected 
            return command;
        }
#endif //POSTEVERETT		

        //----------------------------------------------------------------------
        // IsBehavior()
        //
        private bool IsBehavior(CommandBuilderBehavior behavior) {
            return (behavior == (_behavior & behavior));
        }

        //----------------------------------------------------------------------
        // IsNotBehavior()
        //
        private bool IsNotBehavior(CommandBuilderBehavior behavior) {
            return (behavior != (_behavior & behavior));
        }

        //----------------------------------------------------------------------
        // QuotedColumn()
        //
        private string QuotedColumn(string column) {
            return QuotePrefix + column + QuoteSuffix;
        }

        //----------------------------------------------------------------------
        // RefreshSchema()
        //
        /// <include file='doc\OracleCommandBuilder.uex' path='docs/doc[@for="OracleCommandBuilder.RefreshSchema"]/*' />
        public void RefreshSchema() {
            _dbSchemaTable = null;
            _dbSchemaRows = null;
            _sourceColumnNames = null;
            _quotedBaseTableName = null;

            IDbDataAdapter adapter = DbDataAdapter;
            if (null != adapter) {
            	// MDAC 66016

                if (InsertCommand == adapter.InsertCommand) {
                    adapter.InsertCommand = null;
                }
                if (UpdateCommand == adapter.UpdateCommand) {
                    adapter.UpdateCommand = null;
                }
                if (DeleteCommand == adapter.DeleteCommand) {
                    adapter.DeleteCommand = null;
                }
            }

            if (null != InsertCommand)
                InsertCommand.Dispose();

            if (null != UpdateCommand)
                UpdateCommand.Dispose();

            if (null != DeleteCommand)
                DeleteCommand.Dispose();

            InsertCommand = null;
            UpdateCommand = null;
            DeleteCommand = null;
        }

        //----------------------------------------------------------------------
        // RemoveExtraParameters()
        //
        static private void RemoveExtraParameters(IDbCommand command, int usedParameterCount) {
            for (int i = command.Parameters.Count-1; i >= usedParameterCount; --i) {
#if DEBUG
                if (AdapterSwitches.DBCommandBuilder.TraceVerbose) {
                    IDataParameter p = (IDataParameter) command.Parameters[i];
                    Debug.WriteLine("removing extra " + p.GetType().Name + " " + p.ParameterName);
                }
#endif
                command.Parameters.RemoveAt(i);
            }
        }

        //----------------------------------------------------------------------
        // RowUpdatingHandler()
        //
		private void base_RowUpdatingHandler(object sender, RowUpdatingEventArgs rowUpdatingEvent) {
            if (null == rowUpdatingEvent) {
                throw ADP.ArgumentNull("rowUpdatingEvent");
            }
            try {
                if (UpdateStatus.Continue == rowUpdatingEvent.Status) {
                    StatementType stmtType = rowUpdatingEvent.StatementType;
                    IDbCommand command = rowUpdatingEvent.Command;

                    if (null != command) {
                        switch(stmtType) {
                        case StatementType.Insert:
                            command = InsertCommand;
                            break;
                        case StatementType.Update:
                            command = UpdateCommand;
                            break;
                        case StatementType.Delete:
                            command = DeleteCommand;
                            break;
                        default:
                            throw ADP.InvalidStatementType(stmtType);
                        }
                        if (command != rowUpdatingEvent.Command) {
                            return; // user command, not a command builder command
                        }
                    }

                    // MDAC 58710 - unable to tell Update method that Event opened connection and Update needs to close when done
                    // HackFix - the Update method will close the connection if command was null and returned command.Connection is same as SelectCommand.Connection
                    BuildCache(false);

                    DataRow datarow = rowUpdatingEvent.Row;
                    switch(stmtType) {
                    case StatementType.Insert:
                        command = BuildInsertCommand(rowUpdatingEvent.TableMapping, datarow);
                        break;
                    case StatementType.Update:
                        command = BuildUpdateCommand(rowUpdatingEvent.TableMapping, datarow);
                        break;
                    case StatementType.Delete:
                        command = BuildDeleteCommand(rowUpdatingEvent.TableMapping, datarow);
                        break;
                    default:
                        throw ADP.InvalidStatementType(stmtType);
                    }
                    if (null == command) {
                        if (null != datarow) {
                            datarow.AcceptChanges();
                        }
                        rowUpdatingEvent.Status = UpdateStatus.SkipCurrentRow;
                    }
                    rowUpdatingEvent.Command = command;
                }
            }
            catch(Exception e) {
                ADP.TraceException(e);

                rowUpdatingEvent.Status = UpdateStatus.ErrorsOccurred;
                rowUpdatingEvent.Errors = e;
            }
        }

#if V2
        ////////////////////////////////////////////////////////////////////////
        //
        // Abstract Methods 
        //
        ////////////////////////////////////////////////////////////////////////

        //----------------------------------------------------------------------
        // ApplyParameterInfo()
        //
        abstract protected void ApplyParameterInfo(IDbDataParameter p, DataRow row);

        //----------------------------------------------------------------------
        // GetParameterName()
        //
        abstract protected string GetParameterName(int parameterOrdinal);

        //----------------------------------------------------------------------
        // GetParameterPlaceholder()
        //
        abstract protected string GetParameterPlaceholder(int parameterOrdinal);
#endif //V2

		//-----------------------------------------------------------------------------------
		// Command to derive parameters for a specific stored procedure
		//
		private const string ResolveNameCommand_Part1 = 
			"begin dbms_utility.name_resolve('";
		
		private const string ResolveNameCommand_Part2 = 
			"',1,:schema,:part1,:part2,:dblink,:part1type,:objectnum); end;";
		

		static private readonly string DeriveParameterCommand_Part1 =
			"select"
				+" overload,"
				+" decode(position,0,'RETURN_VALUE',nvl(argument_name,chr(0))) name,"
				+" decode(in_out,'IN',1,'IN/OUT',3,'OUT',decode(argument_name,null,6,2),1) direction,"		// default to input parameter if unknown.
				+" decode(data_type,"
					+" 'BFILE',"	+ ((int)OracleType.BFile).ToString(CultureInfo.CurrentCulture)		+ ","
					+" 'BLOB',"		+ ((int)OracleType.Blob).ToString(CultureInfo.CurrentCulture)		+ ","
					+" 'CHAR'," 	+ ((int)OracleType.Char).ToString(CultureInfo.CurrentCulture)		+ ","
					+" 'CLOB',"		+ ((int)OracleType.Clob).ToString(CultureInfo.CurrentCulture) 		+ ","
					+" 'DATE',"		+ ((int)OracleType.DateTime).ToString(CultureInfo.CurrentCulture)	+ ","
					+" 'FLOAT',"	+ ((int)OracleType.Number).ToString(CultureInfo.CurrentCulture) 	+ ","
					+" 'INTERVAL YEAR TO MONTH',"+ ((int)OracleType.IntervalYearToMonth).ToString(CultureInfo.CurrentCulture)	+ ","
					+" 'INTERVAL DAY TO SECOND',"+ ((int)OracleType.IntervalDayToSecond).ToString(CultureInfo.CurrentCulture)	+ ","
					+" 'LONG',"		+ ((int)OracleType.LongVarChar).ToString(CultureInfo.CurrentCulture)+ ","
					+" 'LONG RAW',"	+ ((int)OracleType.LongRaw).ToString(CultureInfo.CurrentCulture)	+ ","
					+" 'NCHAR'," 	+ ((int)OracleType.NChar).ToString(CultureInfo.CurrentCulture) 		+ ","
					+" 'NCLOB',"	+ ((int)OracleType.NClob).ToString(CultureInfo.CurrentCulture)		+ ","
					+" 'NUMBER',"	+ ((int)OracleType.Number).ToString(CultureInfo.CurrentCulture)		+ ","
					+" 'NVARCHAR2',"+ ((int)OracleType.NVarChar).ToString(CultureInfo.CurrentCulture)	+ ","
					+" 'RAW',"		+ ((int)OracleType.Raw).ToString(CultureInfo.CurrentCulture)		+ ","
					+" 'REF CURSOR',"+((int)OracleType.Cursor).ToString(CultureInfo.CurrentCulture)		+ ","
					+" 'ROWID',"	+ ((int)OracleType.RowId).ToString(CultureInfo.CurrentCulture)		+ ","
					+" 'TIMESTAMP',"+ ((int)OracleType.Timestamp).ToString(CultureInfo.CurrentCulture)	+ ","
					+" 'TIMESTAMP WITH LOCAL TIME ZONE',"+ ((int)OracleType.TimestampLocal).ToString(CultureInfo.CurrentCulture)+ ","
					+" 'TIMESTAMP WITH TIME ZONE',"+ ((int)OracleType.TimestampWithTZ).ToString(CultureInfo.CurrentCulture)		+ ","
					+" 'VARCHAR2',"	+ ((int)OracleType.VarChar).ToString(CultureInfo.CurrentCulture)	+ ","
					+ ((int)OracleType.VarChar).ToString(CultureInfo.CurrentCulture) + ") oracletype,"		// Default to Varchar if unknown.
				+" decode(data_type,"
					+" 'CHAR'," 	+ 2000		+ ","
					+" 'LONG',"		+ Int32.MaxValue	+ ","
					+" 'LONG RAW',"	+ Int32.MaxValue	+ ","
					+" 'NCHAR'," 	+ 4000 		+ ","
					+" 'NVARCHAR2',"+ 4000		+ ","
					+" 'RAW',"		+ 2000		+ ","
					+" 'VARCHAR2',"	+ 2000		+ ","
					+"0) length,"		
				+" nvl(data_precision, 255) precision,"
				+" nvl(data_scale, 255) scale "
				+"from all_arguments "
				+"where data_level = 0"
				+" and data_type is not null"
				+" and owner = '"
				;
		private const string DeriveParameterCommand_Part2 =
			"' and package_name = '";

		private const string DeriveParameterCommand_Part3 =
			"' and object_name = '";

		private const string DeriveParameterCommand_Part4 =
			"'  order by overload, position";


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Fields
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        private OracleRowUpdatingEventHandler   _rowUpdatingHandler;

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Constructors
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleCommandBuilder.uex' path='docs/doc[@for="OracleCommandBuilder.OracleCommandBuilder1"]/*' />
        public OracleCommandBuilder() : base()
        {
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\OracleCommandBuilder.uex' path='docs/doc[@for="OracleCommandBuilder.OracleCommandBuilder2"]/*' />
        public OracleCommandBuilder(OracleDataAdapter adapter) : this()
        {
            DataAdapter = adapter;
        }
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		//----------------------------------------------------------------------
		// DataAdapter
		//
        /// <include file='doc\OracleCommandBuilder.uex' path='docs/doc[@for="OracleCommandBuilder.DataAdapter"]/*' />
        [
        DefaultValue(null),
        OracleDescription(Res.OracleCommandBuilder_DataAdapter)
        ]
        public OracleDataAdapter DataAdapter 
        {
            get 
            {
                return (OracleDataAdapter)DbDataAdapter;
            }
            set 
            {
            	if (DbDataAdapter != (IDbDataAdapter)value)
            		{
            		Dispose(true);
                
	                DbDataAdapter = (IDbDataAdapter)value;

	                if (null != value)
	                	{
						Debug.Assert(null == _rowUpdatingHandler, "handler not clear");
						_rowUpdatingHandler = new OracleRowUpdatingEventHandler(this.RowUpdatingHandler);
						value.RowUpdating += _rowUpdatingHandler;
	                	}
            		}
			}
        }
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		//----------------------------------------------------------------------
		// ApplyParameterInfo()
		//
        /// <include file='doc\OracleCommandBuilder.uex' path='docs/doc[@for="OracleCommandBuilder.ApplyParameterInfo"]/*' />
        /// <internalonly/>
        private void ApplyParameterInfo(
        		IDbDataParameter	parameter,
        		DataRow 			dataRow
        		) 
        {
			OracleType oracleTypeOfColumn = ((OracleType)dataRow["ProviderType", DataRowVersion.Default]);

			switch (oracleTypeOfColumn)
			{
			case OracleType.LongVarChar:
				oracleTypeOfColumn = OracleType.VarChar;	 // We'll promote this automatically in the binding, and it saves headaches
				break;
			}
			((OracleParameter) parameter).OracleType = oracleTypeOfColumn;
		}

		//----------------------------------------------------------------------
		// DeriveParameters()
		//
        /// <include file='doc\OracleCommandBuilder.uex' path='docs/doc[@for="OracleCommandBuilder.DeriveParameters"]/*' />
        static public void DeriveParameters(OracleCommand command) 
        {
			OracleConnection.OraclePermission.Demand();

            if (null == command)
                throw ADP.ArgumentNull("command");

            switch (command.CommandType) 
            {               
                case System.Data.CommandType.StoredProcedure:
                    break;
                    
                case System.Data.CommandType.Text:
                case System.Data.CommandType.TableDirect:
                    throw ADP.DeriveParametersNotSupported(command);
                    
                default:
                    throw ADP.InvalidCommandType(command.CommandType);
            }
            if (ADP.IsEmpty(command.CommandText))
                throw ADP.CommandTextRequired("DeriveParameters");

            OracleConnection connection = command.Connection;
            if (null == connection)
                throw ADP.ConnectionRequired("DeriveParameters");

            ConnectionState	state = connection.State;
            
            if (ConnectionState.Open != state)
                throw ADP.OpenConnectionRequired("DeriveParameters", state);

            ArrayList list = DeriveParametersFromStoredProcedure(connection, command);

            OracleParameterCollection parameters = command.Parameters;
            parameters.Clear();

            int count = list.Count;
            for(int i = 0; i < count; ++i) 
            {
                parameters.Add((OracleParameter)list[i]);
            }
        }

		//----------------------------------------------------------------------
		// DeriveParametersFromStoredProcedure()
		//
		static private ArrayList DeriveParametersFromStoredProcedure(
			OracleConnection	connection, 
			OracleCommand		command
			)
		{
			ArrayList		parameterList = new ArrayList();
			OracleCommand	tempCommand = connection.CreateCommand();
			string			schema;
			string			part1;
			string			part2;
			string			dblink;

			tempCommand.Transaction = command.Transaction;	// must set the transaction context to be the same as the command, or we'll throw when we execute.

			if (0 != ResolveName(tempCommand, command.CommandText, 
									out schema,
									out part1,
									out part2,
									out dblink))
			{
				StringBuilder builder = new StringBuilder();

				builder.Append(DeriveParameterCommand_Part1);
				builder.Append(schema);

				if (!ADP.IsNull(part1))
				{
					builder.Append(DeriveParameterCommand_Part2);
					builder.Append(part1);
				}
				builder.Append(DeriveParameterCommand_Part3);
				builder.Append(part2);
				builder.Append(DeriveParameterCommand_Part4);

				tempCommand.Parameters.Clear();
				tempCommand.CommandText = builder.ToString();

//				Console.WriteLine(tempCommand.CommandText);

				using(OracleDataReader rdr = tempCommand.ExecuteReader()) 
				{
					while (rdr.Read())
					{
						if (!ADP.IsNull(rdr.GetValue(0)))
							throw ADP.CannotDeriveOverloaded();

						string				parameterName	= rdr.GetString (1);
						ParameterDirection	direction		= (ParameterDirection)(int)rdr.GetDecimal(2);
						OracleType			oracleType		= (OracleType)(int)rdr.GetDecimal(3);
						int					size			= (int)rdr.GetDecimal(4);
						byte				precision		= (byte)rdr.GetDecimal(5);
						byte				scale			= (byte)rdr.GetDecimal(6);
	 					
						OracleParameter parameter = new OracleParameter(
															parameterName,
															oracleType,
															size,
															direction,
															true,	// isNullable
															precision,
															scale,
															"",
															DataRowVersion.Current,
															null);
						
						parameterList.Add(parameter);
					}
				}
			}

			return parameterList;
		}

		//----------------------------------------------------------------------
		// Dispose()
		//
        /// <include file='doc\OracleCommandBuilder.uex' path='docs/doc[@for="OracleCommandBuilder.Dispose"]/*' />
        override protected void Dispose(bool disposing) 
        {
            if (disposing) 
	            {
            	// release mananged objects
            	
				if (null != _rowUpdatingHandler)
					{
					((OracleDataAdapter)DbDataAdapter).RowUpdating -= _rowUpdatingHandler;
					_rowUpdatingHandler = null;
					}
	 			}
            
            //release unmanaged objects

//V2		base.Dispose(disposing);
            base_Dispose(disposing);
        }

		//----------------------------------------------------------------------
		// Get{Insert,Update,Delete}Command()
		//
        /// <include file='doc\OracleCommandBuilder.uex' path='docs/doc[@for="OracleCommandBuilder.GetInsertCommand"]/*' />
/*V2
        new public OracleCommand GetInsertCommand()
		{
            return (OracleCommand)base.GetInsertCommand();
		}
V2*/
        public OracleCommand GetInsertCommand() 
        {
            return (OracleCommand)base_GetInsertCommand();
        }

        /// <include file='doc\OracleCommandBuilder.uex' path='docs/doc[@for="OracleCommandBuilder.GetUpdateCommand"]/*' />
/*V2
        new public OracleCommand GetUpdateCommand()
		{
            return (OracleCommand)base.GetUpdateCommand();
		}
V2*/
        public OracleCommand GetUpdateCommand() 
        {
            return (OracleCommand)base_GetUpdateCommand();
        }

        /// <include file='doc\OracleCommandBuilder.uex' path='docs/doc[@for="OracleCommandBuilder.GetDeleteCommand"]/*' />
/*V2
        new public OracleCommand GetDeleteCommand()
		{
            return (OracleCommand)base.GetDeleteCommand();
		}
V2*/
        public OracleCommand GetDeleteCommand() 
        {
            return (OracleCommand)base_GetDeleteCommand();
        }

		//----------------------------------------------------------------------
		// GetParameterName()
		//
        /// <include file='doc\OracleCommandBuilder.uex' path='docs/doc[@for="OracleCommandBuilder.GetParameterName"]/*' />
        /// <internalonly/>
//V2	override protected string GetParameterName( int parameterOrdinal )
        private string GetParameterName( int parameterOrdinal )
        {
        	return  "p" + parameterOrdinal.ToString(CultureInfo.CurrentCulture);
        }

		//----------------------------------------------------------------------
		// GetParameterPlaceholder()
		//
        /// <include file='doc\OracleCommandBuilder.uex' path='docs/doc[@for="OracleCommandBuilder.GetParameterPlaceholder"]/*' />
        /// <internalonly/>
//V2	override protected string GetParameterPlaceholder( int parameterOrdinal )
        private string GetParameterPlaceholder( int parameterOrdinal )
        {
        	return  ":" + GetParameterName(parameterOrdinal);
        }

        //----------------------------------------------------------------------
        // InitializeCommand()
        //
        /// <include file='doc\OracleCommandBuilder.uex' path='docs/doc[@for="OracleCommandBuilder.InitializeCommand"]/*' />
        /// <internalonly/>
//V2	override protected IDbCommand InitializeCommand(IDbCommand command) 
        private  IDbCommand InitializeCommand(IDbCommand command) 
        {
            if (null == command)
            {
                IDbCommand select = GetSelectCommand();
                command = select.Connection.CreateCommand();
                command.Transaction = select.Transaction; // must set the transaction context to be the same as the command, or we'll throw when we execute.
            }

            command.CommandType 	 = CommandType.Text;
            command.UpdatedRowSource = UpdateRowSource.None; // no select or output parameters expected 
            return command;
        }

		//----------------------------------------------------------------------
		// ResolveName()
		//
		//	Ask the server for the component parts of the name
		//
		static uint ResolveName(
			OracleCommand	command,	// command object to use
			string			nameToResolve,
			out string		schema,		// schema part of name
			out string		part1,		// package part of name
			out string		part2,		// procedure/function part of name
			out string		dblink		// database link part of name
			)
		{
			StringBuilder	builder	 = new StringBuilder();

			builder.Append(ResolveNameCommand_Part1);
			builder.Append(nameToResolve);
			builder.Append(ResolveNameCommand_Part2);

			command.CommandText = builder.ToString();
			command.Parameters.Add(new OracleParameter("schema",	OracleType.VarChar, 30)).Direction = ParameterDirection.Output;
			command.Parameters.Add(new OracleParameter("part1",		OracleType.VarChar, 30)).Direction = ParameterDirection.Output;
			command.Parameters.Add(new OracleParameter("part2",		OracleType.VarChar, 30)).Direction = ParameterDirection.Output;
			command.Parameters.Add(new OracleParameter("dblink",	OracleType.VarChar, 128)).Direction = ParameterDirection.Output;
			command.Parameters.Add(new OracleParameter("part1type", OracleType.UInt32)).Direction = ParameterDirection.Output;
			command.Parameters.Add(new OracleParameter("objectnum", OracleType.UInt32)).Direction = ParameterDirection.Output;

			command.ExecuteNonQuery();

			object oracleObjectNumber = command.Parameters["objectnum"].Value;
			if (ADP.IsNull(oracleObjectNumber))
			{
				schema = string.Empty;
				part1 = string.Empty;
				part2 = string.Empty;
				dblink = string.Empty;
				return 0;
			}
			
			schema	= (ADP.IsNull(command.Parameters["schema"].Value)) ? null : (string)command.Parameters["schema"].Value;
			part1	= (ADP.IsNull(command.Parameters["part1"].Value )) ? null : (string)command.Parameters["part1"].Value;
			part2	= (ADP.IsNull(command.Parameters["part2"].Value )) ? null : (string)command.Parameters["part2"].Value;
			dblink	= (ADP.IsNull(command.Parameters["dblink"].Value)) ? null : (string)command.Parameters["dblink"].Value;
			
			return (uint)command.Parameters["part1type"].Value;
		}

		//----------------------------------------------------------------------
		// RowUpdatingHandler()
		//
        private void RowUpdatingHandler(object sender, OracleRowUpdatingEventArgs ruevent) 
        {
//V2		base.RowUpdatingHandler(sender, ruevent);
         	base_RowUpdatingHandler(sender, ruevent);
		}

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracleinfomessageeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="OracleInfoMessageEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OracleClient 
{

    /// <include file='doc\OracleInfoMessageEventHandler.uex' path='docs/doc[@for="OracleInfoMessageEventHandler"]/*' />
    public delegate void OracleInfoMessageEventHandler(object sender, OracleInfoMessageEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oraclelob.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleLob.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Data.SqlTypes;
	using System.Diagnostics;
	using System.Globalization;
	using System.IO;
	using System.Runtime.InteropServices;
	using System.Text;
	using System.Threading;


	//----------------------------------------------------------------------
	// OracleLob
	//
	//	This class implements support for Oracle's BLOB, CLOB, and NCLOB 
	//	internal data types.  This is primarily a stream object, to allow
	//	it to be used by the StreamReader/StreamWriter and BinaryReader/
	//	BinaryWriter objects.
	//
    /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob"]/*' />
	sealed public class OracleLob : Stream, ICloneable, IDisposable, INullable
	{
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Fields
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		private bool				_isNull;				// true when the object is a Null lob.
		private OciLobLocator		_lobLocator;
        private OracleType			_lobType;				// the underlying data type of the LOB locator, cached, because after close/dispose we still need the information
		private OCI.CHARSETFORM		_charsetForm;			// the character set form (char/varchar/clob vs nchar/nvarchar/nclob)
        private long				_currentPosition;		// the current read/write position, in BYTES (NOTE: Oracle is 1 based, but this is zero based)
#if EXPOSELOBBUFFERING
        private bool				_isCurrentlyBuffered;	// lob buffering is currently enabled.
        private bool				_bufferedRequested;		// lob buffering has been requested.
        private bool				_bufferIsDirty;			// true when a buffered write has occured
#endif //EXPOSELOBBUFFERING

        private byte				_isTemporaryState;		// see x_IsTemporary.... constants below.
        private const byte x_IsTemporaryUnknown	= 0;			// don't know the temporary status
        private const byte x_IsTemporary  		= 1;			// know the temporary status, and it's temporary
        private const byte x_IsNotTemporary		= 2;			// know the temporary status, and it's not temporary


        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.Null"]/*' />
        static public new readonly OracleLob Null = new OracleLob();

		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Constructors
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		// (internal) Construct a null lob
		internal OracleLob()
		{
			_isNull = true;
			_lobType = OracleType.Blob;		// pick something...
		}
		

		// (internal) Construct from a buffer
 		internal OracleLob(OciLobLocator lobLocator)
		{
 			_lobLocator				= lobLocator.Clone();
 			_lobType				= _lobLocator.LobType;
 			_charsetForm			= (OracleType.NClob == _lobType) ? OCI.CHARSETFORM.SQLCS_NCHAR : OCI.CHARSETFORM.SQLCS_IMPLICIT;
#if EXPOSELOBBUFFERING
 			_bufferedRequested		= false;
#endif //EXPOSELOBBUFFERING

		}

		// (internal) Construct from an existing Lob object (copy constructor)
		internal OracleLob(OracleLob lob)
		{
			this._lobLocator			= lob._lobLocator.Clone();
 			this._lobType				= lob._lobLocator.LobType;
			this._charsetForm			= lob._charsetForm;
	        this._currentPosition		= lob._currentPosition;
#if EXPOSELOBBUFFERING
	        this._isCurrentlyBuffered	= lob._isCurrentlyBuffered;
	        this._bufferedRequested		= lob._bufferedRequested;
#endif //EXPOSELOBBUFFERING
	        this._isTemporaryState		= lob._isTemporaryState;
		}

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

#if EXPOSELOBBUFFERING
        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.Buffered"]/*' />
		/// <internalonly/>
		internal bool Buffered
		{
			get 
			{
				if (IsNull)
					return false;

				return _bufferedRequested;
			}
			set 
			{
				AssertObjectNotDisposed();

				if (!IsNull) 
				{
					AssertConnectionIsOpen();			
					_bufferedRequested = value; 
				}
			}
		}
#endif //EXPOSELOBBUFFERING

        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.CanRead"]/*' />
		public override bool CanRead
		{
			get 
			{
				if (IsNull)
					return true;

				return !IsDisposed;
			}
		}

        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.CanSeek"]/*' />
		public override bool CanSeek
		{
			get 
			{
				if (IsNull)
					return true;

				return !IsDisposed;
			}
		}

        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.CanWrite"]/*' />
		public override bool CanWrite
		{
			get 
			{
				bool value = (OracleType.BFile != _lobType);

				if (!IsNull)
					value = !IsDisposed;
				
				return value; 
			}
		}

        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.ChunkSize"]/*' />
		public int ChunkSize
		{
			get 
			{
				AssertObjectNotDisposed();			
				
				if (IsNull)
					return 0;
				
				AssertConnectionIsOpen();			
				UInt32 chunkSize = 0;
				
				int rc = TracedNativeMethods.OCILobGetChunkSize(
											ServiceContextHandle,
											ErrorHandle,
											Descriptor,
											out chunkSize
											);
				if (0 != rc)
					Connection.CheckError(ErrorHandle, rc);

				return (int)chunkSize;
			}
		}

        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.Connection"]/*' />
		public OracleConnection Connection 
		{
			get 
			{ 
				AssertObjectNotDisposed();	
				OciLobLocator lobLocator = LobLocator;

				if (null == lobLocator)
					return null;
				
				return lobLocator.Connection; 
			}
		}

		private bool ConnectionIsClosed 
		{
			//	returns TRUE when the parent connection object has been closed
			get { return (null == LobLocator) || LobLocator.ConnectionIsClosed; }
		}
		
		private UInt32 CurrentOraclePosition
		{
			//	Oracle's LOBs can be between 0 and 4GB-1 in size, but the frameworks
			//	Stream class presumes a Int64.  We use we have to pass the offset
			//	to several OCI calls as an UInt32 because that's what Oracle 
			//	expects. 
			//
			//	We solve this dilemma by verifying that the currentPosition is in
			//	the valid range before we use it.
			get 
			{
				Debug.Assert (_currentPosition <= (long)UInt32.MaxValue, "Position is beyond the maximum LOB length");
				return (UInt32)AdjustOffsetToOracle(_currentPosition) + 1;
			}
 		}
		
		internal OciHandle Descriptor
		{
			get { return LobLocator.Descriptor; }
		}

		internal OciHandle ErrorHandle 
		{
			//	Every OCI call needs an error handle, so make it available 
			//	internally.
			get { return LobLocator.ErrorHandle; }
		}

        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.IsBatched"]/*' />
		public bool IsBatched
		{
			get 
			{
				if (IsNull || IsDisposed || ConnectionIsClosed)
					return false;
				
				int flag;
				int rc = TracedNativeMethods.OCILobIsOpen(
											ServiceContextHandle,
											ErrorHandle,
											Descriptor,
											out flag
											);
				if (0 != rc)
					Connection.CheckError(ErrorHandle, rc);
				
				return (flag != 0);
			}
		}

		private bool IsCharacterLob 
		{
			get { return (OracleType.Clob == _lobType || OracleType.NClob == _lobType); }
		}

		private bool IsDisposed 
		{
			get { return _isNull ? false : (null == LobLocator);}
		}

        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.IsNull"]/*' />
		public bool IsNull 
		{
			get { return _isNull; }	
		}

        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.IsTemporary"]/*' />
		public bool IsTemporary
		{
			get 
			{
				AssertObjectNotDisposed();
				
				if (IsNull)
					return false;
				
				AssertConnectionIsOpen();			

				// Don't bother asking if we already know.
				if (x_IsTemporaryUnknown == _isTemporaryState)
				{

					int flag;
					int rc = TracedNativeMethods.OCILobIsTemporary(
												Connection.EnvironmentHandle,
												ErrorHandle,
												Descriptor,
												out flag
												);
					if (0 != rc)
						Connection.CheckError(ErrorHandle, rc);

					_isTemporaryState = (flag != 0) ? x_IsTemporary : x_IsNotTemporary;	
				}

				return (x_IsTemporary == _isTemporaryState);
			}
		}

		internal OciLobLocator LobLocator
		{
			get { return _lobLocator; }
		}

        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.LobType"]/*' />
		public OracleType LobType
		{
			get { return _lobType; }
		}
	
        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.Length"]/*' />
		public override long Length
		{
			get {
				AssertObjectNotDisposed();
				
				if (IsNull)
					return 0;
				
				AssertConnectionIsOpen();			

				EnsureBuffering(false);
				
				UInt32 len;
				int rc = TracedNativeMethods.OCILobGetLength(
											ServiceContextHandle,
											ErrorHandle,
											Descriptor,
											out len
											);

				if (0 != rc)
					Connection.CheckError(ErrorHandle, rc);

				return AdjustOracleToOffset(len);
			}
		}

        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.Position"]/*' />
		public override long Position
		{
			get
			{
				AssertObjectNotDisposed();
				
				if (IsNull)
					return 0;
				
				AssertConnectionIsOpen();
				
				return _currentPosition; 
			}
			set 
			{ 
				if (!IsNull)
					Seek(value, SeekOrigin.Begin); 
			}
		}

		internal OciHandle ServiceContextHandle
		{
			//	You need to provide the service context handle to things like the
			//	OCI execute call so a statement handle can be associated with a
			//	connection.  Better make it available internally, then.

			get { return LobLocator.ServiceContextHandle; }
		}

        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.Value"]/*' />
        public object Value
        {
			//	We need to return a CLS object from the Data Reader and exec
			//	scalar; that means we have to get the contents of the lob, not
			//	a stream.  It's a real bummer.
            get {
				AssertObjectNotDisposed();
				
				if (IsNull)
					return DBNull.Value;

    			long	savedPosition = _currentPosition;
				int		length = (int)this.Length;
				bool	isBinary = (OracleType.Blob == _lobType || OracleType.BFile == _lobType);
				string	result;

				// If the LOB is empty, return the appropriate empty object;
				if (0 == length)
				{
					if (isBinary)
						return new byte[0];

					return String.Empty;
				}

				try 
				{
					try 
					{
						// It's not empty, so we have to read the whole thing. Bummer.
						Seek(0,SeekOrigin.Begin);

						if (isBinary)
						{
				 			byte[]	blobResult = new byte[length];
				 			Read(blobResult, 0, length);
				   			return blobResult;
						}

						StreamReader 	sr;

						try
						{
							sr		= new StreamReader((Stream)this, System.Text.Encoding.Unicode);
							result	= sr.ReadToEnd();
						}
						finally
						{
							sr = null;
						}
					}
					finally
					{
						// Make sure we reset the position back to the start.
						_currentPosition = savedPosition;
					}
				}
	            catch // Prevent exception filters from running in our space
				{
					throw;
				}
				return result;
            }           
        }


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		internal int AdjustOffsetToOracle( int amount )
		{
			int result = IsCharacterLob ? amount / 2 : amount;
			return result;
 		}

		internal long AdjustOffsetToOracle( long amount )
		{
			long result = IsCharacterLob ? amount / 2 : amount;
			return result;
 		}

		internal int AdjustOracleToOffset( int amount )
		{
			int result = IsCharacterLob ? amount * 2 : amount;
			return result;
 		}

		internal long AdjustOracleToOffset( long amount )
		{
			long result = IsCharacterLob ? amount * 2 : amount;
			return result;
 		}

		internal void AssertAmountIsEven(
						long 	amount,
						string	argName
						)
		{
			if (IsCharacterLob && 1 == (amount & 0x1))
				throw ADP.LobAmountMustBeEven(argName);
		}
		
		internal void AssertAmountIsValidOddOK(
						long 	amount,
						string	argName
						)
		{
			if (amount < 0 || amount >= (long)UInt32.MaxValue)
				throw ADP.LobAmountExceeded(argName);
		}
		
		internal void AssertAmountIsValid(
						long 	amount,
						string	argName
						)
		{
			AssertAmountIsValidOddOK(amount, argName);
			AssertAmountIsEven(amount, argName);
		}
		
		internal void AssertConnectionIsOpen()
		{
			if (ConnectionIsClosed)
				throw ADP.ClosedConnectionError();
		}
		
		internal void AssertObjectNotDisposed()
		{
			if (IsDisposed)
				throw ADP.ObjectDisposed("OracleLob");
		}
		
		internal void AssertPositionIsValid()
		{
			if (IsCharacterLob && 1 == (_currentPosition & 0x1))
				throw ADP.LobPositionMustBeEven();
		}
		
		internal void AssertTransactionExists()
		{
			if (!Connection.HasTransaction)
				throw ADP.LobWriteRequiresTransaction();
		}

        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.Append"]/*' />
		public void Append (OracleLob source)
		{
			if (null == source)
				throw ADP.ArgumentNull("source");

			AssertObjectNotDisposed();			
			source.AssertObjectNotDisposed();

			if (IsNull)
				throw ADP.LobWriteInvalidOnNull();

			if (!source.IsNull)
			{
				AssertConnectionIsOpen();			

				EnsureBuffering(false);
				
				int rc = TracedNativeMethods.OCILobAppend(
											ServiceContextHandle,
											ErrorHandle,
											Descriptor,
											source.Descriptor
											);
				if (0 != rc)
					Connection.CheckError(ErrorHandle, rc);
			}
		}
		
        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.BeginBatch1"]/*' />
		public void BeginBatch ()
		{
			BeginBatch(OracleLobOpenMode.ReadOnly);
		}

        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.BeginBatch2"]/*' />
		public void BeginBatch (OracleLobOpenMode mode)
		{
			AssertObjectNotDisposed();			

			if (!IsNull)
			{
				AssertConnectionIsOpen();			
				LobLocator.Open(mode);
			}
		}

        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.Clone"]/*' />
		public object Clone() 
		{
			AssertObjectNotDisposed();

			if (IsNull)
				return Null;
			
			AssertConnectionIsOpen();
            OracleLob clone = new OracleLob(this);
            return clone;
		}
		
        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.Close"]/*' />
		public override void Close ()
		{
			if (!IsNull && !ConnectionIsClosed)
			{
				Flush();
#if EXPOSELOBBUFFERING
	 			_bufferedRequested = false;
#endif //EXPOSELOBBUFFERING
	 			OciLobLocator.SafeDispose(ref _lobLocator);
			}
		}

        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.CopyTo1"]/*' />
		public long CopyTo (OracleLob destination)
		{
			// Copies the entire lob to a compatible lob, starting at the beginning of the target array.
			return CopyTo (0, destination, 0, Length);
		}
		
        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.CopyTo2"]/*' />
		public long CopyTo (
						OracleLob destination, 
						long destinationOffset
						)
		{
			// Copies the entire lob to a compatible lob, starting at the specified offset of the target array.
			return CopyTo (0, destination, destinationOffset, Length);
		}
		
		
        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.CopyTo3"]/*' />
		public long CopyTo (
						long sourceOffset,
						OracleLob destination, 
						long destinationOffset,
						long amount
						)
		{
			// Copies a range of elements from the lob to a compatible lob, starting at the specified index of the target array.
			
			if (null == destination)
				throw ADP.ArgumentNull("destination");

			AssertObjectNotDisposed();			
			destination.AssertObjectNotDisposed();			
			
			AssertAmountIsValid(amount,				"amount");
			AssertAmountIsValid(sourceOffset,		"sourceOffset");
			AssertAmountIsValid(destinationOffset,	"destinationOffset");

			if (destination.IsNull)
				throw ADP.LobWriteInvalidOnNull();

			if (IsNull)
				return 0;
			
			AssertConnectionIsOpen();			
			AssertTransactionExists();

 			int rc;

			EnsureBuffering(false);
			destination.EnsureBuffering(false);

			long dataCount = AdjustOffsetToOracle(Math.Min(Length - sourceOffset, amount));
			long dstOffset = AdjustOffsetToOracle(destinationOffset) + 1;	// Oracle is 1 based, we are zero based.
			long srcOffset = AdjustOffsetToOracle(sourceOffset) + 1;		// Oracle is 1 based, we are zero based.

			if (0 >= dataCount)
				return 0;

			rc = TracedNativeMethods.OCILobCopy(
									ServiceContextHandle,
									ErrorHandle,
									destination.Descriptor,
									Descriptor,
									(UInt32)dataCount,
									(UInt32)dstOffset,	
									(UInt32)srcOffset
									);

			if (0 != rc)
				Connection.CheckError(ErrorHandle, rc);

			// DEVNOTE: Oracle must not do partial copies, because their API doesn't tell you how many bytes were copied.
			long byteCount = AdjustOracleToOffset(dataCount);
			return byteCount;	
		}
		
        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.Dispose1"]/*' />
		public void Dispose() 
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		private void Dispose(bool disposing) 
		{
			// If we're disposing, it's because we went out of scope, and we're
			// being garbage collected.  We shouldn't touch any managed objects
			// or bad things can happen.
			if (disposing)
			{
				Close();
			}

			_lobLocator = null;
 		}

        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.EndBatch"]/*' />
		public void EndBatch ()
		{
			AssertObjectNotDisposed();

			if (!IsNull)
			{
				AssertConnectionIsOpen();
				LobLocator.ForceClose();
			}
		}

		internal void EnsureBuffering (bool buffering)
		{
#if EXPOSELOBBUFFERING
			// Buffering not supported on BFiles yet.
			if (OracleType.BFile == _lobType)
				return;
			
			// DEVNOTE: see MDAC #77834 - We cannot call several OCI calls when buffering is
			//			enabled, but we can turn it off and on as needed...
			if (buffering != _isCurrentlyBuffered)
			{
				int rc;

				if (_isCurrentlyBuffered)
				{
					Flush();
					
					rc = TracedNativeMethods.OCILobDisableBuffering( ServiceContextHandle, ErrorHandle, Descriptor );
					
					if (0 != rc)
						Connection.CheckError(ErrorHandle, rc);

					_isCurrentlyBuffered = false;
				}
				else if (OCI.CHARSETFORM.SQLCS_NCHAR != _charsetForm)
				{
					// TODO: need to get Oracle to give us a fix for the crash in OCILobRead when reading with csfrm=SQLCS_NCHAR
					
					rc = TracedNativeMethods.OCILobEnableBuffering( ServiceContextHandle, ErrorHandle, Descriptor );
					
					if (0 != rc)
						Connection.CheckError(ErrorHandle, rc);

					_isCurrentlyBuffered = true;
				}
			}
#endif //EXPOSELOBBUFFERING
		}

        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.Erase1"]/*' />
		public long Erase ()
		{
 			// Erase (zero or space fill) the entire LOB
			return Erase (0, Length);
		}
		
        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.Erase2"]/*' />
		public long Erase (
						long offset,
						long amount 
						)
		{
			AssertObjectNotDisposed();

			if (IsNull)
				throw ADP.LobWriteInvalidOnNull();
			
			AssertAmountIsValid(amount, "amount");
			AssertAmountIsEven(offset, "offset");
			
			AssertPositionIsValid();

			AssertConnectionIsOpen();			
			AssertTransactionExists();

			if (offset < 0 || offset >= (long)UInt32.MaxValue)		// MDAC 82575
				return 0;

			
			UInt32 eraseAmount = (UInt32)AdjustOffsetToOracle(amount);	
			UInt32 eraseOffset = (UInt32)AdjustOffsetToOracle(offset) + 1;		// Oracle is 1 based, we are zero based.			

			EnsureBuffering(false);
		
			// Erase (zero or space fill) bytes from the specified offset
			int rc = TracedNativeMethods.OCILobErase(
										ServiceContextHandle,
										ErrorHandle,
										Descriptor,
										ref eraseAmount,
										eraseOffset
										);
			if (0 != rc)
				Connection.CheckError(ErrorHandle, rc);

			long bytesErased = AdjustOracleToOffset(eraseAmount);
			return bytesErased;
		}
		
        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.Flush"]/*' />
		public override void Flush ()
		{
#if EXPOSELOBBUFFERING
			if (!IsNull && !IsDisposed)
			{

				if (_bufferIsDirty)
				{
					int rc = TracedNativeMethods.OCILobFlushBuffer(
												ServiceContextHandle,
												ErrorHandle,
												Descriptor,
												(int)OCI.LOB_BUFFER.OCI_LOB_BUFFER_NOFREE // TODO: Consider exposing this through the API
												);
					if (0 != rc)
						Connection.CheckError(ErrorHandle, rc);

					_bufferIsDirty = false;
				}
			}
#endif //EXPOSELOBBUFFERING
		}
		
	    /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.Read"]/*' />
		public override int Read (
						byte[] buffer, 
						int offset, 
						int count
						)
		{
			AssertObjectNotDisposed();

			if (count < 0)
				throw ADP.MustBePositive("count");

			if (offset < 0)
				throw ADP.MustBePositive("offset");

			if (null == buffer)
				throw ADP.ArgumentNull("buffer");

			if ((long)buffer.Length < ((long)offset + (long)count))
				throw ADP.BufferExceeded();

			if (IsNull || 0 == count)
				return 0;

			AssertConnectionIsOpen();
			AssertAmountIsValidOddOK(offset, "offset");
			AssertAmountIsValidOddOK(count,  "count");

			int		amount;
			uint	readPosition = (uint)_currentPosition;

			// Bless their hearts: Oracle won't let us use odd addresses to read
			// character data, nor will they let us read a single byte from a 
			// character lob. Instead, we allocate our own buffer and copy the 
			// value to the caller's buffer.
			int		oddPosition = 0;
			int		oddOffset = 0;
			int		oddCount = 0;
			byte[]	readBuffer = buffer;
			int		readOffset = offset;
			int		readCount = count;
			
			if (IsCharacterLob)
			{
				oddPosition = (int)(readPosition & 0x1);
				oddOffset	= offset & 0x1;
				oddCount  	= count  & 0x1;

				readPosition /= 2;
				
				if (1 == oddOffset || 1 == oddPosition || 1 == oddCount)
				{
					readOffset = 0;
					readCount  = count + oddCount + (2 * oddPosition);
					readBuffer = new byte[readCount];
				}
			}
			
			short		charsetId = IsCharacterLob ? OCI.OCI_UCS2ID : (short)0;
			int			rc = 0;

			amount	= AdjustOffsetToOracle(readCount);

#if EXPOSELOBBUFFERING
			EnsureBuffering(_bufferedRequested);
#endif //EXPOSELOBBUFFERING

			// We need to pin the buffer and get the address of the offset that
			// the user requested; Oracle doesn't allow us to specify an offset
			// into the buffer.
			GCHandle	handle = new GCHandle();

			try
			{
				try
				{
					handle = GCHandle.Alloc(readBuffer, GCHandleType.Pinned);
					
		            IntPtr		bufferPtr	= new IntPtr((long)handle.AddrOfPinnedObject() + readOffset);

					rc = TracedNativeMethods.OCILobRead(
												ServiceContextHandle,
												ErrorHandle,
												Descriptor,
												ref	amount,
												readPosition + 1,
												bufferPtr,
												readCount,
												ADP.NullHandleRef,
												ADP.NullHandleRef,
												charsetId,
												_charsetForm
												);
				}
				finally
				{
					if (handle.IsAllocated)
						handle.Free();	// Unpin the buffer
				}
			}
            catch // Prevent exception filters from running in our space
			{
				throw;
			}
			
			if ((int)OCI.RETURNCODE.OCI_NEED_DATA == rc)
				rc = 0;
			
			if ((int)OCI.RETURNCODE.OCI_NO_DATA == rc)
				return 0;

			if (0 != rc)
				Connection.CheckError(ErrorHandle, rc);

			amount = AdjustOracleToOffset(amount);
			
			if (readBuffer as object != buffer as object)
			{
				if (amount >= count)
					amount = count;
				else
					amount -= oddPosition;

				Buffer.BlockCopy(readBuffer, oddPosition, buffer, offset, amount);
				readBuffer = null;
			}		
			_currentPosition += amount;
			return amount;
		}
		
        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.Seek"]/*' />
		public override long Seek (
						long offset, 
						SeekOrigin origin
						)
		{
			AssertObjectNotDisposed();

			if (IsNull)
				return 0;
			
			long newPosition = offset;	// SeekOrigin.Begin is default case
			long length = Length;
			
			switch (origin)
			{
			case SeekOrigin.Begin:
				newPosition = offset;
				break;

			case SeekOrigin.End:
				newPosition = length + offset;
				break;
				
			case SeekOrigin.Current:
				newPosition = _currentPosition + offset;
				break;

			default:
				throw ADP.InvalidSeekOrigin(origin);
			}
			
			if (newPosition < 0 || newPosition > length)
				throw ADP.SeekBeyondEnd();

			_currentPosition = newPosition;
				
			return _currentPosition;
		}
		
        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.SetLength"]/*' />
		public override void SetLength (long value)
		{
			AssertObjectNotDisposed();

			if (IsNull)
				throw ADP.LobWriteInvalidOnNull();
			
			AssertConnectionIsOpen();			
			AssertAmountIsValid(value,	"value");
			
			AssertTransactionExists();

			EnsureBuffering(false);

			UInt32 newlength = (UInt32)AdjustOffsetToOracle(value);
			
			int rc = TracedNativeMethods.OCILobTrim(
										ServiceContextHandle,
										ErrorHandle,
										Descriptor,
										newlength
										);
			if (0 != rc)
				Connection.CheckError(ErrorHandle, rc);

			// Adjust the current position to be within the length of the lob, if 
			// we just truncated it before the current position.
			_currentPosition = Math.Min(_currentPosition, value);
        }

        /// <include file='doc\OracleLob.uex' path='docs/doc[@for="OracleLob.Write"]/*' />
		public override void Write (
						byte[] buffer, 
						int offset, 
						int count
						)
		{
			AssertObjectNotDisposed();
			AssertConnectionIsOpen();

			if (count < 0)
				throw ADP.MustBePositive("count");

			if (offset < 0)
				throw ADP.MustBePositive("offset");

			if (null == buffer)
				throw ADP.ArgumentNull("buffer");

			if ((long)buffer.Length < ((long)offset + (long)count))
				throw ADP.BufferExceeded();

			AssertTransactionExists();

			if (IsNull)
				throw ADP.LobWriteInvalidOnNull();

			AssertAmountIsValid(offset, "offset");
			AssertAmountIsValid(count,  "count");
			AssertPositionIsValid();
			
			OCI.CHARSETFORM	charsetForm = _charsetForm;

			short			charsetId = IsCharacterLob ? OCI.OCI_UCS2ID : (short)0;
			int				amount	= AdjustOffsetToOracle(count);
			int				rc = 0;

			if (0 == amount)
				return;

#if EXPOSELOBBUFFERING
			EnsureBuffering(_bufferedRequested);
#endif //EXPOSELOBBUFFERING

			// We need to pin the buffer and get the address of the offset that
			// the user requested; Oracle doesn't allow us to specify an offset
			// into the buffer.
			GCHandle	handle = new GCHandle();

			try
			{
				try
				{
					handle = GCHandle.Alloc(buffer, GCHandleType.Pinned);
		            IntPtr bufferPtr = new IntPtr((long)handle.AddrOfPinnedObject() + offset);

					rc = TracedNativeMethods.OCILobWrite(
												ServiceContextHandle,
												ErrorHandle,
												Descriptor,
												ref	amount,
												CurrentOraclePosition,
												bufferPtr,
												count,
												(byte)OCI.PIECE.OCI_ONE_PIECE,
												ADP.NullHandleRef,
												ADP.NullHandleRef,
												charsetId,
												charsetForm
												);
				}
				finally
				{
#if EXPOSELOBBUFFERING
					if (_isCurrentlyBuffered)
						_bufferIsDirty = true;
#endif //EXPOSELOBBUFFERING

					if (handle.IsAllocated)
						handle.Free();	// Unpin the buffer
				}
			}
            catch // Prevent exception filters from running in our space
			{
				throw;
			}
			
			if (0 != rc)
				Connection.CheckError(ErrorHandle, rc);

			amount = AdjustOracleToOffset(amount);
			_currentPosition += amount;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracleinfomessageeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="OracleInfoMessageEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OracleClient 
{
    using System;

    /// <include file='doc\OracleInfoMessageEventArgs.uex' path='docs/doc[@for="OracleInfoMessageEventArgs"]/*' />
    sealed public class OracleInfoMessageEventArgs : System.EventArgs 
    {
        private OracleException exception;

        internal OracleInfoMessageEventArgs(OracleException exception) {
            this.exception = exception;
        }

        /// <include file='doc\OracleInfoMessageEventArgs.uex' path='docs/doc[@for="OracleInfoMessageEventArgs.Code"]/*' />
        public int Code 
        {
            get { return exception.Code; }
        }

        /// <include file='doc\OracleInfoMessageEventArgs.uex' path='docs/doc[@for="OracleInfoMessageEventArgs.Message"]/*' />
        public string Message 
        {
            get { return exception.Message; }
        }

        /// <include file='doc\OracleInfoMessageEventArgs.uex' path='docs/doc[@for="OracleInfoMessageEventArgs.Source"]/*' />
        public string Source 
        {
            get { return exception.Source;}
        }

        /// <include file='doc\OracleInfoMessageEventArgs.uex' path='docs/doc[@for="OracleInfoMessageEventArgs.ToString"]/*' />
        override public string ToString() 
        {
            return Message;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oraclelobopenmode.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleLobOpenMode.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;

	//----------------------------------------------------------------------
	// OracleLobOpenMode
	//
	//	This is an enumeration of the open modes that you can provide
	//	when opening a LOB.
	//
	
    /// <include file='doc\OracleLobOpenMode.uex' path='docs/doc[@for="OracleLobOpenMode"]/*' />
	public enum OracleLobOpenMode 
	{
        /// <include file='doc\OracleLobOpenMode.uex' path='docs/doc[@for="OracleLobOpenMode.ReadOnly"]/*' />
		ReadOnly	= 1,

        /// <include file='doc\OracleLobOpenMode.uex' path='docs/doc[@for="OracleLobOpenMode.ReadWrite"]/*' />
		ReadWrite	= 2,
	};
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracleexception.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleException.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Data;
	using System.Diagnostics;
	using System.IO;
	using System.Runtime.InteropServices;
    using System.Runtime.Serialization;

	//----------------------------------------------------------------------
	// OracleException
	//
	//	You end up with one of these when an OCI call fails unexpectedly.
	//
    /// <include file='doc\OracleException.uex' path='docs/doc[@for="OracleException"]/*' />
    [Serializable]
	sealed public class OracleException : SystemException 
	{
		private string	message;
		private int		code;

        /// <include file='doc\OracleException.uex' path='docs/doc[@for="OracleException.Message"]/*' />
		override public string Message
		{
			get { return message; }
		}

        /// <include file='doc\OracleException.uex' path='docs/doc[@for="OracleException.Code"]/*' />
		public int Code
		{
			get { return code; }
		}

        // runtime will call even if private...
        private OracleException(SerializationInfo si, StreamingContext sc) : base(si, sc) 
        {
            message     = (string) si.GetValue("message", typeof(string));
            code     	= (int) si.GetValue("source", typeof(int));
        }
		
		internal OracleException(
				OciHandle errorHandle, 
				int rc, 
				NativeBuffer buf)
		{
			if (null == buf)
				buf = new NativeBuffer_Exception(1000);
			else if (buf.Length < 1000)
				buf.Length = 1000;


			if (null != errorHandle)
			{
				int	record = 1;
				int rcTemp = TracedNativeMethods.OCIErrorGet(
											errorHandle, 
											record, 
											ADP.NullHandleRef, 
											out code, 
											buf.Ptr, 
											buf.Length
											);

				if (0 == rcTemp)
				{
					message = errorHandle.PtrToString((IntPtr)buf.Ptr);

					// For warning messages, revert back to the OCI7 routine to get
					// the text of the message.
					if (code != 0 && message.StartsWith("ORA-00000"))
						message = TracedNativeMethods.oermsg(errorHandle, (short)code, buf);
				}
				else
				{
					Debug.Assert(false, "Failed to get oracle message text");
					
					// If we couldn't successfully read the message text, we pick 
					// something more descriptive, like "we couldn't read the message"
					// instead of just handing back an empty string...
					message = Res.GetString(Res.ADP_NoMessageAvailable, rc, rcTemp);
					code = 0;
				}
			}
#if USEORAMTS
			else
			{
				int length = buf.Length;
				code = 0;

				int rcTemp = TracedNativeMethods.OraMTSOCIErrGet(ref code, buf.Ptr, ref length);

				if (1 == rcTemp)
				{
					message = Marshal.PtrToStringAnsi((IntPtr)buf.Ptr);
				}
 				else
				{
					Debug.Assert(false, "Failed to get oracle message text");
					
					// If we couldn't successfully read the message text, we pick 
					// something more descriptive, like "we couldn't read the message"
					// instead of just handing back an empty string...
					message = Res.GetString(Res.ADP_NoMessageAvailable, rc, rcTemp);
					code = 0;
				}
			}
#endif //USEORAMTS
		}

        static internal void Check(OciHandle errorHandle, int rc)
        { 
			if (-1 == rc)
	        	throw ADP.OracleError(errorHandle, rc, null); 

			if (-2 == rc)	 // invalid handle; really broken!!!
				throw ADP.InvalidOperation(Res.GetString(Res.ADP_InternalError, rc));

			Debug.Assert(0 == rc, "Unexpected return code: " + rc);
 		}

#if USEORAMTS
        static internal void Check(int rc)
        { 
			if (0 != rc)
	        	throw ADP.OracleError(null, rc, null); 
 		}
#endif //USEORAMTS
 	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oraclemonthspan.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleMonthSpan.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Data.SqlTypes;
	using System.Diagnostics;
	using System.Globalization;
	using System.Runtime.InteropServices;

	//----------------------------------------------------------------------
	// OracleMonthSpan
	//
	//	This class implements support the Oracle 9i 'INTERVAL YEAR TO MONTH'
	//	internal data type.
	//
    /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan"]/*' />
    [StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct OracleMonthSpan : IComparable, INullable
	{

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Fields
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		private int _value;


        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.MaxValue"]/*' />
        public static readonly OracleMonthSpan MaxValue = new OracleMonthSpan(176556);	// 4172 BC - 9999 AD * 12 months/year

        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.MinValue"]/*' />
        public static readonly OracleMonthSpan MinValue = new OracleMonthSpan(-176556);	// 4172 BC - 9999 AD * 12 months/year
    
        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.Null"]/*' />
        public static readonly OracleMonthSpan Null = new OracleMonthSpan(true);
		
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Constructors
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		// Construct from nothing -- the value will be null
		internal OracleMonthSpan(bool isNull)
		{	
			_value = -1;
		}

		// Construct from an integer number of months
        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.OracleMonthSpan1"]/*' />
		public OracleMonthSpan (int months) 
		{
			_value = months;
			AssertValid(_value);
		}

		/// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.OracleMonthSpan3"]/*' />
		public OracleMonthSpan (Int32 years, Int32 months)  
	 	{ 
			_value = (years * 12) + months;
			AssertValid(_value);
		}

		// Copy constructor
        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.OracleMonthSpan9"]/*' />
		public OracleMonthSpan (OracleMonthSpan from)  
		{
			_value = from._value;
		}

        // (internal) construct from a row/parameter binding
 		internal OracleMonthSpan(
					NativeBuffer 		buffer, 
					int					valueOffset)
		{
			_value = MarshalToInt32(buffer, valueOffset);
		}


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.IsNull"]/*' />
		public bool IsNull 
		{
			get { return (-1 == _value); }
		}

        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.Value"]/*' />
        public int Value
        {
            get
            {
            	if (IsNull)
	    			throw ADP.DataIsNull();
	        	
                return _value;
            }           
        }

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		static private void AssertValid(
		  	int monthSpan
			)
		{
			if (monthSpan < MinValue._value || monthSpan > MaxValue._value)
				throw ADP.Argument("Year or Month are out of range");
			
		}

        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.CompareTo"]/*' />
		public int CompareTo(
		  	object obj
			)
		{
			if (obj.GetType() == typeof(OracleMonthSpan))
			{
	            OracleMonthSpan odt = (OracleMonthSpan)obj;

	            // If both values are Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return odt.IsNull ? 0  : -1;

                if (odt.IsNull)
                    return 1;

				// Neither value is null, do the comparison.
	                
				int	result = _value.CompareTo(odt._value);
				return result;
			}

			// Wrong type!
			throw ADP.Argument();
		}

		/// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.Equals"]/*' />
        public override bool Equals(object value) 
        {
            if (value is OracleMonthSpan)
            	return (this == (OracleMonthSpan)value).Value;
            else
                return false;
        }

 		/// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.GetHashCode"]/*' />
        public override int GetHashCode() 
        {
            return IsNull ? 0 : _value.GetHashCode();
        }

		static internal int MarshalToInt32(
						NativeBuffer buffer, 
						int			 valueOffset)
		{
			byte[] ociValue = new byte[5];
			Marshal.Copy((IntPtr)buffer.PtrOffset(valueOffset), ociValue, 0, 5);

			int years	= (int)((long)( (int)ociValue[0] << 24
									  | (int)ociValue[1] << 16
									  | (int)ociValue[2] <<  8
									  | (int)ociValue[3]
									  ) - 0x80000000);
						
			int months	= (int)ociValue[4] - 60;
				
			int result = (years * 12) + months;
			AssertValid(result);

			return result;
		}
		
		static internal int MarshalToNative(object value, HandleRef buffer)
		{
			int from;
			
			if ( value is OracleMonthSpan )
				from = ((OracleMonthSpan)value)._value;
			else
				from = (int)value;
 
			byte[] ociValue = new byte[5];
			
			int years	= (int)((long)(from / 12) + 0x80000000);
			int months	= from % 12;

			// DEVNOTE: undoubtedly, this is Intel byte order specific, but how 
			//			do I verify what Oracle needs on a non Intel machine?
			
			ociValue[0] = (byte)((years >> 24));
			ociValue[1] = (byte)((years >> 16) & 0xff);
			ociValue[2] = (byte)((years >>  8) & 0xff);
			ociValue[3] = (byte)(years & 0xff);
			ociValue[4] = (byte)(months + 60);
			
			Marshal.Copy(ociValue, 0, (IntPtr)buffer, 5);
			return 5;
		}

        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.Parse"]/*' />
		public static OracleMonthSpan Parse(string s)
		{
			int ms = Int32.Parse(s);
			return new OracleMonthSpan(ms);
		}
		
        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.ToString"]/*' />
		public override string ToString()
		{
			if (IsNull)
				return Res.GetString(Res.SqlMisc_NullString);
			
			string retval = Value.ToString(CultureInfo.CurrentCulture);
			return retval;
		}


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Operators 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
        // Alternative method for operator ==
        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.Equals1"]/*' />
        public static OracleBoolean Equals(OracleMonthSpan x, OracleMonthSpan y)
        {
            return (x == y);
        }

        // Alternative method for operator >
        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.GreaterThan"]/*' />
        public static OracleBoolean GreaterThan(OracleMonthSpan x, OracleMonthSpan y)
        {
            return (x > y);
        }

        // Alternative method for operator >=
        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.GreaterThanOrEqual"]/*' />
        public static OracleBoolean GreaterThanOrEqual(OracleMonthSpan x, OracleMonthSpan y)
        {
            return (x >= y);
        }

        // Alternative method for operator <
        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.LessThan"]/*' />
        public static OracleBoolean LessThan(OracleMonthSpan x, OracleMonthSpan y)
        {
            return (x < y);
        }

        // Alternative method for operator <=
        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.LessThanOrEqual"]/*' />
        public static OracleBoolean LessThanOrEqual(OracleMonthSpan x, OracleMonthSpan y)
        {
            return (x <= y);
        }

        // Alternative method for operator !=
        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.NotEquals"]/*' />
        public static OracleBoolean NotEquals(OracleMonthSpan x, OracleMonthSpan y)
        {
            return (x != y);
        }

 		/// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.operatorTimeSpan"]/*' />
        public static explicit operator int(OracleMonthSpan x) 
        {
        	if (x.IsNull)
    			throw ADP.DataIsNull();
       			
            return x.Value;
        }

        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.operatorOracleMonthSpan"]/*' />
        public static explicit operator OracleMonthSpan(string x) 
        {
            return OracleMonthSpan.Parse(x);
        }


		/// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.operatorEQ"]/*' />
        public static OracleBoolean operator==	(OracleMonthSpan x, OracleMonthSpan y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) == 0);
        }

		/// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.operatorGT"]/*' />
		public static OracleBoolean operator>	(OracleMonthSpan x, OracleMonthSpan y)
		{
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) > 0);
		}

        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.operatorGE"]/*' />
        public static OracleBoolean operator>=	(OracleMonthSpan x, OracleMonthSpan y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) >= 0);
        }

        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.operatorLT"]/*' />
        public static OracleBoolean operator<	(OracleMonthSpan x, OracleMonthSpan y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) < 0);
        }

        /// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.operatorLE"]/*' />
        public static OracleBoolean operator<=	(OracleMonthSpan x, OracleMonthSpan y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) <= 0);
        }

 		/// <include file='doc\OracleMonthSpan.uex' path='docs/doc[@for="OracleMonthSpan.operatorNE"]/*' />
		public static OracleBoolean operator!=	(OracleMonthSpan x, OracleMonthSpan y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) != 0);
        }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oraclenumber.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleNumber.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Data.SqlTypes;
	using System.Diagnostics;
	using System.Globalization;
	using System.Runtime.InteropServices;

	//----------------------------------------------------------------------
	// OracleNumber
	//
	//	Contains all the information about a single column in a result set,
	//	and implements the methods necessary to describe column to Oracle
	//	and to extract the column data from the native buffer used to fetch
	//	it.
	//
    /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber"]/*' />
    [StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct OracleNumber : IComparable, INullable
	{
		// Used to bracket the range of double precision values that a number can be constructed from
		static private double doubleMinValue = -9.99999999999999E+125;
		static private double doubleMaxValue =  9.99999999999999E+125;

	
		// DEVNOTE:	the following constants are derived by uncommenting out the
		//			code below and running the OCITest program.  The code below
		//			will compute the correct constant values and will print them
		//			to the console output, where you can cut and past back into
		//			this file.
private static readonly byte[] OciNumberValue_DecimalMaxValue= { 0x10, 0xcf, 0x08, 0x5d, 0x1d, 0x11, 0x1a, 0x0f, 0x1b, 0x2c, 0x26, 0x3b, 0x5d, 0x31, 0x63, 0x1f, 0x28 };
private static readonly byte[] OciNumberValue_DecimalMinValue= { 0x11, 0x30, 0x5e, 0x09, 0x49, 0x55, 0x4c, 0x57, 0x4b, 0x3a, 0x40, 0x2b, 0x09, 0x35, 0x03, 0x47, 0x3e, 0x66 };
private static readonly byte[] OciNumberValue_E         = { 0x15, 0xc1, 0x03, 0x48, 0x53, 0x52, 0x53, 0x55, 0x3c, 0x05, 0x35, 0x24, 0x25, 0x03, 0x58, 0x30, 0x0e, 0x35, 0x43, 0x19, 0x62, 0x4d };
private static readonly byte[] OciNumberValue_MaxValue  = { 0x14, 0xff, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64, 0x64 };
private static readonly byte[] OciNumberValue_MinValue  = { 0x15, 0x00, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x66 };
private static readonly byte[] OciNumberValue_MinusOne  = { 0x03, 0x3e, 0x64, 0x66 };
private static readonly byte[] OciNumberValue_One       = { 0x02, 0xc1, 0x02 };
private static readonly byte[] OciNumberValue_Pi        = { 0x15, 0xc1, 0x04, 0x0f, 0x10, 0x5d, 0x42, 0x24, 0x5a, 0x50, 0x21, 0x27, 0x2f, 0x1b, 0x2c, 0x27, 0x21, 0x50, 0x33, 0x1d, 0x55, 0x15 };
private static readonly byte[] OciNumberValue_TwoPow64  = { 0x0b, 0xca, 0x13, 0x2d, 0x44, 0x2d, 0x08, 0x26, 0x0a, 0x38, 0x11, 0x11 };
private static readonly byte[] OciNumberValue_Zero      = { 0x01, 0x80 };

private const string WholeDigitPattern 		= "99999999999999999999999999999999999999999";
private const string FractionalDigitPattern = ".99999999999999999999999999999999999999999";
			

#if GENERATENUMBERCONSTANTS
		// This is the place that computes the static byte array constant values for the 
		// various constants this class exposes; run this and capture the output to construct 
		// the values that are used above.	
		static OracleNumber()
		{
			OciHandle	errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			byte[]		result = new byte[22];

			//-----------------------------------------------------------------
			FromDecimal(errorHandle, Decimal.MaxValue, result);
			PrintByteConstant("OciNumberValue_DecimalMaxValue", result);
			//-----------------------------------------------------------------
			FromDecimal(errorHandle, Decimal.MinValue, result);
			PrintByteConstant("OciNumberValue_DecimalMinValue", result);
			//-----------------------------------------------------------------
			FromInt32(errorHandle, 1, result);
			UnsafeNativeMethods.OCINumberExp(
									errorHandle.Handle,	// err
									result,				// p
									result				// result
									);
			PrintByteConstant("OciNumberValue_E", result);
			//-----------------------------------------------------------------
	        OracleNumber MaxValue = new OracleNumber("9.99999999999999999999999999999999999999E+125"); 
			PrintByteConstant("OciNumberValue_MaxValue", MaxValue._value);
			//-----------------------------------------------------------------
			OracleNumber MinValue = new OracleNumber("-9.99999999999999999999999999999999999999E+125");
			PrintByteConstant("OciNumberValue_MinValue", MinValue._value);
			//-----------------------------------------------------------------
			FromInt32(errorHandle, -1, result);
			PrintByteConstant("OciNumberValue_MinusOne", result);
			//-----------------------------------------------------------------
			FromInt32(errorHandle, 1, result);
			PrintByteConstant("OciNumberValue_One", result);
			//-----------------------------------------------------------------
			UnsafeNativeMethods.OCINumberSetPi(
									errorHandle.Handle,	// err
									result				// result
									);
			PrintByteConstant("OciNumberValue_Pi", result);
			//-----------------------------------------------------------------
			FromInt32(errorHandle, 2, result);
			PrintByteConstant("OciNumberValue_Two", result);
			//-----------------------------------------------------------------
			FromInt32(errorHandle, 2, result);
			UnsafeNativeMethods.OCINumberIntPower(
									errorHandle.Handle,	// err
									result,				// base
									64,					// exp
									result				// result
									);

			PrintByteConstant("OciNumberValue_TwoPow64", result);
			//-----------------------------------------------------------------
			UnsafeNativeMethods.OCINumberSetZero(
									errorHandle.Handle,	// err
									result				// result
									);
			PrintByteConstant("OciNumberValue_Zero", result);
			//-----------------------------------------------------------------
		}

		static void PrintByteConstant(string name, byte[] value)
		{
			Console.Write(String.Format("private static readonly byte[] {0,-25}= {{ 0x{1,-2:x2}", name, value[0]));

			for (int i = 1; i <= value[0]; i++)
				Console.Write(String.Format(", 0x{0,-2:x2}", value[i]));

			Console.WriteLine(" };");
		}
#endif //GENERATENUMBERCONSTANTS

		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Fields
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
		private byte[]	 _value;	// null == value is null


        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.E"]/*' />
        public static readonly OracleNumber E	= new OracleNumber(OciNumberValue_E);

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.MaxPrecision"]/*' />
        public static readonly Int32 MaxPrecision = 38;
    
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.MaxScale"]/*' />
        public static readonly Int32 MaxScale = 127;
    
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.MinScale"]/*' />
        public static readonly Int32 MinScale = -84;
    
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.MaxValue"]/*' />
        public static readonly OracleNumber MaxValue = new OracleNumber(OciNumberValue_MaxValue); 

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.MinValue"]/*' />
        public static readonly OracleNumber MinValue = new OracleNumber(OciNumberValue_MinValue);

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.MinusOne"]/*' />
        public static readonly OracleNumber MinusOne = new OracleNumber(OciNumberValue_MinusOne);
    
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Null"]/*' />
        public static readonly OracleNumber Null= new OracleNumber(true);

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.One"]/*' />
        public static readonly OracleNumber One	= new OracleNumber(OciNumberValue_One);

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.PI"]/*' />
        public static readonly OracleNumber PI 	= new OracleNumber(OciNumberValue_Pi);

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Zero"]/*' />
        public static readonly OracleNumber Zero= new OracleNumber(OciNumberValue_Zero); 
		
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Constructors
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		// (internal) Construct from nothing
		private OracleNumber(bool isNull)
		{
			_value = (isNull) ? null : new byte[22];
		}

		// (internal) Construct from a constant byte array
		private OracleNumber(byte[] bits)
		{
			_value = bits;
		}

		// Construct from System.Decimal
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.OracleNumber1"]/*' />
		public OracleNumber (Decimal decValue) : this (false)
		{
			OciHandle errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			FromDecimal(errorHandle, decValue, _value);
        }

		// Construct from System.Double
	    /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.OracleNumber2"]/*' />
		public OracleNumber (double dblValue) : this (false)
		{
			OciHandle errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			FromDouble(errorHandle, dblValue, _value);
		}

		// Construct from System.Int32
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.OracleNumber3"]/*' />
		public OracleNumber (Int32 intValue) : this (false)
		{
			OciHandle errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			FromInt32(errorHandle, intValue, _value);
		}
		
		// Construct from System.Int64
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.OracleNumber4"]/*' />
		public OracleNumber (Int64 longValue) : this (false)
		{
			OciHandle errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			FromInt64(errorHandle, longValue, _value);
		}
		
 		// Copy constructor
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.OracleNumber8"]/*' />
		public OracleNumber (OracleNumber from)  
		{
			byte[] fromvalue = from._value;
			
			if (null != fromvalue)
				_value = (byte[])fromvalue.Clone();
			else
				_value = null;
		}
 		
		// (internal) Construct from System.String
		internal OracleNumber (string s) : this (false)
		{
			OciHandle errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			FromString(errorHandle, s, _value);
		}
		
        // (internal) construct from a row/parameter binding
		internal OracleNumber(
					NativeBuffer 		buffer, 
					int					valueOffset) : this (false)
		{
			Marshal.Copy((IntPtr)buffer.PtrOffset(valueOffset), _value, 0, 22);
		}


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.IsNull"]/*' />
		public bool IsNull 
		{
			get { return (null == _value); }
		}

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Value"]/*' />
        public Decimal Value {
            get
            {
                return (Decimal)this;
            }           
        }


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		/// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.CompareTo"]/*' />
		public int CompareTo(
		  	object obj
			)
		{
			if (obj.GetType() == typeof(OracleNumber))
			{
				OracleNumber	value2 = (OracleNumber)obj;

	            // If both values are Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return value2.IsNull ? 0  : -1;

                if (value2.IsNull)
                    return 1;

				// Neither value is null, do the comparison.
	                
				OciHandle	errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
				int			result = InternalCmp(errorHandle, _value, value2._value);
				return result;
			}

			// Wrong type!
			throw ADP.Argument();
		}

 		/// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Equals"]/*' />
        public override bool Equals(object value) 
        {
            if (value is OracleNumber)
            	return (this == (OracleNumber)value).Value;
            else
                return false;
        }
 		

 		/// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.GetHashCode"]/*' />
        public override int GetHashCode() 
        {
            return IsNull ? 0 : _value.GetHashCode();
        }

		static internal decimal MarshalToDecimal(
					NativeBuffer 		buffer, 
					int					valueOffset,
					OracleConnection 	connection)
		{
			byte[] value = new byte[22];
			Marshal.Copy((IntPtr)buffer.PtrOffset(valueOffset), value, 0, 22);
			
			OciHandle errorHandle = connection.ErrorHandle;
			decimal result = ToDecimal(errorHandle, value);
			return result;
		}

		static internal int MarshalToInt32(
					NativeBuffer 		buffer, 
					int					valueOffset,
					OracleConnection 	connection)
		{
			byte[] value = new byte[22];
			Marshal.Copy((IntPtr)buffer.PtrOffset(valueOffset), value, 0, 22);
			
			OciHandle errorHandle = connection.ErrorHandle;
			int result = ToInt32(errorHandle, value);
			return result;
		}

		static internal long MarshalToInt64(
					NativeBuffer 		buffer, 
					int					valueOffset,
					OracleConnection 	connection)
		{
			byte[] value = new byte[22];
			Marshal.Copy((IntPtr)buffer.PtrOffset(valueOffset), value, 0, 22);
			
			OciHandle errorHandle = connection.ErrorHandle;
			long result = ToInt64(errorHandle, value);
			return result;
		}

		static internal int MarshalToNative(object value, HandleRef buffer, OracleConnection connection)
		{
			byte[] from;

			if ( value is OracleNumber )
				from = ((OracleNumber)value)._value;
			else
			{
				OciHandle errorHandle = connection.ErrorHandle;
				from = new byte[22];

				if ( value is Decimal )
					FromDecimal(errorHandle, (decimal)value, from);
				else if ( value is int )
					FromInt32(errorHandle, (int)value, from);
				else if ( value is long )
					FromInt64(errorHandle, (long)value, from);
				else //if ( value is double )
					FromDouble(errorHandle, (double)value, from);
			}
			
			Marshal.Copy(from, 0, (IntPtr)buffer, 22);
			return 22;
		}

		/// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Parse"]/*' />
		public static OracleNumber Parse(string s)
		{
			if (null == s)
				throw ADP.ArgumentNull("s");
			
			return new OracleNumber(s);
		}

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Internal Operators (used in the conversion routines) 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
		private static void InternalAdd (
        			OciHandle errorHandle, 
        			byte[] x, 
        			byte[] y, 
        			byte[] result
        			) 
		{
			int rc = UnsafeNativeMethods.OCINumberAdd(
										errorHandle.Handle,	// err
										x,					// number1
										y,					// number2
										result				// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);
		}

		private static int InternalCmp (
        			OciHandle errorHandle, 
        			byte[] value1, 
        			byte[] value2
        			) 
		{
			int result;
			
			int rc = UnsafeNativeMethods.OCINumberCmp(
									errorHandle.Handle,		// err
									value1,					// number1
									value2,					// number2
									out result				// result
									);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}
 
		private static void InternalDiv (
        			OciHandle errorHandle, 
        			byte[] x, 
        			byte[] y, 
        			byte[] result
        			) 
		{
			int rc = UnsafeNativeMethods.OCINumberDiv(
										errorHandle.Handle,	// err
										x,					// number1
										y,					// number2
										result				// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);
		}

		private static bool InternalIsInt (
        			OciHandle errorHandle, 
        			byte[] n
        			) 
		{
			int isInt;
			
			int rc = UnsafeNativeMethods.OCINumberIsInt(
										errorHandle.Handle,	// err
										n,					// number
										out	isInt			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return (0 != isInt);
		}

		private static void InternalMod (
        			OciHandle errorHandle, 
        			byte[] x, 
        			byte[] y, 
        			byte[] result
        			) 
		{
			int rc = UnsafeNativeMethods.OCINumberMod(
										errorHandle.Handle,	// err
										x,					// number1
										y,					// number2
										result				// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);
		}

		private static void InternalMul (
        			OciHandle errorHandle, 
        			byte[] x, 
        			byte[] y, 
        			byte[] result
        			) 
		{
			int rc = UnsafeNativeMethods.OCINumberMul(
										errorHandle.Handle,	// err
										x,					// number1
										y,					// number2
										result				// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);
		}

		private static void InternalNeg (
        			OciHandle errorHandle, 
        			byte[] x, 
        			byte[] result
        			) 
		{
			int rc = UnsafeNativeMethods.OCINumberNeg(
										errorHandle.Handle,	// err
										x,					// number1
										result				// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);
		}

		private static int InternalSign (
        			OciHandle errorHandle, 
        			byte[] n
        			) 
		{
			int sign;
			
			int rc = UnsafeNativeMethods.OCINumberSign(
										errorHandle.Handle,	// err
										n,					// number
										out	sign			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return sign;
		}

		private static void InternalShift (
        			OciHandle errorHandle, 
        			byte[] n,
        			int digits,
        			byte[] result
        			) 
		{
			int rc = UnsafeNativeMethods.OCINumberShift(
										errorHandle.Handle,	// err
										n,					// nDig
										digits,				// nDig
										result				// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);
		}

		private static void InternalSub (
        			OciHandle errorHandle, 
        			byte[] x, 
        			byte[] y, 
        			byte[] result
        			) 
		{
			int rc = UnsafeNativeMethods.OCINumberSub(
										errorHandle.Handle,	// err
										x,					// number1
										y,					// number2
										result				// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);
		}

		private static void InternalTrunc (
        			OciHandle errorHandle, 
        			byte[] n,
        			int position,
        			byte[] result
        			) 
		{
			int rc = UnsafeNativeMethods.OCINumberTrunc(
										errorHandle.Handle,	// err
										n,					// number
										position,			// decplace
										result				// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);
		}

		private static void FromDecimal(
				OciHandle	errorHandle,
				decimal		decimalValue,
				byte[]		result
				)
		{
 			int[] 	unpackedDecimal = Decimal.GetBits(decimalValue);
			ulong	lowMidPart	= ((ulong)((uint)unpackedDecimal[1]) << 32) | (ulong)((uint)unpackedDecimal[0]);
			uint	highPart	= (uint)unpackedDecimal[2];
			int		sign 		= (unpackedDecimal[3] >> 31);
			int		scale 		= ((unpackedDecimal[3] >> 16) & 0x7f);

			FromUInt64(errorHandle, lowMidPart, result);

			if (0 != highPart)
			{
				// Bummer, the value is larger than an Int64...
				byte[] temp = new byte[22];

				FromUInt32	(errorHandle, highPart,				 temp);
				InternalMul	(errorHandle, temp,   OciNumberValue_TwoPow64, temp);
				InternalAdd	(errorHandle, result, temp, 		 result);
			}
			
			// If the sign bit indicates negative, negate the result;
			if (0 != sign)
				InternalNeg	(errorHandle, result, result);

			// Adjust for a scale value.
			if (0 != scale)
				InternalShift	(errorHandle, result, -scale, result);
        }

		private static void FromDouble(
				OciHandle	errorHandle,
				double		dblValue,
				byte[]		result
				)
		{
			if (dblValue < doubleMinValue || dblValue > doubleMaxValue)
				throw ADP.OperationResultedInOverflow();
			
			int rc = UnsafeNativeMethods.OCINumberFromReal(
										errorHandle.Handle,	// err
										ref dblValue,		// rnum
										8,					// rnum_length
										result				// number
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);
		}
		
		private static void FromInt32(
				OciHandle	errorHandle,
				int			intValue,
				byte[]		result
				)
		{
			int rc = UnsafeNativeMethods.OCINumberFromInt(
										errorHandle.Handle,			// err
										ref intValue,				// inum
										4,							// inum_length
										OCI.SIGN.OCI_NUMBER_SIGNED, // inum_s_flag
										result						// number
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);
		}
		
		private static void FromUInt32(
				OciHandle	errorHandle,
				UInt32		uintValue,
				byte[]		result
				)
		{
			int rc = UnsafeNativeMethods.OCINumberFromInt(
										errorHandle.Handle,			// err
										ref uintValue,				// inum
										4,							// inum_length
										OCI.SIGN.OCI_NUMBER_UNSIGNED,//inum_s_flag
										result						// number
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);
		}
		
		private static void FromInt64(
				OciHandle	errorHandle,
				long		longValue,
				byte[]		result
				)
		{
			int rc = UnsafeNativeMethods.OCINumberFromInt(
										errorHandle.Handle,			// err
										ref longValue,				// inum
										8,							// inum_length
										OCI.SIGN.OCI_NUMBER_SIGNED, // inum_s_flag
										result						// number
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);
		}
		
		private static void FromUInt64(
				OciHandle	errorHandle,
				UInt64		ulongValue,
				byte[]		result
				)
		{
			int rc = UnsafeNativeMethods.OCINumberFromInt(
										errorHandle.Handle,			// err
										ref ulongValue,				// inum
										8,							// inum_length
										OCI.SIGN.OCI_NUMBER_UNSIGNED,//inum_s_flag
										result						// number
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);
		}

		private void FromString(OciHandle errorHandle, string s, string format, byte[] result)
		{
			int rc = UnsafeNativeMethods.OCINumberFromText(
										errorHandle.Handle,	// err
										s,					// str
										s.Length,			// str_length
										format,				// fmt
										format.Length,		// fmt_length
										ADP.NullHandleRef,	// nls_params
										0,					// nls_p_length
										result				// number
										);
			if (0 != rc)
				OracleException.Check(errorHandle, rc);
		}
		
		private void FromString(OciHandle errorHandle, string s, byte[] result)
		{
			// DEVNOTE:	this only supports the format [{+/-}]digits.digits[E[{+/-}]exponent],
			//			that is all that SQLNumeric supports, so that's all I'll support.  It
			//			is also all that the ToString method on this class will produce...
			
			byte[]			temp = new byte[22];
			int				exponent = 0;
			
			s = s.Trim();

			int exponentAt	= s.IndexOfAny("eE".ToCharArray());
			if (exponentAt > 0)
			{
				exponent = Int32.Parse(s.Substring(exponentAt+1), CultureInfo.InvariantCulture);
				s = s.Substring(0,exponentAt);
			}

			bool isNegative = false;
				
			if ('-' == s[0])
			{
				isNegative = true;
				s = s.Substring(1);
			}
			else if ('+' == s[0])
			{
				s = s.Substring(1);
			}

			int decimalPointAt = s.IndexOf('.');
			if (decimalPointAt > 0)
			{
				FromString(errorHandle, s.Substring(0,decimalPointAt), WholeDigitPattern, result);
				FromString(errorHandle, s.Substring(decimalPointAt),  FractionalDigitPattern, temp);
				InternalAdd(errorHandle, result, temp, result);
			}
			else
			{
				FromString(errorHandle, s, WholeDigitPattern, result);
			}

			if (0 != exponent)
				InternalShift(errorHandle, result, exponent, result);

			if (isNegative)
				InternalNeg(errorHandle, result, result);

			GC.KeepAlive(s);

		}

		private static Decimal ToDecimal(
				OciHandle	errorHandle,
				byte[]		value
				)
		{
			byte[]	temp1 = (byte[])value.Clone();	
			byte[]	temp2 = new byte[22];
			byte 	scale = 0;			
			int 	sign = InternalSign(errorHandle, temp1);

			if (sign < 0)
				InternalNeg(errorHandle, temp1, temp1);

			if ( !InternalIsInt(errorHandle, temp1) )
			{
				// DEVNOTE: I happen to know how to figure out how many decimal places the value has,
				//			but it means cracking the value.  Oracle doesn't provide API support to
				//			tell us how many decimal digits there are in a nubmer
				int decimalShift = 2 * (temp1[0] - ((temp1[1] & 0x7f)-64) - 1);
			
				InternalShift(errorHandle, temp1, decimalShift, temp1);
				scale += (byte)decimalShift;
				
				while( !InternalIsInt(errorHandle, temp1) )
				{
					InternalShift(errorHandle, temp1, 1, temp1);
					scale++;
				}
			}
			
			InternalMod(errorHandle, temp1, OciNumberValue_TwoPow64, temp2);
			ulong	loMid = ToUInt64(errorHandle, temp2);
			
			InternalDiv(errorHandle, temp1, OciNumberValue_TwoPow64, temp2);
			InternalTrunc(errorHandle, temp2, 0, temp2);
			uint 	hi	  = ToUInt32(errorHandle, temp2);
			
			Decimal decimalValue = new Decimal(
										(int)(loMid & 0xffffffff),// lo
										(int)(loMid >> 32),	 	 // mid
										(int)hi, 				 // hi
										(sign < 0),				 // isNegative
										scale					 // scale
										);
			
			return decimalValue;
        }

		private static int ToInt32(
				OciHandle	errorHandle,
				byte[]		value
				)
		{
			int result;
			
			int rc = UnsafeNativeMethods.OCINumberToInt(
								errorHandle.Handle,			// err
								value,						// number
								4,							// rsl_length
								OCI.SIGN.OCI_NUMBER_SIGNED,	// rsl_flag
								out result					// rsl
								);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

		private static uint ToUInt32(
				OciHandle	errorHandle,
				byte[]		value
				)
		{
			uint result;
			
			int rc = UnsafeNativeMethods.OCINumberToInt(
								errorHandle.Handle,			// err
								value,						// number
								4,							// rsl_length
								OCI.SIGN.OCI_NUMBER_UNSIGNED,//rsl_flag
								out result					// rsl
								);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

		private static long ToInt64(
				OciHandle	errorHandle,
				byte[]		value
				)
		{
			long result;
			
			int rc = UnsafeNativeMethods.OCINumberToInt(
								errorHandle.Handle,			// err
								value,						// number
								8,							// rsl_length
								OCI.SIGN.OCI_NUMBER_SIGNED,	// rsl_flag
								out result					// rsl
								);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

		private static ulong ToUInt64(
				OciHandle	errorHandle,
				byte[]		value
				)
		{
			ulong result;
			
			int rc = UnsafeNativeMethods.OCINumberToInt(
								errorHandle.Handle,			// err
								value,						// number
								8,							// rsl_length
								OCI.SIGN.OCI_NUMBER_UNSIGNED,//rsl_flag
								out result					// rsl
								);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}
		
		static private string ToString(OciHandle errorHandle, byte[] value)
		{
			byte[]			buffer = new byte[64];
			int				bufferLen = buffer.Length;

			int rc = UnsafeNativeMethods.OCINumberToText(
										errorHandle.Handle,	// err
										value,				// number
										"TM9",				// fmt
										3,					// fmt_length
										ADP.NullHandleRef,	// nls_params
										0,					// nls_p_length
										ref bufferLen,		// buf_size
										buffer				// buf
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			// Wonder of wonders, Oracle has a problem with the value -999999999999999999999999.9999
			// where it seems that has trailing ':' characters if you their translator
			// method; we deal with it by removing the ':' characters.
			int realBufferLen = Array.IndexOf(buffer, (byte)58);

			// Oracle doesn't set the buffer length correctly; they include the null bytes
			// that trail the actual value.  That means it's up to us to remove them.
			realBufferLen = (realBufferLen > 0) ? realBufferLen : Array.LastIndexOf(buffer, 0);

			// Technically, we should use Oracle's conversion OCICharsetToUnicode, but since numeric
			// digits are ANSI digits, we're safe here.
			string retval = System.Text.Encoding.Default.GetString(buffer, 0, (realBufferLen > 0) ? realBufferLen : bufferLen);
			return retval;
		}

		/// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.ToString"]/*' />
		public override string ToString()
		{
			if (IsNull)
				return Res.GetString(Res.SqlMisc_NullString);

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			string retval = ToString(errorHandle, _value);
			return retval;
		}


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Operators 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
		/// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operatorEQ"]/*' />
        public static OracleBoolean operator==	(OracleNumber x, OracleNumber y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) == 0);
        }

		/// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operatorGT"]/*' />
		public static OracleBoolean operator>	(OracleNumber x, OracleNumber y)
		{
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) > 0);
		}

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operatorGE"]/*' />
        public static OracleBoolean operator>=	(OracleNumber x, OracleNumber y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) >= 0);
        }

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operatorLT"]/*' />
        public static OracleBoolean operator<	(OracleNumber x, OracleNumber y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) < 0);
        }

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operatorLE"]/*' />
        public static OracleBoolean operator<=	(OracleNumber x, OracleNumber y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) <= 0);
        }

 		/// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operatorNE"]/*' />
		public static OracleBoolean operator!=	(OracleNumber x, OracleNumber y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) != 0);
        }

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operator-"]/*' />
        public static OracleNumber operator-	(OracleNumber x) 
		{
			if (x.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			InternalNeg(errorHandle, x._value, result._value);
			return result;
		}

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operator+"]/*' />
        public static OracleNumber operator+	(OracleNumber x, OracleNumber y) 
		{
			if (x.IsNull || y.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			InternalAdd(errorHandle,x._value,y._value,result._value);
			return result;
		}


        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operator-1"]/*' />
        public static OracleNumber operator-	(OracleNumber x, OracleNumber y) 
		{
			if (x.IsNull || y.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			InternalSub(errorHandle,x._value,y._value,result._value);
			return result;
		}

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operator*"]/*' />
        public static OracleNumber operator*	(OracleNumber x, OracleNumber y) 
		{
			if (x.IsNull || y.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			InternalMul(errorHandle, x._value, y._value, result._value);
			return result;
		}

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operator/"]/*' />
        public static OracleNumber operator/	(OracleNumber x, OracleNumber y) 
		{
			if (x.IsNull || y.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			InternalDiv(errorHandle, x._value, y._value, result._value);
			return result;
		}

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operator%"]/*' />
        public static OracleNumber operator%	(OracleNumber x, OracleNumber y) 
		{
			if (x.IsNull || y.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			InternalMod(errorHandle, x._value, y._value, result._value);
			return result;
		}

 		/// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operatorDecimal"]/*' />
        public static explicit operator Decimal(OracleNumber x) 
        {
    		if (x.IsNull) 
    			throw ADP.DataIsNull();
 
			OciHandle	errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			
            Decimal result = ToDecimal(errorHandle, x._value);
            return result;
        }

 		/// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operatordouble"]/*' />
        public static explicit operator Double(OracleNumber x) 
        {
    		if (x.IsNull) 
    			throw ADP.DataIsNull();
 
			OciHandle	errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			double		result;
			
			int rc = UnsafeNativeMethods.OCINumberToReal(
										errorHandle.Handle,	// err
										x._value,			// number
										8,					// rsl_length
										out result			// rsl
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
        }

 		/// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operatorInt32"]/*' />
        public static explicit operator Int32(OracleNumber x) 
        {
    		if (x.IsNull) 
    			throw ADP.DataIsNull();
 
			OciHandle	errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			Int32		result = ToInt32(errorHandle, x._value);
			return result;
        }

 		/// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operatorInt64"]/*' />
        public static explicit operator Int64(OracleNumber x) 
        {
    		if (x.IsNull) 
    			throw ADP.DataIsNull();
 
			OciHandle	errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			Int64		result = ToInt64(errorHandle, x._value);
			return result;
        }

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operatorOracleNumber1"]/*' />
        public static explicit operator OracleNumber(Decimal x) 
        {
            return new OracleNumber(x);
        }

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operatorOracleNumber2"]/*' />
        public static explicit operator OracleNumber(double x) 
        {
            return new OracleNumber(x);
        }

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operatorOracleNumber3"]/*' />
        public static explicit operator OracleNumber(int x) 
        {
            return new OracleNumber(x);
        }

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operatorOracleNumber4"]/*' />
        public static explicit operator OracleNumber(long x) 
        {
            return new OracleNumber(x);
        }

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.operatorOracleNumber5"]/*' />
        public static explicit operator OracleNumber(string x) 
        {
            return new OracleNumber(x);
        }


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Built In Functions 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
		//----------------------------------------------------------------------
        // Abs - absolute value
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Abs"]/*' />
        public static OracleNumber Abs(OracleNumber n) 
		{
			if (n.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberAbs(
				errorHandle.Handle,		// err
				n._value,				// number
				result._value			// result
				);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

		//----------------------------------------------------------------------
        // Acos - Get the Arc Cosine of the number
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Acos"]/*' />
        public static OracleNumber Acos(OracleNumber n) 
		{
			if (n.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberArcCos(
										errorHandle.Handle,		// err
										n._value,				// number
										result._value			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

 		//----------------------------------------------------------------------
	    // Add - Alternative method for operator +
	    //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Add"]/*' />
        public static OracleNumber Add(OracleNumber x, OracleNumber y)
        {
            return x + y;
        }

		//----------------------------------------------------------------------
        // Asin - Get the Arc Sine of the number
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Asin"]/*' />
        public static OracleNumber Asin(OracleNumber n) 
		{
			if (n.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberArcSin(
										errorHandle.Handle,		// err
										n._value,				// number
										result._value			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

		//----------------------------------------------------------------------
        // Atan - Get the Arc Tangent of the number
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Atan1"]/*' />
        public static OracleNumber Atan(OracleNumber n) 
		{
			if (n.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberArcTan(
										errorHandle.Handle,		// err
										n._value,				// number
										result._value			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

		//----------------------------------------------------------------------
        // Atan2 - Get the Arc Tangent of twi numbers
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Atan2"]/*' />
        public static OracleNumber Atan2(OracleNumber y, OracleNumber x) 
		{
			if (x.IsNull || y.IsNull)
			    return Null;


			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberArcTan2(
										errorHandle.Handle,		// err
										y._value,				// number
										x._value,				// number
										result._value			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

		//----------------------------------------------------------------------
        // Ceiling - next smallest integer greater than or equal to the numeric
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Ceiling"]/*' />
        public static OracleNumber Ceiling(OracleNumber n) 
		{
			if (n.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberCeil(
										errorHandle.Handle,		// err
										n._value,				// number
										result._value			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

		//----------------------------------------------------------------------
        // Cos - Get the Cosine of the number
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Cos"]/*' />
        public static OracleNumber Cos(OracleNumber n) 
		{
			if (n.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberCos(
										errorHandle.Handle,		// err
										n._value,				// number
										result._value			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

		//----------------------------------------------------------------------
        // Cosh - Get the Hyperbolic Cosine of the number
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Cosh"]/*' />
        public static OracleNumber Cosh(OracleNumber n) 
		{
			if (n.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberHypCos(
										errorHandle.Handle,		// err
										n._value,				// number
										result._value			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

 		//----------------------------------------------------------------------
	    // Divide - Alternative method for operator /
	    //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Divide"]/*' />
        public static OracleNumber Divide(OracleNumber x, OracleNumber y)
        {
            return x / y;
        }

 		//----------------------------------------------------------------------
	    // Equals - Alternative method for operator ==
	    //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Equals1"]/*' />
        public static OracleBoolean Equals(OracleNumber x, OracleNumber y)
        {
            return (x == y);
        }

		//----------------------------------------------------------------------
	    // Exp - raise e to the specified power
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Exp"]/*' />
        public static OracleNumber Exp(OracleNumber p) 
		{
			if (p.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberExp(
										errorHandle.Handle,		// err
										p._value,				// base
										result._value			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

		//----------------------------------------------------------------------
        // Floor - next largest integer smaller or equal to the numeric
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Floor"]/*' />
        public static OracleNumber Floor(OracleNumber n) 
		{
			if (n.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberFloor(
										errorHandle.Handle,		// err
										n._value,				// number
										result._value			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

 		//----------------------------------------------------------------------
	    // GreaterThan - Alternative method for operator >
	    //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.GreaterThan"]/*' />
        public static OracleBoolean GreaterThan(OracleNumber x, OracleNumber y)
        {
            return (x > y);
        }

 		//----------------------------------------------------------------------
	    // GreaterThanOrEqual - Alternative method for operator >=
	    //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.GreaterThanOrEqual"]/*' />
        public static OracleBoolean GreaterThanOrEqual(OracleNumber x, OracleNumber y)
        {
            return (x >= y);
        }

  		//----------------------------------------------------------------------
	    // LessThan - Alternative method for operator <
	    //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.LessThan"]/*' />
        public static OracleBoolean LessThan(OracleNumber x, OracleNumber y)
        {
            return (x < y);
        }

  		//----------------------------------------------------------------------
	    // LessThanOrEqual - Alternative method for operator <=
	    //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.LessThanOrEqual"]/*' />
        public static OracleBoolean LessThanOrEqual(OracleNumber x, OracleNumber y)
        {
            return (x <= y);
        }

		//----------------------------------------------------------------------
	    // Log - Compute the natural logarithm (base e)
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Log1"]/*' />
        public static OracleNumber Log(OracleNumber n) 
		{
			if (n.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberLn(
										errorHandle.Handle,		// err
										n._value,				// base
										result._value			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

		//----------------------------------------------------------------------
	    // Log - Compute the logarithm (any base)
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Log2"]/*' />
        public static OracleNumber Log(OracleNumber n, int newBase) 
		{
			return Log(n, new OracleNumber(newBase));
		}

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Log3"]/*' />
        public static OracleNumber Log(OracleNumber n, OracleNumber newBase) 
		{
			if (n.IsNull || newBase.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberLog(
										errorHandle.Handle,			// err
										newBase._value,			// base
										n._value,					// number
										result._value				// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

		//----------------------------------------------------------------------
	    // Log10 - Compute the logarithm (base 10)
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Log10"]/*' />
        public static OracleNumber Log10(OracleNumber n) 
		{
			return Log(n, new OracleNumber(10));
		}

		//----------------------------------------------------------------------
	    // Max - Get the maximum value of two Oracle Numbers
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Max"]/*' />
        public static OracleNumber Max(OracleNumber x, OracleNumber y) 
		{
			if (x.IsNull || y.IsNull)
			    return Null;

			return (x > y) ? x : y;
		}

		//----------------------------------------------------------------------
	    // Min - Get the minimum value of two Oracle Numbers
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Min"]/*' />
        public static OracleNumber Min(OracleNumber x, OracleNumber y) 
		{
			if (x.IsNull || y.IsNull)
			    return Null;

			return (x < y) ? x : y;
		}

 		//----------------------------------------------------------------------
	    // Modulo - Alternative method for operator %
	    //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Modulo"]/*' />
        public static OracleNumber Modulo(OracleNumber x, OracleNumber y)
        {
            return x % y;
        }

 		//----------------------------------------------------------------------
	    // Multiply - Alternative method for operator *
	    //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Multiply"]/*' />
        public static OracleNumber Multiply(OracleNumber x, OracleNumber y)
        {
            return x * y;
        }

 		//----------------------------------------------------------------------
	    // Negate - Alternative method for unary operator -
	    //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Negate"]/*' />
        public static OracleNumber Negate(OracleNumber x)
        {
            return -x;
        }

  		//----------------------------------------------------------------------
	    // NotEquals - Alternative method for operator !=
	    //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.NotEquals"]/*' />
        public static OracleBoolean NotEquals(OracleNumber x, OracleNumber y)
        {
            return (x != y);
        }

		//----------------------------------------------------------------------
	    // Pow - Compute the power of a numeric
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Pow1"]/*' />
        public static OracleNumber Pow(OracleNumber x, Int32 y) 
		{
			if (x.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberIntPower(
										errorHandle.Handle,		// err
										x._value,				// base
										y,						// exp
										result._value			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Pow2"]/*' />
        public static OracleNumber Pow(OracleNumber x, OracleNumber y) 
		{
			if (x.IsNull || y.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberPower(
										errorHandle.Handle,		// err
										x._value,				// base
										y._value,				// exp
										result._value			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

		//----------------------------------------------------------------------
        // Round - Round the numeric to a specific digit
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Round"]/*' />
        public static OracleNumber Round(OracleNumber n, int position) 
		{
			if (n.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberRound(
										errorHandle.Handle,		// err
										n._value,				// number
										position,				// decplace
										result._value			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

		//----------------------------------------------------------------------
        // Shift - Shift the number of digits
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Shift"]/*' />
        public static OracleNumber Shift(OracleNumber n, int digits) 
		{
			if (n.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			InternalShift(errorHandle,
						  n._value,
						  digits,
						  result._value);
			return result;
		}

		//----------------------------------------------------------------------
        // Sign -   1 if positive, -1 if negative
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Sign"]/*' />
        public static OracleNumber Sign(OracleNumber n) 
		{
			if (n.IsNull)
			    return Null;

			OciHandle	 errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			int			 sign = InternalSign(errorHandle, n._value);
			OracleNumber result = (sign > 0) ? One : MinusOne;
			return result;
		}

		//----------------------------------------------------------------------
        // Sin - Get the Sine of the number
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Sin"]/*' />
        public static OracleNumber Sin(OracleNumber n) 
		{
			if (n.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberSin(
										errorHandle.Handle,		// err
										n._value,				// number
										result._value			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

		//----------------------------------------------------------------------
        // Sinh - Get the Hyperbolic Sine of the number
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Sinh"]/*' />
        public static OracleNumber Sinh(OracleNumber n) 
		{
			if (n.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberHypSin(
										errorHandle.Handle,		// err
										n._value,				// number
										result._value			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

		//----------------------------------------------------------------------
        // Sqrt - Get the Square Root of the number
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Sqrt"]/*' />
        public static OracleNumber Sqrt(OracleNumber n) 
		{
			if (n.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberSqrt(
										errorHandle.Handle,		// err
										n._value,				// number
										result._value			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

 		//----------------------------------------------------------------------
	    // Subtract - Alternative method for operator -
	    //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Subtract"]/*' />
        public static OracleNumber Subtract(OracleNumber x, OracleNumber y)
        {
            return x - y;
        }

		//----------------------------------------------------------------------
        // Tan - Get the  Tangent of the number
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Tan"]/*' />
        public static OracleNumber Tan(OracleNumber n) 
		{
			if (n.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberTan(
										errorHandle.Handle,		// err
										n._value,				// number
										result._value			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

		//----------------------------------------------------------------------
        // Tanh - Get the Hyperbolic Tangent of the number
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Tanh"]/*' />
        public static OracleNumber Tanh(OracleNumber n) 
		{
			if (n.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			int rc = UnsafeNativeMethods.OCINumberHypTan(
										errorHandle.Handle,		// err
										n._value,				// number
										result._value			// result
										);

			if (0 != rc)
				OracleException.Check(errorHandle, rc);

			return result;
		}

		//----------------------------------------------------------------------
        // Truncate - Truncate the numeric to a specific digit
        //
        /// <include file='doc\OracleNumber.uex' path='docs/doc[@for="OracleNumber.Truncate"]/*' />
        public static OracleNumber Truncate(OracleNumber n, int position) 
		{
			if (n.IsNull)
			    return Null;

			OciHandle		errorHandle = TempEnvironment.GetHandle(OCI.HTYPE.OCI_HTYPE_ERROR);
			OracleNumber	result = new OracleNumber(false);

			InternalTrunc(errorHandle,
						  n._value,
						  position,
						  result._value);
			return result;
		}

	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracleparameterbinding.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleParameterBinding.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Data.Common;
    using System.Data.SqlTypes;
    using System.Diagnostics;
    using System.Runtime.InteropServices;

    //----------------------------------------------------------------------
    // OracleParameterBinding
    //
    //  this class is meant to handle the parameter binding for an
    //  single command object (since parameters can be bound concurrently
    //  to multiple command objects)
    //
    sealed internal class OracleParameterBinding
    {
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Fields
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////

        OracleCommand       _command;                   // the command that this binding is for
        OracleParameter     _parameter;                 // the parameter that this binding is for
        object              _coercedValue;              // _parameter.CoercedValue;
        
        MetaType            _bindingMetaType;           // meta type of the binding, in case it needs adjustment (String bound as CLOB, etc...)
        OciHandle           _bindHandle;                // the bind handle, once this has been bound
        int                 _bufferLength;              // number of bytes/characters to reserve on the server
        int                 _bufferLengthInBytes;       // number of bytes required to bind the value
        int                 _indicatorOffset;           // offset from the start of the parameter buffer to the indicator binding (see OCI.INDICATOR)
        int                 _lengthOffset;              // offset from the start of the parameter buffer to the length binding
        int                 _valueOffset;               // offset from the start of the parameter buffer to the value binding
        bool                _bindAsUCS2;                // true when we should bind this as UCS2

        OciHandle           _descriptor;                // ref cursor handle for ref cursor types.
        OciLobLocator       _locator;                   // lob locator for BFile and Lob types.

        
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Constructors
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////

        // Construct an "empty" parameter
        /// <include file='doc\OracleParameterBinding.uex' path='docs/doc[@for="OracleParameterBinding.OracleParameterBinding1"]/*' />
        internal OracleParameterBinding(
            OracleCommand   command,
            OracleParameter parameter
            )
        {
            _command   = command;
            _parameter = parameter;
        }

        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Properties 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////

        internal OracleParameter Parameter
        {
            get { return _parameter; }
        }

        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Methods 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////

        internal void Bind( 
                        OciHandle        statementHandle,
                        NativeBuffer     parameterBuffer,
                        OracleConnection connection
                        )
        {
            IntPtr          h;

            // Don't bother with parameters where the user asks for the default value.
            if ( !IsDirection(Parameter, ParameterDirection.Output) && null == Parameter.Value)
                return; 
            
            string          parameterName  = Parameter.ParameterName;
            OciHandle       errorHandle    = connection.ErrorHandle;
            OciHandle       environmentHandle =  connection.EnvironmentHandle;

            int             valueLength = 0;
            OCI.INDICATOR   indicatorValue  = OCI.INDICATOR.OK;
            int             bufferLength;               
            
            OCI.DATATYPE    ociType = _bindingMetaType.OciType;
            
            HandleRef       indicatorLocation   = parameterBuffer.PtrOffset(_indicatorOffset);
            HandleRef       lengthLocation      = parameterBuffer.PtrOffset(_lengthOffset);
            HandleRef       valueLocation       = parameterBuffer.PtrOffset(_valueOffset);  

            if (IsDirection(Parameter, ParameterDirection.Input))
            {
                if (ADP.IsNull(_coercedValue))
                    indicatorValue = OCI.INDICATOR.ISNULL;
                else
                    valueLength = PutOracleValue(
                                            _coercedValue, 
                                            valueLocation, 
                                            _bindingMetaType, 
                                            connection);
            }
            else
            {
                Debug.Assert(IsDirection(Parameter, ParameterDirection.Output), "non-output output parameter?");

                if (_bindingMetaType.IsVariableLength)
                    valueLength = 0;                // Output-only values never have an input length...
                else
                    valueLength = _bufferLengthInBytes; // ...except when they're fixed length, to avoid ORA-01459 errors
                
                OciLobLocator.SafeDispose(ref _locator);
                OciHandle.SafeDispose(ref _descriptor);
                
                switch (ociType)
                {
                case OCI.DATATYPE.BFILE:
                case OCI.DATATYPE.BLOB:
                case OCI.DATATYPE.CLOB:
                    _locator = new OciLobLocator(connection, _bindingMetaType.OracleType);
                    break;

                case OCI.DATATYPE.RSET:
                    _descriptor = new OciStatementHandle(environmentHandle);
                    break;
                }

                if (null != _locator)
                {
                    Marshal.WriteIntPtr((IntPtr)valueLocation, (IntPtr)_locator.Handle);
                }
                else if (null != _descriptor)
                {
                    Marshal.WriteIntPtr((IntPtr)valueLocation, (IntPtr)_descriptor.Handle);
                }
            }

            Marshal.WriteInt16((IntPtr)indicatorLocation,   (Int16)indicatorValue);

            // Don't bind a length value for LONGVARCHAR or LONGVARRAW data, or you'll end
            // up with ORA-01098: program Interface error during Long Insert\nORA-01458: invalid length inside variable character string
            // errors.
            
            if (OCI.DATATYPE.LONGVARCHAR == ociType
             || OCI.DATATYPE.LONGVARRAW  == ociType)
                lengthLocation = ADP.NullHandleRef;
            else 
            {
                // When we're binding this parameter as UCS2, the length we specify
                // must be in characters, not in bytes.
                if (_bindAsUCS2)
                    Marshal.WriteInt32((IntPtr)lengthLocation,  (Int32)(valueLength/ADP.CharSize));
                else
                    Marshal.WriteInt32((IntPtr)lengthLocation,  (Int32)valueLength);
            }

            if (IsDirection(Parameter, ParameterDirection.Output))
                bufferLength = _bufferLengthInBytes;    
            else
                bufferLength = valueLength; 

            // Finally, tell Oracle about our parameter.
            
            int rc = TracedNativeMethods.OCIBindByName(
                                statementHandle,
                                out h,
                                errorHandle,
                                parameterName,
                                parameterName.Length,
                                valueLocation,
                                bufferLength,
                                ociType,
                                indicatorLocation,
                                lengthLocation,
                                ADP.NullHandleRef,
                                0,
                                ADP.NullHandleRef,
                                OCI.MODE.OCI_DEFAULT
                                );
                                
            if (rc != 0)
                _command.Connection.CheckError(errorHandle, rc);

            _bindHandle = new OciBindHandle(statementHandle, h);

#if TRACEPARAMETERVALUES
            if (null != _coercedValue) 
                SafeNativeMethods.OutputDebugStringW("Value = '" + _coercedValue.ToString() + "'\n");
#endif //TRACEPARAMETERVALUES

            // OK, character bindings have a few extra things we need to do to
            // deal with character sizes and alternate character sets.
            
            if (_bindingMetaType.IsCharacterType)
            {
                // To avoid problems when our buffer is larger than the maximum number
                // of characters, we use OCI_ATTR_MAXCHAR_SIZE to limit the number of
                // characters that will be used.  (Except on Oracle8i clients where it
                // isn't available)
                if (OCI.ClientVersionAtLeastOracle9i 
                        && IsDirection(Parameter, ParameterDirection.Output))
                    _bindHandle.SetAttribute(OCI.ATTR.OCI_ATTR_MAXCHAR_SIZE, (int)_bufferLength, errorHandle);

                if ((bufferLength > _bindingMetaType.MaxBindSize / ADP.CharSize)
                        || (!OCI.ClientVersionAtLeastOracle9i && _bindingMetaType.UsesNationalCharacterSet))    // need to specify MAXDATA_SIZE for OCI8 UCS2 bindings to work
                    _bindHandle.SetAttribute(OCI.ATTR.OCI_ATTR_MAXDATA_SIZE, (int)_bindingMetaType.MaxBindSize, errorHandle);
            
                // NOTE:    the order is important here; setting charsetForm will 
                //          reset charsetId (I found this out the hard way...)
                if (_bindingMetaType.UsesNationalCharacterSet)
                    _bindHandle.SetAttribute(OCI.ATTR.OCI_ATTR_CHARSET_FORM, (int)OCI.CHARSETFORM.SQLCS_NCHAR, errorHandle);

                // NOTE:    the order is important here; setting charsetForm will 
                //          reset charsetId (I found this out the hard way...)
                if (_bindAsUCS2)
                    _bindHandle.SetAttribute(OCI.ATTR.OCI_ATTR_CHARSET_ID, OCI.OCI_UCS2ID, errorHandle);
            }
        }
        
        internal object GetOutputValue( 
                NativeBuffer        parameterBuffer,
                OracleConnection    connection,         // connection, so we can create LOB values
                bool                needCLSType
                )
        {
            object result;
            //  Returns an object that contains the value of the column in the
            //  specified row buffer.  This method returns Oracle-typed objects.

            if (Marshal.ReadInt16((IntPtr)parameterBuffer.Ptr, _indicatorOffset) == (Int16)OCI.INDICATOR.ISNULL)
                return DBNull.Value;
                
            switch (_bindingMetaType.OciType)
            {
                case OCI.DATATYPE.FLOAT:
                case OCI.DATATYPE.INTEGER:
                case OCI.DATATYPE.UNSIGNEDINT:
                    result = Marshal.PtrToStructure((IntPtr)parameterBuffer.PtrOffset(_valueOffset), _bindingMetaType.BaseType);
                    return result;
                
                case OCI.DATATYPE.BFILE:
                    result = new OracleBFile(_locator);
                    return result;

                case OCI.DATATYPE.RAW:
                case OCI.DATATYPE.LONGRAW:
                case OCI.DATATYPE.LONGVARRAW:
                    result = new OracleBinary(parameterBuffer, _valueOffset, _lengthOffset, _bindingMetaType);
                    if (needCLSType)
                    {
                        object newresult = ((OracleBinary)result).Value;
                        result = newresult;
                    }
                    return result;

                case OCI.DATATYPE.RSET:
                    result = new OracleDataReader(connection, _descriptor);
                    return result;
                
                case OCI.DATATYPE.DATE:
                case OCI.DATATYPE.INT_TIMESTAMP:
                case OCI.DATATYPE.INT_TIMESTAMP_TZ:
                case OCI.DATATYPE.INT_TIMESTAMP_LTZ:
                    result = new OracleDateTime(parameterBuffer, _valueOffset, _bindingMetaType, connection);
                    if (needCLSType)
                    {
                        object newresult = ((OracleDateTime)result).Value;
                        result = newresult;
                    }
                    return result;

                case OCI.DATATYPE.BLOB:
                case OCI.DATATYPE.CLOB:
                    result = new OracleLob(_locator);
                    return result;
                    
                case OCI.DATATYPE.INT_INTERVAL_YM:
                    result = new OracleMonthSpan(parameterBuffer, _valueOffset);
                    if (needCLSType)
                    {
                        object newresult = ((OracleMonthSpan)result).Value;
                        result = newresult;
                    }
                    return result;
            
                case OCI.DATATYPE.VARNUM:
                    result = new OracleNumber(parameterBuffer, _valueOffset);
                    if (needCLSType)
                    {
                        object newresult = ((OracleNumber)result).Value;
                        result = newresult;
                    }
                    return result;

                case OCI.DATATYPE.CHAR:
                case OCI.DATATYPE.VARCHAR2:
                case OCI.DATATYPE.LONG:
                case OCI.DATATYPE.LONGVARCHAR:
                    result = new OracleString(parameterBuffer, 
                                            _valueOffset, 
                                            _lengthOffset, 
                                            _bindingMetaType, 
                                            connection, 
                                            _bindAsUCS2,
                                            true
                                            );
                    int size = _parameter.Size;
                    if (0 != size && size < ((OracleString)result).Length)
                    {
                        string truncatedResult = ((OracleString)result).Value.Substring(0,size);
                        if (needCLSType)
                            result = truncatedResult;
                        else
                            result = new OracleString(truncatedResult);
                    }
                    else if (needCLSType)
                    {
                        object newresult = ((OracleString)result).Value;
                        result = newresult;
                    }
                    return result;

                case OCI.DATATYPE.INT_INTERVAL_DS:
                    result = new OracleTimeSpan(parameterBuffer, _valueOffset);
                    if (needCLSType)
                    {
                        object newresult = ((OracleTimeSpan)result).Value;
                        result = newresult;
                    }
                    return result;

            }
            throw ADP.TypeNotSupported(_bindingMetaType.OciType);

        }

        internal void Dispose()
        {
            OciHandle.SafeDispose(ref _bindHandle);
        }

        static internal bool IsDirection(IDataParameter value, ParameterDirection condition)
        {
            return (condition == (condition & value.Direction));
        }

        internal void PostExecute( 
                NativeBuffer        parameterBuffer,
                OracleConnection    connection          // connection, so we can create LOB values
                )
        {
            OracleParameter parameter = Parameter;
            if (IsDirection(parameter, ParameterDirection.Output)
             || IsDirection(parameter, ParameterDirection.ReturnValue))
            {
                bool needCLSType = true;
                if (IsDirection(parameter, ParameterDirection.Input))
                {
                    object inputValue = parameter.Value;

                    if (inputValue is INullable)
                        needCLSType = false;
                }

                parameter.Value = GetOutputValue(parameterBuffer, connection, needCLSType);
            }
        }

        internal void PrepareForBind(
                        OracleConnection    connection,
                        ref int             offset
                        )
        {
            OracleParameter parameter = Parameter;

            // Don't bother with parameters where the user asks for the default value.
            if ( !IsDirection(parameter, ParameterDirection.Output) && null == parameter.Value)
            {
                _bufferLengthInBytes = 0;
                return; 
            }
            
            _bindingMetaType = parameter.GetMetaType();

            // We currently don't support binding a REF CURSOR as an input parameter; that
            // is for a future release.
            if (OCI.DATATYPE.RSET == _bindingMetaType.OciType && ParameterDirection.Output != parameter.Direction)
                throw ADP.InputRefCursorNotSupported(parameter.ParameterName);

            // Make sure we have a coerced value, if we haven't already done 
            // so, then save it.
            parameter.SetCoercedValue(_bindingMetaType.BaseType, _bindingMetaType.NoConvertType);
            _coercedValue = parameter.CoercedValue;

            // When they're binding a LOB type, but not providing a LOB object, 
            // we have to change the binding under the covers so we aren't forced
            // to create a temporary LOB.
            switch (_bindingMetaType.OciType)
            {
            case OCI.DATATYPE.BFILE:
            case OCI.DATATYPE.BLOB:
            case OCI.DATATYPE.CLOB:
                if (!ADP.IsNull(_coercedValue) && !(_coercedValue is OracleLob || _coercedValue is OracleBFile))
                    _bindingMetaType = MetaType.GetMetaTypeForType(_bindingMetaType.DbType);

                break;
            }

            // For fixed-width types, we take the bind size from the meta type
            // information; if it's zero, then the type must be variable width
            // (or it's an output parameter) and we require that they specify a
            // size.
            
            _bufferLength = _bindingMetaType.BindSize;

            if ((IsDirection(parameter, ParameterDirection.Output) 
                                && _bindingMetaType.IsVariableLength)   // they must specify a size for variable-length output parameters...
                || (0 == _bufferLength && !ADP.IsNull(_coercedValue))       // ...or if it's a non-null, variable-length input paramter...
                || (_bufferLength > short.MaxValue) )                       // ...or if the parameter type's maximum size is huge.
            {
                int size = parameter.BindSize;

                if (0 != size)
                    _bufferLength = size;

                if (0 == _bufferLength || MetaType.LongMax == _bufferLength)
                    throw ADP.ParameterSizeIsMissing(parameter.ParameterName, _bindingMetaType.BaseType);
            }

            _bufferLengthInBytes = _bufferLength;

            if (_bindingMetaType.IsCharacterType && connection.ServerVersionAtLeastOracle8)
            {
                _bindAsUCS2 = true;
                _bufferLengthInBytes *= ADP.CharSize;
            }
                
            // Anything with a length that exceeds what fits into a two-byte integer
            // requires special binding because the base types don't allow more than
            // 65535 bytes.  We change the binding under the covers to reflect the 
            // different type.
            
            if (!ADP.IsNull(_coercedValue)
                && _bufferLength > _bindingMetaType.MaxBindSize)
            {
                // DEVNOTE: it is perfectly fine to bind values less than 65535 bytes
                //          as long, so there's no problem with using the maximum number
                //          of bytes for each Unicode character above.
                
                switch (_bindingMetaType.OciType)
                {
                    case OCI.DATATYPE.CHAR:
                    case OCI.DATATYPE.LONG:
                    case OCI.DATATYPE.VARCHAR2:
                        _bindingMetaType = (_bindingMetaType.UsesNationalCharacterSet )
                                                ? MetaType.oracleTypeMetaType_LONGNVARCHAR
                                                : MetaType.oracleTypeMetaType_LONGVARCHAR;
                        break;

                    case OCI.DATATYPE.RAW:
                    case OCI.DATATYPE.LONGRAW:
                        _bindingMetaType = MetaType.oracleTypeMetaType_LONGVARRAW;
                        break;

                    default:
                        Debug.Assert(false, "invalid type for long binding!");  // this should never happen!
                        break;
                }
                
                // Long data requires a LONGVARCHAR or LONGVARRAW binding instead, which
                // mean we have to add another 4 bytes for the length.
                _bufferLengthInBytes += 4;  
            }

            if (0 > _bufferLengthInBytes)
                throw ADP.ParameterSizeIsTooLarge(parameter.ParameterName);

            // Fill in the buffer offsets. We lay out the buffer as follows:
            //
            //      indicator   0-3
            //      length      4-7
            //      data        8-...
            //
            _indicatorOffset    = offset;   offset += 4;
            _lengthOffset       = offset;   offset += 4;
            _valueOffset        = offset;   offset += _bufferLengthInBytes;

            offset = (offset + 3) & ~0x3;   // DWORD align, please.
            
        }

        internal int PutOracleValue(
                        object              value,
                        HandleRef           valueBuffer,
                        MetaType            metaType,
                        OracleConnection    connection
                        ) 
        {
            
            //  writes the managed object into the buffer in the appropriate
            //  native Oracle format.

            OCI.DATATYPE    ociType = metaType.OciType;
            int             dataSize;
            OracleParameter parameter = Parameter;
        
            switch (ociType)
            {
            case OCI.DATATYPE.FLOAT:
            case OCI.DATATYPE.INTEGER:
            case OCI.DATATYPE.UNSIGNEDINT:
                Marshal.StructureToPtr(value, (IntPtr)valueBuffer, false);
                dataSize = metaType.BindSize;
                break;
                
            case OCI.DATATYPE.RAW:
            case OCI.DATATYPE.LONGRAW:
            case OCI.DATATYPE.LONGVARRAW:
                dataSize = OracleBinary.MarshalToNative(value, parameter.Offset, parameter.Size, valueBuffer, ociType);
                break;

            case OCI.DATATYPE.DATE:
            case OCI.DATATYPE.INT_TIMESTAMP:
            case OCI.DATATYPE.INT_TIMESTAMP_TZ:
            case OCI.DATATYPE.INT_TIMESTAMP_LTZ:
                dataSize = OracleDateTime.MarshalToNative(value, valueBuffer, ociType);
                break;

            case OCI.DATATYPE.BFILE:
                // We cannot construct lobs; if you want to bind a lob, you have to have
                // a lob.
                if ( !(value is OracleBFile) )
                    throw ADP.BadBindValueType(value.GetType(), metaType.OracleType);

                Marshal.WriteIntPtr((IntPtr)valueBuffer, (IntPtr)((OracleBFile) value).Descriptor.Handle);
                dataSize = IntPtr.Size;
                break;

            case OCI.DATATYPE.BLOB:
            case OCI.DATATYPE.CLOB:
                // We cannot construct lobs; if you want to bind a lob, you have to have
                // a lob.
                if ( !(value is OracleLob) )
                    throw ADP.BadBindValueType(value.GetType(), metaType.OracleType);

                // If you don't disable the buffering, you'll cause the PL/SQL code that
                // uses this LOB to have problems doing things like DBMS_LOB.GET_LENGTH()
                ((OracleLob)value).EnsureBuffering(false);

                Marshal.WriteIntPtr((IntPtr)valueBuffer, (IntPtr)((OracleLob) value).Descriptor.Handle);
                dataSize = IntPtr.Size;
                break;

            case OCI.DATATYPE.INT_INTERVAL_YM:
                dataSize = OracleMonthSpan.MarshalToNative(value, valueBuffer);
                break;
                
            case OCI.DATATYPE.VARNUM:
                dataSize = OracleNumber.MarshalToNative(value, valueBuffer, connection);
                break;

            case OCI.DATATYPE.CHAR:
            case OCI.DATATYPE.VARCHAR2:
            case OCI.DATATYPE.LONG:
            case OCI.DATATYPE.LONGVARCHAR:
                dataSize = OracleString.MarshalToNative(value, parameter.Offset, parameter.Size, valueBuffer, ociType, _bindAsUCS2);
                break;
  
            case OCI.DATATYPE.INT_INTERVAL_DS:
                dataSize = OracleTimeSpan.MarshalToNative(value, valueBuffer);
                break;
                
            default:
                throw ADP.TypeNotSupported(ociType);
            }

            Debug.Assert(dataSize <= _bufferLengthInBytes, String.Format("Internal Error: Exceeded Internal Buffer.  DataSize={0} BufferLength={1}",dataSize,_bufferLengthInBytes));
            return dataSize;
        }
        
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracleinternalconnection.cs ===
//------------------------------------------------------------------------------
// <copyright file="OracleInternalConnection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OracleClient
{
    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.EnterpriseServices;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;  
    using System.Threading;
    
    sealed internal class OracleInternalConnection : DBPooledObject {

        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Fields 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        
        private OciHandle           _environmentHandle;         // OCI environment handle -- the root of all handles for this connection.
        private OciHandle           _errorHandle;               // OCI error handle -- every call needs one
        private OciHandle           _serviceContextHandle;      // OCI service context handle -- defines the connection and transaction.
        private OciHandle           _serverHandle;              // Not available in MTS transaction connection
        private OciHandle           _sessionHandle;             // Not available in MTS transaction connection
#if USEORAMTS
        private OciEnlistContext    _enlistContext;             // Only available in MTS transaction connection
#else //!USEORAMTS
        private IntPtr              _resourceManagerProxy;      // Only available in MTS transaction connection
#endif //!USEORAMTS
        
        private OracleConnectionString  _connectionOptions;     // parsed connection string attributes
        private bool                _checkLifetime;             // true when the connection is only to live for a specific timespan
        private TimeSpan            _lifetime;                  // the timespan the connection is to live for
        private DateTime            _createTime;                // when the connection was created.

        private int                 _lock = 0;                  // lock used for closing

        private bool                _connectionIsDoomed;        // true when the connection should no longer be used.
        private bool                _connectionIsOpen;

        private OracleConnection.TransactionState   _transactionState;          // our own transacted state
        
        private Guid                _transactionGuid = Guid.Empty;

        private long                _serverVersion;             // server version value,  eg: 0x0801050000
        private string              _serverVersionString;       // server version string, eg: "8.1.5.0.0 Oracle8i Enterprise Edition Release 8.1.5.0.0 - Production"
        
        
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Constructors 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////

        public OracleInternalConnection (
                OracleConnectionString connectionOptions,
                object                 transact)
        {
            _connectionOptions  = connectionOptions;
            Open(transact);
        }
        
        public OracleInternalConnection (
                OracleConnectionString connectionOptions,
                DBObjectPool pool,
                bool checkLifetime,
                TimeSpan lifetime) : base(pool)
        {
            _connectionOptions  = connectionOptions;
            _checkLifetime      = checkLifetime;
            _lifetime           = lifetime;

            Open(null);

            // obtain the time of construction, if checkLifetime is requested
            if (_checkLifetime)
                _createTime = DateTime.Now;
        }

#if !USEORAMTS
        ~OracleInternalConnection()
        {
            // Make sure we release the resource manager proxy, even if 
            // we weren't closed/disposed.
            if (IntPtr.Zero != _resourceManagerProxy)
            {
                Marshal.Release(_resourceManagerProxy);
                _resourceManagerProxy = IntPtr.Zero;
            }
        }
#endif //!USEORAMTS

        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Properties 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////

        internal OciHandle EnvironmentHandle
        {
            //  Every handle is allocated from the environment handle in some way,
            //  so we have to provide access to it internally.
            get { return _environmentHandle; }
        }

        internal OciHandle ErrorHandle 
        {
            //  Every OCI call needs an error handle, so make it available 
            //  internally.
            get { return _errorHandle; }
        }

        internal OciHandle ServiceContextHandle
        {
            //  You need to provide the service context handle to things like the
            //  OCI execute call so a statement handle can be associated with a
            //  connection.  Better make it available internally, then.
            get { return _serviceContextHandle; }
        }

        internal OciHandle SessionHandle
        {
            //  You need to provide the session handle to a few OCI calls.  Better 
            //  make it available internally, then.
            get { return _sessionHandle; }
        }

        internal string ServerVersion 
        {
            get 
            {
                if (null == _serverVersionString)
                {
                    string  result = "no version available";
                    NativeBuffer    buffer = null;

                    try 
                    {
                        buffer = new NativeBuffer_ServerVersion(500);

                        int rc = TracedNativeMethods.OCIServerVersion(
                                            ServiceContextHandle,       // hndlp
                                            ErrorHandle,                // errhp
                                            buffer.Ptr,                 // bufp
                                            buffer.Length,              // bufsz
                                            OCI.HTYPE.OCI_HTYPE_SVCCTX  // hndltype
                                            );

                        if (0 != rc)
                            throw ADP.OracleError(ErrorHandle, rc, buffer); 
                        
                        if (0 == rc) // in case it was a warning message.
                            result = ServiceContextHandle.PtrToString((IntPtr)buffer.Ptr);
                            
                        _serverVersion      = ParseServerVersion(result);
                        _serverVersionString= String.Format("{0}.{1}.{2}.{3}.{4} {5}", 
                                                    (_serverVersion >> 32) & 0xff,
                                                    (_serverVersion >> 24) & 0xff,
                                                    (_serverVersion >> 16) & 0xff,
                                                    (_serverVersion >> 8)  & 0xff,
                                                    _serverVersion         & 0xff,
                                                    result
                                                    );
                    }
                    finally 
                    {
                        if (null != buffer)
                        {
                            buffer.Dispose();
                            buffer = null;
                        }
                    }
                }
                return _serverVersionString;
            }
        }

        internal long ServerVersionNumber
        {
            get 
            {
                if (0 == _serverVersion)
                {
                    string temp = ServerVersion;    // force the serverversion value to be created
                }
                return _serverVersion;
            }
        }

        internal OracleConnection.TransactionState TransState
        {
            //  In oracle, the session object controls the transaction so we keep
            //  the transaction state here as well.
            get { return _transactionState; }
            set { _transactionState = value; }
        }


        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Methods 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////

        public override void Activate()
        {
            // perform any initialization that should be done when the connection is pulled 
            // from the pool.
#if USEORAMTS
            if (_connectionOptions.Enlist)
                ActivateForDistributedTransaction();
#endif //USEORAMTS
        }

#if USEORAMTS
        private void ActivateForDistributedTransaction()
        {
            // When activating a connection, ensure that we are enlisted in the correct
            // transaction (if automatic enlistment is requested) or ensure that we're
            // unenlisted when there isn't currently a transaction.
            if (ContextUtil.IsInTransaction)
            {
                Guid         transactionGuid = Guid.Empty;
                ITransaction transaction = GetTransaction(out transactionGuid);
                
                if (transactionGuid != _transactionGuid)
                    Enlist(_connectionOptions.UserId, _connectionOptions.Password, _connectionOptions.DataSource, transaction, transactionGuid);
            }
            else
                UnEnlist();
        }
#endif //USEORAMTS
        
        public override bool CanBePooled()
        {
            return 0 == _lock && _connectionIsOpen && !_connectionIsDoomed;
        }
        
        public bool CheckLifetime()
        {
            // Returns whether or not this object's lifetime has had expired.
            // True means the object is still good, false if it has timed out.
            
            // obtain current time
            DateTime now = DateTime.Now;

            // obtain timespan
            TimeSpan timeSpan = now.Subtract(_createTime);

            // compare timeSpan with lifetime, if equal or less,
            // designate this object to be killed
            if (TimeSpan.Compare(_lifetime, timeSpan) > 0) 
                return true;
            
            _connectionIsDoomed = true;
            return false;
        }
        public override void Cleanup()
        {
            try 
            {
                if (OracleConnection.TransactionState.LocalStarted == _transactionState)
                    Rollback();
            }
            catch (Exception e)
            {
                ADP.TraceException(e);
                _connectionIsDoomed = true;  // if we can't rollback, then this connection is busted.
            }
        }

        public override void Close()
        {
            // this method will actually close the internal connection and dispose it, this
            // should only be called by a non-pooled OracleConnection, or by the object pooler
            // when it deems an object should be destroyed

            // Distributed Transactions just go out of scope because when the transaction
            // is destroyed they will automatically get cleaned up.
            if (OracleConnection.TransactionState.GlobalStarted != _transactionState)
            {
                // it's possible to have a connection finalizer, internal connection finalizer,
                // and the object pool destructor calling this method at the same time, so
                // we need to provide some synchronization
                if (_connectionIsOpen) 
                {
                    if (Interlocked.CompareExchange(ref _lock, 1, 0) == 0) 
                    {
                        if (_connectionIsOpen) 
                        {
                            _connectionIsOpen = false;
                            try 
                            {
                                try {} finally
                                {
                                    int rc;

                                    // TODO: figure out if we really need to have OCISessionEnd and OCIServerDetach in the finally block, or if disposing the handle is good enough.  (What happens to the session if it isn't ended before it's disposed?)

#if USEORAMTS
                                    UnEnlist();
#else //!USEORAMTS
                                    if (IntPtr.Zero != _resourceManagerProxy)
                                    {
                                        Marshal.Release(_resourceManagerProxy);
                                        _resourceManagerProxy = IntPtr.Zero;
                                    }
#endif //!USEORAMTS

                                    if ((null != _sessionHandle) && _sessionHandle.IsAlive)
                                    {
                                        rc = TracedNativeMethods.OCISessionEnd(
                                                                    _serviceContextHandle,  // svchp
                                                                    _errorHandle,           // errhp
                                                                    _sessionHandle,         // usrhp
                                                                    OCI.MODE.OCI_DEFAULT    // mode
                                                                    );
                                                
                                        if (0 != rc)
                                        {
                                            // We don't really want to throw here, because if we do, we might be dorking
                                            // with a finalizer.  Instead, just write some debug output -- we shouldn't 
                                            // fail from these calls anyway.
                                            Debug.WriteLine(String.Format("OracleClient: OCISessionEnd(0x{0,-8:x} failed: rc={1:d}", _sessionHandle.Handle, rc));
                                            Debug.Assert(false, "OCISessionEnd failed");
                                        }
                                    }

                                    OciHandle.SafeDispose(ref _serviceContextHandle);
                                    OciHandle.SafeDispose(ref _sessionHandle);
                                    OciHandle.SafeDispose(ref _serverHandle);
                                    OciHandle.SafeDispose(ref _errorHandle);
                                    OciHandle.SafeDispose(ref _environmentHandle);
                                }
                            }
                            catch // Prevent exception filters from running in our space
                            {
                                throw;
                            }
                        }
                    }
                }
            }
#if !USEORAMTS
            GC.KeepAlive(this);
            GC.SuppressFinalize(this);
#endif //!USEORAMTS
        }

        internal void Commit()
        {
            //  Commits the current local transaction; called by the transaction
            //  object, because Oracle doesn't have a specific transaction object, 
            //  but combines the transaction into the service context.
            
            int rc = TracedNativeMethods.OCITransCommit(
                                        ServiceContextHandle,
                                        ErrorHandle,
                                        OCI.MODE.OCI_DEFAULT
                                        );
                    
            if (0 != rc)
                OracleException.Check(ErrorHandle, rc);

            // Once we complete the transaction, we're supposed to go back to 
            // autocommit mode.
            _transactionState = OracleConnection.TransactionState.AutoCommit;
        }
        
        public override bool Deactivate()
        {
            // Called when the connection is about to be placed back into the pool; this 
            // method returns true when the connection is for a distributed transaction.
            
            if (!_connectionIsDoomed && _checkLifetime) 
            {
                // check lifetime here - as a side effect it will doom connection if 
                // it's lifetime has elapsed
                CheckLifetime();
            }

#if USEORAMTS
            if (null != _enlistContext)
                return true;
#else //!USEORAMTS
            // TODO: Decide whether we should pool distributed transaction connections; they are per-transaction-only.
            if (IntPtr.Zero != _resourceManagerProxy)
            {
                _connectionIsDoomed = true;
                GC.KeepAlive(this);
                return true;
            }
#endif //!USEORAMTS
            return false;
        }
        
        internal void DoomThisConnection()
        {
            _connectionIsDoomed = true;
        }
        
#if USEORAMTS
        private void Enlist(
                string          userName,
                string          password,
                string          serverName,
                ITransaction    transaction,
                Guid            transactionGuid
                )
        {
            // No matter what happened before, we need to reset this connection 
            // to an unenlisted state.
            UnEnlist();

            // Oracle only implemented OraMTS for 9i.
            if (!OCI.ClientVersionAtLeastOracle9i)
                throw ADP.DistribTxRequiresOracle9i();
            
#if ALLOWTRACING
            ADP.TraceObjectPoolActivity("Enlist", this, transactionGuid);
#endif //ALLOWTRACING
            
            _enlistContext = new OciEnlistContext(userName, password, serverName, ServiceContextHandle, ErrorHandle);
            _enlistContext.Join(transaction);

            _transactionGuid = transactionGuid;
            _transactionState = OracleConnection.TransactionState.GlobalStarted;
        }
#endif //USEORAMTS
        
        private static ITransaction GetTransaction(out Guid transactionGuid)
        {
            ITransaction transact = null;
            
            try 
            {
                (new SecurityPermission(SecurityPermissionFlag.UnmanagedCode)).Assert(); // MDAC 62028
                try 
                { 
                    transact = (ITransaction)ContextUtil.Transaction;
                    transactionGuid = ContextUtil.TransactionId;
                }
                finally 
                {
                    CodeAccessPermission.RevertAssert();
                }
            }
            catch // Prevent exception filters from running in our space
            {
                throw;
            }
            return transact;
        }
        
        private bool Open(object transact)
        {
            //  We test for the presence of a distributed transaction in a function
            //  that is only called when the Enlist connection string attribute is
            //  false, so we can avoid the overhead of loading enterpriseservices
            //  stuff for local-only transactions.

            // Get local copies of various components from the hash table.
            string  userName            = _connectionOptions.UserId;
#if USECRYPTO
            string  passwordEncrypted   = _connectionOptions.Password;
            byte[] password = null;
#else
            string  password            = _connectionOptions.Password;
#endif
            string  serverName          = _connectionOptions.DataSource;
            bool    integratedSecurity  = _connectionOptions.IntegratedSecurity;
            bool    unicode             = _connectionOptions.Unicode;

#if USECRYPTO
            try
            {
                try
                {
                    if (!ADP.IsEmpty(passwordEncrypted))
                        password = Crypto.DecryptString(passwordEncrypted);
#endif                  
                    _connectionIsOpen = false;

                    if (_connectionOptions.Enlist || null != transact)
                        _connectionIsOpen = OpenOnGlobalTransacton (userName, password, serverName, integratedSecurity, unicode, transact);

                    if (!_connectionIsOpen && null == transact)         
                        _connectionIsOpen = OpenOnLocalTransaction (userName, password, serverName, integratedSecurity, unicode);
#if USECRYPTO
                }
                finally
                {
                    ADP.ClearArray(ref password);       // Don't leave sensitive things in memory
                }
            }
            catch // Prevent exception filters from running in our space
            {
                throw;
            }
#endif                  
            return _connectionIsOpen;
        }

        private bool OpenOnGlobalTransacton(
                string       userName,
#if USECRYPTO
                byte[]       password,
#else
                string       password,
#endif
                string       serverName,
                bool         integratedSecurity,
                bool         unicode,
                object       transactObject
                ) 
        {
            ITransaction transact;
            Guid         transactionGuid = Guid.Empty;
            
            if (null == transactObject)
            {
                if (!ContextUtil.IsInTransaction)
                    return false;

                transact = GetTransaction(out transactionGuid);
            }
            else 
                transact = (ITransaction)transactObject;
#if USEORAMTS           
            _connectionIsOpen = OpenOnLocalTransaction (userName, password, serverName, integratedSecurity, unicode);

            if (_connectionIsOpen)
                Enlist(userName, password, serverName, transact, transactionGuid);
#else //!USEORAMTS
            if (integratedSecurity)
                return false;    // Oracle doesn't support integrated security through XA; at least they don't document how to do it...

            // Because we can't replace all the old copies of MTxOCI out there that will
            // hose us (or that we will hose), we're requiring that you install a new version
            // of it before you can use distributed transactions.

            if (!OCI.IsNewMtxOciInstalled || !OCI.IsNewMtxOci8Installed)
#if EVERETT
                throw ADP.MustInstallNewMtxOciDistribTx();
#else //!EVERETT
                throw ADP.MustInstallNewMtxOci();
#endif //!EVERETT
            
            // We need to handle the connection differently when we're in a Distributed 
            // Transaction.  We have to enlist in an XA transaction and ask it for the 
            // Environment and ServiceContext handles it's using, instead of just creating
            // new ones.

            IntPtr  environmentHandle;
            IntPtr  serviceContextHandle;
            int     rc;

            rc = TracedNativeMethods.MTxOciConnectToResourceManager(
                                                userName,
                                                password,
                                                serverName,
                                                out _resourceManagerProxy
                                                );
            if (0 != rc)
                throw ADP.CouldNotAttachToTransaction("MTxOciConnectToResourceManager", rc);

            rc = TracedNativeMethods.MTxOciEnlistInTransaction(
                                                _resourceManagerProxy,
                                                transact,
                                                out environmentHandle,
                                                out serviceContextHandle
                                                );
            if (0 != rc)
                throw ADP.CouldNotAttachToTransaction("MTxOciEnlistInTransaction", rc);

            Debug.Assert(environmentHandle      != IntPtr.Zero, "environmentHandle is null!");
            Debug.Assert(serviceContextHandle   != IntPtr.Zero, "serviceContextHandle is null!");

            _environmentHandle      = new OciEnvironmentHandle(environmentHandle, false, true); // Oracle doesn't document how to specify that handles for DTC transactions be Unicode enabled...
            _serviceContextHandle   = new OciServiceContextHandle(_environmentHandle, serviceContextHandle, true);
            _errorHandle            = _environmentHandle.CreateOciHandle(OCI.HTYPE.OCI_HTYPE_ERROR);                
            
            _transactionState = OracleConnection.TransactionState.GlobalStarted;
            GC.KeepAlive(this);
#endif //!USEORAMTS
            return true;
        }

        private bool OpenOnLocalTransaction(
                string  userName,
#if USECRYPTO
                byte[]  password,
#else
                string  password,
#endif
                string  serverName,
                bool    integratedSecurity,
                bool    unicode
                ) 
        {
            //  This method attempts to perform a local connection that may not
            //  be enlisted in a distributed transaction.  It only returns true
            //  when the connection is successful.
            
            int         rc = 0;
            OCI.CRED    authMode;
            
            
            // Create an OCI environmentHandle handle

//          bool        unicode = false;
            IntPtr      environmentHandle = IntPtr.Zero;
            OCI.MODE    environmentMode = (OCI.MODE.OCI_THREADED | OCI.MODE.OCI_OBJECT);    // Bug 79521 - removing OCI.MODE.OCI_NO_MUTEX to verify 

            if (unicode)
            {
                if (OCI.ClientVersionAtLeastOracle9i)
                    environmentMode |= OCI.MODE.OCI_UTF16;
                else
                    unicode = false;
                    
            }
            rc = TracedNativeMethods.OCIEnvCreate(
                                    out environmentHandle,  // envhpp
                                    environmentMode,        // mode
                                    ADP.NullHandleRef,      // ctxp
                                    ADP.NullHandleRef,      // malocfp
                                    ADP.NullHandleRef,      // ralocfp
                                    ADP.NullHandleRef,      // mfreefp
                                    0,                      // xtramemsz
                                    ADP.NullHandleRef       // usrmempp
                                    );

            if (0 != rc)
                throw ADP.CouldNotCreateEnvironment(rc);

            Debug.Assert(environmentHandle != IntPtr.Zero, "environmentHandle is null!");

            // Now create a bunch of other handles, and attach to the server

            _environmentHandle      = new OciEnvironmentHandle(environmentHandle, unicode);
            _errorHandle            = _environmentHandle.CreateOciHandle(OCI.HTYPE.OCI_HTYPE_ERROR);                
            _serverHandle           = _environmentHandle.CreateOciHandle(OCI.HTYPE.OCI_HTYPE_SERVER);

            ((OciEnvironmentHandle)_environmentHandle).SetExtraInfo((OciErrorHandle)_errorHandle, (OciServerHandle)_serverHandle);
            
            _serviceContextHandle   = _environmentHandle.CreateOciHandle(OCI.HTYPE.OCI_HTYPE_SVCCTX);               
            _sessionHandle          = _environmentHandle.CreateOciHandle(OCI.HTYPE.OCI_HTYPE_SESSION);

            rc = TracedNativeMethods.OCIServerAttach(
                                    _serverHandle,          // srvhp
                                    _errorHandle,           // errhp
                                    serverName,             // dblink
                                    serverName.Length,      // dblink_len
                                    OCI.MODE.OCI_DEFAULT    // mode
                                    );
                
            if (0 != rc)
                OracleException.Check(ErrorHandle, rc);

            _serviceContextHandle.SetAttribute(OCI.ATTR.OCI_ATTR_SERVER, _serverHandle, _errorHandle);

            if (integratedSecurity)
            {
                authMode = OCI.CRED.OCI_CRED_EXT;
            }
            else
            {
                authMode = OCI.CRED.OCI_CRED_RDBMS;
                _sessionHandle.SetAttribute(OCI.ATTR.OCI_ATTR_USERNAME, userName, _errorHandle);

                if (null != password)
                    _sessionHandle.SetAttribute(OCI.ATTR.OCI_ATTR_PASSWORD, password, _errorHandle);                    
            }

#if USEORAMTS
            _serverHandle.SetAttribute(OCI.ATTR.OCI_ATTR_EXTERNAL_NAME, serverName, _errorHandle);
            _serverHandle.SetAttribute(OCI.ATTR.OCI_ATTR_INTERNAL_NAME, serverName, _errorHandle);
#endif //USEORAMTS

            rc = TracedNativeMethods.OCISessionBegin(
                                    _serviceContextHandle,  // svchp
                                    _errorHandle,           // errhp
                                    _sessionHandle,         // usrhp
                                    authMode,               // credt
                                    OCI.MODE.OCI_DEFAULT    // mode
                                    );
                
            if (0 != rc)
                OracleException.Check(ErrorHandle, rc);

            _serviceContextHandle.SetAttribute(OCI.ATTR.OCI_ATTR_SESSION, _sessionHandle, _errorHandle);
            return true;
        }
        
        
        // transistion states used for parsing
        internal enum PARSERSTATE
        {
            NOTHINGYET=1,   //start point
            PERIOD,         
            DIGIT,
        };
            
        static internal long ParseServerVersion (string versionString)
        {
            //  parse the native version string returned from the server and returns
            //  a 64 bit integer value that represents it.  For example, Oracle's
            //  version strings typically look like:
            //
            //      Oracle8i Enterprise Edition Release 8.1.5.0.0 - Production
            //
            //  this method will take the 8.1.5.0.0 and return 0x0801050000, using
            //  8 bits for each dot found.
            
            PARSERSTATE     parserState = PARSERSTATE.NOTHINGYET;
            int             current;
            int             start = 0;
            int             periodCount = 0;
            long            version = 0;

            // make sure we have 4 periods, at the end of the string to force
            // the state machine to have the correct number of periods.
            versionString = String.Concat(versionString, "0.0.0.0.0 ");

            //Console.WriteLine(versionString);

            for (current = 0; current < versionString.Length; current++)
            {
                //Console.WriteLine(String.Format("versionString[{0}]={1} version=0x{2:x10} periodCount={3} parserState={4}", current, versionString.Substring(current,1), version, periodCount, parserState.ToString(CultureInfo.CurrentCulture) ));

                switch(parserState)
                {
                case PARSERSTATE.NOTHINGYET:
                    if (Char.IsDigit(versionString, current))
                    {
                        parserState = PARSERSTATE.DIGIT;
                        start = current;
                    }
                    break;

                case PARSERSTATE.PERIOD:
                    if (Char.IsDigit(versionString, current))
                    {
                        parserState = PARSERSTATE.DIGIT;
                        start = current;
                    }
                    else
                    {
                        parserState = PARSERSTATE.NOTHINGYET;
                        periodCount = 0;
                        version = 0;
                    }
                    break;

                case PARSERSTATE.DIGIT:
                    if ("." == versionString.Substring(current,1) || 4 == periodCount)
                    {
                        periodCount++;
                        parserState = PARSERSTATE.PERIOD;
                        
                        long versionPart = (long)Int32.Parse(versionString.Substring(start,current-start));

                        Debug.Assert(versionPart >= 0 && versionPart < 256, "version part out of range!");
                    
                        version = (version << 8) + versionPart;
                        if (5 == periodCount)
                        {
                            return version;
                        }
                    }
                    else if (!Char.IsDigit(versionString, current))
                    {
                        parserState = PARSERSTATE.NOTHINGYET;
                        periodCount = 0;
                        version =0;
                    }
                    break;

                default:
                    Debug.Assert (false, "no state defined!!!!we should never be here!!!");
                    break;
                }
            }

            Debug.Assert (false, "didn't find a complete version number in the string");
            return 0;
        }

        internal void Rollback()
        {
            //  Rolls back the current local transaction; called by the transaction
            //  object, because Oracle doesn't have a specific transaction object, 
            //  but combines the transaction into the service context.
            
            if (OracleConnection.TransactionState.GlobalStarted != _transactionState
                && _connectionIsOpen)
            {
                int rc = TracedNativeMethods.OCITransRollback(
                                            ServiceContextHandle,
                                            ErrorHandle,
                                            OCI.MODE.OCI_DEFAULT
                                            );
                        
                if (0 != rc)
                    OracleException.Check(ErrorHandle, rc);

                // Once we complete the transaction, we're supposed to go back to 
                // autocommit mode.
                _transactionState = OracleConnection.TransactionState.AutoCommit;
            }
        }

#if USEORAMTS
        private void UnEnlist()
        {
            if (null != _enlistContext)
            {
#if ALLOWTRACING
                ADP.TraceObjectPoolActivity("UnEnlist", this);
#endif //ALLOWTRACING
                
                _transactionState = OracleConnection.TransactionState.AutoCommit;
                _transactionGuid = Guid.Empty;

                _enlistContext.Join(null);

                OciEnlistContext.SafeDispose(ref _enlistContext);
            }
        }
#endif //USEORAMTS              

#if NEVER
        private string              _nlsCharacterSet;
        private string              _nlsNCharCharacterSet;

        internal string CharacterSet 
        {
            get 
            {
                if (null == _nlsCharacterSet)
                    GetCharsetInfo();

                return _nlsCharacterSet;
            }
        }

        internal string NCharCharacterSet 
        {
            get 
            {
                if (null == _nlsNCharCharacterSet)
                    GetCharsetInfo();

                return _nlsNCharCharacterSet;
            }
        }

        internal void GetCharsetInfo()
        {
            //  Called to get the charset info from the server so we can tell what the primary
            //  and national character sets are.  We can't use UCS2 binding for parameters if
            //  the character set for that character set form doesn't allow it.
            _nlsCharacterSet = null;
            _nlsNCharCharacterSet = null;

            if (!ServerVersionAtLeastOracle8)   // prior to Oracle8, there was only one character set: ANSI
                return;
                        
            OciHandle   statementHandle = EnvironmentHandle.CreateOciHandle(OCI.HTYPE.OCI_HTYPE_STMT);
            OciHandle   errorHandle     = ErrorHandle;
            byte[]      statementText   = System.Text.Encoding.Default.GetBytes("select value from nls_database_parameters where parameter = 'NLS_CHARACTERSET' or parameter = 'NLS_NCHAR_CHARACTERSET' order by parameter");
            int         rc;

            rc = TracedNativeMethods.OCIStmtPrepare(
                                    statementHandle, 
                                    errorHandle, 
                                    statementText, 
                                    statementText.Length, 
                                    OCI.SYNTAX.OCI_NTV_SYNTAX,
                                    OCI.MODE.OCI_DEFAULT
                                    );
            
                    
            if (0 != rc)
                return;     // shouldn't fail, so we just treat this as "I don't know"

            rc = TracedNativeMethods.OCIStmtExecute(
                                    ServiceContextHandle,
                                    statementHandle,
                                    errorHandle,
                                    0,                          // iters
                                    0,                          // rowoff
                                    IntPtr.Zero,                // snap_in
                                    IntPtr.Zero,                // snap_out
                                    OCI.MODE.OCI_DEFAULT        // mode
                                    );
                
            if (0 != rc)
                return;     // shouldn't fail, so we just treat this as "I don't know"

            int             rowBufferLength         = 38;
            NativeBuffer    rowBuffer               = new NativeBuffer(rowBufferLength);
            rowBuffer.NumberOfRows = 2;

            IntPtr          charsetDefineHandle;
            IntPtr          charsetIndicator    = rowBuffer.PtrOffset(0);
            IntPtr          charsetLength       = rowBuffer.PtrOffset(4);
            IntPtr          charsetValue        = rowBuffer.PtrOffset(8);

            rc = TracedNativeMethods.OCIDefineByPos(
                                        statementHandle.Handle,     // hndlp
                                        out charsetDefineHandle,    // defnpp
                                        errorHandle.Handle,         // errhp
                                        1,                          // position
                                        charsetValue,               // valuep
                                        30,                         // value_sz
                                        OCI.DATATYPE.VARCHAR2,      // htype
                                        charsetIndicator,           // indp,
                                        charsetLength,              // rlenp,
                                        IntPtr.Zero,                // rcodep,
                                        OCI.MODE.OCI_DEFAULT        // mode
                                        );
            
            if (0 != rc)
                return;     // shouldn't fail, so we just treat this as "I don't know"

            rc = TracedNativeMethods.OCIDefineArrayOfStruct(
                                        charsetDefineHandle,
                                        errorHandle.Handle,
                                        rowBufferLength,
                                        rowBufferLength,
                                        rowBufferLength,
                                        rowBufferLength
                                        );
            
            if (0 != rc)
                return;     // shouldn't fail, so we just treat this as "I don't know"

            rc = TracedNativeMethods.OCIStmtFetch(
                                    statementHandle,            // stmtp
                                    errorHandle,                // errhp
                                    2,                          // crows
                                    OCI.FETCH.OCI_FETCH_NEXT,   // orientation
                                    OCI.MODE.OCI_DEFAULT        // mode
                                    );

            if (0 != rc)
                return;     // shouldn't fail, so we just treat this as "I don't know"
            
            rowBuffer.MoveFirst();
            charsetIndicator    = rowBuffer.PtrOffset(0);
            charsetLength       = rowBuffer.PtrOffset(4);
            charsetValue        = rowBuffer.PtrOffset(8);

            _nlsCharacterSet    = OCI.PtrToString(charsetValue, Marshal.ReadInt16(charsetLength));
            
            rowBuffer.MoveNext();
            charsetIndicator    = rowBuffer.PtrOffset(0);
            charsetLength       = rowBuffer.PtrOffset(4);
            charsetValue        = rowBuffer.PtrOffset(8);

            _nlsNCharCharacterSet = OCI.PtrToString(charsetValue, Marshal.ReadInt16(charsetLength));
        }
#endif //NEVER
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oraclepermissionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="OraclePermissionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OracleClient {

    using System.Diagnostics;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\OraclePermissionAttribute.uex' path='docs/doc[@for="OraclePermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.Method | AttributeTargets.Constructor | AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false )]
	[Serializable()]
    sealed public class OraclePermissionAttribute : CodeAccessSecurityAttribute {
        private bool _allowBlankPassword;// = false;
        private string _connectionString;// = ADP.StrEmpty;
        private string _restrictions;// = ADP.StrEmpty;
        private KeyRestrictionBehavior _behavior;// = KeyRestrictionBehavior.AllowOnly;

        /// <include file='doc\OraclePermissionAttribute.uex' path='docs/doc[@for="OraclePermissionAttribute.OraclePermissionAttribute"]/*' />
        public OraclePermissionAttribute(SecurityAction action) : base(action) {
        }

        /// <include file='doc\OraclePermissionAttribute.uex' path='docs/doc[@for="OraclePermissionAttribute.AllowBlankPassword"]/*' />
        public bool AllowBlankPassword {
            get {
                return _allowBlankPassword;
            }
            set {
                _allowBlankPassword = value;
            }
        }

        /// <include file='doc\OraclePermissionAttribute.uex' path='docs/doc[@for="OraclePermissionAttribute.ConnectionString"]/*' />
        /// <internalonly />
        internal string ConnectionString {
            get {
                string value = _connectionString;
                return (null != value) ? value : ADP.StrEmpty;
            }
            set {
                _connectionString = value;
            }
        }

        /// <include file='doc\OraclePermissionAttribute.uex' path='docs/doc[@for="OraclePermissionAttribute.KeyRestrictionBehavior"]/*' />
        /// <internalonly />
        internal KeyRestrictionBehavior KeyRestrictionBehavior { // default AllowOnly
            get {
                return _behavior;
            }
            set {
                switch(value) {
                case KeyRestrictionBehavior.PreventUsage:
                case KeyRestrictionBehavior.AllowOnly:
                    _behavior = value;
                    break;
                default:
                    throw ADP.Argument("value");
                }
            }
        }

        /// <include file='doc\OraclePermissionAttribute.uex' path='docs/doc[@for="OraclePermissionAttribute.KeyRestrictions"]/*' />
        /// <internalonly />
        internal string KeyRestrictions {
            get {
                string value = _restrictions;
                return (null != value) ? value : ADP.StrEmpty;
            }
            set {
                _restrictions = value;
            }
        }
        
        /// <include file='doc\OraclePermissionAttribute.uex' path='docs/doc[@for="OraclePermissionAttribute.CreatePermission"]/*' />
        override public IPermission CreatePermission() {
            return new OraclePermission(this);
        }
    }

    /// <include file='doc\OraclePermissionAttribute.uex' path='docs/doc[@for="KeyRestrictionBehavior"]/*' />
    /// <internalonly />
    internal enum KeyRestrictionBehavior {

        /// <include file='doc\OraclePermissionAttribute.uex' path='docs/doc[@for="KeyRestrictionBehavior.AllowOnly"]/*' />
        AllowOnly = 0,

        /// <include file='doc\OraclePermissionAttribute.uex' path='docs/doc[@for="KeyRestrictionBehavior.PreventUsage"]/*' />
        PreventUsage = 1,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracleparametercollection.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleParameterCollection.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Collections;
	using System.ComponentModel;
	using System.Data;
	using System.Diagnostics;
	using System.Globalization;
	using System.Runtime.InteropServices;

	//----------------------------------------------------------------------
	// OracleParameterCollection
	//
    /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection"]/*' />
    [
#if EVERETT
    Editor("Microsoft.VSDesigner.Data.Design.DBParametersEditor, " + AssemblyRef.MicrosoftVSDesigner, typeof(System.Drawing.Design.UITypeEditor)),
#endif //EVERETT
    ListBindable(false)
    ]
	sealed public class OracleParameterCollection : MarshalByRefObject, ICollection, IDataParameterCollection, IEnumerable, IList
	{

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Fields 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
		private ArrayList	_items;		// the collection of parameters
		

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.Count"]/*' />
		public int Count
		{
			get
			{ 
				if (null == _items)
					return 0;

				return _items.Count;
			}
		}

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.IsFixedSize"]/*' />
		public bool IsFixedSize
		{
			get { return false; }
		}

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.IsReadOnly"]/*' />
		public bool IsReadOnly
		{
			get { return false; }
		}

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.IsSynchronized"]/*' />
		public bool IsSynchronized
		{
			get { return false; }
		}

		object IDataParameterCollection.this[string index]
		{
            get { return this[index]; }
            set { this[index] = (OracleParameter)value; }
		}

		object IList.this[int index]
		{
            get { return this[index]; }
            set { this[index] = (OracleParameter)value; }
		}

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.Item1"]/*' />
		public OracleParameter this[int index]
		{
            get 
            {
                RangeCheck(index);
                return (OracleParameter)_items[index];
            }
            set
            {
                RangeCheck(index);
                Replace(index, value);
            }
		}
   
        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.Item2"]/*' />
		public OracleParameter this[string parameterName]
		{
            get
            {
                int index = RangeCheck(parameterName);
                return (OracleParameter)_items[index];
            }

            set
            {
                int index = RangeCheck(parameterName);
                Replace(index, value);
            }
		}

		private Type ItemType
		{
            get { return typeof(OracleParameter); }
        }

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.SyncRoot"]/*' />
		public object SyncRoot
		{
			get { return this; }
		}


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.Add1"]/*' />
		public int Add(object value) 
		{
			ValidateType(value);
			Add((OracleParameter)value);
			return Count-1;
		}

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.Add2"]/*' />
		public OracleParameter Add(OracleParameter value) 
		{
			Validate(-1, value);
#if EVERETT
            value.Parent = this;
#endif //EVERETT
            ArrayList().Add(value);
            return value;
		}
		
        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.Add3"]/*' />
		public OracleParameter Add (
					String parameterName,
					Object value
					)
		{
			OracleParameter p = new OracleParameter(parameterName, value);
			return Add(p);
		}

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.Add4"]/*' />
		public OracleParameter Add (
					String parameterName, 
					OracleType dataType
					)
		{
			OracleParameter p = new OracleParameter(parameterName, dataType);
			return Add(p);
		}

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.Add5"]/*' />
		public OracleParameter Add (
					String parameterName, 
					OracleType dataType, 
					Int32 size
					)
		{
			OracleParameter p = new OracleParameter(parameterName, dataType, size);
			return Add(p);
		}

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.Add6"]/*' />
		public OracleParameter Add (
					String parameterName, 
					OracleType dataType, 
					Int32 size, 
					String srcColumn
					)
		{
			OracleParameter p = new OracleParameter(parameterName, dataType, size, srcColumn);
			return Add(p);
		}


        private ArrayList ArrayList() 
        {
            if (null == this._items) 
            {
                this._items = new ArrayList();
            }
            return this._items;
        }

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.Clear"]/*' />
		public void Clear() 
		{
			if (null != _items) 
			{
#if EVERETT
                int count = _items.Count;
                for(int i = 0; i < count; ++i) 
                {
                    ((OracleParameter)_items[i]).Parent = null;
                }
#endif //EVERETT
				_items.Clear();
				_items = null;
			}
		}

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.Contains1"]/*' />
		public bool Contains(string parameterName) 
		{
			return (-1 != IndexOf(parameterName));
		}

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.Contains2"]/*' />
		public bool Contains(object value) 
		{
			return (-1 != IndexOf(value));
		}

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.CopyTo"]/*' />
		public void CopyTo(Array array, int index) 
		{
            ArrayList().CopyTo(array, index);
		}

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.GetEnumerator"]/*' />
		public IEnumerator GetEnumerator() 
		{
            return  ArrayList().GetEnumerator();
		}

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.IndexOf1"]/*' />
		public int IndexOf(string parameterName) 
		{
            if (null != _items) 
            {
                int count = _items.Count;

                for (int i = 0; i < count; ++i) 
                {
                	// Oracle is case-insensitive
                	if (0 == CultureInfo.CurrentCulture.CompareInfo.Compare(
                				parameterName,
                				((OracleParameter)_items[i]).ParameterName,
                				CompareOptions.IgnoreKanaType | CompareOptions.IgnoreWidth | CompareOptions.IgnoreCase
                				)) 
                	{
                        return i;
                    }
                }
            }
            return -1;
		}

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.IndexOf2"]/*' />
		public int IndexOf(object value) 
		{
            if (null != value) 
            {
                ValidateType(value);
                if (null != _items) 
                {
                    int count = _items.Count;
                    
                    for (int i = 0; i < count; ++i) 
                    {
                        if (value == _items[i]) 
                        {
                            return i;
                        }
                    }
                }
            }
            return -1;
		}

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.Insert"]/*' />
		public void Insert(int index, object value) 
		{
            ValidateType(value);
            Validate(-1, (OracleParameter)value);
#if EVERETT
            ((OracleParameter)value).Parent = this;
#endif //EVERETT
            ArrayList().Insert(index, value);
		}

        private void RangeCheck(int index) 
        {
            if ((index < 0) || (Count <= index))
            {
                throw ADP.ParameterIndexOutOfRange(index);
            }
        }

        private int RangeCheck(string parameterName)
        	{
            int index = IndexOf(parameterName);
            if (index < 0)
            {
				throw ADP.ParameterNameNotFound(parameterName);
            }
            return index;
        }

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.Remove"]/*' />
		public void Remove(object value) 
		{
            if (null == value) 
                throw ADP.ParameterIsNull("value");

			int index = IndexOf(value);

			if (-1 == index)
				throw ADP.ParameterNotFound();

			RemoveIndex(index);
		}

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.RemoveAt1"]/*' />
		public void RemoveAt(string parameterName) 
		{
			int index = RangeCheck(parameterName);
			RemoveIndex(index);
		}

        /// <include file='doc\OracleParameterCollection.uex' path='docs/doc[@for="OracleParameterCollection.RemoveAt2"]/*' />
		public void RemoveAt(int index) 
		{
			RangeCheck(index);
			RemoveIndex(index);
		}
		
		private void RemoveIndex(int index) 
		{
#if EVERETT
            ((OracleParameter)_items[index]).Parent = null;
#endif //EVERETT
			_items.RemoveAt(index);
		}
		
        private void Replace(
        		int index, 
        		object newValue
        		) 
        {
            Debug.Assert((null != _items) && (0 <= index) && (index < Count), "RemoveIndex, invalid");
            ValidateType(newValue);
#if EVERETT
            ((OracleParameter)_items[index]).Parent = null;
#endif //EVERETT
            Validate(index, (OracleParameter)newValue);
#if EVERETT
            ((OracleParameter)newValue).Parent = this;
#endif //EVERETT
            _items[index] = newValue;
        }

        private void Validate(int index, OracleParameter value) 
		{
#if EVERETT
            if (null != value.Parent) 
            {
                if (this != value.Parent)
                    throw ADP.ParametersIsNotParent(ItemType, value.ParameterName, this);
                
                if (index != IndexOf(value))
                    throw ADP.ParametersIsParent(ItemType, value.ParameterName, this);
            }
#endif //EVERETT
            
			// generate a ParameterName
			String name = value.ParameterName;
            if (0 == name.Length)
            {
                index = 1;
                do {
                    name = "p" + index.ToString(CultureInfo.CurrentCulture);
                    index++;
                } while (-1 != IndexOf(name));
                value.ParameterName = name;
            }
		}
		
        private void ValidateType(object value) 
        {
            if (null == value) 
            {
                throw ADP.ParameterIsNull("value");
            }
            else if (!ItemType.IsInstanceOfType(value)) 
            {
                throw ADP.WrongArgumentType("value", ItemType);
            }
        }
	};
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oraclepermission.cs ===
//------------------------------------------------------------------------------
// <copyright file="OraclePermission.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

//#define DATAPERMIT

namespace System.Data.OracleClient {

    using System.Collections;
    using System.Data.Common;
    using System.Diagnostics;
    using System.Globalization;
    using System.Security;
    using System.Security.Permissions;
    using System.Text;
    using System.Text.RegularExpressions;

    /// <include file='doc\OraclePermission.uex' path='docs/doc[@for="OraclePermission"]/*' />
    [Serializable] 
    sealed public class OraclePermission :  CodeAccessPermission, IUnrestrictedPermission {

        private bool _isUnrestricted;// = false;
        private bool _allowBlankPassword;// = false;
        private NameValuePermission _keyvaluetree = NameValuePermission.Default;
        private /*DBConnectionString[]*/ArrayList _keyvalues; // = null;

        /// <include file='doc\OraclePermission.uex' path='docs/doc[@for="OraclePermission.OraclePermission1"]/*' />
        public OraclePermission(PermissionState state) {
            if (state == PermissionState.Unrestricted) {
                _isUnrestricted = true;
            }
            else if (state == PermissionState.None) {
                _isUnrestricted = false;
            }
            else {
                throw ADP.Argument("state");
            }
        }

        /// <include file='doc\OraclePermission.uex' path='docs/doc[@for="OraclePermission.OraclePermission3"]/*' />
        private OraclePermission(OraclePermission permission) { // for Copy
            if (null == permission) {
                throw ADP.ArgumentNull("permissionAttribute");
            }
            CopyFrom(permission);
        }

        /// <include file='doc\OraclePermission.uex' path='docs/doc[@for="OraclePermission.OraclePermission4"]/*' />
        internal OraclePermission(OraclePermissionAttribute permissionAttribute) { // for CreatePermission
            if (null == permissionAttribute) {
                throw ADP.ArgumentNull("permissionAttribute");
            }
            _isUnrestricted = permissionAttribute.Unrestricted;
            if (!_isUnrestricted) {
                _allowBlankPassword = permissionAttribute.AllowBlankPassword;
                Add(permissionAttribute.ConnectionString, permissionAttribute.KeyRestrictions, permissionAttribute.KeyRestrictionBehavior);
            }
        }

        // how connectionString security is used
        // parsetable (all string) is shared with connection
        internal OraclePermission(DBConnectionString constr) { // for ConnectionString
            if (null != constr) {
                _allowBlankPassword = constr.HasBlankPassword();
                if (constr.GetType() != typeof(DBConnectionString)) {
                    // everything the OraclePermission references must be Serializable
                    // DBConnectionString is Serializable, its derived classes may not be
                    constr = new DBConnectionString(constr, true); // MDAC 83180
                }
                AddEntry(constr);
            }
        }

        /// <include file='doc\OraclePermission.uex' path='docs/doc[@for="OraclePermission.AllowBlankPassword"]/*' />
        public bool AllowBlankPassword {
            get {
                return _allowBlankPassword;
            }
            set { // MDAC 61263
                _allowBlankPassword = value;
            }
        }


        /// <include file='doc\OraclePermission.uex' path='docs/doc[@for="OraclePermission.AddWithAllow"]/*' />
        /// <internalonly />
        internal void Add(string connectionString, string restrictions, KeyRestrictionBehavior behavior) {
            switch(behavior) {
            case KeyRestrictionBehavior.PreventUsage:
            case KeyRestrictionBehavior.AllowOnly:
                break;
            default:
                throw ADP.Argument("value");
            }
            if (null == restrictions) {
                restrictions = ADP.StrEmpty;
            }
            DBConnectionString entry = new OracleConnectionString(connectionString, restrictions, behavior);
            if (!entry.ContainsPersistablePassword()) {
                entry = new DBConnectionString(entry, true);
            }
            AddEntry(entry);
            _isUnrestricted = false; // MDAC 84639
        }

        private void AddEntry(DBConnectionString entry) {
            try {
                lock(this) { // single writer, multiple readers
                    if (null == _keyvaluetree) {
                        _keyvaluetree = new NameValuePermission();
                    }
                    if (null == _keyvalues) {
                        _keyvalues = new ArrayList();
                    }
                    NameValuePermission.AddEntry(_keyvaluetree, _keyvalues, entry);
#if DATAPERMIT
                        if (null != _keyvaluetree) {
                            _keyvaluetree.DebugDump("-");
                        }
#endif
                }
            }
            catch { // MDAC 80973
                throw;
            }
        }

        /// <include file='doc\OraclePermission.uex' path='docs/doc[@for="OraclePermission.Clear"]/*' />
        /// <internalonly />
        internal void Clear() { // MDAC 83105
            try {
                lock(this) {
                    _keyvaluetree = null;
                    _keyvalues = null;
                }
            }
            catch {
                throw;
            }
        }

        // IPermission interface methods
        /// <include file='doc\OraclePermission.uex' path='docs/doc[@for="OraclePermission.Copy"]/*' />
        override public IPermission Copy() {
            return new OraclePermission(this);
        }

        private void CopyFrom(OraclePermission permission) {
            _isUnrestricted = permission.IsUnrestricted();
            if (!_isUnrestricted) {
                _allowBlankPassword = permission.AllowBlankPassword;

                try {
                    lock(permission) { // single writer, multiple reader
                        if (null != permission._keyvalues) {
                            _keyvalues = (ArrayList) permission._keyvalues.Clone();

                            if (null != permission._keyvaluetree) {
                                _keyvaluetree = permission._keyvaluetree.Copy();
                            }
                        }
                    }
                }
                catch { // MDAC 80973
                    throw;
                }
            }
        }

        /// <include file='doc\OraclePermission.uex' path='docs/doc[@for="OraclePermission.Intersect"]/*' />
        override public IPermission Intersect(IPermission target) { // used during Deny actions
            if (null == target) {
                return null;
            }
            if (target.GetType() != this.GetType()) {
                throw ADP.Argument("target");
            }
            if (IsUnrestricted()) { // MDAC 84803
                return Copy();
            }
            OraclePermission newPermission = (OraclePermission) target.Copy();
            if (!newPermission.IsUnrestricted()) {
                newPermission._allowBlankPassword &= AllowBlankPassword;

                if ((null != _keyvalues) && (null != newPermission._keyvalues)) {
                    newPermission._keyvalues.Clear();

                    newPermission._keyvaluetree.Intersect(newPermission._keyvalues, _keyvaluetree);
                    if (0 == newPermission._keyvalues.Count) { // no intersection
                        newPermission = null;
                    }
                }
                else {
                    // either target.Add or this.Add have not been called
                    // return a non-null object so IsSubset calls will fail
                    newPermission._keyvalues = null;
                    newPermission._keyvaluetree = null;
                }
            }
            return newPermission;
        }

        private bool IsEmpty() { // MDAC 84804,85707
            bool flag = (!IsUnrestricted() && !AllowBlankPassword && (null == _keyvalues));
            return flag;
        }
        
        /// <include file='doc\OraclePermission.uex' path='docs/doc[@for="OraclePermission.IsSubsetOf"]/*' />
        override public bool IsSubsetOf(IPermission target) {
            if (null == target) {
                return IsEmpty();
            }
            if (target.GetType() != this.GetType()) {
                throw ADP.WrongType(this.GetType());
            }
            OraclePermission superset = (target as OraclePermission);
#if DATAPERMIT
            if (null != superset._keyvalues) {
                Debug.WriteLine("+ " + (superset._keyvalues[0] as DBConnectionString).ConnectionString);
            } else Debug.WriteLine("+ <>");
            if (null != _keyvalues) {
                Debug.WriteLine("- " + (_keyvalues[0] as DBConnectionString).ConnectionString);
            } else Debug.WriteLine("- <>");
#endif
            bool subset = superset.IsUnrestricted();
            if (!subset) {
                subset = (!IsUnrestricted()
                        && (!AllowBlankPassword || superset.AllowBlankPassword)
                        && ((null == _keyvalues) || (null != superset._keyvaluetree)));

                if (subset && (null != _keyvalues)) {
                    foreach(DBConnectionString kventry in _keyvalues) {
                        if(!superset._keyvaluetree.CheckValueForKeyPermit(kventry)) {
                            subset = false;
                            break;
                        }
                    }
                }
            }
            return subset;
        }

        // IUnrestrictedPermission interface methods
        /// <include file='doc\OraclePermission.uex' path='docs/doc[@for="OraclePermission.IsUnrestricted"]/*' />
        public bool IsUnrestricted() {
            return _isUnrestricted;
        }

        /// <include file='doc\OraclePermission.uex' path='docs/doc[@for="OraclePermission.Union"]/*' />
        override public IPermission Union(IPermission target) {
            if (null == target) {
                return this.Copy();
            }
            if (target.GetType() != this.GetType()) {
                throw ADP.Argument("target");
            }
            if (IsUnrestricted()) { // MDAC 84803
                return this.Copy();
            }
            OraclePermission newPermission = (OraclePermission) target.Copy();
            if (!newPermission.IsUnrestricted()) {
	            newPermission._allowBlankPassword |= AllowBlankPassword;

	            if (null != _keyvalues) {
	                foreach(DBConnectionString entry in _keyvalues) {
	                    newPermission.AddEntry(entry);
	                }
	            }
            }
            return newPermission;
        }

        // <IPermission class="...Permission" version="1" AllowBlankPassword=false>
        //     <add ConnectionString="provider=x;data source=y;" KeyRestrictions="address=;server=" KeyRestrictionBehavior=PreventUsage/>
        // </IPermission>
        /// <include file='doc\OraclePermission.uex' path='docs/doc[@for="OraclePermission.FromXml"]/*' />
        override public void FromXml(SecurityElement securityElement) {
            // code derived from CodeAccessPermission.ValidateElement
            if (null == securityElement) {
                throw ADP.ArgumentNull("securityElement");
            }
            string tag = securityElement.Tag;
            if (!tag.Equals(XmlStr._Permission) && !tag.Equals(XmlStr._IPermission)) {
                // TODO: do we need to check this?
                //String className = el.Attribute( XmlStr._class );
                //return className == null || !className.Equals( ip.GetType().AssemblyQualifiedName );
                throw ADP.NotAPermissionElement();
            }
            String version = securityElement.Attribute(XmlStr._Version);
            if ((null != version) && !version.Equals(XmlStr._VersionNumber)) {
                throw ADP.InvalidXMLBadVersion();
            }

            string unrestrictedValue = securityElement.Attribute(XmlStr._Unrestricted);
            _isUnrestricted = (null != unrestrictedValue) && Boolean.Parse(unrestrictedValue);

            Clear(); // MDAC 83105
            if (!_isUnrestricted) {
                string allowNull = securityElement.Attribute(XmlStr._AllowBlankPassword);
                _allowBlankPassword = (null != allowNull) && Boolean.Parse(allowNull);

                ArrayList children = securityElement.Children;
                if (null != children) {
                    foreach(SecurityElement keyElement in children) {
                        if (keyElement.Tag.Equals(XmlStr._add)) {
                            string constr = keyElement.Attribute(XmlStr._ConnectionString);
                            string restrt = keyElement.Attribute(XmlStr._KeyRestrictions);
                            string behavr = keyElement.Attribute(XmlStr._KeyRestrictionBehavior);

                            KeyRestrictionBehavior behavior = KeyRestrictionBehavior.AllowOnly;
                            if (null != behavr) {
                                behavior = (KeyRestrictionBehavior) Enum.Parse(typeof(KeyRestrictionBehavior), behavr, true);
                            }
                            Add(constr, restrt, behavior);
                        }
                    }
                }
            }
            else {
                _allowBlankPassword = false;
            }
        }

        // <IPermission class="...Permission" version="1" AllowBlankPassword=false>
        //     <add ConnectionString="provider=x;data source=y;" KeyRestrictions="address=;server=" KeyRestrictionBehavior=PreventUsage/>
        // </IPermission>
        /// <include file='doc\OraclePermission.uex' path='docs/doc[@for="OraclePermission.ToXml"]/*' />
        override public SecurityElement ToXml() {
            Type type = this.GetType();
            SecurityElement root = new SecurityElement(XmlStr._IPermission);
            root.AddAttribute(XmlStr._class, type.FullName + ", " + type.Module.Assembly.FullName.Replace('\"', '\''));
            root.AddAttribute(XmlStr._Version, XmlStr._VersionNumber);

            if (IsUnrestricted()) {
                root.AddAttribute(XmlStr._Unrestricted, XmlStr._true);
            }
            else {
                root.AddAttribute(XmlStr._AllowBlankPassword, _allowBlankPassword.ToString());

                if (null != _keyvalues) {
                    foreach(DBConnectionString value in _keyvalues) {
                        SecurityElement valueElement = new SecurityElement(XmlStr._add);
                        string tmp;

                        tmp = value.GetConnectionString(true);
                        if (!ADP.IsEmpty(tmp)) {
                            valueElement.AddAttribute(XmlStr._ConnectionString, tmp);
                        }
                        tmp = value.Restrictions;
                        if (null == tmp) { tmp = ADP.StrEmpty; }
                        valueElement.AddAttribute(XmlStr._KeyRestrictions, tmp);

                        tmp = value.Behavior.ToString("G");
                        valueElement.AddAttribute(XmlStr._KeyRestrictionBehavior, tmp);
                        root.AddChild(valueElement);
                    }
                }
            }
            return root;
        }

        sealed private class XmlStr {
            internal const string _class = "class";
            internal const string _IPermission = "IPermission";
            internal const string _Permission = "Permission";
            internal const string _Unrestricted = "Unrestricted";
            internal const string _AllowBlankPassword = "AllowBlankPassword";
            internal const string _true = "true";
            internal const string _Version = "version";
            internal const string _VersionNumber = "1";

            internal const string _add = "add";

            internal const string _ConnectionString = "ConnectionString";
            internal const string _KeyRestrictions = "KeyRestrictions";
            internal const string _KeyRestrictionBehavior = "KeyRestrictionBehavior";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracleparameter.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleParameter.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.ComponentModel;
	using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
	using System.Data;
	using System.Data.Common;
	using System.Data.SqlTypes;
	using System.Diagnostics;
    using System.Globalization;
	using System.Runtime.InteropServices;


	//----------------------------------------------------------------------
	// OracleParameter
	//
    /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter"]/*' />
    [
    TypeConverterAttribute(typeof(System.Data.OracleClient.OracleParameter.OracleParameterConverter))
    ]
    sealed public class OracleParameter : MarshalByRefObject, IDbDataParameter, ICloneable
	{
        private string _parameterName;
        private object _value;
        
        private ParameterDirection _direction;
        private byte _precision;
        private byte _scale;

        private int _size;
        private int _offset;

        private string _sourceColumn;
        private DataRowVersion _sourceVersion = DataRowVersion.Current;

        private bool _isNullable;
        private bool _hasScale;

        private bool _hasCoercedValue;
        private object _coercedValue;
        private Type _coerceType, _noConvertType;

        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.CoercedValue"]/*' />
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        internal object CoercedValue {
            get {
                if (!_hasCoercedValue) {
                    SetCoercedValue(_coerceType, _noConvertType);
                }
                return _coercedValue;
            }
        }

		private void ResetCoercedValue() {
            _coerceType = null;
            _hasCoercedValue = false;
            _noConvertType = null;
            _coercedValue = null;
        }

        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.SetCoercedValue"]/*' />
        internal void SetCoercedValue(Type coerceType, Type noConvertType) {
            if (null == coerceType) {
                throw ADP.InvalidCast();
            }
            _hasCoercedValue = false;
            object value = Value;
            _coercedValue = value;
            if ((coerceType != typeof(object)) && !ADP.IsNull(value)) {
                Type type = value.GetType();                
                if ((type != coerceType) && (type != noConvertType)) {
                    _coercedValue = Convert.ChangeType(value, coerceType);
                }
            }
            _hasCoercedValue = true;
            _noConvertType = noConvertType;
            _coerceType = coerceType;
        }

		/// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.Direction"]/*' />
        [
        OracleCategory(Res.OracleCategory_Data),
        DefaultValue(ParameterDirection.Input),
        OracleDescription(Res.DataParameter_Direction),
        RefreshProperties(RefreshProperties.All),
        ]
		public ParameterDirection Direction {
 			get {
                ParameterDirection direction = _direction;
                return ((0 != direction) ? direction : ParameterDirection.Input);
            }
            set {
                if (_direction != value) {
                    switch (value) { // @perfnote: Enum.IsDefined
                    case ParameterDirection.Input:
                    case ParameterDirection.Output:
                    case ParameterDirection.InputOutput:
                    case ParameterDirection.ReturnValue:
                        PropertyChanging();
                        _direction = value;
                        break;
                    default:
                        throw ADP.InvalidParameterDirection(value);
                    }
                }
            }
        }

        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.IsNullable"]/*' />
        [
        Browsable(false), // MDAC 70780
        DefaultValue(false),
        DesignOnly(true),
        OracleDescription(Res.DataParameter_IsNullable),
        EditorBrowsableAttribute(EditorBrowsableState.Never) // MDAC 69508
        ]
        public bool IsNullable {
            get {
                return _isNullable;
            }
            set {
                _isNullable = value;
            }
        }

        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.Offset"]/*' />
        [
        Browsable(false),
        OracleCategory(Res.OracleCategory_Data),
        DefaultValue(0),
		OracleDescription(Res.OracleParameter_Offset)
		]
        public int Offset {
            get {
                return _offset;
            }
            set {
                if (value < 0) {
                    throw ADP.InvalidOffsetValue(value);
                }
                _offset = value;
            }
        }

        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.ParameterName"]/*' />
        [
        DefaultValue(""),
        OracleDescription(Res.DataParameter_ParameterName)
        ]
        public string ParameterName {
            get {
                string parameterName = _parameterName;
                return ((null != parameterName) ? parameterName : ADP.StrEmpty);
            }
            set {
                if (_parameterName != value) {
                    PropertyChanging();
                    _parameterName = value;
                }
            }
        }

        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.Precision"]/*' />
        [
        OracleCategory(Res.OracleCategory_Data),
        DefaultValue((Byte)0), // MDAC 65862
        OracleDescription(Res.DbDataParameter_Precision)
        ]
        public Byte Precision {
            get {
                byte precision = _precision;
                if (0 == precision) {
                    precision = ValuePrecision(_hasCoercedValue ? _coercedValue : Value);
                }
                return precision;
            }
            set {
                if (_precision != value) {
                    PropertyChanging();
                    _precision = value;
                }
            }
        }

        private bool ShouldSerializePrecision() {
            return (0 != _precision);
        }

        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.Scale"]/*' />
        [
        OracleCategory(Res.OracleCategory_Data),
        DefaultValue((Byte)0), // MDAC 65862
        OracleDescription(Res.DbDataParameter_Scale)
        ]
        public Byte Scale {
            get {
                byte scale = _scale;
                if (!_hasScale || ((0 == scale) && !ShouldSerializePrecision())) {
                    scale = ValueScale(_hasCoercedValue ? _coercedValue : Value);
                }
                return scale;
            }
            set {
                if (_scale != value) {
                    PropertyChanging();
                    _scale = value;
                    _hasScale = true;
                }
            }
        }

#if POSTEVERETT
        private void ResetScale() {
            _hasScale = false;
            _scale = 0;
        }
#endif //POSTEVERETT

        private bool ShouldSerializeScale() {
            return _hasScale;
        }

        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.Size"]/*' />
        [
        OracleCategory(Res.OracleCategory_Data),
        DefaultValue(0),
        OracleDescription(Res.DbDataParameter_Size)
        ]
        public int Size {
            get { return _size; }
            set {
                if (_size != value) {
                    if (value < 0) {
                        throw ADP.InvalidSizeValue(value);
                    }
                    PropertyChanging();
                    _size = value;
                }
            }
        }

        private bool ShouldSerializeSize() {
            return (0 != _size);
        }
        
        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.SourceColumn"]/*' />
        [
        OracleCategory(Res.OracleCategory_Data),
        DefaultValue(""),
        OracleDescription(Res.DataParameter_SourceColumn)
        ]
        public string SourceColumn {
            get {
                string sourceColumn = _sourceColumn;
                return ((null != sourceColumn) ? sourceColumn : ADP.StrEmpty);
            }
            set {
                _sourceColumn = value;
            }
        }

        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.SourceVersion"]/*' />
        [
        OracleCategory(Res.OracleCategory_Data),
        DefaultValue(DataRowVersion.Current),
        OracleDescription(Res.DataParameter_SourceVersion)
        ]
        public DataRowVersion SourceVersion {
            get {
                DataRowVersion sourceVersion = _sourceVersion;
                return ((0 != sourceVersion) ? sourceVersion : DataRowVersion.Current);
            }
            set {
                switch(value) { // @perfnote: Enum.IsDefined
                case DataRowVersion.Original:
                case DataRowVersion.Current:
                case DataRowVersion.Proposed:
                case DataRowVersion.Default:
                    _sourceVersion = value;
                    break;
                default:
                    throw ADP.InvalidDataRowVersion(value);
                }
            }
        }

        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.Value"]/*' />
        [
        OracleCategory(Res.OracleCategory_Data),
        DefaultValue(null),
        OracleDescription(Res.DataParameter_Value),
        RefreshProperties(RefreshProperties.All),
        TypeConverterAttribute(typeof(StringConverter))
        ]
        public object Value {
            get {
                return _value;
            }
            set {
                _hasCoercedValue = false; // correct to not call ResetCoercedValue  
                _coercedValue = null;     // since it will clear the coerce type
                _value = value;
            }
        }

        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.ICloneable.Clone"]/*' />
        /// <internalonly/>
        object ICloneable.Clone() {
            OracleParameter clone = new OracleParameter();

            clone._parameterName  = _parameterName;
            clone._value          = _value;
            clone._direction      = _direction;
            clone._precision      = _precision;
            clone._scale          = _scale;
            clone._size           = _size;
            clone._offset         = _offset;
            clone._sourceColumn   = _sourceColumn;
            clone._sourceVersion  = _sourceVersion;
            clone._isNullable     = _isNullable;
            clone._hasScale       = _hasScale;
            clone._metaType       = _metaType;
            clone._hasCoercedValue= _hasCoercedValue;
            clone._coerceType	  = _coerceType;
            clone._noConvertType  = _noConvertType;

            if (_coercedValue is ICloneable) {
            	clone._coercedValue = ((ICloneable) _coercedValue).Clone();
            }
            if (_value is ICloneable) { // MDAC 49322
                clone._value = ((ICloneable) _value).Clone();
            }
            return clone;
        }

        private void PropertyChanging() {
        }

        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.ToString"]/*' />
        override public string ToString() {
            return ParameterName;
        }

        private byte ValuePrecision(object value) {
            return 0;
        }

        private byte ValueScale(object value) {
            if (value is Decimal) {
                return (byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10);
            }
            return 0;
        }

        private int base_ValueSize(object value) {
            if (value is string) {
                return ((string) value).Length;
            }
            if (value is byte[]) {
                return ((byte[]) value).Length;
            }
            if (value is char[]) {
                return ((char[]) value).Length;
            }
            if ((value is byte) || (value is char)) {
                return 1;
            }
            return 0;
	    }
	
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Fields
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
		private MetaType					_metaType;		// type information; only set when DbType or OracleType is set.
#if EVERETT
		private OracleParameterCollection	_parent;		// the collection that owns of this parameter.
#endif //EVERETT
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Constructors
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        // Construct an "empty" parameter
        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.OracleParameter1"]/*' />
		public OracleParameter() {}

        // Construct from a parameter name and a value object
        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.OracleParameter2"]/*' />
		public OracleParameter(
				string name,
				object value
				)
		{
			this.ParameterName	= name;
			this.Value			= value;
		}

        // Construct from a parameter name and a data type
        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.OracleParameter3"]/*' />
		public OracleParameter(
				string 		name,
				OracleType	oracleType
				)
		{
			this.ParameterName	= name;
			this.OracleType		= oracleType;
		}

        // Construct from a parameter name, a data type and the size
        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.OracleParameter4"]/*' />
		public OracleParameter(
				string 		name,
				OracleType	oracleType,
				int			size
				)
		{
			this.ParameterName	= name;
			this.OracleType		= oracleType;
			this.Size			= size;
		}

        // Construct from a parameter name, a data type, the size and the source column
        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.OracleParameter5"]/*' />
		public OracleParameter(
				string 		name,
				OracleType	oracleType,
				int			size,
				string		srcColumn
				)
		{
			this.ParameterName	= name;
			this.OracleType		= oracleType;
			this.Size			= size;
			this.SourceColumn	= srcColumn;
		}

        // Construct from everything but the kitchen sink
        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.OracleParameter6"]/*' />
		public OracleParameter(
				string 				name,
				OracleType			oracleType,
				int					size,
				ParameterDirection	direction,
				bool				isNullable,
				byte				precision,
				byte				scale,
				string				srcColumn,
				DataRowVersion		srcVersion,
				object				value
				)
		{
			this.ParameterName	= name;
			this.OracleType		= oracleType;
			this.Size			= size;
			this.Direction		= direction;
			this.IsNullable		= isNullable;
			this.Precision		= precision;
			this.Scale			= scale;
			this.SourceColumn	= srcColumn;
			this.SourceVersion	= srcVersion;
			this.Value			= value;
		}


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        internal int BindSize 
       	{
            get 
            {
            	// Output parameters (and input/output parameters) must be bound as
            	// they are specified, or we risk truncating output data.
                if (ADP.IsDirection(Direction, ParameterDirection.Output)
                 || (0 != _size && short.MaxValue > _size))
                	return _size;

                // Input-only parameters can be limited to the size of the data that
                // is being bound.
                object value = (_hasCoercedValue ? _coercedValue : Value);
                if (ADP.IsNull(value))
	                return 0;
                
                return ValueSize(value);
            }
        }

		/// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.DbType"]/*' />
        [
        Browsable(false),
        OracleCategory(Res.OracleCategory_Data),
        RefreshProperties(RefreshProperties.All),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
#if EVERETT
        OracleDescription(Res.DataParameter_DbType),
#endif //EVERETT
        ]
		public DbType DbType
		{
			get { return GetMetaType().DbType; }
            set 
            {
                if ((null == _metaType) || (_metaType.DbType != value))
                {
                    PropertyChanging();
                    ResetCoercedValue();
					_metaType = MetaType.GetMetaTypeForType(value);
                }
            }
		}

        /// <include file='doc\OracleParameter.uex' path='docs/doc[@for="OracleParameter.OracleType"]/*' />
        [
        DefaultValue(OracleType.VarChar), // MDAC 65862
        OracleCategory(Res.OracleCategory_Data),
        RefreshProperties(RefreshProperties.All),
#if EVERETT
        OracleDescription(Res.OracleParameter_OracleType),
#endif //EVERETT
        ]
		public OracleType OracleType
		{
			get { return GetMetaType().OracleType; }
			set
            {
                if ((null == _metaType) || (_metaType.OracleType != value))
                {
                    PropertyChanging();
                    ResetCoercedValue();
					_metaType = MetaType.GetMetaTypeForType(value);
                }
            }
		}

#if EVERETT
        internal OracleParameterCollection Parent 
        {
            get { return _parent; }
            set { _parent = value; }
        }
#endif //EVERETT
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		internal MetaType GetMetaType()
		{
			// if the user specifed a type, then return it's meta data
			if (null != _metaType)
				return _metaType;

			object parameterValue = Value;

			// if the didn't specify a type, but they specified a value, then
			// return the meta data for the value they specified
			if (null != parameterValue && !Convert.IsDBNull(parameterValue))
				return MetaType.GetMetaTypeForObject(parameterValue);

			// if they haven't specified anything, then return the default
			// meta data information
			return MetaType.GetDefaultMetaType();
		}

        private bool ShouldSerializeOracleType()
        {
            return (null != _metaType);
        }

        private int ValueSize(object value)
       	{
            if (value is OracleString)  return ((OracleString) value).Length;
            if (value is string) 		return ((string) value).Length;
            if (value is char[]) 		return ((char[]) value).Length;
            if (value is OracleBinary)  return ((OracleBinary) value).Length;

            return base_ValueSize(value);
        }

        sealed internal class OracleParameterConverter : ExpandableObjectConverter {

            /// <include file='doc\OracleParameterConverter.uex' path='docs/doc[@for="OracleParameterConverter.CanConvertTo"]/*' />
            /// <internalonly/>
            public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
                if (destinationType == typeof(InstanceDescriptor)) {
                    return true;
                }
                return base.CanConvertTo(context, destinationType);
            }

            public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
                if (destinationType == null) {
                    throw ADP.ArgumentNull("destinationType");
                }
                if (destinationType == typeof(InstanceDescriptor) && value is OracleParameter) {
                    return ConvertToInstanceDescriptor(value as OracleParameter);
                }            
                return base.ConvertTo(context, culture, value, destinationType);
            }

            private InstanceDescriptor ConvertToInstanceDescriptor(OracleParameter p) {
                // MDAC 67321 - reducing parameter generated code
                int flags = 0; // if part of the collection - the parametername can't be empty

                if (p.ShouldSerializeOracleType()) {
                    flags |= 1;
                }
                if (p.ShouldSerializeSize()) {
                    flags |= 2;
                }
                if (!ADP.IsEmpty(p.SourceColumn)) {
                    flags |= 4;
                }
                if (null != p.Value) {
                    flags |= 8;
                }
                if ((ParameterDirection.Input != p.Direction) || p.IsNullable
                    || p.ShouldSerializePrecision() || p.ShouldSerializeScale()
                    || (DataRowVersion.Current != p.SourceVersion)) {
                    flags |= 16;
                }

                Type[] ctorParams;
                object[] ctorValues;
                switch(flags) {
                case  0: // ParameterName
                case  1: // OracleType
                    ctorParams = new Type[] { typeof(string), typeof(OracleType) };
                    ctorValues = new object[] { p.ParameterName, p.OracleType };
                    break;
                case  2: // Size
                case  3: // Size, OracleType
                    ctorParams = new Type[] { typeof(string), typeof(OracleType), typeof(int) };
                    ctorValues = new object[] { p.ParameterName, p.OracleType, p.Size };
                    break;
                case  4: // SourceColumn
                case  5: // SourceColumn, OracleType
                case  6: // SourceColumn, Size
                case  7: // SourceColumn, Size, OracleType
                    ctorParams = new Type[] { typeof(string), typeof(OracleType), typeof(int), typeof(string) };
                    ctorValues = new object[] { p.ParameterName, p.OracleType, p.Size, p.SourceColumn };
                    break;
                case  8: // Value
                    ctorParams = new Type[] { typeof(string), typeof(object) };
                    ctorValues = new object[] { p.ParameterName, p.Value };
                    break;
                default:
                    ctorParams = new Type[] {
                                                typeof(string), typeof(OracleType), typeof(int), typeof(ParameterDirection),
                                                typeof(bool), typeof(byte), typeof(byte), typeof(string), 
                                                typeof(DataRowVersion), typeof(object) };
                    ctorValues = new object[] {
                                                  p.ParameterName, p.OracleType,  p.Size, p.Direction,
                                                  p.IsNullable, p.Precision, p.Scale, p.SourceColumn,
                                                  p.SourceVersion, p.Value };
                    break;
                }
                System.Reflection.ConstructorInfo ctor = typeof(OracleParameter).GetConstructor(ctorParams);
                return new InstanceDescriptor(ctor, ctorValues);
            }
        }
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oraclerowupdatedeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="OracleRowUpdatedEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OracleClient {

    using System.Diagnostics;

    using System;
    using System.Data;
    using System.Data.Common;

    /// <include file='doc\OracleRowUpdatedEvent.uex' path='docs/doc[@for="OracleRowUpdatedEventArgs"]/*' />
    sealed public class OracleRowUpdatedEventArgs : RowUpdatedEventArgs {
        /// <include file='doc\OracleRowUpdatedEvent.uex' path='docs/doc[@for="OracleRowUpdatedEventArgs.OracleRowUpdatedEventArgs"]/*' />
        public OracleRowUpdatedEventArgs(DataRow row, IDbCommand command, StatementType statementType, DataTableMapping tableMapping)
        : base(row, command, statementType, tableMapping) {
        }

        /// <include file='doc\OracleRowUpdatedEvent.uex' path='docs/doc[@for="OracleRowUpdatedEventArgs.Command"]/*' />
        new public OracleCommand Command {
            get {
                return(OracleCommand) base.Command;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oraclerowupdatingeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="OracleRowUpdatingEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OracleClient {

    using System.Diagnostics;

    using System;
    using System.Data;
    using System.Data.Common;

    /// <include file='doc\OracleRowUpdatingEvent.uex' path='docs/doc[@for="OracleRowUpdatingEventArgs"]/*' />
    sealed public class OracleRowUpdatingEventArgs : RowUpdatingEventArgs {
        /// <include file='doc\OracleRowUpdatingEvent.uex' path='docs/doc[@for="OracleRowUpdatingEventArgs.OracleRowUpdatingEventArgs"]/*' />
        public OracleRowUpdatingEventArgs(DataRow row, IDbCommand command, StatementType statementType, DataTableMapping tableMapping)
        : base(row, command, statementType, tableMapping) {
        }

        /// <include file='doc\OracleRowUpdatingEvent.uex' path='docs/doc[@for="OracleRowUpdatingEventArgs.Command"]/*' />
        new public OracleCommand Command {
            get { return(OracleCommand) base.Command; }
            set { base.Command = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oraclerowupdatedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="OracleRowUpdatedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OracleClient {

    /// <include file='doc\OracleRowUpdatedEventHandler.uex' path='docs/doc[@for="OracleRowUpdatedEventHandler"]/*' />
    public delegate void OracleRowUpdatedEventHandler(object sender, OracleRowUpdatedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oraclerowupdatingeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="OracleRowUpdatingEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Data.OracleClient {

    /// <include file='doc\OracleRowUpdatingEventHandler.uex' path='docs/doc[@for="OracleRowUpdatingEventHandler"]/*' />
    public delegate void OracleRowUpdatingEventHandler(object sender, OracleRowUpdatingEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oraclesqlparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="OracleSqlParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------

namespace System.Data.OracleClient
{

    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.Globalization;
    using System.Text;

    //----------------------------------------------------------------------
    // OracleSqlParser
    //
    //  The overrides to DBSqlParser to create an Oracle-specific SQL
    //  parser.
    //
    sealed internal class OracleSqlParser : DBSqlParser
    {
        private const string SynonymQueryBegin =
            "select"
            +" table_owner,"
            +" table_name "
            +"from"
            +" all_synonyms "
            +"where"
            ;

        private const string SynonymQueryNoSchema =
            " owner in ('PUBLIC', user)"
            ;
            
        private const string SynonymQuerySchema =
            " owner = '"
            ;
            
        private const string SynonymQueryTable =
            " and synonym_name = '"
            ;

        // @devnote If there are both public and private synonyms, Oracle will
        //          use the private one, so we need to do that too.
        private const string SynonymQueryEnd =
            "' order by decode(owner, 'PUBLIC', 2, 1)"
            ;
            
        // Query for index Constraints
        private const string ConstraintQueryPart1 =
            "select * from ("
                +"select"
                +" b.index_name c1,"
                +" b.column_name c2,"
                +" 2 c3 "
                +"from"
                +" (select * from all_indexes where table_owner = "
                ;
            
        private const string ConstraintQueryPart2 =
                " and table_name = '"
                ;
            
        private const string ConstraintQueryPart3 =
                "' and uniqueness = 'UNIQUE') a, "
                +"(select * from all_ind_columns where table_owner = "
                ;

        private const string ConstraintQueryPart4 =
                " and table_name = '"
                ;
            
        private const string ConstraintQueryPart5 =
                "') b "
                +"where a.index_name = b.index_name" 
//              +" order by a.index_name"           // Doesn't work against 8.0.5 servers, but I don't think we needed it anyway
            +") "
            +"union select * from ("
                +"select"
                +" acc.constraint_name c1,"
                +" acc.column_name c2,"
                +" decode(ac.constraint_type, 'P', 1, 'U', 2) c3 "
                +"from"
                +" all_constraints ac,"
                +" all_cons_columns acc "
                +"where"
                +" ac.owner = "
                ;
            
        private const string ConstraintQueryPart6 =
                " and ac.table_name = '"
                ;
            
        private const string ConstraintQueryPart7 =
                "' and ac.constraint_type in ('P', 'U')"
                +" and ac.owner = acc.owner"
                +" and ac.constraint_name = acc.constraint_name"
//              +" order by ac.constraint_type, acc.constraint_name, acc.position"          // Doesn't work against 8.0.5 servers, but I don't think we needed it anyway
            +") order by 3, 1, 2"
            ;
        
        private const string TableOwnerUser =
             "user"
             ;

        private const string IndexSingleQuote =
            "'"
            ;



/*
select * from (
select
 b.index_name c1,
 b.column_name c2,
 1 c3
from
 (select * from all_indexes where table_owner = 'SCOTT' and table_name = 'EMP') a,
 all_ind_columns b
where a.index_name = b.index_name order by a.index_name
)
union all
select * from (
select
 acc.constraint_name c1,
 acc.column_name c2,
 decode(ac.constraint_type, 'P', 2, 'U', 1) c3
from
 all_constraints ac,
 all_cons_columns acc 
where
 ac.owner = 'SCOTT'
 and ac.table_name = 'EMP'
 and ac.constraint_type = 'P'
 and ac.owner = acc.owner
 and ac.constraint_name = acc.constraint_name
 order by acc.constraint_name, acc.position
) order by 3, 1, 2
;

 */
            
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Fields 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////        

        private OracleConnection            _connection;
        private bool                        _moreConstraints;
        static private readonly string      _regexPattern;
        static private readonly string      _quoteCharacter = "\"";
        
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Constructor 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////        

        // This static constructor will build the regex pattern we need.
        static OracleSqlParser()
        {
            // \\p{Lo} = OtherLetter
            // \\p{Lu} = UppercaseLetter
            // \\p{Ll} = LowercaseLetter
            // \\p{Lm} = ModifierLetter
            // \\p{Nd} = DecimalDigitNumber
            _regexPattern = DBSqlParser.CreateRegexPattern(
                                            "[\\p{Lo}\\p{Lu}\\p{Ll}\\p{Lm}\uff3f_#$]",
                                            "[\\p{Lo}\\p{Lu}\\p{Ll}\\p{Lm}\\p{Nd}\uff3f_#$]",
                                            _quoteCharacter,
                                            "([^\"]|\"\")*",
                                            _quoteCharacter,
                                            "(" + "'" + "([^']|'')*" + "'" + ")"
                                            );
        }
        internal OracleSqlParser() : base (
                                            _quoteCharacter,
                                            _quoteCharacter,
                                            _regexPattern
                                            ) {}

        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////
        //
        // Methods 
        //
        ////////////////////////////////////////////////////////////////////////
        ////////////////////////////////////////////////////////////////////////

        static internal string CatalogCase(string value)
        {
            //  Converts the specified value to the correct case for the catalog
            //  entries, using quoting rules
            
            if (null == value || string.Empty == value)
                return String.Empty;
            
            if ('"' == value[0])
                return value.Substring(1, value.Length-2);

            return value.ToUpper(CultureInfo.CurrentCulture);
        }

        protected override bool CatalogMatch(
            string  valueA,
            string  valueB
            )
        {
            //  compares the two values in catalog order, taking into account
            //  quoting rules, and case-sensitivity rules, and returns true if
            //  they match.
            
            // the values are equal if they're both null or empty.
            if (null == valueA && null == valueB)
                return true;

            // the values are not equal if only one is null
            if (null == valueA || null == valueB)
                return false;

            if (string.Empty == valueA && string.Empty == valueB)
                return true;

            if (string.Empty == valueA || string.Empty == valueB)
                return false;

            // Now, we have two non-null values; adjust for possible quotes

            bool isSensitiveA = ('"' == valueA[0]);
            int  offsetA = 0;
            int  lengthA = valueA.Length;

            bool isSensitiveB = ('"' == valueB[0]);
            int  offsetB = 0;
            int  lengthB = valueB.Length;

            if (isSensitiveA)
            {
                offsetA++;
                lengthA -= 2;
            }
                
            if (isSensitiveB)
            {
                offsetB++;
                lengthB -= 2;
            }

            CompareOptions  opt = CompareOptions.IgnoreKanaType | CompareOptions.IgnoreWidth;
                
            if (!isSensitiveA || !isSensitiveB)
                opt |= CompareOptions.IgnoreCase;

            int result = CultureInfo.CurrentCulture.CompareInfo.Compare(valueA, offsetA, lengthA,
                                                                        valueB, offsetB, lengthB, 
                                                                        opt);

            return (0 == result);
        }

        private DBSqlParserColumn FindConstraintColumn(
            string  schemaName,
            string  tableName,
            string  columnName
            )
        {
            //  Searches the collection of parsed column information for the
            //  specific column in the specific table, and returns the parsed
            //  column information if it's found.  If not found then it returns
            //  null instead.
            
            DBSqlParserColumnCollection columns = Columns;
            int                         columnCount = columns.Count;

            for (int i = 0; i < columnCount; ++i)
            {
                DBSqlParserColumn column = columns[i];

                if (CatalogMatch(column.SchemaName, schemaName)
                 && CatalogMatch(column.TableName,  tableName)
                 && CatalogMatch(column.ColumnName, columnName) )
                    return column;
            }
            return null;
        }

        protected override void GatherKeyColumns(
            DBSqlParserTable table
            )
        {
            //  Called after the table and column information is completed to
            //  identify which columns in the select-list are key columns for
            //  their table.
            
            OracleCommand       cmd = null;
            OracleDataReader    rdr = null;
            try {
                try {
                    cmd = _connection.CreateCommand();
                    
                    cmd.Transaction = _connection.Transaction; // must set the transaction context to be the same as the command, or we'll throw when we execute.

                    string schemaName = CatalogCase(table.SchemaName);
                    string tableName  = CatalogCase(table.TableName);

                    string synonymSchemaName = schemaName;
                    string synonymTableName  = tableName;

                    // First, we have to "dereference" a synonym, if it was specified, because
                    // synonyms don't have catalog items stored for them, they're for the table
                    // or view that the synonym references.

                    cmd.CommandText = GetSynonymQueryStatement(schemaName, tableName);
                    rdr = cmd.ExecuteReader();

                    if (rdr.Read())
                        {
                        synonymSchemaName  = rdr.GetString(0);
                        synonymTableName   = rdr.GetString(1);
                        }

                    rdr.Dispose();

                    // Now we have the real schema name and table name, go and derive the key
                    // columns 

                    cmd.CommandText = GetConstraintQueryStatement(synonymSchemaName, synonymTableName);
                    rdr = cmd.ExecuteReader();

                    ArrayList   constraintColumnNames = new ArrayList();
                    bool        isUniqueConstraint;
                    
                    if (true == (_moreConstraints = rdr.Read()))
                        {
                        while (GetConstraint(rdr, out isUniqueConstraint, constraintColumnNames))
                            {
                            bool foundAllColumns = true;
                            int  constraintColumnCount = constraintColumnNames.Count;

                            DBSqlParserColumn[] constraintColumn = new DBSqlParserColumn[constraintColumnCount];

                            for (int j=0; j < constraintColumnCount; ++j)
                                {
                                DBSqlParserColumn column = FindConstraintColumn(
                                                                schemaName,
                                                                tableName,
                                                                (string)constraintColumnNames[j]
                                                                );

                                if (null == column)
                                    {
                                    foundAllColumns = false;
                                    break;
                                    }
                                
                                constraintColumn[j] = column;
                                }

                            if (foundAllColumns)
                                {
                                for (int j=0; j < constraintColumnCount; ++j)
                                    {
                                    constraintColumn[j].SetAsKey(isUniqueConstraint);
                                    }
                                
                                break;
                                }
                            }
                        }
                    }
                finally
                    {
                    if (null != cmd)
                        {
                        cmd.Dispose();
                        cmd = null;
                        }
                    
                    if (null != rdr)
                        {
                        rdr.Dispose();
                        rdr = null;
                        } 
                    }
                }
            catch { // Prevent exception filters from running in our space
                throw;
            }
        }
                
        override protected DBSqlParserColumnCollection GatherTableColumns(
            DBSqlParserTable table
            )
        {
            //  Called to get a column list for the table specified.
            
            OciHandle       statementHandle = _connection.EnvironmentHandle.CreateOciHandle(OCI.HTYPE.OCI_HTYPE_STMT);
            OciHandle       errorHandle = _connection.ErrorHandle;
            StringBuilder   sb = new StringBuilder();
            string          schemaName      = table.SchemaName;
            string          tableName       = table.TableName;
            string          columnName;
            int             tableColumnCount;
            int             rc;
            string          tempStatement;

            DBSqlParserColumnCollection columns = new DBSqlParserColumnCollection();

            Debug.Assert (string.Empty == table.DatabaseName, "oracle doesn't support 4 part names!");      
            
            sb.Append("select * from ");
            
            if (String.Empty != schemaName)
            {
                sb.Append(schemaName);
                sb.Append(".");
            }
            
            sb.Append(tableName);
            
            tempStatement = sb.ToString();

            rc = TracedNativeMethods.OCIStmtPrepare(
                                    statementHandle, 
                                    errorHandle, 
                                    tempStatement, 
                                    tempStatement.Length, 
                                    OCI.SYNTAX.OCI_NTV_SYNTAX,
                                    OCI.MODE.OCI_DEFAULT,
                                    _connection
                                    );
            
            if (0 == rc)
            {
                rc = TracedNativeMethods.OCIStmtExecute(
                                        _connection.ServiceContextHandle,
                                        statementHandle,
                                        errorHandle,
                                        0,                          // iters
                                        0,                          // rowoff
                                        ADP.NullHandleRef,          // snap_in
                                        ADP.NullHandleRef,          // snap_out
                                        OCI.MODE.OCI_DESCRIBE_ONLY  // mode
                                        );

                if (0 == rc)
                {
                    // Build the column list for the table
                    statementHandle.GetAttribute(OCI.ATTR.OCI_ATTR_PARAM_COUNT, out tableColumnCount, errorHandle);

                    for (int j = 0; j < tableColumnCount; j++)
                    {
                        OciHandle describeHandle = statementHandle.GetDescriptor(j, errorHandle);
                        describeHandle.GetAttribute(OCI.ATTR.OCI_ATTR_NAME, out columnName, errorHandle, _connection);
                        OciHandle.SafeDispose(ref describeHandle);

                        columnName = QuotePrefixCharacter + columnName + QuoteSuffixCharacter;

                        columns.Add(null, schemaName, tableName, columnName, null);
                    }
                    
                    // Now, derive the key information for the statement and update the column list
                    // with it.
                }
            }

            // Clean up and return;
            OciHandle.SafeDispose(ref statementHandle);

            return columns;
        }
        
        internal bool GetConstraint(
            OracleDataReader    rdr,
            out bool            isUniqueConstraint,
            ArrayList           constraintColumnNames
            )
        {
            //  Reads the data reader until all column names in a constraint have
            //  been read or there are no more constraints.
            
            string  constraintName;
            string  constraintColumnName;
            int     constraintType = 0;
            
            constraintColumnNames.Clear();

            if (_moreConstraints)
                {
                constraintName       = rdr.GetString(0);
                constraintColumnName = rdr.GetString(1);
                constraintType       = (int)rdr.GetDecimal(2);

                constraintColumnNames.Add(constraintColumnName);

                while (true == (_moreConstraints = rdr.Read()))
                    {
                    string constraintNameNextRow = rdr.GetString(0);
                    
                    if (constraintName != constraintNameNextRow)
                        break;
                        
                    constraintColumnName = rdr.GetString(1);
                    constraintColumnNames.Add(constraintColumnName);
                    }

                }
            isUniqueConstraint = (2 == constraintType);

            return (0 != constraintColumnNames.Count);
        }

        private string GetConstraintQueryStatement(
                string schemaName,
                string tableName
                )
        {
            //  Returns the statement text necessary to identify the constraints
            //  for the table specified.
            
            StringBuilder   sb = new StringBuilder();

            // First build the user or schema string so we can re-use it.
            if (String.Empty == schemaName)
                {
                sb.Append(TableOwnerUser);
                }
            else
                {
                sb.Append(IndexSingleQuote);
                sb.Append(schemaName);
                sb.Append(IndexSingleQuote);
                }

            string userOrSchema = sb.ToString();

            // now build the statement
            sb = new StringBuilder();
            
            sb.Append(ConstraintQueryPart1);
            sb.Append(userOrSchema);
            sb.Append(ConstraintQueryPart2);
            sb.Append(tableName);
            sb.Append(ConstraintQueryPart3);
            sb.Append(userOrSchema);
            sb.Append(ConstraintQueryPart4);
            sb.Append(tableName);
            sb.Append(ConstraintQueryPart5);
            sb.Append(userOrSchema);
            sb.Append(ConstraintQueryPart6);
            sb.Append(tableName);
            sb.Append(ConstraintQueryPart7);
            
            return sb.ToString();
        }

        private string GetSynonymQueryStatement(
                string schemaName,
                string tableName
                )
        {
            //  Returns the statement text necessary to determine the base table
            //  behind a synonym.

            StringBuilder   sb = new StringBuilder();

            sb.Append(SynonymQueryBegin);
            if (string.Empty == schemaName)
                {
                sb.Append(SynonymQueryNoSchema);
                }
            else
                {
                sb.Append(SynonymQuerySchema);
                sb.Append(schemaName);
                sb.Append("'");
                }

            sb.Append(SynonymQueryTable);
            sb.Append(tableName);
            sb.Append(SynonymQueryEnd);

            return sb.ToString();
        }

        internal void Parse(
            string              statementText,
            OracleConnection    connection 
            )
        {
            //  Oracle specific Parse method, to allow us to capture a connection
            //  for use by the schema gathering methods later.
            
            _connection = connection;
            Parse(statementText);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracletype.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleType.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;

	//----------------------------------------------------------------------
	// OracleType
	//
	//	
	//	This is an enumeration of all the potential data types that you
	//	could bind to Oracle; it is an amalgamation of Oracle's Internal
	//	data types, Oracle's External data types, and the CLS types that
	//	Oracle can accept data as.
	//
	
    /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType"]/*' />
	public enum OracleType 
	{
        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.BFile"]/*' />
		BFile = 1,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.Blob"]/*' />
		Blob = 2,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.Char"]/*' />
		Char = 3,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.Clob"]/*' />
		Clob = 4,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.Cursor"]/*' />
		Cursor = 5,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.DateTime"]/*' />
		DateTime= 6,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.IntervalDayToSecond"]/*' />
		IntervalDayToSecond = 7,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.IntervalYearToMonth"]/*' />
		IntervalYearToMonth = 8,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.LongRaw"]/*' />
		LongRaw = 9,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.LongVarChar"]/*' />
		LongVarChar = 10,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.NChar"]/*' />
		NChar = 11,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.NClob"]/*' />
		NClob = 12,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.Number"]/*' />
		Number = 13,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.NVarChar"]/*' />
		NVarChar = 14,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.Raw"]/*' />
		Raw = 15,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.RowId"]/*' />
		RowId = 16,

		// RowIdDescriptor = 17,
		
        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.Timestamp"]/*' />
		Timestamp = 18,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.TimestampLocal"]/*' />
		TimestampLocal = 19,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.TimestampWithTZ"]/*' />
		TimestampWithTZ = 20,

		// UniversalRowId = 21,
		
        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.VarChar"]/*' />
		VarChar = 22,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.Byte"]/*' />
		Byte = 23,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.UInt16"]/*' />
		UInt16 = 24,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.UInt32"]/*' />
		UInt32 = 25,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.SByte"]/*' />
		SByte = 26,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.Int16"]/*' />
		Int16 = 27,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.Int32"]/*' />
		Int32 = 28,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.Float"]/*' />
		Float = 29,

        /// <include file='doc\OracleType.uex' path='docs/doc[@for="OracleType.Double"]/*' />
		Double = 30,
	};
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oraclestring.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleString.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Data.SqlTypes;
	using System.Diagnostics;
	using System.Globalization;
	using System.Runtime.InteropServices;
	using System.Text;

	//----------------------------------------------------------------------
	// OracleString
	//
	//	This class implements support for Oracle's CHAR, VARCHAR, NCHAR,
	//	NVARCHAR and LONG internal data types.  While some of these data 
	//	types may be retrieved as multi-byte strings from Oracle there is
	//	no particular benefit to leaving them as multi-byte because we 
	//	would be forced to re-implement the entire String class for 
	//	multi-byte strings to avoid constant conversions.  
	//
	//	For that reason, this type class should simply be a wrapper class
	//	around the CLS String data type, with the appropriate internal 
	//	constructors to allow data values to be set from the data reader.
	//
    /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString"]/*' />
    [StructLayout(LayoutKind.Sequential)]
	public struct OracleString : IComparable, INullable
	{
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Fields
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
		private string _value;	

        /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.Empty"]/*' />
        public static readonly OracleString Empty = new OracleString(false);

        /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.Null"]/*' />
        public static readonly OracleString Null = new OracleString(true);

		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Constructors
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		// Construct from nothing -- the value will be null or empty
		private OracleString(bool isNull)
		{	
			_value = (isNull) ? null : String.Empty;
		}

        /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.OracleString2"]/*' />
		public OracleString (string s)  
		{
			_value = s;
		}

        // (internal) construct from a row/parameter binding
		internal OracleString(
					NativeBuffer 	 buffer,
					int				 valueOffset,
					int				 lengthOffset,
					MetaType		 metaType,
					OracleConnection connection,			// See MDAC #78258 for reason.
					bool			 boundAsUCS2,			// See MDAC #78258 for reason.
					bool			 outputParameterBinding	// oracle has inconsistent behavior for output parameters.
					)
		{
			_value = MarshalToString(buffer, valueOffset, lengthOffset, metaType, connection, boundAsUCS2, outputParameterBinding);
		}


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.IsNull"]/*' />
		public bool IsNull 
		{
			get { return (null == _value); }
		}

        /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.Length"]/*' />
        public int Length {
            get {
				if (IsNull)
	    			throw ADP.DataIsNull();
	    			
                return _value.Length;
            }
        }

        /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.Value"]/*' />
        public string Value
        {
            get {
            	if (IsNull)
	    			throw ADP.DataIsNull();
    			
            	return _value; 
            }           
        }

		/// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.this"]/*' />
		public char this[int index] {
			get {
				if (IsNull)
	    			throw ADP.DataIsNull();

				return _value[index];
			}
		}
		
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.CompareTo"]/*' />
		public int CompareTo(
		  	object obj
			)
		{
			if (obj.GetType() == typeof(OracleString))
			{
	            OracleString s = (OracleString)obj;

	            // If both values are Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return s.IsNull ? 0  : -1;

                if (s.IsNull)
                    return 1;

				// Neither value is null, do the comparison.
	            return CultureInfo.CurrentCulture.CompareInfo.Compare(_value, s._value);
			}

			// Wrong type!
			throw ADP.Argument();
		}

 		/// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.Equals"]/*' />
        public override bool Equals(object value) 
        {
            if (value is OracleString)
            	return (this == (OracleString)value).Value;
            else
                return false;
        }

		static internal int GetChars(
				NativeBuffer	 buffer, 
				int 			 valueOffset, 
				int 			 lengthOffset, 
				MetaType		 metaType, 
				OracleConnection connection,			// See MDAC #78258 for reason.
				bool			 boundAsUCS2,			// See MDAC #78258 for reason.
				int				 sourceOffset,
				char[]			 destinationBuffer,
				int				 destinationOffset,
				int				 charCount
				)
		{
			// This static method allows the GetChars type getter to do it's job
			// without having to marshal the entire value into managed space.

			if (boundAsUCS2)
			{
				HandleRef	sourceBuffer;
			
				if (!metaType.IsLong)
					sourceBuffer = buffer.PtrOffset(valueOffset + (ADP.CharSize * sourceOffset));
				else
				{
					// Long values are bound out-of-line, which means we have
					// to do this the hard way...
					sourceBuffer = buffer.PtrOffset(valueOffset);
					IntPtr longBuffer = Marshal.ReadIntPtr((IntPtr)sourceBuffer);

					if (0 != sourceOffset)
						longBuffer = new IntPtr(longBuffer.ToInt64() + (long)(ADP.CharSize * sourceOffset));
					
					HandleRef newSourceBuffer = new HandleRef(sourceBuffer.Wrapper, longBuffer);
					sourceBuffer = newSourceBuffer;
				}

				Marshal.Copy((IntPtr)sourceBuffer, destinationBuffer, destinationOffset, charCount );
			}
			else
			{
				// In the odd case that we don't have a Unicode value (see MDAC #78258 
				// for the reason) we have to do this the hard way -- get the full value,
				// then copy the data...
				string	value = MarshalToString(buffer, valueOffset, lengthOffset, metaType, connection, boundAsUCS2, false);
				int		valueLength = value.Length;
				int		resultLength = (sourceOffset + charCount) > valueLength ? valueLength - sourceOffset : charCount;
				char[] 	result = value.ToCharArray(sourceOffset, resultLength);
				Buffer.BlockCopy(result, 0, destinationBuffer, (destinationOffset * ADP.CharSize), (resultLength * ADP.CharSize));
				charCount = resultLength;
			}
			GC.KeepAlive(buffer);
			return charCount;
		}

		/// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.GetHashCode"]/*' />
        public override int GetHashCode() 
        {
            return IsNull ? 0 : _value.GetHashCode();
        }
		
		static internal int GetLength(
					NativeBuffer 		buffer,
					int					lengthOffset,
					MetaType			metaType
					)
		{
			// Get the length of the data bound
			int length;

			HandleRef	lengthBuffer = buffer.PtrOffset(lengthOffset);

			// Oracle only will write two bytes of length, but LONG data types
			// can exceed that amount; our piecewise callbacks will write a
			// full DWORD of length, so we need to get the full length for them,
			// but if we do that for all the other types, we'll be reading 
			// un-initialized memory and bad things happen.
			if (metaType.IsLong)
				length = Marshal.ReadInt32((IntPtr)lengthBuffer);
			else
				length = (int)Marshal.ReadInt16((IntPtr)lengthBuffer);

			GC.KeepAlive(buffer);
			return length;
		}

		static internal string MarshalToString(
				NativeBuffer	 buffer, 
				int 			 valueOffset, 
				int 			 lengthOffset, 
				MetaType		 metaType, 
				OracleConnection connection,
				bool			 boundAsUCS2,
				bool			 outputParameterBinding
				)
		{
			int 	valueLength = GetLength(buffer, lengthOffset, metaType);
			IntPtr	valueBuffer = (IntPtr)buffer.PtrOffset(valueOffset);

			// Long values are bound out-of-line
			if (metaType.IsLong && !outputParameterBinding)
				valueBuffer = (IntPtr)Marshal.ReadIntPtr(valueBuffer);

			if (boundAsUCS2 && outputParameterBinding)
				valueLength /= 2;

			string result;

			if (boundAsUCS2)
				result = Marshal.PtrToStringUni(valueBuffer, valueLength);
			else
				result = connection.GetString (valueBuffer, valueLength, metaType.UsesNationalCharacterSet);

			GC.KeepAlive(buffer);
			return result;
		}

		static internal int MarshalToNative(
					object value, 
					int offset,
					int	size,
					HandleRef buffer,
					OCI.DATATYPE ociType, 
					bool bindAsUCS2
					)
		{
			Encoding	encoding = (bindAsUCS2) ? System.Text.Encoding.Unicode : System.Text.Encoding.UTF8;
			string		from;
			string		fromString;

			// Get the actual CLR String value from the object
			if ( value is OracleString )
				from = ((OracleString)value)._value;
			else
				from = (string)value;

			// Pick out the substring they've asked for with offset and size
			if (0 == offset && 0 == size)
				fromString = from;
			else if (0 == size || (offset+size) > from.Length)
				fromString = from.Substring(offset);
			else
				fromString = from.Substring(offset,size);

			byte[] frombytes = encoding.GetBytes(fromString);
			
			int dataSize	 = frombytes.Length;
			int charCount	 = dataSize;
			int adjust		 = 0;
			IntPtr	to		 = (IntPtr)buffer;
			
			if (bindAsUCS2)
			{
				Debug.Assert(0 == (dataSize & 0x1), "odd number of bytes in a Unicode string?");
				charCount /= 2;	// Need to adjust for number of UCS2 characters
			}
				
			if ( OCI.DATATYPE.LONGVARCHAR == ociType )
			{
				Marshal.WriteInt32(to, charCount);
				adjust = 4;
				to = new IntPtr(to.ToInt64() + adjust);
			}
			else
				Debug.Assert (short.MaxValue >= dataSize, "invalid size for non-LONG data?");
				
			Marshal.Copy( frombytes, 0, to, dataSize);
			return dataSize + adjust;
		}

        /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.ToString"]/*' />
		public override string ToString()
		{
			if (IsNull)
				return Res.GetString(Res.SqlMisc_NullString);
			
			return _value;
		}
		

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Operators 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
        // Alternative method for operator +
        /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.Concat"]/*' />
        public static OracleString Concat(OracleString x, OracleString y)
        {
            return (x + y);
        }

        // Alternative method for operator ==
        /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.Equals1"]/*' />
        public static OracleBoolean Equals(OracleString x, OracleString y)
        {
            return (x == y);
        }

        // Alternative method for operator >
        /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.GreaterThan"]/*' />
        public static OracleBoolean GreaterThan(OracleString x, OracleString y)
        {
            return (x > y);
        }

        // Alternative method for operator >=
        /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.GreaterThanOrEqual"]/*' />
        public static OracleBoolean GreaterThanOrEqual(OracleString x, OracleString y)
        {
            return (x >= y);
        }

        // Alternative method for operator <
        /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.LessThan"]/*' />
        public static OracleBoolean LessThan(OracleString x, OracleString y)
        {
            return (x < y);
        }

        // Alternative method for operator <=
        /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.LessThanOrEqual"]/*' />
        public static OracleBoolean LessThanOrEqual(OracleString x, OracleString y)
        {
            return (x <= y);
        }

        // Alternative method for operator !=
        /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.NotEquals"]/*' />
        public static OracleBoolean NotEquals(OracleString x, OracleString y)
        {
            return (x != y);
        }
        
		/// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.operatorOracleString"]/*' />
        public static implicit operator OracleString(string s) 
        {
          	return new OracleString(s);
        }
 		
 		/// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.operatorString"]/*' />
        public static explicit operator String(OracleString x) 
        {
        	return x.Value;
        }



        /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.operator+"]/*' />
        public static OracleString operator+	(OracleString x, OracleString y) 
		{
			if (x.IsNull || y.IsNull)
			    return Null;

			OracleString	result = new OracleString(x._value + y._value);
			return result;
		}

		/// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.operatorEQ"]/*' />
        public static OracleBoolean operator==	(OracleString x, OracleString y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) == 0);
        }

		/// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.operatorGT"]/*' />
		public static OracleBoolean operator>	(OracleString x, OracleString y)
		{
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) > 0);
		}

        /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.operatorGE"]/*' />
        public static OracleBoolean operator>=	(OracleString x, OracleString y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) >= 0);
        }

        /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.operatorLT"]/*' />
        public static OracleBoolean operator<	(OracleString x, OracleString y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) < 0);
        }

        /// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.operatorLE"]/*' />
        public static OracleBoolean operator<=	(OracleString x, OracleString y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) <= 0);
        }

 		/// <include file='doc\OracleString.uex' path='docs/doc[@for="OracleString.operatorNE"]/*' />
		public static OracleBoolean operator!=	(OracleString x, OracleString y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) != 0);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracletransaction.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleTransaction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Data;
	using System.EnterpriseServices;
	using System.Runtime.InteropServices;

	//----------------------------------------------------------------------
	// OracleTransaction
	//
	//	Implements the Oracle Transaction object, which handles local
	//	transaction requests
	//
    /// <include file='doc\OracleTransaction.uex' path='docs/doc[@for="OracleTransaction"]/*' />
	sealed public class OracleTransaction : MarshalByRefObject, IDbTransaction
	{

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Fields 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
		private OracleConnection	_connection;
		private int					_connectionCloseCount;	// The close count of the connection; used to decide if we're zombied
 		private IsolationLevel		_isolationLevel = IsolationLevel.ReadCommitted;
		
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Constructors 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
 
		internal OracleTransaction(
			OracleConnection	connection
			) : this (connection, IsolationLevel.Unspecified) {}

		internal OracleTransaction(
			OracleConnection	connection,
			IsolationLevel		isolationLevel
			) 
		{
			if (OracleConnection.TransactionState.GlobalStarted == connection.TransState)
				throw ADP.NoLocalTransactionInDistributedContext();
		
 			_connection				= connection;
 			_connectionCloseCount	= connection.CloseCount;
 			_isolationLevel			= isolationLevel;

			// Tell oracle what the isolation level should be.
	 		switch (isolationLevel)
			{
			case IsolationLevel.Unspecified:
				// Take whatever we get from the server
				break;
				
			case IsolationLevel.ReadCommitted:
				{
					
				// DEVNOTE: Most often, this is the default, but it is configurable on the server; 
				//			we should avoid the roundtrip if we can figure out whether this is really
				//			the default.
				OracleCommand cmd = Connection.CreateCommand();
				cmd.CommandText = "set transaction isolation level read committed";
				cmd.ExecuteNonQuery();
				cmd.Dispose();
				cmd = null;
				}
				break;

			case IsolationLevel.Serializable:
				{
				OracleCommand cmd = Connection.CreateCommand();
				cmd.CommandText = "set transaction isolation level serializable";
				cmd.ExecuteNonQuery();
				cmd.Dispose();
				cmd = null;
				}
				break;

			default:
				throw ADP.UnsupportedIsolationLevel();
			}

 			_connection.TransState = OracleConnection.TransactionState.LocalStarted;
 		}
		

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleTransaction.uex' path='docs/doc[@for="OracleTransaction.Connection1"]/*' />
		IDbConnection IDbTransaction.Connection 
		{
			get { return Connection; }
 		}

        /// <include file='doc\OracleTransaction.uex' path='docs/doc[@for="OracleTransaction.Connection2"]/*' />
		public OracleConnection Connection 
		{
			get { return _connection; }
 		}

        /// <include file='doc\OracleTransaction.uex' path='docs/doc[@for="OracleTransaction.IsolationLevel"]/*' />
		public IsolationLevel IsolationLevel 
		{
			get
			{
				AssertNotCompleted();

				if (IsolationLevel.Unspecified == _isolationLevel)
				{
					OracleCommand cmd = Connection.CreateCommand();
					cmd.Transaction = this;
					cmd.CommandText = "select decode(value,'FALSE',0,1) from V$SYSTEM_PARAMETER where name = 'serializable'";
					Decimal x = (Decimal)cmd.ExecuteScalar();
					cmd.Dispose();
					cmd = null;
					
					if (0 == x)
						_isolationLevel = IsolationLevel.ReadCommitted;
					else
						_isolationLevel = IsolationLevel.Serializable;
				}
				return _isolationLevel; 
			}
 		}


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

 		private void AssertNotCompleted()
		{
			if (null == Connection || _connectionCloseCount != Connection.CloseCount)
				throw ADP.TransactionCompleted();
 		}

        /// <include file='doc\OracleTransaction.uex' path='docs/doc[@for="OracleTransaction.Commit"]/*' />
		public void Commit()
		{
			OracleConnection.OraclePermission.Demand();
			
			AssertNotCompleted();
			Connection.Commit();
			Dispose(true);
		}
		
        /// <include file='doc\OracleTransaction.uex' path='docs/doc[@for="OracleTransaction.Dispose"]/*' />
		public void Dispose() 
		{
			Dispose(true);
		}

		private void Dispose(bool disposing) 
		{
			if (disposing)
			{
				if ( null != Connection )
					Connection.Rollback();

				_connection = null;
			}
		}

        /// <include file='doc\OracleTransaction.uex' path='docs/doc[@for="OracleTransaction.Rollback"]/*' />
		public void Rollback()
		{
			AssertNotCompleted();
			Dispose(true);
		}
 	};
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\tempenvironment.cs ===
//----------------------------------------------------------------------
// <copyright file="TempEnvironment.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Security;
	using System.Security.Permissions;

	//----------------------------------------------------------------------
	// TempEnvironment
	//
	//	Temporary Environment, used to get temporary handles so we don't 
	//	have to pass the environment handle everywhere.
	//
	sealed internal class TempEnvironment
	{
		static private OciHandle		environmentHandle;
		static private OciHandle		availableErrorHandle;		// TODO: probably need a pool here
		static private bool				isInitialized;
		static private object			locked = new object();

		static void Initialize()
		{
			lock (locked) 
			{
				if (!isInitialized)
				{
					bool		unicode = false;
					IntPtr		envhp;
					OCI.MODE	environmentMode = (OCI.MODE.OCI_THREADED | OCI.MODE.OCI_OBJECT);	// NOTE: cannot be NO_MUTEX because we might be multi-threaded.
					
					//1 TODO: we only use this environment handle in the OracleNumber class, 
					//1 which doesn't have logic to determine whether we need Unicode or not;  
					//1 we should modify OracleNumber to have that logic, but it's only for 
					//1 consistency -- nothing will break

		#if NEVER
					if (OCI.ClientVersionAtLeastOracle9i)
					{
						unicode = true;
						environmentMode |= OCI.MODE.OCI_UTF16;
					}
		#endif //0
					int rc = TracedNativeMethods.OCIEnvCreate(
						out envhp,				// envhpp
						environmentMode,		// mode
						ADP.NullHandleRef,		// ctxp
						ADP.NullHandleRef,		// malocfp
						ADP.NullHandleRef,		// ralocfp
						ADP.NullHandleRef,		// mfreefp
						0,						// xtramemsz
						ADP.NullHandleRef		// usrmempp
						);		

					if (rc != 0 || envhp == IntPtr.Zero)
						throw ADP.OperationFailed("OCIEnvCreate", rc);

					environmentHandle 		= new OciEnvironmentHandle(envhp, unicode);
					availableErrorHandle	= new OciErrorHandle(environmentHandle);
					isInitialized = true;
				}
			}
		}

		static internal OciHandle GetHandle(OCI.HTYPE handleType)
		{
            OracleConnection.OraclePermission.Demand();
				
			if (!isInitialized)
				Initialize();

			if (OCI.HTYPE.OCI_HTYPE_ERROR == handleType)
				return availableErrorHandle;		// TODO: we probably have thread-safety issues here; can we get some thread affinity?

			return environmentHandle.CreateOciHandle(handleType);
		}
		
	}
		
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\safenativemethods.cs ===
//----------------------------------------------------------------------
// <copyright file="SafeNativeMethods.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Runtime.InteropServices;

	[ System.Security.SuppressUnmanagedCodeSecurityAttribute() ]
	
	sealed internal class SafeNativeMethods 
	{
        [DllImport(ExternDll.Kernel32)]
        static internal extern IntPtr CreateEvent(IntPtr a, int b, int c, IntPtr d);

        [DllImport(ExternDll.Kernel32)]
        static internal extern IntPtr CreateSemaphore(IntPtr a, int b, int c, IntPtr d);

        [DllImport(ExternDll.Kernel32)]
        static internal extern int FreeLibrary(IntPtr hModule);

 		[DllImport(ExternDll.Kernel32, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true)]
        static internal extern IntPtr LoadLibraryExA( [In, MarshalAs(UnmanagedType.LPStr)] string lpFileName, IntPtr hfile, int dwFlags );

        [DllImport(ExternDll.Kernel32)]
        static internal extern int SetEvent(IntPtr handle);

        [DllImport(ExternDll.Kernel32)]
        static internal extern int ReleaseSemaphore(IntPtr hSem, int releaseCount, IntPtr pPrevCount);

        [DllImport(ExternDll.Kernel32)]
        static internal extern int ResetEvent(IntPtr handle);

		[DllImport(ExternDll.Kernel32, PreserveSig=true)]
		static internal extern void ZeroMemory(IntPtr dest, int length);

#if RETAILTRACING
//Useful for debugging in retail bits/runtimes.
		[DllImport(ExternDll.Kernel32)]
		static internal extern void OutputDebugStringW
			(
			[In, MarshalAs(UnmanagedType.LPWStr)]
			string lpOutputString
			);
#endif //RETAILTRACING
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\oracletimespan.cs ===
//----------------------------------------------------------------------
// <copyright file="OracleTimeSpan.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
	using System;
	using System.Data.SqlTypes;
	using System.Diagnostics;
	using System.Globalization;
	using System.Runtime.InteropServices;

	//----------------------------------------------------------------------
	// OracleTimeSpan
	//
	//	This class implements support for the Oracle 9i 'INTERVAL DAY TO SECOND'
	//	internal data type.
	//
    /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan"]/*' />
    [StructLayout(LayoutKind.Sequential, Pack=1)]
	public struct OracleTimeSpan : IComparable, INullable
	{

		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Fields
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		private byte[] _value;

		private const int  FractionalSecondsPerTick	= 100;	

        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.MaxValue"]/*' />
        public static readonly OracleTimeSpan MaxValue = new OracleTimeSpan(TimeSpan.MaxValue);

        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.MinValue"]/*' />
        public static readonly OracleTimeSpan MinValue = new OracleTimeSpan(TimeSpan.MinValue);
    
        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.Null"]/*' />
        public static readonly OracleTimeSpan Null = new OracleTimeSpan(true);
		
		
		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Constructors
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

		// Construct from nothing -- the value will be null
		private OracleTimeSpan(bool isNull)
		{	
			_value = null;
		}

		// Construct from System.TimeSpan type
        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.OracleTimeSpan2"]/*' />
		public OracleTimeSpan (TimeSpan ts)
		{
			_value = new byte[11];
			Pack(_value, ts.Days, ts.Hours, ts.Minutes, ts.Seconds, (int)(ts.Ticks % TimeSpan.TicksPerSecond) * FractionalSecondsPerTick);
		}
		
		/// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.OracleTimeSpan3"]/*' />
		public OracleTimeSpan (Int64 ticks)
	 	{ 
			_value = new byte[11];
			TimeSpan ts = new TimeSpan(ticks);
			Pack(_value, ts.Days, ts.Hours, ts.Minutes, ts.Seconds, (int)(ts.Ticks % TimeSpan.TicksPerSecond) * FractionalSecondsPerTick);
		}

       /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.OracleTimeSpan4"]/*' />
		public OracleTimeSpan (Int32 hours, Int32 minutes, Int32 seconds)  
				: this (0, hours, minutes, seconds, 0) {}

        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.OracleTimeSpan5"]/*' />
		public OracleTimeSpan (Int32 days, Int32 hours, Int32 minutes, Int32 seconds)  
				: this (days, hours, minutes, seconds, 0) {}

        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.OracleTimeSpan6"]/*' />
		public OracleTimeSpan (Int32 days, Int32 hours, Int32 minutes, Int32 seconds, Int32 milliseconds)
		{
			_value = new byte[11];
			Pack(_value, days, hours, minutes, seconds, (int)(milliseconds * TimeSpan.TicksPerMillisecond) * FractionalSecondsPerTick);
		}

		// Copy constructor
        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.OracleTimeSpan7"]/*' />
		public OracleTimeSpan (OracleTimeSpan from)  
		{
			_value = new byte[from._value.Length];
			from._value.CopyTo(_value, 0);
		}

        // (internal) construct from a row/parameter binding
 		internal OracleTimeSpan(
					NativeBuffer 		buffer, 
					int					valueOffset) : this (true)
		{
			_value = new byte[11];
			Marshal.Copy((IntPtr)buffer.PtrOffset(valueOffset), _value, 0, 11);
		}

		static private void Pack (
						byte[] spanval, 
						int days, 
						int hours, 
						int minutes, 
						int seconds, 
						int fsecs)  
		{
			days	= (int)((long)(days) + 0x80000000);
			fsecs	= (int)((long)(fsecs) + 0x80000000);

			// DEVNOTE: undoubtedly, this is Intel byte order specific, but how 
			//			do I verify what Oracle needs on a non Intel machine?

			spanval[0] = (byte)((days >> 24));
			spanval[1] = (byte)((days >> 16) & 0xff);
			spanval[2] = (byte)((days >>  8) & 0xff);
			spanval[3] = (byte)(days & 0xff);
			spanval[4] = (byte)(hours   + 60);
			spanval[5] = (byte)(minutes + 60);
			spanval[6] = (byte)(seconds + 60);
			spanval[7] = (byte)((fsecs >> 24));
			spanval[8] = (byte)((fsecs >> 16) & 0xff);
			spanval[9] = (byte)((fsecs >>  8) & 0xff);
			spanval[10]= (byte)(fsecs & 0xff);
		}

		static private void Unpack (
						byte[] spanval, 
						out int days,
						out int hours,
						out int minutes,
						out int seconds,
						out int fsecs)
		{
				// DEVNOTE: undoubtedly, this is Intel byte order specific, but how 
				//			do I verify what Oracle needs on a non Intel machine?

				days	= (int)(  (long)( (int)spanval[0] << 24
											| (int)spanval[1] << 16
											| (int)spanval[2] <<  8
											| (int)spanval[3]
											) - 0x80000000);

				hours	= (int)spanval[4] - 60;
				minutes = (int)spanval[5] - 60;
				seconds = (int)spanval[6] - 60;
				fsecs	= (int)(  (long)( (int)spanval[7] << 24
											| (int)spanval[8] << 16
											| (int)spanval[9] <<  8
											| (int)spanval[10]
											) - 0x80000000);

		}


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Properties 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.IsNull"]/*' />
		public bool IsNull 
		{
			get { return (null == _value); }
		}

        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.Value"]/*' />
        public TimeSpan Value
        {
            get
            {
            	if (IsNull)
	    			throw ADP.DataIsNull();
	        	
				TimeSpan result = ToTimeSpan(_value);
				return result;
            }           
        }

        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.Days"]/*' />
        public int Days
        {
            get
            {
            	if (IsNull)
	    			throw ADP.DataIsNull();

	        	int day, hour, minute, second, fsec;

	        	Unpack( _value,	out day, out hour, out minute, out second, out fsec);
				return day;
            }           
        }

        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.Hours"]/*' />
        public int Hours
        {
            get
            {
            	if (IsNull)
	    			throw ADP.DataIsNull();

	        	int day, hour, minute, second, fsec;

	        	Unpack( _value,	out day, out hour, out minute, out second, out fsec);
				return hour;
            }           
        }

        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.Minutes"]/*' />
        public int Minutes
        {
            get
            {
            	if (IsNull)
	    			throw ADP.DataIsNull();

	        	int day, hour, minute, second, fsec;

	        	Unpack( _value,	out day, out hour, out minute, out second, out fsec);
				return minute;
            }           
        }

        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.Seconds"]/*' />
        public int Seconds
        {
            get
            {
            	if (IsNull)
	    			throw ADP.DataIsNull();

	        	int day, hour, minute, second, fsec;

	        	Unpack( _value,	out day, out hour, out minute, out second, out fsec);
				return second;
            }           
        }

        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.Milliseconds"]/*' />
        public int Milliseconds
        {
            get
            {
            	if (IsNull)
	    			throw ADP.DataIsNull();

	        	int day, hour, minute, second, fsec;

	        	Unpack( _value,	out day, out hour, out minute, out second, out fsec);
				
				int milliseconds = (int)((fsec / FractionalSecondsPerTick) / TimeSpan.TicksPerMillisecond);
				return milliseconds;
            }           
        }


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Methods 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////

        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.CompareTo"]/*' />
		public int CompareTo(
		  	object obj
			)
		{
			if (obj.GetType() == typeof(OracleTimeSpan))
			{
	            OracleTimeSpan odt = (OracleTimeSpan)obj;

	            // If both values are Null, consider them equal.
                // Otherwise, Null is less than anything.
                if (IsNull)
                    return odt.IsNull ? 0  : -1;

                if (odt.IsNull)
                    return 1;

				// Neither value is null, do the comparison.

	        	int days1, hours1, minutes1, seconds1, fsecs1;
	        	int days2, hours2, minutes2, seconds2, fsecs2;

	        	Unpack( _value,		out days1, out hours1, out minutes1, out seconds1, out fsecs1);
	        	Unpack( odt._value,	out days2, out hours2, out minutes2, out seconds2, out fsecs2);

				int delta;

				delta = (days1 - days2);		if (0 != delta) return delta;
				delta = (hours1 - hours2);		if (0 != delta) return delta;
				delta = (minutes1 - minutes2);	if (0 != delta) return delta;
				delta = (seconds1 - seconds2);	if (0 != delta) return delta;
				delta = (fsecs1 - fsecs2);		if (0 != delta) return delta;
				return 0;
			}

			// Wrong type!
			throw ADP.Argument();
		}

		/// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.Equals"]/*' />
        public override bool Equals(object value) 
        {
            if (value is OracleTimeSpan)
            	return (this == (OracleTimeSpan)value).Value;
            else
                return false;
        }

 		/// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.GetHashCode"]/*' />
        public override int GetHashCode() 
        {
            return IsNull ? 0 : _value.GetHashCode();
        }

		static internal TimeSpan MarshalToTimeSpan(
						NativeBuffer buffer, 
						int			 valueOffset)
		{
			byte[] rawValue = new byte[11];
			Marshal.Copy((IntPtr)buffer.PtrOffset(valueOffset), rawValue, 0, 11);

			TimeSpan result = ToTimeSpan(rawValue);
			return result;
		}
		
		static internal int MarshalToNative(object value, HandleRef buffer)
		{
			byte[] from;
			
			if ( value is OracleTimeSpan )
				from = ((OracleTimeSpan)value)._value;
			else
			{
				TimeSpan ts = (TimeSpan)value;
				from = new byte[11];
				Pack(from, ts.Days, ts.Hours, ts.Minutes, ts.Seconds, (int)(ts.Ticks % TimeSpan.TicksPerSecond) * FractionalSecondsPerTick);
			}
			
			Marshal.Copy(from, 0, (IntPtr)buffer, 11);
			return 11;
		}

        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.Parse"]/*' />
		public static OracleTimeSpan Parse(string s)
		{
			TimeSpan ts = TimeSpan.Parse(s);
			return new OracleTimeSpan(ts);
		}
		
        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.ToString"]/*' />
		public override string ToString()
		{
			if (IsNull)
				return Res.GetString(Res.SqlMisc_NullString);
			
			string retval = Value.ToString();
			return retval;
		}

		static private TimeSpan ToTimeSpan(byte[] rawValue)
		{
			int days, hours, minutes, seconds, fsecs;
        	Unpack( rawValue, out days, out hours, out minutes, out seconds, out fsecs);

			long tickcount = (days		* TimeSpan.TicksPerDay)
							+ (hours	* TimeSpan.TicksPerHour)
							+ (minutes	* TimeSpan.TicksPerMinute)
							+ (seconds	* TimeSpan.TicksPerSecond);

			if (fsecs < 100 || fsecs > 100)
			{
				// DEVNOTE: Yes, there's a mismatch in the precision between Oracle,
				//			(which has 9 digits) and System.TimeSpan (which has 7
				//			digits);  All the other providers truncate the precision,
				//			so we do as well.
				tickcount += ((long)fsecs / 100);
			}

			TimeSpan result = new TimeSpan(tickcount);
			return result;
		}


		////////////////////////////////////////////////////////////////////////
 		////////////////////////////////////////////////////////////////////////
 		//
		// Operators 
		//
		////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////
		
        // Alternative method for operator ==
        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.Equals1"]/*' />
        public static OracleBoolean Equals(OracleTimeSpan x, OracleTimeSpan y)
        {
            return (x == y);
        }

        // Alternative method for operator >
        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.GreaterThan"]/*' />
        public static OracleBoolean GreaterThan(OracleTimeSpan x, OracleTimeSpan y)
        {
            return (x > y);
        }

        // Alternative method for operator >=
        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.GreaterThanOrEqual"]/*' />
        public static OracleBoolean GreaterThanOrEqual(OracleTimeSpan x, OracleTimeSpan y)
        {
            return (x >= y);
        }

        // Alternative method for operator <
        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.LessThan"]/*' />
        public static OracleBoolean LessThan(OracleTimeSpan x, OracleTimeSpan y)
        {
            return (x < y);
        }

        // Alternative method for operator <=
        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.LessThanOrEqual"]/*' />
        public static OracleBoolean LessThanOrEqual(OracleTimeSpan x, OracleTimeSpan y)
        {
            return (x <= y);
        }

        // Alternative method for operator !=
        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.NotEquals"]/*' />
        public static OracleBoolean NotEquals(OracleTimeSpan x, OracleTimeSpan y)
        {
            return (x != y);
        }

 		/// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.operatorTimeSpan"]/*' />
        public static explicit operator TimeSpan(OracleTimeSpan x) 
        {
        	if (x.IsNull)
    			throw ADP.DataIsNull();
       			
            return x.Value;
        }

        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.operatorOracleTimeSpan"]/*' />
        public static explicit operator OracleTimeSpan(string x) 
        {
            return OracleTimeSpan.Parse(x);
        }


		/// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.operatorEQ"]/*' />
        public static OracleBoolean operator==	(OracleTimeSpan x, OracleTimeSpan y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) == 0);
        }

		/// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.operatorGT"]/*' />
		public static OracleBoolean operator>	(OracleTimeSpan x, OracleTimeSpan y)
		{
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) > 0);
		}

        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.operatorGE"]/*' />
        public static OracleBoolean operator>=	(OracleTimeSpan x, OracleTimeSpan y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) >= 0);
        }

        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.operatorLT"]/*' />
        public static OracleBoolean operator<	(OracleTimeSpan x, OracleTimeSpan y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) < 0);
        }

        /// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.operatorLE"]/*' />
        public static OracleBoolean operator<=	(OracleTimeSpan x, OracleTimeSpan y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) <= 0);
        }

 		/// <include file='doc\OracleTimeSpan.uex' path='docs/doc[@for="OracleTimeSpan.operatorNE"]/*' />
		public static OracleBoolean operator!=	(OracleTimeSpan x, OracleTimeSpan y)
        {
            return (x.IsNull || y.IsNull) ? OracleBoolean.Null : new OracleBoolean(x.CompareTo(y) != 0);
        }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\tracednativemethods.cs ===
//----------------------------------------------------------------------
// <copyright file="TracedNativeMethods.cs" company="Microsoft">
//      Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{
    using System;
    using System.Diagnostics;
    using System.EnterpriseServices;
    using System.Runtime.InteropServices;
    using System.Text;

    sealed internal class TracedNativeMethods 
    {
#if DEBUG
        private static bool _traceOciCalls;

        static TracedNativeMethods()
        {
            _traceOciCalls = AdapterSwitches.OciTracing.Enabled;
        }
        
        static private bool TraceOciCalls
        {
            get { return _traceOciCalls; }
        }
        
        //----------------------------------------------------------------------
        static internal string GetAttributeName
            (
            OciHandle       handle,
            OCI.ATTR        atype
            )
        {
            if (OCI.HTYPE.OCI_DTYPE_PARAM == handle.HandleType)
                return ((OCI.PATTR)atype).ToString();

            return atype.ToString();
        }

        //----------------------------------------------------------------------
        static internal string GetAttributeValue
            (
            OciHandle       handle,
            OCI.ATTR        atype, 
            object          value,
            int             size
            )
        {
            if (value is IntPtr)
            {
                if (OCI.ATTR.OCI_ATTR_NAME == atype)
                    return String.Format("'{0}'", handle.PtrToString((IntPtr)value, size));
                
                return String.Format("0x{0}", ((IntPtr)value).ToInt64().ToString("x"));
            }
#if USEORAMTS
            if (value is byte[])
            {
                if (OCI.ATTR.OCI_ATTR_EXTERNAL_NAME == atype                    
                 || OCI.ATTR.OCI_ATTR_INTERNAL_NAME == atype) {
                    char[] temp = System.Text.Encoding.UTF8.GetChars((byte[])value, 0, size);
                    string x = new string(temp);
                    
                    return String.Format("'{0}'", x);
                }
                
                return value.ToString();
            }
#endif //USEORAMTS
            if (value is OciHandle)
            {
                return String.Format("0x{0}", ((IntPtr)((OciHandle)value).Handle).ToInt64().ToString("x"));
            }
            if (value is short)
            {
                if (OCI.ATTR.OCI_ATTR_DATA_TYPE == atype)
                    return String.Format("{0,3} {1}", (short)value, ((OCI.DATATYPE)((short)value)).ToString());
            }

            return String.Format("{0:d}", value);
        }
        //----------------------------------------------------------------------
        static internal string GetHandleType ( OCI.HTYPE htype )
        {
            return (OCI.HTYPE.OCI_DTYPE_LOB == htype) ? "OCI_DTYPE_LOB".PadRight(18) : htype.ToString().PadRight(18);
        }
        //----------------------------------------------------------------------
        static internal string GetHandleType ( OciHandle handle )
        {
            return GetHandleType(handle.HandleType);
        }
        //----------------------------------------------------------------------
        static internal string GetHandleValue ( IntPtr handle )
        {
            string result = handle.ToInt64().ToString("x");
            return result;
        }
        //----------------------------------------------------------------------
        static internal string GetHandleValue ( HandleRef handle )
        {
            return GetHandleValue((IntPtr)handle);
        }

#endif
#if USEORAMTS
        //----------------------------------------------------------------------
        static internal int OraMTSEnlCtxGet
            (
            string      userName,
            string      password,
            string      serverName,
            HandleRef   pOCISvc,
            HandleRef   pOCIErr,
            int         dwFlags,
            out IntPtr  pCtxt       // can't return a HandleRef
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OraMTSEnlCtxGet    userName={0} password=... serverName={1} pOCISvc=0x{2} pOCIErr=0x{3} dwFlags=0x{4}",
                                userName,
                                serverName,
                                pOCISvc.Handle.ToInt64().ToString("x"),
                                pOCIErr.Handle.ToInt64().ToString("x"),
                                dwFlags.ToString("x")
                            ));
#endif
            int     rc;

            byte[]  passwordBytes = System.Text.Encoding.Default.GetBytes(password);
            byte[]  userNameBytes = System.Text.Encoding.Default.GetBytes(userName);
            byte[]  serverNameBytes = System.Text.Encoding.Default.GetBytes(serverName);
            
            rc = UnsafeNativeMethods.OraMTSEnlCtxGet(userNameBytes, 
                                                    passwordBytes, 
                                                    serverNameBytes, 
                                                    pOCISvc,
                                                    pOCIErr,
                                                    dwFlags,
                                                    out pCtxt);

#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tpCtxt=0x{0} rc={1}",
                                pCtxt.ToInt64().ToString("x"),
                                rc)); 
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OraMTSEnlCtxRel
            (
            HandleRef   pCtxt 
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OraMTSEnlCtxRel    pCtxt=0x{0} ",
                                ((IntPtr)pCtxt.Handle).ToInt64().ToString("x")
                                )); 
#endif
            int rc = UnsafeNativeMethods.OraMTSEnlCtxRel(pCtxt);

#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\trc={0}",
                                rc)); 
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OraMTSOCIErrGet
            (
            ref int     dwErr,
            HandleRef   lpcEMsg,
            ref int     lpdLen
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OraMTSOCIErrGet    dwErr=0x{0} lpcEMsg=0x{1} lpdLen={2}",
                                dwErr,
                                lpcEMsg.Handle.ToInt64().ToString("x"),
                                lpdLen
                                )); 
#endif
            int rc = UnsafeNativeMethods.OraMTSOCIErrGet(ref dwErr,lpcEMsg,ref lpdLen);

#if DEBUG
            if (TraceOciCalls)
            {
                if (0 == rc)
                    Debug.WriteLine(String.Format("\trc={0}",
                                    rc)); 
                else
                {
                    string message = Marshal.PtrToStringAnsi(lpcEMsg.Handle);

                    Debug.WriteLine(String.Format("\trc={0} message={1} len={2}",
                                    rc, message, lpdLen)); 
                }
            }
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OraMTSJoinTxn
            (
            HandleRef       pCtxt,
            ITransaction    pTrans
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OraMTSJoinTxn      pCtxt=0x{0} pTrans=...",
                                pCtxt.Handle.ToInt64().ToString("x")
                                )); 
#endif
            int rc = UnsafeNativeMethods.OraMTSJoinTxn(pCtxt, pTrans);

#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\trc={0}",
                                rc)); 
#endif
            return rc;
        }
#else //!USEORAMTS
        //----------------------------------------------------------------------
        static internal int MTxOciConnectToResourceManager
            (
            string      userName,
#if USECRYPTO
            byte[]  password,
#else
            string  password,
#endif
            string      serverName,
            out IntPtr  resourceManagerProxy    // should probably be IResourceManagerProxy, but since all we really need is IUnknown.Release(), we cheat a little
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write("MTxOciConnectToResourceManager ...");
#endif
            int     rc;

#if USECRYPTO
            byte[]  passwordBytes = null;
            
            try {
                try {
                    passwordBytes = System.Text.Encoding.Convert(System.Text.Encoding.Unicode, System.Text.Encoding.Default, password);
#else
                    byte[]  passwordBytes = System.Text.Encoding.Default.GetBytes(password);
#endif
                    int     passwordLength = passwordBytes.Length;

                    byte[]  userNameBytes = System.Text.Encoding.Default.GetBytes(userName);
                    int     userNameLength = userNameBytes.Length;
                                        
                    byte[]  serverNameBytes = System.Text.Encoding.Default.GetBytes(serverName);
                    int     serverNameLength = serverNameBytes.Length;
                    
                    rc = UnsafeNativeMethods.MTxOciConnectToResourceManager(userNameBytes, 
                                                                            userNameLength, 
                                                                            passwordBytes, 
                                                                            passwordLength, 
                                                                            serverNameBytes, 
                                                                            serverNameLength, 
                                                                            out resourceManagerProxy);
#if USECRYPTO
                }
                finally {
                    ADP.ClearArray(ref passwordBytes);
                }
            }
            catch { // Prevent exception filters from running in our space
                throw;
            }
#endif

#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tresourceManagerProxy=0x{0} rc={1}",
                                resourceManagerProxy.ToInt64().ToString("x"),
                                rc)); 
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int MTxOciEnlistInTransaction
            (
            IntPtr          resourceManagerProxy,
            ITransaction    transact,
            out IntPtr      ociEnvironmentHandle,   // can't return a handle ref!
            out IntPtr      ociServiceContextHandle // can't return a handle ref!
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("MTxOciEnlistInTransaction resourceManagerProxy=0x{0} transact={1}",
                                resourceManagerProxy.ToInt64().ToString("x"),
                                transact));
#endif
            int rc = UnsafeNativeMethods.MTxOciEnlistInTransaction(resourceManagerProxy, transact, out ociEnvironmentHandle, out ociServiceContextHandle);

#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tociEnvironmentHandle=0x{1} ociServiceContextHandle=0x{2} rc={0}",
                                rc,
                                ociEnvironmentHandle.ToInt64().ToString("x"),
                                ociServiceContextHandle.ToInt64().ToString("x"))); 
#endif
            return rc;
        }
#endif //!USEORAMTS
        //----------------------------------------------------------------------
        static internal int MTxOciDefineDynamic
            (
            OciHandle                   defnp,
            OciHandle                   errhp,
            HandleRef                   octxp,
            OCI.Callback.OCICallbackDefine  ocbfp
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("MTxOciDefineDynamic defnp=0x{0} errhp=0x{1} octxp=0x{2} ocbfp={3}",
                                GetHandleValue(defnp),
                                GetHandleValue(errhp),
                                GetHandleValue(octxp),
                                ocbfp ));
#endif
            int rc = UnsafeNativeMethods.MTxOciDefineDynamic(defnp, errhp, octxp, ocbfp);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}", rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal string oermsg 
                (
                OciHandle       handle,
                short           rcode,
                NativeBuffer    buf
                )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("oermsg         rcode={0}", rcode));
#endif
            UnsafeNativeMethods.oermsg(rcode, buf.Ptr);
            string message = handle.PtrToString((IntPtr)buf.Ptr);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tbuf={0}", message));
#endif
        return message;
        }
        //----------------------------------------------------------------------
        static internal int OCIAttrGet
            (
            OciHandle       trgthndlp,
            out IntPtr      attributep,     // Used to get strings; can't return a handle ref!
            out int         sizep,
            OCI.ATTR        attrtype, 
            OciHandle       errhp
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIAttrGet         trgthndlp=0x{0} trghndltyp={1} attrtype={2,-20} errhp=0x{3}",
                                GetHandleValue(trgthndlp),
                                GetHandleType(trgthndlp),
                                GetAttributeName(trgthndlp,attrtype),
                                GetHandleValue(errhp) ));
#endif
            int rc = UnsafeNativeMethods.OCIAttrGet(trgthndlp, trgthndlp.HandleType, out attributep, out sizep, attrtype, errhp);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tattributep={0,-20} sizep={1} rc={2}",
                                GetAttributeValue(trgthndlp,attrtype,attributep,sizep),
                                sizep,
                                rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIAttrGet
            (
            OciHandle       trgthndlp,
            out byte        attributep,
            out int         sizep,
            OCI.ATTR        attrtype, 
            OciHandle       errhp
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIAttrGet         trgthndlp=0x{0} trghndltyp={1} attrtype={2,-20} errhp=0x{3}",
                                GetHandleValue(trgthndlp),
                                GetHandleType(trgthndlp),
                                GetAttributeName(trgthndlp,attrtype),
                                GetHandleValue(errhp) ));
#endif
            int rc = UnsafeNativeMethods.OCIAttrGet(trgthndlp, trgthndlp.HandleType, out attributep, out sizep, attrtype, errhp);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tattributep={0,-20} sizep={1} rc={2}",
                                GetAttributeValue(trgthndlp,attrtype,attributep,sizep),
                                sizep,
                                rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIAttrGet
            (
            OciHandle       trgthndlp,
            out short       attributep,
            out int         sizep,
            OCI.ATTR        attrtype, 
            OciHandle       errhp
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIAttrGet         trgthndlp=0x{0} trghndltyp={1} attrtype={2,-20} errhp=0x{3}",
                                GetHandleValue(trgthndlp),
                                GetHandleType(trgthndlp),
                                GetAttributeName(trgthndlp,attrtype),
                                GetHandleValue(errhp) ));
#endif
            int rc = UnsafeNativeMethods.OCIAttrGet(trgthndlp, trgthndlp.HandleType, out attributep, out sizep, attrtype, errhp);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tattributep={0,-20} sizep={1} rc={2}",
                                GetAttributeValue(trgthndlp,attrtype,attributep,sizep),
                                sizep,
                                rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIAttrGet
            (
            OciHandle       trgthndlp,
            out int         attributep,
            out int         sizep,
            OCI.ATTR        attrtype, 
            OciHandle       errhp
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIAttrGet         trgthndlp=0x{0} trghndltyp={1} attrtype={2,-20} errhp=0x{3}",
                                GetHandleValue(trgthndlp),
                                GetHandleType(trgthndlp),
                                GetAttributeName(trgthndlp,attrtype),
                                GetHandleValue(errhp) ));
#endif
            int rc = UnsafeNativeMethods.OCIAttrGet(trgthndlp, trgthndlp.HandleType, out attributep, out sizep, attrtype, errhp);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tattributep={0,-20} sizep={1} rc={2}",
                                GetAttributeValue(trgthndlp,attrtype,attributep,sizep),
                                sizep,
                                rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIAttrGet
            (
            OciHandle       trgthndlp,
            OciHandle       attributep,
            out int         sizep,
            OCI.ATTR        attrtype, 
            OciHandle       errhp
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIAttrGet         trgthndlp=0x{0} trghndltyp={1} attrtype={2,-20} errhp=0x{3}",
                                GetHandleValue(trgthndlp),
                                GetHandleType(trgthndlp),
                                GetAttributeName(trgthndlp,attrtype),
                                GetHandleValue(errhp) ));
#endif
            int rc = UnsafeNativeMethods.OCIAttrGet(trgthndlp, trgthndlp.HandleType, attributep.Handle, out sizep, attrtype, errhp);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tattributep={0,-20} sizep={1} rc={2}",
                                GetAttributeValue(trgthndlp,attrtype,attributep,sizep),
                                sizep,
                                rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIAttrSet
            (
            OciHandle   trgthndlp,
            ref int     attributep, 
            int         size,
            OCI.ATTR    attrtype,
            OciHandle   errhp
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIAttrSet         trgthndlp=0x{0} trghndltyp={1} attributep={2} size={3} attrtype={4,-20} errhp=0x{5}",
                                GetHandleValue(trgthndlp),
                                GetHandleType(trgthndlp),
                                GetAttributeValue(trgthndlp,attrtype,attributep,size),
                                size,
                                GetAttributeName(trgthndlp,attrtype),
                                GetHandleValue(errhp) ));
#endif
            int rc = UnsafeNativeMethods.OCIAttrSet(trgthndlp, trgthndlp.HandleType, ref attributep, size, attrtype, errhp);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}", rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIAttrSet
            (
            OciHandle   trgthndlp,
            OciHandle   attributep, 
            int         size,
            OCI.ATTR    attrtype,
            OciHandle   errhp
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIAttrSet         trgthndlp=0x{0} trghndltyp={1} attributep={2} size={3} attrtype={4,-20} errhp=0x{5}",
                                GetHandleValue(trgthndlp),
                                GetHandleType(trgthndlp),
                                GetAttributeValue(trgthndlp,attrtype,attributep,size),
                                size,
                                GetAttributeName(trgthndlp,attrtype),
                                GetHandleValue(errhp) ));
#endif
            int rc = UnsafeNativeMethods.OCIAttrSet(trgthndlp, trgthndlp.HandleType, attributep, size, attrtype, errhp);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}", rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIAttrSet
            (
            OciHandle   trgthndlp,
            byte[]      attributep, 
            int         size,
            OCI.ATTR    attrtype,
            OciHandle   errhp
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIAttrSet         trgthndlp=0x{0} trghndltyp={1} attributep={2} size={3} attrtype={4,-20} errhp=0x{5}",
                                GetHandleValue(trgthndlp),
                                GetHandleType(trgthndlp),
                                GetAttributeValue(trgthndlp,attrtype,attributep,size),
                                size,
                                GetAttributeName(trgthndlp,attrtype),
                                GetHandleValue(errhp) ));
#endif
            int rc = UnsafeNativeMethods.OCIAttrSet(trgthndlp, trgthndlp.HandleType, attributep, size, attrtype, errhp);

#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}",
                                    rc));
#endif
            return rc;
        }

        //----------------------------------------------------------------------
        static internal int OCIBindByName
            (
            OciHandle       stmtp,
            out IntPtr      bindpp,     // can't return a handle ref!
            OciHandle       errhp,
            string          placeholder,    
            int             placeh_len,
            HandleRef       valuep,
            int             value_sz,
            OCI.DATATYPE    dty,
            HandleRef       indp,
            HandleRef       alenp,  //ub2*
            HandleRef       rcodep, //ub2*
            int             maxarr_len,
            HandleRef       curelap,//ub4*
            OCI.MODE        mode
            )
        {
#if DEBUG
            if (TraceOciCalls)
            {
                StringBuilder spad = new StringBuilder();

                spad.Append("OCIBindByName     ");
                spad.Append(String.Format(" stmtp=0x{0}",       GetHandleValue(stmtp) ));
                spad.Append(String.Format(" errhp=0x{0}",       GetHandleValue(errhp) ));
                spad.Append(String.Format(" placeholder={0,-20}",placeholder ));
                spad.Append(String.Format(" placeh_len={0}",    placeh_len ));
                spad.Append(String.Format(" valuep=0x{0}",      GetHandleValue(valuep) ));
                spad.Append(String.Format(" value_sz={0,-4}",   value_sz ));
                spad.Append(String.Format(" dty={0,-10}",       dty ));
                spad.Append(String.Format(" indp=0x{0}",        GetHandleValue(indp) ));
                spad.Append(String.Format("[{0,2}]",            IntPtr.Zero == (IntPtr)indp ? (short)0 : Marshal.ReadInt16((IntPtr)indp) ));
                spad.Append(String.Format(" alenp=0x{0}",       GetHandleValue(alenp) ));
                spad.Append(String.Format("[{0,4}]",            IntPtr.Zero == (IntPtr)alenp? (short)0 : Marshal.ReadInt16((IntPtr)alenp) ));
                spad.Append(String.Format(" rcodep=0x{0}",      GetHandleValue(rcodep) ));
                spad.Append(String.Format(" maxarr_len={0}",    maxarr_len ));
                spad.Append(String.Format(" curelap=0x{0}",     GetHandleValue(curelap) ));
                spad.Append(String.Format(" mode={0}",          mode));

                Debug.Write(spad.ToString());
            }
#endif
            byte[]  placeholderName = stmtp.GetBytes(placeholder);
            int     placeholderNameLength = placeholderName.Length;
            
            int rc = UnsafeNativeMethods.OCIBindByName(stmtp, out bindpp, errhp, placeholderName, placeholderNameLength, valuep, value_sz, dty, indp, alenp, rcodep, maxarr_len, curelap, mode);
#if DEBUG
            if (TraceOciCalls)
            {
                Debug.WriteLine(String.Format("\tbindpp=0x{0} rc={1}", GetHandleValue(bindpp), rc));
            }
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIDefineByPos
            (
            OciHandle       stmtp,
            out IntPtr      hndlpp,     // can't return a handle ref!
            OciHandle       errhp,
            int             position,
            HandleRef       valuep,
            int             value_sz,
            OCI.DATATYPE    dty,
            HandleRef       indp,
            HandleRef       rlenp,  //ub2*
            HandleRef       rcodep, //ub2*
            OCI.MODE        mode
            )
        {
#if DEBUG
            if (TraceOciCalls)
            {
                StringBuilder spad = new StringBuilder();

                spad.Append("OCIDefineByPos    ");
                spad.Append(String.Format(" stmtp=0x{0}",       GetHandleValue(stmtp) ));
                spad.Append(String.Format(" errhp=0x{0}",       GetHandleValue(errhp) ));
                spad.Append(String.Format(" position={0,-2}",   position ));
                spad.Append(String.Format(" valuep=0x{0}",      GetHandleValue(valuep) ));
                spad.Append(String.Format(" value_sz={0,-4}",   value_sz ));
                spad.Append(String.Format(" dty={0,-10}",       dty ));
                spad.Append(String.Format(" indp=0x{0}",        GetHandleValue(indp) ));
                spad.Append(String.Format(" rlenp=0x{0}",       GetHandleValue(rlenp) ));
                spad.Append(String.Format(" rcodep=0x{0}",      GetHandleValue(rcodep) ));
                spad.Append(String.Format(" mode={0}",          mode));

                Debug.Write(spad.ToString());
            }
#endif
            int rc = UnsafeNativeMethods.OCIDefineByPos(stmtp, out hndlpp, errhp, position, valuep, value_sz, dty, indp, rlenp, rcodep, mode);
#if DEBUG
            if (TraceOciCalls)
            {
                Debug.WriteLine(String.Format("\thndlpp=0x{0} rc={1}", GetHandleValue(hndlpp), rc));
            }
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIDefineArrayOfStruct
            (
            OciHandle       defnp,
            OciHandle       errhp,
            int             pvskip,
            int             indskip,
            int             rlskip,
            int             rcskip
            )
        {
#if DEBUG
            if (TraceOciCalls)
            {
                StringBuilder spad = new StringBuilder();

                spad.Append("OCIDefineArrayOfStruct    ");
                spad.Append(String.Format(" defnp=0x{0}",       GetHandleValue(defnp) ));
                spad.Append(String.Format(" errhp=0x{0}",       GetHandleValue(errhp) ));
                spad.Append(String.Format(" pvskip={0}",        pvskip ));
                spad.Append(String.Format(" indskip={0}",       indskip ));
                spad.Append(String.Format(" rlskip={0}",        rlskip ));
                spad.Append(String.Format(" rcskip={0}",        rcskip ));

                Debug.Write(spad.ToString());
            }
#endif
            int rc = UnsafeNativeMethods.OCIDefineArrayOfStruct(defnp, errhp, pvskip, indskip, rlskip, rcskip);
#if DEBUG
            if (TraceOciCalls)
            {
                Debug.WriteLine(String.Format("\t rc={0}", rc));
            }
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIDescriptorAlloc
            (
            OciHandle   parenth,
            out IntPtr  hndlpp,     // can't return a handle ref!
            OCI.HTYPE   type,
            int         xtramemsz,
            HandleRef   usrmempp
            )

        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIDescriptorAlloc parenth=0x{0} type={1} xtramemsz={2} usrmempp=0x{3}",
                                GetHandleValue(parenth),
                                GetHandleType(type),
                                xtramemsz,
                                GetHandleValue(usrmempp)
                                ));
#endif

            int rc = UnsafeNativeMethods.OCIDescriptorAlloc(parenth, out hndlpp, type, xtramemsz, usrmempp);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\thndlpp=0x{0} rc={1}",
                                GetHandleValue(hndlpp),
                                rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIDescriptorFree
            (
            HandleRef   hndlp,
            OCI.HTYPE   type
            )

        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIDescriptorFree  hndlp=0x{0} type={1}",
                                    GetHandleValue(hndlp),
                                    GetHandleType(type)
                                    ));
#endif

            int rc = UnsafeNativeMethods.OCIDescriptorFree(hndlp, type);
#if DEBUG
            if (TraceOciCalls)
                    Debug.WriteLine(String.Format("rc={0}", rc));
#endif
            return rc;
        }
            //----------------------------------------------------------------------
        static internal int OCIEnvCreate
            (
            out IntPtr  envhpp,     // can't return a handle ref!
            OCI.MODE    mode,
            HandleRef   ctxp,
            HandleRef   malocfp,    // pointer to malloc function
            HandleRef   ralocfp,    // pointer to realloc function
            HandleRef   mfreefp,    // pointer to free function
            int         xtramemsz,
            HandleRef   usrmempp
                )

        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIEnvCreate       mode={0} ctxp={1} malocfp=0x{2} ralocfp=0x{3} mfreefp=0x{4} xtramemsz={5} usrmempp=0x{6}",
                                mode,
                                GetHandleValue(ctxp),
                                GetHandleValue(malocfp),
                                GetHandleValue(ralocfp),
                                GetHandleValue(mfreefp),
                                xtramemsz,
                                GetHandleValue(usrmempp)
                                ));
#endif

            int rc = UnsafeNativeMethods.OCIEnvCreate(out envhpp, mode, ctxp, malocfp, ralocfp, mfreefp, xtramemsz, usrmempp);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tenvhpp=0x{0} rc={1}",
                                GetHandleValue(envhpp),
                                rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIErrorGet
            (
            OciHandle   hndlp,
            int         recordno,
            HandleRef   sqlstate,
            out int     errcodep,
            HandleRef   bufp,
            int         bufsiz
            )

        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIErrorGet        hndlp=0x{0} recordno={1}, sqlstate=0x{2}, bufp=0x{3} bufsiz={4} type={5}",
                                GetHandleValue(hndlp),
                                recordno,
                                GetHandleValue(sqlstate),
                                GetHandleValue(bufp),
                                bufsiz,
                                GetHandleType(hndlp.HandleType)
                                ));
#endif

            int rc = UnsafeNativeMethods.OCIErrorGet(hndlp, recordno, sqlstate, out errcodep, bufp, bufsiz, hndlp.HandleType);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\terrcodep={0} rc={2}\r\n\t\t{1}\r\n\r\n",
                                errcodep,
                                hndlp.PtrToString((IntPtr)bufp),
                                rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIHandleAlloc
            (
            OciHandle   parenth,
            out IntPtr  hndlpp,     // can't return a handle ref!
            OCI.HTYPE   type,
            int         xtramemsz,
            HandleRef   usrmempp
            )

        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIHandleAlloc     parenth=0x{0} type={1} xtramemsz={2} usrmempp=0x{3}",
                                GetHandleValue(parenth),
                                GetHandleType(type),
                                xtramemsz,
                                GetHandleValue(usrmempp)
                                ));
#endif

            int rc = UnsafeNativeMethods.OCIHandleAlloc(parenth, out hndlpp, type, xtramemsz, usrmempp);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\thndlpp=0x{0} rc={1}",
                                GetHandleValue(hndlpp),
                                rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIHandleFree
            (
            HandleRef   hndlp,
            OCI.HTYPE   type
            )

        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIHandleFree      hndlp=0x{0} type={1}",
                                GetHandleValue(hndlp),
                                GetHandleType(type)
                                ));
#endif

            int rc = UnsafeNativeMethods.OCIHandleFree(hndlp, type);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("rc={0}", rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCILobAppend
            (
            OciHandle   svchp,
            OciHandle   errhp,
            OciHandle   dst_locp,
            OciHandle   src_locp
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCILobAppend  svchp=0x{0} errhp=0x{1} dst_locp=0x{2} src_locp=0x{3}",
                                GetHandleValue(svchp),
                                GetHandleValue(errhp),
                                GetHandleValue(dst_locp),
                                GetHandleValue(src_locp)
                                ));
#endif
            int rc = UnsafeNativeMethods.OCILobAppend(svchp, errhp, dst_locp, src_locp);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}", rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCILobClose
            (
            OciHandle   svchp,
            OciHandle   errhp,
            OciHandle   locp
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCILobClose  svchp=0x{0} errhp=0x{1} locp=0x{2}",
                                GetHandleValue(svchp),
                                GetHandleValue(errhp),
                                GetHandleValue(locp)
                                ));
#endif
            int rc = UnsafeNativeMethods.OCILobClose(svchp, errhp, locp);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}", rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCILobCopy
            (
            OciHandle   svchp,
            OciHandle   errhp,
            OciHandle   dst_locp,
            OciHandle   src_locp,
            uint        amount,
            uint        dst_offset,
            uint        src_offset
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCILobCopy  svchp=0x{0} errhp=0x{1} dst_locp=0x{2} src_locp=0x{3} amount={4} dst_offset={5} src_offset={6}",
                                GetHandleValue(svchp),
                                GetHandleValue(errhp),
                                GetHandleValue(dst_locp),
                                GetHandleValue(src_locp),
                                amount.ToString(),
                                dst_offset.ToString(),
                                src_offset.ToString()
                                ));
#endif
            int rc = UnsafeNativeMethods.OCILobCopy(svchp, errhp, dst_locp, src_locp, amount, dst_offset, src_offset);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}", rc));
#endif
            return rc;
        }

#if EXPOSELOBBUFFERING
        //----------------------------------------------------------------------
        static internal int OCILobDisableBuffering
            (
            OciHandle   svchp,
            OciHandle   errhp,
            OciHandle   locp
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCILobDisableBuffering  svchp=0x{0} errhp=0x{1} locp=0x{2}",
                                GetHandleValue(svchp),
                                GetHandleValue(errhp),
                                GetHandleValue(locp)
                                ));
#endif
            int rc = UnsafeNativeMethods.OCILobDisableBuffering(svchp, errhp, locp);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}", rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCILobEnableBuffering
            (
            OciHandle   svchp,
            OciHandle   errhp,
            OciHandle   locp
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCILobEnableBuffering  svchp=0x{0} errhp=0x{1} locp=0x{2}",
                                GetHandleValue(svchp),
                                GetHandleValue(errhp),
                                GetHandleValue(locp)
                                ));
#endif
            int rc = UnsafeNativeMethods.OCILobEnableBuffering(svchp, errhp, locp);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}", rc));
#endif
            return rc;
        }
#endif //EXPOSELOBBUFFERING
        //----------------------------------------------------------------------
        static internal int OCILobErase
            (
            OciHandle   svchp,
            OciHandle   errhp,
            OciHandle   locp,
            ref uint    amount,
            uint        offset
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCILobErase  svchp=0x{0} errhp=0x{1} locp=0x{2} amount={3} offset={4}",
                                GetHandleValue(svchp),
                                GetHandleValue(errhp),
                                GetHandleValue(locp),
                                amount.ToString(),
                                offset.ToString()
                                ));
#endif
            int rc = UnsafeNativeMethods.OCILobErase(svchp, errhp, locp, ref amount, offset);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tamount={1} rc={0}",
                                rc, amount));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCILobFileExists
            (
            OciHandle   svchp,
            OciHandle   errhp,
            OciHandle   locp,
            out int     flag
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCILobFileExists  svchp=0x{0} errhp=0x{1} locp=0x{2}",
                                GetHandleValue(svchp),
                                GetHandleValue(errhp),
                                GetHandleValue(locp)
                                ));
#endif
            int rc = UnsafeNativeMethods.OCILobFileExists(svchp, errhp, locp, out flag);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tflag={1} rc={0}", rc, flag));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCILobFileGetName
            (
            OciHandle       envhp,
            OciHandle       errhp,
            OciHandle       filep,
            HandleRef       dir_alias,
            ref short       d_length,
            HandleRef       filename,
            ref short       f_length
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCILobFileGetName  envhp=0x{0} errhp=0x{1} filep=0x{2}",
                                GetHandleValue(envhp),
                                GetHandleValue(errhp),
                                GetHandleValue(filep)
                                ));
#endif
            int rc = UnsafeNativeMethods.OCILobFileGetName(envhp, errhp, filep, dir_alias, ref d_length, filename, ref f_length);
#if DEBUG
            if (TraceOciCalls)
            {
                Debug.WriteLine(String.Format("\t rc={0}", rc));

                Debug.WriteLine(String.Format("\t\t\tdir_alias=\"{0}\" d_length={1}", 
                                envhp.PtrToString((IntPtr)dir_alias, d_length),
                                d_length
                                ));

                Debug.WriteLine(String.Format("\t\t\tfilename=\"{0}\" f_length={1}", 
                                envhp.PtrToString((IntPtr)filename, f_length),
                                f_length
                                ));
            }
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCILobFileSetName
            (
            OciHandle   envhp,
            OciHandle   errhp,
            ref IntPtr  filep,      // can't return a handle ref!
            string      dir_alias,
            short       d_length,
            string      filename,
            short       f_length
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCILobFileSetName  envhp=0x{0} errhp=0x{1} filep=0x{2} dir_alias={3} d_length={4} filename={5} f_length={6}",
                                GetHandleValue(envhp),
                                GetHandleValue(errhp),
                                GetHandleValue(filep),
                                dir_alias,
                                d_length,
                                filename,
                                f_length
                                ));
#endif
            byte[]  dirAlias = envhp.GetBytes(dir_alias);
            int     dirAliasLength = dirAlias.Length;
            byte[]  fileName = envhp.GetBytes(filename);
            int     fileNameLength = fileName.Length;
            
            int rc = UnsafeNativeMethods.OCILobFileSetName(envhp, errhp, ref filep, dirAlias, (short)dirAliasLength, fileName, (short)fileNameLength);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}", rc));
#endif
            return rc;
        }
#if EXPOSELOBBUFFERING
        //----------------------------------------------------------------------
        static internal int OCILobFlushBuffer
            (
            OciHandle   svchp,
            OciHandle   errhp,
            OciHandle   locp,
            int         flag
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCILobFlushBuffer  svchp=0x{0} errhp=0x{1} locp=0x{2} flag={3}",
                                GetHandleValue(svchp),
                                GetHandleValue(errhp),
                                GetHandleValue(locp),
                                flag
                                ));
#endif
            int rc = UnsafeNativeMethods.OCILobFlushBuffer(svchp, errhp, locp, flag);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}", rc));
#endif
            return rc;
        }
#endif //EXPOSELOBBUFFERING
        //----------------------------------------------------------------------
        static internal int OCILobGetChunkSize
            (
            OciHandle   svchp,
            OciHandle   errhp,
            OciHandle   locp,
            out uint    lenp
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCILobGetChunkSize  svchp=0x{0} errhp=0x{1} locp=0x{2}",
                                GetHandleValue(svchp),
                                GetHandleValue(errhp),
                                GetHandleValue(locp)
                                ));
#endif
            int rc = UnsafeNativeMethods.OCILobGetChunkSize(svchp, errhp, locp, out lenp);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tlen={1} rc={0}",
                                rc, lenp));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCILobGetLength
            (
            OciHandle   svchp,
            OciHandle   errhp,
            OciHandle   locp,
            out uint    lenp
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCILobGetLength  svchp=0x{0} errhp=0x{1} locp=0x{2}",
                                GetHandleValue(svchp),
                                GetHandleValue(errhp),
                                GetHandleValue(locp)
                                ));
#endif
            int rc = UnsafeNativeMethods.OCILobGetLength(svchp, errhp, locp, out lenp);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tlen={1} rc={0}",
                                rc, lenp));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCILobIsOpen
            (
            OciHandle   svchp,
            OciHandle   errhp,
            OciHandle   locp,
            out int     flag
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCILobIsOpen  svchp=0x{0} errhp=0x{1} locp=0x{2}",
                                GetHandleValue(svchp),
                                GetHandleValue(errhp),
                                GetHandleValue(locp)
                                ));
#endif
            int rc = UnsafeNativeMethods.OCILobIsOpen(svchp, errhp, locp, out flag);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tflag={1} rc={0}",
                                rc, flag));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCILobIsTemporary
            (
            OciHandle   envhp,
            OciHandle   errhp,
            OciHandle   locp,
            out int     flag
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCILobIsTemporary  envhp=0x{0} errhp=0x{1} locp=0x{2}",
                                GetHandleValue(envhp),
                                GetHandleValue(errhp),
                                GetHandleValue(locp)
                                ));
#endif
            int rc = UnsafeNativeMethods.OCILobIsTemporary(envhp, errhp, locp, out flag);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tflag={1} rc={0}",
                                rc, flag));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCILobLoadFromFile
            (
            OciHandle   svchp,
            OciHandle   errhp,
            OciHandle   dst_locp,
            OciHandle   src_locp,
            uint        amount,
            uint        dst_offset,
            uint        src_offset
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCILobLoadFromFile  svchp=0x{0} errhp=0x{1} dst_locp=0x{2} src_locp=0x{3} amount={4} dst_offset={5} src_offset={6}",
                                GetHandleValue(svchp),
                                GetHandleValue(errhp),
                                GetHandleValue(dst_locp),
                                GetHandleValue(src_locp),
                                amount.ToString(),
                                dst_offset.ToString(),
                                src_offset.ToString()
                                ));
#endif
            int rc = UnsafeNativeMethods.OCILobLoadFromFile(svchp, errhp, dst_locp, src_locp, amount, dst_offset, src_offset);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}",
                                rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCILobOpen
            (
            OciHandle   svchp,
            OciHandle   errhp,
            OciHandle   locp,
            byte        mode
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCILobOpen  svchp=0x{0} errhp=0x{1} locp=0x{2} mode={3}",
                                GetHandleValue(svchp),
                                GetHandleValue(errhp),
                                GetHandleValue(locp),
                                ((OracleLobOpenMode)mode).ToString()
                                ));
#endif
            int rc = UnsafeNativeMethods.OCILobOpen(svchp, errhp, locp, mode);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}",
                                rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCILobRead
            (
            OciHandle   svchp,
            OciHandle   errhp,
            OciHandle   locp,
            ref int     amtp,
            uint        offset,
            IntPtr      bufp,       // using pinned memory, IntPtr is OK
            int         bufl,
            HandleRef   ctxp,           
            HandleRef   cbfp,
            short       csid,
            OCI.CHARSETFORM     csfrm
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCILobRead  svchp=0x{0} errhp=0x{1} locp=0x{2} amt={3} offset={4} bufp=0x{5} bufl={6} ctxp=0x{7} cbfp=0x{8} csid={9} csfrm={10}",
                                GetHandleValue(svchp),
                                GetHandleValue(errhp),
                                GetHandleValue(locp),
                                amtp.ToString(),
                                offset.ToString(),
                                GetHandleValue(bufp),
                                bufl.ToString(),
                                GetHandleValue(ctxp),
                                GetHandleValue(cbfp),                               
                                csid.ToString(),
                                csfrm.ToString()
                                ));
#endif
            int rc = UnsafeNativeMethods.OCILobRead(svchp, errhp, locp, ref amtp, offset, bufp, bufl, ctxp, cbfp, csid, csfrm);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tamt={1} rc={0}",
                                rc, amtp));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCILobTrim
            (
            OciHandle   svchp,
            OciHandle   errhp,
            OciHandle   locp,
            uint        newlen
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCILobTrim  svchp=0x{0} errhp=0x{1} locp=0x{2} newlen={3}",
                                GetHandleValue(svchp),
                                GetHandleValue(errhp),
                                GetHandleValue(locp),
                                newlen.ToString()
                                ));
#endif
            int rc = UnsafeNativeMethods.OCILobTrim(svchp, errhp, locp, newlen);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}", rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCILobWrite
            (
            OciHandle   svchp,
            OciHandle   errhp,
            OciHandle   locp,
            ref int     amtp,
            uint        offset,
            IntPtr      bufp,       // using pinned memory, IntPtr is OK
            int         buflen,
            byte        piece,
            HandleRef   ctxp,           
            HandleRef   cbfp,
            short       csid,
            OCI.CHARSETFORM     csfrm
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCILobWrite  svchp=0x{0} errhp=0x{1} locp=0x{2} amt={3} offset={4} bufp=0x{5} buflen={6} piece={7} ctxp=0x{8} cbfp=0x{9} csid={10} csfrm={11}",
                                GetHandleValue(svchp),
                                GetHandleValue(errhp),
                                GetHandleValue(locp),
                                amtp.ToString(),
                                offset.ToString(),
                                GetHandleValue(bufp),
                                buflen.ToString(),
                                piece.ToString(),
                                GetHandleValue(ctxp),
                                GetHandleValue(cbfp),                               
                                csid.ToString(),
                                csfrm.ToString()
                                ));
#endif
            int rc = UnsafeNativeMethods.OCILobWrite(svchp, errhp, locp, ref amtp, offset, bufp, buflen, piece, ctxp, cbfp, csid, csfrm);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tamt={1} rc={0}",
                                rc, amtp));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIParamGet
            (
            OciHandle   hndlp,
            OciHandle   errhp,
            out IntPtr  paramdpp,   // can't return a handle ref!
            int         pos
            )

        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIParamGet        hndlp=0x{0} htype={1} errhp=0x{2} pos={3}",
                                GetHandleValue(hndlp),
                                GetHandleType(hndlp.HandleType),
                                GetHandleValue(errhp),
                                pos
                                ));
#endif

            int rc = UnsafeNativeMethods.OCIParamGet(hndlp, hndlp.HandleType, errhp, out paramdpp, pos);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tparamdpp=0x{0} rc={1}",
                                GetHandleValue(paramdpp),
                                rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIRowidToChar
            (
            OciHandle   rowidDesc,
            HandleRef   outbfp,
            ref short   outbflp,
            OciHandle   errhp
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIRowidToChar    rowidDesc=0x{0} outbfp=0x{1} outbflp={2} errhp=0x{3} ",
                                GetHandleValue(rowidDesc),
                                GetHandleValue(outbfp),
                                outbflp,
                                GetHandleValue(errhp)
                                ));
#endif
            int rc = UnsafeNativeMethods.OCIRowidToChar(rowidDesc, outbfp, ref outbflp, errhp);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t outbfp='{1}' rc={0}", rc, rowidDesc.PtrToString((IntPtr)outbfp, outbflp) ));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIServerAttach
            (
            OciHandle   srvhp,
            OciHandle   errhp,
            string      dblink,
            int         dblink_len,
            OCI.MODE    mode        // Must always be OCI_DEFAULT
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIServerAttach    srvhp=0x{0} errhp=0x{1} dblink={2,-15} dblink_len={3} mode={4}",
                                GetHandleValue(srvhp),
                                GetHandleValue(errhp),
                                "'"+dblink+"'",
                                dblink_len,
                                mode ));
#endif
            byte[]  dblinkValue = srvhp.GetBytes(dblink);
            int     dblinkLen = dblinkValue.Length;
            
            int rc = UnsafeNativeMethods.OCIServerAttach(srvhp, errhp, dblinkValue, dblinkLen, mode);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}", rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIServerDetach
            (
            HandleRef   srvhp,
            HandleRef   errhp,
            OCI.MODE    mode
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIServerDetach    srvhp=0x{0} errhp=0x{1} mode={2}",
                                GetHandleValue(srvhp),
                                GetHandleValue(errhp),
                                mode ));
#endif
            int rc = UnsafeNativeMethods.OCIServerDetach(srvhp, errhp, mode);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}", rc));
#endif
            return rc;
        }
            //----------------------------------------------------------------------
        static internal int OCIServerVersion
            (
            OciHandle   hndlp,
            OciHandle   errhp,
            HandleRef   bufp,
            int         bufsz,
            OCI.HTYPE   hndltype
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIServerVersion   hndlp=0x{0} errhp=0x{1} bufp=0x{2} bufsz={3} hndltype={4}",
                                    GetHandleValue(hndlp),
                                    GetHandleValue(errhp),
                                    GetHandleValue(bufp),
                                    bufsz,
                                    GetHandleType(hndltype) ));
#endif
            int rc = UnsafeNativeMethods.OCIServerVersion(hndlp, errhp, bufp, bufsz, (byte)hndltype);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\tbufp={0} rc={1}",
                                    hndlp.PtrToString((IntPtr)bufp),
                                    rc));
#endif
            return rc;
        }
            //----------------------------------------------------------------------
        static internal int OCISessionBegin
            (
            OciHandle   svchp,
            OciHandle   errhp,
            OciHandle   usrhp,
            OCI.CRED    credt,
            OCI.MODE    mode
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCISessionBegin    svchp=0x{0} errhp=0x{1} usrhp=0x{2} credt={3} mode={4}",
                                    GetHandleValue(svchp),
                                    GetHandleValue(errhp),
                                    GetHandleValue(usrhp),
                                    credt,
                                    mode ));
#endif
            int rc = UnsafeNativeMethods.OCISessionBegin(svchp, errhp, usrhp, credt, mode);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}", rc));
#endif
            return rc;
        }
            //----------------------------------------------------------------------
        static internal int OCISessionEnd
            (
            OciHandle   svchp,
            OciHandle   errhp,
            OciHandle   usrhp,
            OCI.MODE    mode
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCISessionEnd      svchp=0x{0} errhp=0x{1} usrhp=0x{2} mode={3}",
                                GetHandleValue(svchp),
                                GetHandleValue(errhp),
                                GetHandleValue(usrhp),
                                mode ));
#endif
            int rc = UnsafeNativeMethods.OCISessionEnd(svchp, errhp, usrhp, mode);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}", rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIStmtExecute
            (
            OciHandle       svchp,
            OciHandle       stmtp,
            OciHandle       errhp,
            int             iters,
            int             rowoff,
            HandleRef       snap_in,
            HandleRef       snap_out,
            OCI.MODE        mode
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIStmtExecute     svchp=0x{0} stmtp=0x{1} errhp=0x{2} iters={3} rowoff={4} snap_in=0x{5} snap_out=0x{6} mode={7}",
                                GetHandleValue(svchp),
                                GetHandleValue(stmtp),
                                GetHandleValue(errhp),
                                iters,
                                rowoff,
                                GetHandleValue(snap_in),
                                GetHandleValue(snap_out),
                                mode ));
#endif
            int rc = UnsafeNativeMethods.OCIStmtExecute(svchp, stmtp, errhp, iters, rowoff, snap_in, snap_out, mode);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}", rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIStmtFetch
            (
            OciHandle       stmtp,
            OciHandle       errhp,
            int             nrows,
            OCI.FETCH       orientation,
            OCI.MODE        mode
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCIStmtFetch       stmtp=0x{0} errhp=0x{1} nrows={2} orientation={3} mode={4}",
                                GetHandleValue(stmtp),
                                GetHandleValue(errhp),
                                nrows,
                                orientation,
                                mode ));
#endif
            int rc = UnsafeNativeMethods.OCIStmtFetch(stmtp, errhp, nrows, orientation, mode);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}", rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCIStmtPrepare
            (
            OciHandle       stmtp,
            OciHandle       errhp,
            string          stmt,
            int             stmt_len,
            OCI.SYNTAX      language,
            OCI.MODE        mode,
            OracleConnection connection
            )
        {
#if DEBUG
            if (TraceOciCalls)
            {
                Debug.Write(String.Format("OCIStmtPrepare     stmtp=0x{0} errhp=0x{1} stmt_len={3} language={4} mode={5}\r\n\t\t{2}",
                                GetHandleValue(stmtp),
                                GetHandleValue(errhp),
                                stmt,
                                stmt_len,
                                language,
                                mode ));
            }
#endif
            byte[]  statementText = connection.GetBytes(stmt, 0, stmt_len, false);
            int     statementTextLength = statementText.Length;
            
            int rc = UnsafeNativeMethods.OCIStmtPrepare(stmtp, errhp, statementText, statementTextLength, language, mode);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\r\n\t rc={0}", rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCITransCommit
            (
            OciHandle   srvhp,
            OciHandle   errhp,
            OCI.MODE    mode
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCITransCommit     srvhp=0x{0} errhp=0x{1} mode={2}",
                                GetHandleValue(srvhp),
                                GetHandleValue(errhp),
                                mode ));
#endif
            int rc = UnsafeNativeMethods.OCITransCommit(srvhp, errhp, mode);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}", rc));
#endif
            return rc;
        }
        //----------------------------------------------------------------------
        static internal int OCITransRollback
            (
            OciHandle   srvhp,
            OciHandle   errhp,
            OCI.MODE    mode
            )
        {
#if DEBUG
            if (TraceOciCalls)
                Debug.Write(String.Format("OCITransRollback   srvhp=0x{0} errhp=0x{1} mode={2}",
                                GetHandleValue(srvhp),
                                GetHandleValue(errhp),
                                mode ));
#endif
            int rc = UnsafeNativeMethods.OCITransRollback(srvhp, errhp, mode);
#if DEBUG
            if (TraceOciCalls)
                Debug.WriteLine(String.Format("\t rc={0}", rc));
#endif
            return rc;
        }
    
    };
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\dataoracleclient\system\data\oracleclient\unsafenativemethods.cs ===
//----------------------------------------------------------------------
// <copyright file="UnsafeNativeMethods.cs" company="Microsoft">
//		Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//----------------------------------------------------------------------

namespace System.Data.OracleClient
{

	using System;
	using System.EnterpriseServices;
	using System.Runtime.InteropServices;

	[ System.Security.SuppressUnmanagedCodeSecurityAttribute() ]

	sealed internal class UnsafeNativeMethods
	{
#if USEORAMTS
		[DllImport(ExternDll.OraMtsDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OraMTSEnlCtxGet 
			(
			[In, MarshalAs(UnmanagedType.LPArray)]
			byte[]		lpUname,	
			[In, MarshalAs(UnmanagedType.LPArray)]
			byte[]		lpPsswd,
			[In, MarshalAs(UnmanagedType.LPArray)]
			byte[]		lpDbnam,
			HandleRef	pOCISvc,
			HandleRef	pOCIErr,
			int			dwFlags,
			out IntPtr	pCtxt		// can't return a HandleRef
			);

		[DllImport(ExternDll.OraMtsDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OraMTSEnlCtxRel
			(
			HandleRef	pCtxt
			);

		[DllImport(ExternDll.OraMtsDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OraMTSOCIErrGet
			(
			ref int		dwErr,
			HandleRef	lpcEMsg,
			ref int		lpdLen
			);

		[DllImport(ExternDll.OraMtsDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OraMTSJoinTxn
			(
			HandleRef		pCtxt,
			ITransaction	pTrans
			);
 #else //!USEORAMTS
		[DllImport(ExternDll.MtxOciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int MTxOciGetVersion 
			(
			out int		version
			);


		[DllImport(ExternDll.MtxOci8Dll, CallingConvention=CallingConvention.Cdecl )]
		static internal extern int MTxOciConnectToResourceManager
			(
			[In, MarshalAs(UnmanagedType.LPArray)]
			byte[]		userId,
			int			userIdLength,
			[In, MarshalAs(UnmanagedType.LPArray)]
			byte[]		password,
			int			passwordLength,
			[In, MarshalAs(UnmanagedType.LPArray)]
			byte[]		server,
			int			serverLength,
			out IntPtr	resourceManagerProxy	// should probably be IResourceManagerProxy, but since all we really need is IUnknown.Release(), we cheat a little
			);

		[DllImport(ExternDll.MtxOci8Dll, CallingConvention=CallingConvention.Cdecl )]
		static internal extern int MTxOciEnlistInTransaction
			(
			IntPtr			resourceManagerProxy,
			ITransaction	transact,
			out IntPtr		ociEnvironmentHandle,	// can't return a handle ref!
			out IntPtr		ociServiceContextHandle	// can't return a handle ref!
			);
#endif //!USEORAMTS

		[DllImport(ExternDll.MtxOci8Dll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int MTxOciDefineDynamic
			(
			HandleRef					defnp,
			HandleRef					errhp,
			HandleRef					octxp,
			[MarshalAs(UnmanagedType.FunctionPtr), In] 
			OCI.Callback.OCICallbackDefine	ocbfp
			);

		[DllImport(ExternDll.MtxOci8Dll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int MTxOciGetOracleVersion
			(
			ref int	oracleVersion
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int oermsg
			(
			short		rcode,
			HandleRef	buf
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIAttrGet
			(
			HandleRef		trgthndlp,
			OCI.HTYPE		trghndltyp,
			HandleRef		attributep,
			out int			sizep,
			OCI.ATTR		attrtype, 
			HandleRef		errhp
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIAttrGet
			(
			HandleRef		trgthndlp,
			OCI.HTYPE		trghndltyp,
			out byte		attributep,
			out int			sizep,
			OCI.ATTR		attrtype, 
			HandleRef		errhp
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIAttrGet
			(
			HandleRef		trgthndlp,
			OCI.HTYPE		trghndltyp,
			out short		attributep,
			out int			sizep,
			OCI.ATTR		attrtype, 
			HandleRef		errhp
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIAttrGet
			(
			HandleRef		trgthndlp,
			OCI.HTYPE		trghndltyp,
			out int			attributep,
			out int			sizep,
			OCI.ATTR		attrtype, 
			HandleRef		errhp
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIAttrGet
			(
			HandleRef		trgthndlp,
			OCI.HTYPE		trghndltyp,
			out IntPtr		attributep,		// can't return a handle ref!
			out int			sizep,
			OCI.ATTR		attrtype, 
			HandleRef		errhp
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIAttrSet
			(
			HandleRef	trgthndlp,
			OCI.HTYPE	trghndltyp,
			HandleRef	attributep,	
			int			size,
			OCI.ATTR	attrtype,
			HandleRef	errhp
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIAttrSet
			(
			HandleRef	trgthndlp,
			OCI.HTYPE	trghndltyp,
			ref int		attributep,	
			int			size,
			OCI.ATTR	attrtype,
			HandleRef	errhp
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIAttrSet
			(
			HandleRef	trgthndlp,
			OCI.HTYPE	trghndltyp,
			[In, MarshalAs(UnmanagedType.LPArray)]
			byte[]		attributep,	
			int			size,
			OCI.ATTR	attrtype,
			HandleRef	errhp
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIBindByName
			(
			HandleRef		stmtp,
			out IntPtr		bindpp,			// can't return a handle ref!
			HandleRef		errhp,
			[In, MarshalAs(UnmanagedType.LPArray)]
			byte[]			placeholder,	
			int				placeh_len,
			HandleRef		valuep,
			int				value_sz,
			OCI.DATATYPE	dty,
			HandleRef		indp,
			HandleRef		alenp,	//ub2*
			HandleRef		rcodep, //ub2*
			int				maxarr_len,
			HandleRef		curelap,//ub4*
			OCI.MODE		mode
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCICharSetToUnicode
			(
			HandleRef		hndl,
			IntPtr			dst,		// Using pinned memory; this is OK.
			int				dstsz,
			IntPtr			src,		// Using pinned memory; this is OK.
			int				srcsz,
			out int			size
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIUnicodeToCharSet
			(
			HandleRef		hndl,
			IntPtr			dst,		// Using pinned memory; this is OK.
			int				dstsz,
			IntPtr			src,		// Using pinned memory; this is OK.
			int				srcsz,
			out int			size
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIDefineArrayOfStruct
			(
			HandleRef		defnp,
			HandleRef		errhp,
			int				pvskip,
			int				indskip,
			int				rlskip,
			int				rcskip
			);	

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIDefineByPos
			(
			HandleRef		stmtp,
			out IntPtr		hndlpp,			// can't return a handle ref!
			HandleRef		errhp,
			int				position,
			HandleRef		valuep,
			int				value_sz,
			OCI.DATATYPE	dty,
			HandleRef		indp,
			HandleRef		rlenp,  //ub2*
			HandleRef		rcodep, //ub2*
			OCI.MODE		mode
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIDescriptorAlloc
			(
			HandleRef		parenth,
			out IntPtr		descp,			// can't return a handle ref!
			OCI.HTYPE		type,
			int				xtramem_sz,
			HandleRef		usrmempp
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIDescriptorFree
			(
			HandleRef	hndlp,
			OCI.HTYPE	type
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIEnvCreate
			(
			out IntPtr	envhpp,		// can't return a handle ref!
			OCI.MODE	mode,
			HandleRef	ctxp,
			HandleRef	malocfp,	// pointer to malloc function
			HandleRef	ralocfp,	// pointer to realloc function
			HandleRef	mfreefp,	// pointer to free function
			int			xtramemsz,
			HandleRef	usrmempp
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIErrorGet
			(
			HandleRef	hndlp,
			int			recordno,
			HandleRef	sqlstate,
			out int		errcodep,
			HandleRef	bufp,
			int			bufsiz,
			OCI.HTYPE	type
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIHandleAlloc
			(
			HandleRef	parenth,
			out IntPtr	hndlpp,		// can't return a handle ref!
			OCI.HTYPE	type,
			int			xtramemsz,
			HandleRef	usrmempp
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIHandleFree
			(
			HandleRef	hndlp,
			OCI.HTYPE	type
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCILobAppend
			(
			HandleRef	svchp,
			HandleRef	errhp,
			HandleRef	dst_locp,
			HandleRef	src_locp
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCILobClose
			(
			HandleRef	svchp,
			HandleRef	errhp,
			HandleRef	locp
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCILobCopy
			(
			HandleRef	svchp,
			HandleRef	errhp,
			HandleRef	dst_locp,
			HandleRef	src_locp,
			[In, MarshalAs(UnmanagedType.U4)]				
			uint		amount,
			[In, MarshalAs(UnmanagedType.U4)]				
			uint		dst_offset,
			[In, MarshalAs(UnmanagedType.U4)]				
			uint		src_offset
			);

#if EXPOSELOBBUFFERING
		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCILobDisableBuffering
			(
			HandleRef	svchp,
			HandleRef	errhp,
			HandleRef	locp
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCILobEnableBuffering
			(
			HandleRef	svchp,
			HandleRef	errhp,
			HandleRef	locp
			);
#endif //EXPOSELOBBUFFERING

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCILobErase
			(
			HandleRef	svchp,
			HandleRef	errhp,
			HandleRef	locp,
			[In, Out, MarshalAs(UnmanagedType.U4)]				
			ref uint	amount,
			[In, MarshalAs(UnmanagedType.U4)]				
			uint		offset
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCILobFileExists
			(
			HandleRef	svchp,
			HandleRef	errhp,
			HandleRef	locp,
			out int		flag
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCILobFileGetName
			(
			HandleRef	envhp,
			HandleRef	errhp,
			HandleRef	filep,
			HandleRef	dir_alias,
			[In, Out, MarshalAs(UnmanagedType.U2)]
			ref short	d_length,
			HandleRef	filename,
			[In, Out, MarshalAs(UnmanagedType.U2)]
			ref short	f_length
			);
		
		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCILobFileSetName
			(
			HandleRef	envhp,
			HandleRef	errhp,
			ref IntPtr	filep,		// can't return a handle ref!
			[In, MarshalAs(UnmanagedType.LPArray)]
			byte[]		dir_alias,
			[In, MarshalAs(UnmanagedType.U2)]
			short		d_length,
			[In, MarshalAs(UnmanagedType.LPArray)]
			byte[]		filename,
			[In, MarshalAs(UnmanagedType.U2)]
			short		f_length
			);

#if EXPOSELOBBUFFERING
		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCILobFlushBuffer
			(
			HandleRef	svchp,
			HandleRef	errhp,
			HandleRef	locp,
			int			flag
			);			
#endif //EXPOSELOBBUFFERING

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCILobGetChunkSize
			(
			HandleRef	svchp,
			HandleRef	errhp,
			HandleRef	locp,
			[Out, MarshalAs(UnmanagedType.U4)]
			out uint	lenp
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCILobGetLength
			(
			HandleRef	svchp,
			HandleRef	errhp,
			HandleRef	locp,
			[Out, MarshalAs(UnmanagedType.U4)]
			out uint	lenp
			);
		
		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCILobIsOpen
			(
			HandleRef	svchp,
			HandleRef	errhp,
			HandleRef	locp,
			out int		flag
			);			

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCILobIsTemporary
			(
			HandleRef	envhp,
			HandleRef	errhp,
			HandleRef	locp,
			out int		flag
			);			

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCILobLoadFromFile
			(
			HandleRef	svchp,
			HandleRef	errhp,
			HandleRef	dst_locp,
			HandleRef	src_locp,
			[In, MarshalAs(UnmanagedType.U4)]				
			uint		amount,
			[In, MarshalAs(UnmanagedType.U4)]				
			uint		dst_offset,
			[In, MarshalAs(UnmanagedType.U4)]				
			uint		src_offset
			);
		
		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCILobOpen
			(
			HandleRef	svchp,
			HandleRef	errhp,
			HandleRef	locp,
			byte		mode
			);
			
		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCILobRead
			(
			HandleRef	svchp,
			HandleRef	errhp,
			HandleRef	locp,
			ref int		amtp,
			uint		offset,
			IntPtr		bufp,		// using pinned memory, IntPtr is OK
			int			bufl,
			HandleRef	ctxp,			
			HandleRef	cbfp,
			[In, MarshalAs(UnmanagedType.U2)]				
			short		csid,
			[In, MarshalAs(UnmanagedType.U1)]				
			OCI.CHARSETFORM		csfrm
			);			

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCILobTrim
			(
			HandleRef	svchp,
			HandleRef	errhp,
			HandleRef	locp,
			[In, MarshalAs(UnmanagedType.U4)]				
			uint		newlen
			);			

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCILobWrite
			(
			HandleRef	svchp,
			HandleRef	errhp,
			HandleRef	locp,
			ref int		amtp,
			uint		offset,
			IntPtr		bufp,		// using pinned memory, IntPtr is OK
			int			buflen,
			byte		piece,
			HandleRef	ctxp,			
			HandleRef	cbfp,
			[In, MarshalAs(UnmanagedType.U2)]				
			short		csid,
			[In, MarshalAs(UnmanagedType.U1)]				
			OCI.CHARSETFORM		csfrm
			);			

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberAbs
			(
			HandleRef		err,
			byte[]			number,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberAdd
			(
			HandleRef		err,
			byte[]			number1,
			byte[]			number2,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberArcCos
			(
			HandleRef		err,
			byte[]			number,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberArcSin
			(
			HandleRef		err,
			byte[]			number,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberArcTan
			(
			HandleRef		err,
			byte[]			number,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberArcTan2
			(
			HandleRef		err,
			byte[]			number1,
			byte[]			number2,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberCeil
			(
			HandleRef		err,
			byte[]			number,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberCmp
			(
			HandleRef		err,
			byte[]			number1,
			byte[]			number2,
			out int			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberCos
			(
			HandleRef		err,
			byte[]			number,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberDiv
			(
			HandleRef		err,
			byte[]			number1,
			byte[]			number2,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberExp
			(
			HandleRef		err,
			byte[]			p,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberFloor
			(
			HandleRef		err,
			byte[]			number,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberFromInt
			(
			HandleRef		err,
			ref int			inum,
			int				inum_length,
			OCI.SIGN		inum_s_flag,
			byte[]			number
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberFromInt
			(
			HandleRef		err,
			ref uint			inum,
			int				inum_length,
			OCI.SIGN		inum_s_flag,
			byte[]			number
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberFromInt
			(
			HandleRef		err,
			ref long		inum,
			int				inum_length,
			OCI.SIGN		inum_s_flag,
			byte[]			number
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberFromInt
			(
			HandleRef		err,
			ref ulong		inum,
			int				inum_length,
			OCI.SIGN		inum_s_flag,
			byte[]			number
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberFromReal
			(
			HandleRef		err,
			ref double		rnum,
			int				rnum_length,
			byte[]			number
			);

#if EVERETT
		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true)]
#else
		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
#endif
		static internal extern int OCINumberFromText
			(
			HandleRef		err,
			[In, MarshalAs(UnmanagedType.LPStr)]	// NOTE: Should be MultiByte, but UnmanagedType doesn't have it, and we don't pass user-data here.
			string			str,
			int				str_length,
			[In, MarshalAs(UnmanagedType.LPStr)]	// NOTE: Should be MultiByte, but UnmanagedType doesn't have it, and we don't pass user-data here.
			string			fmt,
			int				fmt_length,
			HandleRef		lang_name,
			int				lang_length,
			byte[]			number
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberHypCos
			(
			HandleRef		err,
			byte[]			number,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberHypSin
			(
			HandleRef		err,
			byte[]			number,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberHypTan
			(
			HandleRef		err,
			byte[]			number,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberIntPower
			(
			HandleRef		err,
			byte[]			baseNumber,
			int				exponent,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberIsInt
			(
			HandleRef		err,
			byte[]			number,
			out int			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberLn
			(
			HandleRef		err,
			byte[]			number,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberLog
			(
			HandleRef		err,
			byte[]			b,
			byte[]			number,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberMod
			(
			HandleRef		err,
			byte[]			number1,
			byte[]			number2,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberMul
			(
			HandleRef		err,
			byte[]			number1,
			byte[]			number2,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberNeg
			(
			HandleRef		err,
			byte[]			number,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberPower
			(
			HandleRef		err,
			byte[]			baseNumber,
			byte[]			exponent,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberRound
			(
			HandleRef		err,
			byte[]			number,
			int				decplace,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberShift
			(
			HandleRef		err,
			byte[]			baseNumber,
			int				nDig,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberSign
			(
			HandleRef		err,
			byte[]			number,
			out int			result
			);
#if GENERATENUMBERCONSTANTS
		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern void OCINumberSetPi
			(
			HandleRef		err,
			byte[]			number	
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern void OCINumberSetZero
			(
			HandleRef		err,
			byte[]			number
			);
#endif //GENERATENUMBERCONSTANTS
		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberSin
			(
			HandleRef		err,
			byte[]			number,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberSqrt
			(
			HandleRef		err,
			byte[]			number,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberSub
			(
			HandleRef		err,
			byte[]			number1,
			byte[]			number2,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberTan
			(
			HandleRef		err,
			byte[]			number,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberToInt
			(
			HandleRef		err,
			byte[]			number,
			int				rsl_length,
			OCI.SIGN		rsl_flag,
			out int			rsl
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberToInt
			(
			HandleRef		err,
			byte[]			number,
			int				rsl_length,
			OCI.SIGN		rsl_flag,
			out uint		rsl
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberToInt
			(
			HandleRef		err,
			byte[]			number,
			int				rsl_length,
			OCI.SIGN		rsl_flag,
			out long		rsl
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberToInt
			(
			HandleRef		err,
			byte[]			number,
			int				rsl_length,
			OCI.SIGN		rsl_flag,
			out ulong		rsl
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberToReal
			(
			HandleRef		err,
			byte[]			number,
			int				rsl_length,
			out double		rsl
			);

#if EVERETT
		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl, CharSet=CharSet.Ansi, BestFitMapping=false, ThrowOnUnmappableChar=true)]
#else
		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
#endif
		static internal extern int OCINumberToText
			(
			HandleRef		err,
			byte[]			number,
			[In, MarshalAs(UnmanagedType.LPStr)]	// NOTE: Should be MultiByte, but UnmanagedType doesn't have it, and we don't pass user-data here.
			string			fmt,
			int				fmt_length,
			HandleRef		nls_params,
			int				nls_p_length,
			ref int			buf_size,
			[In, Out, MarshalAs(UnmanagedType.LPArray)]
			byte[]			buffer
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCINumberTrunc
			(
			HandleRef		err,
			byte[]			number,
			int				decplace,
			byte[]			result
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIParamGet
			(
			HandleRef	hndlp,
			OCI.HTYPE	htype,
			HandleRef	errhp,
			out IntPtr	paramdpp,		// can't return a handle ref!
			int			pos
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIRowidToChar
			(
			HandleRef	rowidDesc,
			HandleRef	outbfp,
			ref short	outbflp,
			HandleRef	errhp
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIServerAttach
			(
			HandleRef	srvhp,
			HandleRef	errhp,
			[In, MarshalAs(UnmanagedType.LPArray)]
			byte[]		dblink,
			int			dblink_len,
			OCI.MODE	mode		// Must always be OCI_DEFAULT
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIServerDetach
			(
			HandleRef	srvhp,
			HandleRef	errhp,
			OCI.MODE	mode
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIServerVersion
			(
			HandleRef	hndlp,
			HandleRef	errhp,
			HandleRef	bufp,
			int			bufsz,
			byte		hndltype
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCISessionBegin
			(
			HandleRef	svchp,
			HandleRef	errhp,
			HandleRef	usrhp,
			OCI.CRED	credt,
			OCI.MODE	mode
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCISessionEnd
			(
			HandleRef	svchp,
			HandleRef	errhp,
			HandleRef	usrhp,
			OCI.MODE	mode
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIStmtExecute
			(
			HandleRef		svchp,
			HandleRef		stmtp,
			HandleRef		errhp,
			int				iters,
			int				rowoff,
			HandleRef		snap_in,
			HandleRef		snap_out,
			OCI.MODE		mode
			);	

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIStmtFetch
			(
			HandleRef		stmtp,
			HandleRef		errhp,
			int				nrows,
			OCI.FETCH		orientation,
			OCI.MODE		mode
			);	

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCIStmtPrepare   
			(
			HandleRef	stmtp,
			HandleRef	errhp,
			[In, MarshalAs(UnmanagedType.LPArray)]
			byte[]		stmt,
			int			stmt_len,
			OCI.SYNTAX	language,
			OCI.MODE	mode
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCITransCommit   
			(
			HandleRef	svchp,
			HandleRef	errhp,
			OCI.MODE	mode
			);

		[DllImport(ExternDll.OciDll, CallingConvention=CallingConvention.Cdecl)]
		static internal extern int OCITransRollback   
			(
			HandleRef	svchp,
			HandleRef	errhp,
			OCI.MODE	mode
			);

#if USEORAMTS
        [
        ComImport,
        Guid("3A6AD9E2-23B9-11cf-AD60-00AA00A74CCD"),
        InterfaceType(ComInterfaceType.InterfaceIsIUnknown),
        ]
        internal interface ITransactionOutcomeEvents {
            void Committed([MarshalAs(UnmanagedType.Bool)] bool fRetaining,
                           IntPtr pNewUOW,
                           Int32 hResult);
            void Aborted(IntPtr pBoidReason,
                         [MarshalAs(UnmanagedType.Bool)] bool fRetaining,
                         IntPtr pNewUOW,
                         Int32 hResult);
            void HeuristicDecision(UInt32 decision,
                                   IntPtr pBoidReason,
                                   Int32 hResult);
            void Indoubt();
        }
#endif //USEORAMTS
	};
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\arrayeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ArrayEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting.Activation;
    
    using System.Runtime.InteropServices;
    using System.ComponentModel;

    using System.Diagnostics;

    using System;
    using System.Collections;
    using Microsoft.Win32;
    using System.Drawing;
    
    using System.Drawing.Design;
    using System.Reflection;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;

    /// <include file='doc\ArrayEditor.uex' path='docs/doc[@for="ArrayEditor"]/*' />
    /// <devdoc>
    ///    <para>Edits an array of values.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ArrayEditor : CollectionEditor {

        /// <include file='doc\ArrayEditor.uex' path='docs/doc[@for="ArrayEditor.ArrayEditor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.ComponentModel.Design.ArrayEditor'/> using the
        ///       specified type for the array.
        ///    </para>
        /// </devdoc>
        public ArrayEditor(Type type) : base(type) {
        }

        /// <include file='doc\ArrayEditor.uex' path='docs/doc[@for="ArrayEditor.CreateCollectionItemType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets
        ///       the data type this collection contains.
        ///    </para>
        /// </devdoc>
        protected override Type CreateCollectionItemType() {
            return CollectionType.GetElementType();
        }

        /// <include file='doc\ArrayEditor.uex' path='docs/doc[@for="ArrayEditor.GetItems"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the items in the array.
        ///    </para>
        /// </devdoc>
        protected override object[] GetItems(object editValue) {
            if (editValue is Array) {
                Array valueArray = (Array)editValue;
                object[] items = new object[valueArray.GetLength(0)];
                Array.Copy(valueArray, items, items.Length);
                return items;
            }
            else {
                return new object[0];
            }
        }

        /// <include file='doc\ArrayEditor.uex' path='docs/doc[@for="ArrayEditor.SetItems"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the items in the array.
        ///    </para>
        /// </devdoc>
        protected override object SetItems(object editValue, object[] value) {
            if (editValue is Array) {
                Array newArray = Array.CreateInstance(CollectionItemType, value.Length);
                Array.Copy(value, newArray, value.Length);
                return newArray;
            }
            return editValue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\byteviewer.cs ===
//------------------------------------------------------------------------------
// <copyright file="ByteViewer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design  {
    using System.Design;
    using System.Text;
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;    
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.IO;
    using System.Globalization;
    using System.Drawing;
    using Microsoft.Win32;

    /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer"]/*' />
    /// <devdoc>
    ///    <para>Displays byte arrays in
    ///       HEXDUMP, ANSI and Unicode formats.</para>
    /// </devdoc>
    [
    System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode),
    ToolboxItem(false),
    DesignTimeVisible(false)
    ]
    public class ByteViewer : Control {
        private const int DEFAULT_COLUMN_COUNT = 16;
        private const int DEFAULT_ROW_COUNT = 25;

        private const int COLUMN_COUNT = 16;

        private const int BORDER_GAP = 2;
        private const int INSET_GAP = 3;

        private const int CELL_HEIGHT = 21;
        private const int CELL_WIDTH = 25;
        private const int CHAR_WIDTH = 8;

        private const int ADDRESS_WIDTH = 69;  // this is ceiling(sizeof("DDDDDDDD").width) + 1
        private const int HEX_WIDTH = CELL_WIDTH * COLUMN_COUNT;
        private const int DUMP_WIDTH = CHAR_WIDTH * COLUMN_COUNT;
        private const int SCROLLBAR_WIDTH = 16;

        private const int HEX_DUMP_GAP = 5;

        private const int ADDRESS_START_X = BORDER_GAP + INSET_GAP;
        private const int CLIENT_START_Y = BORDER_GAP + INSET_GAP;
        private const int LINE_START_Y = CLIENT_START_Y + CELL_HEIGHT / 8;
        private const int HEX_START_X = ADDRESS_START_X + ADDRESS_WIDTH;
        private const int DUMP_START_X = HEX_START_X + HEX_WIDTH + HEX_DUMP_GAP;
        private const int SCROLLBAR_START_X = DUMP_START_X + DUMP_WIDTH + HEX_DUMP_GAP;
        private const int COMPONENT_WIDTH = SCROLLBAR_START_X + SCROLLBAR_WIDTH + BORDER_GAP + INSET_GAP;

        private static readonly Font ADDRESS_FONT = new Font("Microsoft Sans Serif", 8.0f);
        private static readonly Font HEXDUMP_FONT = new Font("Courier New", 8.0f);

        private VScrollBar scrollBar;
        private TextBox edit;

        private int columnCount = DEFAULT_COLUMN_COUNT;
        private int rowCount = DEFAULT_ROW_COUNT;

        private byte[] dataBuf;

        private int startLine = 0;
        private int displayLinesCount;
        private int linesCount;

        private DisplayMode displayMode;
        private DisplayMode realDisplayMode;

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.ByteViewer"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.Design.ByteViewer'/> class.
        ///    </para>
        /// </devdoc>
        public ByteViewer()
        : base() {
            InitUI();
            displayMode = DisplayMode.Hexdump;
            realDisplayMode = DisplayMode.Hexdump;
            SetStyle(ControlStyles.DoubleBuffer, true);

        }

        //Stole this code from  XmlSanner       
        private static int AnalizeByteOrderMark(byte[] buffer, int index) {
            int c1 = buffer[index + 0] << 8 | buffer[index + 1];
            int c2 = buffer[index + 2] << 8 | buffer[index + 3];
            int c4,c5;

            //Assign an index (label) value for first two bytes
            c4 = GetEncodingIndex(c1);
            //Assign an index (label) value for 3rd and 4th byte            
            c5 = GetEncodingIndex(c2);

            //Bellow table is to identify Encoding type based on
            //first four bytes, those we have converted in index 
            //values for this look up table
            //values on column are first two bytes and
            //values on rows are 3rd and 4th byte 
            
           int[,] encodings = {
                   //Unknown 0000 feff fffe efbb  3c00 003c 3f00 003f  3c3f 786d  4c6f  a794 
           /*Unknown*/ {1   ,5   ,1   ,1    ,1   ,1   ,1   ,1   ,1    ,1    ,1    ,1    ,1   },
              /*0000*/ {1   ,1   ,1   ,11   ,1   ,10  ,4   ,1   ,1    ,1    ,1    ,1    ,1   },
              /*feff*/ {2   ,9   ,5   ,2    ,2   ,2   ,2   ,2   ,2    ,2    ,2    ,2    ,2   },
              /*fffe*/ {3   ,7   ,3   ,7    ,3   ,3   ,3   ,3   ,3    ,3    ,3    ,3    ,3   },
              /*efbb*/ {14  ,1   ,1   ,1    ,1   ,1   ,1   ,1   ,1    ,1    ,1    ,1    ,1   },
              /*3c00*/ {1   ,6   ,1   ,1    ,1   ,1   ,1   ,3   ,1    ,1    ,1    ,1    ,1   },
              /*003c*/ {1   ,8   ,1   ,1    ,1   ,1   ,1   ,1   ,2    ,1    ,1    ,1    ,1   },
              /*3f00*/ {1   ,1   ,1   ,1    ,1   ,1   ,1   ,1   ,1    ,1    ,1    ,1    ,1   },
              /*003f*/ {1   ,1   ,1   ,1    ,1   ,1   ,1   ,1   ,1    ,1    ,1    ,1    ,1   },
              /*3c3f*/ {1   ,1   ,1   ,1    ,1   ,1   ,1   ,1   ,1    ,1    ,13   ,1    ,1   },
              /*786d*/ {1   ,1   ,1   ,1    ,1   ,1   ,1   ,1   ,1    ,1    ,1    ,1    ,1   },
              /*4c6f*/ {1   ,1   ,1   ,1    ,1   ,1   ,1   ,1   ,1    ,1    ,1    ,1    ,12  },
              /*a794*/ {1   ,1   ,1   ,1    ,1   ,1   ,1   ,1   ,1    ,1    ,1    ,1    ,1   }
            };

            return encodings[c4,c5];        
        }


        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.CellToIndex"]/*' />
        /// <devdoc>
        ///     Calculates an index for a cell in the HEX grid
        /// </devdoc>
        /// <internalonly/>
        private int CellToIndex(int column, int row) {
            return row * columnCount + column;
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.ComposeLineBuffer"]/*' />
        /// <devdoc>
        ///     Copies the line from main data buffer to a line buffer
        /// </devdoc>
        /// <internalonly/>
        private byte[] ComposeLineBuffer(int startLine, int line) {
            byte[] lineBuffer;

            int offset = startLine * columnCount;
            if (offset + (line+1) * columnCount > dataBuf.Length)
                lineBuffer = new byte[dataBuf.Length % columnCount];
            else
                lineBuffer = new byte[columnCount];
            for (int i = 0; i < lineBuffer.Length; i++)
                lineBuffer[i] = dataBuf[offset + CellToIndex(i, line)];
            return lineBuffer;
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.DrawAddress"]/*' />
        /// <devdoc>
        ///     Draws an adress part in the HEXDUMP view
        /// </devdoc>
        /// <internalonly/>
        private void DrawAddress(System.Drawing.Graphics g, int startLine, int line) {
            Font font = ADDRESS_FONT;
            Brush brush = SystemBrushes.Control;

            string hexString = ((startLine + line) * columnCount).ToString("X8");

            Brush foreground = new SolidBrush(ForeColor);
            g.DrawString(hexString, font, foreground,
                         ADDRESS_START_X,LINE_START_Y + line * CELL_HEIGHT);
            foreground.Dispose();
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.DrawClient"]/*' />
        /// <devdoc>
        ///     Draws the client background and frames
        /// </devdoc>
        /// <internalonly/>
        private void DrawClient(System.Drawing.Graphics g) {
            Brush brush = new SolidBrush(SystemColors.ControlLightLight);
            Pen pen = new Pen(SystemColors.ControlLight);
            g.FillRectangle(brush, new Rectangle(HEX_START_X,CLIENT_START_Y
                                                 ,HEX_WIDTH +
                                                 HEX_DUMP_GAP + DUMP_WIDTH + HEX_DUMP_GAP,
                                                 rowCount * CELL_HEIGHT));
            g.DrawRectangle(pen, new Rectangle(HEX_START_X,CLIENT_START_Y
                                               ,HEX_WIDTH +
                                               HEX_DUMP_GAP + DUMP_WIDTH + HEX_DUMP_GAP - 1,
                                               rowCount * CELL_HEIGHT - 1));

            pen =  new Pen(SystemColors.ControlDark);
            g.DrawRectangle(pen, new Rectangle(HEX_START_X,CLIENT_START_Y
                                               ,HEX_WIDTH +
                                               HEX_DUMP_GAP + DUMP_WIDTH + HEX_DUMP_GAP - 1,
                                               rowCount * CELL_HEIGHT - 1));
            g.DrawLine(pen, DUMP_START_X - HEX_DUMP_GAP, CLIENT_START_Y,
                       DUMP_START_X - HEX_DUMP_GAP, CLIENT_START_Y + rowCount * CELL_HEIGHT - 1);
        }

        // Char.IsPrintable is going away because it's a mostly meaningless concept.
        // Copied code here to preserve semantics.  -- BrianGru, 10/3/2000
        private static bool CharIsPrintable(char c) {
            UnicodeCategory uc = Char.GetUnicodeCategory(c);
            return (!(uc == UnicodeCategory.Control) || (uc == UnicodeCategory.Format) || 
                    (uc == UnicodeCategory.LineSeparator) || (uc == UnicodeCategory.ParagraphSeparator) ||
                    (uc == UnicodeCategory.OtherNotAssigned));
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.DrawDump"]/*' />
        /// <devdoc>
        ///     Draws the "DUMP" part in the HEXDUMP view
        /// </devdoc>
        /// <internalonly/>
        private void DrawDump(System.Drawing.Graphics g, byte[] lineBuffer, int line) {
            char c;
            StringBuilder sb = new StringBuilder(lineBuffer.Length);
            for (int i = 0; i < lineBuffer.Length; i++) {
                c = Convert.ToChar(lineBuffer[i]);
                if (CharIsPrintable(c))
                    sb.Append(c);
                else
                    sb.Append('.');
            }
            Font font = HEXDUMP_FONT;
            Color backColor = SystemColors.Window;
            Brush foreground = new SolidBrush(ForeColor);
            g.DrawString(sb.ToString(), font, foreground, DUMP_START_X,  LINE_START_Y + line * CELL_HEIGHT);
            foreground.Dispose();
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.DrawHex"]/*' />
        /// <devdoc>
        ///     Draws the "HEX" part in the HEXDUMP view
        /// </devdoc>
        /// <internalonly/>
        private void DrawHex(System.Drawing.Graphics g, byte[] lineBuffer, int line) {
            Color backColor = SystemColors.ControlLightLight;
            Font font = HEXDUMP_FONT;

            StringBuilder result = new StringBuilder(lineBuffer.Length * 3 + 1);
            for (int i = 0; i < lineBuffer.Length; i++) {
                result.Append(lineBuffer[i].ToString("X2"));
                result.Append(" ");
                if (i == columnCount/2 - 1)
                    result.Append(" ");  //add one extra in the middle
            }
            Brush foreground = new SolidBrush(ForeColor);
            g.DrawString(result.ToString(), font, foreground, HEX_START_X + BORDER_GAP, LINE_START_Y + line * CELL_HEIGHT);
            foreground.Dispose();

            /* ISSUE a-gregka: If perf problem, could be done this way to eliminate drawing twice on repaint
               The current solution good enough for a dialog box
            int hdc = g.getHandle();
            Windows.SelectObject(hdc, HEXDUMP_FONT.getHandle(g));
            Windows.ExtTextOut(hdc, HEX_START_X, LINE_START_Y - 1 + line * CELL_HEIGHT,
                 win.ETO_OPAQUE,
                 Utils.createRECT(HEX_START_X, LINE_START_Y -1 + line * CELL_HEIGHT, HEX_WIDTH, CELL_HEIGHT),
                 out, columnCount * 3 + 1, null);
            */
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.DrawFrame"]/*' />
        /// <devdoc>
        ///     Draws a 3D frame around the component
        /// </devdoc>
        /// <internalonly/>
        private void DrawFrame(System.Drawing.Graphics g) {
            Pen pen = new Pen(SystemColors.ControlDark);
            g.DrawLine(pen, BORDER_GAP, BORDER_GAP,
                       COMPONENT_WIDTH - BORDER_GAP, BORDER_GAP);
            g.DrawLine(pen, BORDER_GAP,CLIENT_START_Y + rowCount * CELL_HEIGHT + INSET_GAP,
                       BORDER_GAP, BORDER_GAP);
            pen = new Pen(SystemColors.ControlLightLight);
            g.DrawLine(pen, BORDER_GAP, CLIENT_START_Y + rowCount * CELL_HEIGHT + INSET_GAP,
                       COMPONENT_WIDTH - BORDER_GAP, CLIENT_START_Y + rowCount * CELL_HEIGHT + INSET_GAP);
            g.DrawLine(pen, COMPONENT_WIDTH - BORDER_GAP,
                       BORDER_GAP,
                       COMPONENT_WIDTH - BORDER_GAP,
                       CLIENT_START_Y + rowCount * CELL_HEIGHT + INSET_GAP);
        }


        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.DrawLines"]/*' />
        /// <devdoc>
        ///     Draws the all lines (a line includes address, hex and dump part)
        ///     for the HEXDUMP view
        /// </devdoc>
        /// <internalonly/>
        private void DrawLines(System.Drawing.Graphics g, int startLine, int linesCount) {
            for (int i = 0; i < linesCount; i++) {
                byte[] lineBuffer = ComposeLineBuffer(startLine,i);
                DrawAddress(g, startLine, i);
                DrawHex(g,lineBuffer,i);
                DrawDump(g,lineBuffer,i);
            }
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.GetAutoDisplayMode"]/*' />
        /// <devdoc>
        ///     Establishes the display mode for the control based on the
        ///     contents of the buffer.
        ///     This is based on the following algorithm:
        ///     Count number of zeros, prinables and other characters in the half of the dataBuffer
        ///     Base on the following table establish the mode:
        ///     80% Characters or digits -> ANSI
        ///     80% Valid Unicode chars -> Unicode
        ///     All other cases -> HEXDUMP
        ///     Also for the buffer of size [0..5] it returns the HEXDUMP mode
        /// </devdoc>
        /// <internalonly/>
        private DisplayMode GetAutoDisplayMode() {
            int printablesCount = 0;
            int unicodeCount = 0;
            int size;

            if ((dataBuf == null) || (dataBuf.Length >= 0 && (dataBuf.Length < 8)))
                return DisplayMode.Hexdump;

            switch(AnalizeByteOrderMark(dataBuf, 0)) {                            
            case 2:  
                //_Encoding = Encoding.BigEndianUnicode;
                return DisplayMode.Hexdump;
            case 3:
                //_Encoding = Encoding.Unicode;
                return DisplayMode.Unicode;
            case 4:
            case 5:
                //_Encoding = Ucs4Encoding.UCS4_Bigendian; 
                return DisplayMode.Hexdump;                    
            case 6: 
            case 7:
                //_Encoding = Ucs4Encoding.UCS4_Littleendian; 
                return DisplayMode.Hexdump;                    
            case 8: 
            case 9:
                //_Encoding = Ucs4Encoding.UCS4_3412;
                return DisplayMode.Hexdump;                    
            case 10: 
            case 11: 
                //_Encoding = Ucs4Encoding.UCS4_2143;
                return DisplayMode.Hexdump;                    
            case 12: 
                //8 ebcdic
                return DisplayMode.Hexdump;                                            
            case 13: //9                    
                //_Encoding = new UTF8Encoding(false);
                return DisplayMode.Ansi;                          
            case 14:
                return DisplayMode.Ansi;                          
            default:                    
                //If ByteOrderMark not detected try
                if (dataBuf.Length > 1024)
                    size = 512;
                else
                    size = dataBuf.Length / 2;
                
                for (int i = 0; i < size; i++) {
                    char c = (char) dataBuf[i]; //OK we do not care for Unicode now
                    if (Char.IsLetterOrDigit(c) || Char.IsWhiteSpace(c))
                        printablesCount++;
                }
                for (int i = 0; i < size; i+=2) {            
                    char[] unicodeChars = new char[1];
                    Encoding.Unicode.GetChars(dataBuf, i, 2, unicodeChars, 0);
                    if (CharIsPrintable(unicodeChars[0]))
                        unicodeCount++;
                }
    
                if (unicodeCount * 100 / (size/2) > 80)
                    return DisplayMode.Unicode;
    
                if (printablesCount * 100 / size > 80)
                    return DisplayMode.Ansi;
        
                return DisplayMode.Hexdump;                    
            }            
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.GetBytes"]/*' />
        /// <devdoc>
        ///    <para>Gets the bytes in the buffer.</para>
        /// </devdoc>
        public virtual byte[] GetBytes() {
            return dataBuf;
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.GetDisplayMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the display mode for the control.
        ///    </para>
        /// </devdoc>
        public virtual DisplayMode GetDisplayMode() {
            return displayMode;
        }

        //Stole this code from  XmlSanner       
        private static int GetEncodingIndex(int c1) {
            switch(c1) {
                case 0x0000:    return 1; 
                case 0xfeff:    return 2; 
                case 0xfffe:    return 3; 
                case 0xefbb:    return 4; 
                case 0x3c00:    return 5;                     
                case 0x003c:    return 6; 
                case 0x3f00:    return 7; 
                case 0x003f:    return 8; 
                case 0x3c3f:    return 9; 
                case 0x786d:    return 10;                     
                case 0x4c6f:    return 11; 
                case 0xa794:    return 12; 
                default:        return 0; //unknown
            }
        }
                                    
        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.InitAnsi"]/*' />
        /// <devdoc>
        ///     Initializes the ansi string variable that will be assigned to the edit box.
        /// </devdoc>
        /// <internalonly/>
        private void InitAnsi() {                        
            int size = dataBuf.Length;
            char[] text = new char[size + 1];
            size = NativeMethods.MultiByteToWideChar(0, 0, dataBuf, size, text, size);
            text[size] = (char)0;

            for (int i = 0; i < size; i++)
                if (text[i] == '\0') text[i] = (char)0x0B;
                
            edit.Text = new string(text);
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.InitUnicode"]/*' />
        /// <devdoc>
        ///     Initializes the Unicode string varible that will be assigned to the edit box
        /// </devdoc>
        /// <internalonly/>
        private void InitUnicode() {
            char[] text = new char[dataBuf.Length/2+1];                            
            Encoding.Unicode.GetChars(dataBuf, 0, dataBuf.Length, text, 0);                                                                     
            for (int i = 0; i < text.Length; i++)
                if (text[i] == '\0') text[i] = (char)0x0B;
            
            text[text.Length - 1] = '\0';
            edit.Text = new string(text);
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.InitUI"]/*' />
        /// <devdoc>
        ///     Initializes the UI components of a control
        /// </devdoc>
        /// <internalonly/>
        private void InitUI() {
            this.Size = new Size(SCROLLBAR_START_X + SCROLLBAR_WIDTH + BORDER_GAP + INSET_GAP,
                                 2 * (BORDER_GAP + INSET_GAP) + rowCount * (CELL_HEIGHT));

            scrollBar = new VScrollBar();
            scrollBar.Location = new Point(SCROLLBAR_START_X,CLIENT_START_Y);
            scrollBar.Size = new Size(SCROLLBAR_WIDTH, rowCount * (CELL_HEIGHT));
            scrollBar.ValueChanged += new EventHandler(this.ScrollChanged);
            scrollBar.TabStop = true;
            scrollBar.TabIndex = 0;

            edit = new TextBox();
            edit.Location = new Point(ADDRESS_START_X,CLIENT_START_Y);
            edit.Size = new Size(COMPONENT_WIDTH - 2 * (ADDRESS_START_X), rowCount * CELL_HEIGHT);
            edit.BorderStyle = BorderStyle.None;
            edit.Multiline = true;
            edit.ReadOnly = true;
            edit.ScrollBars = ScrollBars.Both;
            edit.AcceptsTab = true;
            edit.AcceptsReturn = true;
            edit.WordWrap = false;

            Controls.Add(scrollBar);
            Controls.Add(edit);
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.InitState"]/*' />
        /// <devdoc>
        ///     Initializes some important variables
        /// </devdoc>
        /// <internalonly/>
        private void InitState() {
            // calculate number of lines required (being careful to count 1 for the last partial line)
            linesCount = (dataBuf.Length + columnCount - 1) / columnCount;
            
            startLine = 0;
            if (linesCount > rowCount) {
                displayLinesCount = rowCount;
                scrollBar.Hide();
                scrollBar.Maximum = linesCount - 1;
                scrollBar.LargeChange = rowCount;
                scrollBar.Show();
                scrollBar.Enabled = true;
            }
            else {
                displayLinesCount = linesCount;
                scrollBar.Hide();
                scrollBar.Maximum = rowCount;
                scrollBar.LargeChange = rowCount;
                scrollBar.Show();
                scrollBar.Enabled = false;
            }
            scrollBar.Select();
            Invalidate();
        }
        
        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.OnKeyDown"]/*' />
        /// <devdoc>
        ///     KeyDown handler.
        /// </devdoc>
        /// <internalonly/>
        protected override void OnKeyDown(KeyEventArgs e) {
            scrollBar.Select();
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.OnPaint"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Paint handler
        ///       for the control.
        ///    </para>
        /// </devdoc>
        protected override void OnPaint(PaintEventArgs e) {
            base.OnPaint(e);
            Graphics g = e.Graphics;
            DrawFrame(g);

            switch (realDisplayMode) {
                case DisplayMode.Hexdump:
                    edit.Hide();
                    scrollBar.Show();
                    DrawClient(g);
                    DrawLines(g, startLine, displayLinesCount);
                    break;
                case DisplayMode.Ansi:
                    edit.Invalidate();
                    break;
                case DisplayMode.Unicode:
                    edit.Invalidate();
                    break;
            }
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.OnResize"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Resize handler for the control.
        ///    </para>
        /// </devdoc>
        protected override void OnResize(EventArgs e) {
            int rows = (ClientSize.Height - 2 * (BORDER_GAP + INSET_GAP)) / CELL_HEIGHT;
            if (rows != rowCount) rowCount = rows;
            else return;

            Size = new Size(COMPONENT_WIDTH,
                            2 * (BORDER_GAP + INSET_GAP) + rowCount * (CELL_HEIGHT));
            if (edit != null) {
                edit.Size = new Size(COMPONENT_WIDTH - 2 * (ADDRESS_START_X), rowCount * CELL_HEIGHT);
            }
            if (scrollBar != null) {
                scrollBar.Size = new Size(SCROLLBAR_WIDTH, rowCount * (CELL_HEIGHT));
                if (linesCount > rowCount) {
                    scrollBar.Hide();
                    scrollBar.Maximum = linesCount - 1;
                    scrollBar.LargeChange = rowCount;
                    scrollBar.Show();
                    scrollBar.Enabled = true;
                    scrollBar.Select();
                }
                else
                    scrollBar.Enabled = false;
            }
            displayLinesCount = (startLine + rowCount < linesCount) ? rowCount : linesCount - startLine;
            Invalidate();
            base.OnResize(e);
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.SaveToFile"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the raw data from the data buffer to a file.
        ///    </para>
        /// </devdoc>
        public virtual void SaveToFile(string path) {
            if (dataBuf != null) {
                FileStream currentFile = new FileStream(path, FileMode.OpenOrCreate, FileAccess.ReadWrite, FileShare.None);
                try {
                    currentFile.Write(dataBuf,0,dataBuf.Length);
                    currentFile.Close();
                }
                catch (Exception e) {
                    currentFile.Close();
                    throw e;
                }
            }
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.ScrollChanged"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Scroll event handler.
        ///    </para>
        /// </devdoc>
        protected virtual void ScrollChanged(object source, EventArgs e) {
            startLine = scrollBar.Value;
            
            Invalidate();
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.SetBytes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the byte array to be displayed in the viewer.
        ///    </para>
        /// </devdoc>
        public virtual void SetBytes(byte[] bytes) {
            if (bytes == null)
                throw new ArgumentNullException("bytes");
                
            if (dataBuf != null)
                dataBuf = null;
            dataBuf = bytes;
            InitState();
            SetDisplayMode(displayMode);
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.SetDisplayMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the current display mode.
        ///    </para>
        /// </devdoc>
        public virtual void SetDisplayMode(DisplayMode mode) {
           if (!Enum.IsDefined(typeof(DisplayMode), mode)) 
                throw new InvalidEnumArgumentException("mode", (int)mode, typeof(DisplayMode));
           
            displayMode = mode;

            realDisplayMode = (mode == DisplayMode.Auto) ? GetAutoDisplayMode() : mode;

            switch (realDisplayMode) {
                case DisplayMode.Ansi:
                    InitAnsi();
                    edit.Show();
                    scrollBar.Hide();
                    Invalidate();
                    break;
                case DisplayMode.Unicode:
                    InitUnicode();
                    edit.Show();
                    scrollBar.Hide();
                    Invalidate();
                    break;
                case DisplayMode.Hexdump:
                    edit.Hide();
                    if (linesCount > rowCount)
                        if (!scrollBar.Visible) {
                            scrollBar.Show();
                            scrollBar.Invalidate();
                            scrollBar.Select();
                        }
                    break;
            }
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.SetFile"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the file to be displayed in the viewer.
        ///    </para>
        /// </devdoc>
        public virtual void SetFile(string path) {
            FileStream currentFile = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.None);
            try {
                int length = (int)currentFile.Length;
                byte[] buf = new byte[length+1];
                currentFile.Read(buf,0,length);
                SetBytes(buf);
                currentFile.Close();
            }
            catch (Exception e) {
                currentFile.Close();
                throw e;
            }
        }

        /// <include file='doc\ByteViewer.uex' path='docs/doc[@for="ByteViewer.SetStartLine"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the current line for the HEXDUMP view.
        ///    </para>
        /// </devdoc>
        public virtual void SetStartLine(int line) {
            if (line < 0 || line >= linesCount || line > dataBuf.Length / columnCount)
                startLine = 0;
            else
                startLine = line;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\compmodswitches.cs ===
//------------------------------------------------------------------------------
// <copyright file="Component.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.Diagnostics;

    /// <internalonly/>
    internal sealed class CompModSwitches {
        private static BooleanSwitch commonDesignerServices;
        private static TraceSwitch userControlDesigner;
        private static TraceSwitch dragDrop;
        private static TraceSwitch msaa;
        
        public static BooleanSwitch CommonDesignerServices {
            get {
                if (commonDesignerServices == null) {
                    commonDesignerServices = new BooleanSwitch("CommonDesignerServices", "Assert if any common designer service is not found.");
                }
                return commonDesignerServices;
            }
        }
        
        public static TraceSwitch DragDrop {
            get {
                if (dragDrop == null) {
                    dragDrop = new TraceSwitch("DragDrop", "Debug OLEDragDrop support in Controls");
                }
                return dragDrop;
            }
        }
        
        public static TraceSwitch MSAA {
            get {
                if (msaa == null) {
                    msaa = new TraceSwitch("MSAA", "Debug Microsoft Active Accessibility");
                }
                return msaa;
            }
        }
        
        public static TraceSwitch UserControlDesigner {
            get {
                if (userControlDesigner == null) {
                    userControlDesigner = new TraceSwitch("UserControlDesigner", "User Control Designer : Trace service calls.");
                }
                return userControlDesigner;
            }
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\binaryeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="BinaryEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design {

    using System.Design;
    using System;
    using System.Text;
    using System.IO;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Design;
    using Microsoft.Win32;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;

    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class BinaryUI : System.Windows.Forms.Form {                
        private BinaryEditor editor;
        object value;
        
        private RadioButton radioAuto = null;
        private Button buttonSave = null;
        private Button buttonOK = null;
        private ByteViewer byteViewer = null;
        private GroupBox groupBoxMode = null;
        private RadioButton radioHex = null;
        private RadioButton radioAnsi = null;
        private RadioButton radioUnicode = null;

        public BinaryUI(BinaryEditor editor) {
            this.editor = editor;
            InitializeComponent();
        }
        
        public object Value { 
            get {
                return value;
            }
            set {
                this.value = value;
                byte[] bytes = null;
                
                if (value != null) {
                    bytes = editor.ConvertToBytes(value);
                }
                
                if (bytes != null) {
                    byteViewer.SetBytes(bytes);
                    byteViewer.Enabled = true;
                }
                else {
                    byteViewer.SetBytes(new byte[0]);
                    byteViewer.Enabled = false;
                }
            }
        }

        private void RadioAuto_checkedChanged(object source, EventArgs e) {
            if (radioAuto.Checked)
                byteViewer.SetDisplayMode(DisplayMode.Auto);
        }

        private void RadioHex_checkedChanged(object source, EventArgs e) {
            if (radioHex.Checked)
                byteViewer.SetDisplayMode(DisplayMode.Hexdump);
        }

        private void RadioAnsi_checkedChanged(object source, EventArgs e) {
            if (radioAnsi.Checked)
                byteViewer.SetDisplayMode(DisplayMode.Ansi);
        }

        private void RadioUnicode_checkedChanged(object source, EventArgs e) {
            if (radioUnicode.Checked)
                byteViewer.SetDisplayMode(DisplayMode.Unicode);
        }
        
        private void ButtonOK_click(object source, EventArgs e) {
            object localValue = value;
            editor.ConvertToValue(byteViewer.GetBytes(), ref localValue);
            value = localValue;
        }

        private void ButtonSave_click(object source, EventArgs e) {
            try {
                SaveFileDialog sfd = new SaveFileDialog();

                sfd.FileName = SR.GetString(SR.BinaryEditorFileName);
                sfd.Title = SR.GetString(SR.BinaryEditorSaveFile);
                sfd.Filter = SR.GetString(SR.BinaryEditorAllFiles) + " (*.*)|*.*";

                DialogResult result = sfd.ShowDialog();
                if (result == DialogResult.OK) {
                    byteViewer.SaveToFile(sfd.FileName);
                }
            }
            catch (IOException x) {
                MessageBox.Show(SR.GetString(SR.BinaryEditorFileError)+x.Message,
                                SR.GetString(SR.BinaryEditorTitle), MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }
        
        private void Form_HelpRequested(object sender, HelpEventArgs e) {
            editor.ShowHelp();
        }
        
        private void InitializeComponent() {
            System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(BinaryEditor));
            byteViewer = new ByteViewer();
            buttonOK = new System.Windows.Forms.Button();
            buttonSave = new System.Windows.Forms.Button();
            groupBoxMode = new System.Windows.Forms.GroupBox();
            radioAuto = new System.Windows.Forms.RadioButton();
            radioHex = new System.Windows.Forms.RadioButton();
            radioAnsi = new System.Windows.Forms.RadioButton();
            radioUnicode = new System.Windows.Forms.RadioButton();
            groupBoxMode.SuspendLayout();
            SuspendLayout();
            // 
            // byteViewer
            // 
            byteViewer.SetDisplayMode(DisplayMode.Auto);
            byteViewer.AccessibleDescription = ((string)(resources.GetObject("byteViewer.AccessibleDescription")));
            byteViewer.AccessibleName = ((string)(resources.GetObject("byteViewer.AccessibleName")));
            byteViewer.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("byteViewer.Anchor")));
            byteViewer.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("byteViewer.Dock")));
            byteViewer.Location = ((System.Drawing.Point)(resources.GetObject("byteViewer.Location")));
            byteViewer.Size = ((System.Drawing.Size)(resources.GetObject("byteViewer.Size")));
            byteViewer.TabIndex = ((int)(resources.GetObject("byteViewer.TabIndex")));
            // 
            // buttonOK
            // 
            buttonOK.DialogResult = System.Windows.Forms.DialogResult.OK;
            buttonOK.Click += new EventHandler(this.ButtonOK_click);
            buttonOK.AccessibleDescription = ((string)(resources.GetObject("buttonOK.AccessibleDescription")));
            buttonOK.AccessibleName = ((string)(resources.GetObject("buttonOK.AccessibleName")));
            buttonOK.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("buttonOK.Anchor")));
            buttonOK.Location = ((System.Drawing.Point)(resources.GetObject("buttonOK.Location")));
            buttonOK.Size = ((System.Drawing.Size)(resources.GetObject("buttonOK.Size")));
            buttonOK.TabIndex = ((int)(resources.GetObject("buttonOK.TabIndex")));
            buttonOK.Text = resources.GetString("buttonOK.Text");
            // 
            // buttonSave
            // 
            buttonSave.Click += new EventHandler(this.ButtonSave_click);
            buttonSave.AccessibleDescription = ((string)(resources.GetObject("buttonSave.AccessibleDescription")));
            buttonSave.AccessibleName = ((string)(resources.GetObject("buttonSave.AccessibleName")));
            buttonSave.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("buttonSave.Anchor")));
            buttonSave.Location = ((System.Drawing.Point)(resources.GetObject("buttonSave.Location")));
            buttonSave.Size = ((System.Drawing.Size)(resources.GetObject("buttonSave.Size")));
            buttonSave.TabIndex = ((int)(resources.GetObject("buttonSave.TabIndex")));
            buttonSave.Text = resources.GetString("buttonSave.Text");
            // 
            // groupBoxMode
            // 
            groupBoxMode.TabStop = false;
            groupBoxMode.Controls.AddRange(new System.Windows.Forms.Control[] {this.radioUnicode,
                   this.radioAnsi,
                   this.radioHex,
                   this.radioAuto});
            groupBoxMode.Location = ((System.Drawing.Point)(resources.GetObject("groupBoxMode.Location")));
            groupBoxMode.Size = ((System.Drawing.Size)(resources.GetObject("groupBoxMode.Size")));
            groupBoxMode.TabIndex = ((int)(resources.GetObject("groupBoxMode.TabIndex")));
            groupBoxMode.Text = resources.GetString("groupBoxMode.Text");
            // 
            // radioAuto
            // 
            radioAuto.TabStop = true;
            radioAuto.Checked = true;
            radioAuto.CheckedChanged += new EventHandler(this.RadioAuto_checkedChanged);
            radioAuto.AccessibleDescription = ((string)(resources.GetObject("radioAuto.AccessibleDescription")));
            radioAuto.AccessibleName = ((string)(resources.GetObject("radioAuto.AccessibleName")));
            radioAuto.Location = ((System.Drawing.Point)(resources.GetObject("radioAuto.Location")));
            radioAuto.Size = ((System.Drawing.Size)(resources.GetObject("radioAuto.Size")));
            radioAuto.TabIndex = ((int)(resources.GetObject("radioAuto.TabIndex")));
            radioAuto.Text = resources.GetString("radioAuto.Text");
            // 
            // radioHex
            // 
            radioHex.CheckedChanged += new EventHandler(this.RadioHex_checkedChanged);
            radioHex.AccessibleDescription = ((string)(resources.GetObject("radioHex.AccessibleDescription")));
            radioHex.AccessibleName = ((string)(resources.GetObject("radioHex.AccessibleName")));
            radioHex.Location = ((System.Drawing.Point)(resources.GetObject("radioHex.Location")));
            radioHex.Size = ((System.Drawing.Size)(resources.GetObject("radioHex.Size")));
            radioHex.TabIndex = ((int)(resources.GetObject("radioHex.TabIndex")));
            radioHex.Text = resources.GetString("radioHex.Text");
            // 
            // radioAnsi
            // 
            radioAnsi.CheckedChanged += new EventHandler(this.RadioAnsi_checkedChanged);
            radioAnsi.AccessibleDescription = ((string)(resources.GetObject("radioAnsi.AccessibleDescription")));
            radioAnsi.AccessibleName = ((string)(resources.GetObject("radioAnsi.AccessibleName")));
            radioAnsi.Location = ((System.Drawing.Point)(resources.GetObject("radioAnsi.Location")));
            radioAnsi.Size = ((System.Drawing.Size)(resources.GetObject("radioAnsi.Size")));
            radioAnsi.TabIndex = ((int)(resources.GetObject("radioAnsi.TabIndex")));
            radioAnsi.Text = resources.GetString("radioAnsi.Text");
            // 
            // radioUnicode
            // 
            radioUnicode.CheckedChanged += new EventHandler(this.RadioUnicode_checkedChanged);
            radioUnicode.AccessibleDescription = ((string)(resources.GetObject("radioUnicode.AccessibleDescription")));
            radioUnicode.AccessibleName = ((string)(resources.GetObject("radioUnicode.AccessibleName")));
            radioUnicode.Location = ((System.Drawing.Point)(resources.GetObject("radioUnicode.Location")));
            radioUnicode.Size = ((System.Drawing.Size)(resources.GetObject("radioUnicode.Size")));
            radioUnicode.TabIndex = ((int)(resources.GetObject("radioUnicode.TabIndex")));
            radioUnicode.Text = resources.GetString("radioUnicode.Text");
            // 
            // Win32Form1
            // 
            FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            MaximizeBox = false;
            AcceptButton = buttonOK;
            CancelButton = buttonOK;
            AccessibleDescription = ((string)(resources.GetObject("$this.AccessibleDescription")));
            AccessibleName = ((string)(resources.GetObject("$this.AccessibleName")));
            AutoScaleBaseSize = ((System.Drawing.Size)(resources.GetObject("$this.AutoScaleBaseSize")));
            ClientSize = ((System.Drawing.Size)(resources.GetObject("$this.ClientSize")));
            HelpRequested += new HelpEventHandler(this.Form_HelpRequested);
            Controls.AddRange(new System.Windows.Forms.Control[] {this.groupBoxMode,
                   this.buttonSave,
                   this.buttonOK,
                   this.byteViewer});
            Icon = null;
            StartPosition = ((System.Windows.Forms.FormStartPosition)(resources.GetObject("$this.StartPosition")));
            Text = resources.GetString("$this.Text");
            ResumeLayout(false);
        }
    }

    /// <include file='doc\BinaryEditor.uex' path='docs/doc[@for="BinaryEditor"]/*' />
    /// <devdoc>
    ///      Generic editor for editing binary data.  This presents
    ///      a hex editing window to the user.
    /// </devdoc>
    public sealed class BinaryEditor : UITypeEditor {
        private static readonly string HELP_KEYWORD = "System.ComponentModel.Design.BinaryEditor";
        private ITypeDescriptorContext context;
        private BinaryUI binaryUI;
                
        internal object GetService(Type serviceType) {
            if (this.context != null) {
                IDesignerHost host = this.context.GetService(typeof(IDesignerHost)) as IDesignerHost;
                if (host == null) 
                    return this.context.GetService(serviceType);                    
                else
                    return host.GetService(serviceType);
            }
            return null;
        }
        
        /// <include file='doc\BinaryEditor.uex' path='docs/doc[@for="BinaryEditor.ConvertToBytes"]/*' />
        /// <devdoc>
        ///      Converts the given object to an array of bytes to be manipulated
        ///      by the editor.  The default implementation of this supports
        ///      byte[] and stream objects.
        /// </devdoc>
        internal byte[] ConvertToBytes(object value) {
            if (value is Stream) {
                Stream s = (Stream)value;
                s.Position = 0;
                int byteCount = (int)(s.Length - s.Position);
                byte[] bytes = new byte[byteCount];
                s.Read(bytes, 0, byteCount);
                return bytes;
            }
            
            if (value is byte[]) {
                return (byte[])value;
            }
            
            if (value is string) {  
                int size = ((string)value).Length * 2;
                byte[] buffer = new byte[size];                                                                                                            
                Encoding.Unicode.GetBytes(((string)value).ToCharArray(), 0, size /2, buffer, 0);
                return buffer;
            }
                                
             Debug.Fail("No conversion from " + value == null ? "null" : value.GetType().FullName + " to byte[]");
            return null;
        }
        
        /// <include file='doc\BinaryEditor.uex' path='docs/doc[@for="BinaryEditor.ConvertToValue"]/*' />
        /// <devdoc>
        ///      Converts the given byte array back into a native object.  If
        ///      the object itself needs to be replace (as is the case for arrays),
        ///      then a new object may be assigned out through the parameter.
        /// </devdoc>
        internal void ConvertToValue(byte[] bytes, ref object value) {
        
            if (value is Stream) {
                Stream s = (Stream)value;
                s.Position = 0;
                s.Write(bytes, 0, bytes.Length);
            }
            else if (value is byte[]) {
                value = bytes;
            }
            else if (value is string) {
                value = BitConverter.ToString(bytes);
            }
            else {
                Debug.Fail("No conversion from byte[] to " + value == null ? "null" : value.GetType().FullName);
            }
        }
        
        /// <include file='doc\BinaryEditor.uex' path='docs/doc[@for="BinaryEditor.EditValue"]/*' />
        /// <devdoc>
        ///      Edits the given object value using the editor style provided by
        ///      GetEditorStyle.  A service provider is provided so that any
        ///      required editing services can be obtained.
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {
            if (provider != null) {
                this.context = context;
            
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));
                
                if (edSvc != null) {
                    if (binaryUI == null) {
                        binaryUI = new BinaryUI(this);
                    }
                    
                    binaryUI.Value = value;
                    
                    if (edSvc.ShowDialog(binaryUI) == DialogResult.OK) {
                        value = binaryUI.Value;
                    }
                    
                    binaryUI.Value = null;
                }
            }
            
            return value;
        }
        
        /// <include file='doc\BinaryEditor.uex' path='docs/doc[@for="BinaryEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///      Retrieves the editing style of the Edit method.  If the method
        ///      is not supported, this will return None.
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.Modal;
        }    
        
        internal void ShowHelp() {            
            IHelpService helpService = GetService(typeof(IHelpService)) as IHelpService;
            if (helpService != null) {
                helpService.ShowHelpFromKeyword(HELP_KEYWORD);
            }
            else {
                Debug.Fail("Unable to get IHelpService.");
            }
        }                    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\datetimeeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="DateTimeEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using Microsoft.Win32;    
    using System.Drawing;
    using System.Drawing.Design;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    /// <include file='doc\DateTimeEditor.uex' path='docs/doc[@for="DateTimeEditor"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       This date/time editor is a UITypeEditor suitable for
    ///       visually editing DateTime objects.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class DateTimeEditor : UITypeEditor {
    
        private DateTimeUI dateTimeUI;
    
        /// <include file='doc\DateTimeEditor.uex' path='docs/doc[@for="DateTimeEditor.EditValue"]/*' />
        /// <devdoc>
        ///      Edits the given object value using the editor style provided by
        ///      GetEditorStyle.  A service provider is provided so that any
        ///      required editing services can be obtained.
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {
        
            object returnValue = value;
        
            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));
                
                if (edSvc != null) {
                    if (dateTimeUI == null) {
                        dateTimeUI = new DateTimeUI();
                    }
                    dateTimeUI.Start(edSvc, value);
                    edSvc.DropDownControl(dateTimeUI);
                    value = dateTimeUI.Value;
                    dateTimeUI.End();
                }
            }
            
            return value;
        }

        /// <include file='doc\DateTimeEditor.uex' path='docs/doc[@for="DateTimeEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///      Retrieves the editing style of the Edit method.  If the method
        ///      is not supported, this will return None.
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.DropDown;
        }
        
        /// <include file='doc\DateTimeEditor.uex' path='docs/doc[@for="DateTimeEditor.DateTimeUI"]/*' />
        /// <devdoc>
        ///      UI we drop down to pick dates.
        /// </devdoc>
        private class DateTimeUI : Control {
            private MonthCalendar monthCalendar = new DateTimeMonthCalendar();
            private object value;
            private IWindowsFormsEditorService edSvc;
            
            /// <include file='doc\DateTimeEditor.uex' path='docs/doc[@for="DateTimeEditor.DateTimeUI.DateTimeUI"]/*' />
            /// <devdoc>
            /// </devdoc>
            public DateTimeUI() {
                InitializeComponent();
                Size = monthCalendar.SingleMonthSize;
                monthCalendar.Resize += new EventHandler(this.MonthCalResize);
            }
            
            /// <include file='doc\DateTimeEditor.uex' path='docs/doc[@for="DateTimeEditor.DateTimeUI.Value"]/*' />
            /// <devdoc>
            /// </devdoc>
            public object Value {
                get {
                    return value;
                }
            }
            
            /// <include file='doc\DateTimeEditor.uex' path='docs/doc[@for="DateTimeEditor.DateTimeUI.End"]/*' />
            /// <devdoc>
            /// </devdoc>
            public void End() {
                edSvc = null;
                value = null;
            }

            private void MonthCalKeyDown(object sender, KeyEventArgs e) {
                switch (e.KeyCode) {
                    case Keys.Enter:
                        OnDateSelected(sender, null);
                        break;
                }
            }

            /// <include file='doc\DateTimeEditor.uex' path='docs/doc[@for="DateTimeEditor.DateTimeUI.InitializeComponent"]/*' />
            /// <devdoc>
            /// </devdoc>
            private void InitializeComponent() {
                monthCalendar.DateSelected += new DateRangeEventHandler(this.OnDateSelected);
                monthCalendar.KeyDown += new KeyEventHandler(this.MonthCalKeyDown);
                this.Controls.Add(monthCalendar);
            }
            
            private void MonthCalResize(object sender, EventArgs e) {
                this.Size = monthCalendar.Size;
            }
        
            /// <include file='doc\DateTimeEditor.uex' path='docs/doc[@for="DateTimeEditor.DateTimeUI.OnDateSelected"]/*' />
            /// <devdoc>
            /// </devdoc>
            private void OnDateSelected(object sender, DateRangeEventArgs e) {
                value = monthCalendar.SelectionStart;
                edSvc.CloseDropDown();
            }
            
            protected override void OnGotFocus(EventArgs e) {
                base.OnGotFocus(e);
                monthCalendar.Focus();
            }
            
            /// <include file='doc\DateTimeEditor.uex' path='docs/doc[@for="DateTimeEditor.DateTimeUI.Start"]/*' />
            /// <devdoc>
            /// </devdoc>
            public void Start(IWindowsFormsEditorService edSvc, object value) {
                this.edSvc = edSvc;
                this.value = value;
                
                if (value != null) {
                    DateTime dt = (DateTime) value;
                    monthCalendar.SetDate((dt.Equals(DateTime.MinValue)) ? DateTime.Today : dt);
                }
            }

            class DateTimeMonthCalendar : MonthCalendar {
                protected override bool IsInputKey(System.Windows.Forms.Keys keyData) {
                    switch (keyData) {
                        case Keys.Enter:
                            return true;
                    }
                    return base.IsInputKey(keyData);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\displaymode.cs ===
//------------------------------------------------------------------------------
// <copyright file="DisplayMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design {

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\DisplayMode.uex' path='docs/doc[@for="DisplayMode"]/*' />
    /// <devdoc>
    ///    <para>Specifies identifiers to indicate the display modes used 
    ///       by <see cref='System.ComponentModel.Design.ByteViewer'/>.</para>
    /// </devdoc>
    public enum DisplayMode {

        /// <include file='doc\DisplayMode.uex' path='docs/doc[@for="DisplayMode.Hexdump"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates using
        ///       Hexadecimal format.
        ///    </para>
        /// </devdoc>
        Hexdump = 1,
        /// <include file='doc\DisplayMode.uex' path='docs/doc[@for="DisplayMode.Ansi"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates using ANSI format.
        ///    </para>
        /// </devdoc>
        Ansi    = 2,
        /// <include file='doc\DisplayMode.uex' path='docs/doc[@for="DisplayMode.Unicode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates using Unicode format.
        ///    </para>
        /// </devdoc>
        Unicode = 3,
        /// <include file='doc\DisplayMode.uex' path='docs/doc[@for="DisplayMode.Auto"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates using automatic format selection.
        ///    </para>
        /// </devdoc>
        Auto    = 4,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\componentdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComponentDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Design;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Reflection;    
    using System.Windows.Forms;
    using Microsoft.Win32;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;

    /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The default designer for all components.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ComponentDesigner : IDesigner, IDesignerFilter {

        IComponent               component;
        InheritanceAttribute     inheritanceAttribute;
        Hashtable                inheritedProps;
        DesignerVerbCollection   verbs;
        ShadowPropertyCollection shadowProperties;
        

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.AssociatedComponents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a list of assosciated components.  These are components that should be incluced in a cut or copy operation on this component.
        ///    </para>
        /// </devdoc>
        public virtual ICollection AssociatedComponents{
            get {
                return new IComponent[0];
            }
        }
        
        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.Component"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the component this designer is designing.
        ///    </para>
        /// </devdoc>
        public IComponent Component {
            get {
                return component;
            }
        }
        
        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.Inherited"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value
        ///       indicating whether or not this component is being inherited.
        ///    </para>
        /// </devdoc>
        protected bool Inherited {
            get {
                return !InheritanceAttribute.Equals(InheritanceAttribute.NotInherited);
            }
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.InvokeGetInheritanceAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Invokes the get inheritance attribute of the specified ComponentDesigner.
        ///    </para>
        /// </devdoc>
        protected InheritanceAttribute InvokeGetInheritanceAttribute(ComponentDesigner toInvoke) {
            return toInvoke.InheritanceAttribute;
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.InheritanceAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the inheritance attribute for this component.
        ///    </para>
        /// </devdoc>
        protected InheritanceAttribute InheritanceAttribute {
            get {
                if (inheritanceAttribute == null) {
                    // Record if this component is being inherited or not.
                    //
                    IInheritanceService inher = (IInheritanceService)GetService(typeof(IInheritanceService));
                    if (inher != null) {
                        inheritanceAttribute = inher.GetInheritanceAttribute(Component);
                    }
                    else {
                        inheritanceAttribute = InheritanceAttribute.Default;
                    }
                }

                return inheritanceAttribute;
            }
        }
        
        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.ShadowProperties"]/*' />
        /// <devdoc>
        ///     Gets a collection that houses shadow properties.  Shadow properties. are properties that fall
        ///     through to the underlying component before they are set, but return their set values once they
        ///     are set.
        /// </devdoc>
        protected ShadowPropertyCollection ShadowProperties {
            get {
                if (shadowProperties == null) {
                    shadowProperties = new ShadowPropertyCollection(this);
                }
                return shadowProperties;
            }
        }
        
        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.Verbs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the design-time verbs supported by the component associated with the designer.
        ///    </para>
        /// </devdoc>
        public virtual DesignerVerbCollection Verbs {
            get {
                if (verbs == null) {
                    verbs = new DesignerVerbCollection();
                }
                return verbs;
            }
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.Dispose"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Disposes of the resources (other than memory) used
        ///       by the <see cref='System.ComponentModel.Design.ComponentDesigner'/>.
        ///    </para>
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for=".Finalize"]/*' />
        ~ComponentDesigner() {
            Dispose(false);
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.Dispose2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Disposes of the resources (other than memory) used
        ///       by the <see cref='System.ComponentModel.Design.ComponentDesigner'/>.
        ///    </para>
        /// </devdoc>
        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                component = null;
            }
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.DoDefaultAction"]/*' />
        /// <devdoc>
        ///    <para>Creates a method signature in the source code file for the default event on the component and navigates
        ///       the user's cursor to that location in preparation to assign
        ///       the default action.</para>
        /// </devdoc>
        public virtual void DoDefaultAction() {
        
            ISelectionService selectionService = (ISelectionService)GetService(typeof(ISelectionService));
            
            ICollection components = selectionService.GetSelectedComponents();
            
            // hmmmm, I sure could use some services.
            //
            IEventBindingService eps = (IEventBindingService)GetService(typeof(IEventBindingService));
            EventDescriptor thisDefaultEvent = null;
            string          thisHandler = null;     
            
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            DesignerTransaction t = null;
            
            try {
                foreach(object comp in components) {
                
                    if (!(comp is IComponent)) {
                        continue;
                    }
            
                    EventDescriptor defaultEvent = TypeDescriptor.GetDefaultEvent(comp);
                    PropertyDescriptor defaultPropEvent = null;
                    string handler = null;
                    bool eventChanged = false;
                    
                    if (defaultEvent != null) {
                        if (CompModSwitches.CommonDesignerServices.Enabled) Debug.Assert(eps != null, "IEventBindingService not found");
                        if (eps != null) {
                            defaultPropEvent = eps.GetEventProperty(defaultEvent);
                        }
                    }
        
                    // If we couldn't find a property for this event, or of the property is read only, then
                    // abort.
                    //
                    if (defaultPropEvent == null || defaultPropEvent.IsReadOnly) {
                        continue;
                    }
                    
                    try {
                        if (host != null && t == null) {
                            t = host.CreateTransaction(SR.GetString(SR.ComponentDesignerAddEvent, defaultEvent.Name));
                        }
                    }
                    catch (CheckoutException cxe) {
                        if (cxe == CheckoutException.Canceled)
                            return;
                            
                        throw cxe;
                    }
        
                    // handler will be null if there is no explicit event hookup in the parsed init method
                    handler = (string)defaultPropEvent.GetValue(comp);
                    
                    if (handler == null) {
                        eventChanged = true;
                        
                        handler = eps.CreateUniqueMethodName((IComponent)comp, defaultEvent);
                    }
                    else {
                        // ensure the handler is still there
                        eventChanged = true;
                        foreach(string compatibleMethod in eps.GetCompatibleMethods(defaultEvent)) {
                            if (handler == compatibleMethod) {
                                eventChanged = false;
                                break;
                            }
                        }
                    }
                    
                    // Save the new value... BEFORE navigating to it!
                    //
                    if (eventChanged && defaultPropEvent != null) {
                       defaultPropEvent.SetValue(comp, handler);
                    }
                    
                    if (component == comp){
                        thisDefaultEvent = defaultEvent;
                        thisHandler = handler;
                    }
                }
            }
            finally {
                if (t != null) {
                    t.Commit();
                }
            }
            
            // Now show the event code.
            //
            if (thisHandler != null && thisDefaultEvent != null) {
                eps.ShowCode(component, thisDefaultEvent);
            }
        }
        
        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.Initialize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.Design.ComponentDesigner'/>
        ///       class using the specified component.
        ///    </para>
        /// </devdoc>
        public virtual void Initialize(IComponent component) {
        
            Debug.Assert(component != null, "Can't create designer with no component!");
            
            this.component = component;

            // For inherited components, save off the current values so we can
            // compute a delta.  We also do this for the root component, but, 
            // as it is ALWAYS inherited, the computation of default values
            // favors the presence of a default value attribute over
            // the current code value.
            //
            bool isRoot = false;
            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            if (host != null && component == host.RootComponent) {
                isRoot = true;
            }
            
            if (isRoot || !InheritanceAttribute.Equals(InheritanceAttribute.NotInherited)) {
                InitializeInheritedProperties(isRoot);
            }
        }

        private void InitializeInheritedProperties(bool rootComponent) {

            Hashtable props = new Hashtable();

            bool readOnlyInherit = (InheritanceAttribute.Equals(InheritanceAttribute.InheritedReadOnly));

            if (!readOnlyInherit) {
                PropertyDescriptorCollection properties = TypeDescriptor.GetProperties(Component);

                // Now loop through all the properties.  For each one, try to match a pre-created property.
                // If that fails, then create a new property.
                //
                PropertyDescriptor[] values = new PropertyDescriptor[properties.Count];
                properties.CopyTo(values, 0);

                for (int i = 0; i < values.Length; i++) {
                    PropertyDescriptor prop = values[i];

                    // Skip some properties
                    //
                    if (object.Equals(prop.Attributes[typeof(DesignOnlyAttribute)], DesignOnlyAttribute.Yes)) {
                        continue;
                    }

                    if (prop.SerializationVisibility == DesignerSerializationVisibility.Hidden && !prop.IsBrowsable) {
                        continue;
                    }

                    PropertyDescriptor inheritedProp = (PropertyDescriptor)props[prop.Name];

                    if (inheritedProp == null) {
                        // This ia a publicly inherited component.  We replace all component properties with
                        // inherited versions that reset the default property values to those that are
                        // currently on the component.
                        //
                        props[prop.Name] = new InheritedPropertyDescriptor(prop, component, rootComponent);
                    }
                }
            }

            inheritedProps = props;
        }
        
        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.InitializeNonDefault"]/*' />
        /// <devdoc>
        ///    <para>Called when the designer has been associated with a control that is not in it's default state, 
        ///          such as one that has been pasted or drag-dropped onto the designer.  This is an opportunity
        ///          to fixup any shadowed properties in a different way than for default components.  This is called
        ///          after the other initialize functions.
        ///     </para>
        /// </devdoc>
        public virtual void InitializeNonDefault() {
        }
        
        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.GetService"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides
        ///       a way for a designer to get services from the hosting
        ///       environment.
        ///    </para>
        /// </devdoc>
        protected virtual object GetService(Type serviceType) {
            if (component != null) {
                ISite site = component.Site;
                if (site != null) {
                    return site.GetService(serviceType);
                }
            }
            return null;
        }
        
        private Attribute[] NonBrowsableAttributes(EventDescriptor e) {
                Attribute[] attrs = new Attribute[e.Attributes.Count];
                e.Attributes.CopyTo(attrs, 0);
                
                for (int i = 0; i < attrs.Length; i++) {
                    if (attrs[i] != null && typeof(BrowsableAttribute).IsInstanceOfType(attrs[i]) && ((BrowsableAttribute)attrs[i]).Browsable) {
                        attrs[i] = BrowsableAttribute.No;
                        return attrs;
                    }
                }
                
                // we didn't find it, we have to alloc a new array
                Attribute[] newAttrs = new Attribute[attrs.Length+1];
                Array.Copy(attrs, 0, newAttrs, 0, attrs.Length);
                newAttrs[attrs.Length] = BrowsableAttribute.No;
                return newAttrs;
        }
        
        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.OnSetComponentDefaults"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Raises the SetComponentDefault event.
        ///    </para>
        /// </devdoc>
        public virtual void OnSetComponentDefaults() {
            ISite site = Component.Site;
            if (site != null) {
                IComponent component = Component;
                PropertyDescriptor pd = TypeDescriptor.GetDefaultProperty(component);
                if (pd != null && pd.PropertyType.Equals(typeof(string))) {

                    string current = (string)pd.GetValue(component);
                    if (current == null || current.Length == 0) {
                        pd.SetValue(component, site.Name);
                    }
                }
            }
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.PostFilterAttributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Allows a
        ///       designer to filter the set of member attributes the
        ///       component it is designing will expose through the
        ///       TypeDescriptor object.
        ///    </para>
        /// </devdoc>
        protected virtual void PostFilterAttributes(IDictionary attributes) {

            // If this component is being inherited, mark it as such in the class attributes.
            //
            if (!InheritanceAttribute.Equals(InheritanceAttribute.NotInherited)) {
                attributes[typeof(InheritanceAttribute)] = InheritanceAttribute;
            }
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.PostFilterEvents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Allows
        ///       a designer to filter the set of events the
        ///       component it is designing will expose through the
        ///       TypeDescriptor object.
        ///    </para>
        /// </devdoc>
        protected virtual void PostFilterEvents(IDictionary events) {

            // If this component is being privately inherited, we need to filter
            // the events to make them read-only.
            //
            if (InheritanceAttribute.Equals(InheritanceAttribute.InheritedReadOnly)) {
                EventDescriptor[] values = new EventDescriptor[events.Values.Count];
                events.Values.CopyTo(values, 0);
                
                for (int i = 0; i < values.Length; i++) {
                    EventDescriptor evt = values[i];
                    events[evt.Name] = TypeDescriptor.CreateEvent(evt.ComponentType, evt, ReadOnlyAttribute.Yes);
                }
            }
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.PostFilterProperties"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Allows
        ///       a designer to filter the set of properties the
        ///       component it is designing will expose through the
        ///       TypeDescriptor object.
        ///    </para>
        /// </devdoc>
        protected virtual void PostFilterProperties(IDictionary properties) {

            // Check for inheritance
            //
            if (inheritedProps != null) {

                bool readOnlyInherit = (InheritanceAttribute.Equals(InheritanceAttribute.InheritedReadOnly));

                if (readOnlyInherit) {
                    // Now loop through all the properties.  For each one, try to match a pre-created property.
                    // If that fails, then create a new property.
                    //
                    PropertyDescriptor[] values = new PropertyDescriptor[properties.Values.Count];
                    properties.Values.CopyTo(values, 0);
                    
                    for (int i = 0; i < values.Length; i++) {
                        PropertyDescriptor prop = values[i];
                          // This is a private component.  Therefore, the user should not be
                          // allowed to modify any properties.  We replace all properties with
                          // read-only versions.
                          //
                          properties[prop.Name] = TypeDescriptor.CreateProperty(prop.ComponentType, prop, ReadOnlyAttribute.Yes);
                    }
                }
                else {
                    // otherwise apply our inherited properties to the actual property list.
                    //
                    foreach (DictionaryEntry de in inheritedProps) {
                        InheritedPropertyDescriptor inheritedPropDesc = de.Value as InheritedPropertyDescriptor;
                        
                        if (inheritedPropDesc != null) {
                            // replace the property descriptor it was created 
                            // with with the new one in case we're shadowing
                            //
                            PropertyDescriptor newInnerProp = (PropertyDescriptor)properties[de.Key];
                            if (newInnerProp != null) {
                                inheritedPropDesc.PropertyDescriptor = newInnerProp;
                                properties[de.Key] = inheritedPropDesc;
                            }
                        }
                    }
                }
            }
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.PreFilterAttributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Allows a designer
        ///       to filter the set of member attributes the component
        ///       it is designing will expose through the TypeDescriptor
        ///       object.
        ///    </para>
        /// </devdoc>
        protected virtual void PreFilterAttributes(IDictionary attributes) {
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.PreFilterEvents"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Allows a
        ///       designer to filter the set of events the component
        ///       it is designing will expose through the TypeDescriptor
        ///       object.
        ///    </para>
        /// </devdoc>
        protected virtual void PreFilterEvents(IDictionary events) {
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.PreFilterProperties"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Allows a
        ///       designer to filter the set of properties the component
        ///       it is designing will expose through the TypeDescriptor
        ///       object.
        ///    </para>
        /// </devdoc>
        protected virtual void PreFilterProperties(IDictionary properties) {
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.RaiseComponentChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Notifies the <see cref='System.ComponentModel.Design.IComponentChangeService'/> that this component
        ///       has been changed. You only need to call this when you are
        ///       affecting component properties directly and not through the
        ///       MemberDescriptor's accessors.
        ///    </para>
        /// </devdoc>
        protected void RaiseComponentChanged(MemberDescriptor member, Object oldValue, Object newValue) {
            IComponentChangeService changeSvc = (IComponentChangeService)GetService(typeof(IComponentChangeService));
            if (changeSvc != null) {
                changeSvc.OnComponentChanged(Component, member, oldValue, newValue);
            }
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.RaiseComponentChanging"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Notifies the <see cref='System.ComponentModel.Design.IComponentChangeService'/> that this component is
        ///       about to be changed. You only need to call this when you are
        ///       affecting component properties directly and not through the
        ///       MemberDescriptor's accessors.
        ///    </para>
        /// </devdoc>
        protected void RaiseComponentChanging(MemberDescriptor member) {
            IComponentChangeService changeSvc = (IComponentChangeService)GetService(typeof(IComponentChangeService));
            if (changeSvc != null) {
                changeSvc.OnComponentChanging(Component, member);
            }
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.IDesignerFilter.PostFilterAttributes"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para> Allows a designer to filter the set of
        /// attributes the component being designed will expose through the <see cref='System.ComponentModel.TypeDescriptor'/> object.</para>
        /// </devdoc>
        void IDesignerFilter.PostFilterAttributes(IDictionary attributes) {
            PostFilterAttributes(attributes);
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.IDesignerFilter.PostFilterEvents"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para> Allows a designer to filter the set of events
        /// the component being designed will expose through the <see cref='System.ComponentModel.TypeDescriptor'/>
        /// object.</para>
        /// </devdoc>
        void IDesignerFilter.PostFilterEvents(IDictionary events) {
            PostFilterEvents(events);
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.IDesignerFilter.PostFilterProperties"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para> Allows a designer to filter the set of properties
        /// the component being designed will expose through the <see cref='System.ComponentModel.TypeDescriptor'/>
        /// object.</para>
        /// </devdoc>
        void IDesignerFilter.PostFilterProperties(IDictionary properties) {
            PostFilterProperties(properties);
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.IDesignerFilter.PreFilterAttributes"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para> Allows a designer to filter the set of
        /// attributes the component being designed will expose through the <see cref='System.ComponentModel.TypeDescriptor'/>
        /// object.</para>
        /// </devdoc>
        void IDesignerFilter.PreFilterAttributes(IDictionary attributes) {
            PreFilterAttributes(attributes);
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.IDesignerFilter.PreFilterEvents"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para> Allows a designer to filter the set of events
        /// the component being designed will expose through the <see cref='System.ComponentModel.TypeDescriptor'/>
        /// object.</para>
        /// </devdoc>
        void IDesignerFilter.PreFilterEvents(IDictionary events) {
            PreFilterEvents(events);
        }

        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.IDesignerFilter.PreFilterProperties"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para> Allows a designer to filter the set of properties
        /// the component being designed will expose through the <see cref='System.ComponentModel.TypeDescriptor'/>
        /// object.</para>
        /// </devdoc>
        void IDesignerFilter.PreFilterProperties(IDictionary properties) {
            PreFilterProperties(properties);
        }
        
        /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.ShadowPropertyCollection"]/*' />
        /// <devdoc>
        ///     Collection that holds shadow properties.
        /// </devdoc>
        protected sealed class ShadowPropertyCollection {
            private ComponentDesigner designer;
            private Hashtable         properties;
            private Hashtable         descriptors;
        
            internal ShadowPropertyCollection(ComponentDesigner designer) {
                this.designer = designer;
            }
            
            /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.ShadowPropertyCollection.this"]/*' />
            /// <devdoc>
            ///     Accesses the given property name.  This will throw an exception if the property does not exsit on the
            ///     base component.
            /// </devdoc>
            public object this[string propertyName] {
                get {
                    if (propertyName == null) {
                        throw new ArgumentNullException("propertyName");
                    }
                    
                    // First, check to see if the name is in the given properties table
                    if (properties != null && properties.ContainsKey(propertyName)) {
                        return properties[propertyName];
                    }
                    
                    // Next, check to see if the name is in the descriptors table.  If
                    // it isn't, we will search the underlying component and add it.
                    PropertyDescriptor property = GetShadowedPropertyDescriptor(propertyName);
                    
                    return property.GetValue(designer.Component);
                }
                set {
                    if (properties == null) {
                        properties = new Hashtable();
                    }
                    properties[propertyName] = value;
                }
            }
            
            /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.ShadowPropertyCollection.Contains"]/*' />
            /// <devdoc>
            ///     Returns true if this shadow properties object contains the given property name.
            /// </devdoc>
            public bool Contains(string propertyName) {
                return (properties != null && properties.ContainsKey(propertyName));
            }

            /// <devdoc>
            ///     Returns the underlying property descriptor for this property on the component
            /// </devdoc>
            private PropertyDescriptor GetShadowedPropertyDescriptor(string propertyName) {

                if (descriptors == null) {
                    descriptors = new Hashtable();
                }

                PropertyDescriptor property = (PropertyDescriptor)descriptors[propertyName];
                if (property == null) {
                    property = TypeDescriptor.GetProperties(designer.Component.GetType())[propertyName];
                    if (property == null) {
                        throw new ArgumentException(SR.GetString(SR.DesignerPropNotFound, propertyName, designer.Component.GetType().FullName));
                    }
                    descriptors[propertyName] = property;
                }
                return property;
            }

            /// <include file='doc\ComponentDesigner.uex' path='docs/doc[@for="ComponentDesigner.ShadowPropertyCollection.ShouldSerializeValue"]/*' />
            /// <devdoc>
            ///     Returns true if the given property name should be serialized, or false
            ///     if not.  This is useful in implementing your own ShouldSerialize* methods
            ///     on shadowed properties.
            /// </devdoc>
            internal bool ShouldSerializeValue(string propertyName, object defaultValue) {

                // CONSIDER: Promote this guy to be public.  I like it.
                
                if (propertyName == null) {
                    throw new ArgumentNullException("propertyName");
                }

                if (Contains(propertyName)) {
                    return !object.Equals(this[propertyName], defaultValue);
                }
                else {
                    return GetShadowedPropertyDescriptor(propertyName).ShouldSerializeValue(designer.Component);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\inheritedpropertydescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="InheritedPropertyDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;    
    using System.Windows.Forms;
    using System.Reflection;
    using Microsoft.Win32;

    /// <include file='doc\InheritedPropertyDescriptor.uex' path='docs/doc[@for="InheritedPropertyDescriptor"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>Describes and represents inherited properties in an inherited
    ///       class.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class InheritedPropertyDescriptor : PropertyDescriptor {
        private PropertyDescriptor propertyDescriptor;
        private object defaultValue;
        private static object noDefault = new Object();
        private bool initShouldSerialize;

        private object originalValue;

        /// <include file='doc\InheritedPropertyDescriptor.uex' path='docs/doc[@for="InheritedPropertyDescriptor.InheritedPropertyDescriptor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.Design.InheritedPropertyDescriptor'/> class.
        ///    </para>
        /// </devdoc>
        public InheritedPropertyDescriptor(
            PropertyDescriptor propertyDescriptor,
            object component,
            bool rootComponent)
            : base(propertyDescriptor, new Attribute[] {}) {

            Debug.Assert(!(propertyDescriptor is InheritedPropertyDescriptor), "Recursive inheritance propertyDescriptor " + propertyDescriptor.ToString());
            this.propertyDescriptor = propertyDescriptor;
        
            InitInheritedDefaultValue(component, rootComponent);

            ArrayList attributes = new ArrayList(AttributeArray);
            attributes.Add(new DefaultValueAttribute(defaultValue));
            Attribute[] attributeArray = new Attribute[attributes.Count];
            attributes.CopyTo(attributeArray, 0);
            AttributeArray = attributeArray;
        }

        /// <include file='doc\InheritedPropertyDescriptor.uex' path='docs/doc[@for="InheritedPropertyDescriptor.ComponentType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the type of the component this property descriptor is bound to.
        ///    </para>
        /// </devdoc>
        public override Type ComponentType {
            get {
                return propertyDescriptor.ComponentType;
            }
        }

        /// <include file='doc\InheritedPropertyDescriptor.uex' path='docs/doc[@for="InheritedPropertyDescriptor.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether this property is read only.
        ///    </para>
        /// </devdoc>
        public override bool IsReadOnly {
            get {
                return propertyDescriptor.IsReadOnly || Attributes[typeof(ReadOnlyAttribute)].Equals(ReadOnlyAttribute.Yes);
            }
        }

        internal object OriginalValue {
            get {
                return originalValue;
            }
        }

        internal PropertyDescriptor PropertyDescriptor {
            get {
                return this.propertyDescriptor;
            }
            set {
                Debug.Assert(!(value is InheritedPropertyDescriptor), "Recursive inheritance propertyDescriptor " + propertyDescriptor.ToString());
                this.propertyDescriptor = value;
            }
        }
        
        /// <include file='doc\InheritedPropertyDescriptor.uex' path='docs/doc[@for="InheritedPropertyDescriptor.PropertyType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the type of the property.
        ///    </para>
        /// </devdoc>
        public override Type PropertyType {
            get {
                return propertyDescriptor.PropertyType;
            }
        }

        /// <include file='doc\InheritedPropertyDescriptor.uex' path='docs/doc[@for="InheritedPropertyDescriptor.CanResetValue"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether reset will change
        ///       the value of the component.</para>
        /// </devdoc>
        public override bool CanResetValue(object component) {

            // We always have a default value, because we got it from the component
            // when we were constructed.
            //
            if (defaultValue == noDefault) {
                return propertyDescriptor.CanResetValue(component);
            }
            else {
                return !object.Equals(GetValue(component),defaultValue);
            }
        }

        private object ClonedDefaultValue(object value) {
            DesignerSerializationVisibilityAttribute dsva = (DesignerSerializationVisibilityAttribute)propertyDescriptor.Attributes[typeof(DesignerSerializationVisibilityAttribute)];
            DesignerSerializationVisibility serializationVisibility;

            // if we have a persist contents guy, we'll need to try to clone the value because
            // otherwise we won't be able to tell when it's been modified.
            //
            if (dsva == null) {
                serializationVisibility = DesignerSerializationVisibility.Visible;
            }
            else {
                serializationVisibility = dsva.Visibility;
            }

            if (value != null && serializationVisibility == DesignerSerializationVisibility.Content) {
                if (value is ICloneable) {
                    // if it's clonable, clone it...
                    //
                    value = ((ICloneable)value).Clone();
                }
                else {
                    // otherwise, we'll just have to always spit it.
                    //
                    value = noDefault;
                }
            }
            return value;
        }
        
        /// <include file='doc\InheritedPropertyDescriptor.uex' path='docs/doc[@for="InheritedPropertyDescriptor.GetValue"]/*' />
        /// <devdoc>
        ///    <para> Gets the current value of the property on the component,
        ///       invoking the getXXX method.</para>
        /// </devdoc>
        public override object GetValue(object component) {
            return propertyDescriptor.GetValue(component);
        }

        private void InitInheritedDefaultValue(object component, bool rootComponent) {
            try {

                object currentValue;

                // Don't just get the default value.  Check to see if the propertyDescriptor has
                // indicated ShouldSerialize, and if it hasn't try to use the default value.
                // We need to do this for properties that inherit from their parent.  If we
                // are processing properties on the root component, we always favor the presence
                // of a default value attribute.  The root component is always inherited
                // but some values should always be written into code.
                //
                if (!propertyDescriptor.ShouldSerializeValue(component)) {
                    DefaultValueAttribute defaultAttribute = (DefaultValueAttribute)propertyDescriptor.Attributes[typeof(DefaultValueAttribute)];
                    if (defaultAttribute != null) {
                        defaultValue = defaultAttribute.Value;
                        currentValue = defaultValue;
                    }
                    else {
                        defaultValue = noDefault;
                        currentValue = propertyDescriptor.GetValue(component);
                    }
                }
                else {
                    defaultValue = propertyDescriptor.GetValue(component);
                    currentValue = defaultValue;
                    defaultValue = ClonedDefaultValue(defaultValue);
                }

                SaveOriginalValue(currentValue);
            }
            catch(Exception) {
                // If the property get blows chunks, then the default value is NoDefault and
                // we resort to the base property descriptor.
                this.defaultValue = noDefault;
            }

            this.initShouldSerialize = ShouldSerializeValue(component);
        }

        /// <include file='doc\InheritedPropertyDescriptor.uex' path='docs/doc[@for="InheritedPropertyDescriptor.ResetValue"]/*' />
        /// <devdoc>
        ///    <para>Resets the default value for this property
        ///       on the component.</para>
        /// </devdoc>
        public override void ResetValue(object component) {
            if (defaultValue == noDefault) {
                propertyDescriptor.ResetValue(component);
            }
            else {
                SetValue(component, defaultValue);
            }
        }

        private void SaveOriginalValue(object value) {
            if (value is ICollection) {
                originalValue = new object[((ICollection)value).Count];
                ((ICollection)value).CopyTo((Array)originalValue, 0);
            }
            else {
                originalValue = value;
            }
        }

        /// <include file='doc\InheritedPropertyDescriptor.uex' path='docs/doc[@for="InheritedPropertyDescriptor.SetValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the value to be the new value of this property
        ///       on the component by invoking the setXXX method on the component.
        ///    </para>
        /// </devdoc>
        public override void SetValue(object component, object value) {
            propertyDescriptor.SetValue(component, value);
        }

        /// <include file='doc\InheritedPropertyDescriptor.uex' path='docs/doc[@for="InheritedPropertyDescriptor.ShouldSerializeValue"]/*' />
        /// <devdoc>
        ///    <para>Indicates whether the value of this property needs to be persisted.</para>
        /// </devdoc>
        public override bool ShouldSerializeValue(object component) {

            if (IsReadOnly) {
                return Attributes.Contains(DesignerSerializationVisibilityAttribute.Content);
            }

            if (defaultValue == noDefault) {
                return propertyDescriptor.ShouldSerializeValue(component);
            }
            else {
                return !object.Equals(GetValue(component), defaultValue);
            }
        }
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\localizer.cs ===
//------------------------------------------------------------------------------
// <copyright file="Localizer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Design;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using System;
    using System.Globalization;
    using System.Windows.Forms;    
    using System.Windows.Forms.Design;    
    using Microsoft.Win32;
    using System.Threading;
    using System.Runtime.Remoting.Contexts;

    /// <include file='doc\Localizer.uex' path='docs/doc[@for="LocalizationExtenderProvider"]/*' />
    /// <devdoc>
    ///    <para>Provides design-time localization support to enable code 
    ///       generators to provide localization features.</para>
    /// </devdoc>
    [
    System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode),
    ProvideProperty("Language", typeof(object)),
    ProvideProperty("LoadLanguage", typeof(object)),
    ProvideProperty("Localizable", typeof(object))
    ]
    public class LocalizationExtenderProvider : IExtenderProvider, IDisposable {

        private IServiceProvider  serviceProvider;
        private IComponent              baseComponent;
        private bool                    localizable;
        private bool                    defaultLocalizable = false;
        private CultureInfo             language;
        private CultureInfo             loadLanguage;
        private CultureInfo             defaultLanguage;

        private const string            KeyThreadDefaultLanguage = "_Thread_Default_Language";
        

        /// <include file='doc\Localizer.uex' path='docs/doc[@for="LocalizationExtenderProvider.LocalizationExtenderProvider"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.Design.LocalizationExtenderProvider'/> class using the
        ///    specified service provider and base component.</para>
        /// </devdoc>
        public LocalizationExtenderProvider(ISite serviceProvider, IComponent baseComponent) {
            this.serviceProvider = (IServiceProvider)serviceProvider;
            this.baseComponent = baseComponent;

            if (serviceProvider != null) {

                IExtenderProviderService es = (IExtenderProviderService)serviceProvider.GetService(typeof(IExtenderProviderService));
                if (es != null) {
                    es.AddExtenderProvider(this);
                }
            }
            language = CultureInfo.InvariantCulture;

            //We need to check to see if our baseComponent has its localizable value persisted into 
            //the resource file.  If so, we'll want to "inherit" this value for our baseComponent.
            //This enables us to create Inherited forms and inherit the  localizable props from the base.
            System.Resources.ResourceManager resources = new System.Resources.ResourceManager(baseComponent.GetType());
            if (resources != null) {
                System.Resources.ResourceSet rSet = resources.GetResourceSet(language, true, false);
                if (rSet != null) {
                    object objLocalizable = rSet.GetObject("$this.Localizable");
                    if (objLocalizable is bool) {
                        defaultLocalizable = (bool)objLocalizable;
                        this.localizable = defaultLocalizable;
                    }
                }
            }
        }

        private CultureInfo ThreadDefaultLanguage {
            get {
                lock(typeof(LocalizationExtenderProvider)){
                    if (defaultLanguage != null) {
                        return defaultLanguage;
                    }
    
                    LocalDataStoreSlot dataSlot = Thread.GetNamedDataSlot(LocalizationExtenderProvider.KeyThreadDefaultLanguage);


                    if (dataSlot == null) {
                        Debug.Fail("Failed to get a data slot for ui culture");
                        return null;
                    }


                    this.defaultLanguage = (CultureInfo)Thread.GetData(dataSlot);
    
                    if (this.defaultLanguage == null) {
                        this.defaultLanguage = Application.CurrentCulture;
                        Thread.SetData(dataSlot, this.defaultLanguage);
                    }
                }
                return this.defaultLanguage;
            }
        }

        /// <include file='doc\Localizer.uex' path='docs/doc[@for="LocalizationExtenderProvider.GetLanguage"]/*' />
        /// <devdoc>
        ///    <para>Gets the language set for the specified object.</para>
        /// </devdoc>
        [
        DesignOnly(true),
        Localizable(true),
        SRDescriptionAttribute("ParentControlDesignerLanguageDescr")
        ]
        public CultureInfo GetLanguage(object o) {
            return language;
        }

        /// <include file='doc\Localizer.uex' path='docs/doc[@for="LocalizationExtenderProvider.GetLoadLanguage"]/*' />
        /// <devdoc>
        ///    <para>Gets the language we'll use when re-loading the designer.</para>
        /// </devdoc>
        [
        DesignOnly(true),
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        ]
        public CultureInfo GetLoadLanguage(object o) {
            // If we never configured the load language, we're always invariant.
            if (loadLanguage == null) {
                loadLanguage = CultureInfo.InvariantCulture;
            }
            return loadLanguage;
        }

        /// <include file='doc\Localizer.uex' path='docs/doc[@for="LocalizationExtenderProvider.GetLocalizable"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the specified object supports design-time localization 
        ///       support.</para>
        /// </devdoc>
        [
        DesignOnly(true),
        Localizable(true),
        SRDescriptionAttribute("ParentControlDesignerLocalizableDescr")
        ]
        public bool GetLocalizable(object o) {
            return localizable;
        }

        /// <include file='doc\Localizer.uex' path='docs/doc[@for="LocalizationExtenderProvider.SetLanguage"]/*' />
        /// <devdoc>
        ///    <para>Sets the language to use.</para>
        /// </devdoc>
        public void SetLanguage(object o, CultureInfo language) {
            
            if(language == null) {
                language = CultureInfo.InvariantCulture;
            }
            
            if (this.language.Equals(language)) {
                return;
            }
            
            bool isInvariantCulture = (language.Equals(CultureInfo.InvariantCulture));
            CultureInfo defaultUICulture = this.ThreadDefaultLanguage;

            this.language = language;
            
            if (!isInvariantCulture) {
                SetLocalizable(null,true);
            }
            
            
            if (serviceProvider != null) {
                IDesignerLoaderService ls = (IDesignerLoaderService)serviceProvider.GetService(typeof(IDesignerLoaderService));
                IDesignerHost host = (IDesignerHost)serviceProvider.GetService(typeof(IDesignerHost));
                


                // Only reload if we're not in the process of loading!
                //
                if (host != null) {

                    // If we're loading, adopt the load language for later use.
                    //
                    if (host.Loading) {
                        loadLanguage = language;
                    }
                    else {
                        bool reloadSuccessful = false;
                        if (ls != null) {
                            reloadSuccessful = ls.Reload();
                        }
                        if (!reloadSuccessful) {
                            IUIService uis = (IUIService)serviceProvider.GetService(typeof(IUIService));
                            if (uis != null) {
                                uis.ShowMessage(SR.GetString(SR.LocalizerManualReload));
                            }
                        }
                    }
                }
            }
        }

        /// <include file='doc\Localizer.uex' path='docs/doc[@for="LocalizationExtenderProvider.SetLocalizable"]/*' />
        /// <devdoc>
        ///    <para>Sets a value indicating whether or not the specified object has design-time 
        ///       localization support.</para>
        /// </devdoc>
        public void SetLocalizable(object o, bool localizable) {
            this.localizable = localizable;
            if (!localizable) {
                SetLanguage(null, CultureInfo.InvariantCulture);
            }
        }
        
        /// <include file='doc\Localizer.uex' path='docs/doc[@for="LocalizationExtenderProvider.ShouldSerializeLanguage"]/*' />
        /// <devdoc>
        ///    <para> Gets a value indicating whether the specified object should have its design-time localization support persisted. </para>
        /// </devdoc>
        public bool ShouldSerializeLanguage(object o) {
            return (language != null && language != CultureInfo.InvariantCulture);
        }

        /// <devdoc>
        ///    <para> Gets a value indicating whether the specified object should have its design-time localization support persisted. </para>
        /// </devdoc>
        private bool ShouldSerializeLocalizable(object o) {
            return (localizable != defaultLocalizable);
        }

        /// <devdoc>
        ///    <para> Resets the localizable property to the 'defaultLocalizable' value. </para>
        /// </devdoc>
        private void ResetLocalizable(object o) {
            SetLocalizable(null, defaultLocalizable);
        }
        
        /// <include file='doc\Localizer.uex' path='docs/doc[@for="LocalizationExtenderProvider.ResetLanguage"]/*' />
        /// <devdoc>
        ///    <para> Resets the language for the specified 
        ///       object.</para>
        /// </devdoc>
        public void ResetLanguage(object o) {
            SetLanguage(null, CultureInfo.InvariantCulture);
        }

        /// <include file='doc\Localizer.uex' path='docs/doc[@for="LocalizationExtenderProvider.Dispose"]/*' />
        /// <devdoc>
        /// <para>Disposes of the resources (other than memory) used by the <see cref='System.ComponentModel.Design.LocalizationExtenderProvider'/>.</para>
        /// </devdoc>
        public void Dispose() {
            if (serviceProvider != null) {

                IExtenderProviderService es = (IExtenderProviderService)serviceProvider.GetService(typeof(IExtenderProviderService));
                if (es != null) {
                    es.RemoveExtenderProvider(this);
                }
            }
        }

        /// <include file='doc\Localizer.uex' path='docs/doc[@for="LocalizationExtenderProvider.CanExtend"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the <see cref='System.ComponentModel.Design.LocalizationExtenderProvider'/> provides design-time localization information for the specified object.</para>
        /// </devdoc>
        public bool CanExtend(object o) {
            return o.Equals(baseComponent);

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\inheritanceservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="InheritanceService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.Reflection;
    using System.Windows.Forms;
    using System.ComponentModel.Design.Serialization;
    using AccessedThroughPropertyAttribute = System.Runtime.CompilerServices.AccessedThroughPropertyAttribute;

    /// <include file='doc\InheritanceService.uex' path='docs/doc[@for="InheritanceService"]/*' />
    /// <devdoc>
    ///    <para> Provides a set of methods
    ///       for analyzing and identifying inherited components.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class InheritanceService : IInheritanceService, IDisposable {

        private static TraceSwitch InheritanceServiceSwitch = new TraceSwitch("InheritanceService", "InheritanceService : Debug inheritance scan.");
        
        private Hashtable inheritedComponents;
        
        // While we're adding an inherited component, we must be wary of components
        // that the inherited component adds as a result of being sited.  These
        // are treated as inherited as well.  To track these, we keep track of the
        // component we're currently adding as well as it's inheritance attribute.
        // During the add, we sync IComponentAdding events and push in the component
        //
        private IComponent addingComponent;
        private InheritanceAttribute addingAttribute;

        /// <include file='doc\InheritanceService.uex' path='docs/doc[@for="InheritanceService.InheritanceService"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.Design.InheritanceService'/> class.
        ///    </para>
        /// </devdoc>
        public InheritanceService() {
            inheritedComponents = new Hashtable();
        }

        /// <include file='doc\InheritanceService.uex' path='docs/doc[@for="InheritanceService.Dispose"]/*' />
        /// <devdoc>
        ///    <para>Disposes of the resources (other than memory) used by
        ///       the <see cref='System.ComponentModel.Design.InheritanceService'/>.</para>
        /// </devdoc>
        public void Dispose() {
            if (inheritedComponents != null) {
                inheritedComponents.Clear();
                inheritedComponents = null;
            }
        }

        /// <include file='doc\InheritanceService.uex' path='docs/doc[@for="InheritanceService.AddInheritedComponents"]/*' />
        /// <devdoc>
        /// <para>Adds inherited components to the <see cref='System.ComponentModel.Design.InheritanceService'/>.</para>
        /// </devdoc>
        public void AddInheritedComponents(IComponent component, IContainer container) {
            AddInheritedComponents(component.GetType(), component, container);
        }

        /// <include file='doc\InheritanceService.uex' path='docs/doc[@for="InheritanceService.AddInheritedComponents1"]/*' />
        /// <devdoc>
        /// <para>Adds inherited components to the <see cref='System.ComponentModel.Design.InheritanceService'/>.</para>
        /// </devdoc>
        protected virtual void AddInheritedComponents(Type type, IComponent component, IContainer container) {

            // We get out now if this component type is not assignable from IComponent.  We only walk
            // down to the component level.
            //
            if (type == null || !typeof(IComponent).IsAssignableFrom(type)) {
                return;
            }

            Debug.WriteLineIf(InheritanceServiceSwitch.TraceVerbose, "Searching for inherited components on '" + type.FullName + "'.");

            Debug.Indent();
            
            ISite site = component.Site;
            IComponentChangeService cs = null;
            INameCreationService ncs = null;
            
            if (site != null) {
                ncs = (INameCreationService)site.GetService(typeof(INameCreationService));

                cs = (IComponentChangeService)site.GetService(typeof(IComponentChangeService));
                if (cs != null) {
                    cs.ComponentAdding += new ComponentEventHandler(this.OnComponentAdding);
                }
            }
            
            try {
                while(type != typeof(object)) {
                    FieldInfo[] fields = type.GetFields(BindingFlags.Instance | 
                                                        BindingFlags.DeclaredOnly |
                                                        BindingFlags.Public |
                                                        BindingFlags.NonPublic);
                        
                    Debug.WriteLineIf(InheritanceServiceSwitch.TraceVerbose, "...found " + fields.Length.ToString() + " fields.");
    
                    for (int i = 0; i < fields.Length; i++) {
    
                        FieldInfo field = fields[i];
                        string name = field.Name;
    
                        // Get out now if this field is not assignable from IComponent.
                        //
                        if (!typeof(IComponent).IsAssignableFrom(field.FieldType)) {
                            Debug.WriteLineIf(InheritanceServiceSwitch.TraceVerbose, "...skipping " + name + ": Not IComponent");
                            continue;
                        }
    
                        // Now check the attributes of the field and get out if it isn't something that can
                        // be inherited.
                        //
                        Debug.Assert(!field.IsStatic, "Instance binding shouldn't have found this field");
    
                        // If the value of the field is null, then don't mess with it.  If it wasn't assigned
                        // when our base class was created then we can't really use it.
                        //
                        Object value = field.GetValue(component);
                        if (value == null) {
                            Debug.WriteLineIf(InheritanceServiceSwitch.TraceVerbose, "...skipping " + name + ": Contains NULL");
                            continue;
                        }
                        
                        // We've been fine up to this point looking at the field.  Now, however, we must check to see
                        // if this field has an AccessedThroughPropertyAttribute on it.  If it does, then
                        // we must look for the property and use its name and visibility for the remainder of the
                        // scan.  Should any of this bail we just use the field.
                        //
                        MemberInfo member = field;
                        
                        object[] fieldAttrs = field.GetCustomAttributes(typeof(AccessedThroughPropertyAttribute), false);
                        if (fieldAttrs != null && fieldAttrs.Length > 0) {
                            Debug.Assert(fieldAttrs.Length == 1, "Non-inheritable attribute has more than one copy");
                            Debug.Assert(fieldAttrs[0] is AccessedThroughPropertyAttribute, "Reflection bug:  GetCustomAttributes(type) didn't discriminate by type");
                            AccessedThroughPropertyAttribute propAttr = (AccessedThroughPropertyAttribute)fieldAttrs[0];
                            
                            PropertyInfo fieldProp = type.GetProperty(propAttr.PropertyName, 
                                                                      BindingFlags.Instance | 
                                                                      BindingFlags.Public | 
                                                                      BindingFlags.NonPublic);
                                
                            Debug.Assert(fieldProp != null, "Field declared with AccessedThroughPropertyAttribute has no associated property");
                            Debug.Assert(fieldProp.PropertyType == field.FieldType, "Field declared with AccessedThroughPropertyAttribute is associated with a property with a different return type.");
                            if (fieldProp != null && fieldProp.PropertyType == field.FieldType) {
                            
                                // If the property cannot be read, it is useless to us.
                                //
                                if (!fieldProp.CanRead) {
                                    continue;
                                }
                                
                                // We never access the set for the property, so we
                                // can concentrate on just the get method.
                                member = fieldProp.GetGetMethod(true);
                                Debug.Assert(member != null, "GetGetMethod for property didn't return a method, but CanRead is true");
                                name = propAttr.PropertyName;
                            }
                        }
    
                        // Add a user hook to add or remove members.  The default hook here ignores all inherited
                        // private members.
                        //
                        bool ignoreMember = IgnoreInheritedMember(member, component);
    
                        // We now have an inherited member.  Gather some information about it and then
                        // add it to our list.  We must always add to our list, but we may not want to 
                        // add it to the container.  That is up to the IngoreInheritedMember method.
                        // We add here because there are components in the world that, when sited, 
                        // add their children to the container too. That's fine, but we want to make sure
                        // we account for them in the inheritance service too.
                        //
                        Debug.WriteLineIf(InheritanceServiceSwitch.TraceVerbose, "...found inherited member '" + name + "'");
                        Debug.Indent();
                        Debug.WriteLineIf(InheritanceServiceSwitch.TraceVerbose, "Type: " + field.FieldType.FullName);
    
                        InheritanceAttribute attr;
    
                        Debug.Assert(value is IComponent, "Value of inherited field is not IComponent.  How did this value get into the datatype?");
    
                        bool privateInherited = false;
                        
                        if (ignoreMember) {
                            // If we are ignoring this member, then always mark it as private.
                            // The designer doesn't want it; we only do this in case some other
                            // component adds this guy to the container.
                            //
                            privateInherited = true;
                        }
                        else {
                            if (member is FieldInfo) {
                                FieldInfo fi = (FieldInfo)member;
                                privateInherited = fi.IsPrivate | fi.IsAssembly;
                            }
                            else if (member is MethodInfo) {
                                MethodInfo mi = (MethodInfo)member;
                                privateInherited = mi.IsPrivate | mi.IsAssembly;
                            }
                        }
                        
                        if (privateInherited) {
                            attr = InheritanceAttribute.InheritedReadOnly;
                            Debug.WriteLineIf(InheritanceServiceSwitch.TraceVerbose, "Inheritance: Private");
                        }
                        else {
                            Debug.WriteLineIf(InheritanceServiceSwitch.TraceVerbose, "Inheritance: Public");
                            attr = InheritanceAttribute.Inherited;
                        }
    
                        Debug.Assert(inheritedComponents[value] == null, "We have already visited field " + field.Name);
                        inheritedComponents[value] = attr;
                        
                        if (!ignoreMember) {
                            Debug.WriteLineIf(InheritanceServiceSwitch.TraceVerbose, "Adding " + name + " to container.");
                            try {
                                addingComponent = (IComponent)value;
                                addingAttribute = attr;

                                // Lets make sure this is a valid name
                                if (ncs == null || ncs.IsValidName(name)) {
                                    try {
                                        container.Add((IComponent)value, name);
                                    }
                                    catch { // We do not always control the base components,
                                        // and there could be a lot of rogue base
                                        // components. If there are exceptions when adding
                                        // them, lets just ignore and continue.
                                    }
                                }
                            }
                            finally {
                                addingComponent = null;
                                addingAttribute = null;
                            }
                        }
                    }
    
                    type = type.BaseType;
                }
            }
            finally {
                if (cs != null) {
                    cs.ComponentAdding -= new ComponentEventHandler(this.OnComponentAdding);
                }
    
                Debug.Unindent();
            }
        }

        /// <include file='doc\InheritanceService.uex' path='docs/doc[@for="InheritanceService.IgnoreInheritedMember"]/*' />
        /// <devdoc>
        ///    <para>Indicates the inherited members to ignore.</para>
        /// </devdoc>
        protected virtual bool IgnoreInheritedMember(MemberInfo member, IComponent component) {

            // Our default implementation ignores all private or assembly members.
            //
            if (member is FieldInfo) {
                FieldInfo field = (FieldInfo)member;
                return field.IsPrivate || field.IsAssembly;
            }
            else if (member is MethodInfo) {
                MethodInfo method = (MethodInfo)member;
                return method.IsPrivate || method.IsAssembly;
            }
            
            Debug.Fail("Unknown member type passed to IgnoreInheritedMember");
            return true;
        }

        /// <include file='doc\InheritanceService.uex' path='docs/doc[@for="InheritanceService.GetInheritanceAttribute"]/*' />
        /// <devdoc>
        ///    <para>Gets the inheritance attribute
        ///       of the specified component.</para>
        /// </devdoc>
        public InheritanceAttribute GetInheritanceAttribute(IComponent component) {
            InheritanceAttribute attr = (InheritanceAttribute)inheritedComponents[component];
            if (attr == null) {
                attr = InheritanceAttribute.Default;
            }

            return attr;
        }
        
        private void OnComponentAdding(object sender, ComponentEventArgs ce) {
            if (addingComponent != null && addingComponent != ce.Component) {
                inheritedComponents[ce.Component] = addingAttribute;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\runtimecomponentfilter.cs ===
//------------------------------------------------------------------------------
// <copyright file="RuntimeComponentFilter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Design;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Reflection;    
    using System.Windows.Forms;
    using Microsoft.Win32;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;

    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal abstract class RuntimeComponentFilter {

        public static void FilterProperties(IDictionary properties, ICollection makeReadWrite, ICollection makeBrowsable) {
            FilterProperties(properties, makeReadWrite, makeBrowsable, null);
        }
        
        public static void FilterProperties(IDictionary properties, ICollection makeReadWrite, ICollection makeBrowsable, bool[] browsableSettings) {
            if (makeReadWrite != null) {
                foreach (string name in makeReadWrite) {
                    PropertyDescriptor readOnlyProp = properties[name] as PropertyDescriptor;
    
                    if (readOnlyProp != null) {
                        properties[name] = TypeDescriptor.CreateProperty(readOnlyProp.ComponentType, readOnlyProp, ReadOnlyAttribute.No);
                    }
                    else {
                        Debug.Fail("Didn't find property '" + name + "' to make read/write");
                    }
                }
            }

            if (makeBrowsable != null) {
                int count = -1;

                Debug.Assert(browsableSettings == null || browsableSettings.Length == makeBrowsable.Count, "browsableSettings must be null or same length as makeBrowsable");
                foreach (string name in makeBrowsable) {
                    PropertyDescriptor nonBrowsableProp = properties[name] as PropertyDescriptor;

                    count++;
    
                    if (nonBrowsableProp != null) {
                        Attribute browse;
                        if (browsableSettings == null || browsableSettings[count]) {
                            browse = BrowsableAttribute.Yes;
                        }
                        else {
                            browse = BrowsableAttribute.No;
                        }
                        properties[name] = TypeDescriptor.CreateProperty(nonBrowsableProp.ComponentType, nonBrowsableProp, browse);
                    }
                    else {
                        Debug.Fail("Didn't find property '" + name + "' to make browsable");
                    }
                }
            }
        }

    
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\objectselectoreditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectSelectorEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design {
    using System.Design;
    using System.Runtime.Serialization.Formatters;    
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;    
    using System.Windows.Forms;
    using System.Drawing;
    using System.Windows.Forms.PropertyGridInternal;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;

    using Microsoft.Win32;
    using System.Drawing.Design;


    /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor"]/*' />
    /// <internalonly/>
    /// <devdoc>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public abstract class ObjectSelectorEditor : UITypeEditor {
        /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.subObjectSelector"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool SubObjectSelector = false;
        /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.prevValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected object prevValue = null;
        /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.currValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected object currValue = null;
        private Selector selector = null;

        //
        /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.ObjectSelectorEditor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ObjectSelectorEditor() {
        }

        //
        /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.ObjectSelectorEditor1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ObjectSelectorEditor(bool subObjectSelector) {
            this.SubObjectSelector = subObjectSelector;
        }

        /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.EditValue"]/*' />
        /// <devdoc>
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {
            if (null != provider) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));
                if (edSvc != null) {
                    if (null == selector) {
                        selector = new Selector(this);
                    }

                    prevValue = value;
                    currValue = value;
                    FillTreeWithData(selector, context, provider);
                    selector.Start(edSvc, value);
                    edSvc.DropDownControl(selector);
                    selector.Stop();
                    if (prevValue != currValue) {
                        value = currValue;
                    }
                }
            }

            return value;
        }

        /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.GetEditStyle"]/*' />
        /// <devdoc>
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.DropDown;
        }

        //
        /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.EqualsToValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool EqualsToValue(object value) {
            if (value == currValue)
                return true;
            else
                return false;
        }

        //
        /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.FillTreeWithData"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void FillTreeWithData(Selector selector, ITypeDescriptorContext context, IServiceProvider provider) {
            selector.Clear();
        }

        //
        // override this method to add validation code for new value
        //
        /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.SetValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void SetValue(object value) {
            this.currValue = value;
        }

        //
        //
        //
        /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.Selector"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public class Selector : System.Windows.Forms.TreeView {

            //
            private ObjectSelectorEditor editor = null;
            private IWindowsFormsEditorService edSvc = null;
            /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.Selector.clickSeen"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool clickSeen = false;

            //
            /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.Selector.Selector"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public Selector(ObjectSelectorEditor editor) {
                CreateHandle();
                this.editor = editor;

                this.BorderStyle = BorderStyle.None;
                this.FullRowSelect = !editor.SubObjectSelector;
                this.Scrollable = true;
                this.CheckBoxes = false;
                this.ShowPlusMinus = editor.SubObjectSelector;
                this.ShowLines = editor.SubObjectSelector;
                this.ShowRootLines = editor.SubObjectSelector;

                AfterSelect += new TreeViewEventHandler(this.OnAfterSelect);
            }

            //
            /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.Selector.AddNode"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public SelectorNode AddNode(string label, object value, SelectorNode parent) {
                SelectorNode newNode = new SelectorNode(label, value);

                if (parent != null) {
                    parent.Nodes.Add(newNode);
                }
                else {
                    Nodes.Add(newNode);
                }
                return newNode;
            }

            //
            /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.Selector.Clear"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void Clear() {
                Nodes.Clear();
            }

            //
            /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.Selector.OnAfterSelect"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            protected void OnAfterSelect(object sender, TreeViewEventArgs e) {
                if (clickSeen) {
                    editor.SetValue(((SelectorNode)SelectedNode).value);
                    if (editor.EqualsToValue(((SelectorNode)SelectedNode).value)) {
                        edSvc.CloseDropDown();
                    }
                    clickSeen = false;
                }
            }

            //
            /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.Selector.OnKeyDown"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            protected override void OnKeyDown(KeyEventArgs e) {
                Keys key = e.KeyCode;
                switch (key) {
                    case Keys.Return:
                        editor.SetValue(((SelectorNode)SelectedNode).value);
                        if (editor.EqualsToValue(((SelectorNode)SelectedNode).value)) {
                            e.Handled = true;
                            edSvc.CloseDropDown();
                        }
                        break;
                        
                    case Keys.Escape:
                        editor.SetValue(editor.prevValue);
                        e.Handled = true;
                        edSvc.CloseDropDown();
                        break;
                }
                base.OnKeyDown(e);    
            }
            
            /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.Selector.OnKeyPress"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            protected override void OnKeyPress(KeyPressEventArgs e) {
                switch (e.KeyChar) {
                    case '\r':  // Enter key
                        e.Handled = true;
                        break;
                }
                base.OnKeyPress(e);    
            }

            /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.Selector.SetSelection"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public bool SetSelection(object value, System.Windows.Forms.TreeNodeCollection nodes) {
                TreeNode[] treeNodes;

                if (nodes == null) {
                    treeNodes = new TreeNode[this.Nodes.Count];
                    this.Nodes.CopyTo(treeNodes, 0);
                }
                else {
                    treeNodes = new TreeNode[nodes.Count];
                    nodes.CopyTo(treeNodes, 0);
                }

                int len = treeNodes.Length;
                if (len == 0) return false;

                for (int i=0; i<len; i++) {
                    if (((SelectorNode)treeNodes[i]).value == value) {
                        SelectedNode = treeNodes[i];
                        return true;
                    }
                    if ((treeNodes[i].Nodes != null) && (treeNodes[i].Nodes.Count != 0)) {
                        treeNodes[i].Expand();
                        if (SetSelection(value, treeNodes[i].Nodes)) {
                            return true;
                        }
                        treeNodes[i].Collapse();
                    }
                }
                return false;
            }

            //
            /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.Selector.Start"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void Start(IWindowsFormsEditorService edSvc, object value) {
                this.edSvc = edSvc;
                SetSelection(value, Nodes);
            }

            //
            /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.Selector.Stop"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public void Stop() {
                this.edSvc = null;
            }

            //
            /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.Selector.WndProc"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            protected override void WndProc(ref Message m) {
                switch (m.Msg) {
                    case NativeMethods.WM_GETDLGCODE:
                        m.Result = (IntPtr)((long)m.Result | NativeMethods.DLGC_WANTALLKEYS);
                        return;
                    case NativeMethods.WM_MOUSEMOVE:
                        if (clickSeen) {
                            clickSeen = false;
                        }
                        break;
                    case NativeMethods.WM_REFLECT + NativeMethods.WM_NOTIFY:
                        NativeMethods.NMTREEVIEW nmtv = (NativeMethods.NMTREEVIEW)Marshal.PtrToStructure(m.LParam, typeof(NativeMethods.NMTREEVIEW));
                        if (nmtv.nmhdr.code == NativeMethods.NM_CLICK) {
                            clickSeen = true;
                        }
                        break;
                }
                base.WndProc(ref m);
            }
        }

        //
        /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.SelectorNode"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public class SelectorNode : System.Windows.Forms.TreeNode {
            /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.SelectorNode.value"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public object value = null;

            /// <include file='doc\ObjectSelectorEditor.uex' path='docs/doc[@for="ObjectSelectorEditor.SelectorNode.SelectorNode"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            public SelectorNode(string label, object value) : base (label) {
                this.value = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\collectioneditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="CollectionEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design {
    using System.Design;
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    using System;
    using System.Collections;
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Drawing2D;
    using System.Drawing.Imaging;
    using System.IO;
    using System.Drawing.Design;
    using System.Reflection;
    using System.Windows.Forms;
    using System.Windows.Forms.ComponentModel;
    using System.Windows.Forms.Design;
    using System.Runtime.Serialization.Formatters.Binary;
    

    /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor"]/*' />
    /// <devdoc>
    ///    <para>Provides a generic editor for most any collection.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class CollectionEditor : UITypeEditor {
        private CollectionForm         collectionForm;
        private Type                   type;
        private Type                   collectionItemType;
        private Type[]                 newItemTypes;
        private ITypeDescriptorContext context;
        
        private bool                   ignoreChangedEvents = false;
        private bool                   ignoreChangingEvents = false;
        
        
        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.Design.CollectionEditor'/> class using the
        ///       specified collection type.
        ///    </para>
        /// </devdoc>
        public CollectionEditor(Type type) {
            this.type = type;
        }

        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionItemType"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the data type of each item in the collection.</para>
        /// </devdoc>
        protected Type CollectionItemType {
            get {
                if (collectionItemType == null) {
                    collectionItemType = CreateCollectionItemType();
                }
                return collectionItemType;
            }
        }

        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the type of the collection.
        ///    </para>
        /// </devdoc>
        protected Type CollectionType {
            get {
                return type;
            }
        }

        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.Context"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a type descriptor that indicates the current context.
        ///    </para>
        /// </devdoc>
        protected ITypeDescriptorContext Context {
            get {
                return context;
            }
        }

        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.NewItemTypes"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets
        ///       the available item types that can be created for this collection.</para>
        /// </devdoc>
        protected Type[] NewItemTypes {
            get {
                if (newItemTypes == null) {
                    newItemTypes = CreateNewItemTypes();
                }
                return newItemTypes;
            }
        }

        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.HelpTopic"]/*' />
        /// <devdoc>
        ///    <para>Gets the help topic to display for the dialog help button or pressing F1. Override to
        ///          display a different help topic.</para>
        /// </devdoc>
        protected virtual string HelpTopic {
            get {
                return "net.ComponentModel.CollectionEditor";
            }
        }
        
        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CanRemoveInstance"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether original members of the collection can be removed.</para>
        /// </devdoc>
        protected virtual bool CanRemoveInstance(object value) {
            IComponent comp = value as IComponent;
            if (value != null) {
                // Make sure the component is not being inherited -- we can't delete these!
                //
                InheritanceAttribute ia = (InheritanceAttribute)TypeDescriptor.GetAttributes(comp)[typeof(InheritanceAttribute)];
                if (ia != null && ia.InheritanceLevel != InheritanceLevel.NotInherited) {
                    return false;
                }
            }
            
            return true;
        }

        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CanSelectMultipleInstances"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether multiple collection members can be
        ///       selected.</para>
        /// </devdoc>
        protected virtual bool CanSelectMultipleInstances() {
            return true;
        }
        
        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CreateCollectionForm"]/*' />
        /// <devdoc>
        ///    <para>Creates a
        ///       new form to show the current collection.</para>
        /// </devdoc>
        protected virtual CollectionForm CreateCollectionForm() {
            return new CollectionEditorCollectionForm(this);
        }

        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CreateInstance"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a new instance of the specified collection item type.
        ///    </para>
        /// </devdoc>
        protected virtual object CreateInstance(Type itemType) {
            return CollectionEditor.CreateInstance(itemType, (IDesignerHost)GetService(typeof(IDesignerHost)), null);    
        }
        
        internal static object CreateInstance(Type itemType, IDesignerHost host, string name) {
            object instance = null;

            if (typeof(IComponent).IsAssignableFrom(itemType)) {
                if (host != null) {
                    instance = host.CreateComponent(itemType, (string)name);

                    // Set component defaults
                    if (host != null) {
                        IDesigner designer = host.GetDesigner((IComponent)instance);
                        if (designer is ComponentDesigner) {
                            ((ComponentDesigner) designer).OnSetComponentDefaults();
                        }
                    }
                }
            }

            if (instance == null) {
                instance = Activator.CreateInstance(itemType, BindingFlags.Instance | BindingFlags.Public | BindingFlags.CreateInstance, null, null, null);
            }
            
            return instance;
        }

        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CreateCollectionItemType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an instance of
        ///       the data type this collection contains.
        ///    </para>
        /// </devdoc>
        protected virtual Type CreateCollectionItemType() {
            PropertyInfo[] props = CollectionType.GetProperties();

            for (int i = 0; i < props.Length; i++) {
                if (props[i].Name.Equals("Item") || props[i].Name.Equals("Items")) {
                    return props[i].PropertyType;
                }
            }
            
            // Couldn't find anything.  Return Object

            Debug.Fail("Collection " + CollectionType.FullName + " contains no Item or Items property so we cannot display and edit any values");
            return typeof(object);
        }

        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CreateNewItemTypes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the data
        ///       types this collection editor can create.
        ///    </para>
        /// </devdoc>
        protected virtual Type[] CreateNewItemTypes() {
            return new Type[] {CollectionItemType};
        }

        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.DestroyInstance"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Destroys the specified instance of the object.
        ///    </para>
        /// </devdoc>
        protected virtual void DestroyInstance(object instance) {
            if (instance is IComponent) {
                IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                if (host != null) {
                    host.DestroyComponent((IComponent)instance);
                }
                else {
                    ((IComponent)instance).Dispose();
                }
            }
        }

        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.EditValue"]/*' />
        /// <devdoc>
        ///    <para>Edits the specified object value using the editor style 
        ///       provided by <see cref='System.ComponentModel.Design.CollectionEditor.GetEditStyle'/>.</para>
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {
            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));

                if (edSvc != null) {
                    
                    if (collectionForm == null || collectionForm.Visible) {
                        collectionForm = CreateCollectionForm();
                    }
                    CollectionForm localCollectionForm = collectionForm;

                    this.context = context;
                    localCollectionForm.EditValue = value;
                    ignoreChangingEvents = false;
                    ignoreChangedEvents = false;
                    DesignerTransaction trans = null;

                    bool commitChange = true;
                    IComponentChangeService cs = null;
                    IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                    
                    try {
                        try {
                            if (host != null) {
                                trans = host.CreateTransaction(SR.GetString(SR.CollectionEditorUndoBatchDesc, CollectionItemType.Name));
                            }
                        }
                        catch(CheckoutException cxe) {
                            if (cxe == CheckoutException.Canceled)
                                return value;
        
                            throw cxe;
                        }
                        
                        cs = host != null ? (IComponentChangeService)host.GetService(typeof(IComponentChangeService)) : null;
                        
                        if (cs != null) {
                            cs.ComponentChanged += new ComponentChangedEventHandler(this.OnComponentChanged);
                            cs.ComponentChanging += new ComponentChangingEventHandler(this.OnComponentChanging);
                        }
                    
                        if (localCollectionForm.ShowEditorDialog(edSvc) == DialogResult.OK) {
                            value = localCollectionForm.EditValue;
                        }
                        else {
                            commitChange = false;
                        }
                    }
                    finally {
                        this.context = null;
                        localCollectionForm.EditValue = null;
                        if (trans != null) {
                            if (commitChange) {
                                trans.Commit();
                            }
                            else {
                                trans.Cancel();
                            }
                        }
                        
                        if (cs != null) {
                            cs.ComponentChanged -= new ComponentChangedEventHandler(this.OnComponentChanged);
                            cs.ComponentChanging -= new ComponentChangingEventHandler(this.OnComponentChanging);
                        }
                    }
                }
            }

            return value;
        }

        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///    <para>Gets the editing style of the Edit method.</para>
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.Modal;
        }

        private bool IsAnyObjectInheritedReadOnly(object[] items) {
            // If the object implements IComponent, and is not sited, check with
            // the inheritance service (if it exists) to see if this is a component
            // that is being inherited from another class.  If it is, then we do
            // not want to place it in the collection editor.  If the inheritance service
            // chose not to site the component, that indicates it should be hidden from 
            // the user.

            IInheritanceService iSvc = null;
            bool checkISvc = false;

            foreach(object o in items) {
                IComponent comp = o as IComponent;
                if (comp != null && comp.Site == null) {
                    if (!checkISvc) {
                        checkISvc = true;
                        if (Context != null) {
                            iSvc = (IInheritanceService)Context.GetService(typeof(IInheritanceService));
                        }
                    }

                    if (iSvc != null && iSvc.GetInheritanceAttribute(comp).Equals(InheritanceAttribute.InheritedReadOnly)) {
                        return true;
                    }
                }
            }

            return false;
        }

        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.GetItems"]/*' />
        /// <devdoc>
        ///    <para>Converts the specified collection into an array of objects.</para>
        /// </devdoc>
        protected virtual object[] GetItems(object editValue) {
            if (editValue != null) {
                // We look to see if the value implements ICollection, and if it does, 
                // we set through that.
                //
                if (editValue is System.Collections.ICollection) {
                    ArrayList list = new ArrayList();
                    
                    System.Collections.ICollection col = (System.Collections.ICollection)editValue;
                    foreach(object o in col) {
                        list.Add(o);
                    }
                    
                    object[] values = new object[list.Count];
                    list.CopyTo(values, 0);
                    return values;                
                }
            }

            return new object[0];
        }

        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.GetService"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the requested service, if it is available.
        ///    </para>
        /// </devdoc>
        protected object GetService(Type serviceType) {
            if (Context != null) {
                return Context.GetService(serviceType);
            }
            return null;
        }
        
        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.OnComponentChanged"]/*' />
        /// <devdoc>
        /// reflect any change events to the instance object
        /// </devdoc>
        private void OnComponentChanged(object sender, ComponentChangedEventArgs e) {
            if (!ignoreChangedEvents && sender != Context.Instance) {
                ignoreChangedEvents = true;
                Context.OnComponentChanged();
            }
        }
        
        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.OnComponentChanging"]/*' />
        /// <devdoc>
        ///  reflect any changed events to the instance object
        /// </devdoc>
        private void OnComponentChanging(object sender, ComponentChangingEventArgs e) {
            if (!ignoreChangingEvents && sender != Context.Instance) {
                ignoreChangingEvents = true;
                Context.OnComponentChanging();
            }
        }

        
        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.SetItems"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets
        ///       the specified collection to have the specified array of items.
        ///    </para>
        /// </devdoc>
        protected virtual object SetItems(object editValue, object[] value) {
            if (editValue != null) {
                Array oldValue = (Array)GetItems(editValue);
                bool  valueSame = (oldValue.Length == value.Length);            
                // We look to see if the value implements IList, and if it does, 
                // we set through that.
                //
                Debug.Assert(editValue is System.Collections.IList, "editValue is not an IList");
                if (editValue is System.Collections.IList) {
                    System.Collections.IList list = (System.Collections.IList)editValue;

                    list.Clear();
                    for (int i = 0; i < value.Length; i++) {
                        list.Add(value[i]);
                    }
                }
            }
            return editValue;
        }

        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.ShowHelp"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Called when the help button is clicked.
        ///    </para>
        /// </devdoc>
        protected virtual void ShowHelp() {
            IHelpService helpService = GetService(typeof(IHelpService)) as IHelpService;
            if (helpService != null) {
                helpService.ShowHelpFromKeyword(HelpTopic);
            }
            else {
                Debug.Fail("Unable to get IHelpService.");
            }
        }

        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm"]/*' />
        /// <devdoc>
        ///      This is the collection editor's default implementation of a
        ///      collection form.
        /// </devdoc>
        private class CollectionEditorCollectionForm : CollectionForm {

            private const int               TEXT_INDENT = 1;
            private const int               PAINT_WIDTH = 20;
            private const int               PAINT_INDENT = 26;
            private static readonly double  LOG10 = Math.Log(10);
            
            // Manipulation of the collection.
            //
            private ArrayList              createdItems;
            private ArrayList              removedItems;
            private ArrayList              originalItems;

            // Calling Editor
            private CollectionEditor       editor;

            // Dialog UI
            //
            private ListBox                listbox;
            private Button                 addButton;
            private Button                 addDownButton;
            private Button                 removeButton;
            private GroupBox               groupBox1;
            private Button                 cancelButton;
            private Button                 okButton;
            private Button                 helpButton;
            private ImageButton            downButton;
            private ImageButton            upButton;
            private PropertyGrid           propertyBrowser;
            private Label                  membersLabel;
            private Label                  propertiesLabel;
            private ContextMenu            addDownMenu;

            // our flag for if something changed
            //
            private bool                   dirty;

            public CollectionEditorCollectionForm(CollectionEditor editor) : base(editor) {
                this.editor = editor;
                InitializeComponent();

                Type[] newItemTypes = NewItemTypes;
                if (newItemTypes.Length > 1) {
                    EventHandler addDownMenuClick = new EventHandler(this.AddDownMenu_click);
                    addDownButton.Visible = true;
                    addDownMenu = new ContextMenu();
                    for (int i = 0; i < newItemTypes.Length; i++) {
                        addDownMenu.MenuItems.Add(new TypeMenuItem(newItemTypes[i], addDownMenuClick));
                    }
                }
                
                AdjustListBoxItemHeight();
            }            
            
            private bool IsImmutable {
                get {
                    bool immutable = true;
                    
                    // We are considered immutable if the converter is defined as requiring a
                    // create instance or all the properties are read-only.
                    //
                    if (!TypeDescriptor.GetConverter(CollectionItemType).GetCreateInstanceSupported()) {
                        foreach (PropertyDescriptor p in TypeDescriptor.GetProperties(CollectionItemType)) {
                            if (!p.IsReadOnly) {
                                immutable = false;
                                break;
                            }
                        }
                    }

                    return immutable;
                }
            }
            
            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.AddButton_click"]/*' />
            /// <devdoc>
            ///      Adds a new element to the collection.
            /// </devdoc>
            private void AddButton_click(object sender, EventArgs e) {
                CreateAndAddInstance(NewItemTypes[0]);
            }

            private void AddDownButton_click(object sender, EventArgs e) {
                Point location = addButton.Location;
                location.Y += addButton.Height;
                addDownMenu.Show(this, location);
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.AddDownMenu_click"]/*' />
            /// <devdoc>
            ///      Processes a click of the drop down type menu.  This creates a 
            ///      new instance.
            /// </devdoc>
            private void AddDownMenu_click(object sender, EventArgs e) {
                if (sender is TypeMenuItem) {
                    TypeMenuItem typeMenuItem = (TypeMenuItem) sender;
                    CreateAndAddInstance(typeMenuItem.ItemType);
                }
            }
            
            private void AdjustListBoxItemHeight() {
                listbox.ItemHeight = Font.Height + SystemInformation.BorderSize.Width*2;
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.CancelButton_click"]/*' />
            /// <devdoc>
            ///      Aborts changes made in the editor.
            /// </devdoc>
            private void CancelButton_click(object sender, EventArgs e) {
                try {
                    if (!CollectionEditable || !dirty) {
                        return;
                    }

                    dirty = false;
                    if (createdItems != null) {
                        object[] items = createdItems.ToArray();
                        for (int i=0; i<items.Length; i++) {
                            DestroyInstance(items[i]);
                        }
                        createdItems.Clear();
                    }
                    if (removedItems != null) {
                        removedItems.Clear();
                    }
                    listbox.Items.Clear();

                    // Restore the original contents. Because objects get parented during CreateAndAddInstance, the underlying collection
                    // gets changed during add, but not other operations. Not all consumers of this dialog can roll back every single change,
                    // but this will at least roll back the additions, removals and reordering. See ASURT #85470.
                    if (originalItems != null && (originalItems.Count > 0)) {
                        object[] items = new object[originalItems.Count];
                        for (int i = 0; i < originalItems.Count; i++) {
                            items[i] = originalItems[i];
                        }
                        Items = items;                        
                        originalItems.Clear();
                    }
                    else {
                        Items = new object[0];
                    }
                    
                }
                catch (Exception ex) {
                    DialogResult = DialogResult.None;
                    DisplayError(ex);
                }
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.CreateAndAddInstance"]/*' />
            /// <devdoc>
            ///      Performs a create instance and then adds the instance to
            ///      the list box.
            /// </devdoc>
            private void CreateAndAddInstance(Type type) {
                try {
                    object instance = CreateInstance(type);

                    if (instance != null) {
                        dirty = true;
                        int oldLog = ((int)(Math.Log((double)listbox.Items.Count)/LOG10) + 1);

                        if (createdItems == null) {
                            createdItems = new ArrayList();
                        }

                        createdItems.Add(instance);
                        ListItem created = new ListItem(instance);
                        listbox.Items.Add(created);
                        UpdateItemWidths(created);

                        int newLog = ((int)(Math.Log((double)listbox.Items.Count)/LOG10) + 1);
                        if (oldLog != newLog) {
                            listbox.Invalidate();
                        }

                        // Select this and only this item
                        //
                        listbox.ClearSelected();
                        listbox.SelectedIndex = listbox.Items.Count - 1;

                        //subhag(72857)
                        object[] items = new object[listbox.Items.Count];
                        for (int i = 0; i < items.Length; i++) {
                            items[i] = ((ListItem)listbox.Items[i]).Value;
                        }
                        Items = items;
                    }

                }
                catch (Exception e) {
                    DisplayError(e);
                }
            }
            
            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.DownButton_click"]/*' />
            /// <devdoc>
            ///      Moves the selected item down one.
            /// </devdoc>
            private void DownButton_click(object sender, EventArgs e) {
                dirty = true;
                int index = listbox.SelectedIndex;
                if (index == listbox.Items.Count - 1)
                    return;
                int ti = listbox.TopIndex;
                object itemMove = listbox.Items[index];
                listbox.Items[index] = listbox.Items[index+1];
                listbox.Items[index+1] = itemMove;
                
                if (ti < listbox.Items.Count - 1)
                    listbox.TopIndex = ti + 1;
                    
                listbox.ClearSelected();                    
                listbox.SelectedIndex = index + 1;
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.GetDisplayText"]/*' />
            /// <devdoc>
            ///      Retrieves the display text for the given list item.
            /// </devdoc>
            private string GetDisplayText(ListItem item) {
                string text;

                if (item == null) {
                    return string.Empty;
                }

                object value = item.Value;
                if (value == null) {
                    return string.Empty;
                }

                PropertyDescriptor prop = TypeDescriptor.GetProperties(value)["Name"];
                if (prop != null) {
                    text = (string) prop.GetValue( value );
                    if (text != null && text.Length > 0) {
                        return text;
                    }
                }

                prop = TypeDescriptor.GetDefaultProperty(CollectionType);
                if (prop != null && prop.PropertyType == typeof(string)) {
                    text = (string)prop.GetValue(EditValue);
                    if (text != null && text.Length > 0) {
                        return text;
                    }
                }

                text = item.Converter.ConvertToString(value);

                if (text == null || text.Length == 0) {
                    text = value.GetType().Name;
                }

                return text;
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.HelpButton_click"]/*' />
            private void HelpButton_click(object sender, EventArgs e) {
                editor.ShowHelp();
            }

            private void Form_HelpRequested(object sender, HelpEventArgs e) {
                editor.ShowHelp();
            }

        private void InitializeComponent() {
            System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(CollectionEditor));
            membersLabel = new System.Windows.Forms.Label();
            listbox = new FilterListBox();
            upButton = new ImageButton();
            downButton = new ImageButton();
            propertiesLabel = new System.Windows.Forms.Label();
            propertyBrowser = new System.Windows.Forms.PropertyGrid();
            addButton = new System.Windows.Forms.Button();
            removeButton = new System.Windows.Forms.Button();
            addDownButton = new System.Windows.Forms.Button();
            groupBox1 = new System.Windows.Forms.GroupBox();
            okButton = new System.Windows.Forms.Button();
            cancelButton = new System.Windows.Forms.Button();
            helpButton = new System.Windows.Forms.Button();
            propertyBrowser.SuspendLayout();
            this.SuspendLayout();
            // 
            // membersLabel
            // 
            membersLabel.AccessibleDescription = ((string)(resources.GetObject("membersLabel.AccessibleDescription")));
            membersLabel.AccessibleName = ((string)(resources.GetObject("membersLabel.AccessibleName")));
            membersLabel.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("membersLabel.Anchor")));
            membersLabel.AutoSize = ((bool)(resources.GetObject("membersLabel.AutoSize")));
            membersLabel.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("membersLabel.Cursor")));
            membersLabel.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("membersLabel.Dock")));
            membersLabel.Enabled = ((bool)(resources.GetObject("membersLabel.Enabled")));
            membersLabel.Font = ((System.Drawing.Font)(resources.GetObject("membersLabel.Font")));
            membersLabel.Image = ((System.Drawing.Image)(resources.GetObject("membersLabel.Image")));
            membersLabel.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("membersLabel.ImageAlign")));
            membersLabel.ImageIndex = ((int)(resources.GetObject("membersLabel.ImageIndex")));
            membersLabel.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("membersLabel.ImeMode")));
            membersLabel.Location = ((System.Drawing.Point)(resources.GetObject("membersLabel.Location")));
            membersLabel.Name = "membersLabel";
            membersLabel.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("membersLabel.RightToLeft")));
            membersLabel.Size = ((System.Drawing.Size)(resources.GetObject("membersLabel.Size")));
            membersLabel.TabIndex = ((int)(resources.GetObject("membersLabel.TabIndex")));
            membersLabel.Text = resources.GetString("membersLabel.Text");
            membersLabel.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("membersLabel.TextAlign")));
            membersLabel.Visible = ((bool)(resources.GetObject("membersLabel.Visible")));
            // 
            // listbox
            // 
            listbox.DrawMode = DrawMode.OwnerDrawFixed;
            listbox.UseTabStops = true;
            listbox.SelectionMode = (CanSelectMultipleInstances() ? SelectionMode.MultiExtended : SelectionMode.One);
            listbox.KeyDown += new KeyEventHandler(this.Listbox_keyDown);
            listbox.DrawItem += new DrawItemEventHandler(this.Listbox_drawItem);
            listbox.SelectedIndexChanged += new EventHandler(this.Listbox_selectedIndexChanged);
            listbox.AccessibleDescription = ((string)(resources.GetObject("listbox.AccessibleDescription")));
            listbox.AccessibleName = ((string)(resources.GetObject("listbox.AccessibleName")));
            listbox.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("listbox.Anchor")));
            listbox.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("listbox.BackgroundImage")));
            listbox.ColumnWidth = ((int)(resources.GetObject("listbox.ColumnWidth")));
            listbox.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("listbox.Cursor")));
            listbox.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("listbox.Dock")));
            listbox.Enabled = ((bool)(resources.GetObject("listbox.Enabled")));
            listbox.Font = ((System.Drawing.Font)(resources.GetObject("listbox.Font")));
            listbox.HorizontalExtent = ((int)(resources.GetObject("listbox.HorizontalExtent")));
            listbox.HorizontalScrollbar = ((bool)(resources.GetObject("listbox.HorizontalScrollbar")));
            listbox.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("listbox.ImeMode")));
            listbox.IntegralHeight = ((bool)(resources.GetObject("listbox.IntegralHeight")));
            listbox.ItemHeight = ((int)(resources.GetObject("listbox.ItemHeight")));
            listbox.Location = ((System.Drawing.Point)(resources.GetObject("listbox.Location")));
            listbox.Name = "listbox";
            listbox.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("listbox.RightToLeft")));
            listbox.ScrollAlwaysVisible = ((bool)(resources.GetObject("listbox.ScrollAlwaysVisible")));
            listbox.Size = ((System.Drawing.Size)(resources.GetObject("listbox.Size")));
            listbox.TabIndex = ((int)(resources.GetObject("listbox.TabIndex")));
            listbox.Visible = ((bool)(resources.GetObject("listbox.Visible")));
            // 
            // upButton
            // 
            upButton.Click += new EventHandler(this.UpButton_click);
            upButton.AccessibleDescription = ((string)(resources.GetObject("upButton.AccessibleDescription")));
            upButton.AccessibleName = ((string)(resources.GetObject("upButton.AccessibleName")));
            upButton.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("upButton.Anchor")));
            upButton.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("upButton.BackgroundImage")));
            upButton.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("upButton.Cursor")));
            upButton.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("upButton.Dock")));
            upButton.Enabled = ((bool)(resources.GetObject("upButton.Enabled")));
            upButton.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("upButton.FlatStyle")));
            upButton.Font = ((System.Drawing.Font)(resources.GetObject("upButton.Font")));
            upButton.Image = ((System.Drawing.Bitmap)(resources.GetObject("upButton.Image")));
            upButton.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("upButton.ImageAlign")));
            upButton.ImageIndex = ((int)(resources.GetObject("upButton.ImageIndex")));
            upButton.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("upButton.ImeMode")));
            upButton.Location = ((System.Drawing.Point)(resources.GetObject("upButton.Location")));
            upButton.Name = "upButton";
            upButton.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("upButton.RightToLeft")));
            upButton.Size = ((System.Drawing.Size)(resources.GetObject("upButton.Size")));
            upButton.TabIndex = ((int)(resources.GetObject("upButton.TabIndex")));
            upButton.Text = resources.GetString("upButton.Text");
            upButton.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("upButton.TextAlign")));
            upButton.Visible = ((bool)(resources.GetObject("upButton.Visible")));
            // 
            // downButton
            // 
            downButton.Click += new EventHandler(this.DownButton_click);
            downButton.AccessibleDescription = ((string)(resources.GetObject("downButton.AccessibleDescription")));
            downButton.AccessibleName = ((string)(resources.GetObject("downButton.AccessibleName")));
            downButton.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("downButton.Anchor")));
            downButton.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("downButton.BackgroundImage")));
            downButton.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("downButton.Cursor")));
            downButton.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("downButton.Dock")));
            downButton.Enabled = ((bool)(resources.GetObject("downButton.Enabled")));
            downButton.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("downButton.FlatStyle")));
            downButton.Font = ((System.Drawing.Font)(resources.GetObject("downButton.Font")));
            downButton.Image = ((System.Drawing.Bitmap)(resources.GetObject("downButton.Image")));
            downButton.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("downButton.ImageAlign")));
            downButton.ImageIndex = ((int)(resources.GetObject("downButton.ImageIndex")));
            downButton.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("downButton.ImeMode")));
            downButton.Location = ((System.Drawing.Point)(resources.GetObject("downButton.Location")));
            downButton.Name = "downButton";
            downButton.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("downButton.RightToLeft")));
            downButton.Size = ((System.Drawing.Size)(resources.GetObject("downButton.Size")));
            downButton.TabIndex = ((int)(resources.GetObject("downButton.TabIndex")));
            downButton.Text = resources.GetString("downButton.Text");
            downButton.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("downButton.TextAlign")));
            downButton.Visible = ((bool)(resources.GetObject("downButton.Visible")));
            // 
            // propertiesLabel
            // 
            propertiesLabel.Text = SR.GetString(SR.CollectionEditorPropertiesNone);
            propertiesLabel.AccessibleDescription = ((string)(resources.GetObject("propertiesLabel.AccessibleDescription")));
            propertiesLabel.AccessibleName = ((string)(resources.GetObject("propertiesLabel.AccessibleName")));
            propertiesLabel.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("propertiesLabel.Anchor")));
            propertiesLabel.AutoSize = ((bool)(resources.GetObject("propertiesLabel.AutoSize")));
            propertiesLabel.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("propertiesLabel.Cursor")));
            propertiesLabel.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("propertiesLabel.Dock")));
            propertiesLabel.Enabled = ((bool)(resources.GetObject("propertiesLabel.Enabled")));
            propertiesLabel.Font = ((System.Drawing.Font)(resources.GetObject("propertiesLabel.Font")));
            propertiesLabel.Image = ((System.Drawing.Image)(resources.GetObject("propertiesLabel.Image")));
            propertiesLabel.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("propertiesLabel.ImageAlign")));
            propertiesLabel.ImageIndex = ((int)(resources.GetObject("propertiesLabel.ImageIndex")));
            propertiesLabel.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("propertiesLabel.ImeMode")));
            propertiesLabel.Location = ((System.Drawing.Point)(resources.GetObject("propertiesLabel.Location")));
            propertiesLabel.Name = "propertiesLabel";
            propertiesLabel.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("propertiesLabel.RightToLeft")));
            propertiesLabel.Size = ((System.Drawing.Size)(resources.GetObject("propertiesLabel.Size")));
            propertiesLabel.TabIndex = ((int)(resources.GetObject("propertiesLabel.TabIndex")));
            propertiesLabel.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("propertiesLabel.TextAlign")));
            propertiesLabel.Visible = ((bool)(resources.GetObject("propertiesLabel.Visible")));
            // 
            // propertyBrowser
            // 
            propertyBrowser.ToolbarVisible = false;
            propertyBrowser.HelpVisible = false;
            propertyBrowser.BackColor = SystemColors.Window;
            propertyBrowser.CommandsVisibleIfAvailable = false; // ASURT: 27374
            propertyBrowser.PropertyValueChanged += new PropertyValueChangedEventHandler(this.PropertyGrid_propertyValueChanged);
            propertyBrowser.AccessibleDescription = ((string)(resources.GetObject("propertyBrowser.AccessibleDescription")));
            propertyBrowser.AccessibleName = ((string)(resources.GetObject("propertyBrowser.AccessibleName")));
            propertyBrowser.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("propertyBrowser.Anchor")));
            propertyBrowser.AutoScroll = ((bool)(resources.GetObject("propertyBrowser.AutoScroll")));
            propertyBrowser.AutoScrollMargin = ((System.Drawing.Size)(resources.GetObject("propertyBrowser.AutoScrollMargin")));
            propertyBrowser.AutoScrollMinSize = ((System.Drawing.Size)(resources.GetObject("propertyBrowser.AutoScrollMinSize")));
            propertyBrowser.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("propertyBrowser.BackgroundImage")));
            propertyBrowser.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("propertyBrowser.Cursor")));
            propertyBrowser.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("propertyBrowser.Dock")));
            propertyBrowser.Enabled = ((bool)(resources.GetObject("propertyBrowser.Enabled")));
            propertyBrowser.Font = ((System.Drawing.Font)(resources.GetObject("propertyBrowser.Font")));
            propertyBrowser.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("propertyBrowser.ImeMode")));
            propertyBrowser.LargeButtons = false;
            propertyBrowser.LineColor = System.Drawing.SystemColors.ScrollBar;
            propertyBrowser.Location = ((System.Drawing.Point)(resources.GetObject("propertyBrowser.Location")));
            propertyBrowser.Name = "propertyBrowser";
            propertyBrowser.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("propertyBrowser.RightToLeft")));
            propertyBrowser.Size = ((System.Drawing.Size)(resources.GetObject("propertyBrowser.Size")));
            propertyBrowser.TabIndex = ((int)(resources.GetObject("propertyBrowser.TabIndex")));
            propertyBrowser.Text = resources.GetString("propertyBrowser.Text");
            propertyBrowser.ViewBackColor = System.Drawing.SystemColors.Window;
            propertyBrowser.ViewForeColor = System.Drawing.SystemColors.WindowText;
            propertyBrowser.Visible = ((bool)(resources.GetObject("propertyBrowser.Visible")));
            // 
            // addButton
            // 
            addButton.Click += new EventHandler(this.AddButton_click);
            addButton.AccessibleDescription = ((string)(resources.GetObject("addButton.AccessibleDescription")));
            addButton.AccessibleName = ((string)(resources.GetObject("addButton.AccessibleName")));
            addButton.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("addButton.Anchor")));
            addButton.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("addButton.BackgroundImage")));
            addButton.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("addButton.Cursor")));
            addButton.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("addButton.Dock")));
            addButton.Enabled = ((bool)(resources.GetObject("addButton.Enabled")));
            addButton.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("addButton.FlatStyle")));
            addButton.Font = ((System.Drawing.Font)(resources.GetObject("addButton.Font")));
            addButton.Image = ((System.Drawing.Image)(resources.GetObject("addButton.Image")));
            addButton.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("addButton.ImageAlign")));
            addButton.ImageIndex = ((int)(resources.GetObject("addButton.ImageIndex")));
            addButton.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("addButton.ImeMode")));
            addButton.Location = ((System.Drawing.Point)(resources.GetObject("addButton.Location")));
            addButton.Name = "addButton";
            addButton.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("addButton.RightToLeft")));
            addButton.Size = ((System.Drawing.Size)(resources.GetObject("addButton.Size")));
            addButton.TabIndex = ((int)(resources.GetObject("addButton.TabIndex")));
            addButton.Text = resources.GetString("addButton.Text");
            addButton.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("addButton.TextAlign")));
            addButton.Visible = ((bool)(resources.GetObject("addButton.Visible")));
            // 
            // removeButton
            // 
            removeButton.Click += new EventHandler(this.RemoveButton_click);
            removeButton.AccessibleDescription = ((string)(resources.GetObject("removeButton.AccessibleDescription")));
            removeButton.AccessibleName = ((string)(resources.GetObject("removeButton.AccessibleName")));
            removeButton.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("removeButton.Anchor")));
            removeButton.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("removeButton.BackgroundImage")));
            removeButton.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("removeButton.Cursor")));
            removeButton.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("removeButton.Dock")));
            removeButton.Enabled = ((bool)(resources.GetObject("removeButton.Enabled")));
            removeButton.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("removeButton.FlatStyle")));
            removeButton.Font = ((System.Drawing.Font)(resources.GetObject("removeButton.Font")));
            removeButton.Image = ((System.Drawing.Image)(resources.GetObject("removeButton.Image")));
            removeButton.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("removeButton.ImageAlign")));
            removeButton.ImageIndex = ((int)(resources.GetObject("removeButton.ImageIndex")));
            removeButton.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("removeButton.ImeMode")));
            removeButton.Location = ((System.Drawing.Point)(resources.GetObject("removeButton.Location")));
            removeButton.Name = "removeButton";
            removeButton.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("removeButton.RightToLeft")));
            removeButton.Size = ((System.Drawing.Size)(resources.GetObject("removeButton.Size")));
            removeButton.TabIndex = ((int)(resources.GetObject("removeButton.TabIndex")));
            removeButton.Text = resources.GetString("removeButton.Text");
            removeButton.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("removeButton.TextAlign")));
            removeButton.Visible = ((bool)(resources.GetObject("removeButton.Visible")));
            // 
            // addDownButton
            // 
            addDownButton.Click += new EventHandler(this.AddDownButton_click);
            addDownButton.AccessibleDescription = ((string)(resources.GetObject("addDownButton.AccessibleDescription")));
            addDownButton.AccessibleName = ((string)(resources.GetObject("addDownButton.AccessibleName")));
            addDownButton.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("addDownButton.Anchor")));
            addDownButton.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("addDownButton.BackgroundImage")));
            addDownButton.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("addDownButton.Cursor")));
            addDownButton.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("addDownButton.Dock")));
            addDownButton.Enabled = ((bool)(resources.GetObject("addDownButton.Enabled")));
            addDownButton.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("addDownButton.FlatStyle")));
            addDownButton.Font = ((System.Drawing.Font)(resources.GetObject("addDownButton.Font")));
            addDownButton.Image = ((System.Drawing.Bitmap)(resources.GetObject("addDownButton.Image")));
            addDownButton.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("addDownButton.ImageAlign")));
            addDownButton.ImageIndex = ((int)(resources.GetObject("addDownButton.ImageIndex")));
            addDownButton.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("addDownButton.ImeMode")));
            addDownButton.Location = ((System.Drawing.Point)(resources.GetObject("addDownButton.Location")));
            addDownButton.Name = "addDownButton";
            addDownButton.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("addDownButton.RightToLeft")));
            addDownButton.Size = ((System.Drawing.Size)(resources.GetObject("addDownButton.Size")));
            addDownButton.TabIndex = ((int)(resources.GetObject("addDownButton.TabIndex")));
            addDownButton.Text = resources.GetString("addDownButton.Text");
            addDownButton.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("addDownButton.TextAlign")));
            addDownButton.Visible = ((bool)(resources.GetObject("addDownButton.Visible")));
            // 
            // groupBox1
            // 
            groupBox1.AccessibleDescription = ((string)(resources.GetObject("groupBox1.AccessibleDescription")));
            groupBox1.AccessibleName = ((string)(resources.GetObject("groupBox1.AccessibleName")));
            groupBox1.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("groupBox1.Anchor")));
            groupBox1.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("groupBox1.BackgroundImage")));
            groupBox1.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("groupBox1.Cursor")));
            groupBox1.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("groupBox1.Dock")));
            groupBox1.Enabled = ((bool)(resources.GetObject("groupBox1.Enabled")));
            groupBox1.Font = ((System.Drawing.Font)(resources.GetObject("groupBox1.Font")));
            groupBox1.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("groupBox1.ImeMode")));
            groupBox1.Location = ((System.Drawing.Point)(resources.GetObject("groupBox1.Location")));
            groupBox1.Name = "groupBox1";
            groupBox1.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("groupBox1.RightToLeft")));
            groupBox1.Size = ((System.Drawing.Size)(resources.GetObject("groupBox1.Size")));
            groupBox1.TabIndex = ((int)(resources.GetObject("groupBox1.TabIndex")));
            groupBox1.TabStop = false;
            groupBox1.Text = resources.GetString("groupBox1.Text");
            groupBox1.Visible = ((bool)(resources.GetObject("groupBox1.Visible")));
            // 
            // okButton
            // 
            okButton.DialogResult = DialogResult.OK;
            okButton.Click += new EventHandler(this.OKButton_click);
            okButton.AccessibleDescription = ((string)(resources.GetObject("okButton.AccessibleDescription")));
            okButton.AccessibleName = ((string)(resources.GetObject("okButton.AccessibleName")));
            okButton.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("okButton.Anchor")));
            okButton.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("okButton.BackgroundImage")));
            okButton.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("okButton.Cursor")));
            okButton.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("okButton.Dock")));
            okButton.Enabled = ((bool)(resources.GetObject("okButton.Enabled")));
            okButton.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("okButton.FlatStyle")));
            okButton.Font = ((System.Drawing.Font)(resources.GetObject("okButton.Font")));
            okButton.Image = ((System.Drawing.Image)(resources.GetObject("okButton.Image")));
            okButton.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("okButton.ImageAlign")));
            okButton.ImageIndex = ((int)(resources.GetObject("okButton.ImageIndex")));
            okButton.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("okButton.ImeMode")));
            okButton.Location = ((System.Drawing.Point)(resources.GetObject("okButton.Location")));
            okButton.Name = "okButton";
            okButton.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("okButton.RightToLeft")));
            okButton.Size = ((System.Drawing.Size)(resources.GetObject("okButton.Size")));
            okButton.TabIndex = ((int)(resources.GetObject("okButton.TabIndex")));
            okButton.Text = resources.GetString("okButton.Text");
            okButton.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("okButton.TextAlign")));
            okButton.Visible = ((bool)(resources.GetObject("okButton.Visible")));
            // 
            // cancelButton
            // 
            cancelButton.DialogResult = DialogResult.Cancel;
            cancelButton.Click += new EventHandler(this.CancelButton_click);
            cancelButton.AccessibleDescription = ((string)(resources.GetObject("cancelButton.AccessibleDescription")));
            cancelButton.AccessibleName = ((string)(resources.GetObject("cancelButton.AccessibleName")));
            cancelButton.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("cancelButton.Anchor")));
            cancelButton.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("cancelButton.BackgroundImage")));
            cancelButton.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("cancelButton.Cursor")));
            cancelButton.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("cancelButton.Dock")));
            cancelButton.Enabled = ((bool)(resources.GetObject("cancelButton.Enabled")));
            cancelButton.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("cancelButton.FlatStyle")));
            cancelButton.Font = ((System.Drawing.Font)(resources.GetObject("cancelButton.Font")));
            cancelButton.Image = ((System.Drawing.Image)(resources.GetObject("cancelButton.Image")));
            cancelButton.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("cancelButton.ImageAlign")));
            cancelButton.ImageIndex = ((int)(resources.GetObject("cancelButton.ImageIndex")));
            cancelButton.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("cancelButton.ImeMode")));
            cancelButton.Location = ((System.Drawing.Point)(resources.GetObject("cancelButton.Location")));
            cancelButton.Name = "cancelButton";
            cancelButton.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("cancelButton.RightToLeft")));
            cancelButton.Size = ((System.Drawing.Size)(resources.GetObject("cancelButton.Size")));
            cancelButton.TabIndex = ((int)(resources.GetObject("cancelButton.TabIndex")));
            cancelButton.Text = resources.GetString("cancelButton.Text");
            cancelButton.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("cancelButton.TextAlign")));
            cancelButton.Visible = ((bool)(resources.GetObject("cancelButton.Visible")));
            // 
            // helpButton
            // 
            helpButton.Click += new EventHandler(this.HelpButton_click);
            helpButton.AccessibleDescription = ((string)(resources.GetObject("helpButton.AccessibleDescription")));
            helpButton.AccessibleName = ((string)(resources.GetObject("helpButton.AccessibleName")));
            helpButton.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("helpButton.Anchor")));
            helpButton.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("helpButton.BackgroundImage")));
            helpButton.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("helpButton.Cursor")));
            helpButton.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("helpButton.Dock")));
            helpButton.Enabled = ((bool)(resources.GetObject("helpButton.Enabled")));
            helpButton.FlatStyle = ((System.Windows.Forms.FlatStyle)(resources.GetObject("helpButton.FlatStyle")));
            helpButton.Font = ((System.Drawing.Font)(resources.GetObject("helpButton.Font")));
            helpButton.Image = ((System.Drawing.Image)(resources.GetObject("helpButton.Image")));
            helpButton.ImageAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("helpButton.ImageAlign")));
            helpButton.ImageIndex = ((int)(resources.GetObject("helpButton.ImageIndex")));
            helpButton.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("helpButton.ImeMode")));
            helpButton.Location = ((System.Drawing.Point)(resources.GetObject("helpButton.Location")));
            helpButton.Name = "helpButton";
            helpButton.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("helpButton.RightToLeft")));
            helpButton.Size = ((System.Drawing.Size)(resources.GetObject("helpButton.Size")));
            helpButton.TabIndex = ((int)(resources.GetObject("helpButton.TabIndex")));
            helpButton.Text = resources.GetString("helpButton.Text");
            helpButton.TextAlign = ((System.Drawing.ContentAlignment)(resources.GetObject("helpButton.TextAlign")));
            helpButton.Visible = ((bool)(resources.GetObject("helpButton.Visible")));
            // 
            // Win32Form1
            // 
            this.Text = SR.GetString(SR.CollectionEditorCaption, CollectionItemType.Name);
            this.AcceptButton = okButton;
            this.CancelButton = cancelButton;
            this.ShowInTaskbar = false;
            this.HelpRequested += new HelpEventHandler(this.Form_HelpRequested);

            this.AccessibleDescription = ((string)(resources.GetObject("$this.AccessibleDescription")));
            this.AccessibleName = ((string)(resources.GetObject("$this.AccessibleName")));
            this.Anchor = ((System.Windows.Forms.AnchorStyles)(resources.GetObject("$this.Anchor")));
            this.AutoScaleBaseSize = ((System.Drawing.Size)(resources.GetObject("$this.AutoScaleBaseSize")));
            this.AutoScroll = ((bool)(resources.GetObject("$this.AutoScroll")));
            this.AutoScrollMargin = ((System.Drawing.Size)(resources.GetObject("$this.AutoScrollMargin")));
            this.AutoScrollMinSize = ((System.Drawing.Size)(resources.GetObject("$this.AutoScrollMinSize")));
            this.BackgroundImage = ((System.Drawing.Image)(resources.GetObject("$this.BackgroundImage")));
            this.ClientSize = ((System.Drawing.Size)(resources.GetObject("$this.ClientSize")));
            this.Controls.AddRange(new System.Windows.Forms.Control[] {helpButton,
                        cancelButton,
                        okButton,
                        groupBox1,
                        addDownButton,
                        removeButton,
                        addButton,
                        propertyBrowser,
                        propertiesLabel,
                        downButton,
                        upButton,
                        listbox,
                        membersLabel});
            this.ControlBox = false;
            this.Cursor = ((System.Windows.Forms.Cursor)(resources.GetObject("$this.Cursor")));
            this.Dock = ((System.Windows.Forms.DockStyle)(resources.GetObject("$this.Dock")));
            this.Enabled = ((bool)(resources.GetObject("$this.Enabled")));
            this.Font = ((System.Drawing.Font)(resources.GetObject("$this.Font")));
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
            this.ImeMode = ((System.Windows.Forms.ImeMode)(resources.GetObject("$this.ImeMode")));
            this.Location = ((System.Drawing.Point)(resources.GetObject("$this.Location")));
            this.MaximizeBox = false;
            this.MaximumSize = ((System.Drawing.Size)(resources.GetObject("$this.MaximumSize")));
            this.MinimizeBox = false;
            this.MinimumSize = ((System.Drawing.Size)(resources.GetObject("$this.MinimumSize")));
            this.Name = "Win32Form1";
            this.RightToLeft = ((System.Windows.Forms.RightToLeft)(resources.GetObject("$this.RightToLeft")));
            this.StartPosition = ((System.Windows.Forms.FormStartPosition)(resources.GetObject("$this.StartPosition")));
            this.propertyBrowser.ResumeLayout(false);
            this.ResumeLayout(false);
        }
            
            private void UpdateItemWidths(ListItem item) {
                using (Graphics g = listbox.CreateGraphics()) {
                    int old = listbox.HorizontalExtent;

                    if (item != null) {
                        int w = CalcItemWidth(g, item);
                        if (w > old) {
                            listbox.HorizontalExtent = w;
                        }
                    }
                    else {
                        int max = old;
                        foreach (ListItem i in listbox.Items) {
                            int w = CalcItemWidth(g, i);
                            if (w > max) {
                                max = w;
                            }
                        }
                        listbox.HorizontalExtent = max;
                    }
                }
            }

            private int CalcItemWidth(Graphics g, ListItem item) {
                int c = listbox.Items.Count;
                if (c == 0) {
                    c = 1;
                }
                int charactersInNumber = ((int)(Math.Log((double)c)/LOG10) + 1);
                int w = 4 + charactersInNumber * (Font.Height / 2) + SystemInformation.BorderSize.Width*4;

                SizeF size = g.MeasureString(GetDisplayText(item), listbox.Font);
                int pic = 0;
                if (item.Editor != null && item.Editor.GetPaintValueSupported()) {
                    pic = PAINT_WIDTH + TEXT_INDENT;
                }
                return (int)Math.Ceiling(size.Width) + w + pic + SystemInformation.BorderSize.Width*4;
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.Listbox_drawItem"]/*' />
            /// <devdoc>
            ///     This draws a row of the listbox.
            /// </devdoc>
            private void Listbox_drawItem(object sender, DrawItemEventArgs e) {
                if (e.Index != -1) {
                    ListItem item = (ListItem)listbox.Items[e.Index];

                    Graphics g = e.Graphics;

                    int c = listbox.Items.Count;
                    // We add the +4 is a fudge factor...
                    //
                    int charactersInNumber = ((int)(Math.Log((double)c)/LOG10) + 1); // Luckily, this is never called if count = 0
                    int w = 4 + charactersInNumber * (Font.Height / 2) + SystemInformation.BorderSize.Width*4;

                    Rectangle button = new Rectangle(e.Bounds.X, e.Bounds.Y, w, e.Bounds.Height);

                    ControlPaint.DrawButton(g, button, ButtonState.Normal);
                    button.Inflate(-SystemInformation.BorderSize.Width*2, -SystemInformation.BorderSize.Height*2);

                    int offset = w;

                    Color backColor = SystemColors.Window;
                    Color textColor = SystemColors.WindowText;
                    if ((e.State & DrawItemState.Selected) == DrawItemState.Selected) {
                        backColor = SystemColors.Highlight;
                        textColor = SystemColors.HighlightText;
                    }
                    Rectangle res = new Rectangle(e.Bounds.X + offset, e.Bounds.Y,
                                                  e.Bounds.Width - offset,
                                                  e.Bounds.Height);
                    g.FillRectangle(new SolidBrush(backColor), res);
                    if ((e.State & DrawItemState.Focus) == DrawItemState.Focus) {
                        ControlPaint.DrawFocusRectangle(g, res);
                    }
                    offset+=2;

                    if (item.Editor != null && item.Editor.GetPaintValueSupported()) {
                        Rectangle baseVar = new Rectangle(e.Bounds.X + offset, e.Bounds.Y + 1, PAINT_WIDTH, e.Bounds.Height - 3);
                        g.DrawRectangle(SystemPens.ControlText, baseVar.X, baseVar.Y, baseVar.Width - 1, baseVar.Height - 1);
                        baseVar.Inflate(-1, -1);
                        item.Editor.PaintValue(item.Value, g, baseVar);
                        offset += PAINT_INDENT + TEXT_INDENT;
                    }

                    StringFormat format = new StringFormat();
                    format.Alignment = StringAlignment.Center;
                    g.DrawString(e.Index.ToString(), Font, SystemBrushes.ControlText, 
                                 new Rectangle(e.Bounds.X, e.Bounds.Y, w, e.Bounds.Height), format);
                    Brush textBrush = new SolidBrush(textColor);
                    
                    string itemText = GetDisplayText(item);
                    
                    g.DrawString(itemText, Font, textBrush,
                                 new Rectangle(e.Bounds.X + offset, e.Bounds.Y, e.Bounds.Width - offset, e.Bounds.Height));
                                 
                    textBrush.Dispose();
                    format.Dispose();
                    
                    // Check to see if we need to change the horizontal extent of the listbox
                    //                                    
                    int width = offset + (int)g.MeasureString(itemText, Font).Width;
                    if (width > e.Bounds.Width && listbox.HorizontalExtent < width) {
                        listbox.HorizontalExtent = width;
                    }
                }
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.Listbox_keyPress"]/*' />
            /// <devdoc>
            ///      Handles keypress events for the list box.
            /// </devdoc>
            private void Listbox_keyDown(object sender, KeyEventArgs kevent) {
                switch (kevent.KeyData) {
                    case Keys.Delete:
                        RemoveButton_click(removeButton, EventArgs.Empty);
                        break;
                    case Keys.Insert:
                        AddButton_click(removeButton, EventArgs.Empty);
                        break;
                }
            } 

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.Listbox_selectedIndexChanged"]/*' />
            /// <devdoc>
            ///      Event that fires when the selected list box index changes.
            /// </devdoc>
            private void Listbox_selectedIndexChanged(object sender, EventArgs e) {
                UpdateEnabled();
            }
            
            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.OKButton_click"]/*' />
            /// <devdoc>
            ///      Commits the changes to the editor.
            /// </devdoc>
            private void OKButton_click(object sender, EventArgs e) {
                try {

                    if (!dirty || !CollectionEditable) {
                        dirty = false;
                        DialogResult = DialogResult.Cancel;
                        return;
                    }
                    
                    // Now apply the changes to the actual value.
                    //
                    if (EditValue != null && dirty) {
                        object[] items = new object[listbox.Items.Count];
                        for (int i = 0; i < items.Length; i++) {
                            items[i] = ((ListItem)listbox.Items[i]).Value;
                        }
                        
                        Items = items;
                    }

    
                    // Now destroy any existing items we had.
                    //
                    if (removedItems != null && dirty) {
                        object[] deadItems = removedItems.ToArray();
                        
                        for (int i=0; i<deadItems.Length; i++) {
                            DestroyInstance(deadItems[i]);
                        }
                        removedItems.Clear();
                    }
                    if (createdItems != null) {
                        createdItems.Clear();
                    }

                    if (originalItems != null) {
                        originalItems.Clear();
                    }

                    listbox.Items.Clear();
                    dirty = false;
                }
                catch (Exception ex) {
                    DialogResult = DialogResult.None;
                    DisplayError(ex);
                }
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.OnComponentChanged"]/*' />
            /// <devdoc>
            /// reflect any change events to the instance object
            /// </devdoc>
            private void OnComponentChanged(object sender, ComponentChangedEventArgs e) {

                // see if this is any of the items in our list...this can happen if
                // we launched a child editor
                if (!dirty) {                
                    foreach (object item in originalItems) {
                        if (item == e.Component) {
                            dirty = true;
                            break;
                        }
                    }
                }
                
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.OnEditValueChanged"]/*' />
            /// <devdoc>
            ///      This is called when the value property in the CollectionForm has changed.
            ///      In it you should update your user interface to reflect the current value.
            /// </devdoc>
            protected override void OnEditValueChanged() {
                
                // Remember these contents for cancellation
                if (originalItems == null) {
                    originalItems = new ArrayList();
                }
                originalItems.Clear();

                // Now update the list box.
                //
                listbox.Items.Clear();
                if (EditValue != null) {
                    propertyBrowser.Site = new PropertyGridSite(Context, propertyBrowser);
                    
                    object[] items = Items;
                    for (int i = 0; i < items.Length; i++) {
                        listbox.Items.Add(new ListItem(items[i]));
                        originalItems.Add(items[i]);
                    }
                    if (listbox.Items.Count > 0) {
                        listbox.SelectedIndex = 0;
                    }
                    UpdateEnabled();
                }
                
                AdjustListBoxItemHeight();
                UpdateItemWidths(null);

            }
            
            protected override void OnFontChanged(EventArgs e) {
                base.OnFontChanged(e);
                AdjustListBoxItemHeight();                
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.PropertyGrid_propertyValueChanged"]/*' />
            /// <devdoc>
            ///      When something in the properties window changes, we update pertinent text here.
            /// </devdoc>
            private void PropertyGrid_propertyValueChanged(object sender, PropertyValueChangedEventArgs e) {

                dirty = true;

                // if a property changes, invalidate the grid in case
                // it affects the item's name.
                UpdateItemWidths((ListItem)listbox.SelectedItem);
                listbox.Invalidate();

                // also update the string above the grid.
                propertiesLabel.Text = SR.GetString(SR.CollectionEditorProperties, GetDisplayText((ListItem)listbox.SelectedItem));
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.RemoveButton_click"]/*' />
            /// <devdoc>
            ///      Removes the selected item.
            /// </devdoc>
            private void RemoveButton_click(object sender, EventArgs e) {
                int index = listbox.SelectedIndex;
                
                if (index != -1) {
                    dirty = true;
                    ListItem item = (ListItem)listbox.Items[index];
                    
                    if (createdItems != null && createdItems.Contains(item.Value)) {
                        DestroyInstance(item.Value);
                        createdItems.Remove(item.Value);
                        listbox.Items.RemoveAt(index);
                    }
                    else {
                        try {
                            if (CanRemoveInstance(item.Value)) {
                                if (removedItems == null) {
                                    removedItems = new ArrayList();
                                }
                                removedItems.Add(item.Value);
                                listbox.Items.RemoveAt(index);
                            }
                            else {
                                throw new Exception(SR.GetString(SR.CollectionEditorCantRemoveItem, GetDisplayText(item)));
                            }
                        }
                        catch (Exception ex) {
                            DisplayError(ex);
                        }
                    }
                }
                if (index < listbox.Items.Count) {
                    listbox.SelectedIndex = index;
                }
                else if (listbox.Items.Count > 0) {
                    listbox.SelectedIndex = listbox.Items.Count - 1;
                }
                else {
                    UpdateEnabled();
                }
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.UpButton_click"]/*' />
            /// <devdoc>
            ///      Moves an item up one in the list box.
            /// </devdoc>
            private void UpButton_click(object sender, EventArgs e) {
                int index = listbox.SelectedIndex;
                if (index == 0)
                    return;

                dirty = true;
                int ti = listbox.TopIndex;
                object itemMove = listbox.Items[index];
                listbox.Items[index] = listbox.Items[index-1];
                listbox.Items[index-1] = itemMove;
                
                if (ti > 0)
                    listbox.TopIndex = ti - 1;
                    
                listbox.ClearSelected();
                listbox.SelectedIndex = index - 1;
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.UpdateEnabled"]/*' />
            /// <devdoc>
            ///      Updates the set of enabled buttons.
            /// </devdoc>
            private void UpdateEnabled() {
                bool editEnabled = (listbox.SelectedItem != null) && this.CollectionEditable;
                removeButton.Enabled = editEnabled;
                upButton.Enabled = editEnabled;
                downButton.Enabled = editEnabled;
                propertyBrowser.Enabled = editEnabled;
                addButton.Enabled = this.CollectionEditable;

                if (listbox.SelectedItem != null) {
                    object[] items;
                    
                    // If we are to create new instances from the items, then we must wrap them in an outer object.
                    // otherwise, the user will be presented with a batch of read only properties, which isn't terribly
                    // useful.
                    //
                    if (IsImmutable) {
                        items = new object[] {new SelectionWrapper(CollectionType, CollectionItemType, listbox, listbox.SelectedItems)};
                    }
                    else {
                        items = new object[listbox.SelectedItems.Count];
                        for (int i = 0; i < items.Length; i++) {
                            items[i] = ((ListItem)listbox.SelectedItems[i]).Value;
                        }
                    }

                    int selectedItemCount = listbox.SelectedItems.Count;
                    if ((selectedItemCount == 1) || (selectedItemCount == -1)) {
                        // handle both single select listboxes and a single item selected in a multi-select listbox
                        propertiesLabel.Text = SR.GetString(SR.CollectionEditorProperties, GetDisplayText((ListItem)listbox.SelectedItem));
                    }
                    else {
                        propertiesLabel.Text = SR.GetString(SR.CollectionEditorPropertiesMultiSelect);
                    }

                    if (editor.IsAnyObjectInheritedReadOnly(items)) {
                        propertyBrowser.SelectedObjects = null;
                        propertyBrowser.Enabled = false;
                        removeButton.Enabled = false;
                        upButton.Enabled = false;
                        downButton.Enabled = false;
                        propertiesLabel.Text = SR.GetString(SR.CollectionEditorInheritedReadOnlySelection);
                    }
                    else {
                        propertyBrowser.Enabled = true;
                        propertyBrowser.SelectedObjects = items;
                    }
                }
                else {
                    propertiesLabel.Text = SR.GetString(SR.CollectionEditorPropertiesNone);
                    propertyBrowser.SelectedObject = null;
                }
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.ShowEditorDialog"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Called to show the dialog via the IWindowsFormsEditorService 
            ///    </para>
            /// </devdoc>
            protected internal override DialogResult ShowEditorDialog(IWindowsFormsEditorService edSvc) {
                IComponentChangeService cs = null;
                DialogResult result = DialogResult.OK;
                try {

                    cs = (IComponentChangeService)editor.Context.GetService(typeof(IComponentChangeService));
                        
                    if (cs != null) {
                        cs.ComponentChanged += new ComponentChangedEventHandler(this.OnComponentChanged);
                    }

                    // This is cached across requests, so reset the initial focus.
                    ActiveControl = listbox;
                    //SystemEvents.UserPreferenceChanged += new UserPreferenceChangedEventHandler(this.OnSysColorChange);
                    result = base.ShowEditorDialog(edSvc);
                    //SystemEvents.UserPreferenceChanged -= new UserPreferenceChangedEventHandler(this.OnSysColorChange);
                }
                finally{

                    if (cs != null) {
                        cs.ComponentChanged -= new ComponentChangedEventHandler(this.OnComponentChanged);
                    }
                }
                return result;
            }


            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper"]/*' />
            /// <devdoc>
            ///     This class implements a custom type descriptor that is used to provide properties for the set of
            ///     selected items in the collection editor.  It provides a single property that is equivalent
            ///     to the editor's collection item type.
            /// </devdoc>
            private class SelectionWrapper : PropertyDescriptor, ICustomTypeDescriptor {
                private Type collectionType;
                private Type collectionItemType;
                private Control control;
                private ICollection collection;
                private PropertyDescriptorCollection properties;
                private object value;

                public SelectionWrapper(Type collectionType, Type collectionItemType, Control control, ICollection collection) : 
                base("Value", 
                     new Attribute[] {new CategoryAttribute(collectionItemType.Name)}
                    ) {
                    this.collectionType = collectionType;
                    this.collectionItemType = collectionItemType;
                    this.control = control;
                    this.collection = collection;
                    this.properties = new PropertyDescriptorCollection(new PropertyDescriptor[] {this});

                    Debug.Assert(collection.Count > 0, "We should only be wrapped if there is a selection");
                    value = this;

                    // In a multiselect case, see if the values are different.  If so,
                    // NULL our value to represent indeterminate.
                    //
                    foreach (ListItem li in collection) {
                        if (value == this) {
                            value = li.Value;
                        }
                        else {
                            object nextValue = li.Value;
                            if (value != null) {
                                if (nextValue == null) {
                                    value = null;
                                    break;
                                }
                                else {
                                    if (!value.Equals(nextValue)) {
                                        value = null;
                                        break;
                                    }
                                }
                            }
                            else {
                                if (nextValue != null) {
                                    value = null;
                                    break;
                                }
                            }
                        }
                    }
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.ComponentType"]/*' />
                /// <devdoc>
                ///    <para>
                ///       When overridden in a derived class, gets the type of the
                ///       component this property
                ///       is bound to.
                ///    </para>
                /// </devdoc>
                public override Type ComponentType {
                    get {
                        return collectionType;
                    }
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.IsReadOnly"]/*' />
                /// <devdoc>
                ///    <para>
                ///       When overridden in
                ///       a derived class, gets a value
                ///       indicating whether this property is read-only.
                ///    </para>
                /// </devdoc>
                public override bool IsReadOnly {
                    get {
                        return false;
                    }
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.PropertyType"]/*' />
                /// <devdoc>
                ///    <para>
                ///       When overridden in a derived class,
                ///       gets the type of the property.
                ///    </para>
                /// </devdoc>
                public override Type PropertyType {
                    get {
                        return collectionItemType;
                    }
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.CanResetValue"]/*' />
                /// <devdoc>
                ///    <para>
                ///       When overridden in a derived class, indicates whether
                ///       resetting the <paramref name="component "/>will change the value of the
                ///    <paramref name="component"/>.
                /// </para>
                /// </devdoc>
                public override bool CanResetValue(object component) {
                    return false;
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.GetValue"]/*' />
                /// <devdoc>
                ///    <para>
                ///       When overridden in a derived class, gets the current
                ///       value
                ///       of the
                ///       property on a component.
                ///    </para>
                /// </devdoc>
                public override object GetValue(object component) {
                    return value;
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.ResetValue"]/*' />
                /// <devdoc>
                ///    <para>
                ///       When overridden in a derived class, resets the
                ///       value
                ///       for this property
                ///       of the component.
                ///    </para>
                /// </devdoc>
                public override void ResetValue(object component) {
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.SetValue"]/*' />
                /// <devdoc>
                ///    <para>
                ///       When overridden in a derived class, sets the value of
                ///       the component to a different value.
                ///    </para>
                /// </devdoc>
                public override void SetValue(object component, object value) {
                    this.value = value;

                    foreach(ListItem li in collection) {
                        li.Value = value;
                    }
                    control.Invalidate();
                    OnValueChanged(component, EventArgs.Empty);
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.ShouldSerializeValue"]/*' />
                /// <devdoc>
                ///    <para>
                ///       When overridden in a derived class, indicates whether the
                ///       value of
                ///       this property needs to be persisted.
                ///    </para>
                /// </devdoc>
                public override bool ShouldSerializeValue(object component) {
                    return false;
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.ICustomTypeDescriptor.GetAttributes"]/*' />
                /// <devdoc>
                ///     Retrieves an array of member attributes for the given object.
                /// </devdoc>
                AttributeCollection ICustomTypeDescriptor.GetAttributes() {
                    return TypeDescriptor.GetAttributes(collectionItemType);
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.ICustomTypeDescriptor.GetClassName"]/*' />
                /// <devdoc>
                ///     Retrieves the class name for this object.  If null is returned,
                ///     the type name is used.
                /// </devdoc>
                string ICustomTypeDescriptor.GetClassName() {
                    return collectionItemType.Name;
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.ICustomTypeDescriptor.GetComponentName"]/*' />
                /// <devdoc>
                ///     Retrieves the name for this object.  If null is returned,
                ///     the default is used.
                /// </devdoc>
                string ICustomTypeDescriptor.GetComponentName() {
                    return null;
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.ICustomTypeDescriptor.GetConverter"]/*' />
                /// <devdoc>
                ///      Retrieves the type converter for this object.
                /// </devdoc>
                TypeConverter ICustomTypeDescriptor.GetConverter() {
                    return null;
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.ICustomTypeDescriptor.GetDefaultEvent"]/*' />
                /// <devdoc>
                ///     Retrieves the default event.
                /// </devdoc>
                EventDescriptor ICustomTypeDescriptor.GetDefaultEvent() {
                    return null;
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.ICustomTypeDescriptor.GetDefaultProperty"]/*' />
                /// <devdoc>
                ///     Retrieves the default property.
                /// </devdoc>
                PropertyDescriptor ICustomTypeDescriptor.GetDefaultProperty() {
                    return this;
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.ICustomTypeDescriptor.GetEditor"]/*' />
                /// <devdoc>
                ///      Retrieves the an editor for this object.
                /// </devdoc>
                object ICustomTypeDescriptor.GetEditor(Type editorBaseType) {
                    return null;
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.ICustomTypeDescriptor.GetEvents"]/*' />
                /// <devdoc>
                ///     Retrieves an array of events that the given component instance
                ///     provides.  This may differ from the set of events the class
                ///     provides.  If the component is sited, the site may add or remove
                ///     additional events.
                /// </devdoc>
                EventDescriptorCollection ICustomTypeDescriptor.GetEvents() {
                    return EventDescriptorCollection.Empty;
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.ICustomTypeDescriptor.GetEvents1"]/*' />
                /// <devdoc>
                ///     Retrieves an array of events that the given component instance
                ///     provides.  This may differ from the set of events the class
                ///     provides.  If the component is sited, the site may add or remove
                ///     additional events.  The returned array of events will be
                ///     filtered by the given set of attributes.
                /// </devdoc>
                EventDescriptorCollection ICustomTypeDescriptor.GetEvents(Attribute[] attributes) {
                    return EventDescriptorCollection.Empty;
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.ICustomTypeDescriptor.GetProperties"]/*' />
                /// <devdoc>
                ///     Retrieves an array of properties that the given component instance
                ///     provides.  This may differ from the set of properties the class
                ///     provides.  If the component is sited, the site may add or remove
                ///     additional properties.
                /// </devdoc>
                PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties() {
                    return properties;
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.ICustomTypeDescriptor.GetProperties1"]/*' />
                /// <devdoc>
                ///     Retrieves an array of properties that the given component instance
                ///     provides.  This may differ from the set of properties the class
                ///     provides.  If the component is sited, the site may add or remove
                ///     additional properties.  The returned array of properties will be
                ///     filtered by the given set of attributes.
                /// </devdoc>
                PropertyDescriptorCollection ICustomTypeDescriptor.GetProperties(Attribute[] attributes) {
                    return properties;
                }

                /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.SelectionWrapper.ICustomTypeDescriptor.GetPropertyOwner"]/*' />
                /// <devdoc>
                ///     Retrieves the object that directly depends on this value being edited.  This is
                ///     generally the object that is required for the PropertyDescriptor's GetValue and SetValue
                ///     methods.  If 'null' is passed for the PropertyDescriptor, the ICustomComponent
                ///     descripotor implemementation should return the default object, that is the main
                ///     object that exposes the properties and attributes,
                /// </devdoc>
                object ICustomTypeDescriptor.GetPropertyOwner(PropertyDescriptor pd) {
                    return this;
                }
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.ListItem"]/*' />
            /// <devdoc>
            ///      ListItem class.  This is a single entry in our list box.  It contains the value we're editing
            ///      as well as accessors for the type converter and UI editor.
            /// </devdoc>
            private class ListItem {
                private object value;
                private TypeConverter converter;
                private object editor;

                public ListItem(object value) {
                    this.value = value;
                }

                public TypeConverter Converter {
                    get {
                        if (converter == null) {
                            converter = TypeDescriptor.GetConverter(value);
                        }
                        return converter;
                    }
                }

                public UITypeEditor Editor {
                    get {
                        if (editor == null) {
                            editor = TypeDescriptor.GetEditor(value, typeof(UITypeEditor));
                            if (editor == null) {
                                editor = this;
                            }
                        }

                        if (editor != this) {
                            return(UITypeEditor)editor;
                        }

                        return null;
                    }
                }

                public object Value {
                    get {
                        return value;
                    }
                    set {
                        converter = null;
                        editor = null;
                        this.value = value;
                    }
                }
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionEditorCollectionForm.TypeMenuItem"]/*' />
            /// <devdoc>
            ///      Menu items we attach to the drop down menu if there are multiple
            ///      types the collection editor can create.
            /// </devdoc>
            private class TypeMenuItem : MenuItem {
                Type itemType;

                public TypeMenuItem(Type itemType, EventHandler handler) :
                base(itemType.Name, handler) {
                    this.itemType = itemType;
                }

                public Type ItemType {
                    get {
                        return itemType;
                    }
                }
            }

            private class ImageButton : Button {

                Image baseImage;
                int   rgbBackColor;
                int   rgbForeColor;

                private void DrawImageReplaceColor(Graphics g, Image image, Rectangle dest, Color oldColor, Color newColor) {
                    ImageAttributes attrs = new ImageAttributes();
        
                    ColorMap cm = new ColorMap();
                    cm.OldColor = oldColor;
                    cm.NewColor = newColor;
        
                    attrs.SetRemapTable(new ColorMap[]{cm}, ColorAdjustType.Bitmap);
        
                    g.DrawImage(image, dest, 0, 0, image.Width, image.Height, GraphicsUnit.Pixel, attrs, null, IntPtr.Zero);
                    attrs.Dispose();
                }

                private void UpdateImage(Graphics g) {
                    if (baseImage == null) {
                        baseImage = this.Image;
                    }
                    Image newImage = (Image)baseImage.Clone();
                    g = Graphics.FromImage(newImage);
                    DrawImageReplaceColor(g, newImage, new Rectangle(0, 0, baseImage.Width, baseImage.Height), Color.Black, ForeColor);
                    g.Dispose();
                    base.Image = newImage;
                    rgbForeColor = ForeColor.ToArgb();
                    rgbBackColor = BackColor.ToArgb();
                }

                protected override void OnPaint(PaintEventArgs pe) {
                    if (this.ForeColor.ToArgb() != rgbForeColor || this.BackColor.ToArgb() != rgbBackColor) {
                        UpdateImage(pe.Graphics);
                    }

                    base.OnPaint(pe);
                }
            }

            /// <devdoc>
            /// This class allows us to trap keyboard messages to the list view and sling focus over to the grid so you can
            /// just select a list view item and start typeing rather than having to click on the grid.
            /// </devdoc>
            private class FilterListBox : ListBox {

                private PropertyGrid grid;
                private Message      lastKeyDown;
                
                private PropertyGrid PropertyGrid {
                    get {
                        if (grid == null) {
                            foreach (Control c in Parent.Controls) {
                                if (c is PropertyGrid) {
                                    grid = (PropertyGrid)c;
                                    break;
                                }
                            }
                        }
                        return grid;
                    }

                }

                protected override void WndProc(ref Message m) {
                    switch (m.Msg) {
                        case NativeMethods.WM_KEYDOWN:
                            this.lastKeyDown = m;

                            // the first thing the ime does on a key it cares about is send a VK_PROCESSKEY,
                            // so we use that to sling focus to the grid.
                            //
                            if ((int)m.WParam == NativeMethods.VK_PROCESSKEY) {
                                if (PropertyGrid != null) {
                                    UnsafeNativeMethods.SetFocus(PropertyGrid.Handle);
                                    Application.DoEvents();
                                }
                                else {
                                    break;
                                }
                
                                // recreate the keystroke to the newly activated window
                                NativeMethods.SendMessage(UnsafeNativeMethods.GetFocus(), NativeMethods.WM_KEYDOWN, lastKeyDown.WParam, lastKeyDown.LParam);
                            }
                            break;
                        
                        case NativeMethods.WM_CHAR: 
            
                            if ((Control.ModifierKeys & (Keys.Control | Keys.Alt)) != 0) {
                                break;
                            }

                            if (PropertyGrid != null) {
                                PropertyGrid.Focus();
                                UnsafeNativeMethods.SetFocus(PropertyGrid.Handle);
                                Application.DoEvents();
                            }
                            else {
                                break;
                            }
            
                            // Make sure we changed focus properly
                            // recreate the keystroke to the newly activated window
                            //
                            if (PropertyGrid.Focused || PropertyGrid.ContainsFocus) {
                                IntPtr hWnd = UnsafeNativeMethods.GetFocus();
                                NativeMethods.SendMessage(hWnd, NativeMethods.WM_KEYDOWN, lastKeyDown.WParam, lastKeyDown.LParam);
                                NativeMethods.SendMessage(hWnd, NativeMethods.WM_CHAR, m.WParam, m.LParam);
                                return;
                            }
                            break;

                    }
                    base.WndProc(ref m);
                }
            }
        }

        /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionForm"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The <see cref='System.ComponentModel.Design.CollectionEditor.CollectionForm'/>
        ///       provides a modal dialog for editing the
        ///       contents of a collection.
        ///    </para>
        /// </devdoc>
        protected abstract class CollectionForm : Form {

            // Manipulation of the collection.
            //
            private CollectionEditor       editor;
            private object                 value;
            private short                  editableState = EditableDynamic;

            private const short            EditableDynamic = 0;
            private const short            EditableYes     = 1;
            private const short            EditableNo      = 2;
            
            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionForm.CollectionForm"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Initializes a new instance of the <see cref='System.ComponentModel.Design.CollectionEditor.CollectionForm'/> class.
            ///    </para>
            /// </devdoc>
            public CollectionForm(CollectionEditor editor) {
                this.editor = editor; 
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionForm.CollectionItemType"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Gets or sets the data type of each item in the collection.
            ///    </para>
            /// </devdoc>
            protected Type CollectionItemType {
                get {
                    return editor.CollectionItemType;
                }
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionForm.CollectionType"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Gets or sets the type of the collection.
            ///    </para>
            /// </devdoc>
            protected Type CollectionType {
                get {
                    return editor.CollectionType;
                }
            }

            /// <internalonly/>
            internal virtual bool CollectionEditable {
                get {
                    if (editableState != EditableDynamic) {
                        return editableState == EditableYes;
                    }

                    bool editable = typeof(IList).IsAssignableFrom(editor.CollectionType);
                    
                    if (editable) {
                        IList list = EditValue as IList;    
                        if (list != null) {
                            return !list.IsReadOnly;
                        }
                    }
                    return editable;
                }
                set {
                    if (value) {
                        editableState = EditableYes;
                    }
                    else {
                        editableState = EditableNo;
                    }
                }
            }
                         
            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionForm.Context"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Gets or sets a type descriptor that indicates the current context.
            ///    </para>
            /// </devdoc>
            protected ITypeDescriptorContext Context {
                get {
                    return editor.Context;
                }
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionForm.EditValue"]/*' />
            /// <devdoc>
            ///    <para>Gets or sets the value of the item being edited.</para>
            /// </devdoc>
            public object EditValue {
                get {
                    return value;
                }
                set {
                    this.value = value;
                    OnEditValueChanged();
                }
            }            
            
            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionForm.Items"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Gets or sets the
            ///       array of items this form is to display.
            ///    </para>
            /// </devdoc>
            protected object[] Items {
                get {
                    return editor.GetItems(EditValue);
                }
                set {
                    // Request our desire to make a change.
                    //
                    if (Context.OnComponentChanging()) {
                        object newValue = editor.SetItems(EditValue, value);
                        if (newValue != EditValue) {
                            EditValue = newValue;
                        }

                        Context.OnComponentChanged();
                    }
                }
            }
            
            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionForm.NewItemTypes"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Gets or sets the available item types that can be created for this
            ///       collection.
            ///    </para>
            /// </devdoc>
            protected Type[] NewItemTypes {
                get {
                    return editor.NewItemTypes;
                }
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionForm.CanRemoveInstance"]/*' />
            /// <devdoc>
            ///    <para>Gets or sets a value indicating whether original members of the collection
            ///       can be removed.</para>
            /// </devdoc>
            protected bool CanRemoveInstance(object value) {
                return editor.CanRemoveInstance(value);
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionForm.CanSelectMultipleInstances"]/*' />
            /// <devdoc>
            ///    <para>Gets or sets a value indicating whether multiple collection members can be
            ///       selected.</para>
            /// </devdoc>
            protected virtual bool CanSelectMultipleInstances() {
                return editor.CanSelectMultipleInstances();
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionForm.CreateInstance"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Creates a new instance of the specified collection item type.
            ///    </para>
            /// </devdoc>
            protected object CreateInstance(Type itemType) {
                return editor.CreateInstance(itemType);
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionForm.DestroyInstance"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Destroys the specified instance of the object.
            ///    </para>
            /// </devdoc>
            protected void DestroyInstance(object instance) {
                editor.DestroyInstance(instance);
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionForm.DisplayError"]/*' />
            /// <devdoc>
            ///    Displays the given exception to the user.
            /// </devdoc>
            protected virtual void DisplayError(Exception e) {
                IUIService uis = (IUIService)GetService(typeof(IUIService));
                if (uis != null) {
                    uis.ShowError(e);
                }
                else {
                    string message = e.Message;
                    if (message == null || message.Length == 0) {
                        message = e.ToString();
                    }
                    MessageBox.Show(message, null, MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
                }
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionForm.GetService"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Gets the requested service, if it is available.
            ///    </para>
            /// </devdoc>
            protected override object GetService(Type serviceType) {
                return editor.GetService(serviceType);
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionForm.ShowEditorDialog"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Called to show the dialog via the IWindowsFormsEditorService
            ///    </para>
            /// </devdoc>
            protected internal virtual DialogResult ShowEditorDialog(IWindowsFormsEditorService edSvc) {
                return edSvc.ShowDialog(this);
            }

            /// <include file='doc\CollectionEditor.uex' path='docs/doc[@for="CollectionEditor.CollectionForm.OnEditValueChanged"]/*' />
            /// <devdoc>
            ///    <para>
            ///       This is called when the value property in
            ///       the <see cref='System.ComponentModel.Design.CollectionEditor.CollectionForm'/>
            ///       has changed.
            ///    </para>
            /// </devdoc>
            protected abstract void OnEditValueChanged();
        }


     internal class PropertyGridSite : ISite {

            private IServiceProvider sp;
            private IComponent comp;
            private bool       inGetService = false;

            public PropertyGridSite(IServiceProvider sp, IComponent comp) {
                this.sp = sp;
                this.comp = comp;
            }

             /** The component sited by this component site. */
            /// <include file='doc\ISite.uex' path='docs/doc[@for="ISite.Component"]/*' />
            /// <devdoc>
            ///    <para>When implemented by a class, gets the component associated with the <see cref='System.ComponentModel.ISite'/>.</para>
            /// </devdoc>
            public IComponent Component {get {return comp;}}
        
            /** The container in which the component is sited. */
            /// <include file='doc\ISite.uex' path='docs/doc[@for="ISite.Container"]/*' />
            /// <devdoc>
            /// <para>When implemented by a class, gets the container associated with the <see cref='System.ComponentModel.ISite'/>.</para>
            /// </devdoc>
            public IContainer Container {get {return null;}}
        
            /** Indicates whether the component is in design mode. */
            /// <include file='doc\ISite.uex' path='docs/doc[@for="ISite.DesignMode"]/*' />
            /// <devdoc>
            ///    <para>When implemented by a class, determines whether the component is in design mode.</para>
            /// </devdoc>
            public  bool DesignMode {get {return false;}}
        
            /** 
             * The name of the component.
             */
                /// <include file='doc\ISite.uex' path='docs/doc[@for="ISite.Name"]/*' />
                /// <devdoc>
                ///    <para>When implemented by a class, gets or sets the name of
                ///       the component associated with the <see cref='System.ComponentModel.ISite'/>.</para>
                /// </devdoc>
                public String Name {
                        get {return null;}
                        set {}
                }

            public object GetService(Type t) {
                if (!inGetService && sp != null) {
                    try {
                        inGetService = true;
                        return sp.GetService(t);
                    }
                    finally {
                        inGetService = false;
                    }
                }
                return null;
            }

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\serialization\codevalueexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeValueExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design.Serialization {

    using System;
    using System.CodeDom;

    /// <include file='doc\CodeValueExpression.uex' path='docs/doc[@for="CodeValueExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a code expression that has been matched to a value.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class CodeValueExpression {
        private CodeExpression expression;
        private object value;
        private Type   type;

        public CodeValueExpression(CodeExpression expression, object value, Type t) {
            this.expression = expression;
            this.value = value;
            this.type = t;
        }
        
        public CodeValueExpression(CodeExpression expression, object value) : this(expression, value, null){
        }

        
        public CodeExpression Expression {
            get {
                return expression;
            }
        }
        
        public object Value {
            get {
                return value;
            }
        }

        public Type ExpressionType {
            get {
                return type;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\serialization\codedomserializerexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeDomSerializerException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel.Design.Serialization {
    
    using System;
    using System.CodeDom;
    using System.Runtime.Serialization;

    /// <include file='doc\CodeDomSerializerException.uex' path='docs/doc[@for="CodeDomSerializerException"]/*' />
    /// <devdoc>
    ///    <para> The exception that is thrown when the code dom serializer experiences an error.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class CodeDomSerializerException : SystemException {

        private CodeLinePragma linePragma;
        
        /// <include file='doc\CodeDomSerializerException.uex' path='docs/doc[@for="CodeDomSerializerException.CodeDomSerializerException"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the CodeDomSerializerException class.</para>
        /// </devdoc>
        public CodeDomSerializerException(string message, CodeLinePragma linePragma) : base(message) {
            this.linePragma = linePragma;
        }

        /// <include file='doc\CodeDomSerializerException.uex' path='docs/doc[@for="CodeDomSerializerException.CodeDomSerializerException1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the CodeDomSerializerException class.</para>
        /// </devdoc>
        public CodeDomSerializerException(Exception ex, CodeLinePragma linePragma) : base(ex.Message, ex) {
            this.linePragma = linePragma;
        }

        /// <include file='doc\CodeDomSerializerException.uex' path='docs/doc[@for="CodeDomSerializerException.CodeDomSerializerException2"]/*' />
        protected CodeDomSerializerException(SerializationInfo info, StreamingContext context) : base (info, context) {
            linePragma = (CodeLinePragma)info.GetValue("linePragma", typeof(CodeLinePragma));
        }

        /// <include file='doc\CodeDomSerializerException.uex' path='docs/doc[@for="CodeDomSerializerException.LinePragma"]/*' />
        /// <devdoc>
        ///    <para>Gets the line pragma object that is related to this error.</para>
        /// </devdoc>
        public CodeLinePragma LinePragma {
            get {
                return linePragma;
            }
        }
        
        /// <include file='doc\CodeDomSerializerException.uex' path='docs/doc[@for="CodeDomSerializerException.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            info.AddValue("linePragma", linePragma);
            base.GetObjectData(info, context);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\serialization\enumcodedomserializer.cs ===
//------------------------------------------------------------------------------
// <copyright file="EnumCodeDomSerializer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design.Serialization {

    using System;
    using System.CodeDom;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Reflection;
    
    /// <include file='doc\EnumCodeDomSerializer.uex' path='docs/doc[@for="EnumCodeDomSerializer"]/*' />
    /// <devdoc>
    ///     Code model serializer for enum types.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class EnumCodeDomSerializer : CodeDomSerializer {
    
        private static EnumCodeDomSerializer defaultSerializer;
        
        /// <include file='doc\EnumCodeDomSerializer.uex' path='docs/doc[@for="EnumCodeDomSerializer.Default"]/*' />
        /// <devdoc>
        ///     Retrieves a default static instance of this serializer.
        /// </devdoc>
        public static EnumCodeDomSerializer Default {
            get {
                if (defaultSerializer == null) {
                    defaultSerializer = new EnumCodeDomSerializer();
                }
                return defaultSerializer;
            }
        }
        
        /// <include file='doc\EnumCodeDomSerializer.uex' path='docs/doc[@for="EnumCodeDomSerializer.Deserialize"]/*' />
        /// <devdoc>
        ///     Deserilizes the given CodeDom object into a real object.  This
        ///     will use the serialization manager to create objects and resolve
        ///     data types.  The root of the object graph is returned.
        /// </devdoc>
        public override object Deserialize(IDesignerSerializationManager manager, object codeObject) {
            // No need to have this code -- we just deserialize by exectuting code.
            Debug.Fail("Don't expect this to be called.");
            return null;
        }
            
        /// <include file='doc\EnumCodeDomSerializer.uex' path='docs/doc[@for="EnumCodeDomSerializer.Serialize"]/*' />
        /// <devdoc>
        ///     Serializes the given object into a CodeDom object.
        /// </devdoc>
        public override object Serialize(IDesignerSerializationManager manager, object value) {
            CodeExpression expression = null;
            
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "EnumCodeDomSerializer::Serialize");
            Debug.Indent();
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Type: " + (value == null ? "(null)" : value.GetType().Name));
            
            if (value is Enum) {
                string enumName = TypeDescriptor.GetConverter(value.GetType()).ConvertToInvariantString(value);
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Names: " + enumName);
                string[] names = enumName.Split(new char[] {','});
                
                CodeTypeReferenceExpression enumType = new CodeTypeReferenceExpression(value.GetType());
                
                // If names is of length 1, then this is a simple field reference. Otherwise,
                // it is an or-d combination of expressions.
                //
                Debug.WriteLineIf(traceSerialization.TraceVerbose && names.Length == 1, "Single field entity.");
                Debug.WriteLineIf(traceSerialization.TraceVerbose && names.Length > 1, "Multi field entity.");
                foreach(string name in names) {
                    string nameCopy = name.Trim();
                    CodeExpression newExpression = new CodeFieldReferenceExpression(enumType, nameCopy);
                    if (expression == null) {
                        expression = newExpression;
                    }
                    else {
                        expression = new CodeBinaryOperatorExpression(expression, CodeBinaryOperatorType.BitwiseOr, newExpression);
                    }
                }

                // If we had to combine multiple names, wrap the result in an appropriate cast.
                //
                if (names.Length > 1) {
                    expression = new CodeCastExpression(value.GetType(), expression);
                }
            }
            
            Debug.Unindent();
            return expression;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\serialization\icodedomdesignerreload.cs ===
//------------------------------------------------------------------------------
// <copyright file="ICodeDomDesignerReload.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
 
    namespace System.ComponentModel.Design.Serialization {

    using System;
    using System.Design;
    using System.CodeDom;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Reflection;

    
    /// <include file='doc\ICodeDomDesignerReload.uex' path='docs/doc[@for="ICodeDomDesignerReload"]/*' />
    /// <devdoc>
    ///     Implement this interface on a CodeDomProvider to optimize reloading in the designer.  When the designer
    ///     goes to reparse a file, it will reparse the top level of the file, and then pass the new CodeCompileUnit to
    ///     the ShouldReloadDesigner method, which returns true if the desinger should be reloaded.  Reloading generally occurs
    ///     when the code inside the methods that the designer has generated, such as InitializeComponent have changed.  Otherwise,
    ///     it is unnecessary to take the performance hit of reloading the designer.
    /// </devdoc>
    public interface ICodeDomDesignerReload {

        /// <include file='doc\ICodeDomDesignerReload.uex' path='docs/doc[@for="ICodeDomDesignerReload.ShouldReloadDesigner"]/*' />
        /// <devdoc>
        /// If ICodeDomDesignerReload is implemented on a CodeDomProvider that is in use by the designer, ShouldReloadDesigner will be called
        /// before a reload occurs.  Reloads generally occur when a user switches from design view to code view, modifies the code, and switches
        /// back to design view.  ShouldReloadDesigner allows the CodeDomProvider implementation to decide if code that is relevant to the designer
        /// has been modified -- ususally this is the code that the designer generated when the user saved or went to code view.
        /// </devdoc>
        bool ShouldReloadDesigner(CodeCompileUnit newTree);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\serialization\codedomserializer.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeDomSerializer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design.Serialization {

    using System;
    using System.Design;
    using System.Resources;
    using System.CodeDom;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Globalization;
    using System.Reflection;
    
    /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer"]/*' />
    /// <devdoc>
    ///     The is a base class that can be used to serialize an object graph to a series of
    ///     CodeDom statements.  
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public abstract class CodeDomSerializer {
    
        
        internal static TraceSwitch traceSerialization = new TraceSwitch("DesignerSerialization", "Trace design time serialization");
        
        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.Deserialize"]/*' />
        /// <devdoc>
        ///     Deserilizes the given CodeDom object into a real object.  This
        ///     will use the serialization manager to create objects and resolve
        ///     data types.  The root of the object graph is returned.
        /// </devdoc>
        public abstract object Deserialize(IDesignerSerializationManager manager, object codeObject);
            
        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.DeserializePropertiesFromResources"]/*' />
        /// <devdoc>
        ///     This method will inspect all of the properties on the given object fitting the filter, and check for that
        ///     property in a resource blob.  This is useful for deserializing properties that cannot be represented
        ///     in code, such as design-time properties. 
        /// </devdoc>
        protected void DeserializePropertiesFromResources(IDesignerSerializationManager manager, object value, Attribute[] filter) {
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "ComponentCodeDomSerializer::DeserializePropertiesFromResources");
            Debug.Indent();
            
            // It is much faster to dig through the resources first, and then map these resources
            // to properties than it is to filter properties at each turn.  Why?  Because filtering
            // properties requires a separate filter call for each object (because designers get a chance
            // to filter, the cache is per-component), while resources are loaded once per
            // document.
            //
            IDictionaryEnumerator de = ResourceCodeDomSerializer.Default.GetEnumerator(manager, CultureInfo.InvariantCulture);
            
            if (de != null) {
            
                string ourObjectName;
                IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                if (host != null && host.RootComponent == value) {
                    ourObjectName = "$this";
                }
                else {
                    ourObjectName = manager.GetName(value);
                }
                
                PropertyDescriptorCollection ourProperties = TypeDescriptor.GetProperties(value);
                
                while(de.MoveNext()) {

                    object current = de.Current;
                    
                    string resourceName = de.Key as string;
                    Debug.Assert(resourceName != null, "non-string keys in dictionary entry");
                    int dotIndex = resourceName.IndexOf('.');
                    if (dotIndex == -1) {
                        continue;
                    }
                    
                    string objectName = resourceName.Substring(0, dotIndex);
                    
                    // Skip now if this isn't a value for our object.
                    //
                    if (!objectName.Equals(ourObjectName)) {
                        continue;
                    }
                    
                    string propertyName = resourceName.Substring(dotIndex + 1);
                    
                    // Now locate the property by this name.
                    //
                    PropertyDescriptor property = ourProperties[propertyName];
                    if (property == null) {
                        continue;
                    }
                    
                    // This property must have matching attributes.
                    //
                    bool passFilter = true;
                    
                    if (filter != null) {
                        AttributeCollection propAttributes = property.Attributes;
                        
                        foreach(Attribute a in filter) {
                            if (!propAttributes.Contains(a)) {
                                passFilter = false;
                                break;
                            }
                        }
                    }
                    
                    // If this property passes inspection, then set it.
                    //
                    if (passFilter) {
                        object resourceObject = de.Value;
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Resource: " + resourceName + ", value: " + resourceObject.ToString());
                        try {
                            property.SetValue(value, resourceObject);
                        }
                        catch(Exception e) {
                            manager.ReportError(e);
                        }
                    }
                }
            }
            
            Debug.Unindent();
        }
        
        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.DeserializeStatement"]/*' />
        /// <devdoc>
        ///     This is a helper method that will deserialize a given statement.  It deserializes
        ///     the statement by interpreting and executing the CodeDom statement.
        /// </devdoc>
        protected void DeserializeStatement(IDesignerSerializationManager manager, CodeStatement statement) {
        
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "CodeDomSerializer::DeserializeStatement");
            Debug.Indent();
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Statement: " + statement.GetType().Name);
            
            // Push this statement onto the context stack.  This allows any serializers handling an expression
            // to know what it was connected to.
            //
            manager.Context.Push(statement);
            
            try {
                try {
                    if (statement is CodeAssignStatement) {
                        DeserializeAssignStatement(manager, (CodeAssignStatement)statement);
                    }
                    else if (statement is CodeAttachEventStatement) {
                        DeserializeAttachEventStatement(manager, (CodeAttachEventStatement)statement);
                    }
                    else if (statement is CodeRemoveEventStatement) {
                        DeserializeDetachEventStatement(manager, (CodeRemoveEventStatement)statement);
                    }
                    else if (statement is CodeExpressionStatement) {
                        DeserializeExpression(manager, null, ((CodeExpressionStatement)statement).Expression);
                    }
                    else if (statement is CodeLabeledStatement) {
                        DeserializeStatement(manager, ((CodeLabeledStatement)statement).Statement);
                    }
                    else if (statement is CodeMethodReturnStatement) {
                        DeserializeExpression(manager, null, ((CodeMethodReturnStatement)statement).Expression);
                    }
                    else if (statement is CodeVariableDeclarationStatement) {
                        DeserializeVariableDeclarationStatement(manager, (CodeVariableDeclarationStatement)statement);
                    }
                    else {
                        Debug.WriteLineIf(traceSerialization.TraceWarning, "WARNING: Unrecognized statement type: " + statement.GetType().Name);
                    }
                }
                catch(Exception e) {
                
                    // Since we always go through reflection, don't 
                    // show what our engine does, show what caused 
                    // the problem.
                    //
                    if (e is TargetInvocationException) {
                        e = e.InnerException;
                    }
                    
                    manager.ReportError(e);
                }
            }
            finally {
                Debug.Assert(manager.Context.Current == statement, "Someone corrupted the context stack");
                manager.Context.Pop();
            }
            
            Debug.Unindent();
        }
        
        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.DeserializeAssignStatement"]/*' />
        /// <devdoc>
        ///     Deserializes an assign statement by performing the assignment.
        /// </devdoc>
        private void DeserializeAssignStatement(IDesignerSerializationManager manager, CodeAssignStatement statement) {
        
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "CodeDomSerializer::DeserializeAssignStatement");
            Debug.Indent();
            
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Processing RHS");
            object rhs = DeserializeExpression(manager, null, statement.Right);
            if (rhs is CodeExpression) {
                Debug.WriteLineIf(traceSerialization.TraceError, "*** Unable to simplify statement to anything better than: " + rhs.GetType().Name);
                Debug.Unindent();
                return;
            }
            
            // Since we're doing an assignment into something, we need to know
            // what that something is.  It can be a property, a variable, or
            // a member. Anything else is invalid.  
            //
            CodeExpression expression = statement.Left;
            
            if (expression is CodeArrayIndexerExpression) {
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "LHS is Array Indexer");
                CodeArrayIndexerExpression a = (CodeArrayIndexerExpression)expression;
                int[] indexes = new int[a.Indices.Count];
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Dims: " + indexes.Length.ToString());
                object array = DeserializeExpression(manager, null, a.TargetObject);
                bool indexesOK = true;
                
                // The indexes have to be of type int32.  If they're not, then
                // we cannot assign to this array.
                //
                for (int i = 0; i < indexes.Length; i++) {
                    object index = DeserializeExpression(manager, null, a.Indices[i]);
                    if (index is IConvertible) {
                        indexes[i] = ((IConvertible)index).ToInt32(null);
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "[" + i.ToString() + "] == " + indexes[i].ToString());
                    }
                    else {
                        Debug.WriteLineIf(traceSerialization.TraceWarning, "WARNING: Index " + i.ToString() + " could not be converted to int.  Type: " + (index == null ? "(null)" : index.GetType().Name));
                        indexesOK = false;
                        break;
                    }
                }
                
                if (array is Array && indexesOK) {
                    ((Array)array).SetValue(rhs, indexes);
                }
                else {
                    Debug.WriteLineIf(traceSerialization.TraceError && !(array is Array), "*** Array resovled to something other than an array: " + (array == null ? "(null)" : array.GetType().Name) + " ***");
                    Debug.WriteLineIf(traceSerialization.TraceError && !indexesOK, "*** Indexes to array could not be converted to int32. ***");
                }
            }
            else if (expression is CodeFieldReferenceExpression) {
                CodeFieldReferenceExpression field = (CodeFieldReferenceExpression)expression;
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "LHS is field reference.  Name: " + field.FieldName);
                
                object lhs = DeserializeExpression(manager, field.FieldName, field.TargetObject);
                if (lhs != null) {
                    FieldInfo f;
                    object instance;
                     
                    if (lhs is Type) {
                        instance = null;
                        f = ((Type)lhs).GetField(field.FieldName,
                            BindingFlags.GetField |
                            BindingFlags.Static |
                            BindingFlags.Public);
                    }
                    else {
                        instance = lhs;
                        f = lhs.GetType().GetField(field.FieldName,
                            BindingFlags.GetField |
                            BindingFlags.Instance |
                            BindingFlags.Public);
                    }
                    if (f != null) {

                        if (rhs != null && f.FieldType != rhs.GetType() && rhs is IConvertible) {
                            try {
                                rhs = ((IConvertible)rhs).ToType(f.FieldType, null);
                            }
                            catch {
                                // oh well...
                            }
                        }


                        f.SetValue(instance, rhs);
                    }
                    else {
                        Debug.WriteLineIf(traceSerialization.TraceError, "*** Object " + lhs.GetType().Name + " does not have a field " + field.FieldName + "***");
                        Error(manager, 
                              SR.GetString(SR.SerializerNoSuchField, lhs.GetType().FullName, field.FieldName), 
                              SR.SerializerNoSuchField);
                    }
                }
                else {
                    Debug.WriteLineIf(traceSerialization.TraceWarning, "WARNING: Could not find target object for field " + field.FieldName);
                }
            }
            else if (expression is CodePropertyReferenceExpression) {
                CodePropertyReferenceExpression property = (CodePropertyReferenceExpression)expression;
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "LHS is property reference.  Name: " + property.PropertyName);
                
                object lhs = DeserializeExpression(manager, null, property.TargetObject);
                if (lhs != null && !(lhs is CodeExpression)) {
                
                    // Property assignments must go through our type descriptor system.
                    // However, we do not support parameterized properties.  If there are
                    // any parameters on the property, we do not perform the assignment.
                    //
                    PropertyDescriptor p = TypeDescriptor.GetProperties(lhs)[property.PropertyName];
                    if (p != null) {

                        if (rhs != null && p.PropertyType != rhs.GetType() && rhs is IConvertible) {
                            try {
                                rhs = ((IConvertible)rhs).ToType(p.PropertyType, null);
                            }
                            catch {
                                // oh well...
                            }
                        }

                        p.SetValue(lhs, rhs);
                    }
                    else {
                        Debug.WriteLineIf(traceSerialization.TraceError, "*** Object " + lhs.GetType().Name + " does not have a property " + property.PropertyName + "***");
                        Error(manager, 
                              SR.GetString(SR.SerializerNoSuchProperty, lhs.GetType().FullName, property.PropertyName),
                              SR.SerializerNoSuchProperty);
                    }
                }
                else {
                    Debug.WriteLineIf(traceSerialization.TraceWarning, "WARNING: Could not find target object for property " + property.PropertyName);
                }
            }
            else if (expression is CodeVariableReferenceExpression) {
                CodeVariableReferenceExpression variable = (CodeVariableReferenceExpression)expression;
                
                // This is the easiest.  Just relate the RHS object to the name of the variable.
                //
                manager.SetName(rhs, variable.VariableName);
            }
            
            Debug.Unindent();
        }
        
        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.DeserializeAttachEventStatement"]/*' />
        /// <devdoc>
        ///     Deserializes the event attachment by setting the event value throught IEventBindingService.
        /// </devdoc>
        private void DeserializeAttachEventStatement(IDesignerSerializationManager manager, CodeAttachEventStatement statement) {
        
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "CodeDomSerializer::DeserializeAttachEventStatement");
            Debug.Indent();
            
            string handlerMethodName = null;
            object eventAttachObject = null; 
            
            // Get the target information
            //
            object targetObject = DeserializeExpression(manager, null, statement.Event.TargetObject);
            string eventName = statement.Event.EventName;
            
            Debug.Assert(targetObject != null, "Failed to get target object for event attach");
            Debug.Assert(eventName != null, "Failed to get eventName for event attach");
            if (eventName == null || targetObject == null) {
                Debug.Unindent();
                return;
            }
            
            if (statement.Listener is CodeObjectCreateExpression) {
                
                // now walk into the CodeObjectCreateExpression and get the parameters so we can 
                // get the name of the method, e.g. button1_Click
                //
                CodeObjectCreateExpression objCreate = (CodeObjectCreateExpression)statement.Listener;
                
                if (objCreate.Parameters.Count == 1) {
                
                    // if this is a delegate create (new EventHandler(this.button1_Click)), then
                    // the first parameter should be a method ref.
                    //
                    if (objCreate.Parameters[0] is CodeMethodReferenceExpression) {
                        CodeMethodReferenceExpression methodRef = (CodeMethodReferenceExpression)objCreate.Parameters[0];
                        handlerMethodName = methodRef.MethodName;
                        eventAttachObject = DeserializeExpression(manager, null, methodRef.TargetObject);
                    }
                }
                else {
                    Debug.Fail("Encountered delegate object create with more or less than 1 parameter?");
                }
            }
            else {
                object eventListener = DeserializeExpression(manager, null, statement.Listener);
                if (eventListener is CodeDelegateCreateExpression) {
                    CodeDelegateCreateExpression delegateCreate = (CodeDelegateCreateExpression)eventListener;
                    
                    eventAttachObject = DeserializeExpression(manager, null, delegateCreate.TargetObject);
                    handlerMethodName = delegateCreate.MethodName;
                    
                }
            }
            
            if (eventAttachObject == null || handlerMethodName == null) {
                Debug.WriteLineIf(traceSerialization.TraceError, "*** Unable to retrieve handler method and object for delegate create. ***");
            }
            else {
            
                // We only support binding methods to the root object.
                //
                IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                Debug.Assert(host != null, "No designer host -- we cannot attach events.");
                
                Debug.WriteLineIf(traceSerialization.TraceWarning && (host != null && host.RootComponent != eventAttachObject), "WARNING: Event is bound to an object other than the root.  We do not support this.");
                if (host != null && host.RootComponent == eventAttachObject) {
                
                    // Now deserialize the LHS of the event attach to discover the guy whose
                    // event we are attaching.
                    //
                    Debug.WriteLineIf(traceSerialization.TraceError && targetObject is CodeExpression, "*** Unable to simplify event attach LHS to an object reference. ***");
                    if (!(targetObject is CodeExpression)) {
                        EventDescriptor evt = TypeDescriptor.GetEvents(targetObject)[eventName];
                        
                        if (evt != null) {
                            IEventBindingService evtSvc = (IEventBindingService)manager.GetService(typeof(IEventBindingService));
                            Debug.Assert(evtSvc != null, "No event binding service on host -- we cannot attach events.");
                            if (evtSvc != null) {
                                PropertyDescriptor prop = evtSvc.GetEventProperty(evt);
                                prop.SetValue(targetObject, handlerMethodName);
                                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Attached event '"  + targetObject.GetType().Name + "." + eventName + "' to method '" + handlerMethodName + "'");
                            }
                        }
                        else {
                            Debug.WriteLineIf(traceSerialization.TraceError, "*** Object " + targetObject.GetType().Name + " does not have a event " + eventName + " ***");
                            Error(manager,
                                  SR.GetString(SR.SerializerNoSuchEvent, targetObject.GetType().FullName, eventName),
                                  SR.SerializerNoSuchEvent);
                        }
                    }
                }
            }
            
            Debug.Unindent();
        }
        
        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.DeserializeDetachEventStatement"]/*' />
        /// <devdoc>
        ///     Deserializes the event detachment by setting the event value throught IEventBindingService.
        /// </devdoc>
        private void DeserializeDetachEventStatement(IDesignerSerializationManager manager, CodeRemoveEventStatement statement) {
        
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "CodeDomSerializer::DeserializeDetachEventStatement");
            Debug.Indent();
            
            object eventListener = DeserializeExpression(manager, null, statement.Listener);
            Debug.WriteLineIf(traceSerialization.TraceError && eventListener is CodeDelegateCreateExpression, "*** Unable to simplify event attach RHS to a delegate create. ***");
            
            if (eventListener is CodeDelegateCreateExpression) {
                CodeDelegateCreateExpression delegateCreate = (CodeDelegateCreateExpression)eventListener;
                
                // We only support binding methods to the root object.
                //
                object eventAttachObject = DeserializeExpression(manager, null, delegateCreate.TargetObject);
                IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                Debug.Assert(host != null, "No designer host -- we cannot attach events.");
                
                Debug.WriteLineIf(traceSerialization.TraceWarning && (host != null && host.RootComponent == eventAttachObject), "WARNING: Event is bound to an object other than the root.  We do not support this.");
                if (host != null && host.RootComponent == eventAttachObject) {
                
                    // Now deserialize the LHS of the event attach to discover the guy whose
                    // event we are attaching.
                    //
                    object targetObject = DeserializeExpression(manager, null, statement.Event.TargetObject);
                    
                    Debug.WriteLineIf(traceSerialization.TraceError && targetObject is CodeExpression, "*** Unable to simplify event attach LHS to an object reference. ***");
                    if (!(targetObject is CodeExpression)) {
                        EventDescriptor evt = TypeDescriptor.GetEvents(targetObject)[statement.Event.EventName];
                        
                        if (evt != null) {
                            IEventBindingService evtSvc = (IEventBindingService)manager.GetService(typeof(IEventBindingService));
                            Debug.Assert(evtSvc != null, "No event binding service on host -- we cannot attach events.");
                            if (evtSvc != null) {
                                PropertyDescriptor prop = evtSvc.GetEventProperty(evt);
                                if (delegateCreate.MethodName.Equals(prop.GetValue(targetObject))) {
                                    prop.SetValue(targetObject, null);
                                }
                            }
                        }
                        else {
                            Debug.WriteLineIf(traceSerialization.TraceError, "*** Object " + targetObject.GetType().Name + " does not have a event " + statement.Event.EventName + "***");
                            Error(manager, 
                                  SR.GetString(SR.SerializerNoSuchEvent, targetObject.GetType().FullName, statement.Event.EventName),
                                  SR.SerializerNoSuchEvent);
                        }
                    }
                }
            }
            
            Debug.Unindent();
        }
        
        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.DeserializeExpression"]/*' />
        /// <devdoc>
        ///     This is a helper method that will deserialize a given expression.  It deserializes
        ///     the statement by interpreting and executing the CodeDom expression, returning
        ///     the results.
        /// </devdoc>
        protected object DeserializeExpression(IDesignerSerializationManager manager, string name, CodeExpression expression) {
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "CodeDomSerializer::DeserializeExpression");
            Debug.Indent();
            
            object result = expression;
            
            try {
                while(result != null) {
                    if(result is CodeArgumentReferenceExpression) {
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "ArgumentNameReference");
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Name: " + ((CodeArgumentReferenceExpression)result).ParameterName);
                        CodeArgumentReferenceExpression argRef = (CodeArgumentReferenceExpression)result;
                        
                        result = manager.GetInstance(argRef.ParameterName);
                        if (result == null) {
                            Debug.WriteLineIf(traceSerialization.TraceError, "*** Parameter " + argRef.ParameterName + " does not exist ***");
                            Error(manager,
                                  SR.GetString(SR.SerializerUndeclaredName, argRef.ParameterName),
                                  SR.SerializerUndeclaredName);
                        }
                        break;
                    }
                    else if (result is CodeArrayCreateExpression) {
                        CodeArrayCreateExpression e = (CodeArrayCreateExpression)result;
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "ArrayCreate");
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Type: " + e.CreateType.BaseType);
                        Type arrayType = manager.GetType(e.CreateType.BaseType);
                        Array array = null;
                        
                        if (arrayType != null) {
                            if (e.Initializers.Count > 0) {
                                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Initialized with " + e.Initializers.Count.ToString() + " values.");
                                
                                // Passed an array of initializers.  Use this
                                // to create the array.  Note that we use an 
                                // ArrayList here and add elements as we create them.
                                // It is possible that an element cannot be resolved.
                                // This is an error, but we do not want to tank the
                                // entire array.  If we kicked out the entire statement,
                                // a missing control would cause all controls on a form
                                // to vanish.

                                ArrayList arrayList = new ArrayList(e.Initializers.Count);

                                foreach(CodeExpression initializer in e.Initializers) {
                                    try {
                                        object o = DeserializeExpression(manager, name, initializer);
                                        if (!(o is CodeExpression)) {
                                            arrayList.Add(o);
                                        }
                                    }
                                    catch(Exception ex) {
                                        manager.ReportError(ex);
                                    }
                                }

                                array = Array.CreateInstance(arrayType, arrayList.Count);
                                arrayList.CopyTo(array, 0);
                            }
                            else if (e.SizeExpression != null) {
                                object o = DeserializeExpression(manager, name, e.SizeExpression);
                                Debug.Assert(o is IConvertible, "Array size expression could not be resolved to IConvertible: " + (o == null ? "(null)" : o.GetType().Name));
                                if (o is IConvertible) {
                                    int size = ((IConvertible)o).ToInt32(null);
                                    Debug.WriteLineIf(traceSerialization.TraceVerbose, "Initialized with expression that simplified to " + size.ToString());
                                    array = Array.CreateInstance(arrayType, size);
                                }
                            }
                            else {
                                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Initialized with size " + e.Size.ToString());
                                array = Array.CreateInstance(arrayType, e.Size);
                            }
                        }
                        else {
                            Debug.WriteLineIf(traceSerialization.TraceError, "*** Type could not be resolved: " + e.CreateType.BaseType);
                            Error(manager,
                                  SR.GetString(SR.SerializerTypeNotFound, e.CreateType.BaseType),
                                  SR.SerializerTypeNotFound);
                        }
                        
                        result = array;
                        if (result != null && name != null) {
                            manager.SetName(result, name);
                        }
                        break;
                    }
                    else if(result is CodeArrayIndexerExpression) {
                        CodeArrayIndexerExpression e = (CodeArrayIndexerExpression)result;
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "ArrayIndexer");
                        
                        // For this, assume in any error we return a null.  The only errors
                        // here should come from a mal-formed expression.
                        //
                        result = null;
                        
                        object array = DeserializeExpression(manager, name, e.TargetObject);
                        if (array is Array) {
                            int[] indexes = new int[e.Indices.Count];
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Dims: " + indexes.Length.ToString());
                            bool indexesOK = true;
                    
                            // The indexes have to be of type int32.  If they're not, then
                            // we cannot assign to this array.
                            //
                            for (int i = 0; i < indexes.Length; i++) {
                                object index = DeserializeExpression(manager, name, e.Indices[i]);
                                if (index is IConvertible) {
                                    indexes[i] = ((IConvertible)index).ToInt32(null);
                                    Debug.WriteLineIf(traceSerialization.TraceVerbose, "[" + i.ToString() + "] == " + indexes[i].ToString());
                                }
                                else {
                                    Debug.WriteLineIf(traceSerialization.TraceWarning, "WARNING: Index " + i.ToString() + " could not be converted to int.  Type: " + (index == null ? "(null)" : index.GetType().Name));
                                    indexesOK = false;
                                    break;
                                }
                            }
                            
                            if (indexesOK) {
                                result = ((Array)array).GetValue(indexes);
                            }
                        }
                        break;
                    }
                    else if(result is CodeBaseReferenceExpression) {
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "BaseReference");
                        IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                        if (host != null) {
                            result = host.RootComponent;
                        }
                        else {
                            result = null;
                        }
                        break;
                    }
                    else if(result is CodeBinaryOperatorExpression) {
                        CodeBinaryOperatorExpression e = (CodeBinaryOperatorExpression)result;
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "BinaryOperator");
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Operator: " + e.Operator.ToString());
                        
                        object left = DeserializeExpression(manager, null, e.Left);
                        object right = DeserializeExpression(manager, null, e.Right);
                        
                        // We assign the result to an arbitrary value here in case the operation could
                        // not be performed.
                        //
                        result = left;
                        
                        if (left is IConvertible && right is IConvertible) {
                            result = ExecuteBinaryExpression((IConvertible)left, (IConvertible)right, e.Operator);
                        }
                        else {
                            Debug.WriteLineIf(traceSerialization.TraceWarning, "WARNING: Could not simplify left and right binary operators to IConvertible.");
                        }
                        break;
                    }
                    else if(result is CodeCastExpression) {
                        CodeCastExpression e = (CodeCastExpression)result;
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Cast");
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Type: " + e.TargetType.BaseType);
                        result = DeserializeExpression(manager, name, e.Expression);
                        if (result is IConvertible) {
                            Type targetType = manager.GetType(e.TargetType.BaseType);
                            if (targetType != null) {
                                result = ((IConvertible)result).ToType(targetType, null);
                            }
                        }
                        break;
                    }
                    else if(result is CodeDelegateInvokeExpression) {
                        CodeDelegateInvokeExpression e = (CodeDelegateInvokeExpression)result;
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "DelegateInvoke");
                        object targetObject = DeserializeExpression(manager, null, e.TargetObject);
                        if (targetObject is Delegate) {
                            object[] parameters = new object[e.Parameters.Count];
                            bool paramsOk = true;
                            for (int i = 0; i < parameters.Length; i++) {
                                parameters[i] = DeserializeExpression(manager, null, e.Parameters[i]);
                                if (parameters[i] is CodeExpression) {
                                    paramsOk = false;
                                    break;
                                }
                            }
                            
                            if (paramsOk) {
                                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Invoking " + targetObject.GetType().Name + " with " + parameters.Length.ToString() + " parameters.");
                                ((Delegate)targetObject).DynamicInvoke(parameters);
                            }
                        }
                        break;
                    }
                    else if(result is CodeDirectionExpression) {
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "CodeDirection");
                        result = DeserializeExpression(manager, name, ((CodeDirectionExpression)result).Expression);
                        break;
                    }
                    else if (result is CodeFieldReferenceExpression) {
                        CodeFieldReferenceExpression e = (CodeFieldReferenceExpression)result;
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "FieldReference");
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Name: " + e.FieldName);
                        object target = DeserializeExpression(manager, null, e.TargetObject);
                        if (target != null && !(target is CodeExpression)) {
                        
                            // If the target is the root object, then this won't be found
                            // through reflection.  Instead, ask the manager for the field
                            // by name.
                            //
                            IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                            if (host != null && host.RootComponent == target) {
                                object namedObject = manager.GetInstance(e.FieldName);
                                if (namedObject != null) {
                                    result = namedObject;
                                }
                                else {
                                    Debug.WriteLineIf(traceSerialization.TraceError, "*** Field " + e.FieldName + " could not be resolved");
                                    Error(manager, 
                                          SR.GetString(SR.SerializerUndeclaredName, e.FieldName),
                                          SR.SerializerUndeclaredName);
                                }
                            }
                            else {
                                FieldInfo field;
                                object instance;
                                 
                                if (target is Type) {
                                    instance = null;
                                    field = ((Type)target).GetField(e.FieldName,
                                        BindingFlags.GetField |
                                        BindingFlags.Static |
                                        BindingFlags.Public);
                                }
                                else {
                                    instance = target;
                                    field = target.GetType().GetField(e.FieldName,
                                        BindingFlags.GetField |
                                        BindingFlags.Instance |
                                        BindingFlags.Public);
                                }
                                if (field != null) {
                                    result = field.GetValue(instance);
                                }
                                else {
                                    Error(manager, 
                                          SR.GetString(SR.SerializerUndeclaredName, e.FieldName),
                                          SR.SerializerUndeclaredName);
                                }
                            }
                        }
                        else {
                            Error(manager, SR.GetString(SR.SerializerFieldTargetEvalFailed, e.FieldName),
                                  SR.SerializerFieldTargetEvalFailed);
                        }
                        Debug.WriteLineIf(traceSerialization.TraceWarning && result == e, "WARNING: Could not resolve field " + e.FieldName + " to an object instance.");
                        break;
                    }
                    else if(result is CodeIndexerExpression) {
                        CodeIndexerExpression e = (CodeIndexerExpression)result;
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Indexer");
                        
                        // For this, assume in any error we return a null.  The only errors
                        // here should come from a mal-formed expression.
                        //
                        result = null;
                        
                        object targetObject = DeserializeExpression(manager, null, e.TargetObject);
                        if (targetObject != null) {
                            object[] indexes = new object[e.Indices.Count];
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Indexes: " + indexes.Length.ToString());
                            bool indexesOK = true;
                    
                            for (int i = 0; i < indexes.Length; i++) {
                                indexes[i] =  DeserializeExpression(manager, null, e.Indices[i]);
                                if (indexes[i] is CodeExpression) {
                                    Debug.WriteLineIf(traceSerialization.TraceWarning, "WARNING: Index " + i.ToString() + " could not be simplified to an object.");
                                    indexesOK = false;
                                    break;
                                }
                            }
                            
                            if (indexesOK) {
                                result = targetObject.GetType().InvokeMember("Item",
                                    BindingFlags.GetProperty |
                                    BindingFlags.Public | 
                                    BindingFlags.Instance,
                                    null, targetObject, indexes);
                            }
                        }
                        break;
                    }
                    else if(result is CodeSnippetExpression) {
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Snippet");
                        result = null;
                        break;
                    }
                    else if(result is CodeMethodInvokeExpression) {
                        CodeMethodInvokeExpression e = (CodeMethodInvokeExpression)result;
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "MethodInvoke");
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "    name=" + e.Method.MethodName);
                        object targetObject = DeserializeExpression(manager, null, e.Method.TargetObject);
                        if (targetObject != null) {
                            object[] parameters = new object[e.Parameters.Count];
                            bool paramsOk = true;
                            
                            for (int i = 0; i < parameters.Length; i++) {
                                parameters[i] = DeserializeExpression(manager, null, e.Parameters[i]);
                                if (parameters[i] is CodeExpression) {
                                    paramsOk = false;
                                    break;
                                }
                            }
                            
                            if (paramsOk) {
                                if (targetObject is Type) {
                                    result = ((Type)targetObject).InvokeMember(e.Method.MethodName, 
                                        BindingFlags.InvokeMethod |
                                        BindingFlags.Public | 
                                        BindingFlags.Static,                                    
                                        null, null, parameters);
                                }
                                else {
                                    try {
                                        IComponentChangeService compChange = (IComponentChangeService)manager.GetService(typeof(IComponentChangeService));
                                        if (compChange != null) {
                                            compChange.OnComponentChanging(targetObject, null);
                                        }

                                        result = targetObject.GetType().InvokeMember(e.Method.MethodName, 
                                            BindingFlags.InvokeMethod |
                                            BindingFlags.Public | 
                                            BindingFlags.Instance,                                    
                                            null, targetObject, parameters);

                                        if (compChange != null) {                   
                                            compChange.OnComponentChanged(targetObject, null, null, null);
                                        }

                                    }
                                    catch(MissingMethodException) {
                                        // We did not find the method directly. Let's see if we can find it 
                                        // as an private implemented interface name.
                                        //
                                        CodeCastExpression castExpr = e.Method.TargetObject as CodeCastExpression;
                                        if (castExpr != null) {
                                            Type castType = manager.GetType(castExpr.TargetType.BaseType);

                                            if (castType != null && castType.IsInterface) {
                                                result = castType.InvokeMember(e.Method.MethodName, 
                                                    BindingFlags.InvokeMethod |
                                                    BindingFlags.NonPublic | 
                                                    BindingFlags.Public | 
                                                    BindingFlags.Instance,                                    
                                                    null, targetObject, parameters);
                                            }
                                            else {
                                                throw;
                                            }
                                        }
                                        else {
                                            throw;
                                        }
                                    }
                                }
                            }
                            else if (parameters.Length == 1 && parameters[0] is CodeDelegateCreateExpression) {
                                string methodName = e.Method.MethodName;
                                if (methodName.StartsWith("add_")) {
                                    methodName = methodName.Substring(4);
                                    DeserializeAttachEventStatement(manager, new CodeAttachEventStatement(e.Method.TargetObject, methodName, (CodeExpression)parameters[0]));
                                    result = null;
                                }
                            }
                        }
                        break;
                    }
                    else if(result is CodeObjectCreateExpression) {
                        CodeObjectCreateExpression e = (CodeObjectCreateExpression) result;
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "ObjectCreate");
                        
                        result = null;
                        
                        Type type = manager.GetType(e.CreateType.BaseType);
                        if (type != null) {
                            object[] parameters = new object[e.Parameters.Count];
                            bool paramsOk = true;
                            
                            for (int i = 0; i < parameters.Length; i++) {
                                parameters[i] = DeserializeExpression(manager, null, e.Parameters[i]);
                                if (parameters[i] is CodeExpression) {
                                    paramsOk = false;
                                    break;
                                }
                            }
                            
                            if (paramsOk) {
                                // Create an instance of the object.  If the caller provided a name,
                                // then ask the manager to add this object to the container.
                                result = manager.CreateInstance(type, parameters, name, (name != null));
                            }
                        }
                        break;
                    }
                    else if(result is CodeParameterDeclarationExpression) {
                        CodeParameterDeclarationExpression e = (CodeParameterDeclarationExpression)result;
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "ParameterDeclaration");
                        result = manager.GetType(e.Type.BaseType);
                        break;
                    }
                    else if(result is CodePrimitiveExpression) {
                        CodePrimitiveExpression e = (CodePrimitiveExpression)result;
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Primitive");
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Value: " + (e.Value == null ? "(null)" : e.Value.ToString()));
                        result = e.Value;
                        break;
                    }
                    else if (result is CodePropertyReferenceExpression) {
                        CodePropertyReferenceExpression e = (CodePropertyReferenceExpression)result;
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "PropertyReference");
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Name: " + e.PropertyName);
                        object target = DeserializeExpression(manager, null, e.TargetObject);
                        if (target != null && !(target is CodeExpression)) {
                            
                            // if it's a type, then we've got ourselves a static field...
                            //
                            if (!(target is Type)) {
                                PropertyDescriptor prop = TypeDescriptor.GetProperties(target)[e.PropertyName];
                                if (prop != null) {
                                    result = prop.GetValue(target);
                                }
                                else {
                                    // This could be a protected property on the base class.  Make sure we're 
                                    // actually accessing through the base class, and then get the property
                                    // directly from reflection.
                                    //
                                    IDesignerHost host = manager.GetService(typeof(IDesignerHost)) as IDesignerHost;
                                    if (host != null && host.RootComponent == target) {
                                        PropertyInfo propInfo = target.GetType().GetProperty(e.PropertyName, BindingFlags.GetProperty | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                                        if (propInfo != null) {
                                            result = propInfo.GetValue(target, null);
                                        }
                                    }
                                }
                            }
                            else {
                                PropertyInfo prop = ((Type)target).GetProperty(e.PropertyName, BindingFlags.GetProperty | BindingFlags.Static | BindingFlags.Public);
                                if (prop != null) {
                                    result = prop.GetValue(null, null);
                                }
                            }
                        }
                        Debug.WriteLineIf(traceSerialization.TraceWarning && result == e, "WARNING: Could not resolve property " + e.PropertyName + " to an object instance.");
                        break;
                    }
                    else if(result is CodeThisReferenceExpression) {
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "ThisReference");
                        IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                        if (host != null) {
                            result = host.RootComponent;
                        }
                        else {
                            result = null;
                        }
                        break;
                    }
                    else if(result is CodeTypeOfExpression) {
                        CodeTypeOfExpression e = (CodeTypeOfExpression)result;
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "TypeOf");
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Type: " + e.Type.BaseType);
                        string type = e.Type.BaseType;

                        // add the array ranks so we get the right type of this thing.
                        //
                        for (int i = 0; i < e.Type.ArrayRank; i++) {
                            type += "[]";
                        }
                        result = manager.GetType(type);
                        break;
                    }
                    else if(result is CodeTypeReferenceExpression) {
                        CodeTypeReferenceExpression e = (CodeTypeReferenceExpression)result;
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "TypeReference");
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Type: " + e.Type.BaseType);
                        result = manager.GetType(e.Type.BaseType);
                        break;
                    }
                    else if(result is CodeVariableReferenceExpression) {
                        CodeVariableReferenceExpression e = (CodeVariableReferenceExpression)result;
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "VariableReference");
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Name: " + e.VariableName);
                        result = manager.GetInstance(e.VariableName);
                        if (result == null) {
                            Debug.WriteLineIf(traceSerialization.TraceError, "*** Variable " + e.VariableName + " does not exist ***");
                            Error(manager,
                                  SR.GetString(SR.SerializerUndeclaredName, e.VariableName),
                                  SR.SerializerUndeclaredName);
                        }
                        break;
                    }
                    else if(result is CodeEventReferenceExpression ||
                            result is CodeMethodReferenceExpression ||
                            result is CodeDelegateCreateExpression) {
                            
                        // These are all the expressions we know about, but
                        // expect to return to the caller because we cannot
                        // simplify them.
                        //
                        break;
                    }
                    else {
                        // All expression evaluation happens above.  This codepath
                        // indicates that we got some sort of junk in the evalualtor, 
                        // or that someone assigned result to a value without
                        // breaking out of the loop.
                        //
                        Debug.Fail("Unrecognized expression type: " + result.GetType().Name);
                        break;
                    }
                    
                }
            }
            finally {
                Debug.Unindent();
            }
            
            return result;
        }
        
        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.DeserializeVariableDeclarationStatement"]/*' />
        /// <devdoc>
        ///     Deserializes a variable declaration by deserializing the target object of the variable and providing a name.
        /// </devdoc>
        private void DeserializeVariableDeclarationStatement(IDesignerSerializationManager manager, CodeVariableDeclarationStatement statement) {
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "CodeDomSerializer::DeserializeVariableDeclarationStatement");
            Debug.Indent();
            
            if (statement.InitExpression != null) {
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Variable " + statement.Name + " contains init expression.");
                object varObject = DeserializeExpression(manager, statement.Name, statement.InitExpression);
            }
            
            Debug.Unindent();
        }
        
        /// <devdoc>
        ///     This creates a new exception object with the given string.  It attempts to discover the 
        ///     current statement, and if it can find one, will create a CodeDomserializerException that
        ///     contains the correct file / line number information.  After creating the exception, it
        ///     throws it.
        /// </devdoc>
        /// <param name='manager'>
        ///     Used to look into the context stack for a statement we can use to determine the line number.
        /// </param>
        /// <param name='exceptionText'>
        ///     The localized exception text information.
        /// </param>
        /// <param name='resourceKey'>
        ///     The name of the resource key for this exception text.  This is used to fill in the help topic
        ///     value of the exception.
        /// </param>
        private void Error(IDesignerSerializationManager manager, string exceptionText, string resourceKey) {

            // v.next: this should be protected, not private.

            Exception exception;

            CodeStatement statement = (CodeStatement)manager.Context[typeof(CodeStatement)];
            CodeLinePragma linePragma = null;

            if (statement != null) {
                linePragma = statement.LinePragma;
            }

            exception = new CodeDomSerializerException(exceptionText, linePragma);
            exception.HelpLink = resourceKey;

            throw exception;
        }

        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.ExecuteBinaryExpression"]/*' />
        /// <devdoc>
        ///     Executes the given binary expression.  If at any stage of the game the expression execution fails,
        ///     this just returns the default value for the datatype required by the operator.  Boolean == false,
        ///     for example.
        /// </devdoc>
        private object ExecuteBinaryExpression(IConvertible left, IConvertible right, CodeBinaryOperatorType op) {
        
            // "Binary" operator type is actually a combination of several types of operators: boolean, binary
            //  and math.  Group them into categories here.
            //
            CodeBinaryOperatorType[] booleanOperators = new CodeBinaryOperatorType[] {
                CodeBinaryOperatorType.IdentityInequality,
                CodeBinaryOperatorType.IdentityEquality,
                CodeBinaryOperatorType.ValueEquality,
                CodeBinaryOperatorType.BooleanOr,
                CodeBinaryOperatorType.BooleanAnd,
                CodeBinaryOperatorType.LessThan,
                CodeBinaryOperatorType.LessThanOrEqual,
                CodeBinaryOperatorType.GreaterThan,
                CodeBinaryOperatorType.GreaterThanOrEqual
            };
                
            CodeBinaryOperatorType[] mathOperators = new CodeBinaryOperatorType[] {
                CodeBinaryOperatorType.Add,
                CodeBinaryOperatorType.Subtract,
                CodeBinaryOperatorType.Multiply,
                CodeBinaryOperatorType.Divide,
                CodeBinaryOperatorType.Modulus
            };
            
            CodeBinaryOperatorType[] binaryOperators = new CodeBinaryOperatorType[] {
                CodeBinaryOperatorType.BitwiseOr,
                CodeBinaryOperatorType.BitwiseAnd
            };
            
            // Figure out what kind of expression we have.
            //
            for (int i = 0; i < binaryOperators.Length; i++) {
                if (op == binaryOperators[i]) {
                    return ExecuteBinaryOperator(left, right, op);
                }
            }
            for (int i = 0; i < mathOperators.Length; i++) {
                if (op == mathOperators[i]) {
                    return ExecuteMathOperator(left, right, op);
                }
            }
            for (int i = 0; i < booleanOperators.Length; i++) {
                if (op == booleanOperators[i]) {
                    return ExecuteBooleanOperator(left, right, op);
                }
            }
            
            Debug.Fail("Unsupported binary operator type: " + op.ToString());
            return left;
        }

        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.ExecuteBinaryOperator"]/*' />
        /// <devdoc>
        ///     Executes the given binary operator.  If at any stage of the game the expression execution fails,
        ///     this just returns the left hand side.
        ///     for example.
        /// </devdoc>
        private object ExecuteBinaryOperator(IConvertible left, IConvertible right, CodeBinaryOperatorType op) {
            TypeCode leftType = left.GetTypeCode();
            TypeCode rightType = right.GetTypeCode();
            
            // The compatible types are listed in order from lowest bitness to highest.  We must
            // operate on the highest bitness to keep fidelity.
            //
            TypeCode[] compatibleTypes = new TypeCode[] {
                TypeCode.Byte, 
                TypeCode.Char, 
                TypeCode.Int16, 
                TypeCode.UInt16,
                TypeCode.Int32,
                TypeCode.UInt32,
                TypeCode.Int64,
                TypeCode.UInt64};
                
            int leftTypeIndex = -1;
            int rightTypeIndex = -1;
            
            for(int i = 0; i < compatibleTypes.Length; i++) {
                if (leftType == compatibleTypes[i]) {
                    leftTypeIndex = i;
                }
                if (rightType == compatibleTypes[i]) {
                    rightTypeIndex = i;
                }
                if (leftTypeIndex != -1 && rightTypeIndex != -1) {
                    break;
                }
            }
            
            if (leftTypeIndex == -1 || rightTypeIndex == -1) {
                Debug.Fail("Could not convert left or right side to binary-compatible value.");
                return left;
            }
            
            int maxIndex = Math.Max(leftTypeIndex, rightTypeIndex);
            object result = left;
            
            switch(compatibleTypes[maxIndex]) {
                case TypeCode.Byte: {
                    byte leftValue = left.ToByte(null);
                    byte rightValue = right.ToByte(null);
                    
                    if (op == CodeBinaryOperatorType.BitwiseOr) {
                        result = leftValue | rightValue;
                    }
                    else {
                        result = leftValue & rightValue;
                    }
                    break;
                }
                case TypeCode.Char: {
                    char leftValue = left.ToChar(null);
                    char rightValue = right.ToChar(null);
                    
                    if (op == CodeBinaryOperatorType.BitwiseOr) {
                        result = leftValue | rightValue;
                    }
                    else {
                        result = leftValue & rightValue;
                    }
                    break;
                }
                case TypeCode.Int16: {
                    short leftValue = left.ToInt16(null);
                    short rightValue = right.ToInt16(null);
                    
                    if (op == CodeBinaryOperatorType.BitwiseOr) {
                        result = (short)((ushort)leftValue | (ushort)rightValue);
                    }
                    else {
                        result = leftValue & rightValue;
                    }
                    break;
                }
                case TypeCode.UInt16: {
                    ushort leftValue = left.ToUInt16(null);
                    ushort rightValue = right.ToUInt16(null);
                    
                    if (op == CodeBinaryOperatorType.BitwiseOr) {
                        result = leftValue | rightValue;
                    }
                    else {
                        result = leftValue & rightValue;
                    }
                    break;
                }
                case TypeCode.Int32: {
                    int leftValue = left.ToInt32(null);
                    int rightValue = right.ToInt32(null);
                    
                    if (op == CodeBinaryOperatorType.BitwiseOr) {
                        result = leftValue | rightValue;
                    }
                    else {
                        result = leftValue & rightValue;
                    }
                    break;
                }
                case TypeCode.UInt32: {
                    uint leftValue = left.ToUInt32(null);
                    uint rightValue = right.ToUInt32(null);
                    
                    if (op == CodeBinaryOperatorType.BitwiseOr) {
                        result = leftValue | rightValue;
                    }
                    else {
                        result = leftValue & rightValue;
                    }
                    break;
                }
                case TypeCode.Int64: {
                    long leftValue = left.ToInt64(null);
                    long rightValue = right.ToInt64(null);
                    
                    if (op == CodeBinaryOperatorType.BitwiseOr) {
                        result = leftValue | rightValue;
                    }
                    else {
                        result = leftValue & rightValue;
                    }
                    break;
                }
                case TypeCode.UInt64: {
                    ulong leftValue = left.ToUInt64(null);
                    ulong rightValue = right.ToUInt64(null);
                    
                    if (op == CodeBinaryOperatorType.BitwiseOr) {
                        result = leftValue | rightValue;
                    }
                    else {
                        result = leftValue & rightValue;
                    }
                    break;
                }
            }
            
            if (result != left && left is Enum) {
                // For enums, try to convert back to the original type
                //
                result = Enum.ToObject(left.GetType(), result);
            }
            return result;
        }
            
        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.ExecuteBooleanOperator"]/*' />
        /// <devdoc>
        ///     Executes the given boolean operator.  If at any stage of the game the expression execution fails,
        ///     this just returns false.
        ///     for example.
        /// </devdoc>
        private object ExecuteBooleanOperator(IConvertible left, IConvertible right, CodeBinaryOperatorType op) {
            bool result = false;
            
            switch(op) {
                case CodeBinaryOperatorType.IdentityInequality:
                    result = (left != right);
                    break;
                case CodeBinaryOperatorType.IdentityEquality:
                    result = (left == right);
                    break;
                case CodeBinaryOperatorType.ValueEquality:
                    result = left.Equals(right);
                    break;
                case CodeBinaryOperatorType.BooleanOr:
                    result = (left.ToBoolean(null) || right.ToBoolean(null));
                    break;
                case CodeBinaryOperatorType.BooleanAnd:
                    result = (left.ToBoolean(null) && right.ToBoolean(null));
                    break;
                case CodeBinaryOperatorType.LessThan:
                    // Not doing these at design time.
                    break;
                case CodeBinaryOperatorType.LessThanOrEqual:
                    // Not doing these at design time.
                    break;
                case CodeBinaryOperatorType.GreaterThan:
                    // Not doing these at design time.
                    break;
                case CodeBinaryOperatorType.GreaterThanOrEqual:
                    // Not doing these at design time.
                    break;
                default:
                    Debug.Fail("Should never get here!");
		    break;
            }
            
            return result;
        }
            
        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.ExecuteMathOperator"]/*' />
        /// <devdoc>
        ///     Executes the given math operator.  If at any stage of the game the expression execution fails,
        ///     this just returns the left hand side.
        ///     for example.
        /// </devdoc>
        private object ExecuteMathOperator(IConvertible left, IConvertible right, CodeBinaryOperatorType op) {
            
            switch(op) {
                case CodeBinaryOperatorType.Add:
                    string leftString = left as string;
                    string rightString = right as string;

                    if (leftString == null && left is Char) {
                        leftString = left.ToString();
                    }

                    if (rightString == null && right is Char) {
                        rightString = right.ToString();
                    }

                    if (leftString != null && rightString != null) {
                        return leftString + rightString;
                    }
                    else {
                        Debug.Fail("Addition operator not supported for this type");
                        return left;
                    }
                default:
                    Debug.Fail("Math operators are not supported");
                    return left;
            }
        }

        private PropertyDescriptorCollection GetFilteredProperties(IDesignerSerializationManager manager, object value, Attribute[] filter) {

            IComponent comp = value as IComponent;
            
            PropertyDescriptorCollection props = TypeDescriptor.GetProperties(value, filter);
            if (comp != null) {

                if (((IDictionary)props).IsReadOnly) {
                    PropertyDescriptor[] propArray = new PropertyDescriptor[props.Count];
                    props.CopyTo(propArray, 0);
                    props = new PropertyDescriptorCollection(propArray);
                }

                PropertyDescriptor filterProp = manager.Properties["FilteredProperties"];
                
                if (filterProp != null) {
                    ITypeDescriptorFilterService filterSvc = filterProp.GetValue(manager) as ITypeDescriptorFilterService;
                    if (filterSvc != null) {
                        filterSvc.FilterProperties(comp, props);
                    }
                }
            }
            return props;
        }
        
        /// <devdoc>
        ///     This retrieves the value of this property.  If the property returns false
        ///     from ShouldSerializeValue (indicating the ambient value for this property)
        ///     This will look for an AmbientValueAttribute and use it if it can.
        /// </devdoc>
        private object GetPropertyValue(PropertyDescriptor property, object value) {
                                 
            if (!property.ShouldSerializeValue(value)) {
            
                // We aren't supposed to be serializing this property, but we decided to do 
                // it anyway.  Check the property for an AmbientValue attribute and if we
                // find one, use it's value to serialize.
                //
                AmbientValueAttribute attr = (AmbientValueAttribute)property.Attributes[typeof(AmbientValueAttribute)];
                if (attr != null) {
                    return attr.Value;
                }
            }
            
            return property.GetValue(value);
        }
        
        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.Serialize"]/*' />
        /// <devdoc>
        ///     Serializes the given object into a CodeDom object.
        /// </devdoc>
        public abstract object Serialize(IDesignerSerializationManager manager, object value);
    
        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.SerializeEvents"]/*' />
        /// <devdoc>
        ///     This serializes all events for the given object.
        /// </devdoc>
        protected void SerializeEvents(IDesignerSerializationManager manager, CodeStatementCollection statements, object value, Attribute[] filter) {
        
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "CodeDomSerializer::SerializeEvents");
            Debug.Indent();
            
            IEventBindingService eventBindings = (IEventBindingService)manager.GetService(typeof(IEventBindingService));
            if (eventBindings == null) {
                Error(manager,
                      SR.GetString(SR.SerializerMissingService, typeof(IEventBindingService).Name),
                      SR.SerializerMissingService);
            }
            
            // Now walk the events.
            //
            CodeThisReferenceExpression thisRef = new CodeThisReferenceExpression();
            CodeExpression eventTarget = SerializeToReferenceExpression(manager, value);
            
            Debug.WriteLineIf(traceSerialization.TraceWarning && eventTarget == null, "WARNING: Object has no name and no propery ref in context so we cannot serialize events: " + value.ToString());
            
            if (eventTarget != null) {
                EventDescriptorCollection events = TypeDescriptor.GetEvents(value, filter).Sort();
                
                manager.Context.Push(statements);

                try {
                    foreach(EventDescriptor evt in events) {
                        PropertyDescriptor prop = eventBindings.GetEventProperty(evt);
                        
                        string methodName = (string)prop.GetValue(value);
                        if (methodName != null) {
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Event " + evt.Name + " bound to " + methodName);
                            
                            CodeTypeReference delegateTypeRef = new CodeTypeReference(evt.EventType);
                            
                            CodeDelegateCreateExpression delegateCreate = new CodeDelegateCreateExpression(
                                delegateTypeRef,
                                thisRef,
                                methodName);
                                
                            
                            CodeEventReferenceExpression eventRef = new CodeEventReferenceExpression(
                                eventTarget,
                                evt.Name);
                                
                            CodeAttachEventStatement attach = new CodeAttachEventStatement(
                                eventRef,
                                delegateCreate);

                            attach.UserData[typeof(Delegate)] = evt.EventType;
                                
                            statements.Add(attach);
                        }
                    }
                }
                finally {
                    Debug.Assert(manager.Context.Current == statements, "Somebody messed up our context stack.");
                    manager.Context.Pop();
                }
            }
        
            Debug.Unindent();
        }
        
        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.SerializeProperties"]/*' />
        /// <devdoc>
        ///     This serializes all properties for the given object, using the provided filter.
        /// </devdoc>
        protected void SerializeProperties(IDesignerSerializationManager manager, CodeStatementCollection statements, object value, Attribute[] filter) {
        
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "CodeDomSerializer::SerializeProperties");
            Debug.Indent();
            
            // Now walk the properties.
            //
            PropertyDescriptorCollection properties = GetFilteredProperties(manager, value, filter).Sort();
            
            manager.Context.Push(statements);
            
            // Check to see if we are in localization mode.  If so, push this data on the context stack for future
            // reference (possibly)
            //
            LocalizableAttribute localizable = LocalizableAttribute.No;
            
            IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
            if (host != null) {
                PropertyDescriptor prop = TypeDescriptor.GetProperties(host.RootComponent)["Localizable"];
                if (prop != null && prop.PropertyType == typeof(bool) && ((bool)prop.GetValue(host.RootComponent))) {
                    localizable = LocalizableAttribute.Yes;
                }
            }

            // Check to see if this object is being inherited. Inherited objects are treated differently because
            // we never want to write all their properties, even if we're in localization mode.
            //
            bool notInherited = TypeDescriptor.GetAttributes(value).Contains(InheritanceAttribute.NotInherited);
            
            manager.Context.Push(localizable);
            
            try {
                foreach(PropertyDescriptor property in properties) {

                    try { 
                        bool serializeContents = property.Attributes.Contains(DesignerSerializationVisibilityAttribute.Content);
                        bool serializeProperty = (!property.Attributes.Contains(DesignerSerializationVisibilityAttribute.Hidden));
                        bool shouldSerializeProperty = property.ShouldSerializeValue(value);
                        bool isDesignTime = property.Attributes.Contains(DesignOnlyAttribute.Yes);
                        
                        #if NEW_LOC_MODEL
                        
                        // If this property contains its default value, we still want to serialize it if we are in
                        // localization mode if we are writing the non-default culture.  Let the resource serializer
                        // determine if the value matches the parent culture value, and only write it out if it
                        // doesn't.
                        //
                        if (!shouldSerializeProperty 
                            && host != null
                            && localizable.IsLocalizable 
                            && property.Attributes.Contains(LocalizableAttribute.Yes)) {

                            PropertyDescriptor langProp = TypeDescriptor.GetProperties(host.RootComponent)["LoadLanguage"];
                            if (langProp != null && langProp.PropertyType == typeof(CultureInfo)) {
                                if (!langProp.GetValue(host.RootComponent).Equals(CultureInfo.InvariantCulture)) {
                                    shouldSerializeProperty = true;
                                }
                            }
                        }

                        #else
                        
                        // If this property contains its default value, we still want to serialize it if we are in
                        // localization mode if we are writing to the default culture.
                        //
                        if (!shouldSerializeProperty 
                            && localizable.IsLocalizable 
                            && notInherited
                            && property.Attributes.Contains(LocalizableAttribute.Yes)) {
                            
                            shouldSerializeProperty = true;
                        }

                        #endif
                        
                        // Merge these.  Now ShouldSerialize dictates if we will write out the property.
                        //
                        serializeProperty &= shouldSerializeProperty;
                        
                        // Skip this property if there is no need to serialize it.
                        //
                        if (isDesignTime || !serializeProperty) {
                            continue;
                        } 
                        
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Serializing property " + property.Name);
                        manager.Context.Push(property);
                        try {
                        
                            // Check to see if this is a property marked with "PersistContents".  If
                            // it is, then recurse into the property's object, rather than serializing
                            // the property.
                            //
                            if (serializeContents) {
                                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Property is marked as PersistContents.  Recursing.");
                                object propertyValue = GetPropertyValue(property, value);
                                
                                // For persist contents objects, we don't just serialize the properties on the object; we
                                // serialize everything.
                                //
                                CodeDomSerializer serializer = null;
                                
                                if (propertyValue == null) {
                                    Debug.WriteLineIf(traceSerialization.TraceError, "*** Property " + property.Name + " is marked as PersistContents but it is returning null. ***");
                                    string name = manager.GetName(value);
                                    if (name == null) {
                                        name = value.GetType().FullName;
                                    }
                                    manager.ReportError(SR.GetString(SR.SerializerNullNestedProperty, name, property.Name));
                                }
                                else {
                                    serializer = (CodeDomSerializer)manager.GetSerializer(propertyValue.GetType(), typeof(CodeDomSerializer));
                                    
                                    if (serializer != null) {
                                    
                                        // Create a property reference expression and push it on the context stack.
                                        // This allows the serializer to gain some context as to what it should be
                                        // serializing.
                                        //
                                        CodeExpression target = SerializeToReferenceExpression(manager, value);
                                        if (target == null) {
                                            Debug.WriteLineIf(traceSerialization.TraceWarning, "WARNING: Unable to convert value to expression object");
                                            continue;
                                        }
                                        CodePropertyReferenceExpression propertyRef = new CodePropertyReferenceExpression(target, property.Name);
                                        CodeValueExpression codeValue = new CodeValueExpression(propertyRef, propertyValue);
                                        manager.Context.Push(codeValue);
                                        
                                        object result = null;
                                        
                                        try {
                                            result = serializer.Serialize(manager, propertyValue);
                                        }
                                        finally {
                                            Debug.Assert(manager.Context.Current == codeValue, "Serializer added a context it didn't remove.");
                                            manager.Context.Pop();
                                        }
        
                                        if (result is CodeStatementCollection) {
                                            foreach(CodeStatement statement in (CodeStatementCollection)result) {
                                                statements.Add(statement);
                                            }
                                        }
                                        else if (result is CodeStatement) {
                                            statements.Add((CodeStatement)result);
                                        }
                                    }
                                    else {
                                        Debug.WriteLineIf(traceSerialization.TraceError, "*** Property " + property.Name + " is marked as PersistContents but there is no serializer for it. ***");
                                        manager.ReportError(SR.GetString(SR.SerializerNoSerializerForComponent, property.PropertyType.FullName));
                                    }
                                }
                            }
                            else {
                                SerializeProperty(manager, statements, value, property);
                            }
                        }
                        finally {
                            Debug.Assert(manager.Context.Current == property, "Context stack corrupted.");
                            manager.Context.Pop();
                        }
                    }   
                    catch (Exception e) {
                        // Since we usually go through reflection, don't 
                        // show what our engine does, show what caused 
                        // the problem.
                        //
                        if (e is TargetInvocationException) {
                            e = e.InnerException;
                        }
                        manager.ReportError(SR.GetString(SR.SerializerPropertyGenFailed, property.Name, e.Message));
                    }
                }
            }
            finally {
                Debug.Assert(manager.Context.Current == localizable, "Somebody messed up our context stack.");
                manager.Context.Pop();
                manager.Context.Pop();
            }
        
            Debug.Unindent();
        }
        
        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.SerializePropertiesToResources"]/*' />
        /// <devdoc>
        ///     This method will inspect all of the properties on the given object fitting the filter, and check for that
        ///     property in a resource blob.  This is useful for deserializing properties that cannot be represented
        ///     in code, such as design-time properties. 
        /// </devdoc>
        protected void SerializePropertiesToResources(IDesignerSerializationManager manager, CodeStatementCollection statements, object value, Attribute[] filter) {
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "ComponentCodeDomSerializer::SerializePropertiesToResources");
            Debug.Indent();
            PropertyDescriptorCollection props = TypeDescriptor.GetProperties(value, filter); 
            
            CodeExpression target = SerializeToReferenceExpression(manager, value);
            
            if (target != null) {
            
                CodePropertyReferenceExpression propertyRef = new CodePropertyReferenceExpression(target, string.Empty);
                CodeValueExpression codeValue = new CodeValueExpression(propertyRef, value);
                manager.Context.Push(statements);
                manager.Context.Push(codeValue);
            
                try {
                    foreach(PropertyDescriptor property in props) {
                        Debug.WriteLineIf(traceSerialization.TraceWarning && property.Attributes.Contains(DesignerSerializationVisibilityAttribute.Content), "WARNING: PersistContents property " + property.Name + " cannot be serialized to resources.");
                        if (property.Attributes.Contains(DesignerSerializationVisibilityAttribute.Visible)) {
                            propertyRef.PropertyName = property.Name;
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Property: " + property.Name);
                            ResourceCodeDomSerializer.Default.SerializeInvariant(manager, property.GetValue(value), property.ShouldSerializeValue(value));
                        }
                    }
                }
                finally {
                    Debug.Assert(manager.Context.Current == codeValue, "Context stack corrupted.");
                    manager.Context.Pop();
                    manager.Context.Pop();
                }
            }
            
            Debug.Unindent();
        }
        
        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.SerializeProperty"]/*' />
        /// <devdoc>
        ///     This serializes the given property on this object.
        /// </devdoc>
        private void SerializeProperty(IDesignerSerializationManager manager, CodeStatementCollection statements, object value, PropertyDescriptor property) {
            
            AttributeCollection attributes = property.Attributes;
            
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "CodeDomSerializer::SerializeProperty");
            Debug.Indent();
            
            // There are three types of properties we will serialize:
            //      Design Time properties
            //      Runtime properties
            //      extender propeties.
            
            ExtenderProvidedPropertyAttribute exAttr = (ExtenderProvidedPropertyAttribute)attributes[typeof(ExtenderProvidedPropertyAttribute)];
            bool isExtender = (exAttr != null && exAttr.Provider != null);
            bool isDesignTime = attributes.Contains(DesignOnlyAttribute.Yes);
            
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Extender: " + isExtender.ToString());
            Debug.WriteLineIf(traceSerialization.TraceWarning && isDesignTime, "WARNING: Skipping design time property " + property.Name + ".  Is your filter correct?");
            
            if (!isDesignTime) {
                // Extender properties are method invokes on a target "extender" object.
                //
                if (isExtender) {
                    
                    CodeExpression extender = SerializeToReferenceExpression(manager, exAttr.Provider);
                    CodeExpression extendee = SerializeToReferenceExpression(manager, value);
    
                    Debug.WriteLineIf(traceSerialization.TraceWarning && extender == null, "WARNING: Extender object " + manager.GetName(exAttr.Provider) + " could not be serialized.");
                    Debug.WriteLineIf(traceSerialization.TraceWarning && extendee == null, "WARNING: Extendee object " + manager.GetName(value) + " could not be serialized.");
                    
                    if (extender != null && extendee != null) {
                        CodeMethodReferenceExpression methodRef = new CodeMethodReferenceExpression(
                            extender,
                            "Set" + property.Name);
                            
                        // Serialize the value of this property into a code expression.  If we can't get one,
                        // then we won't serialize the property.
                        //
                        CodeValueExpression codeValue = new CodeValueExpression(methodRef, value, property.PropertyType);
                        manager.Context.Push(codeValue);
                        
                        CodeExpression serializedPropertyValue = null;
                        
                        try {
                            serializedPropertyValue = SerializeToExpression(manager, GetPropertyValue(property, value));
                        }
                        finally {
                            Debug.Assert(manager.Context.Current == codeValue, "Context stack corrupted.");
                            manager.Context.Pop();
                        }
                        
                        if (serializedPropertyValue != null) {
                            CodeMethodInvokeExpression methodInvoke = new CodeMethodInvokeExpression();
                            methodInvoke.Method = methodRef;
                            methodInvoke.Parameters.Add(extendee);
                            methodInvoke.Parameters.Add(serializedPropertyValue);
                            statements.Add(methodInvoke);
                        }
                        else {
                            Debug.WriteLineIf(traceSerialization.TraceError, "*** Property " + property.Name + " cannot be serialized because it has no serializer.");
                            manager.ReportError(SR.GetString(SR.SerializerNoSerializerForComponent, property.PropertyType.FullName));
                        }
                    }
                }
                else {
                    CodeExpression target = SerializeToReferenceExpression(manager, value);
                    Debug.WriteLineIf(traceSerialization.TraceWarning && target == null, "WARNING: Unable to serialize target for property " + property.Name);

                    if (target != null) {
                        CodeExpression propertyRef = new CodePropertyReferenceExpression(target, property.Name);

                        // Serialize the value of this property into a code expression.  If we can't get one,
                        // then we won't serialize the property.
                        //
                        object propValue = GetPropertyValue(property, value);
                        CodeValueExpression codeValue = null;
                        if (propValue != value) {
                            // ASURT 68960
                            // make sure the value isn't the object or we'll end up printing
                            // this property instead of the value.
                            //
                            codeValue = new CodeValueExpression(propertyRef, value, property.PropertyType);
                            manager.Context.Push(codeValue);
                        }

                        CodeExpression serializedPropertyValue = null;

                        try {
                            serializedPropertyValue = SerializeToExpression(manager, propValue);
                        }
                        finally {
                            if (propValue != value) {
                                Debug.Assert(manager.Context.Current == codeValue, "Context stack corrupted.");
                                manager.Context.Pop();
                            }
                        }

                        Debug.WriteLineIf(traceSerialization.TraceError && serializedPropertyValue == null, "*** Property " + property.Name + " cannot be serialized because it has no serializer.");
                        if (serializedPropertyValue != null) {
                            CodeAssignStatement assign = new CodeAssignStatement(propertyRef, serializedPropertyValue);
                            statements.Add(assign);
                        }
                    }
                }
            }
        
            Debug.Unindent();
        }

        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.SerializeResource"]/*' />
        /// <devdoc>
        ///     Writes the given resource value under the given name.  The resource is written to the
        ///     current CultureInfo the user is using to design with.
        /// </devdoc>
        protected void SerializeResource(IDesignerSerializationManager manager, string resourceName, object value) {
            ResourceCodeDomSerializer.Default.WriteResource(manager, resourceName, value);
        }
        
        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.SerializeResourceInvariant"]/*' />
        /// <devdoc>
        ///     Writes the given resource value under the given name.  The resource is written to the
        ///     invariant culture.
        /// </devdoc>
        protected void SerializeResourceInvariant(IDesignerSerializationManager manager, string resourceName, object value) {
            ResourceCodeDomSerializer.Default.WriteResourceInvariant(manager, resourceName, value);
        }
        
        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.SerializeToExpression"]/*' />
        /// <devdoc>
        ///     This serializes the given value to an expression.  It will return null if the value could not be
        ///     serialized.
        /// </devdoc>
        protected CodeExpression SerializeToExpression(IDesignerSerializationManager manager, object value) {
            CodeExpression expression = null;
            
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "CodeDomSerializer::SerializeToExpression");
            Debug.Indent();
            
            // We do several things here:
            //
            //      First, we peek the context stack to see if it has a CodeValueExpression
            //      that contains our object.  If it does, then we just return it, as this is the expression someone
            //      has requested we use.  
            //
            //      Next, we check for a named IComponent, and return a reference to it.
            //
            //      Third, we check the designer host to see if there is "Localization" property on the
            //      root component that is set to true.  If so, we look on the context stack for
            //      a PropertyDescriptor, and check to see if this property is markes as localizable.
            //      If it is, we use the resource serializer to perform the serialization.
            //
            //      Fourth, we serialize the object using the object's serializer.  If this serializer
            //      returned a CodeExpression, we return it.
            //
            //      Finally, if the object's serializer failed, and if the object is serializable, we
            //      invoke the resource serializer to serialize the object.
            
            // The first two attempts are handled by SerializeToReferenceExpression
            //
            expression = SerializeToReferenceExpression(manager, value);
            
            // Check for a localizable property, and use it.  If it fails, resort to the default
            // serializer.
            
            if (expression == null) {
                CodeDomSerializer serializer = null;

                // for serializing null, we pass null to the serialization manager
                // otherwise, external IDesignerSerializationProviders wouldn't be given a chance to 
                // serialize null their own special way.
                //
                Type t;
                if (value == null) {
                    t = null;
                }
                else {
                    t = value.GetType();
                }

                // Check for a localizable property on the context stack.  If we have one, also check
                // to see if we are in localization mode, and finally, if everything matches, we will
                // add a marker onto the context stack that the root serializer will use to interpret
                // that it should provide a resource-based serializer for us.  This extra indirection
                // is necessary so that other serialization providers can override our usage of
                // a resource serializer.
                //
                bool useResourceSerializer = false;
                PropertyDescriptor prop = (PropertyDescriptor)manager.Context[typeof(PropertyDescriptor)];
                if (prop != null && prop.Attributes.Contains(LocalizableAttribute.Yes)) {

                    // Check to see if a LocalizableAttribute is in the context stack.  If so, we
                    // use this to drive our localization decision.  If not, then we defer to
                    // sifting through the root component's properties, which is slower (but has
                    // no dependency on other callers).
                    //
                    LocalizableAttribute localizable = (LocalizableAttribute)manager.Context[typeof(LocalizableAttribute)];

                    if (localizable == null) {

                        // this is quite a bit more expensive, but allows us to be stateless.
                        //
                        IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                        if (host != null) {
                            prop = TypeDescriptor.GetProperties(host.RootComponent)["Localizable"];
                            if (prop != null && prop.PropertyType == typeof(bool) && ((bool)prop.GetValue(host.RootComponent))) {
                                localizable = LocalizableAttribute.Yes;
                            }
                        }
                    }

                    if (localizable.IsLocalizable) {
                        useResourceSerializer = true;
                    }
                }

                if (useResourceSerializer) {
                    manager.Context.Push(ResourceCodeDomSerializer.Default);
                    try {
                        serializer = (CodeDomSerializer)manager.GetSerializer(t, typeof(CodeDomSerializer));
                    }
                    finally {
                        Debug.Assert(manager.Context.Current == ResourceCodeDomSerializer.Default, "Someone corrupted the context stack");
                        manager.Context.Pop();
                    }
                }
                else {
                    serializer = (CodeDomSerializer)manager.GetSerializer(t, typeof(CodeDomSerializer));
                }

                // If we were unable to locate an appropriate serializer, and the object is serializable,
                // save it into resources.
                //
                if (serializer == null && value != null && value.GetType().IsSerializable) {
                    serializer = ResourceCodeDomSerializer.Default;
                }
                
                if (serializer != null) {
                    Debug.WriteLineIf(traceSerialization.TraceVerbose, "Using serializer " + serializer.GetType().Name);
                    expression = serializer.Serialize(manager, value) as CodeExpression;
                }
                else {
                    Debug.WriteLineIf(traceSerialization.TraceError, "*** No serializer for data type: " + value.GetType().Name);
                    manager.ReportError(SR.GetString(SR.SerializerNoSerializerForComponent, value.GetType().FullName));
                }
            }
            
            Debug.Unindent();
            return expression;
        }
    
        /// <include file='doc\CodeDomSerializer.uex' path='docs/doc[@for="CodeDomSerializer.SerializeToReferenceExpression"]/*' />
        /// <devdoc>
        ///     This serializes the given value to an expression.  It will return null if the value could not be
        ///     serialized.  This is similar to SerializeToExpression, except that it will stop
        ///     if it cannot obtain a simple reference expression for the value.  Call this method
        ///     when you expect the resulting expression to be used as a parameter or target
        ///     of a statement.
        /// </devdoc>
        protected CodeExpression SerializeToReferenceExpression(IDesignerSerializationManager manager, object value) {
            CodeExpression expression = null;
            
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "CodeDomSerializer::SerializeToReferenceExpression");
            Debug.Indent();
            
            // We do several things here:
            //
            //      First, we peek the context stack to see if it has a CodeValueExpression
            //      that contains our object.  If it does, then we just return it, as this is the expression someone
            //      has requested we use.  
            //
            //      Next, we check for a named IComponent, and return a reference to it.
            //
            
            // Check the context stack.
            //
            object context = manager.Context[typeof(CodeValueExpression)];
            if (context is CodeValueExpression) {
                CodeValueExpression valueEx = (CodeValueExpression)context;
                if (valueEx.Value == value) {
                    Debug.WriteLineIf(traceSerialization.TraceVerbose, "Object is on context stack.  Returning pushed expression.");
                    expression = valueEx.Expression;
                }
            }
            
            // Check for IComponent.
            //
            if (expression == null && value is IComponent) {

                string name = manager.GetName(value);
                bool referenceName = false;

                if (name == null) {
                    IReferenceService referenceService = (IReferenceService)manager.GetService(typeof(IReferenceService));
                    if (referenceService != null) {
                        name = referenceService.GetName(value);
                        referenceName = name != null;
                    }                                   
                }

                if (name != null) {
                    Debug.WriteLineIf(traceSerialization.TraceVerbose, "Object is reference (" + name + ") Creating reference expression");
                    
                    // Check to see if this is a reference to the root component.  If it is, then use "this".
                    //
                    CodeThisReferenceExpression thisRef = new CodeThisReferenceExpression();
                    IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                    if (host != null && host.RootComponent == value) {
                        expression = thisRef;
                    }
                    else if (referenceName && name.IndexOf('.') != -1) {
                        // if it's a reference name with a dot, we've actually got a property here...
                        //
                        int dotIndex = name.IndexOf('.');

                        expression = new CodePropertyReferenceExpression(new CodeFieldReferenceExpression(thisRef, name.Substring(0, dotIndex)), name.Substring(dotIndex + 1));
                    }
                    else {
                        expression = new CodeFieldReferenceExpression(thisRef, name);
                    }
                }
            }
            
            Debug.Unindent();
            return expression;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\serialization\componentcodedomserializer.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComponentCodeDomSerializer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design.Serialization {

    using System;
    using System.Design;
    using System.CodeDom;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Reflection;
    using System.Text;
    
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class ComponentCodeDomSerializer : CodeDomSerializer {
    
        private static readonly Attribute[] designTimeProperties = new Attribute[] { DesignOnlyAttribute.Yes};
        private static readonly Attribute[] runTimeProperties = new Attribute[] { DesignOnlyAttribute.No};
        private static readonly Type[] containerConstructor = new Type[] {typeof(IContainer)};
        
        private static ComponentCodeDomSerializer defaultSerializer;
        
        /// <include file='doc\ComponentCodeDomSerializer.uex' path='docs/doc[@for="ComponentCodeDomSerializer.Default"]/*' />
        /// <devdoc>
        ///     Retrieves a default static instance of this serializer.
        /// </devdoc>
        public static ComponentCodeDomSerializer Default {
            get {
                if (defaultSerializer == null) {
                    defaultSerializer = new ComponentCodeDomSerializer();
                }
                return defaultSerializer;
            }
        }
        
        /// <include file='doc\ComponentCodeDomSerializer.uex' path='docs/doc[@for="ComponentCodeDomSerializer.Deserialize"]/*' />
        /// <devdoc>
        ///     Deserilizes the given CodeDom object into a real object.  This
        ///     will use the serialization manager to create objects and resolve
        ///     data types.  The root of the object graph is returned.
        /// </devdoc>
        public override object Deserialize(IDesignerSerializationManager manager, object codeObject) {
            if (manager == null || codeObject == null) {
                throw new ArgumentNullException( manager == null ? "manager" : "codeObject");
            }
            
            if (!(codeObject is CodeStatementCollection)) {
                Debug.Fail("ComponentCodeDomSerializer::Deserialize requires a CodeStatementCollection to parse");
                throw new ArgumentException(SR.GetString(SR.SerializerBadElementType, typeof(CodeStatementCollection).FullName));
            }
            
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "ComponentCodeDomSerializer::Deserialize");
            Debug.Indent();
            
            object instance = null;

            if (manager.Context[typeof(CodeExpression)] != null) {
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Retrieving instance from context stack");
                instance = DeserializeExpression(manager, null, (CodeExpression)manager.Context[typeof(CodeExpression)]);
                Debug.WriteLineIf(traceSerialization.TraceWarning && instance == null, "WARNING: CodeExpression on stack did not return an instance.");
                if (instance != null) {
                    DeserializePropertiesFromResources(manager, instance, designTimeProperties);
                }
            }

            
            // Now look for things we understand.
            //
            foreach(CodeStatement element in (CodeStatementCollection)codeObject) {

                

                if (element is CodeAssignStatement) {
                    CodeAssignStatement statement = (CodeAssignStatement)element;
                    
                    // If this is an assign statement to a field, that field is our object.  Let DeserializeExpression
                    // do the work, but supply the field name as the name of the object.
                    //
                    if (statement.Left is CodeFieldReferenceExpression) {
                        CodeFieldReferenceExpression fieldRef = (CodeFieldReferenceExpression)statement.Left;
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Creating instance of object: " + fieldRef.FieldName);
                        Debug.WriteLineIf(traceSerialization.TraceWarning && instance != null, "WARNING: Instance has already been established.");
                        instance = DeserializeExpression(manager, fieldRef.FieldName, statement.Right);
                        
                        // Now that the object has been created, deserialize its design time properties.
                        //
                        if (instance != null) {
                            DeserializePropertiesFromResources(manager, instance, designTimeProperties);
                        }
                    }
                    else {
                        DeserializeStatement(manager, element);
                    }
                }
                else {
                    DeserializeStatement(manager, element);
                }
            }
            
            Debug.Unindent();
            return instance;
        }
        
        /// <include file='doc\ComponentCodeDomSerializer.uex' path='docs/doc[@for="ComponentCodeDomSerializer.Serialize"]/*' />
        /// <devdoc>
        ///     Serializes the given object into a CodeDom object.
        /// </devdoc>
        public override object Serialize(IDesignerSerializationManager manager, object value) {
            
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "ComponentCodeDomSerializer::Serialize");
            Debug.Indent();
            try {
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Value: " + value.ToString());
            }
            catch{
                // in case the ToString throws...
            }
            
            
            if (manager == null || value == null) {
                throw new ArgumentNullException( manager == null ? "manager" : "value");
            }
            
            CodeStatementCollection statements = new CodeStatementCollection();
            CodeExpression instanceDescrExpr = null;
            InheritanceAttribute inheritanceAttribute = (InheritanceAttribute)TypeDescriptor.GetAttributes(value)[typeof(InheritanceAttribute)];
            InheritanceLevel inheritanceLevel = InheritanceLevel.NotInherited;
            
            if (inheritanceAttribute != null) {
                inheritanceLevel = inheritanceAttribute.InheritanceLevel;
            }
            
            // Get the name for this object.  Components can only be serialized if they have
            // a name.
            //
            string name = manager.GetName(value);
            bool generateDeclaration = (name != null);
            if (name == null) {
                IReferenceService referenceService = (IReferenceService)manager.GetService(typeof(IReferenceService));
                if (referenceService != null) {
                    name = referenceService.GetName(value);
                }
            }
            Debug.WriteLineIf(traceSerialization.TraceWarning && name == null , "WARNING: object has no name so we cannot serialize.");
            if (name != null) {
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Name: " + name);
                
                // Push the component being serialized onto the stack.  It may be handy to
                // be able to discover this.
                //
                manager.Context.Push(value);
                
                try {
                    try {

                        // If the object is not inherited ensure that is has a component declaration.
                        //
                        if (generateDeclaration && inheritanceLevel == InheritanceLevel.NotInherited) {
                            // Check to make sure this isn't our base component.  If it is, there is
                            // no need to serialize its declaration.
                            //
                            IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                            if ((host == null || host.RootComponent != value)) {
                                SerializeDeclaration(manager, statements, value);
                            }
                        }
                        else {
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Skipping declaration of inherited or namespace component.");
                        }
                        
                        // Next, if the object is not being privately inherited, serialize the
                        // rest of its state.
                        //
                        if (inheritanceLevel != InheritanceLevel.InheritedReadOnly) {
                        
                            bool supportInitialize = (value is ISupportInitialize);
                            
                            if (supportInitialize) {
                                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Object implements ISupportInitialize.");
                                SerializeSupportInitialize(manager, statements, value, "BeginInit");
                            }
                            
                            // Add a nice comment that declares we're about to serialize this component
                            //
                            int insertLoc = statements.Count;
                            SerializePropertiesToResources(manager, statements, value, designTimeProperties);
                            SerializeProperties(manager, statements, value, runTimeProperties);
                            SerializeEvents(manager, statements, value, null);

                            // if we added some statements, insert the comments
                            //
                            if (statements.Count > insertLoc) {
                                statements.Insert(insertLoc, new CodeCommentStatement(string.Empty));
                                statements.Insert(insertLoc, new CodeCommentStatement(name));
                                statements.Insert(insertLoc, new CodeCommentStatement(string.Empty));
                            }
                            
                            if (supportInitialize) {
                                SerializeSupportInitialize(manager, statements, value, "EndInit");
                            }
                        }
                        else {
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Skipping serialization of read-only inherited component");
                        }
                    }
                    catch(Exception ex) {
                        manager.ReportError(ex);
                    }
                }
                finally {
                    Debug.Assert(manager.Context.Current == value, "Context stack corrupted");
                    manager.Context.Pop();
                }
            }
            else {

                Debug.WriteLineIf(traceSerialization.TraceWarning, "Attempting instance descriptor serialization.");
                Debug.Indent();
                // Last resort, lets see if if can serialize itself to an instance descriptor.
                //
                if (TypeDescriptor.GetConverter(value).CanConvertTo(typeof(InstanceDescriptor))) {

                    Debug.WriteLineIf(traceSerialization.TraceWarning, "Type supports instance descriptor.");
                    // Got an instance descriptor.  Ask it to serialize 
                    //
                    object o = InstanceDescriptorCodeDomSerializer.Default.Serialize(manager, value);
                    if (o is CodeExpression) {
                        Debug.WriteLineIf(traceSerialization.TraceWarning, "Serialized successfully.");
                        instanceDescrExpr = (CodeExpression)o;
                    }
                }
                Debug.Unindent();
            }
            
            if (instanceDescrExpr != null) {
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Object serialized into a single InstanceDescriptor expression.");
                Debug.Unindent();
                return instanceDescrExpr;
            }
            else {
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Object serialized into " + statements.Count.ToString() + " statements.");
                Debug.Unindent();
                return statements;
            }
        }
        
        /// <include file='doc\ComponentCodeDomSerializer.uex' path='docs/doc[@for="ComponentCodeDomSerializer.SerializeDeclaration"]/*' />
        /// <devdoc>
        ///     This ensures that the declaration for the component exists in the code class.  In 
        ///     addition, it will wire up the creation of the object in the init method.
        /// </devdoc>
        private void SerializeDeclaration(IDesignerSerializationManager manager, CodeStatementCollection statements, object value) {
                                  
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "ComponentCodeDomSerializer::SerializeDeclaration");
            Debug.Indent();
            
            // Attempt to get the type declaration in the context.
            //
            CodeTypeDeclaration docType = (CodeTypeDeclaration)manager.Context[typeof(CodeTypeDeclaration)];
            string name = manager.GetName(value);
            
            Debug.Assert(name != null, "Cannot serialize declaration of unnamed component.");

            if (name != null) {
                
                CodeTypeReference type = new CodeTypeReference(value.GetType());
                
                // Add the declaration to the code type, if we found one.
                //
                if (docType != null) {
                    MemberAttributes modifiers = MemberAttributes.Private;
                    PropertyDescriptor modifierProp = TypeDescriptor.GetProperties(value)["Modifiers"];
                    if (modifierProp != null && modifierProp.PropertyType == typeof(MemberAttributes)) {
                        modifiers = (MemberAttributes)modifierProp.GetValue(value);
                    }
                    else {
                        Debug.WriteLineIf(traceSerialization.TraceWarning, "WARNING: No Modifiers property on component " + name + "; assuming private.");
                    }
                    
                    // Create a field on the class that represents this component.
                    //
                    CodeMemberField field = new CodeMemberField(type, name);
                    field.Attributes = modifiers;
                    
                    docType.Members.Add(field);
                }
                
                // Next, add the instance creation to our statement list.  We check to see if there is an instance
                // descriptor attached to this compnent type that knows how to emit, which allows components to
                // init themselves from static method calls or public static fields, rather than always creating
                // an instance.
                //
                CodeFieldReferenceExpression fieldRef = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), name);
                CodeExpression createExpression = null;
                
                if (TypeDescriptor.GetConverter(value).CanConvertTo(typeof(InstanceDescriptor))) {
                
                    // Got an instance descriptor.  Ask it to serialize 
                    //
                    object o = InstanceDescriptorCodeDomSerializer.Default.Serialize(manager, value);
                    if (o is CodeExpression) {
                        createExpression = (CodeExpression)o;
                    }
                }
                
                if (createExpression == null) {
                    // Standard object create
                    //
                    CodeObjectCreateExpression objectCreate = new CodeObjectCreateExpression();
                    objectCreate.CreateType = type;
                    
                    // Check to see if this component has a constructor that takes an IContainer.  If it does,
                    // then add the container reference to the creation parameters.
                    //
                    ConstructorInfo ctr = value.GetType().GetConstructor(BindingFlags.ExactBinding | BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly,
                                                                         null, containerConstructor, null);
                    
                    if (ctr != null) {
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Object requires an IContainer constructor.");
                        RootCodeDomSerializer rootSerializer = (RootCodeDomSerializer)manager.Context[typeof(RootCodeDomSerializer)];
                        Debug.WriteLineIf(traceSerialization.TraceWarning && rootSerializer == null, "WARNING : Context stack does not have a root serializer on it so we cannot emit a required container constructor.");
                        if (rootSerializer != null) {
                            CodeFieldReferenceExpression container = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), rootSerializer.ContainerName);
                            objectCreate.Parameters.Add(container);
                            rootSerializer.ContainerRequired = true;
                        }
                    }
                    
                    createExpression = objectCreate;
                }
                
                
                statements.Add(new CodeAssignStatement(fieldRef, createExpression));
            }
        
            Debug.Unindent();
        }
        
        /// <include file='doc\ComponentCodeDomSerializer.uex' path='docs/doc[@for="ComponentCodeDomSerializer.SerializeSupportInitialize"]/*' />
        /// <devdoc>
        ///     This emits a method invoke to ISupportInitialize.
        /// </devdoc>
        private void SerializeSupportInitialize(IDesignerSerializationManager manager, CodeStatementCollection statements, object value, string methodName) {
        
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "ComponentCodeDomSerializer::SerializeSupportInitialize");
            Debug.Indent();
            
            string name = manager.GetName(value);

            if (name == null) {
                IReferenceService referenceService = (IReferenceService)manager.GetService(typeof(IReferenceService));
                if (referenceService != null) {
                    name = referenceService.GetName(value);
                }
            }

            Debug.WriteLineIf(traceSerialization.TraceVerbose, name + "." + methodName);
            
            // Assemble a cast to ISupportInitialize, and then invoke the method.
            //
            CodeExpression targetExpr = null;
            
            IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
            if (host != null && host.RootComponent == value) {
                targetExpr = new CodeThisReferenceExpression();
            }
            else {
                targetExpr = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), name);
            }

            CodeTypeReference type = new CodeTypeReference(typeof(ISupportInitialize));
            CodeCastExpression castExp = new CodeCastExpression(type, targetExpr);
            CodeMethodReferenceExpression method = new CodeMethodReferenceExpression(castExp, methodName);
            CodeMethodInvokeExpression methodInvoke = new CodeMethodInvokeExpression();
            methodInvoke.Method = method;
            CodeExpressionStatement statement = new CodeExpressionStatement(methodInvoke);
            
            if (methodName == "BeginInit") {
                statement.UserData["statement-ordering"] = "begin";
            }
            else {
                statement.UserData["statement-ordering"] = "end";
            }

            statements.Add(statement);
            Debug.Unindent();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\drawing\makefile.inc ===
!if 0
    -------------------------------------------------------------------------------------
        Don't modify... user variables are set in "sources"
    -------------------------------------------------------------------------------------
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\serialization\objectcodedomserializer.cs ===
//------------------------------------------------------------------------------
// <copyright file="ObjectCodeDomSerializer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design.Serialization {

    using System;
    using System.CodeDom;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Reflection;
    
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class ObjectCodeDomSerializer : CodeDomSerializer {
    
        private static ObjectCodeDomSerializer defaultSerializer;
        
        /// <include file='doc\ObjectCodeDomSerializer.uex' path='docs/doc[@for="ObjectCodeDomSerializer.Default"]/*' />
        /// <devdoc>
        ///     Retrieves a default static instance of this serializer.
        /// </devdoc>
        public static ObjectCodeDomSerializer Default {
            get {
                if (defaultSerializer == null) {
                    defaultSerializer = new ObjectCodeDomSerializer();
                }
                return defaultSerializer;
            }
        }
        
        /// <include file='doc\ObjectCodeDomSerializer.uex' path='docs/doc[@for="ObjectCodeDomSerializer.Deserialize"]/*' />
        /// <devdoc>
        ///     Deserilizes the given CodeDom object into a real object.  This
        ///     will use the serialization manager to create objects and resolve
        ///     data types.  The root of the object graph is returned.
        /// </devdoc>
        public override object Deserialize(IDesignerSerializationManager manager, object codeObject) {
            Debug.Fail("Object serializer cannot deserialize, only serialize.");
            return null;
        }
        
        /// <include file='doc\ObjectCodeDomSerializer.uex' path='docs/doc[@for="ObjectCodeDomSerializer.Serialize"]/*' />
        /// <devdoc>
        ///     Serializes the given object into a CodeDom object.
        /// </devdoc>
        public override object Serialize(IDesignerSerializationManager manager, object value) {
        
            object expression = null;
            
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "ObjectCodeDomSerializer::Serialize");
            Debug.Indent();
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Value: " + value.ToString());
            
            if (manager == null || value == null) {
                throw new ArgumentNullException( manager == null ? "manager" : "value");
            }
            
            if (value is Type) {
                expression = new CodeTypeOfExpression((Type)value);
            }
            else {
                CodeStatementCollection statements = new CodeStatementCollection();
                
                SerializeProperties(manager, statements, value, null);
                SerializeEvents(manager, statements, value, null);
                
                if (statements.Count > 0) {
                    expression = statements;
                }
                else {
                    if (value.GetType().IsSerializable) {
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Failed to serialize through code but object is runtime serializable.");
                        expression = ResourceCodeDomSerializer.Default.Serialize(manager, value);
                    }
                }
            }
            
            Debug.Unindent();
            return expression;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\serialization\instancedescriptorcodedomserializer.cs ===
//------------------------------------------------------------------------------
// <copyright file="InstanceDescriptorCodeDomSerializer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design.Serialization {

    using System;
    using System.CodeDom;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Reflection;
    using System.Design;
    using System.Globalization;

    /// <include file='doc\InstanceDescriptorCodeDomSerializer.uex' path='docs/doc[@for="InstanceDescriptorCodeDomSerializer"]/*' />
    /// <devdoc>
    ///     Code model serializer for objects that have InstanceDescriptors.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class InstanceDescriptorCodeDomSerializer : CodeDomSerializer {
    
        private static readonly Attribute[] runTimeProperties = new Attribute[] { DesignOnlyAttribute.No};
        private static readonly Attribute[] designTimeProperties = new Attribute[] { DesignOnlyAttribute.Yes};
        
        private static InstanceDescriptorCodeDomSerializer defaultSerializer;
        
        /// <include file='doc\InstanceDescriptorCodeDomSerializer.uex' path='docs/doc[@for="InstanceDescriptorCodeDomSerializer.Default"]/*' />
        /// <devdoc>
        ///     Retrieves a default static instance of this serializer.
        /// </devdoc>
        public static InstanceDescriptorCodeDomSerializer Default {
            get {
                if (defaultSerializer == null) {
                    defaultSerializer = new InstanceDescriptorCodeDomSerializer();
                }
                return defaultSerializer;
            }
        }
        
        /// <include file='doc\InstanceDescriptorCodeDomSerializer.uex' path='docs/doc[@for="InstanceDescriptorCodeDomSerializer.Deserialize"]/*' />
        /// <devdoc>
        ///     Deserilizes the given CodeDom object into a real object.  This
        ///     will use the serialization manager to create objects and resolve
        ///     data types.  The root of the object graph is returned.
        /// </devdoc>
        public override object Deserialize(IDesignerSerializationManager manager, object codeObject) {
            if (manager == null || codeObject == null) {
                throw new ArgumentNullException( manager == null ? "manager" : "codeObject");
            }
            
            if (!(codeObject is CodeStatementCollection)) {
                Debug.Fail("ComponentCodeDomSerializer::Deserialize requires a CodeStatementCollection to parse");
                throw new ArgumentException(SR.GetString(SR.SerializerBadElementType, typeof(CodeStatementCollection).FullName));
            }
            
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "InstanceDescriptorCodeDomSerializer::Deserialize");
            Debug.Indent();
            
            object instance = null;

            if (manager.Context[typeof(CodeExpression)] != null) {
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Retrieving instance from context stack");
                instance = DeserializeExpression(manager, null, (CodeExpression)manager.Context[typeof(CodeExpression)]);
                Debug.WriteLineIf(traceSerialization.TraceWarning && instance == null, "WARNING: CodeExpression on stack did not return an instance.");
            }
            // Now look for things we understand.
            //
            foreach(CodeStatement statement in (CodeStatementCollection)codeObject) {
                
                if (statement is CodeVariableDeclarationStatement) {
                    CodeVariableDeclarationStatement localRef = (CodeVariableDeclarationStatement)statement;
                    Debug.WriteLineIf(traceSerialization.TraceVerbose, "Creating instance of object: " + localRef.Name);
                    Debug.WriteLineIf(traceSerialization.TraceWarning && instance != null, "WARNING: Instance has already been established.");
                    instance = DeserializeExpression(manager, localRef.Name, localRef.InitExpression);
                    
                    // make sure we pushed in the value of the variable
                    //
                    if (instance != null && null == manager.GetInstance(localRef.Name)) {
                        manager.SetName(instance, localRef.Name);
                    }

                    // Now that the object has been created, deserialize its design time properties.
                    //
                    DeserializePropertiesFromResources(manager, instance, designTimeProperties);
                }
                else {
                    DeserializeStatement(manager, statement);
                }
            }  
            
            Debug.Unindent();
            return instance;
        }
            
        /// <include file='doc\InstanceDescriptorCodeDomSerializer.uex' path='docs/doc[@for="InstanceDescriptorCodeDomSerializer.Serialize"]/*' />
        /// <devdoc>
        ///     Serializes the given object into a CodeDom object.
        /// </devdoc>
        public override object Serialize(IDesignerSerializationManager manager, object value) {
            object expression = null;
            
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "InstanceDescriptorCodeDomSerializer::Serialize");
            Debug.Indent();

            // To serialize a primitive type, we must assign its value to the current statement.  We get the current
            // statement by asking the context.

            object statement = manager.Context.Current;
            Debug.Assert(statement != null, "Statement is null -- we need a context to be pushed for instance descriptors to serialize");

            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Value: " + value.ToString());
            Debug.WriteLineIf(traceSerialization.TraceVerbose && statement != null, "Statement: " + statement.GetType().Name);
            
            TypeConverter converter = TypeDescriptor.GetConverter(value);
            InstanceDescriptor descriptor = (InstanceDescriptor)converter.ConvertTo(value, typeof(InstanceDescriptor));
            if (descriptor != null) {
                expression = SerializeInstanceDescriptor(manager, value, descriptor);
            }
            else {
                Debug.WriteLineIf(traceSerialization.TraceError, "*** Converter + " + converter.GetType().Name + " failed to give us an instance descriptor");
            }
            
            // Ok, we have the "new Foo(arg, arg, arg)" done.  Next, check to see if the instance
            // descriptor has given us a complete representation of the object.  If not, we must
            // go through the additional work of creating a local variable and saving properties.
            // 
            if (descriptor != null && !descriptor.IsComplete) {
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Incomplete instance descriptor; creating local variable declaration and serializing properties.");
                CodeStatementCollection statements = (CodeStatementCollection)manager.Context[typeof(CodeStatementCollection)];
                Debug.WriteLineIf(traceSerialization.TraceError && statements == null, "*** No CodeStatementCollection on context stack so we can generate a local variable statement.");
                
                if (statements != null) {
                    MemberInfo mi = descriptor.MemberInfo;
                    Type targetType;

                    if (mi is PropertyInfo) {
                        targetType = ((PropertyInfo)mi).PropertyType;
                    }
                    else if (mi is MethodInfo) {
                        targetType = ((MethodInfo)mi).ReturnType;
                    }
                    else {
                        targetType = mi.DeclaringType;
                    }
                    
                    string localName = manager.GetName(value);
                    
                    if (localName == null) {
                    
                        string baseName;
                        
                        INameCreationService ns = (INameCreationService)manager.GetService(typeof(INameCreationService));
                        Debug.WriteLineIf(traceSerialization.TraceWarning && (ns == null), "WARNING: Need to generate name for local variable but we have no service.");
                        
                        if (ns != null) {
                            baseName = ns.CreateName(null, targetType);
                        }
                        else {
                            baseName = targetType.Name.ToLower(CultureInfo.InvariantCulture);
                        }
                        
                        int suffixIndex = 1;
                        
                        // Declare this name to the serializer.  If there is already a name defined,
                        // keep trying.
                        //
                        while(true) {
                        
                            localName = baseName + suffixIndex.ToString();
                            
                            if (manager.GetInstance(localName) == null) {
                                manager.SetName(value, localName);
                                break;
                            }
                            
                            suffixIndex++;
                        }
                    }
    
                    Debug.WriteLineIf(traceSerialization.TraceVerbose, "Named local variable " + localName);
                    
                    CodeVariableDeclarationStatement localStatement = new CodeVariableDeclarationStatement(targetType, localName);
                    localStatement.InitExpression = (CodeExpression)expression;
                    statements.Add(localStatement);
                    
                    expression = new CodeVariableReferenceExpression(localName);
                    
                    // Create a CodeValueExpression to place on the context stack.  
                    CodeValueExpression cve = new CodeValueExpression((CodeExpression)expression, value);
                    
                    manager.Context.Push(cve);
                    
                    try {
                        // Now that we have hooked the return expression up and declared the local,
                        // it's time to save off the properties for the object.
                        //
                        SerializeProperties(manager, statements, value, runTimeProperties);
                    }
                    finally {
                        Debug.Assert(manager.Context.Current == cve, "Context stack corrupted");
                        manager.Context.Pop();
                    }
                }
            }
            
            Debug.Unindent();
            return expression;
        }
        
        /// <include file='doc\InstanceDescriptorCodeDomSerializer.uex' path='docs/doc[@for="InstanceDescriptorCodeDomSerializer.SerializeInstanceDescriptor"]/*' />
        /// <devdoc>
        ///     Serializes the given instance descriptor into a code model expression.
        /// </devdoc>
        private object SerializeInstanceDescriptor(IDesignerSerializationManager manager, object value, InstanceDescriptor descriptor) {
        
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "InstanceDescriptorCodeDomSerializer::SerializeInstanceDescriptor");
            Debug.Indent();

            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Member: " + descriptor.MemberInfo.Name);
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Argument count: " + descriptor.Arguments.Count);
            
            // Serialize all of the arguments.
            //
            CodeExpression[] arguments = new CodeExpression[descriptor.Arguments.Count];
            int i = 0;
            bool paramsOk = true;
            
            foreach(object argument in descriptor.Arguments) {
                CodeValueExpression codeValue = new CodeValueExpression(null, argument, (argument != null ? argument.GetType() : null));
                manager.Context.Push(codeValue);                                                        
                try {
                    arguments[i] = SerializeToExpression(manager, argument);
                    if (arguments[i] == null) {
                        Debug.WriteLineIf(traceSerialization.TraceWarning, "WARNING: Parameter " + i.ToString() + " in instance descriptor call " + descriptor.GetType().Name + " could not be serialized.");
                        paramsOk = false;
                        break;
                    }
                }
                finally {
                    manager.Context.Pop();
                }
                i++;
            }
            
            CodeExpression expression = null;
            
            if (paramsOk) {
                Type expressionType = descriptor.MemberInfo.DeclaringType;
                CodeTypeReference typeRef = new CodeTypeReference(expressionType);
                
                if (descriptor.MemberInfo is ConstructorInfo) {
                    expression = new CodeObjectCreateExpression(typeRef, arguments);
                }
                else if (descriptor.MemberInfo is MethodInfo) {
                    CodeTypeReferenceExpression typeRefExp = new CodeTypeReferenceExpression(typeRef);
                    CodeMethodReferenceExpression methodRef = new CodeMethodReferenceExpression(typeRefExp, descriptor.MemberInfo.Name);
                    expression = new CodeMethodInvokeExpression(methodRef, arguments);
                    expressionType = ((MethodInfo)descriptor.MemberInfo).ReturnType;
                }
                else if (descriptor.MemberInfo is PropertyInfo) {
                    CodeTypeReferenceExpression typeRefExp = new CodeTypeReferenceExpression(typeRef);
                    CodePropertyReferenceExpression propertyRef = new CodePropertyReferenceExpression(typeRefExp, descriptor.MemberInfo.Name);
                    Debug.Assert(arguments.Length == 0, "Property serialization does not support arguments");
                    expression = propertyRef;
                    expressionType = ((PropertyInfo)descriptor.MemberInfo).PropertyType;
                }
                else if (descriptor.MemberInfo is FieldInfo) {
                    Debug.Assert(arguments.Length == 0, "Field serialization does not support arguments");
                    CodeTypeReferenceExpression typeRefExp = new CodeTypeReferenceExpression(typeRef);
                    expression = new CodeFieldReferenceExpression(typeRefExp, descriptor.MemberInfo.Name);
                    expressionType = ((FieldInfo)descriptor.MemberInfo).FieldType;
                }
                else {
                    Debug.Fail("Unrecognized reflection type in instance descriptor: " + descriptor.MemberInfo.GetType().Name);
                }
                
                // Finally, check to see if our value is assignable from the expression type.  If not, 
                // then supply a cast.  The value may be an internal or protected type; if it is,
                // then walk up its hierarchy until we find one that is public.
                //
                Type targetType = value.GetType();
                while(!targetType.IsPublic) {
                    targetType = targetType.BaseType;
                }
                
                if (!targetType.IsAssignableFrom(expressionType)) {
                    Debug.WriteLineIf(traceSerialization.TraceVerbose, "Target type of " + targetType.Name + " is not assignable from " + expressionType.Name + ".  Supplying cast.");
                    expression = new CodeCastExpression(targetType, expression);
                }
            }
            
            Debug.Unindent();
            return expression;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\serialization\collectioncodedomserializer.cs ===
//------------------------------------------------------------------------------
// <copyright file="CollectionCodeDomSerializer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design.Serialization {

    using System;
    using System.Design;
    using System.CodeDom;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Reflection;
    
    /// <include file='doc\CollectionCodeDomSerializer.uex' path='docs/doc[@for="CollectionCodeDomSerializer"]/*' />
    /// <devdoc>
    ///     This serializer serializes collections.  This can either
    ///     create statements or expressions.  It will create an
    ///     expression and assign it to the statement in the current
    ///     context stack if the object is an array.  If it is
    ///     a collection with an add range or similar method,
    ///     it will create a statement calling the method.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class CollectionCodeDomSerializer : CodeDomSerializer {
    
        private static CollectionCodeDomSerializer defaultSerializer;
        
        /// <include file='doc\CollectionCodeDomSerializer.uex' path='docs/doc[@for="CollectionCodeDomSerializer.Default"]/*' />
        /// <devdoc>
        ///     Retrieves a default static instance of this serializer.
        /// </devdoc>
        public static CollectionCodeDomSerializer Default {
            get {
                if (defaultSerializer == null) {
                    defaultSerializer = new CollectionCodeDomSerializer();
                }
                return defaultSerializer;
            }
        }
        
        /// <include file='doc\CollectionCodeDomSerializer.uex' path='docs/doc[@for="CollectionCodeDomSerializer.Deserialize"]/*' />
        /// <devdoc>
        ///     Deserilizes the given CodeDom object into a real object.  This
        ///     will use the serialization manager to create objects and resolve
        ///     data types.  The root of the object graph is returned.
        /// </devdoc>
        public override object Deserialize(IDesignerSerializationManager manager, object codeObject) {
            // No need to have this code -- we just deserialize by exectuting code.
            Debug.Fail("Don't expect this to be called.");
            return null;
        }

        /// <devdoc>
        ///     Computes the delta between an existing collection and a modified one.
        ///     This is for the case of inherited items that have collection properties so we only
        ///     generate Add/AddRange calls for the items that have been added.  It works by
        ///     Hashing up the items in the original collection and then walking the modified collection
        ///     and only returning those items which do not exist in the base collection.
        /// </devdoc>
        private ICollection GetCollectionDelta(ICollection original, ICollection modified) {

            if (original == null || modified == null || original.Count == 0) {
                return modified;
            }

            IEnumerator modifiedEnum = modified.GetEnumerator();

            // yikes! who wrote this thing?
            if (modifiedEnum == null) {
                Debug.Fail("Collection of type " + modified.GetType().FullName + " doesn't return an enumerator");
                return modified;
            }
            // first hash up the values so we can quickly decide if it's a new one or not
            // 
            IDictionary originalValues = new HybridDictionary();
            foreach (object originalValue in original) {
                
                // the array could contain multiple copies of the same value (think of a string collection),
                // so we need to be sensitive of that.
                //
                if (originalValues.Contains(originalValue)) {
                    int count = (int)originalValues[originalValue];
                    originalValues[originalValue] = ++count;
                }
                else {
                    originalValues.Add(originalValue, 1);
                }
            }

            // now walk through and delete existing values
            //
            ArrayList result = null;

            // now compute the delta.
            //
            for (int i = 0; i < modified.Count && modifiedEnum.MoveNext(); i++) {
                object value = modifiedEnum.Current;
                
                if (originalValues.Contains(value)) {
                    // we've got one we need to remove, so 
                    // create our array list, and push all the values we've passed
                    // into it.
                    //
                    if (result == null) {
                        result = new ArrayList();
                        modifiedEnum.Reset();
                        for (int n = 0; n < i && modifiedEnum.MoveNext(); n++) {
                            result.Add(modifiedEnum.Current);
                        }

                        // and finally skip the one we're on
                        //
                        modifiedEnum.MoveNext();
                    }

                    // decrement the count if we've got more than one...
                    //
                    int count = (int)originalValues[value];

                    if (--count == 0) {
                        originalValues.Remove(value);
                    }
                    else {
                        originalValues[value] = count;
                    }
                }
                else if (result != null) {
                    // this one isn't in the old list, so add it to our 
                    // result list.
                    //
                    result.Add(value);
                }

                // this item isn't in the list and we haven't yet created our array list
                // so just keep on going.
                //
            }

            if (result != null) {
                return result;
            }
            return modified;
        }

        protected virtual bool PreferAddRange {
            get {
                return true;
            }
        }
            
        /// <include file='doc\CollectionCodeDomSerializer.uex' path='docs/doc[@for="CollectionCodeDomSerializer.Serialize"]/*' />
        /// <devdoc>
        ///     Serializes the given object into a CodeDom object.
        /// </devdoc>
        public override object Serialize(IDesignerSerializationManager manager, object value) {
            object result = null;
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "CollectionCodeDomSerializer::Serialize");
            Debug.Indent();
            
            // We serialize collections as follows:
            //
            //      If the collection is an array, we write out the array.
            //
            //      If the collection has a method called AddRange, we will
            //      call that, providing an array.
            //
            //      If the colleciton has an Add method, we will call it
            //      repeatedly.
            //
            //      If the collection is an IList, we will cast to IList
            //      and add to it.
            //
            //      If the collection has no add method, but is marked
            //      with PersistContents, we will enumerate the collection
            //      and serialize each element.
            
            // Check to see if there is a CodePropertyReferenceExpression on the stack.  If there is,
            // we can use it as a guide for serialization.
            //
            object context = manager.Context.Current;
            if (context is CodeValueExpression) {
                CodeValueExpression valueEx = (CodeValueExpression)context;
                if (valueEx.Value == value) {
                    context = valueEx.Expression;
                }
            }
            
            if (context is CodePropertyReferenceExpression) {
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Property reference encountered on context stack.");
                
                // Only serialize if the value is a collection.
                //
                Debug.Assert(value is ICollection, "Collection serializer invoked for non-collection: " + (value == null ? "(null)" : value.GetType().Name));
                if (value is ICollection) {
                    CodePropertyReferenceExpression propRef = (CodePropertyReferenceExpression)context;
                    object targetObject = DeserializeExpression(manager, null, propRef.TargetObject);
                    Debug.WriteLineIf(traceSerialization.TraceWarning && targetObject == null, "WARNING: Failed to deserialize property reference target");
                    
                    if (targetObject != null) {
                        PropertyDescriptor prop = TypeDescriptor.GetProperties(targetObject)[propRef.PropertyName];
                        
                        if (prop != null) {
                            Type propertyType = prop.PropertyType;
                            
                            if (typeof(Array).IsAssignableFrom(propertyType)) {
                                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Collection is array");
                                result = SerializeArray(manager, propRef, propertyType.GetElementType(), (Array)value, targetObject);
                            }
                            else {
                                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Searching for AddRange or Add");
                                MethodInfo[] methods = propertyType.GetMethods(BindingFlags.Public | BindingFlags.Instance);
                                MethodInfo addRange = null;
                                MethodInfo add = null;
                                ParameterInfo[] parameters = null;
                                
                                foreach(MethodInfo method in methods) {
                                    if (method.Name.Equals("AddRange")) {
                                        parameters = method.GetParameters();
                                        if (parameters.Length == 1 && parameters[0].ParameterType.IsArray) {
                                            addRange = method;
                                            if (PreferAddRange) break;
                                        }
                                    }
                                    if (method.Name.Equals("Add")) {
                                        parameters = method.GetParameters();
                                        if (parameters.Length == 1) {
                                            add = method;
                                            if (!PreferAddRange) break;
                                        }
                                    }
                                }

                                if (!PreferAddRange && addRange != null && add != null) {
                                    addRange = null;
                                }

                                if (addRange != null) {
                                    result = SerializeViaAddRange(manager, propRef, (ICollection)value, addRange, parameters[0], targetObject);
                                }
                                else if (add != null) {
                                    result = SerializeViaAdd(manager, propRef, (ICollection)value, add, parameters[0], targetObject);
                                }                                                            
                            }
                        }
                    }
                }
            }
            else {
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "No property reference encountered on context stack, serializing as array expression.");
                
                if (value is Array) {
                    result = SerializeArray(manager, null, null, (Array)value, null);
                }
            }
            
            Debug.Unindent();
            return result;
        }
        
        /// <include file='doc\CollectionCodeDomSerializer.uex' path='docs/doc[@for="CollectionCodeDomSerializer.SerializeArray"]/*' />
        /// <devdoc>
        ///     Serializes the given array.
        /// </devdoc>
        private object SerializeArray(IDesignerSerializationManager manager, CodePropertyReferenceExpression propRef, Type asType, Array array, object targetObject) {
            object result = null;
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "CollectionCodeDomSerializer::SerializeArray");
            Debug.Indent();
            
            if (array.Rank != 1) {
                Debug.WriteLineIf(traceSerialization.TraceError, "*** Cannot serialize arrays with rank > 1. ***");
                manager.ReportError(SR.GetString(SR.SerializerInvalidArrayRank, array.Rank.ToString()));
            }
            else {
                // For an array, we need an array create expression.  First, get the array type
                //
                Type elementType = null;
                
                if (asType != null) {
                    elementType = asType;
                }
                else {
                    elementType = array.GetType().GetElementType();
                }
                
                CodeTypeReference elementTypeRef = new CodeTypeReference(elementType);
                
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Array type: " +elementType.Name);
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Length:" + array.Length.ToString());
                
                // Now create an ArrayCreateExpression, and fill its initializers.
                //
                CodeArrayCreateExpression arrayCreate = new CodeArrayCreateExpression();
                arrayCreate.CreateType = elementTypeRef;
                bool arrayOk = true;

                ICollection collection = array;

                bool isTargetInherited = false;
                IComponent comp = targetObject as IComponent;
                if (comp != null) {
                    InheritanceAttribute ia = (InheritanceAttribute)TypeDescriptor.GetAttributes(comp)[typeof(InheritanceAttribute)];
                    isTargetInherited = (ia != null && ia.InheritanceLevel == InheritanceLevel.Inherited);
                }
    
                if (isTargetInherited) {
                    InheritedPropertyDescriptor inheritedDesc = manager.Context[typeof(PropertyDescriptor)] as InheritedPropertyDescriptor;
                    if (inheritedDesc != null) {
                        collection = GetCollectionDelta(inheritedDesc.OriginalValue as ICollection, array);
                    }
                }

                CodeValueExpression codeValue = new CodeValueExpression(null, collection, elementType);
                manager.Context.Push(codeValue);                                                        

                try {
                    
                    foreach(object o in collection) {
                    
                        // If this object is being privately inherited, it cannot be inside
                        // this collection.  Since we're writing an entire array here, we
                        // cannot write any of it.
                        //
                        if (o is IComponent && TypeDescriptor.GetAttributes(o).Contains(InheritanceAttribute.InheritedReadOnly)) {
                            arrayOk = false;
                            break;
                        }
                      
                        object expression = SerializeToExpression(manager, o);
                        if (expression is CodeExpression) {
                            arrayCreate.Initializers.Add((CodeExpression)expression);
                        }
                        else {
                            arrayOk = false;
                            break;
                        }
                    }
                }
                finally {
                    manager.Context.Pop();
                }
                
                // if we weren't given a property, we're done.  Otherwise, we must create an assign statement for
                // the property.
                //
                if (arrayOk) {
                    if (propRef != null) {
                        result = new CodeAssignStatement(propRef, arrayCreate);
                    }
                    else {
                        result = arrayCreate;
                    }
                }
            }
            
            Debug.Unindent();
            return result;
        }

        /// <include file='doc\CollectionCodeDomSerializer.uex' path='docs/doc[@for="CollectionCodeDomSerializer.SerializeViaAdd"]/*' />
        /// <devdoc>
        ///     Serializes the given collection by creating multiple calls to an Add method.
        /// </devdoc>
        private object SerializeViaAdd(
            IDesignerSerializationManager manager, 
            CodePropertyReferenceExpression propRef, 
            ICollection collection, 
            MethodInfo addMethod, 
            ParameterInfo parameter,
            object targetObject) {

            Debug.WriteLineIf(traceSerialization.TraceVerbose, "CollectionCodeDomSerializer::SerializeViaAdd");
            Debug.Indent();
            
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Collection: " + collection.GetType().Name);
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Elements: " + collection.Count.ToString());
        
            // Here we need to invoke Add once for each and every item in the collection. We can re-use the property
            // reference and method reference, but we will need to recreate the invoke statement each time.
            //
            CodeStatementCollection statements = new CodeStatementCollection();
            CodeMethodReferenceExpression methodRef = new CodeMethodReferenceExpression(propRef, addMethod.Name);
            
            MethodInfo clearMethod = collection.GetType().GetMethod("Clear", new Type[0]);
            if (clearMethod != null) {
                PropertyDescriptor clearProp = manager.Properties["ClearCollections"];
                if (clearProp != null) {
                    // insert code here to clear the collecion...
                    //
                    statements.Add(new CodeMethodInvokeExpression(propRef, "Clear"));
                }
            }
            
            bool isTargetInherited = false;
            InheritedPropertyDescriptor inheritedDesc = manager.Context[typeof(PropertyDescriptor)] as InheritedPropertyDescriptor;
            if (inheritedDesc != null) {
                isTargetInherited = true;
                collection = GetCollectionDelta(inheritedDesc.OriginalValue as ICollection, collection);
                if (collection.Count == 0) {
                    Debug.Unindent();
                    return statements;
                } 
            }

            foreach(object o in collection) {
                
                // If this object is being privately inherited, it cannot be inside
                // this collection.
                //
                bool genCode = !(o is IComponent);
                if (!genCode) {
                    InheritanceAttribute ia = (InheritanceAttribute)TypeDescriptor.GetAttributes(o)[typeof(InheritanceAttribute)];
                    if (ia != null) {
                        if (ia.InheritanceLevel == InheritanceLevel.InheritedReadOnly)
                            genCode = false;
                        else if (ia.InheritanceLevel == InheritanceLevel.Inherited && isTargetInherited)
                            genCode = false;
                        else
                            genCode = true;
                    }
                    else {
                        genCode = true;
                    }
                }

                if (genCode) {

                    CodeMethodInvokeExpression statement = new CodeMethodInvokeExpression();
                    statement.Method = methodRef;

                    CodeValueExpression codeValue = new CodeValueExpression(null, o, parameter.ParameterType);
                    manager.Context.Push(codeValue);                                                        

                    CodeExpression serializedObj = null;
        
                    try {
                        serializedObj = SerializeToExpression(manager, o);
                    }
                    finally {
                        manager.Context.Pop();
                    }
                    if (serializedObj != null) {
                        statement.Parameters.Add(serializedObj);
                        statements.Add(statement);
                    }
                }
            }
        
            Debug.Unindent();
            return statements;
        }
        
        /// <include file='doc\CollectionCodeDomSerializer.uex' path='docs/doc[@for="CollectionCodeDomSerializer.SerializeViaAddRange"]/*' />
        /// <devdoc>
        ///     Serializes the given collection by creating an array and passing it to the AddRange method.
        /// </devdoc>
        private object SerializeViaAddRange(
            IDesignerSerializationManager manager, 
            CodePropertyReferenceExpression propRef, 
            ICollection collection, 
            MethodInfo addRangeMethod, 
            ParameterInfo parameter,
            object targetObject) {

            Debug.WriteLineIf(traceSerialization.TraceVerbose, "CollectionCodeDomSerializer::SerializeViaAddRange");
            Debug.Indent();
            
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Collection: " + collection.GetType().Name);
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Elements: " + collection.Count.ToString());
            
            
            CodeStatementCollection statements = new CodeStatementCollection();
            
            MethodInfo clearMethod = collection.GetType().GetMethod("Clear", new Type[0]);
            if (clearMethod != null) {
                PropertyDescriptor clearProp = manager.Properties["ClearCollections"];
                if (clearProp != null && clearProp.PropertyType == typeof(bool) && ((bool)clearProp.GetValue(manager) == true)) {
                    // insert code here to clear the collecion...
                    //
                    statements.Add(new CodeMethodInvokeExpression(propRef, "Clear"));
                }
            }
            
            if (collection.Count == 0) {
                Debug.Unindent();
                return statements;
            }                         
            
            // We must walk the collection looking for privately inherited objects.  If we find them,
            // we need to exclude them from the array.
            //
            ArrayList arrayList = new ArrayList(collection.Count);
            
            bool isTargetInherited = false;
            InheritedPropertyDescriptor inheritedDesc = manager.Context[typeof(PropertyDescriptor)] as InheritedPropertyDescriptor;
            if (inheritedDesc != null) {
                isTargetInherited = true;
                collection = GetCollectionDelta(inheritedDesc.OriginalValue as ICollection, collection);
                if (collection.Count == 0) {
                    Debug.Unindent();
                    return statements;
                } 
            }

            CodeValueExpression codeValue = new CodeValueExpression(null, collection, parameter.ParameterType.GetElementType());
            manager.Context.Push(codeValue);                                                        

            try {
                foreach(object o in collection) {
                    // If this object is being privately inherited, it cannot be inside
                    // this collection.
                    //
                    bool genCode = !(o is IComponent);
                    if (!genCode) {
                        InheritanceAttribute ia = (InheritanceAttribute)TypeDescriptor.GetAttributes(o)[typeof(InheritanceAttribute)];
                        if (ia != null) {
                            if (ia.InheritanceLevel == InheritanceLevel.InheritedReadOnly)
                                genCode = false;
                            else if (ia.InheritanceLevel == InheritanceLevel.Inherited && isTargetInherited)
                                genCode = false;
                            else
                                genCode = true;
                        }
                        else {
                            genCode = true;
                        }
                    }
    
                    if (genCode) {
                        CodeExpression exp = SerializeToExpression(manager, o);
                        if (exp != null) {
                            arrayList.Add(exp);
                        }
                    }
                }
            }
            finally {
                manager.Context.Pop();
            }
            
            if (arrayList.Count > 0) {

                // Now convert the array list into an array create expression.
                //
                CodeTypeReference elementTypeRef = new CodeTypeReference(parameter.ParameterType.GetElementType());
                
                // Now create an ArrayCreateExpression, and fill its initializers.
                //
                CodeArrayCreateExpression arrayCreate = new CodeArrayCreateExpression();
                arrayCreate.CreateType = elementTypeRef;
            
                foreach(CodeExpression exp in arrayList) {
                    arrayCreate.Initializers.Add(exp);
                }
                CodeMethodReferenceExpression methodRef = new CodeMethodReferenceExpression(propRef, addRangeMethod.Name);
                CodeMethodInvokeExpression methodInvoke = new CodeMethodInvokeExpression();
                methodInvoke.Method = methodRef; 
                methodInvoke.Parameters.Add(arrayCreate);
                statements.Add(new CodeExpressionStatement(methodInvoke));
            }
            
            Debug.Unindent();
            return statements;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\serialization\primitivecodedomserializer.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrimitiveCodeDomSerializer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design.Serialization {

    using System;
    using System.CodeDom;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Reflection;
    
    /// <include file='doc\PrimitiveCodeDomSerializer.uex' path='docs/doc[@for="PrimitiveCodeDomSerializer"]/*' />
    /// <devdoc>
    ///     Code model serializer for primitive types.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class PrimitiveCodeDomSerializer : CodeDomSerializer {
    
        private static PrimitiveCodeDomSerializer defaultSerializer;
        
        /// <include file='doc\PrimitiveCodeDomSerializer.uex' path='docs/doc[@for="PrimitiveCodeDomSerializer.Default"]/*' />
        /// <devdoc>
        ///     Retrieves a default static instance of this serializer.
        /// </devdoc>
        public static PrimitiveCodeDomSerializer Default {
            get {
                if (defaultSerializer == null) {
                    defaultSerializer = new PrimitiveCodeDomSerializer();
                }
                return defaultSerializer;
            }
        }
        
        /// <include file='doc\PrimitiveCodeDomSerializer.uex' path='docs/doc[@for="PrimitiveCodeDomSerializer.Deserialize"]/*' />
        /// <devdoc>
        ///     Deserilizes the given CodeDom object into a real object.  This
        ///     will use the serialization manager to create objects and resolve
        ///     data types.  The root of the object graph is returned.
        /// </devdoc>
        public override object Deserialize(IDesignerSerializationManager manager, object codeObject) {
            object instance = null;
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "PrimitiveCodeDomSerializer::Deserialize");
            Debug.Indent();
            
            Debug.WriteLineIf(traceSerialization.TraceWarning && !(codeObject is CodePrimitiveExpression), "WARNING: Code object is not CodePrimitiveExpression.");
            if (codeObject is CodePrimitiveExpression) {
                instance = ((CodePrimitiveExpression)codeObject).Value;
            }
            
            Debug.Unindent();
            return instance;
        }
            
        /// <include file='doc\PrimitiveCodeDomSerializer.uex' path='docs/doc[@for="PrimitiveCodeDomSerializer.Serialize"]/*' />
        /// <devdoc>
        ///     Serializes the given object into a CodeDom object.
        /// </devdoc>
        public override object Serialize(IDesignerSerializationManager manager, object value) {
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "PrimitiveCodeDomSerializer::Serialize");
            Debug.Indent();
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Value: " + (value == null ? "(null)" : value.ToString()));
            Debug.Unindent();

            if (value == null 
                || value is string
                || value is bool
                || value is char
                || value is int
                || value is float
                || value is double) {
                
                return new CodePrimitiveExpression(value);
            }

            // generate a cast for non-int types because we won't parse them properly otherwise because we won't know to convert
            // them to the narrow form.
            //
            return new CodeCastExpression(new CodeTypeReference(value.GetType()), new CodePrimitiveExpression(value));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\drawing\system\drawing\design\bitmapeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="BitmapEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Design {
    using System.Runtime.Serialization.Formatters;

    using System.Diagnostics;
    using System;
    using System.IO;
    using System.Collections;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;

    /// <include file='doc\BitmapEditor.uex' path='docs/doc[@for="BitmapEditor"]/*' />
    /// <devdoc>
    ///    <para>Provides an editor that can perform default file searching for bitmap (.bmp)
    ///       files.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class BitmapEditor : ImageEditor {

        /// <include file='doc\BitmapEditor.uex' path='docs/doc[@for="BitmapEditor.GetFileDialogDescription"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override string GetFileDialogDescription() {
            return SR.GetString(SR.bitmapFileDescription);
        }

        /// <include file='doc\BitmapEditor.uex' path='docs/doc[@for="BitmapEditor.GetExtensions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override string[] GetExtensions() {
            return new string[] { "bmp","gif","jpg","jpeg", "png", "ico" };
        }

        /// <include file='doc\BitmapEditor.uex' path='docs/doc[@for="BitmapEditor.LoadFromStream"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override Image LoadFromStream(Stream stream) {
            return new Bitmap(stream);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\drawing\system\drawing\design\contentalignmenteditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ContentAlignmentEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing.Design {
    
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using Microsoft.Win32;    
    using System.ComponentModel.Design;
    using System.Drawing;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    /// <internalonly/>
    /// <include file='doc\ContentAlignmentEditor.uex' path='docs/doc[@for="ContentAlignmentEditor"]/*' />
    /// <devdoc>
    /// <para> Provides a <see cref='System.Drawing.Design.UITypeEditor'/> for
    ///    visually editing content alignment.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ContentAlignmentEditor : UITypeEditor {
    
        private ContentUI contentUI;
    
        /// <include file='doc\ContentAlignmentEditor.uex' path='docs/doc[@for="ContentAlignmentEditor.EditValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Edits the given object value using
        ///       the editor style provided by GetEditStyle.
        ///    </para>
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {
        
            object returnValue = value;
        
            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));
                
                if (edSvc != null) {
                    if (contentUI == null) {
                        contentUI = new ContentUI();
                    }
                    contentUI.Start(edSvc, value);
                    edSvc.DropDownControl(contentUI);
                    value = contentUI.Value;
                    contentUI.End();
                }
            }
            
            return value;
        }

        /// <include file='doc\ContentAlignmentEditor.uex' path='docs/doc[@for="ContentAlignmentEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the editing style of the Edit method.
        ///    </para>
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.DropDown;
        }
        
        /// <include file='doc\ContentAlignmentEditor.uex' path='docs/doc[@for="ContentAlignmentEditor.ContentUI"]/*' />
        /// <devdoc>
        ///      Control we use to provide the content alignment UI.
        /// </devdoc>
        private class ContentUI : Control {
        
            private IWindowsFormsEditorService edSvc;
            private object value;

            private RadioButton topLeft = new RadioButton();
            private RadioButton topCenter = new RadioButton();
            private RadioButton topRight = new RadioButton();
            private RadioButton middleLeft = new RadioButton();
            private RadioButton middleCenter = new RadioButton();
            private RadioButton middleRight = new RadioButton();
            private RadioButton bottomLeft = new RadioButton();
            private RadioButton bottomCenter = new RadioButton();
            private RadioButton bottomRight = new RadioButton();

            /// <include file='doc\ContentAlignmentEditor.uex' path='docs/doc[@for="ContentAlignmentEditor.ContentUI.ContentUI"]/*' />
            /// <devdoc>
            /// </devdoc>
            public ContentUI() {
                InitComponent();
            }
            
            /// <include file='doc\ContentAlignmentEditor.uex' path='docs/doc[@for="ContentAlignmentEditor.ContentUI.Align"]/*' />
            /// <devdoc>
            /// </devdoc>
            private ContentAlignment Align {
                get {
                    if (topLeft.Checked) {
                        return ContentAlignment.TopLeft;
                    }
                    else if (topCenter.Checked) {
                        return ContentAlignment.TopCenter;
                    }
                    else if (topRight.Checked) {
                        return ContentAlignment.TopRight;
                    }
                    else if (middleLeft.Checked) {
                        return ContentAlignment.MiddleLeft;
                    }
                    else if (middleCenter.Checked) {
                        return ContentAlignment.MiddleCenter;
                    }
                    else if (middleRight.Checked) {
                        return ContentAlignment.MiddleRight;
                    }
                    else if (bottomLeft.Checked) {
                        return ContentAlignment.BottomLeft;
                    }
                    else if (bottomCenter.Checked) {
                        return ContentAlignment.BottomCenter;
                    }
                    else {
                        return ContentAlignment.BottomRight;
                    }
                }
                set {
                    switch (value) {
                        case ContentAlignment.TopLeft:
                            topLeft.Checked = true;
                            break;
                        case ContentAlignment.TopCenter:
                            topCenter.Checked = true;
                            break;
                        case ContentAlignment.TopRight:
                            topRight.Checked = true;
                            break;
                        case ContentAlignment.MiddleLeft:
                            middleLeft.Checked = true;
                            break;
                        case ContentAlignment.MiddleCenter:
                            middleCenter.Checked = true;
                            break;
                        case ContentAlignment.MiddleRight:
                            middleRight.Checked = true;
                            break;
                        case ContentAlignment.BottomLeft:
                            bottomLeft.Checked = true;
                            break;
                        case ContentAlignment.BottomCenter:
                            bottomCenter.Checked = true;
                            break;
                        case ContentAlignment.BottomRight:
                            bottomRight.Checked = true;
                            break;
                    }
                }
            }
            
            protected override bool ShowFocusCues {
               get {
                    return true;
               }
            }

            /// <include file='doc\ContentAlignmentEditor.uex' path='docs/doc[@for="ContentAlignmentEditor.ContentUI.Value"]/*' />
            /// <devdoc>
            /// </devdoc>
            public object Value {
                get {
                    return value;
                }
            }
            
            /// <include file='doc\ContentAlignmentEditor.uex' path='docs/doc[@for="ContentAlignmentEditor.ContentUI.End"]/*' />
            /// <devdoc>
            /// </devdoc>
            public void End() {
                edSvc = null;
                value = null;
            }
            
            /// <include file='doc\ContentAlignmentEditor.uex' path='docs/doc[@for="ContentAlignmentEditor.ContentUI.InitComponent"]/*' />
            /// <devdoc>
            /// </devdoc>
            private void InitComponent() {
                this.Size = new Size(125, 89);
                this.BackColor = SystemColors.Control;
                this.ForeColor = SystemColors.ControlText;

                topLeft.Size = new Size(24, 25);
                topLeft.TabIndex = 8;
                topLeft.Text = "";
                topLeft.Appearance = Appearance.Button;
                topLeft.Click += new EventHandler(this.OptionClick);
                topLeft.AccessibleName = SR.GetString(SR.ContentAlignmentEditorTopLeftAccName);

                topCenter.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
                topCenter.Location = new Point(32, 0);
                topCenter.Size = new Size(59, 25);
                topCenter.TabIndex = 0;
                topCenter.Text = "";
                topCenter.Appearance = Appearance.Button;
                topCenter.Click += new EventHandler(this.OptionClick);
                topCenter.AccessibleName = SR.GetString(SR.ContentAlignmentEditorTopCenterAccName);

                topRight.Anchor = AnchorStyles.Top | AnchorStyles.Right;
                topRight.Location = new Point(99, 0);
                topRight.Size = new Size(24, 25);
                topRight.TabIndex = 1;
                topRight.Text = "";
                topRight.Appearance = Appearance.Button;
                topRight.Click += new EventHandler(this.OptionClick);
                topRight.AccessibleName = SR.GetString(SR.ContentAlignmentEditorTopRightAccName);

                middleLeft.Location = new Point(0, 32);
                middleLeft.Size = new Size(24, 25);
                middleLeft.TabIndex = 2;
                middleLeft.Text = "";
                middleLeft.Appearance = Appearance.Button;
                middleLeft.Click += new EventHandler(this.OptionClick);
                middleLeft.AccessibleName = SR.GetString(SR.ContentAlignmentEditorMiddleLeftAccName);

                middleCenter.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
                middleCenter.Location = new Point(32, 32);
                middleCenter.Size = new Size(59, 25);
                middleCenter.TabIndex = 3;
                middleCenter.Text = "";
                middleCenter.Appearance = Appearance.Button;
                middleCenter.Click += new EventHandler(this.OptionClick);
                middleCenter.AccessibleName = SR.GetString(SR.ContentAlignmentEditorMiddleCenterAccName);

                middleRight.Anchor = AnchorStyles.Top | AnchorStyles.Right;
                middleRight.Location = new Point(99, 32);
                middleRight.Size = new Size(24, 25);
                middleRight.TabIndex = 4;
                middleRight.Text = "";
                middleRight.Appearance = Appearance.Button;
                middleRight.Click += new EventHandler(this.OptionClick);
                middleRight.AccessibleName = SR.GetString(SR.ContentAlignmentEditorMiddleRightAccName);

                bottomLeft.Location = new Point(0, 64);
                bottomLeft.Size = new Size(24, 25);
                bottomLeft.TabIndex = 5;
                bottomLeft.Text = "";
                bottomLeft.Appearance = Appearance.Button;
                bottomLeft.Click += new EventHandler(this.OptionClick);
                bottomLeft.AccessibleName = SR.GetString(SR.ContentAlignmentEditorBottomLeftAccName);

                bottomCenter.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
                bottomCenter.Location = new Point(32, 64);
                bottomCenter.Size = new Size(59, 25);
                bottomCenter.TabIndex = 6;
                bottomCenter.Text = "";
                bottomCenter.Appearance = Appearance.Button;
                bottomCenter.Click += new EventHandler(this.OptionClick);
                bottomCenter.AccessibleName = SR.GetString(SR.ContentAlignmentEditorBottomCenterAccName);

                bottomRight.Anchor = AnchorStyles.Top | AnchorStyles.Right;
                bottomRight.Location = new Point(99, 64);
                bottomRight.Size = new Size(24, 25);
                bottomRight.TabIndex = 7;
                bottomRight.Text = "";
                bottomRight.Appearance = Appearance.Button;
                bottomRight.Click += new EventHandler(this.OptionClick);
                bottomRight.AccessibleName = SR.GetString(SR.ContentAlignmentEditorBottomRightAccName);

                this.Controls.Clear();
                this.Controls.AddRange(new Control[]{
                                        bottomRight,
                                        bottomCenter,
                                        bottomLeft,
                                        middleRight,
                                        middleCenter,
                                        middleLeft,
                                        topRight,
                                        topCenter,
                                        topLeft});
            }
            
            protected override bool IsInputKey(System.Windows.Forms.Keys keyData) {
                switch (keyData) {
                    case Keys.Left:
                    case Keys.Right:
                    case Keys.Up:
                    case Keys.Down:
                        //here, we will return false, 'cause we want the arrow keys
                        //to get picked up by the process key method below
                        return false;
                }
                return base.IsInputKey(keyData);
            }
        
            /// <include file='doc\ContentAlignmentEditor.uex' path='docs/doc[@for="ContentAlignmentEditor.ContentUI.OptionClick"]/*' />
            /// <devdoc>
            /// </devdoc>
            private void OptionClick(object sender, EventArgs e) {
                value = Align;
                edSvc.CloseDropDown();
            }
                
            /// <include file='doc\ContentAlignmentEditor.uex' path='docs/doc[@for="ContentAlignmentEditor.ContentUI.Start"]/*' />
            /// <devdoc>
            /// </devdoc>
            public void Start(IWindowsFormsEditorService edSvc, object value) {
                this.edSvc = edSvc;
                this.value = value;
                
                ContentAlignment align;
                
                if (value == null) {
                    align = ContentAlignment.MiddleLeft;
                }
                else {
                    align = (ContentAlignment)value;
                }
                
                Align = align;
            }
            
            /// <include file='doc\ContentAlignmentEditor.uex' path='docs/doc[@for="ContentAlignmentEditor.ContentUI.ProcessDialogKey"]/*' />
            /// <devdoc>
            ///     Here, we handle the return, tab, and escape keys appropriately
            /// </devdoc>
            protected override bool ProcessDialogKey(Keys keyData) {


                RadioButton checkedControl = CheckedControl;
                
                if ((keyData & Keys.KeyCode) == Keys.Left) {
                        
                    if (checkedControl == bottomRight) {
                        CheckedControl = bottomCenter;
                    }
                    else if (checkedControl == middleRight) {
                        CheckedControl = middleCenter;
                    }
                    else if (checkedControl == topRight) {
                        CheckedControl = topCenter;
                    }
                    else if (checkedControl == bottomCenter) {
                        CheckedControl = bottomLeft;
                    }
                    else if (checkedControl == middleCenter) {
                        CheckedControl = middleLeft;
                    }
                    else if (checkedControl == topCenter) {
                        CheckedControl = topLeft;
                    }
                    return true;
                }

                else if ((keyData & Keys.KeyCode) == Keys.Right) {
                    
                    if (checkedControl == bottomLeft) {
                        CheckedControl = bottomCenter;
                    }
                    else if (checkedControl == middleLeft) {
                        CheckedControl = middleCenter;
                    }
                    else if (checkedControl == topLeft) {
                        CheckedControl = topCenter;
                    }
                    else if (checkedControl == bottomCenter) {
                        CheckedControl = bottomRight;
                    }
                    else if (checkedControl == middleCenter) {
                        CheckedControl = middleRight;
                    }
                    else if (checkedControl == topCenter) {
                        CheckedControl = topRight;
                    }
                    return true;
                }

                else if ((keyData & Keys.KeyCode) == Keys.Up) {
                    
                    if (checkedControl == bottomRight) {
                        CheckedControl = middleRight;
                    }
                    else if (checkedControl == middleRight) {
                        CheckedControl = topRight;
                    }
                    else if (checkedControl == bottomCenter) {

                        CheckedControl = middleCenter;
                    }
                    else if (checkedControl == middleCenter) {
                        CheckedControl = topCenter;
                    }
                    else if (checkedControl == bottomLeft) {
                        CheckedControl = middleLeft;
                    }
                    else if (checkedControl == middleLeft) {
                        CheckedControl = topLeft;
                    }
                    return true;
                }

                else if ((keyData & Keys.KeyCode) == Keys.Down) {
                    
                    if (checkedControl == topRight) {
                        CheckedControl = middleRight;
                    }
                    else if (checkedControl == middleRight) {
                        CheckedControl = bottomRight;
                    }
                    else if (checkedControl == topCenter) {
                        CheckedControl = middleCenter;
                    }
                    else if (checkedControl == middleCenter) {
                        CheckedControl = bottomCenter;
                    }
                    else if (checkedControl == topLeft) {
                        CheckedControl = middleLeft;
                    }
                    else if (checkedControl == middleLeft) {
                        CheckedControl = bottomLeft;
                    }
                    return true;
                }

                else if ((keyData & Keys.KeyCode) == Keys.Space) {
                    this.OptionClick(this, EventArgs.Empty);
                    return true;
                }

                else if ((keyData & Keys.KeyCode) == Keys.Return && (keyData & (Keys.Alt | Keys.Control)) == 0) {
                    this.OptionClick(this, EventArgs.Empty);
                    return true;
                }
                else if ((keyData & Keys.KeyCode) == Keys.Escape && (keyData & (Keys.Alt | Keys.Control)) == 0) {
                    edSvc.CloseDropDown();
                    return true;
                }
                else if ((keyData & Keys.KeyCode) == Keys.Tab && (keyData & (Keys.Alt | Keys.Control)) == 0) {

                    int nextTabIndex = CheckedControl.TabIndex + ((keyData & Keys.Shift) == 0 ? 1 : -1);
                    if (nextTabIndex < 0) {
                        nextTabIndex = Controls.Count - 1;
                    }
                    else if (nextTabIndex >= Controls.Count) {
                        nextTabIndex = 0;
                    }

                    for (int i = 0; i < Controls.Count; i++ ) {
                        if (Controls[i] is RadioButton && Controls[i].TabIndex == nextTabIndex) {
                            CheckedControl = (RadioButton)Controls[i];
                            return true;
                        }
                    }
                    return true;
                }
                
                return base.ProcessDialogKey(keyData);
            }            
            
            /// <include file='doc\ContentAlignmentEditor.uex' path='docs/doc[@for="ContentAlignmentEditor.ContentUI.CheckedControl"]/*' />
            /// <devdoc>
            ///     Gets/Sets the checked control value of our editor
            /// </devdoc>
            private RadioButton CheckedControl {
                get {
                    for (int i =0; i < Controls.Count; i++) {
                        if (Controls[i] is RadioButton && ((RadioButton)Controls[i]).Checked == true) {
                            return (RadioButton)Controls[i];
                        }
                    }
                    return middleLeft;
                }
                set {
                    CheckedControl.Checked = false;
                    value.Checked = true;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\drawing\system\drawing\design\fonteditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="FontEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing.Design {
    
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using System;
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.Drawing;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    /// <include file='doc\FontEditor.uex' path='docs/doc[@for="FontEditor"]/*' />
    /// <devdoc>
    ///    <para> Provides a font editor that
    ///       is used to visually select and configure a Font
    ///       object.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class FontEditor : UITypeEditor {
    
        private FontDialog fontDialog;
        private object     value;

        /// <include file='doc\FontEditor.uex' path='docs/doc[@for="FontEditor.EditValue"]/*' />
        /// <devdoc>
        ///      Edits the given object value using the editor style provided by
        ///      GetEditorStyle.  A service provider is provided so that any
        ///      required editing services can be obtained.
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {
        
            this.value = value;
        
            Debug.Assert(provider != null, "No service provider; we cannot edit the value");
            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));
                
                Debug.Assert(edSvc != null, "No editor service; we cannot edit the value");
                if (edSvc != null) {
                    if (fontDialog == null) {
                        fontDialog = new FontDialog();
                        fontDialog.ShowApply = false;
                        fontDialog.ShowColor = false;
                        fontDialog.AllowVerticalFonts = false;
                    }
                    
                    if (value is Font) {
                        fontDialog.Font = (Font)value;
                    }

                    IntPtr hwndFocus = UnsafeNativeMethods.GetFocus();
                    try {
                        if (fontDialog.ShowDialog() == DialogResult.OK) {
                            this.value = fontDialog.Font;
                        }
                    }
                    finally {
                        if (hwndFocus != IntPtr.Zero) {
                            UnsafeNativeMethods.SetFocus(hwndFocus);
                        }
                    }
                }
            }
            
            // Now pull out the updated value, if there was one.
            //
            value = this.value;
            this.value = null;
            
            return value;
        }

        /// <include file='doc\FontEditor.uex' path='docs/doc[@for="FontEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///      Retrieves the editing style of the Edit method.  If the method
        ///      is not supported, this will return None.
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.Modal;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\drawing\system\drawing\design\fontnameeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="FontNameEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing.Design {

    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.Globalization;
    using System.Reflection;
    using System.Windows.Forms;

    using System.ComponentModel;
    using System.IO;
    using System.Collections;
    using Microsoft.Win32;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;

    /// <internalonly/>
    /// <include file='doc\FontNameEditor.uex' path='docs/doc[@for="FontNameEditor"]/*' />
    /// <devdoc>
    ///    <para>Provides an editor that paints a glyph for the font name.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class FontNameEditor : UITypeEditor {

        /// <include file='doc\FontNameEditor.uex' path='docs/doc[@for="FontNameEditor.GetPaintValueSupported"]/*' />
        /// <devdoc>
        ///      Determines if this editor supports the painting of a representation
        ///      of an object's value.
        /// </devdoc>
        public override bool GetPaintValueSupported(ITypeDescriptorContext context) {
            return true;
        }

        /// <include file='doc\FontNameEditor.uex' path='docs/doc[@for="FontNameEditor.PaintValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Paints a representative value of the given object to the provided
        ///       canvas. Painting should be done within the boundaries of the
        ///       provided rectangle.
        ///    </para>
        /// </devdoc>
        public override void PaintValue(PaintValueEventArgs e) {
            if (e.Value is string) {

                if ((string)e.Value == "") {
                    // don't draw anything if we don't have a value.
                    return;
                }

                e.Graphics.FillRectangle(SystemBrushes.ActiveCaption, e.Bounds);

                string fontName = (string)e.Value;

                if (fontName != null && fontName.Length != 0) {
                    FontFamily family = null;

                    try {
                        family = new FontFamily(fontName);
                    }
                    catch {
                        // Ignore the exception if the fontName does not exist or is invalid...
                        // we just won't render a preview of the font at all
                    }
                    
                    if (family != null) {
                        // Adjust font size to fit nicely in the rectangle provided
                        float fontSize = (float) (e.Bounds.Height / 1.2);
                        Font font = null;

                        // Believe it or not, not all font families have a "normal" face.  Try normal, then italic, 
                        // then bold, then bold italic, then give up.
                        try {
                            font = new Font(family, fontSize, FontStyle.Regular, GraphicsUnit.Pixel);
                        }
                        catch (Exception) {
                            try {
                                font = new Font(family, fontSize, FontStyle.Italic, GraphicsUnit.Pixel);
                            }
                            catch (Exception) {
                                try {
                                    font = new Font(family, fontSize, FontStyle.Bold, GraphicsUnit.Pixel);
                                }
                                catch (Exception) {
                                    try {
                                        font = new Font(family, fontSize, FontStyle.Bold | FontStyle.Italic, GraphicsUnit.Pixel);
                                    }
                                    catch (Exception) {
                                        // No font style we can think of is supported
                                    }
                                }
                            }
                        }

                        if (font != null) {
                            e.Graphics.DrawString("abcd", font, SystemBrushes.ActiveCaptionText, e.Bounds);
                            font.Dispose();
                        }
                    }
                }

                e.Graphics.DrawLine(SystemPens.WindowFrame, e.Bounds.Right, e.Bounds.Y, e.Bounds.Right, e.Bounds.Bottom);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\drawing\system\drawing\design\cursoreditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="CursorEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Design {
    using System.Runtime.Serialization.Formatters;

    using System.Diagnostics;
    using System;
    using System.IO;
    using System.Collections;
    using System.Reflection;
    
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;
    using Microsoft.Win32;

    /// <internalonly/>
    /// <include file='doc\CursorEditor.uex' path='docs/doc[@for="CursorEditor"]/*' />
    /// <devdoc>
    ///    <para> Provides an editor that can perform default file searching for cursor (.cur)
    ///       files.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class CursorEditor : UITypeEditor {

        private CursorUI cursorUI;

        /// <include file='doc\CursorEditor.uex' path='docs/doc[@for="CursorEditor.EditValue"]/*' />
        /// <devdoc>
        ///      Edits the given object value using the editor style provided by
        ///      GetEditorStyle.  A service provider is provided so that any
        ///      required editing services can be obtained.
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, object value) {

            object returnValue = value;

            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));

                if (edSvc != null) {
                    if (cursorUI == null) {
                        cursorUI = new CursorUI(this);
                    }
                    cursorUI.Start(edSvc, value);
                    edSvc.DropDownControl(cursorUI);
                    value = cursorUI.Value;
                    cursorUI.End();
                }
            }

            return value;
        }

        /// <include file='doc\CursorEditor.uex' path='docs/doc[@for="CursorEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///      Retrieves the editing style of the Edit method.  If the method
        ///      is not supported, this will return None.
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.DropDown;
        }

        /// <include file='doc\CursorEditor.uex' path='docs/doc[@for="CursorEditor.CursorUI"]/*' />
        /// <devdoc>
        ///      The user interface for the cursor drop-down.  This is just an owner-drawn
        ///      list box.
        /// </devdoc>
        private class CursorUI : ListBox {
            private object value;
            private IWindowsFormsEditorService edSvc;
            private TypeConverter cursorConverter;
            private UITypeEditor editor;

            public CursorUI(UITypeEditor editor) {
                this.editor = editor;

                Height = 310;
                ItemHeight = (int) Math.Max(4 + Cursors.Default.Size.Height, Font.Height);
                DrawMode = DrawMode.OwnerDrawFixed;
                BorderStyle = BorderStyle.None;

                cursorConverter = TypeDescriptor.GetConverter(typeof(Cursor));
                Debug.Assert(cursorConverter.GetStandardValuesSupported(), "Converter '" + cursorConverter.ToString() + "' does not support a list of standard values.  We cannot provide a drop-down");

                // Fill the list with cursors.
                //
                if (cursorConverter.GetStandardValuesSupported()) {
                    foreach (object obj in cursorConverter.GetStandardValues()) {
                        Items.Add(obj);
                    }
                }
            }

            public object Value {
                get {
                    return value;
                }
            }

            public void End() {
                edSvc = null;
                value = null;
            }

            protected override void OnClick(EventArgs e) {
                base.OnClick(e);
                value = SelectedItem;
                edSvc.CloseDropDown();
            }

            protected override void OnDrawItem(DrawItemEventArgs die) {
                base.OnDrawItem(die);

                if (die.Index != -1) {
                    Cursor cursor = (Cursor)Items[die.Index];
                    string text = cursorConverter.ConvertToString(cursor);
                    Font font = die.Font;
                    Brush brushText = new SolidBrush(die.ForeColor);

                    die.DrawBackground();
                    die.Graphics.FillRectangle(SystemBrushes.Control, new Rectangle(die.Bounds.X + 2, die.Bounds.Y + 2, 32, die.Bounds.Height - 4));
                    die.Graphics.DrawRectangle(SystemPens.WindowText, new Rectangle(die.Bounds.X + 2, die.Bounds.Y + 2, 32 - 1, die.Bounds.Height - 4 - 1));

                    cursor.DrawStretched(die.Graphics, new Rectangle(die.Bounds.X + 2, die.Bounds.Y + 2, 32, die.Bounds.Height - 4));
                    die.Graphics.DrawString(text, font, brushText, die.Bounds.X + 36, die.Bounds.Y + (die.Bounds.Height - font.Height)/2);
                    
                    brushText.Dispose();
                }
            }

            protected override bool ProcessDialogKey(Keys keyData) {
                if ((keyData & Keys.KeyCode) == Keys.Return && (keyData & (Keys.Alt | Keys.Control)) == 0) {
                    OnClick( EventArgs.Empty );
                    return true;
                }
                
                return base.ProcessDialogKey(keyData);
            }

            public void Start(IWindowsFormsEditorService edSvc, object value) {
                this.edSvc = edSvc;
                this.value = value;

                // Select the current cursor
                //
                if (value != null) {
                    for (int i = 0; i < Items.Count; i++) {
                        if (Items[i] == value) {
                            SelectedIndex = i;
                            break;
                        }
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\serialization\rootcodedomserializer.cs ===
//------------------------------------------------------------------------------
// <copyright file="RootCodeDomSerializer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design.Serialization {

    using System.Design;
    using System;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Resources;
    using System.Runtime.Serialization;
    using System.Globalization;
    
    /// <include file='doc\RootCodeDomSerializer.uex' path='docs/doc[@for="RootCodeDomSerializer"]/*' />
    /// <devdoc>
    ///     This is our root serialization object.  It is responsible for organizing all of the
    ///     serialization for subsequent objects.  This inherits from ComponentCodeDomSerializer
    ///     in order to share useful methods.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class RootCodeDomSerializer : ComponentCodeDomSerializer, IDesignerSerializationProvider {
    
        // Used only during deserialization to provide name to object mapping.
        //
        private IDictionary      nameTable;
        private IDictionary      statementTable;
        private CodeMemberMethod initMethod;
        private bool             providerAdded;
        private bool             containerRequired;
        
        private static readonly Attribute[] designTimeProperties = new Attribute[] { DesignOnlyAttribute.Yes};
        private static readonly Attribute[] runTimeProperties = new Attribute[] { DesignOnlyAttribute.No};
        
        /// <include file='doc\RootCodeDomSerializer.uex' path='docs/doc[@for="RootCodeDomSerializer.ContainerName"]/*' />
        /// <devdoc>
        ///     The name of the IContainer we will use for components that require a container.
        ///     Note that compnent model serializer also has this property.
        /// </devdoc>
        public string ContainerName {
            get {
                return "components";
            }
        }
    
        /// <include file='doc\RootCodeDomSerializer.uex' path='docs/doc[@for="RootCodeDomSerializer.ContainerRequired"]/*' />
        /// <devdoc>
        ///     The component serializer will set this to true if it emitted a compnent declaration that required
        ///     a container.
        /// </devdoc>
        public bool ContainerRequired {
            get {
                return containerRequired;
            }
            set {
                containerRequired = value;
            }
        }
        
        /// <include file='doc\RootCodeDomSerializer.uex' path='docs/doc[@for="RootCodeDomSerializer.InitMethodName"]/*' />
        /// <devdoc>
        ///     The name of the method we will serialize into.  We always use this, so if there
        ///     is a need to change it down the road, we can make it virtual.
        /// </devdoc>
        public string InitMethodName {
            get {
                return "InitializeComponent";
            }
        }
    
        /// <include file='doc\RootCodeDomSerializer.uex' path='docs/doc[@for="RootCodeDomSerializer.AddStatement"]/*' />
        /// <devdoc>
        ///     Unility method that adds the given statement to our statementTable dictionary under the
        ///     given name.
        /// </devdoc>
        private void AddStatement(string name, CodeStatement statement) {
            OrderedCodeStatementCollection statements = (OrderedCodeStatementCollection)statementTable[name];
            
            if (statements == null) {
                statements = new OrderedCodeStatementCollection();

                // push in an order key so we know what position this item was in the list of declarations.
                // this allows us to preserve ZOrder.
                //
                statements.Order = statementTable.Count;
                statements.Name = name;
                statementTable[name] = statements;
            }
            
            statements.Add(statement);
        }
        
        /// <include file='doc\RootCodeDomSerializer.uex' path='docs/doc[@for="RootCodeDomSerializer.Deserialize"]/*' />
        /// <devdoc>
        ///     Deserilizes the given CodeDom element into a real object.  This
        ///     will use the serialization manager to create objects and resolve
        ///     data types.  The root of the object graph is returned.
        /// </devdoc>
        public override object Deserialize(IDesignerSerializationManager manager, object codeObject) {
        
            if (manager == null || codeObject == null) {
                throw new ArgumentNullException( manager == null ? "manager" : "codeObject");
            }
            
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "RootCodeDomSerializer::Deserialize");
            Debug.Indent();

            if (!(codeObject is CodeTypeDeclaration)) {
                Debug.Fail("RootCodeDomSerializer::Deserialize requires a CodeTypeDeclaration to parse");
                throw new ArgumentException(SR.GetString(SR.SerializerBadElementType, typeof(CodeTypeDeclaration).FullName));
            }

            // Determine case-sensitivity
            //
            bool caseInsensitive = false;
            CodeDomProvider provider = manager.GetService(typeof(CodeDomProvider)) as CodeDomProvider;
            if (provider != null) {
                caseInsensitive = ((provider.LanguageOptions & LanguageOptions.CaseInsensitive) != 0);
            } else {
                Debug.Fail("Unable to determine case sensitivity. Make sure CodeDomProvider is a service of the manager.");
            }

            // Get and initialize the document type.
            //
            CodeTypeDeclaration docType = (CodeTypeDeclaration)codeObject;
            CodeTypeReference baseType = null;
            foreach(CodeTypeReference typeRef in docType.BaseTypes) {
                Type t = manager.GetType(typeRef.BaseType);
                if (t != null && !(t.IsInterface)) {
                    baseType = typeRef;
                    break;
                }
            }
            
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Document type: " + docType.Name + " of type " + baseType.BaseType);
            Type type = manager.GetType(baseType.BaseType);
            if (type == null) {
                Exception ex = new SerializationException(SR.GetString(SR.SerializerTypeNotFound, baseType.BaseType));
                ex.HelpLink = SR.SerializerTypeNotFound;
                
                throw ex;
            }
            if (type.IsAbstract) {
                Exception ex = new SerializationException(SR.GetString(SR.SerializerTypeAbstract, type.FullName));
                ex.HelpLink = SR.SerializerTypeAbstract;
                
                throw ex;
            }
            
            ResolveNameEventHandler onResolveName = new ResolveNameEventHandler(OnResolveName);
            manager.ResolveName += onResolveName;
            
            if (!providerAdded) {
                providerAdded = true;
                manager.AddSerializationProvider(this);
            }
            
            object documentObject = manager.CreateInstance(type, null, docType.Name, true);
            
            // Now that we have the document type, we create a nametable and fill it with member declarations.
            // During this time we also search for our initialization method and save it off for later
            // processing.
            //
            nameTable = new HybridDictionary(docType.Members.Count, caseInsensitive);
            statementTable = new HybridDictionary(docType.Members.Count, caseInsensitive);
            initMethod = null;
            
            try {
                foreach(CodeTypeMember member in docType.Members) {
                    if (member is CodeMemberField) {
                        if (string.Compare(member.Name, docType.Name, caseInsensitive, CultureInfo.InvariantCulture) != 0) {
                            // always skip members with the same name as the type -- because that's the name
                            // we use when we resolve "base" and "this" items...
                            //
                            nameTable[member.Name] = member;
                        }
                    }
                    else if (initMethod == null && member is CodeMemberMethod) {
                        CodeMemberMethod method = (CodeMemberMethod)member;
                        if ((string.Compare(method.Name, InitMethodName, caseInsensitive, CultureInfo.InvariantCulture) == 0) && method.Parameters.Count == 0) {
                            initMethod = method;
                        }
                    }
                }
                
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Encountered " + nameTable.Keys.Count.ToString() + " members to deserialize.");
                Debug.WriteLineIf(traceSerialization.TraceWarning && initMethod == null, "WARNING : Init method '" + InitMethodName + "' wasn't found.");
                
                // We have the members, and possibly the init method.  Walk the init method looking for local variable declarations,
                // and add them to the pile too.
                //
                if (initMethod != null) {
                    foreach(CodeStatement statement in initMethod.Statements) {
                        if (statement is CodeVariableDeclarationStatement) {
                            CodeVariableDeclarationStatement local = (CodeVariableDeclarationStatement)statement;
                            nameTable[local.Name] = statement;
                        }
                    }
                }
                
                // Check for the case of a reference that has the same variable name as our root
                // object.  If we find such a reference, we pre-populate the name table with our
                // document object.  We don't really have to populate, but it is very important
                // that we don't leave the original field in there.  Otherwise, we will try to
                // load up the field, and since the class we're designing doesn't yet exist, this
                // will cause an error.
                //
                if (nameTable[docType.Name] != null) {
                    nameTable[docType.Name] = documentObject;
                }
            
                // We fill a "statement table" for everything in our init method.  This statement
                // table is a dictionary whose keys contain object names and whose values contain
                // a statement collection of all statements with a LHS resolving to an object
                // by that name.
                //
                if (initMethod != null) {
                    FillStatementTable(initMethod, docType.Name);
                }

                // Interesting problem.  The CodeDom parser may auto generate statements
                // that are associated with other methods. VB does this, for example, to 
                // create statements automatically for Handles clauses.  The problem with
                // this technique is that we will end up with statements that are related
                // to variables that live solely in user code and not in InitializeComponent.
                // We will attempt to construct instances of these objects with limited
                // success.  To guard against this, we check to see if the manager
                // even supports this feature, and if it does, we must walk each
                // statement.
                //
                PropertyDescriptor supportGenerate = manager.Properties["SupportsStatementGeneration"];
                if (supportGenerate != null && 
                    supportGenerate.PropertyType == typeof(bool) && 
                    ((bool)supportGenerate.GetValue(manager)) == true) {

                    // Ok, we must do the more expensive work of validating the statements we get.
                    //
                    foreach (string name in nameTable.Keys) {
                        OrderedCodeStatementCollection statements = (OrderedCodeStatementCollection)statementTable[name];

                        if (statements != null) {
                            bool acceptStatement = false;
                            foreach(CodeStatement statement in statements) {
                                object genFlag = statement.UserData["GeneratedStatement"];
                                if (genFlag == null || !(genFlag is bool) || !((bool)genFlag)) {
                                    acceptStatement = true;
                                    break;
                                }
                            }

                            if (!acceptStatement) {
                                statementTable.Remove(name);
                            }
                        }
                    }
                }

                // Design time properties must be resolved before runtime properties to make
                // sure that properties like "language" get established before we need to read
                // values out the resource bundle.                                                  
                //
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "--------------------------------------------------------------------");
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "     Beginning deserialization of " + docType.Name + " (design time)");
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "--------------------------------------------------------------------");
                
                // Deserialize design time properties for the root component and any inherited component.
                //
                IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                if (host != null) {
                    foreach(object comp in host.Container.Components) {
                        DeserializePropertiesFromResources(manager, comp, designTimeProperties);
                    }
                }
                
                // make sure we have fully deserialized everything that is referenced in the statement table.
                //
                object[] keyValues = new object[statementTable.Values.Count];
                statementTable.Values.CopyTo(keyValues, 0);

                // sort by the order so we deserialize in the same order the objects
                // were decleared in.
                //
                Array.Sort(keyValues, StatementOrderComparer.Default);

                foreach (OrderedCodeStatementCollection statements in keyValues) {
                    string name = statements.Name;
                    if (name != null && !name.Equals(docType.Name)) {
                        DeserializeName(manager, name);
                    }
                }
               
                // Now do the runtime part of the 
                // we must do the document class itself.
                //
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "--------------------------------------------------------------------");
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "     Beginning deserialization of " + docType.Name + " (run time)");
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "--------------------------------------------------------------------");
                CodeStatementCollection rootStatements = (CodeStatementCollection)statementTable[docType.Name];
                if (rootStatements != null && rootStatements.Count > 0) {
                    foreach(CodeStatement statement in rootStatements) {
                        DeserializeStatement(manager, statement);
                    }
                }
            }
            finally {
                manager.ResolveName -= onResolveName;
                initMethod = null;
                nameTable = null;
                statementTable = null;
            }
            
            Debug.Unindent();
            return documentObject;
        }
        
        /// <include file='doc\RootCodeDomSerializer.uex' path='docs/doc[@for="RootCodeDomSerializer.DeserializeName"]/*' />
        /// <devdoc>
        ///     This takes the given name and deserializes it from our name table.  Before blindly
        ///     deserializing it checks the contents of the name table to see if the object already
        ///     exists within it.  We do this because deserializing one object may call back
        ///     into us through OnResolveName and deserialize another.
        /// </devdoc>
        private object DeserializeName(IDesignerSerializationManager manager, string name) {
            string typeName = null;
            Type type = null;
        
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "RootCodeDomSerializer::DeserializeName");
            Debug.Indent();
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Name: " + name);
            
            // If the name we're looking for isn't in our dictionary, we return null.  It is up to the caller
            // to decide if this is an error or not.
            //
            object value = nameTable[name];
            CodeMemberField field = null;
            
            Debug.WriteLineIf(traceSerialization.TraceVerbose && !(value is CodeObject), "Name already deserialized.  Type: " + (value == null ? "(null)" : value.GetType().Name));
            
            if (value is CodeObject) {
                // If we fail, don't return a CodeDom element to the caller!
                //
                CodeObject codeObject = (CodeObject)value;
                value = null;

                // Clear out our nametable entry here -- A badly written serializer may cause a recursion here, and
                // we want to stop it.
                //
                nameTable[name] = null;
                
                // What kind of code object is this?
                //
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "CodeDom type: " + codeObject.GetType().Name);
                if (codeObject is CodeVariableDeclarationStatement) {
                    CodeVariableDeclarationStatement declaration = (CodeVariableDeclarationStatement)codeObject;
                    typeName = declaration.Type.BaseType;
                }
                else if (codeObject is CodeMemberField) {
                    field = (CodeMemberField)codeObject;
                    typeName = field.Type.BaseType;
                }
            }
            else if (value != null) {
                return value;
            }
            else {
                IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                if (host != null) {
                    Debug.WriteLineIf(traceSerialization.TraceVerbose, "Try to get the type name from the designer host: " + name);
                    IComponent comp = host.Container.Components[name];
                    if (comp != null) {
                        typeName = comp.GetType().FullName;
                        
                        // we had to go to the host here, so there isn't a nametable entry here --
                        // push in the component here so we don't accidentally recurse when
                        // we try to deserialize this object.
                        //
                        nameTable[name] = comp;
                    }
                }
            }
                
            // Special case our container name to point to the designer host -- it is our container at design time.
            //
            if (name.Equals(ContainerName)) {
                IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                if (host != null) {
                    Debug.WriteLineIf(traceSerialization.TraceVerbose, "Substituted designer host's container");
                    value = host.Container;
                }
            }
            else if (typeName != null) {
                // Default case -- something that needs to be deserialized
                //
                type = manager.GetType(typeName);
                
                if (type == null) {
                    Debug.WriteLineIf(traceSerialization.TraceError, "*** Type does not exist: " + typeName);
                    manager.ReportError(new SerializationException(SR.GetString(SR.SerializerTypeNotFound, typeName)));
                }
                else {
                    CodeStatementCollection statements = (CodeStatementCollection)statementTable[name];
                    if (statements != null && statements.Count > 0) {
                        CodeDomSerializer serializer = (CodeDomSerializer)manager.GetSerializer(type, typeof(CodeDomSerializer));
                        if (serializer == null) {
                            // We report this as an error.  This indicates that there are code statements
                            // in initialize component that we do not know how to load.
                            //
                            Debug.WriteLineIf(traceSerialization.TraceError, "*** Type referenced in init method has no serializer: " + type.Name + " ***");
                            manager.ReportError(SR.GetString(SR.SerializerNoSerializerForComponent, type.FullName));
                        }
                        else {
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "--------------------------------------------------------------------");
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "     Beginning deserialization of " + name);
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "--------------------------------------------------------------------");

                            try {
                                value = serializer.Deserialize(manager, statements);
    
                                // Search for a modifiers property, and set it.
                                //
                                if (value != null && field != null) {
                                    PropertyDescriptor prop = TypeDescriptor.GetProperties(value)["Modifiers"];
                                    if (prop != null && prop.PropertyType == typeof(MemberAttributes)) {
                                        MemberAttributes modifiers = field.Attributes & MemberAttributes.AccessMask;
                                        prop.SetValue(value, modifiers);
                                    }
                                }
                            }
                            catch (Exception ex) {
                                manager.ReportError(ex);
                            }
                        }
                    }
                }
            }
            
            nameTable[name] = value;
            
            Debug.Unindent();
            return value;
        }

        /// <include file='doc\RootCodeDomSerializer.uex' path='docs/doc[@for="RootCodeDomSerializer.FillStatementTable"]/*' />
        /// <devdoc>
        ///     This method enumerates all the statements in the given method.  For those statements who
        ///     have a LHS that points to a name in our nametable, we add the statement to a Statement
        ///     Collection within the statementTable dictionary.  This allows us to very quickly
        ///     put to gether what statements are associated with what names.
        /// </devdoc>
        private void FillStatementTable(CodeMemberMethod method, string className) {
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "RootCodeDomSerializer::FillStatementTable");
            Debug.Indent();
            
            // Look in the method body to try to find statements with a LHS that
            // points to a name in our nametable.
            //
            foreach(CodeStatement statement in method.Statements) {
            
                CodeExpression expression = null;
                
                if (statement is CodeAssignStatement) {
                    Debug.WriteLineIf(traceSerialization.TraceVerbose, "Processing CodeAssignStatement");
                    expression = ((CodeAssignStatement)statement).Left;
                }
                else if (statement is CodeAttachEventStatement) {
                    Debug.WriteLineIf(traceSerialization.TraceVerbose, "Processing CodeAttachEventStatement");
                    expression = ((CodeAttachEventStatement)statement).Event;
                }
                else if (statement is CodeRemoveEventStatement) {
                    Debug.WriteLineIf(traceSerialization.TraceVerbose, "Processing CodeRemoveEventStatement");
                    expression = ((CodeRemoveEventStatement)statement).Event;
                }
                else if (statement is CodeExpressionStatement) {
                    Debug.WriteLineIf(traceSerialization.TraceVerbose, "Processing CodeExpressionStatement");
                    expression = ((CodeExpressionStatement)statement).Expression;
                }
                else if (statement is CodeVariableDeclarationStatement) {
                
                    // Local variables are different because their LHS contains no expression.  
                    //
                    Debug.WriteLineIf(traceSerialization.TraceVerbose, "Processing CodeVariableDeclarationStatement");
                    CodeVariableDeclarationStatement localVar = (CodeVariableDeclarationStatement)statement;
                    if (localVar.InitExpression != null && nameTable.Contains(localVar.Name)) {
                        AddStatement(localVar.Name, localVar);
                    }
                    expression = null;
                }
                
                if (expression != null) {
                
                    // Simplify the expression as much as we can, looking for our target
                    // object in the process.  If we find an expression that refers to our target
                    // object, we're done and can move on to the next statement.
                    //
                    while(true) {
                        if (expression is CodeCastExpression) {
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Simplifying CodeCastExpression");
                            expression = ((CodeCastExpression)expression).Expression;
                        }
                        else if (expression is CodeDelegateCreateExpression) {
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Simplifying CodeDelegateCreateExpression");
                            expression = ((CodeDelegateCreateExpression)expression).TargetObject;
                        }
                        else if (expression is CodeDelegateInvokeExpression) {
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Simplifying CodeDelegateInvokeExpression");
                            expression = ((CodeDelegateInvokeExpression)expression).TargetObject;
                        }
                        else if (expression is CodeDirectionExpression) {
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Simplifying CodeDirectionExpression");
                            expression = ((CodeDirectionExpression)expression).Expression;
                        }
                        else if (expression is CodeEventReferenceExpression) {
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Simplifying CodeEventReferenceExpression");
                            expression = ((CodeEventReferenceExpression)expression).TargetObject;
                        }
                        else if (expression is CodeMethodInvokeExpression) {
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Simplifying CodeMethodInvokeExpression");
                            expression = ((CodeMethodInvokeExpression)expression).Method;
                        }
                        else if (expression is CodeMethodReferenceExpression) {
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Simplifying CodeMethodReferenceExpression");
                            expression = ((CodeMethodReferenceExpression)expression).TargetObject;
                        }
                        else if (expression is CodeArrayIndexerExpression) {
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Simplifying CodeArrayIndexerExpression");
                            expression = ((CodeArrayIndexerExpression)expression).TargetObject;
                        }
                        else if (expression is CodeFieldReferenceExpression) {
                        
                            // For fields we need to check to see if the field name is equal to the target object.
                            // If it is, then we have the expression we want.  We can add the statement here
                            // and then break out of our loop.
                            //
                            // Note:  We cannot validate that this is a name in our nametable.  The nametable
                            // only contains names we have discovered through code parsing and will not include
                            // data from any inherited objects.  We accept the field now, and then fail later
                            // if we try to resolve it to an object and we can't find it.
                            //
                            CodeFieldReferenceExpression field = (CodeFieldReferenceExpression)expression;
                            if (field.TargetObject is CodeThisReferenceExpression) {
                                AddStatement(field.FieldName, statement);
                                break;
                            }
                            else {
                                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Simplifying CodeFieldReferenceExpression");
                                expression = field.TargetObject;
                            }
                        }
                        else if (expression is CodePropertyReferenceExpression) {
                        
                            // For properties we need to check to see if the property name is equal to the target object.
                            // If it is, then we have the expression we want.  We can add the statement here
                            // and then break out of our loop.
                            //
                            CodePropertyReferenceExpression property = (CodePropertyReferenceExpression)expression;
                            if (property.TargetObject is CodeThisReferenceExpression && nameTable.Contains(property.PropertyName)) {
                                AddStatement(property.PropertyName, statement);
                                break;
                            }
                            else {
                                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Simplifying CodePropertyReferenceExpression");
                                expression = property.TargetObject;
                            }
                        }
                        else if (expression is CodeVariableReferenceExpression) {
                        
                            // For variables we need to check to see if the variable name is equal to the target object.
                            // If it is, then we have the expression we want.  We can add the statement here
                            // and then break out of our loop.
                            //
                            CodeVariableReferenceExpression variable = (CodeVariableReferenceExpression)expression;
                            if (nameTable.Contains(variable.VariableName)) {
                                AddStatement(variable.VariableName, statement);
                            }
                            else {
                                Debug.WriteLineIf(traceSerialization.TraceWarning, "WARNING: Variable " + variable.VariableName + " used before it was declared.");
                            }
                            break;
                        }
                        else if (expression is CodeThisReferenceExpression || expression is CodeBaseReferenceExpression) {
                        
                            // We cannot go any further than "this".  So, we break out
                            // of the loop.  We file this statement under the root object.
                            //
                            AddStatement(className, statement);
                            break;
                        }
                        else {
                            // We cannot simplify this expression any further, so we stop looping.
                            //
                            break;
                        }
                    }
                }
            }
            
            Debug.Unindent();
        }
        
        /// <include file='doc\RootCodeDomSerializer.uex' path='docs/doc[@for="RootCodeDomSerializer.GetMethodName"]/*' />
        /// <devdoc>
        ///     If this statement is a method invoke, this gets the name of the method.
        ///     Otherwise, it returns null.
        /// </devdoc>
        private string GetMethodName(object statement) {
            string name = null;
            
            while(name == null) {
                if (statement is CodeExpressionStatement) {
                    statement = ((CodeExpressionStatement)statement).Expression;
                }
                else if (statement is CodeMethodInvokeExpression) {
                    statement = ((CodeMethodInvokeExpression)statement).Method;
                }
                else if (statement is CodeMethodReferenceExpression) {
                    return ((CodeMethodReferenceExpression)statement).MethodName;
                }
                else {
                    break;
                }
            }
            
            return name;
        }
        
        /// <include file='doc\RootCodeDomSerializer.uex' path='docs/doc[@for="RootCodeDomSerializer.OnResolveName"]/*' />
        /// <devdoc>
        ///     Called by the serialization manager to resolve a name to an object.
        /// </devdoc>
        private void OnResolveName(object sender, ResolveNameEventArgs e) {
            Debug.Assert(nameTable != null, "OnResolveName called and we are not deserializing!");

            Debug.WriteLineIf(traceSerialization.TraceVerbose, "RootCodeDomSerializer::OnResolveName");
            Debug.Indent();
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Name: " + e.Name);
            
            // If someone else already found a value, who are we to complain?
            //
            if (e.Value != null) {
                Debug.WriteLineIf(traceSerialization.TraceWarning, "WARNING: Another name resolver has already found the value for " + e.Name + ".");
                Debug.Unindent();
                return;
            }
            
            IDesignerSerializationManager manager = (IDesignerSerializationManager)sender;
            object value = DeserializeName(manager, e.Name);
            
            Debug.Unindent();
            e.Value = value;
        }
    
#if DEBUG
        static int NextSerializeSessionId = 0;
#endif

        /// <include file='doc\RootCodeDomSerializer.uex' path='docs/doc[@for="RootCodeDomSerializer.Serialize"]/*' />
        /// <devdoc>
        ///     Serializes the given object into a CodeDom object.
        /// </devdoc>
        public override object Serialize(IDesignerSerializationManager manager, object value) {
#if DEBUG
            int serializeSessionId = ++NextSerializeSessionId;
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "RootCodeDomSerializer::Serialize  id=" + serializeSessionId);
#endif
            Debug.Indent();
            
            if (manager == null || value == null) {
                throw new ArgumentNullException( manager == null ? "manager" : "value");
            }

            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Value: " + value.ToString());
            
            // As the root serializer, we are responsible for creating the code class for our
            // object.  We will create the class, and the init method, and then push both
            // on the context stack.
            // These will be used by other serializers to insert statements and members.
            //
            CodeTypeDeclaration docType = new CodeTypeDeclaration(manager.GetName(value));
            docType.BaseTypes.Add(value.GetType());
            
            containerRequired = false;
            manager.Context.Push(this);
            manager.Context.Push(docType);
            
            if (!providerAdded) {
                providerAdded = true;
                manager.AddSerializationProvider(this);
            }
            
            try {
                Debug.WriteLineIf(traceSerialization.TraceWarning && !(value is IComponent), "WARNING: Object " + value.ToString() + " is not an IComponent but the root serializer is attempting to serialize it.");
                if (value is IComponent) {
                    ISite site = ((IComponent)value).Site;
                    Debug.WriteLineIf(traceSerialization.TraceWarning && site == null, "WARNING: Object " + value.ToString() + " is not sited but the root serializer is attempting to serialize it.");
                    if (site != null) {
                    
                        // Do each component, skipping us, since we handle our own serialization.
                        //
                        ArrayList codeElements = new ArrayList();
                        CodeStatementCollection rootStatements = new CodeStatementCollection();
                        
                        ICollection components = site.Container.Components;
                        
                        // This looks really sweet, but is it worth it?  We take the
                        // perf hit of a quicksort + the allocation overhead of 4
                        // bytes for each component.  Profiles show this as a 2% 
                        // cost for a form with 100 controls.  Let's meet the perf
                        // goals first, then consider uncommenting this.
                        //
                        //ArrayList sortedComponents = new ArrayList(components);
                        //sortedComponents.Sort(ComponentComparer.Default);
                        //components = sortedComponents;
                        
                        foreach(IComponent component in components) {
                            if (component != value) {
                                Debug.WriteLineIf(traceSerialization.TraceVerbose, "--------------------------------------------------------------------");
                                Debug.WriteLineIf(traceSerialization.TraceVerbose, "     Beginning serialization of " + component.Site.Name);
                                Debug.WriteLineIf(traceSerialization.TraceVerbose, "--------------------------------------------------------------------");
                                CodeDomSerializer ser = (CodeDomSerializer)manager.GetSerializer(component.GetType(), typeof(CodeDomSerializer));
                                if (ser != null) {
                                    codeElements.Add(ser.Serialize(manager, component));
                                }
                                else {
                                    Debug.WriteLineIf(traceSerialization.TraceError, "*** Component has no serializer: " + component.GetType().Name + " ***");
                                    manager.ReportError(SR.GetString(SR.SerializerNoSerializerForComponent, component.GetType().FullName));
                                }
                            }
                        }
                        

                        // Push the component being serialized onto the stack.  It may be handy to
                        // be able to discover this.
                        //
                        manager.Context.Push(value);

                        try {
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "--------------------------------------------------------------------");
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "     Beginning serialization of root component " + manager.GetName(value));
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "--------------------------------------------------------------------");
                            CodeDomSerializer rootSer = (CodeDomSerializer)manager.GetSerializer(value.GetType(), typeof(CodeDomSerializer));
                            if (rootSer != null) {
                                codeElements.Add(rootSer.Serialize(manager, value));
                            }
                            else {
                                Debug.WriteLineIf(traceSerialization.TraceError, "*** Component has no serializer: " + value.GetType().Name + " ***");
                                manager.ReportError(SR.GetString(SR.SerializerNoSerializerForComponent, value.GetType().FullName));
                            }
                        }
                        finally {
                            Debug.Assert(manager.Context.Current == value, "Context stack corrupted");
                            manager.Context.Pop();
                        }

                        CodeMemberMethod method = new CodeMemberMethod();
                        method.Name = InitMethodName;
                        method.Attributes = MemberAttributes.Private;
                        docType.Members.Add(method);
                        
                        // We write the code into the method in the following order:
                        // 
                        // components = new Container() assignment
                        // individual component assignments
                        // root object design time proeprties
                        // individual component properties / events
                        // root object properties / events
                        //
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Assembling init method from " + codeElements.Count.ToString() + " statements");
                        
                        if (ContainerRequired) {
                            SerializeContainerDeclaration(manager, method.Statements);
                        }
                        
                        SerializeElementsToStatements(codeElements, method.Statements);
                    }
                }
            }
            finally {
                Debug.Assert(manager.Context.Current == docType, "Somebody messed up our context stack");
                manager.Context.Pop();
                manager.Context.Pop();
            }
            
#if DEBUG
            if (traceSerialization.TraceVerbose) {
                Debug.WriteLine("--------------------------------------------------------------------");
                Debug.WriteLine("     Generated code for " + manager.GetName(value));
                Debug.WriteLine("--------------------------------------------------------------------");
                System.IO.StringWriter sw = new System.IO.StringWriter();
                new Microsoft.CSharp.CSharpCodeProvider().CreateGenerator().GenerateCodeFromType(docType, sw, new CodeGeneratorOptions());
                Debug.WriteLine("\n" + sw.ToString());
            }
#endif


            Debug.Unindent();
#if DEBUG
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "end serialize  id=" + serializeSessionId);
#endif
            return docType;
        }
        
        /// <include file='doc\RootCodeDomSerializer.uex' path='docs/doc[@for="RootCodeDomSerializer.SerializeContainerDeclaration"]/*' />
        /// <devdoc>
        ///     This ensures that the declaration for IContainer exists in the class, and that
        ///     the init method creates an instance of Conatiner.
        /// </devdoc>
        private void SerializeContainerDeclaration(IDesignerSerializationManager manager, CodeStatementCollection statements) {
        
            // Get some services we need up front.
            //
            CodeTypeDeclaration docType = (CodeTypeDeclaration)manager.Context[typeof(CodeTypeDeclaration)];
            
            if (docType == null) {
                Debug.Fail("Missing CodeDom objects in context.");
                return;
            }
            
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "RootModelSerializer::SerializeContainerDeclaration");
            Debug.Indent();
            
            // Add the definition for IContainer to the class.
            //
            Type containerType = typeof(IContainer);
            CodeTypeReference containerTypeRef = new CodeTypeReference(containerType);
            
            CodeMemberField componentsDeclaration = new CodeMemberField(containerTypeRef, ContainerName);
            componentsDeclaration.Attributes = MemberAttributes.Private;
            docType.Members.Add(componentsDeclaration);
            
            // Next, add the instance creation to the init method.  We change containerType
            // here from IContainer to Container.
            //
            containerType = typeof(Container);
            containerTypeRef = new CodeTypeReference(containerType);
            
            CodeObjectCreateExpression objectCreate = new CodeObjectCreateExpression();
            objectCreate.CreateType = containerTypeRef;
            
            CodeFieldReferenceExpression fieldRef = new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), ContainerName);
            CodeAssignStatement assignment = new CodeAssignStatement(fieldRef, objectCreate);
            
            statements.Add(assignment);
            Debug.Unindent();
        }
        
        /// <include file='doc\RootCodeDomSerializer.uex' path='docs/doc[@for="RootCodeDomSerializer.SerializeElementsToStatements"]/*' />
        /// <devdoc>
        ///     Takes the given list of elements and serializes them into the statement
        ///     collection.  This performs a simple sorting algorithm as well, putting
        ///     local variables at the top, assignments next, and statements last.
        /// </devdoc>
        private void SerializeElementsToStatements(ArrayList elements, CodeStatementCollection statements) {
                        
            ArrayList beginInitStatements = new ArrayList();
            ArrayList endInitStatements = new ArrayList();
            ArrayList localVariables = new ArrayList();
            ArrayList fieldAssignments = new ArrayList();
            ArrayList codeStatements = new ArrayList();
            
            foreach(object element in elements) {
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "ElementStatement: " + element.GetType().FullName);

                if (element is CodeAssignStatement && ((CodeAssignStatement)element).Left is CodeFieldReferenceExpression) {
                    fieldAssignments.Add(element);
                }
                else if (element is CodeVariableDeclarationStatement) {
                    localVariables.Add(element);
                }
                else if (element is CodeStatement) {
                    string order = ((CodeObject)element).UserData["statement-ordering"] as string;
                    if (order != null) {
                        switch (order) {
                            case "begin":
                                beginInitStatements.Add(element);
                                break;
                            case "end":
                                endInitStatements.Add(element);
                                break;
                            case "default":
                            default:
                                codeStatements.Add(element);
                                break;
                        }
                    }
                    else {
                        codeStatements.Add(element);
                    }
                }
                else if (element is CodeStatementCollection) {
                    CodeStatementCollection childStatements = (CodeStatementCollection)element;
                    foreach(CodeStatement statement in childStatements) {
                        if (statement is CodeAssignStatement && ((CodeAssignStatement)statement).Left is CodeFieldReferenceExpression) {
                            fieldAssignments.Add(statement);
                        }
                        else if (statement is CodeVariableDeclarationStatement) {
                            localVariables.Add(statement);
                        }
                        else {
                            string order = statement.UserData["statement-ordering"] as string;
                            if (order != null) {
                                switch (order) {
                                    case "begin":
                                        beginInitStatements.Add(statement);
                                        break;
                                    case "end":
                                        endInitStatements.Add(statement);
                                        break;
                                    case "default":
                                    default:
                                        codeStatements.Add(statement);
                                        break;
                                }
                            }
                            else {
                                codeStatements.Add(statement);
                            }
                        }
                    }
                }
            }
            
            // Now that we have our lists, we can actually add them in the
            // proper order to the statement collection.
            //
            statements.AddRange((CodeStatement[])localVariables.ToArray(typeof(CodeStatement)));
            statements.AddRange((CodeStatement[])fieldAssignments.ToArray(typeof(CodeStatement)));
            statements.AddRange((CodeStatement[])beginInitStatements.ToArray(typeof(CodeStatement)));
            statements.AddRange((CodeStatement[])codeStatements.ToArray(typeof(CodeStatement)));
            statements.AddRange((CodeStatement[])endInitStatements.ToArray(typeof(CodeStatement)));
        }
        
        /// <include file='doc\RootCodeDomSerializer.uex' path='docs/doc[@for="RootCodeDomSerializer.SerializeRootObject"]/*' />
        /// <devdoc>
        ///     Serializes the root object of the object graph.
        /// </devdoc>
        private CodeStatementCollection SerializeRootObject(IDesignerSerializationManager manager, object value, bool designTime) {
            // Get some services we need up front.
            //
            CodeTypeDeclaration docType = (CodeTypeDeclaration)manager.Context[typeof(CodeTypeDeclaration)];
            
            if (docType == null) {
                Debug.Fail("Missing CodeDom objects in context.");
                return null;
            }
            
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "RootModelSerializer::SerializeRootObject");
            Debug.Indent();
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Design time values: " + designTime.ToString());
            
            CodeStatementCollection statements = new CodeStatementCollection();
            
            if (designTime) {
                SerializeProperties(manager, statements, value, designTimeProperties);
            }
            else {
                SerializeProperties(manager, statements, value, runTimeProperties);
                SerializeEvents(manager, statements, value, null);
            }
            
            Debug.Unindent();
            return statements;
        }
        
        /// <include file='doc\RootCodeDomSerializer.uex' path='docs/doc[@for="RootCodeDomSerializer.IDesignerSerializationProvider.GetSerializer"]/*' />
        /// <devdoc>
        ///     This will be called by the serialization manager when it 
        ///     is trying to locate a serialzer for an object type.
        ///     If this serialization provider can provide a serializer
        ///     that is of the correct type, it should return it.
        ///     Otherwise, it should return null.
        /// </devdoc>
        object IDesignerSerializationProvider.GetSerializer(IDesignerSerializationManager manager, object currentSerializer, Type objectType, Type serializerType) {
        
            // If this isn't a serializer type we recognize, do nothing.  Also, if metadata specified
            // a custom serializer, then use it.
            if (serializerType != typeof(CodeDomSerializer) || currentSerializer != null) {
                return null;
            }

            // Check to see if the context stack contains a ResourceCodeDomSerializer type.  If it does,
            // that indicates that we should be favoring resource emission rather than code emission.
            // 
            CodeDomSerializer serializer = (CodeDomSerializer)manager.Context[typeof(ResourceCodeDomSerializer)];
            if (serializer != null) {
                return serializer;
            }

            // Null is a valid value that can be passed into GetSerializer.  It indicates
            // that the value we need to serialize is null, in which case we handle it
            // through the PrimitiveCodeDomSerializer.
            //
            if (objectType == null) {
                return PrimitiveCodeDomSerializer.Default;
            }
            
            // Support for components.
            //
            if (typeof(IComponent).IsAssignableFrom(objectType)) {
                return ComponentCodeDomSerializer.Default;
            }
            
            // We special case enums.  They do have instance descriptors, but we want
            // better looking code than the instance descriptor can provide for flags,
            // so we do it ourselves.
            //
            if (typeof(Enum).IsAssignableFrom(objectType)) {
                return EnumCodeDomSerializer.Default;
            }
            
            // We will also provide a serializer for any data type that supports an
            // instance descriptor.
            //
            TypeConverter converter = TypeDescriptor.GetConverter(objectType);
            if (converter.CanConvertTo(typeof(InstanceDescriptor))) {
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Chosen instance serializer based on " + converter.GetType().Name + " for type " + objectType.Name);
                return InstanceDescriptorCodeDomSerializer.Default;
            }
            
            // We will provide a serializer for any intrinsic types.
            //
            if (objectType.IsPrimitive || objectType.IsEnum || objectType == typeof(string)) {
                return PrimitiveCodeDomSerializer.Default;
            }
            
            // And one for collections.
            //
            if (typeof(ICollection).IsAssignableFrom(objectType)) {
                return CollectionCodeDomSerializer.Default;
            }
            
            // And one for resources
            //
            if (typeof(ResourceManager).IsAssignableFrom(objectType)) {
                return ResourceCodeDomSerializer.Default;
            }

            return ObjectCodeDomSerializer.Default;
        }

        private class StatementOrderComparer : IComparer {
        
            public static readonly StatementOrderComparer Default = new StatementOrderComparer();
            
            private StatementOrderComparer() {
            }
            
            public int Compare(object left, object right) {
                OrderedCodeStatementCollection cscLeft = left as OrderedCodeStatementCollection;
                OrderedCodeStatementCollection cscRight = right as OrderedCodeStatementCollection;

                if (left == null) {
                    return 1;
                }
                else if (right == null) {
                    return -1;
                }
                else if (right == left) {
                    return 0;
                }

                return cscLeft.Order - cscRight.Order;
            }
        }
        
        private class ComponentComparer : IComparer {
        
            public static readonly ComponentComparer Default = new ComponentComparer();
            
            private ComponentComparer() {
            }
            
            public int Compare(object left, object right) {
                int n = string.Compare(((IComponent)left).GetType().Name,
                                      ((IComponent)right).GetType().Name, false, CultureInfo.InvariantCulture);
                                      
                if (n == 0) {
                    n = string.Compare(((IComponent)left).Site.Name,
                                       ((IComponent)right).Site.Name, 
                                          true, CultureInfo.InvariantCulture);
                }
                
                return n;
            }
        }

        private class OrderedCodeStatementCollection : CodeStatementCollection {
            public int Order;
            public string Name;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\drawing\system\drawing\design\iconeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="IconEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Design {
    
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    using System.IO;
    using System.Collections;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;

    /// <internalonly/>
    /// <include file='doc\IconEditor.uex' path='docs/doc[@for="IconEditor"]/*' />
    /// <devdoc>
    ///    <para>Provides an editor for visually picking an icon.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class IconEditor : UITypeEditor {
    // NOTE: this class should be almost identical to ImageEditor.  The main exception is PaintValue,
    // which has logic that should probably be copied into ImageEditor.

        internal static Type[] imageExtenders = new Type[] { };
        
        internal FileDialog fileDialog = null;

        /// <include file='doc\IconEditor.uex' path='docs/doc[@for="IconEditor.CreateExtensionsString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected static string CreateExtensionsString(string[] extensions,string sep) {
            if (extensions == null || extensions.Length == 0)
                return null;
            string text = null;
            for (int i = 0; i < extensions.Length - 1; i++)
                text = text + "*." + extensions[i] + sep;
            text = text + "*." + extensions[extensions.Length-1];
            return text;
        }

        /// <include file='doc\IconEditor.uex' path='docs/doc[@for="IconEditor.CreateFilterEntry"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected static string CreateFilterEntry(IconEditor e) {
            string desc = e.GetFileDialogDescription();
            string exts = CreateExtensionsString(e.GetExtensions(),",");
            string extsSemis = CreateExtensionsString(e.GetExtensions(),";");
            return desc + "(" + exts + ")|" + extsSemis;
        }

        /// <include file='doc\IconEditor.uex' path='docs/doc[@for="IconEditor.EditValue"]/*' />
        /// <devdoc>
        ///      Edits the given object value using the editor style provided by
        ///      GetEditorStyle.  A service provider is provided so that any
        ///      required editing services can be obtained.
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {
            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));

                if (edSvc != null) {
                    if (fileDialog == null) {
                        fileDialog = new OpenFileDialog();
                        string filter = CreateFilterEntry(this);
                        for (int i = 0; i < imageExtenders.Length; i++) {
                    Debug.Fail("Why does IconEditor have subclasses if Icon doesn't?");
                        }
                        fileDialog.Filter = filter;
                    }

                    IntPtr hwndFocus = UnsafeNativeMethods.GetFocus();
                    try {
                        if (fileDialog.ShowDialog() == DialogResult.OK) {
                            FileStream file = new FileStream(fileDialog.FileName, FileMode.Open, FileAccess.Read, FileShare.Read);
                            value = LoadFromStream(file);
                        } 
                    }
                    finally {
                        if (hwndFocus != IntPtr.Zero) {
                            UnsafeNativeMethods.SetFocus(hwndFocus);
                        }
                    }

                }
            }
            return value;
        }

        /// <include file='doc\IconEditor.uex' path='docs/doc[@for="IconEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///      Retrieves the editing style of the Edit method.  If the method
        ///      is not supported, this will return None.
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.Modal;
        }

        /// <include file='doc\IconEditor.uex' path='docs/doc[@for="IconEditor.GetFileDialogDescription"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual string GetFileDialogDescription() {
            return SR.GetString(SR.iconFileDescription);
        }

        /// <include file='doc\IconEditor.uex' path='docs/doc[@for="IconEditor.GetExtensions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual string[] GetExtensions() {
            return new string[] { "ico"};
        }

        /// <include file='doc\IconEditor.uex' path='docs/doc[@for="IconEditor.GetPaintValueSupported"]/*' />
        /// <devdoc>
        ///      Determines if this editor supports the painting of a representation
        ///      of an object's value.
        /// </devdoc>
        public override bool GetPaintValueSupported(ITypeDescriptorContext context) {
            return true;
        }

        /// <include file='doc\IconEditor.uex' path='docs/doc[@for="IconEditor.LoadFromStream"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual Icon LoadFromStream(Stream stream) {
            return new Icon(stream);
        }

        /// <include file='doc\IconEditor.uex' path='docs/doc[@for="IconEditor.PaintValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Paints a representative value of the given object to the provided
        ///       canvas. Painting should be done within the boundaries of the
        ///       provided rectangle.
        ///    </para>
        /// </devdoc>
        public override void PaintValue(PaintValueEventArgs e) {
           if (e.Value is Icon) {
                Icon icon = (Icon) e.Value;

                // If icon is smaller than rectangle, just center it unscaled in the rectangle
                Size iconSize = icon.Size;
                Rectangle rectangle = e.Bounds;
                if (icon.Width < rectangle.Width) {
                    rectangle.X = (rectangle.Width - icon.Width) / 2;
                    rectangle.Width = icon.Width;
                }
                if (icon.Height < rectangle.Height) {
                    rectangle.X = (rectangle.Height - icon.Height) / 2;
                    rectangle.Height = icon.Height;
                }

                e.Graphics.DrawIcon(icon, rectangle);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\drawing\system\drawing\design\safenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="SafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Design {
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [
    System.Runtime.InteropServices.ComVisible(false), 
    System.Security.SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class SafeNativeMethods {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\drawing\system\drawing\design\nativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Design {
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [System.Runtime.InteropServices.ComVisible(false)]
    internal class NativeMethods {
        public static IntPtr InvalidIntPtr = ((IntPtr)((int)(-1)));

        public const int
            EM_GETSEL = 0x00B0,
            EM_SETSEL = 0x00B1,
            EM_GETRECT = 0x00B2,
            EM_SETRECT = 0x00B3,
            EM_SETRECTNP = 0x00B4,
            EM_SCROLL = 0x00B5,
            EM_LINESCROLL = 0x00B6,
            EM_SCROLLCARET = 0x00B7,
            EM_GETMODIFY = 0x00B8,
            EM_SETMODIFY = 0x00B9,
            EM_GETLINECOUNT = 0x00BA,
            EM_LINEINDEX = 0x00BB,
            EM_SETHANDLE = 0x00BC,
            EM_GETHANDLE = 0x00BD,
            EM_GETTHUMB = 0x00BE,
            EM_LINELENGTH = 0x00C1,
            EM_REPLACESEL = 0x00C2,
            EM_GETLINE = 0x00C4,
            EM_LIMITTEXT = 0x00C5,
            EM_CANUNDO = 0x00C6,
            EM_UNDO = 0x00C7,
            EM_FMTLINES = 0x00C8,
            EM_LINEFROMCHAR = 0x00C9,
            EM_SETTABSTOPS = 0x00CB,
            EM_SETPASSWORDCHAR = 0x00CC,
            EM_EMPTYUNDOBUFFER = 0x00CD,
            EM_GETFIRSTVISIBLELINE = 0x00CE,
            EM_SETREADONLY = 0x00CF,
            EM_SETWORDBREAKPROC = 0x00D0,
            EM_GETWORDBREAKPROC = 0x00D1,
            EM_GETPASSWORDCHAR = 0x00D2,
            EM_SETMARGINS = 0x00D3,
            EM_GETMARGINS = 0x00D4,
            EM_SETLIMITTEXT = 0x00C5,
            EM_GETLIMITTEXT = 0x00D5,
            EM_POSFROMCHAR = 0x00D6,
            EM_CHARFROMPOS = 0x00D7,
        EC_LEFTMARGIN = 0x0001,
        EC_RIGHTMARGIN = 0x0002,
        EC_USEFONTINFO = 0xffff,
        IDOK = 1,
        IDCANCEL = 2,
        IDABORT = 3,
        IDRETRY = 4,
        IDIGNORE = 5,
        IDYES = 6,
        IDNO = 7,
        IDCLOSE = 8,
        IDHELP = 9,
            WM_INITDIALOG = 0x0110,
        SWP_NOSIZE = 0x0001,
        SWP_NOMOVE = 0x0002,
        SWP_NOZORDER = 0x0004,
        SWP_NOREDRAW = 0x0008,
        SWP_NOACTIVATE = 0x0010,
        SWP_FRAMECHANGED = 0x0020,
        SWP_SHOWWINDOW = 0x0040,
        SWP_HIDEWINDOW = 0x0080,
        SWP_NOCOPYBITS = 0x0100,
        SWP_NOOWNERZORDER = 0x0200,
        SWP_NOSENDCHANGING = 0x0400,
        SWP_DRAWFRAME = 0x0020,
        SWP_NOREPOSITION = 0x0200,
        SWP_DEFERERASE = 0x2000,
        SWP_ASYNCWINDOWPOS = 0x4000,
        WM_COMMAND = 0x0111,
            CC_FULLOPEN = 0x00000002,
        CC_PREVENTFULLOPEN = 0x00000004,
        CC_SHOWHELP = 0x00000008,
        CC_ENABLEHOOK = 0x00000010,
        CC_ENABLETEMPLATE = 0x00000020,
        CC_ENABLETEMPLATEHANDLE = 0x00000040,
        CC_SOLIDCOLOR = 0x00000080,
        CC_ANYCOLOR = 0x00000100;

        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public extern static IntPtr SendDlgItemMessage(IntPtr hDlg, int nIDDlgItem, int Msg, IntPtr wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GetDlgItem(IntPtr hWnd, int nIDDlgItem);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool EnableWindow(IntPtr hWnd, bool enable);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter,
                                               int x, int y, int cx, int cy, int flags);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetDlgItemInt(IntPtr hWnd, int nIDDlgItem, bool[] err, bool signed);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr PostMessage(IntPtr hwnd, int msg, IntPtr wparam, IntPtr lparam);
        [System.Runtime.InteropServices.ComVisible(false), 
            System.Security.Permissions.SecurityPermissionAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)
       ]
        public class Util {
            public static int MAKELONG(int low, int high) {
                return (high << 16) | (low & 0xffff);
            }

            public static int MAKELPARAM(int low, int high) {
                return (high << 16) | (low & 0xffff);
            }

            public static int HIWORD(int n) {
                return (n >> 16) & 0xffff;
            }

            public static int LOWORD(int n) {
                return n & 0xffff;
            }

            public static int SignedHIWORD(int n) {
                int i = (int)(short)((n >> 16) & 0xffff);

                i = i << 16;
                i = i >> 16;

                return i;
            }

            public static int SignedLOWORD(int n) {
                int i = (int)(short)(n & 0xFFFF);

                i = i << 16;
                i = i >> 16;

                return i;
            }
            [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
            private static extern int lstrlen(String s);

            [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
            internal static extern int RegisterWindowMessage(String msg);
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public class POINT {
            public int x;
            public int y;

            public POINT() {
            }
            
            public POINT(int x, int y) {
                this.x = x;
                this.y = y;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\drawing\system\drawing\design\metafileeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="MetafileEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Design {
    using System.Runtime.Serialization.Formatters;

    using System.Diagnostics;
    using System;
    using System.IO;
    using System.Collections;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Drawing.Imaging;
    
    /// <include file='doc\MetafileEditor.uex' path='docs/doc[@for="MetafileEditor"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///     Extends Image's editor class to provide default file searching for metafile (.emf)
    ///     files.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class MetafileEditor : ImageEditor {

        /// <include file='doc\MetafileEditor.uex' path='docs/doc[@for="MetafileEditor.GetFileDialogDescription"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override string GetFileDialogDescription() {
            return SR.GetString(SR.metafileFileDescription);
        }

        /// <include file='doc\MetafileEditor.uex' path='docs/doc[@for="MetafileEditor.GetExtensions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override string[] GetExtensions() {
            return new string[] { "emf","wmf" };
        }

        /// <include file='doc\MetafileEditor.uex' path='docs/doc[@for="MetafileEditor.LoadFromStream"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override Image LoadFromStream(Stream stream) {
            return new Metafile(stream);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\compmod\system\componentmodel\design\serialization\resourcecodedomserializer.cs ===
//------------------------------------------------------------------------------
// <copyright file="ResourceCodeDomSerializer.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel.Design.Serialization {

    using System;
    using System.CodeDom;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Design;
    using System.Diagnostics;
    using System.Globalization;
    using System.IO;
    using System.Reflection;
    using System.Resources;
    using System.Runtime.Serialization;
    
    /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer"]/*' />
    /// <devdoc>
    ///     Code model serializer for resource managers.  This is called
    ///     in one of two ways.  On Deserialization, we are associated
    ///     with a ResourceManager object.  Instead of creating a
    ///     ResourceManager, however, we create an object called a
    ///     SerializationResourceManager.  This class inherits
    ///     from ResourceManager, but overrides all of the methods.
    ///     Instead of letting resource manager maintain resource
    ///     sets, it uses the designer host's IResourceService
    ///     for this purpose.
    ///
    ///     During serialization, this class will also create
    ///     a SerializationResourceManager.  This will be added
    ///     to the serialization manager as a service so other
    ///     resource serializers can get at it.  SerializationResourceManager
    ///     has additional methods on it to support writing data
    ///     into the resource streams for various cultures.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class ResourceCodeDomSerializer : CodeDomSerializer {
    
        private static ResourceCodeDomSerializer defaultSerializer;
        
        /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.Default"]/*' />
        /// <devdoc>
        ///     Retrieves a default static instance of this serializer.
        /// </devdoc>
        public static ResourceCodeDomSerializer Default {
            get {
                if (defaultSerializer == null) {
                    defaultSerializer = new ResourceCodeDomSerializer();
                }
                return defaultSerializer;
            }
        }
        
        /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.ResourceManagerName"]/*' />
        /// <devdoc>
        ///     This is the name of the resource manager object we declare
        ///     on the component surface.
        /// </devdoc>
        private string ResourceManagerName {
            get {
                return "resources";
            }
        }
        
        /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.Deserialize"]/*' />
        /// <devdoc>
        ///     Deserilizes the given CodeDom object into a real object.  This
        ///     will use the serialization manager to create objects and resolve
        ///     data types.  The root of the object graph is returned.
        /// </devdoc>
        public override object Deserialize(IDesignerSerializationManager manager, object codeObject) {
            object instance = null;
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "ResourceCodeDomSerializer::Deserialize");
            Debug.Indent();
            
            // Now look for things we understand.
            //
            if (codeObject is CodeStatementCollection) {
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Incoming codeDom object is a statement collection.");
                foreach(CodeStatement element in (CodeStatementCollection)codeObject) {
                    if (element is CodeVariableDeclarationStatement) {
                        CodeVariableDeclarationStatement statement = (CodeVariableDeclarationStatement)element;
                        
                        // We create the resource manager ouselves here because it's not just a straight
                        // parse of the code.
                        //
                        Debug.WriteLineIf(traceSerialization.TraceWarning && !statement.Name.Equals(ResourceManagerName), "WARNING: Resource manager serializer being invoked to deserialize a collection we didn't create.");
                        if (statement.Name.Equals(ResourceManagerName)) {
                            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Variable is our resource manager.  Creating it");
                            instance = manager.GetService(typeof(SerializationResourceManager));
                            if (instance == null) {
                                instance = new SerializationResourceManager(manager);
                            }
                            
                            SerializationResourceManager sm = (SerializationResourceManager)instance;
                            Debug.WriteLineIf(traceSerialization.TraceWarning && sm.DeclarationAdded, "WARNING: We have already created a resource manager.");
                            if (!sm.DeclarationAdded) {
                                sm.DeclarationAdded = true;
                                manager.SetName(instance, ResourceManagerName);
                            }
                        }
                    }
                    else {
                        DeserializeStatement(manager, element);
                    }
                }
            }
            else if (codeObject is CodeExpression) {
            
                // Not a statement collection.  This must be an expression.  We just let
                // the base serializer do the work of resolving it here.  The magic
                // happens when we associate an instance of SerializationResourceManager
                // with the name "resources", which allows the rest of the 
                // serializers to just execute code.
                //
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Incoming codeDom object is a code expression.");
                instance = DeserializeExpression(manager, null, (CodeExpression)codeObject);
                if (instance is CodeExpression) {
                    Debug.WriteLineIf(traceSerialization.TraceWarning, "WARNING: Unable to simplify expression.");
                    instance = null;
                }
            }
            else {
                Debug.WriteLineIf(traceSerialization.TraceWarning, "WARNING: Unsupported code dom element: " + (codeObject == null ? "(null)" : codeObject.GetType().Name));
            }
            
            Debug.Unindent();
            return instance;
        }
        
        /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.DeserializeInvariant"]/*' />
        /// <devdoc>
        ///     Deserilizes the given CodeDom object into a real object.  This
        ///     will use the serialization manager to create objects and resolve
        ///     data types.  It uses the invariant resource blob to obtain resources.
        /// </devdoc>
        public object DeserializeInvariant(IDesignerSerializationManager manager, string resourceName) {
            SerializationResourceManager resources = (SerializationResourceManager)manager.GetService(typeof(SerializationResourceManager));
            if (resources == null) {
                resources = new SerializationResourceManager(manager);
            }
            
            return resources.GetObject(resourceName, true);
        }
        
        /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.GetEnumerator"]/*' />
        /// <devdoc>
        ///     Retrieves a dictionary enumerator for the requested culture, or null if no resources for that culture exist.
        /// </devdoc>
        public IDictionaryEnumerator GetEnumerator(IDesignerSerializationManager manager, CultureInfo culture) {
            SerializationResourceManager resources = (SerializationResourceManager)manager.GetService(typeof(SerializationResourceManager));
            if (resources == null) {
                resources = new SerializationResourceManager(manager);
            }
            
            return resources.GetEnumerator(culture);
        }
        
        /// <devdoc>
        ///     Try to discover the data type we should apply a cast for.  To do this, we
        ///     first search the context stack for a CodeValueExpression to decrypt, and if
        ///     we fail that we try the actual object.  If we can't find a cast type we 
        ///     return null.
        /// </devdoc>
        private Type GetCastType(IDesignerSerializationManager manager, object value) {
            
            // Is there a CodeValueExpression we can work with?
            //
            CodeValueExpression cve = (CodeValueExpression)manager.Context[typeof(CodeValueExpression)];
            if (cve != null) {
                if (cve.Expression is CodePropertyReferenceExpression) {
                    string propertyName = ((CodePropertyReferenceExpression)cve.Expression).PropertyName;
                    PropertyDescriptor actualProperty = (PropertyDescriptor)manager.Context[typeof(PropertyDescriptor)];
                    if (actualProperty != null && actualProperty.Name.Equals(propertyName)) {
                        return actualProperty.PropertyType;
                    }
                }
                else if (cve.ExpressionType != null) {
                    return cve.ExpressionType;
                }
            }

            // Party on the object, if we can.  It is the best identity we can get.
            //
            if (value != null) {
                Type castTo = value.GetType();
                while (!castTo.IsPublic && !castTo.IsNestedPublic) {
                    castTo = castTo.BaseType;
                }
                return castTo;
            }
            // Object is null. Nuttin we can do
            //
            Debug.WriteLineIf(traceSerialization.TraceError, "*** We need to supply a cast, but we cannot determine the cast type. ***");
            return null;
        }

        /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.Serialize"]/*' />
        /// <devdoc>
        ///     Serializes the given object into a CodeDom object.  This expects the following
        ///     values to be available on the context stack:
        ///
        ///         A CodeStatementCollection that we can add our resource declaration to, 
        ///         if necessary.
        ///
        ///         A CodeValueExpression that contains the property, field or method
        ///         that is being serialized, along with the object being serialized.
        ///         We need this so we can create a unique resource name for the
        ///         object.
        ///
        /// </devdoc>
        public override object Serialize(IDesignerSerializationManager manager, object value) {
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "ResourceCodeDomSerializer::Serialize");
            return Serialize(manager, value, false, false);
        }
        
        /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.Serialize2"]/*' />
        /// <devdoc>
        ///     Serializes the given object into a CodeDom object.  This expects the following
        ///     values to be available on the context stack:
        ///
        ///         A CodeStatementCollection that we can add our resource declaration to, 
        ///         if necessary.
        ///
        ///         A CodeValueExpression that contains the property, field or method
        ///         that is being serialized, along with the object being serialized.
        ///         We need this so we can create a unique resource name for the
        ///         object.
        ///
        /// </devdoc>
        public object Serialize(IDesignerSerializationManager manager, object value, bool shouldSerializeInvariant) {
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "ResourceCodeDomSerializer::Serialize");
            return Serialize(manager, value, false, shouldSerializeInvariant);
        }

        /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.Serialize1"]/*' />
        /// <devdoc>
        ///     This performs the actual work of serialization between Serialize and SerializeInvariant.
        /// </devdoc>
        private object Serialize(IDesignerSerializationManager manager, object value, bool forceInvariant, bool shouldSerializeInvariant) {
            CodeExpression expression = null;
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "ResourceCodeDomSerializer::Serialize");
            Debug.Indent();

            // Resource serialization is a little inconsistent.  We deserialize our own resource manager
            // creation statement, but we will never be asked to serialize a resource manager, because
            // it doesn't exist as a product of the design container; it is purely an artifact of
            // serializing.  Some not-so-obvious side effects of this are:
            //
            //      This method will never ever be called by the serialization system directly.  
            //      There is no attribute or metadata that will invoke it.  Instead, other
            //      serializers will call this method to see if we should serialize to resources.
            //
            //      We need a way to inject the local variable declaration into the method body
            //      for the resource manager if we actually do emit a resource, which we shove
            //      into the statements collection.
    
            SerializationResourceManager sm = (SerializationResourceManager)manager.GetService(typeof(SerializationResourceManager));
            if (sm == null) {
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Creating resource manager.");
                sm = new SerializationResourceManager(manager);
            }
            
            CodeStatementCollection statements = (CodeStatementCollection)manager.Context[typeof(CodeStatementCollection)];
            
            // If this serialization resource manager has never been used to output
            // culture-sensitive statements, then we must emit the local variable hookup.  Culture
            // invariant statements are used to save random data that is not representable in code,
            // so there is no need to emit a declaration.
            //
            if (!forceInvariant && !sm.DeclarationAdded) {
                sm.DeclarationAdded = true;
            
                IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                
                Debug.WriteLineIf(traceSerialization.TraceWarning && host == null, "WARNING: No designer host, we cannot serialize resource manager creation statements.");
                Debug.WriteLineIf(traceSerialization.TraceWarning && statements == null, "WARNING: No CodeStatementCollection on serialization stack, we cannot serialize resource manager creation statements.");
                
                if (host != null && statements != null) {

                    string baseType = manager.GetName(host.RootComponent);

                    CodeExpression[] parameters = new CodeExpression[] {new CodeTypeOfExpression(baseType)};

                    #if NEW_LOC_MODEL
                    
                    CodeExpression initExpression = new CodeObjectCreateExpression(typeof(ComponentResourceManager), parameters);
                    statements.Add(new CodeVariableDeclarationStatement(typeof(ComponentResourceManager), ResourceManagerName, initExpression));

                    #else
                    
                    CodeExpression initExpression = new CodeObjectCreateExpression(typeof(ResourceManager), parameters);
                    statements.Add(new CodeVariableDeclarationStatement(typeof(ResourceManager), ResourceManagerName, initExpression));
                    
                    #endif
                }
            }

            // Retrieve the code value expression on the context stack, and save the value as a resource.
            CodeValueExpression codeValue = (CodeValueExpression)manager.Context[typeof(CodeValueExpression)];
            Debug.WriteLineIf(traceSerialization.TraceWarning && codeValue == null, "WARNING: No CodeValueExpression on stack.  We can serialize, but we cannot create a well-formed name.");
            string resourceName = sm.SetValue(manager, codeValue, value, forceInvariant, shouldSerializeInvariant);

            // Now, check to see if the code value expression contains a property reference.  If so,
            // we emit the much more efficient "ApplyResources" call to the resource manager and
            // return null as an expression to indicate we want to discard the expression.
            //

            #if NEW_LOC_MODEL

            if (!forceInvariant && codeValue != null && codeValue.Expression is CodePropertyReferenceExpression && statements != null) {

                if (sm.AddPropertyFill(codeValue.Value)) {

                    Debug.WriteLineIf(traceSerialization.TraceVerbose, "Creating method invoke to " + ResourceManagerName + ".ApplyResources");

                    string objectName = null;
                    int idx = resourceName.LastIndexOf('.');
                    if (idx != -1) {
                        objectName = resourceName.Substring(0, idx);
                    }

                    CodeMethodInvokeExpression methodInvoke = new CodeMethodInvokeExpression();
                    methodInvoke.Method = new CodeMethodReferenceExpression(
                        new CodeVariableReferenceExpression(ResourceManagerName),
                        "ApplyResources");

                    CodePropertyReferenceExpression propRef = (CodePropertyReferenceExpression)codeValue.Expression;
                    methodInvoke.Parameters.Add(propRef.TargetObject);
                    methodInvoke.Parameters.Add(new CodePrimitiveExpression(objectName));

                    statements.Add(methodInvoke);
                }
            }
            else {

            #else
            
            {

            #endif
            
                // Now the next step is to discover the type of the given value.  If it is a string,
                // we will invoke "GetString"  Otherwise, we will invoke "GetObject" and supply a
                // cast to the proper value.
                //
                bool needCast;
                string methodName;
                
                if (value is string || (codeValue != null && codeValue.ExpressionType == typeof(string))) {
                    needCast = false;
                    methodName = "GetString";
                }
                else {
                    needCast = true;
                    methodName = "GetObject";
                }

                // Finally, all we need to do is create a CodeExpression that represents the resource manager
                // method invoke.
                //
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Creating method invoke to " + ResourceManagerName + "." + methodName);
                CodeMethodInvokeExpression methodInvoke = new CodeMethodInvokeExpression();
                methodInvoke.Method = new CodeMethodReferenceExpression(
                    new CodeVariableReferenceExpression(ResourceManagerName),
                    methodName);

                methodInvoke.Parameters.Add(new CodePrimitiveExpression(resourceName));


                if (needCast) {
                    Type castTo = GetCastType(manager, value);

                    if (castTo != null) {
                        Debug.WriteLineIf(traceSerialization.TraceVerbose, "Supplying cast to " + castTo.Name);
                        expression = new CodeCastExpression(castTo, methodInvoke);
                    }
                    else {
                        expression = methodInvoke;
                    }
                }
                else {
                    expression = methodInvoke;
                }
            }
            
            Debug.Unindent();
            return expression;
        }
        
        /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.SerializeInvariant"]/*' />
        /// <devdoc>
        ///     Serializes the given object into a CodeDom object saving resources
        ///     in the invariant culture, rather than the current culture.  This expects the following
        ///     values to be available on the context stack:
        ///
        ///         A CodeStatementCollection that we can add our resource declaration to, 
        ///         if necessary.
        ///
        ///         A CodeValueExpression that contains the property, field or method
        ///         that is being serialized, along with the object being serialized.
        ///         We need this so we can create a unique resource name for the
        ///         object.
        ///
        /// </devdoc>
        public object SerializeInvariant(IDesignerSerializationManager manager, object value, bool shouldSerializeValue) {
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "ResourceCodeDomSerializer::SerializeInvariant");
            return Serialize(manager, value, true, shouldSerializeValue);
        }
        
        /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.WriteResource"]/*' />
        /// <devdoc>
        ///     Serializes the given resource value into the resource set.  This does not effect
        ///     the code dom values.  The resource is written into the current culture.
        /// </devdoc>
        public void WriteResource(IDesignerSerializationManager manager, string name, object value) {
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "ResourceCodeDomSerializer::WriteResource");
            
            Debug.Indent();
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Name: " + name);
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Value: " + (value == null ? "(null)" : value.ToString()));
            
            SerializationResourceManager sm = (SerializationResourceManager)manager.GetService(typeof(SerializationResourceManager));
            if (sm == null) {
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Creating resource manager.");
                sm = new SerializationResourceManager(manager);
            }
            
            sm.SetValue(manager, name, value, false, false);
            Debug.Unindent();
        }
        
        /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.WriteResourceInvariant"]/*' />
        /// <devdoc>
        ///     Serializes the given resource value into the resource set.  This does not effect
        ///     the code dom values.  The resource is written into the invariant culture.
        /// </devdoc>
        public void WriteResourceInvariant(IDesignerSerializationManager manager, string name, object value) {
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "ResourceCodeDomSerializer::WriteResourceInvariant");
            
            Debug.Indent();
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Name: " + name);
            Debug.WriteLineIf(traceSerialization.TraceVerbose, "Value: " + (value == null ? "(null)" : value.ToString()));
            
            SerializationResourceManager sm = (SerializationResourceManager)manager.GetService(typeof(SerializationResourceManager));
            if (sm == null) {
                Debug.WriteLineIf(traceSerialization.TraceVerbose, "Creating resource manager.");
                sm = new SerializationResourceManager(manager);
            }
            
            sm.SetValue(manager, name, value, true, true);
            Debug.Unindent();
        }
        
        /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.SerializationResourceManager"]/*' />
        /// <devdoc>
        ///     This is the meat of resource serialization.  This implements
        ///     a resource manager through a host-provided IResourceService
        ///     interface.  The resource service feeds us with resource
        ///     readers and writers, and we simulate a runtime ResourceManager.
        ///     There is one instance of this object for the entire serialization
        ///     process, just like there is one resource manager in runtime
        ///     code.  When an instance of this object is created, it
        ///     adds itself to the serialization manager's service list,
        ///     and listens for the SerializationComplete event.  When
        ///     serialization is complete, this will close and flush
        ///     any readers or writers it may have opened and will
        ///     also remove itself from the service list.
        /// </devdoc>
        private class SerializationResourceManager : ComponentResourceManager {

            private static object resourceSetSentinel = new object();
            private IDesignerSerializationManager   manager;
            private bool                            checkedLocalizationLanguage;
            private CultureInfo                     localizationLanguage;
            private IResourceWriter                 writer;
            private CultureInfo                     readCulture;
            private Hashtable                       nameTable;
            private Hashtable                       resourceSets;
            private IComponent                      rootComponent;
            private bool                            declarationAdded = false;
            private Hashtable                       propertyFillAdded;
            private bool                            invariantCultureResourcesDirty = false; 
            
            
            public SerializationResourceManager(IDesignerSerializationManager manager) {
                this.manager = manager;
                this.nameTable = new Hashtable();
                
                // Hook us into the manager's services
                //
                manager.SerializationComplete += new EventHandler(OnSerializationComplete);
                IServiceContainer sc = (IServiceContainer)manager.GetService(typeof(IServiceContainer));
                Debug.Assert(sc != null, "Serialization resource manager requires a serivce container");
                if (sc != null) {
                    sc.AddService(typeof(SerializationResourceManager), this);
                }
            }
            
            /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.SerializationResourceManager.DeclarationAdded"]/*' />
            /// <devdoc>
            ///     State the serializers use to determine if the declaration
            ///     of this resource manager has been performed.  This is just
            ///     per-document state we keep; we do not actually care about
            ///     this value.
            /// </devdoc>
            public bool DeclarationAdded {
                get {
                    return declarationAdded;
                }
                set {
                    declarationAdded = value;
                }
            }
            
            /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.SerializationResourceManager.LocalizationLanguage"]/*' />
            /// <devdoc>
            ///     The language we should be localizing into.
            /// </devdoc>
            private CultureInfo LocalizationLanguage {
                get {
                    if (!checkedLocalizationLanguage) {
                        // Check to see if our base component's localizable prop is true
                        IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                        if (host != null) {
                            IComponent comp = host.RootComponent;
                            PropertyDescriptor prop = TypeDescriptor.GetProperties(comp)["LoadLanguage"];
                            if (prop != null && prop.PropertyType == typeof(CultureInfo)) {
                                localizationLanguage = (CultureInfo)prop.GetValue(comp);
                            }
                        }
                        checkedLocalizationLanguage = true;
                    }
                    return localizationLanguage;
                }
            }

            /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.SerializationResourceManager.ReadCulture"]/*' />
            /// <devdoc>
            ///     This is the culture info we should use to read and write resources.  We always write
            ///     using the same culture we read with so we don't stomp on data.
            /// </devdoc>
            private CultureInfo ReadCulture {
                get {
                    if (readCulture == null) {
                        CultureInfo locCulture = LocalizationLanguage;
                        if (locCulture != null) {
                            readCulture = locCulture;
                        }
                        else {
                            readCulture = CultureInfo.InvariantCulture;
                        }
                    }

                    return readCulture;
                }
            }

            /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.SerializationResourceManager.ResourceTable"]/*' />
            /// <devdoc>
            ///     Returns a hash table where we shove resource sets.
            /// </devdoc>
            private Hashtable ResourceTable {
                get {
                    if (resourceSets == null) {
                        resourceSets = new Hashtable();
                    }
                    return resourceSets;
                }
            }

            /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.SerializationResourceManager.RootComponent"]/*' />
            /// <devdoc>
            ///     Retrieves the root component we're designing.
            /// </devdoc>
            private IComponent RootComponent {
                get {
                    if (rootComponent == null) {
                        IDesignerHost host = (IDesignerHost)manager.GetService(typeof(IDesignerHost));
                        if (host != null) {
                            rootComponent = host.RootComponent;
                        }
                    }
                    return rootComponent;
                }
            }
            
            /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.SerializationResourceManager.Writer"]/*' />
            /// <devdoc>
            ///     Retrieves a resource writer we should write into.
            /// </devdoc>
            private IResourceWriter Writer {
                get {
                    if (writer == null) {
                        IResourceService rs = (IResourceService)manager.GetService(typeof(IResourceService));
    
                        if (rs != null) {
    
                            // We always write with the culture we read with.  In the event of a language change
                            // during localization, we will write the new language to the source code and then
                            // perform a reload.
                            //
                            writer = rs.GetResourceWriter(ReadCulture);
                        }
                        else {
    
                            // No resource service, so there is no way to create a resource writer for the
                            // object.  In this case we just create an empty one so the resources go into
                            // the bit-bucket.
                            //
                            Debug.Fail("We expected to get IResourceService -- no resource serialization will be available");
                            writer = new ResourceWriter(new MemoryStream());
                        }
                    }
                    return writer;
                }
            }
            
            /// <devdoc>
            ///     Returns true if the caller should add a property fill statement
            ///     for the given object.  A property fill is required for the
            ///     component only once, so this remembers the value.
            /// </devdoc>
            public bool AddPropertyFill(object value) {
                bool added = false;
                if (propertyFillAdded == null) {
                    propertyFillAdded = new Hashtable();
                }
                else {
                    added = propertyFillAdded.ContainsKey(value);
                }
                if (!added) {
                    propertyFillAdded[value] = value;
                }
                return !added;
            }
            
            /// <devdoc>
            ///     This method examines all the resources for the provided culture.
            ///     When it finds a resource with a key in the format of 
            ///     &quot;[objectName].[property name]&quot; it will apply that resources value
            ///     to the corresponding property on the object.
            /// </devdoc>
            public override void ApplyResources(object value, string objectName, CultureInfo culture) {

                if (culture == null) {
                    culture = ReadCulture;
                }

                base.ApplyResources(value, objectName, culture);
            }

            /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.SerializationResourceManager.CompareWithParentValue"]/*' />
            /// <devdoc>
            ///     This determines if the given resource name/value pair can be retrieved
            ///     from a parent culture.  We don't want to write duplicate resources for
            ///     each language, so we do a check of the parent culture.
            /// </devdoc>
            private CompareValue CompareWithParentValue(string name, object value) {
                Debug.Assert(name != null, "name is null");
    
                // If there is no parent culture, treat that as being different from the parent's resource,
                // which results in the "normal" code path for the caller.
                if (ReadCulture.Equals(CultureInfo.InvariantCulture))
                    return CompareValue.Different;
    
                CultureInfo culture = ReadCulture;
    
                for (;;) {
                    Debug.Assert(culture.Parent != culture, "should have exited loop when culture = InvariantCulture");
                    culture = culture.Parent;
    
                    Hashtable rs = GetResourceSet(culture);
                    
                    bool contains = (rs == null) ? false : rs.ContainsKey(name);
                    
                    if (contains) {
                        object parentValue = (rs != null) ? rs[name] : null;
                        
                        if (parentValue == value) {
                            return CompareValue.Same;
                        }
                        else if (parentValue != null) {
                            if (parentValue.Equals(value))
                                return CompareValue.Same;
                            else
                                return CompareValue.Different;
                        }
                        else {
                            return CompareValue.Different;
                        }
                    }
                    else if (culture.Equals(CultureInfo.InvariantCulture)) {
                        return CompareValue.New;
                    }
                }
            }
            
            /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.SerializationResourceManager.CreateResourceSet"]/*' />
            /// <devdoc>
            ///     Creates a resource set hashtable for the given resource
            ///     reader.
            /// </devdoc>
            private Hashtable CreateResourceSet(IResourceReader reader, CultureInfo culture) {
                Hashtable result = new Hashtable();
    
                // We need to guard against bad or unloadable resources.  We warn the user in the task
                // list here, but we will still load the designer.
                //
                try {
                    IDictionaryEnumerator resEnum = reader.GetEnumerator();
                    while (resEnum.MoveNext()) {
                        string name = (string)resEnum.Key;
                        object value = resEnum.Value;
                        result[name] = value;
                    }
                }
                catch (Exception e) {
                    string message = e.Message;
                    if (message == null || message.Length == 0) {
                        message = e.GetType().Name;
                    }
                    
                    Exception se;
                    
                    if (culture == CultureInfo.InvariantCulture) {
                        se = new SerializationException(SR.GetString(SR.SerializerResourceExceptionInvariant, message), e);
                    }
                    else {
                        se = new SerializationException(SR.GetString(SR.SerializerResourceException, culture.ToString(), message), e);
                    }
                    
                    manager.ReportError(se);
                }
    
                return result;
            }
            
            /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.SerializationResourceManager.GetEnumerator"]/*' />
            /// <devdoc>
            ///     This returns a dictionary enumerator for the given culture.  If no such resource file exists for the culture this 
            ///     will return null.
            /// </devdoc>
            public IDictionaryEnumerator GetEnumerator(CultureInfo culture) {
                Hashtable ht = GetResourceSet(culture);
                if (ht != null) {
                    return ht.GetEnumerator();
                }
                
                return null;
            }
    
            /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.SerializationResourceManager.GetObject"]/*' />
            /// <devdoc>
            ///     Overrides ResourceManager.GetObject to return the requested
            ///     object.  Returns null if the object couldn't be found.
            /// </devdoc>
            public override object GetObject(string resourceName) {
                return GetObject(resourceName, false);
            }
            
            /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.SerializationResourceManager.GetObject1"]/*' />
            /// <devdoc>
            ///     Retrieves the object of the given name from our resource bundle.
            ///     If forceInvariant is true, this will always use the invariant
            ///     resource, rather than using the current language.
            ///     Returns null if the object couldn't be found.
            /// </devdoc>
            public object GetObject(string resourceName, bool forceInvariant) {
            
                Debug.Assert(manager != null, "This resource manager object has been destroyed.");
    
                // We fetch the read culture if someone asks for a
                // culture-sensitive string.  If forceInvariant is set, we always
                // use the invariant culture.
                // 
                CultureInfo culture;
                
                if (forceInvariant) {
                    culture = CultureInfo.InvariantCulture;
                }
                else {
                    culture = ReadCulture;
                }
    
                object value = null;
    
                while (value == null) {
                    Hashtable rs = GetResourceSet(culture);
    
                    if (rs != null) {
                        value = rs[resourceName];
                    }

                    CultureInfo lastCulture = culture;
                    culture = culture.Parent;
                    if (lastCulture.Equals(culture)) {
                        break;
                    }
                }
    
                return value;
            }

            /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.SerializationResourceManager.GetResourceSet"]/*' />
            /// <devdoc>
            ///     Looks up the resource set in the resourceSets hash table, loading the set if it hasn't been loaded already.
            ///     Returns null if no resource that exists for that culture.
            /// </devdoc>
            private Hashtable GetResourceSet(CultureInfo culture) {
                Debug.Assert(culture != null, "null parameter");
                Hashtable rs = null;
                object objRs = ResourceTable[culture];
                if (objRs == null) {
                    IResourceService resSvc = (IResourceService)manager.GetService(typeof(IResourceService));
    
                    if (resSvc != null) {
                        IResourceReader reader = resSvc.GetResourceReader(culture);
                        if (reader != null) {
                            rs = CreateResourceSet(reader, culture);
                            reader.Close();
                            ResourceTable[culture] = rs;
                        }
                        else {

                            // Provide a sentinel so we don't repeatedly ask
                            // for the same resource.  If this is the invariant
                            // culture, always provide one.
                            //
                            if (culture.Equals(CultureInfo.InvariantCulture)) {
                                rs = new Hashtable();
                                ResourceTable[culture] = rs;
                            }
                            else {
                                ResourceTable[culture] = resourceSetSentinel;
                            }
                        }
                    }
                }
                else if (objRs is Hashtable) {
                    rs = (Hashtable)objRs;
                }
                else {
                    // the resourceSets hash table may contain our "this" pointer as a sentinel value
                    Debug.Assert(objRs == resourceSetSentinel, "unknown object in resourceSets: " + objRs);
                }
    
                return rs;
            }
            
            /// <devdoc>
            ///     Override of GetResourceSet from ResourceManager.
            /// </devdoc>
            public override ResourceSet GetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents) {

                if (culture == null) {
                    throw new ArgumentNullException("culture");
                }

                CultureInfo lastCulture = culture;

                do {
                    Hashtable ht = GetResourceSet(culture);
                    if (ht != null) {
                        return new CodeDomResourceSet(ht);
                    }

                    lastCulture = culture;
                    culture = culture.Parent;

                } while (tryParents && !lastCulture.Equals(culture));

                if (createIfNotExists) {
                    return new CodeDomResourceSet();
                }

                return null;
            }

            /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.SerializationResourceManager.GetString"]/*' />
            /// <devdoc>
            ///     Overrides ResourceManager.GetString to return the requested
            ///     string.  Returns null if the string couldn't be found.
            /// </devdoc>
            public override string GetString(string resourceName) {
                object o = GetObject(resourceName, false);
                if (o is string) {
                    return (string)o;
                }
                return null;
            }
            
            /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.SerializationResourceManager.OnSerializationComplete"]/*' />
            /// <devdoc>
            ///     Event handler that gets called when serialization or deserialization
            ///     is complete. Here we need to write any resources to disk.  Sine
            ///     we open resources for write on demand, this code handles the case
            ///     of reading resources as well.
            /// </devdoc>
            private void OnSerializationComplete(object sender, EventArgs e) {
                if (manager != null) {
                    manager.SerializationComplete -= new EventHandler(OnSerializationComplete);
                    IServiceContainer sc = (IServiceContainer)manager.GetService(typeof(IServiceContainer));
                    Debug.Assert(sc != null, "Serialization resource manager requires a serivce container");
                    if (sc != null) {
                        sc.RemoveService(typeof(SerializationResourceManager));
                    }
                }
                
                // Commit any changes we have made.
                //
                if (writer != null) {
                    writer.Close();
                    writer = null;
                }
    
                if (invariantCultureResourcesDirty) {
                    Debug.Assert(!ReadCulture.Equals(CultureInfo.InvariantCulture), 
                                 "invariantCultureResourcesDirty should only come into play when readCulture != CultureInfo.InvariantCulture; check that CompareWithParentValue is correct");
    
                    object objRs = ResourceTable[CultureInfo.InvariantCulture];
                    Debug.Assert(objRs != null && objRs is Hashtable, "ResourceSet for the InvariantCulture not loaded, but it's considered dirty?");
                    Hashtable resourceSet = (Hashtable) objRs;
    
                    IResourceService service = (IResourceService)manager.GetService(typeof(IResourceService));
                    if (service != null) {
                        IResourceWriter invariantWriter = service.GetResourceWriter(CultureInfo.InvariantCulture);
                        Debug.Assert(invariantWriter != null, "GetResourceWriter returned null for the InvariantCulture");
    
                        // Dump the hash table to the resource writer
                        //
                        IDictionaryEnumerator resEnum = resourceSet.GetEnumerator();
                        while (resEnum.MoveNext()) {
                            string name = (string)resEnum.Key;
                            object value = resEnum.Value;
                            invariantWriter.AddResource(name, value);
                        }
    
                        invariantWriter.Close();
                        invariantCultureResourcesDirty = false;
                    }
                    else {
                        Debug.Fail("Couldn't find IResourceService");
                        invariantCultureResourcesDirty = false;
                    }
                }
            }

            /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.SerializationResourceManager.SetValue"]/*' />
            /// <devdoc>
            ///     Writes the given resource value under the given name.
            ///     This checks the parent resource to see if the values are the
            ///     same.  If they are, the resource is not written.  If not, then
            ///     the resource is written.  We always write using the resource language
            ///     we read in with, so we don't stomp on the wrong resource data in the
            ///     event that someone changes the language.
            /// </devdoc>
            public void SetValue(IDesignerSerializationManager manager, string resourceName, object value, bool forceInvariant, bool shouldSerializeInvariant) {

                // Values we are going to serialize must be serializable or else
                // the resource writer will fail when we close it.
                //
                if (value != null && (!value.GetType().IsSerializable)) {
                    Debug.Fail("Cannot save a non-serializable value into resources.  Add serializable to " + (value == null ? "(null)" : value.GetType().Name));
                    return;
                }

                if (forceInvariant) {
                    if (ReadCulture.Equals(CultureInfo.InvariantCulture)) {
                        Writer.AddResource(resourceName, value);
                    }
                    else {
                        Hashtable resourceSet = GetResourceSet(CultureInfo.InvariantCulture);
                        
                        Debug.Assert(resourceSet != null, "No ResourceSet for the InvariantCulture?");

                        if (shouldSerializeInvariant) {
                            resourceSet[resourceName] = value;
                        }
                        else {
                            resourceSet.Remove(resourceName);
                        }
                        
                        invariantCultureResourcesDirty = true;
                    }
                }
                else {
                    CompareValue comparison = CompareWithParentValue(resourceName, value);
                    switch (comparison) {
                        case CompareValue.Same:
                            // don't add to any resource set
                            break;
        
                        case CompareValue.Different:
                            Writer.AddResource(resourceName, value);
                            break;
        
                        case CompareValue.New:
                            
                            #if NEW_LOC_MODEL

                            // This is a new value.  We want to write it out, PROVIDED
                            // that the value is not associated with a property that is currently
                            // returning false from ShouldSerializeValue.  This allows us to skip writing out
                            // Font == NULL on all non-invariant cultures, but still allow us to
                            // write out the value if the user is resetting a font back to null.
                            // If we cannot associate the value with a property we will write
                            // it out just to be safe.
                            //
                            // In addition, we need to handle the case of the user adding a new
                            // component to the non-invariant language.  This would be bad, because
                            // when he/she moved back to the invariant language the component's properties
                            // would all be defaults.  In order to minimize this problem, but still allow
                            // holes in the invariant resx, we also check to see if the property can
                            // be reset.  If it cannot be reset, that means that it has no meaningful
                            // default. Therefore, it should have appeared in the invariant resx and its
                            // absence indicates a new component.
                            //
                            bool writeValue = true;
                            bool writeInvariant = false;
                            PropertyDescriptor prop = (PropertyDescriptor)manager.Context[typeof(PropertyDescriptor)];
                            if (prop != null) {
                                CodeValueExpression codeValue = (CodeValueExpression)manager.Context[typeof(CodeValueExpression)];
                                if (codeValue != null && codeValue.Expression is CodePropertyReferenceExpression) {
                                    writeValue = prop.ShouldSerializeValue(codeValue.Value);
                                    writeInvariant = !prop.CanResetValue(codeValue.Value);
                                }
                            }

                            if (writeValue) {
                                Writer.AddResource(resourceName, value);

                                if (writeInvariant) {
                                    // Add resource to InvariantCulture
                                    Debug.Assert(!ReadCulture.Equals(CultureInfo.InvariantCulture), 
                                                 "invariantCultureResourcesDirty should only come into play when readCulture != CultureInfo.InvariantCulture; check that CompareWithParentValue is correct");

                                    Hashtable resourceSet = GetResourceSet(CultureInfo.InvariantCulture);
                                    Debug.Assert(resourceSet != null, "No ResourceSet for the InvariantCulture?");
                                    resourceSet[resourceName] = value;
                                    invariantCultureResourcesDirty = true;
                                }
                            }

                            #else
                            
                            // Add resource to InvariantCulture
                            Debug.Assert(!ReadCulture.Equals(CultureInfo.InvariantCulture), 
                                         "invariantCultureResourcesDirty should only come into play when readCulture != CultureInfo.InvariantCulture; check that CompareWithParentValue is correct");

                            Hashtable resourceSet = GetResourceSet(CultureInfo.InvariantCulture);
                            Debug.Assert(resourceSet != null, "No ResourceSet for the InvariantCulture?");
                            resourceSet[resourceName] = value;
                            invariantCultureResourcesDirty = true;
                            Writer.AddResource(resourceName, value);

                            #endif
                            break;
        
                        default:
                            Debug.Fail("Unknown CompareValue " + comparison);
                            break;
                    }
                }
            }
            
            /// <include file='doc\ResourceCodeDomSerializer.uex' path='docs/doc[@for="ResourceCodeDomSerializer.SerializationResourceManager.SetValue1"]/*' />
            /// <devdoc>
            ///     Writes the given resource value under the given name.
            ///     This checks the parent resource to see if the values are the
            ///     same.  If they are, the resource is not written.  If not, then
            ///     the resource is written.  We always write using the resource language
            ///     we read in with, so we don't stomp on the wrong resource data in the
            ///     event that someone changes the language.
            /// </devdoc>
            public string SetValue(IDesignerSerializationManager manager, CodeValueExpression codeValue, object value, bool forceInvariant, bool shouldSerializeInvariant) {
                string nameBase = null;
                bool appendCount = false;
                
                if (codeValue != null) {
                    if (codeValue.Value == RootComponent) {
                        nameBase = "$this";
                    }
                    else {
                        nameBase = manager.GetName(codeValue.Value);

                        if (nameBase == null) {
                            IReferenceService referenceService = (IReferenceService)manager.GetService(typeof(IReferenceService));
                            if (referenceService != null) {
                                nameBase = referenceService.GetName(codeValue.Value);
                            }
                        }
                    }
                    CodeExpression expression = codeValue.Expression;
                    
                    string expressionName;
                    
                    if (expression is CodePropertyReferenceExpression) {
                        expressionName = ((CodePropertyReferenceExpression)expression).PropertyName;
                    }
                    else if (expression is CodeFieldReferenceExpression) {
                        expressionName = ((CodeFieldReferenceExpression)expression).FieldName;
                    }
                    else if (expression is CodeMethodReferenceExpression) {
                        expressionName = ((CodeMethodReferenceExpression)expression).MethodName;
                        if (expressionName.StartsWith("Set")) {
                            expressionName = expressionName.Substring(3);
                        }
                    }
                    else {
                        expressionName = null;
                    }
                    
                    if (nameBase == null) {
                        nameBase = "resource";
                    }
                    
                    if (expressionName != null) {
                        nameBase += "." + expressionName;
                    }
                }
                else {
                    nameBase = "resource";
                    appendCount = true;
                }
                
                // Now find an unused name
                //
                string resourceName = nameBase;
                int count = 1;
                
                for(;;) {
                    if (appendCount) {
                        resourceName = nameBase + count.ToString();
                        count++;
                    }
                    else {
                        appendCount = true;
                    }
                    
                    if (!nameTable.ContainsKey(resourceName)) {
                        break;
                    }
                }
                
                // Now that we have a name, write out the resource.
                //
                SetValue(manager, resourceName, value, forceInvariant, shouldSerializeInvariant);
                
                nameTable[resourceName] = resourceName;
                return resourceName;
            }
    
            private class CodeDomResourceSet : ResourceSet {

                public CodeDomResourceSet() {
                }

                public CodeDomResourceSet(Hashtable resources) {
                    Table = resources;
                }
            }

            private enum CompareValue {
                Same, // parent value == child value
                Different, // parent value exists, but != child value
                New, // parent value does not exist
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\drawing\system\drawing\design\imageeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Design {
    
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    using System.IO;
    using System.Collections;
    using System.ComponentModel;
    using System.Windows.Forms;
    using System.Drawing;
    using System.Reflection;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;

    /// <include file='doc\ImageEditor.uex' path='docs/doc[@for="ImageEditor"]/*' />
    /// <devdoc>
    ///    <para>Provides an editor for visually picking an image.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ImageEditor : UITypeEditor {

        internal static Type[] imageExtenders = new Type[] { typeof(BitmapEditor), /*gpr typeof(Icon),*/ typeof(MetafileEditor)};
        internal FileDialog fileDialog = null;

        /// <include file='doc\ImageEditor.uex' path='docs/doc[@for="ImageEditor.CreateExtensionsString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected static string CreateExtensionsString(string[] extensions,string sep) {
            if (extensions == null || extensions.Length == 0)
                return null;
            string text = null;
            for (int i = 0; i < extensions.Length - 1; i++)
                text = text + "*." + extensions[i] + sep;
            text = text + "*." + extensions[extensions.Length-1];
            return text;
        }

        /// <include file='doc\ImageEditor.uex' path='docs/doc[@for="ImageEditor.CreateFilterEntry"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected static string CreateFilterEntry(ImageEditor e) {
            string desc = e.GetFileDialogDescription();
            string exts = CreateExtensionsString(e.GetExtensions(),",");
            string extsSemis = CreateExtensionsString(e.GetExtensions(),";");
            return desc + "(" + exts + ")|" + extsSemis;
        }

        /// <include file='doc\ImageEditor.uex' path='docs/doc[@for="ImageEditor.EditValue"]/*' />
        /// <devdoc>
        ///      Edits the given object value using the editor style provided by
        ///      GetEditorStyle.  A service provider is provided so that any
        ///      required editing services can be obtained.
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {
            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));

                if (edSvc != null) {
                    if (fileDialog == null) {
                        fileDialog = new OpenFileDialog();
                        string filter = CreateFilterEntry(this);
                        for (int i = 0; i < imageExtenders.Length; i++) {
                            ImageEditor e = (ImageEditor) Activator.CreateInstance(imageExtenders[i], BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null, null); //.CreateInstance();
                            Type myClass = this.GetType();
                            Type editorClass = e.GetType();
                            if (!myClass.Equals(editorClass) && e != null && myClass.IsInstanceOfType(e))
                                filter += "|" + CreateFilterEntry(e);
                        }
                        fileDialog.Filter = filter;
                    }

                    IntPtr hwndFocus = UnsafeNativeMethods.GetFocus();
                    try {
                        if (fileDialog.ShowDialog() == DialogResult.OK) {
                            FileStream file = new FileStream(fileDialog.FileName, FileMode.Open, FileAccess.Read, FileShare.Read);
                            value = LoadFromStream(file);
                        }
                    }
                    finally {
                        if (hwndFocus != IntPtr.Zero) {
                            UnsafeNativeMethods.SetFocus(hwndFocus);
                        }
                    }
                }
            }
            return value;
        }

        /// <include file='doc\ImageEditor.uex' path='docs/doc[@for="ImageEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///      Retrieves the editing style of the Edit method.  If the method
        ///      is not supported, this will return None.
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.Modal;
        }

        /// <include file='doc\ImageEditor.uex' path='docs/doc[@for="ImageEditor.GetFileDialogDescription"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual string GetFileDialogDescription() {
            return SR.GetString(SR.imageFileDescription);
        }

        /// <include file='doc\ImageEditor.uex' path='docs/doc[@for="ImageEditor.GetExtensions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual string[] GetExtensions() {
            // We should probably smash them together...
            ArrayList list = new ArrayList();
            for (int i = 0; i < imageExtenders.Length; i++) {
                ImageEditor e = (ImageEditor) Activator.CreateInstance(imageExtenders[i], BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, null, null, null);   //.CreateInstance();
                if (!e.GetType().Equals(typeof(ImageEditor)))
                    list.AddRange(new ArrayList(e.GetExtensions()));
            }
            return(string[]) list.ToArray(typeof(string));
        }

        /// <include file='doc\ImageEditor.uex' path='docs/doc[@for="ImageEditor.GetPaintValueSupported"]/*' />
        /// <devdoc>
        ///      Determines if this editor supports the painting of a representation
        ///      of an object's value.
        /// </devdoc>
        public override bool GetPaintValueSupported(ITypeDescriptorContext context) {
            return true;
        }

        /// <include file='doc\ImageEditor.uex' path='docs/doc[@for="ImageEditor.LoadFromStream"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual Image LoadFromStream(Stream stream) {
            //Copy the original stream to a buffer, then wrap a
            //memory stream around it.  This way we can avoid
            //locking the file
            byte[] buffer = new byte[stream.Length];
            stream.Read(buffer, 0, (int)stream.Length);
            MemoryStream ms = new MemoryStream(buffer);

            return Image.FromStream(ms);
        }

        /// <include file='doc\ImageEditor.uex' path='docs/doc[@for="ImageEditor.PaintValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Paints a representative value of the given object to the provided
        ///       canvas. Painting should be done within the boundaries of the
        ///       provided rectangle.
        ///    </para>
        /// </devdoc>
        public override void PaintValue(PaintValueEventArgs e) {
            if (e.Value is Image) {
                Image image = (Image) e.Value;
                Rectangle r = e.Bounds;
                r.Width --;
                r.Height--;
                e.Graphics.DrawRectangle(SystemPens.WindowFrame, r);
                e.Graphics.DrawImage(image, e.Bounds);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\drawing\system\drawing\design\coloreditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColorEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Design {
    using System.Runtime.Serialization.Formatters;

    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.IO;
    using System.Reflection;
    using System.Collections;
    using System.Globalization;

    using System.Windows.Forms;
    using System.Drawing;

    using Microsoft.Win32;
    using System.Windows.Forms.Design;
    using System.Windows.Forms.ComponentModel;

    using Accessibility;
                    
    /// <internalonly/>
    /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor"]/*' />
    /// <devdoc>
    ///    <para>Provides an editor for visually picking a color.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ColorEditor : UITypeEditor {

        private ColorUI colorUI;

        /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.EditValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Edits the given object value using the editor style
        ///       provided by <see cref='System.Drawing.Design.ColorEditor.GetEditStyle'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {

            object returnValue = value;

            if (provider != null) {
                IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));

                if (edSvc != null) {
                    if (colorUI == null) {
                        colorUI = new ColorUI(this);
                    }
                    colorUI.Start(edSvc, value);
                    edSvc.DropDownControl(colorUI);

                    if (colorUI.Value != null && ((Color) colorUI.Value) != Color.Empty) {
                            value = colorUI.Value;
                    }
                    

                    colorUI.End();
                }
            }

            return value;
        }

        /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the editing style of the Edit method. If the method
        ///       is not supported, this will return <see cref='System.Drawing.Design.UITypeEditorEditStyle.None'/>.
        ///    </para>
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.DropDown;
        }

        /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.GetPaintValueSupported"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating if this editor supports the painting of a representation
        ///       of an object's value.
        ///    </para>
        /// </devdoc>
        public override bool GetPaintValueSupported(ITypeDescriptorContext context) {
            return true;
        }

        /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.PaintValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Paints a representative value of the given object to the provided
        ///       canvas. Painting should be done within the boundaries of the
        ///       provided rectangle.
        ///    </para>
        /// </devdoc>
        public override void PaintValue(PaintValueEventArgs e) {
            if (e.Value is Color) {
                Color color = (Color)e.Value;
                SolidBrush b = new SolidBrush(color);
                e.Graphics.FillRectangle(b, e.Bounds);
                b.Dispose();
            }
        }

        /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.ColorPalette"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class ColorPalette : Control {

            public const int CELLS_ACROSS = 8;
            public const int CELLS_DOWN = 8;
            public const int CELLS_CUSTOM = 16; // last cells
            public const int CELLS = CELLS_ACROSS * CELLS_DOWN;
            public const int CELL_SIZE = 16;
            public const int MARGIN = 8;

            private static readonly int[] staticCells = new int[] {
                0x00ffffff, 0x00c0c0ff, 0x00c0e0ff, 0x00c0ffff,
                0x00c0ffc0, 0x00ffffc0, 0x00ffc0c0, 0x00ffc0ff,

                0x00e0e0e0, 0x008080ff, 0x0080c0ff, 0x0080ffff,
                0x0080ff80, 0x00ffff80, 0x00ff8080, 0x00ff80ff,

                0x00c0c0c0, 0x000000ff, 0x000080ff, 0x0000ffff,
                0x0000ff00, 0x00ffff00, 0x00ff0000, 0x00ff00ff,

                0x00808080, 0x000000c0, 0x000040c0, 0x0000c0c0,
                0x0000c000, 0x00c0c000, 0x00c00000, 0x00c000c0,

                0x00404040, 0x00000080, 0x00004080, 0x00008080,
                0x00008000, 0x00808000, 0x00800000, 0x00800080,

                0x00000000, 0x00000040, 0x00404080, 0x00004040,
                0x00004000, 0x00404000, 0x00400000, 0x00400040
            };

            private Color[] staticColors;
            private Color selectedColor;
            private Point focus = new Point(0, 0);
            private Color[] customColors;
            private EventHandler onPicked;
            private ColorUI colorUI;

            public ColorPalette(ColorUI colorUI, Color[] customColors) {
                this.colorUI = colorUI;
                SetStyle(ControlStyles.Opaque, true);

                BackColor = SystemColors.Control;

                Size = new Size(CELLS_ACROSS * (CELL_SIZE + MARGIN) + MARGIN + 2,
                                CELLS_DOWN * (CELL_SIZE + MARGIN) + MARGIN + 2);

                staticColors = new Color[CELLS - CELLS_CUSTOM];

                for (int i = 0; i < staticCells.Length; i++)
                    staticColors[i] = ColorTranslator.FromOle(staticCells[i]);

                this.customColors = customColors;
            }

            public Color[] CustomColors {
                get { return customColors;}
            }

            internal int FocusedCell {
                get {
                    return Get1DFrom2D(focus);
                }
            }

            public Color SelectedColor {
                get {
                    return selectedColor;
                }
                set {
                    if (!value.Equals(selectedColor)) {
                        InvalidateSelection();
                        selectedColor = value;
                        
                        SetFocus(GetCellFromColor(value));
                        InvalidateSelection();
                    }
                }
            }

            public event EventHandler Picked {
                add {
                    onPicked += value;
                }
                remove {
                    onPicked -= value;
                }
            }
            
            protected override AccessibleObject CreateAccessibilityInstance() {
                return new ColorPaletteAccessibleObject(this);
            } 

            protected void OnPicked(EventArgs e) {
                if (onPicked != null) {
                    onPicked(this, e);
                }
            }

            private void FillRectWithCellBounds(int across, int down, ref Rectangle rect) {

                rect.X = MARGIN + across * (CELL_SIZE + MARGIN);
                rect.Y = MARGIN + down * (CELL_SIZE + MARGIN);
                rect.Width = CELL_SIZE;
                rect.Height = CELL_SIZE;
            }
            
            private Point GetCellFromColor(Color c) {
                for (int y = 0; y < CELLS_DOWN; y++) {
                    for (int x = 0; x < CELLS_ACROSS; x++) {
                        if (GetColorFromCell(x, y).Equals(c)) {
                            return new Point(x, y);
                        }
                    }
                }
                return Point.Empty;
            }

            private Color GetColorFromCellMouse(int x, int y) {
                return GetColorFromCell(GetCellFromLocationMouse(x, y));
            }

            private Color GetColorFromCell(int across, int down) {
                return GetColorFromCell(Get1DFrom2D(across, down));
            }

            private Color GetColorFromCell(int index) {

                if (index < CELLS - CELLS_CUSTOM)
                    return staticColors[index];
                else
                    return customColors[index - CELLS + CELLS_CUSTOM];
            }

            private Point GetCell2DFromLocationMouse(int x, int y) {
            
                int across = x / (CELL_SIZE + MARGIN);
                int down = y / (CELL_SIZE + MARGIN);
                
                // Check if we're outside the cells
                //
                if (across < 0 || down < 0 || across >= CELLS_ACROSS || down >= CELLS_DOWN) {
                    return new Point(-1, -1);
                }
                             
                // Check if we're in the margin
                //
                if ((x - (CELL_SIZE + MARGIN) * across) < MARGIN ||
                    (y - (CELL_SIZE + MARGIN) * down) < MARGIN) {                    
                    return new Point(-1, -1);
                }
                
                return new Point(across, down);
            }

            private int GetCellFromLocationMouse(int x, int y) {
                return Get1DFrom2D(GetCell2DFromLocationMouse(x, y));
            }

            private int Get1DFrom2D(Point pt) {
                return Get1DFrom2D(pt.X, pt.Y);
            }
            
            private int Get1DFrom2D(int x, int y) {
                if (x == -1 || y == -1) {
                    return -1;
                }
                return x + CELLS_ACROSS*y;
            }
            
            internal Point Get2DFrom1D(int cell) {
                int x = cell % CELLS_ACROSS;
                int y = cell / CELLS_ACROSS;
                return new Point(x, y);
            }

            private void InvalidateSelection() {
                for (int y = 0; y < CELLS_DOWN; y++) {
                    for (int x = 0; x < CELLS_ACROSS; x++) {
                        if (SelectedColor.Equals(GetColorFromCell(x, y))) {
                            Rectangle r = new Rectangle();
                            FillRectWithCellBounds(x, y, ref r);
                            Invalidate(Rectangle.Inflate(r, 5, 5));
                            break;
                        }
                    }
                }
            }
            private void InvalidateFocus() {
                Rectangle r = new Rectangle();
                FillRectWithCellBounds(focus.X, focus.Y, ref r);
                Invalidate(Rectangle.Inflate(r, 5, 5));
                UnsafeNativeMethods.NotifyWinEvent((int)AccessibleEvents.Focus, this.Handle, UnsafeNativeMethods.OBJID_CLIENT, 1 + Get1DFrom2D(focus.X, focus.Y));
            }

            protected override bool IsInputKey(System.Windows.Forms.Keys keyData) {
                switch (keyData) {
                    case Keys.Left:
                    case Keys.Right:
                    case Keys.Up:
                    case Keys.Down:
                    case Keys.Enter:
                        return true;

                        // If we don't do this in ProcessDialogKey, VS will take it from us (ASURT 37231)
                    case Keys.F2:
                        return false;
                }
                return base.IsInputKey(keyData);
            }
            protected virtual void LaunchDialog(int customIndex) {
                Invalidate();
                colorUI.EditorService.CloseDropDown(); // It will be closed anyway as soon as it sees the WM_ACTIVATE
                CustomColorDialog dialog = new CustomColorDialog();

                IntPtr hwndFocus = UnsafeNativeMethods.GetFocus();
                try {

                    DialogResult result = dialog.ShowDialog();
                    if (result != DialogResult.Cancel) {
                        Color color = dialog.Color;
                        customColors[customIndex] = dialog.Color;
                        SelectedColor = customColors[customIndex];
                        OnPicked(EventArgs.Empty);
                    }
    
                    dialog.Dispose();
                }
                finally {
                    if (hwndFocus != IntPtr.Zero) {
                        UnsafeNativeMethods.SetFocus(hwndFocus);
                    }
                }
            }

            protected override void OnGotFocus(EventArgs e) {
                base.OnGotFocus(e);
                InvalidateFocus();
            }

            protected override void OnKeyDown(KeyEventArgs e) {
                base.OnKeyDown(e);
                switch (e.KeyCode) {
                    case Keys.Enter:
                        SelectedColor = GetColorFromCell(focus.X, focus.Y);
                        InvalidateFocus();
                        OnPicked(EventArgs.Empty);
                        break;
                    case Keys.Space:
                        SelectedColor = GetColorFromCell(focus.X, focus.Y);
                        InvalidateFocus();
                        break;
                    case Keys.Left:
                        SetFocus(new Point(focus.X - 1, focus.Y));
                        break;
                    case Keys.Right:
                        SetFocus(new Point(focus.X + 1, focus.Y));
                        break;
                    case Keys.Up:
                        SetFocus(new Point(focus.X, focus.Y - 1));
                        break;
                    case Keys.Down:
                        SetFocus(new Point(focus.X, focus.Y + 1));
                        break;
                }
            }
            protected override void OnLostFocus(EventArgs e) {
                base.OnLostFocus(e);
                InvalidateFocus();
            }

            protected override void OnMouseDown(MouseEventArgs me) {
                base.OnMouseDown(me);
                if (me.Button == MouseButtons.Left) {
                    Point cell2D = GetCell2DFromLocationMouse(me.X,me.Y);

                    if (cell2D.X != -1 && cell2D.Y != -1 && cell2D != focus) {
                        SetFocus(cell2D);
                    }
                }

            }
            protected override void OnMouseMove(MouseEventArgs me) {
                base.OnMouseMove(me);
                if (me.Button == MouseButtons.Left &&
                    Bounds.Contains(me.X, me.Y)) {
                    Point cell2D = GetCell2DFromLocationMouse(me.X,me.Y);

                    if (cell2D.X != -1 && cell2D.Y != -1 && cell2D != focus) {
                        SetFocus(cell2D);
                    }
                }
            }
            protected override void OnMouseUp(MouseEventArgs me) {
                base.OnMouseUp(me);

                if (me.Button == MouseButtons.Left) {
                    Point cell2D = GetCell2DFromLocationMouse(me.X,me.Y);
                    if (cell2D.X != -1 && cell2D.Y != -1) {
                        SetFocus(cell2D);
                        SelectedColor = GetColorFromCell(focus.X, focus.Y);
                        OnPicked(EventArgs.Empty);
                    }
                }
                else if (me.Button == MouseButtons.Right) {
                    int cell = GetCellFromLocationMouse(me.X,me.Y);
                    if (cell != -1 && cell >= (CELLS - CELLS_CUSTOM) && cell < CELLS) {
                        LaunchDialog(cell - CELLS + CELLS_CUSTOM);
                    }
                }
            }

            protected override void OnPaint(PaintEventArgs pe) {

                Graphics g = pe.Graphics;
                g.FillRectangle(new SolidBrush(BackColor), ClientRectangle);
                Rectangle rect = new Rectangle();
                Rectangle selectedRect = new Rectangle();

                rect.Width = CELL_SIZE;
                rect.Height = CELL_SIZE;
                rect.X = MARGIN;
                rect.Y = MARGIN;
                bool drawSelected =false;

                for (int y = 0; y < CELLS_DOWN; y++) {
                    for (int x = 0; x < CELLS_ACROSS; x++) {

                        Color cur = GetColorFromCell(Get1DFrom2D(x,y));

                        FillRectWithCellBounds(x, y, ref rect);

                        if (cur.Equals(SelectedColor) && !drawSelected) {
                            ControlPaint.DrawBorder(g, Rectangle.Inflate(rect, 3, 3), SystemColors.ControlText, ButtonBorderStyle.Solid);
                            drawSelected = true;
                        }

                        if (focus.X == x && focus.Y == y && Focused) {
                            ControlPaint.DrawFocusRectangle(g, Rectangle.Inflate(rect, 5, 5), SystemColors.ControlText, SystemColors.Control);
                        }


                        ControlPaint.DrawBorder(g, Rectangle.Inflate(rect, 2, 2),
                                                SystemColors.Control, 2, ButtonBorderStyle.Inset,
                                                SystemColors.Control, 2, ButtonBorderStyle.Inset,
                                                SystemColors.Control, 2, ButtonBorderStyle.Inset,
                                                SystemColors.Control, 2, ButtonBorderStyle.Inset);
                        PaintValue(cur,g,rect);
                    }
                }
            }

            private void PaintValue(Color color, Graphics g, Rectangle rect) {
                g.FillRectangle(new SolidBrush(color), rect);
            }

            protected override bool ProcessDialogKey(Keys keyData) {
                if (keyData == Keys.F2) { // no ctrl, alt, shift...
                    int cell = Get1DFrom2D(focus.X, focus.Y);
                    if (cell >= (CELLS - CELLS_CUSTOM) && cell < CELLS) {
                        LaunchDialog(cell - CELLS + CELLS_CUSTOM);
                        return true;
                    }
                }

                return base.ProcessDialogKey(keyData);
            }

            private void SetFocus(Point newFocus) {
                // Make sure newFocus is within correct range of cells
                //
                if (newFocus.X < 0) {
                    newFocus.X = 0;
                }
                if (newFocus.Y < 0) {
                    newFocus.Y = 0;
                }
                if (newFocus.X >= CELLS_ACROSS) {
                    newFocus.X = CELLS_ACROSS - 1;
                }
                if (newFocus.Y >= CELLS_DOWN) {
                    newFocus.Y = CELLS_DOWN - 1;
                }

                if (focus != newFocus) {
                    InvalidateFocus();
                    focus = newFocus;
                    InvalidateFocus();                    
                }
            }
            
            /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorPaletteAccessibleObject"]/*' />
            [ComVisible(true)]
            public class ColorPaletteAccessibleObject : ControlAccessibleObject {
                private ColorCellAccessibleObject[] cells;
            
                /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorPaletteAccessibleObject.ColorPaletteAccessibleObject"]/*' />
                public ColorPaletteAccessibleObject(ColorPalette owner) : base(owner) {
                    cells = new ColorCellAccessibleObject[CELLS_ACROSS * CELLS_DOWN];
                }
                
                internal ColorPalette ColorPalette {
                    get {
                        return (ColorPalette)Owner;
                    }
                }
                
                /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorPaletteAccessibleObject.GetChildCount"]/*' />
                public override int GetChildCount() {
                    return CELLS_ACROSS * CELLS_DOWN;
                }
                
                /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorPaletteAccessibleObject.GetChild"]/*' />
                public override AccessibleObject GetChild(int id) {
                    if (id < 0 || id >= CELLS_ACROSS * CELLS_DOWN) {
                        return null;
                    }
                    
                    if (cells[id] == null) {
                        cells[id] = new ColorCellAccessibleObject(this, ColorPalette.GetColorFromCell(id), id);
                    }
                    return cells[id];
                }
                
                /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorPaletteAccessibleObject.HitTest"]/*' />
                public override AccessibleObject HitTest(int x, int y) {
                    // Convert from screen to client coordinates
                    //
                    NativeMethods.POINT pt = new NativeMethods.POINT(x, y);
                    UnsafeNativeMethods.ScreenToClient(ColorPalette.Handle, pt);
                    
                    int cell = ColorPalette.GetCellFromLocationMouse(pt.x, pt.y);
                    if (cell != -1) {
                        return GetChild(cell);    
                    }
                     
                    return base.HitTest(x, y);
                }
                
                /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorCellAccessibleObject"]/*' />
                [ComVisible(true)]
                public class ColorCellAccessibleObject : AccessibleObject {
                    private Color color;
                    private ColorPaletteAccessibleObject parent;
                    private int cell;
                    
                    /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorCellAccessibleObject.ColorCellAccessibleObject"]/*' />
                    public ColorCellAccessibleObject(ColorPaletteAccessibleObject parent, Color color, int cell) {
                        this.color = color;
                        this.parent = parent;
                        this.cell = cell;
                    }
                    
                    /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorCellAccessibleObject.Bounds"]/*' />
                    public override Rectangle Bounds {
                        get {
                            Point cellPt = parent.ColorPalette.Get2DFrom1D(cell);
                            Rectangle rect = new Rectangle();
                            parent.ColorPalette.FillRectWithCellBounds(cellPt.X, cellPt.Y, ref rect);
                            
                            // Translate rect to screen coordinates
                            //
                            NativeMethods.POINT pt = new NativeMethods.POINT(rect.X, rect.Y);
                            UnsafeNativeMethods.ClientToScreen(parent.ColorPalette.Handle, pt);

                            return new Rectangle(pt.x, pt.y, rect.Width, rect.Height);
                        }
                    }
                    
                    /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorCellAccessibleObject.Name"]/*' />
                    public override string Name {
                        get {
                            return color.ToString();
                        }
                    }
                    
                    /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorCellAccessibleObject.Parent"]/*' />
                    public override AccessibleObject Parent {
                        get {
                            return parent;
                        }
                    }
                    
                    /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorCellAccessibleObject.Role"]/*' />
                    public override AccessibleRole Role {
                        get {
                            return AccessibleRole.Cell;
                        }
                    }

                    public override AccessibleStates State {
                        get {
                            AccessibleStates state = base.State;
                            if (this.cell == parent.ColorPalette.FocusedCell) {
                                state |= AccessibleStates.Focused;
                            }
                            return state;
                        }
                    }
                    
                    /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorCellAccessibleObject.Value"]/*' />
                    public override string Value {
                        get {
                            return color.ToString();
                        }
                    }
                }
            }
        }

        /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.ColorUI"]/*' />
        /// <devdoc>
        ///      Editor UI for the color editor.
        /// </devdoc>
        private class ColorUI : Control {

            private ColorEditor editor;
            private IWindowsFormsEditorService edSvc;
            private object value;
            private ColorEditorTabControl tabControl;
            private TabPage systemTabPage;
            private TabPage commonTabPage;
            private TabPage paletteTabPage;
            private ListBox lbSystem;
            private ListBox lbCommon;
            private ColorPalette pal;
            private object[] systemColorConstants;
            private object[] colorConstants;
            private Color[] customColors;
            private bool commonHeightSet = false;
            private bool systemHeightSet = false;

            /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.ColorUI.ColorUI"]/*' />
            /// <devdoc>
            /// </devdoc>
            public ColorUI(ColorEditor editor) {
                this.editor = editor;
                InitializeComponent();
                AdjustListBoxItemHeight();
            }

            /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.ColorUI.ColorValues"]/*' />
            /// <devdoc>
            ///      Array of standard colors.
            /// </devdoc>
            private object[] ColorValues {
                get {
                    if (colorConstants == null) {
                        colorConstants = GetConstants(typeof(Color));
                    }

                    return colorConstants;
                }
            }

            /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.ColorUI.CustomColors"]/*' />
            /// <devdoc>
            ///      Retrieves the array of custom colors for our use.
            /// </devdoc>
            private Color[] CustomColors {
                get {
                    if (customColors == null) {
                        customColors = new Color[ColorPalette.CELLS_CUSTOM];
                        for (int i = 0; i < ColorPalette.CELLS_CUSTOM; i++) {
                            customColors[i] = Color.White;
                        }
                    }
                    return customColors;
                }

                set {
                    this.customColors = customColors;
                    pal = null;
                }
            }

            /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.ColorUI.EditorService"]/*' />
            /// <devdoc>
            ///      Allows someone else to close our dropdown.
            /// </devdoc>
            public IWindowsFormsEditorService EditorService {
                get {
                    return edSvc;
                }
            }

            /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.ColorUI.SystemColorValues"]/*' />
            /// <devdoc> 
            ///      Array of system colors.
            /// </devdoc>
            private object[] SystemColorValues {
                get {
                    if (systemColorConstants == null) {
                        systemColorConstants = GetConstants(typeof(SystemColors));
                    }

                    return systemColorConstants;
                }
            }

            /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.ColorUI.Value"]/*' />
            /// <devdoc>
            /// </devdoc>
            public object Value {
                get {
                    return value;
                }
            }

            /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.ColorUI.End"]/*' />
            /// <devdoc>
            /// </devdoc>
            public void End() {
                edSvc = null;
                value = null;
            }

            private void AdjustColorUIHeight() {
                // Compute the default size for the color UI
                //
                Size size = pal.Size;
                Rectangle rectItemSize = tabControl.GetTabRect(0);
                int CMARGIN = 0;
                this.Size = new Size(size.Width + 2*CMARGIN, size.Height + 2*CMARGIN + rectItemSize.Height);
                tabControl.Size = this.Size;
            }
            
            private void AdjustListBoxItemHeight() {
                lbSystem.ItemHeight = Font.Height + 2;
                lbCommon.ItemHeight = Font.Height + 2;
            }
            
            /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.ColorUI.GetBestColor"]/*' />
            /// <devdoc>
            ///      Takes the given color and looks for an instance in the ColorValues table.
            /// </devdoc>
            private Color GetBestColor(Color color) {
                object[] colors = ColorValues;
                int rgb = color.ToArgb();
                for (int i = 0; i < colors.Length; i++) {
                    if (((Color)colors[i]).ToArgb() == rgb) {
                        return(Color)colors[i];
                    }
                }
                return color;
            }

            /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.ColorUI.GetConstants"]/*' />
            /// <devdoc>
            ///      Retrieves an array of color constants for the given object.
            /// </devdoc>
            private object[] GetConstants(Type enumType) {
                MethodAttributes attrs = MethodAttributes.Public | MethodAttributes.Static;
                PropertyInfo[] props = enumType.GetProperties();

                ArrayList colorList = new ArrayList();

                for (int i = 0; i < props.Length; i++) {
                    PropertyInfo prop = props[i];
                    if (prop.PropertyType == typeof(Color)) {
                        MethodInfo method = prop.GetGetMethod();
                        if (method != null && (method.Attributes & attrs) == attrs) {
                            object[] tempIndex = null;
                            colorList.Add(prop.GetValue(null, tempIndex));
                        }
                    }
                }

                return colorList.ToArray();
            }

            /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.ColorUI.GetCurrentComponent"]/*' />
            /// <devdoc>
            /// </devdoc>
            private Control GetCurrentComponent() {
                if (tabControl.SelectedTab == systemTabPage) {
                    return lbSystem;
                }
                else if (tabControl.SelectedTab == commonTabPage) {
                    return lbCommon;
                }
                else {
                    return pal;
                }
            }

            /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.ColorUI.InitializeComponent"]/*' />
            /// <devdoc>
            /// </devdoc>
            private void InitializeComponent() {
                paletteTabPage = new TabPage(SR.GetString(SR.ColorEditorPaletteTab));
                commonTabPage = new TabPage(SR.GetString(SR.ColorEditorStandardTab));
                systemTabPage = new TabPage(SR.GetString(SR.ColorEditorSystemTab));
                
                tabControl = new ColorEditorTabControl();
                tabControl.TabPages.Add(paletteTabPage);
                tabControl.TabPages.Add(commonTabPage);
                tabControl.TabPages.Add(systemTabPage);
                tabControl.TabStop = false;
                tabControl.SelectedTab = systemTabPage;
                tabControl.SelectedIndexChanged += new EventHandler(this.OnTabControlSelChange);
                tabControl.Dock = DockStyle.Fill;
                tabControl.Resize += new EventHandler(this.OnTabControlResize);
                
                lbSystem = new ColorEditorListBox();
                lbSystem.DrawMode = DrawMode.OwnerDrawFixed;
                lbSystem.BorderStyle = BorderStyle.FixedSingle;
                lbSystem.IntegralHeight = false;
                lbSystem.Sorted = false;
                lbSystem.Click += new EventHandler(this.OnListClick);
                lbSystem.DrawItem += new DrawItemEventHandler(this.OnListDrawItem);
                lbSystem.KeyDown += new KeyEventHandler(this.OnListKeyDown);
                lbSystem.Dock = DockStyle.Fill;
                lbSystem.FontChanged += new EventHandler( this.OnFontChanged );

                lbCommon = new ColorEditorListBox();
                lbCommon.DrawMode = DrawMode.OwnerDrawFixed;
                lbCommon.BorderStyle = BorderStyle.FixedSingle;
                lbCommon.IntegralHeight = false;
                lbCommon.Sorted = false;
                lbCommon.Click += new EventHandler(this.OnListClick);
                lbCommon.DrawItem += new DrawItemEventHandler(this.OnListDrawItem);
                lbCommon.KeyDown += new KeyEventHandler(this.OnListKeyDown);
                lbCommon.Dock = DockStyle.Fill;

                Array.Sort(ColorValues, new StandardColorComparer());
                Array.Sort(SystemColorValues, new SystemColorComparer());

                lbCommon.Items.Clear();
                foreach(object color in ColorValues) {
                    lbCommon.Items.Add(color);
                }
                lbSystem.Items.Clear();
                foreach(object color in SystemColorValues) {
                    lbSystem.Items.Add(color);
                }

                pal = new ColorPalette(this, CustomColors);
                pal.Picked += new EventHandler(this.OnPalettePick);
                
                paletteTabPage.Controls.Add(pal);
                systemTabPage.Controls.Add(lbSystem);
                commonTabPage.Controls.Add(lbCommon);

                this.Controls.Add(tabControl);
            }

            protected override void OnGotFocus(EventArgs e) {
                base.OnGotFocus(e);
                OnTabControlSelChange(this, EventArgs.Empty);
            }

            private void OnFontChanged( object sender, EventArgs e ) {
                commonHeightSet = systemHeightSet = false;
            }
            
            /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.ColorUI.OnListClick"]/*' />
            /// <devdoc>
            /// </devdoc>
            private void OnListClick(object sender, EventArgs e) {
                ListBox lb = (ListBox)sender;
                value = (Color)lb.SelectedItem;
                edSvc.CloseDropDown();
            }

            /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.ColorUI.OnListDrawItem"]/*' />
            /// <devdoc>
            /// </devdoc>
            private void OnListDrawItem(object sender, DrawItemEventArgs die) {
                ListBox lb = (ListBox)sender;
                object value = lb.Items[die.Index];
                Font font = Font;

                if (lb == lbCommon && !commonHeightSet) {
                    lb.ItemHeight = lb.Font.Height;
                    commonHeightSet = true;
                }
                else if (lb == lbSystem && !systemHeightSet) {
                    lb.ItemHeight = lb.Font.Height;
                    systemHeightSet = true;
                }
                
                Graphics graphics = die.Graphics;
                die.DrawBackground();

                editor.PaintValue(value, graphics, new Rectangle(die.Bounds.X + 2, die.Bounds.Y + 2, 22, die.Bounds.Height - 4));
                graphics.DrawRectangle(SystemPens.WindowText, new Rectangle(die.Bounds.X + 2, die.Bounds.Y + 2, 22 - 1, die.Bounds.Height - 4 - 1));
                Brush foreBrush = new SolidBrush(die.ForeColor);
                graphics.DrawString(((Color)value).Name, font, foreBrush, die.Bounds.X + 26, die.Bounds.Y);
                foreBrush.Dispose();
            }

            /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.ColorUI.OnListKeyDown"]/*' />
            /// <devdoc>
            /// </devdoc>
            private void OnListKeyDown(object sender, KeyEventArgs ke) {
                if (ke.KeyCode == Keys.Return) {
                    OnListClick(sender, EventArgs.Empty);
                }
            }

            /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.ColorUI.OnPalettePick"]/*' />
            /// <devdoc>
            /// </devdoc>
            private void OnPalettePick(object sender, EventArgs e) {
                ColorPalette p = (ColorPalette)sender;
                value = GetBestColor(p.SelectedColor);
                edSvc.CloseDropDown();
            }

            protected override void OnFontChanged(EventArgs e) {
                base.OnFontChanged(e);
                AdjustListBoxItemHeight();
                AdjustColorUIHeight();
            }

            /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.ColorUI.OnTabControlResize"]/*' />
            /// <devdoc>
            /// </devdoc>
            private void OnTabControlResize(object sender, EventArgs e) {
                Rectangle rectTabControl = tabControl.TabPages[0].ClientRectangle;
                Rectangle rectItemSize = tabControl.GetTabRect(1);
                rectTabControl.Y = 0;
                rectTabControl.Height -= rectTabControl.Y;
                int CMARGIN = 2;
                lbSystem.SetBounds(CMARGIN, rectTabControl.Y + 2*CMARGIN,
                                   rectTabControl.Width - CMARGIN,
                                   pal.Size.Height - rectItemSize.Height + 2*CMARGIN);
                lbCommon.Bounds = lbSystem.Bounds;
                pal.Location = new Point(0, rectTabControl.Y);
            }

            private void OnTabControlSelChange(object sender, EventArgs e) {
                TabPage selectedPage = tabControl.SelectedTab;

                if (selectedPage!= null && selectedPage.Controls.Count > 0) {
                    selectedPage.Controls[0].Focus();
                }
            }
            
            protected override bool ProcessDialogKey(Keys keyData) {
                // We treat tab characters as switching tab pages.  In most other contexts,
                // ctrl-tab switches tab pages, but I couldn't get that to work, and besides,
                // then there would be nothing for tab to do in this editor.
                if ((keyData & Keys.Alt) == 0
                    && (keyData & Keys.Control) == 0
                    && (keyData & Keys.KeyCode) == Keys.Tab) {

                    // Logic taken straight out of TabBase
                    bool forward = (keyData & Keys.Shift) == 0;
                    int sel = tabControl.SelectedIndex;
                    if (sel != -1) {
                        int count = tabControl.TabPages.Count;
                        if (forward)
                            sel = (sel + 1) % count;
                        else
                            sel = (sel + count - 1) % count;
                        tabControl.SelectedTab = tabControl.TabPages[sel];

                        return true;
                    }
                }
                return base.ProcessDialogKey(keyData);
            }

            /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.ColorUI.Start"]/*' />
            /// <devdoc>  
            /// </devdoc>
            public void Start(IWindowsFormsEditorService edSvc, object value) {
                this.edSvc = edSvc;
                this.value = value;

                AdjustColorUIHeight();

                // Now look for the current color so we can select the proper tab.
                //
                if (value != null) {
                    object[] values = ColorValues;
                    TabPage selectedTab = paletteTabPage;

                    for (int i = 0; i < values.Length; i++) {
                        if (values[i].Equals(value)) {
                            lbCommon.SelectedItem = value;
                            selectedTab = commonTabPage;
                            break;
                        }
                    }

                    if (selectedTab == paletteTabPage) {
                        values = SystemColorValues;
                        for (int i = 0; i < values.Length; i++) {
                            if (values[i].Equals(value)) {
                                lbSystem.SelectedItem = value;
                                selectedTab = systemTabPage;
                                break;
                            }
                        }
                    }

                    tabControl.SelectedTab = selectedTab;
                }
            }
            

            private class ColorEditorListBox : ListBox {
                protected override bool IsInputKey(System.Windows.Forms.Keys keyData) {
                    switch (keyData) {
                        case Keys.Return:
                            return true;
                    }
                    return base.IsInputKey(keyData);
                }
            }

            private class ColorEditorTabControl : TabControl {
                public ColorEditorTabControl() : base() {
                }
                
                protected override void OnGotFocus(EventArgs e) {
                    TabPage selectedTab = this.SelectedTab;
                    if (selectedTab != null && selectedTab.Controls.Count > 0) {
                        selectedTab.Controls[0].Focus();
                    }
                }
            }
        }

        /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.CustomColorDialog"]/*' />
        /// <devdoc>
        /// </devdoc>
        private class CustomColorDialog : ColorDialog {

            private const int COLOR_HUE = 703;
            private const int COLOR_SAT = 704;
            private const int COLOR_LUM = 705;
            private const int COLOR_RED = 706;
            private const int COLOR_GREEN = 707;
            private const int COLOR_BLUE = 708;
            private const int COLOR_ADD = 712;
            private const int COLOR_MIX = 719;

            private IntPtr hInstance;

            public CustomColorDialog() {
                // colordlg.data was copied from VB6's dlg-4300.dlg
                Stream stream = typeof(ColorEditor).Module.Assembly.GetManifestResourceStream(typeof(ColorEditor), "colordlg.data");

                int size = (int)(stream.Length - stream.Position);
                byte[] buffer = new byte[size];
                stream.Read(buffer, 0, size);

                hInstance = Marshal.AllocHGlobal(size);
                Marshal.Copy(buffer,0,hInstance,size);
            }

            protected override IntPtr Instance {
                get { 
                    Debug.Assert(hInstance != IntPtr.Zero, "Dialog has been disposed");
                    return hInstance;
                }
            }

            protected override int Options {
                get {
                    return NativeMethods.CC_FULLOPEN | NativeMethods.CC_ENABLETEMPLATEHANDLE;
                }
            }

            protected override void Dispose(bool disposing) {
                if (hInstance != IntPtr.Zero) {
                    Marshal.FreeHGlobal(hInstance);
                    hInstance = IntPtr.Zero;
                }
                base.Dispose(disposing);
            }

            protected override IntPtr HookProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam) {

                switch (msg) {
                    case NativeMethods.WM_INITDIALOG:
                        NativeMethods.SendDlgItemMessage(hwnd, COLOR_HUE,   NativeMethods.EM_SETMARGINS, (IntPtr)(NativeMethods.EC_LEFTMARGIN|NativeMethods.EC_RIGHTMARGIN), IntPtr.Zero);
                        NativeMethods.SendDlgItemMessage(hwnd, COLOR_SAT,   NativeMethods.EM_SETMARGINS, (IntPtr)(NativeMethods.EC_LEFTMARGIN|NativeMethods.EC_RIGHTMARGIN), IntPtr.Zero);
                        NativeMethods.SendDlgItemMessage(hwnd, COLOR_LUM,   NativeMethods.EM_SETMARGINS, (IntPtr)(NativeMethods.EC_LEFTMARGIN|NativeMethods.EC_RIGHTMARGIN), IntPtr.Zero);
                        NativeMethods.SendDlgItemMessage(hwnd, COLOR_RED,   NativeMethods.EM_SETMARGINS, (IntPtr)(NativeMethods.EC_LEFTMARGIN|NativeMethods.EC_RIGHTMARGIN), IntPtr.Zero);
                        NativeMethods.SendDlgItemMessage(hwnd, COLOR_GREEN, NativeMethods.EM_SETMARGINS, (IntPtr)(NativeMethods.EC_LEFTMARGIN|NativeMethods.EC_RIGHTMARGIN), IntPtr.Zero);
                        NativeMethods.SendDlgItemMessage(hwnd, COLOR_BLUE,  NativeMethods.EM_SETMARGINS, (IntPtr)(NativeMethods.EC_LEFTMARGIN|NativeMethods.EC_RIGHTMARGIN), IntPtr.Zero);
                        IntPtr hwndCtl = NativeMethods.GetDlgItem(hwnd,COLOR_MIX);
                        NativeMethods.EnableWindow(hwndCtl, false);
                        NativeMethods.SetWindowPos(hwndCtl, IntPtr.Zero, 0, 0, 0, 0, NativeMethods.SWP_HIDEWINDOW);
                        hwndCtl = NativeMethods.GetDlgItem(hwnd,NativeMethods.IDOK);
                        NativeMethods.EnableWindow(hwndCtl, false);
                        NativeMethods.SetWindowPos(hwndCtl, IntPtr.Zero, 0, 0, 0, 0, NativeMethods.SWP_HIDEWINDOW);
                        this.Color = Color.Empty;
                        break;
                    case NativeMethods.WM_COMMAND:
                        switch (NativeMethods.Util.LOWORD((int)wParam)) {
                            case COLOR_ADD:
                                byte red, green, blue;
                                bool[] err = new bool[1];
                                red = (byte)NativeMethods.GetDlgItemInt(hwnd, COLOR_RED, err, false);
                                Debug.Assert(!err[0], "Couldn't find dialog member COLOR_RED");
                                green = (byte)NativeMethods.GetDlgItemInt(hwnd, COLOR_GREEN, err, false);
                                Debug.Assert(!err[0], "Couldn't find dialog member COLOR_GREEN");
                                blue = (byte)NativeMethods.GetDlgItemInt(hwnd, COLOR_BLUE, err, false);
                                Debug.Assert(!err[0], "Couldn't find dialog member COLOR_BLUE");
                                this.Color = Color.FromArgb(red,green,blue);
                                NativeMethods.PostMessage(hwnd, NativeMethods.WM_COMMAND, (IntPtr)NativeMethods.Util.MAKELONG(NativeMethods.IDOK,0),NativeMethods.GetDlgItem(hwnd,NativeMethods.IDOK));
                break;
                        }
                        break;
                }
                return base.HookProc(hwnd,msg,wParam,lParam);
            }
        }

        /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.SystemColorComparer"]/*' />
        /// <devdoc>
        ///      Comparer for system colors.
        /// </devdoc>
        private class SystemColorComparer : IComparer {
            public int Compare(object x, object y) {
                return String.Compare(((Color)x).Name, ((Color)y).Name, false, CultureInfo.InvariantCulture);
            }
        }

        /// <include file='doc\ColorEditor.uex' path='docs/doc[@for="ColorEditor.StandardColorComparer"]/*' />
        /// <devdoc>
        ///      Comparer for standard colors
        /// </devdoc>
        private class StandardColorComparer : IComparer {
            public int Compare(object x, object y) {
                Color left = (Color)x;
                Color right = (Color)y;

                if (left.A < right.A) {
                    return -1;
                }
                else if (left.A > right.A) {
                    return 1;
                }
                else {
                    if ((float)left.GetHue() < (float)right.GetHue()) {
                        return -1;
                    }
                    else if ((float)left.GetHue() > (float)right.GetHue()) {
                        return 1;
                    }
                    else {
                        if ((float)left.GetSaturation() < (float)right.GetSaturation()) {
                            return -1;
                        }
                        else if ((float)left.GetSaturation() > (float)right.GetSaturation()) {
                            return 1;
                        }
                        else {
                            if ((float)left.GetBrightness() < (float)right.GetBrightness()) {
                                return -1;
                            }
                            else if ((float)left.GetBrightness() > (float)right.GetBrightness()) {
                                return 1;
                            }
                            else {
                                return 0;
                            }
                        }
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\monitoring\system\diagnostics\design\fswpatheditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="FSWPathEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics.Design {

    using System;
    using System.Windows.Forms.Design;

    /// <include file='doc\FSWPathEditor.uex' path='docs/doc[@for="FSWPathEditor"]/*' />
    /// <devdoc>
    ///     Folder editor for choosing the path to watch.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class FSWPathEditor : FolderNameEditor {
        
        protected override void InitializeDialog(FolderBrowser folderBrowser) {
            folderBrowser.Description = System.Design.SR.GetString(System.Design.SR.FSWPathEditorLabel);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\drawing\system\drawing\design\unsafenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnsafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Design {
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [
    System.Runtime.InteropServices.ComVisible(false), 
    System.Security.SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class UnsafeNativeMethods {
        
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int ClientToScreen( IntPtr hWnd, [In, Out] NativeMethods.POINT pt );
        
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int ScreenToClient( IntPtr hWnd, [In, Out] NativeMethods.POINT pt );

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr SetFocus(IntPtr hWnd);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GetFocus();

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern void NotifyWinEvent(int winEvent, IntPtr hwnd, int objType, int objID);

        public const int OBJID_CLIENT = unchecked(unchecked((int)0xFFFFFFFC));
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\monitoring\system\diagnostics\design\logconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="LogConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Diagnostics.Design {
    using System.Runtime.Serialization.Formatters;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Windows.Forms;
    using Microsoft.Win32;    
    using System.ComponentModel.Design;
    using System.Globalization;

    /// <include file='doc\LogConverter.uex' path='docs/doc[@for="LogConverter"]/*' />
    /// <devdoc>
    /// LogConverter is the TypeConverter for the Log property on EventLog. It returns
    /// a list of all event logs on the system.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class LogConverter : TypeConverter {
        /// <include file='doc\LogConverter.uex' path='docs/doc[@for="LogConverter.values"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides a <see cref='System.ComponentModel.TypeConverter.StandardValuesCollection'/> that specifies the
        ///       possible values for the enumeration.
        ///    </para>
        /// </devdoc>
        private StandardValuesCollection values;
        private string oldMachineName;
        
        /// <include file='doc\LogConverter.uex' path='docs/doc[@for="LogConverter.LogConverter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the LogConverter class for the given
        ///       type.
        ///    </para>
        /// </devdoc>
        public LogConverter() {
        }
        
        /// <include file='doc\LogConverter.uex' path='docs/doc[@for="LogConverter.CanConvertFrom"]/*' />
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }
        
        /// <include file='doc\LogConverter.uex' path='docs/doc[@for="LogConverter.ConvertFrom"]/*' />
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                string text = ((string)value).Trim();
                return text;
            }
            return base.ConvertFrom(context, culture, value);
        }
                
        /// <include file='doc\LogConverter.uex' path='docs/doc[@for="LogConverter.GetStandardValues"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a collection of standard values for the data type this validator is
        ///       designed for.</para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {            
            EventLog component = (context == null) ? null : context.Instance as EventLog;                
            string machineName = ".";
            if (component != null)
                machineName = component.MachineName;
                            
            if (values == null || machineName != oldMachineName) {                
                try {
                    EventLog[] eventLogs = EventLog.GetEventLogs(machineName);
                    object[] names = new object[eventLogs.Length];
                    for (int i = 0; i < names.Length; i++)
                        names[i] = eventLogs[i].Log;
                    values = new StandardValuesCollection(names);
                    oldMachineName = machineName;
                }
                catch(Exception) {  
                    //Do Nothing
                }
            }
            return values;
        }
    
                                                                                                                                                    
        /// <include file='doc\LogConverter.uex' path='docs/doc[@for="LogConverter.GetStandardValuesSupported"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating
        ///       whether this object
        ///       supports a standard set of values that can be picked
        ///       from a list using the specified context.</para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\monitoring\system\diagnostics\design\processmoduledesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProcessModuleDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Diagnostics.Design {
    using System.Runtime.Serialization.Formatters;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Windows.Forms;
    using Microsoft.Win32;    
    using System.ComponentModel.Design;
    using System.Globalization;

    /// <include file='doc\ProcessModuleDesigner.uex' path='docs/doc[@for="ProcessModuleDesigner"]/*' />
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ProcessModuleDesigner : ComponentDesigner {

        /// <include file='doc\ProcessModuleDesigner.uex' path='docs/doc[@for="ProcessModuleDesigner.PreFilterProperties"]/*' />
        protected override void PreFilterProperties(IDictionary properties) {
            base.PreFilterProperties(properties);
            RuntimeComponentFilter.FilterProperties(properties, null, new string[]{"FileVersionInfo"});
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\monitoring\system\diagnostics\design\processdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProcessDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Diagnostics.Design {
    using System.Runtime.Serialization.Formatters;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Windows.Forms;
    using Microsoft.Win32;    
    using System.ComponentModel.Design;
    using System.Globalization;

    /// <include file='doc\ProcessDesigner.uex' path='docs/doc[@for="ProcessDesigner"]/*' />
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ProcessDesigner : ComponentDesigner {

        /// <include file='doc\ProcessDesigner.uex' path='docs/doc[@for="ProcessDesigner.PreFilterProperties"]/*' />
        protected override void PreFilterProperties(IDictionary properties) {
            base.PreFilterProperties(properties);
            RuntimeComponentFilter.FilterProperties(properties, 
                                                    null,
                                                    new string[]{"SynchronizingObject","EnableRaisingEvents", "StartInfo",
                                                                 "BasePriority", "HandleCount", "Id",
                                                                 "MainWindowHandle", "MainWindowTitle", "MaxWorkingSet",
                                                                 "MinWorkingSet", "NonpagedSystemMemorySize", "PagedMemorySize",
                                                                 "PagedSystemMemorySize", "PeakPagedMemorySize", "PeakWorkingSet",
                                                                 "PeakVirtualMemorySize", "PriorityBoostEnabled", "PriorityClass",
                                                                 "PrivateMemorySize", "PrivilegedProcessorTime", "ProcessName",
                                                                 "ProcessorAffinity", "Responding", "StartTime",
                                                                 "TotalProcessorTime", "UserProcessorTime", "VirtualMemorySize", 
                                                                 "WorkingSet"},
                                                    new bool[] { true, true, true,
                                                                 false, false, false,
                                                                 false, false, false,
                                                                 false, false, false, 
                                                                 false, false, false,
                                                                 false, false, false,
                                                                 false, false, false,
                                                                 false, false, false,
                                                                 false, false, false,
                                                                 false } );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\services\system\messaging\design\messagedesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="MessageDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Messaging.Design {
    using System.Runtime.Serialization.Formatters;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Windows.Forms;
    using Microsoft.Win32;    
    using System.ComponentModel.Design;
    using System.Globalization;
    

    /// <include file='doc\MessageDesigner.uex' path='docs/doc[@for="MessageDesigner"]/*' />
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class MessageDesigner : ComponentDesigner {

        /// <include file='doc\MessageDesigner.uex' path='docs/doc[@for="MessageDesigner.PreFilterProperties"]/*' />
        protected override void PreFilterProperties(IDictionary properties) {
            base.PreFilterProperties(properties);
            RuntimeComponentFilter.FilterProperties(properties, new string[]{"EncryptionAlgorithm","BodyType","DigitalSignature","UseJournalQueue","SenderCertificate",
                                                                             "ConnectorType","TransactionStatusQueue","UseDeadLetterQueue",
                                                                             "UseTracing","UseAuthentication",
                                                                             "TimeToReachQueue","HashAlgorithm","Priority","BodyStream","DestinationSymmetricKey",
                                                                             "AppSpecific","ResponseQueue","AuthenticationProviderName","Recoverable",
                                                                             "UseEncryption","AttachSenderId","CorrelationId","AdministrationQueue","AuthenticationProviderType","TimeToBeReceived",
                                                                             "AcknowledgeType","Label","Extension"}, 
                                                                null);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\monitoring\system\diagnostics\design\processthreaddesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProcessThreadDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Diagnostics.Design {
    using System.Runtime.Serialization.Formatters;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Windows.Forms;
    using Microsoft.Win32;    
    using System.ComponentModel.Design;
    using System.Globalization;

    /// <include file='doc\ProcessThreadDesigner.uex' path='docs/doc[@for="ProcessThreadDesigner"]/*' />
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ProcessThreadDesigner : ComponentDesigner {

        /// <include file='doc\ProcessThreadDesigner.uex' path='docs/doc[@for="ProcessThreadDesigner.PreFilterProperties"]/*' />
        protected override void PreFilterProperties(IDictionary properties) {
            base.PreFilterProperties(properties);
            RuntimeComponentFilter.FilterProperties(properties, null, new string[]{"IdealProcessor","ProcessorAffinity"});
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\monitoring\system\diagnostics\design\startfilenameeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="StartFileNameEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics.Design {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Design;
    using System.IO;
    using System.ComponentModel;
    using System.Collections;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;


    /// <include file='doc\StartFileNameEditor.uex' path='docs/doc[@for="StartFileNameEditor"]/*' />
    /// <devdoc>
    ///     Editor for the ProcessStartInfo.FileName property.
    /// </devdoc>
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class StartFileNameEditor : FileNameEditor {
        protected override void InitializeDialog(OpenFileDialog openFile) {
            openFile.Filter = SR.GetString(SR.StartFileNameEditorAllFiles);
            openFile.Title = SR.GetString(SR.StartFileNameEditorTitle);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\monitoring\system\diagnostics\design\workingdirectoryeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="WorkingDirectoryEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Diagnostics.Design {

    using System;
    using System.Windows.Forms.Design;

    /// <include file='doc\WorkingDirectoryEditor.uex' path='docs/doc[@for="WorkingDirectoryEditor"]/*' />
    /// <devdoc>
    ///     Folder editor for choosing the working directory.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal class WorkingDirectoryEditor : FolderNameEditor {
        
        protected override void InitializeDialog(FolderBrowser folderBrowser) {
            folderBrowser.Description = System.Design.SR.GetString(System.Design.SR.WorkingDirectoryEditorLabel);
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\services\system\serviceprocess\design\servicecontrollerdesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ServiceControllerDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ServiceProcess.Design {
    using System.Runtime.Serialization.Formatters;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Windows.Forms;
    using Microsoft.Win32;    
    using System.ComponentModel.Design;
    using System.Globalization;


    /// <include file='doc\ServiceControllerDesigner.uex' path='docs/doc[@for="ServiceControllerDesigner"]/*' />
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ServiceControllerDesigner : ComponentDesigner {

        /// <include file='doc\ServiceControllerDesigner.uex' path='docs/doc[@for="ServiceControllerDesigner.PreFilterProperties"]/*' />
        protected override void PreFilterProperties(IDictionary properties) {
            base.PreFilterProperties(properties);
            RuntimeComponentFilter.FilterProperties(properties, new string[]{"ServiceName", "DisplayName"}, 
                                                                new string[]{"CanPauseAndContinue", "CanShutdown", "CanStop", "DisplayName", "DependentServices", "ServicesDependedOn", "Status", "ServiceType", "MachineName"}, 
                                                                new bool[]{false, false, false, false, false, false, false, false, true});
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\system\design\safenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="SafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Design {
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [
    System.Runtime.InteropServices.ComVisible(false), 
    System.Security.SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class SafeNativeMethods {
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool MessageBeep(int type);

        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetTickCount();
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool RedrawWindow(IntPtr hwnd, ref NativeMethods.RECT rcUpdate, IntPtr hrgnUpdate, int flags);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool RedrawWindow(IntPtr hwnd, NativeMethods.COMRECT rcUpdate, IntPtr hrgnUpdate, int flags);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter,
                                               int x, int y, int cx, int cy, int flags);
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\system\design\nativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Design {
    using System.Runtime.InteropServices;
    using System;
    using System.Drawing;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [System.Runtime.InteropServices.ComVisible(false)]
    internal class NativeMethods {
        public const int WM_USER = 0x0400,
        WM_GETDLGCODE = 0x0087,
        WM_MOUSEMOVE = 0x0200,
        WM_NOTIFY = 0x004E,
        DLGC_WANTALLKEYS = 0x0004,
        NM_CLICK = ((0-0)-2),
        WM_REFLECT          = WM_USER + 0x1C00,
        BM_SETIMAGE = 0x00F7,
        IMAGE_ICON = 1,
        BS_ICON = 0x00000040;
        
        public const int    VK_PROCESSKEY = 0xE5;

        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern int MultiByteToWideChar(int CodePage, int dwFlags,
                                                     byte[] lpMultiByteStr, int cchMultiByte, char[] lpWideCharStr, int cchWideChar);
        
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public class NMHEADER {
            public int hwndFrom; 
            public int idFrom; 
            public int code; 
            public int iItem;
            public int iButton;
            public int pItem;  // HDITEM*
        }
        [StructLayout(LayoutKind.Sequential)]
        public class POINT {
            public int x;
            public int y;

            public POINT() {
            }

            public POINT(int x, int y) {
                this.x = x;
                this.y = y;
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct WINDOWPOS {
            public IntPtr hwnd;
            public IntPtr hwndInsertAfter;
            public int x;
            public int y;
            public int cx;
            public int cy;
            public int flags;
        }
        
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto, Pack=1)]
        public class TV_ITEM {
            public int	mask;
            public int	hItem;
            public int	state;
            public int	stateMask;
            public int /* LPTSTR */	pszText;
            public int	cchTextMax;
            public int	iImage;
            public int	iSelectedImage;
            public int	cChildren;
            public int	lParam;
        }
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public class NMHDR
        {
            public int hwndFrom;
            public int idFrom;
            public int code;
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public class NMTREEVIEW
        {
            public NMHDR    nmhdr;
            public int      action;
            public TV_ITEM  itemOld;
            public TV_ITEM  itemNew;
            public POINT    ptDrag;
        }


        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public class TCHITTESTINFO {
            public Point pt;
            public TabControlHitTest flags;
        }

        public const int TCM_HITTEST = 4877;

        [Flags]
        public enum TabControlHitTest {
            TCHT_NOWHERE         =   0x0001,
            TCHT_ONITEMICON      =   0x0002,
            TCHT_ONITEMLABEL     =   0x0004
        }

        [System.Runtime.InteropServices.ComVisible(false)]
        public enum StructFormat {
            Ansi = 1,
            Unicode = 2,
            Auto = 3,
        }


        public static IntPtr InvalidIntPtr = ((IntPtr)((int)(-1)));

        public const int S_OK =      0x00000000;
        public const int S_FALSE =   0x00000001;
        public const int E_NOTIMPL = unchecked((int)0x80004001);
        public const int E_NOINTERFACE = unchecked((int)0x80004002);
        public const int E_INVALIDARG = unchecked((int)0x80070057);
        public const int E_FAIL = unchecked((int)0x80004005);

        public const int WS_EX_STATICEDGE = 0x00020000;

        public const int
        OLEIVERB_PRIMARY = 0,
        OLEIVERB_SHOW = -1,
        OLEIVERB_OPEN = -2,
        OLEIVERB_HIDE = -3,
        OLEIVERB_UIACTIVATE = -4,
        OLEIVERB_INPLACEACTIVATE = -5,
        OLEIVERB_DISCARDUNDOSTATE = -6,
        OLEIVERB_PROPERTIES = -7;

        public const int
        OLECLOSE_SAVEIFDIRTY = 0,
        OLECLOSE_NOSAVE = 1,
        OLECLOSE_PROMPTSAVE = 2;

        public const int
        PM_NOREMOVE = 0x0000,
        PM_REMOVE = 0x0001;

        public const int
        WM_CHAR = 0x0102;

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetClientRect(IntPtr hWnd, [In, Out] ref RECT rect);

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetClientRect(IntPtr hWnd, [In, Out] COMRECT rect);

        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool PeekMessage([In, Out] ref MSG msg, IntPtr hwnd, int msgMin, int msgMax, int remove);

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
        public static extern bool PeekMessageA([In, Out] ref MSG msg, IntPtr hwnd, int msgMin, int msgMax, int remove);

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern bool PeekMessageW([In, Out] ref MSG msg, IntPtr hwnd, int msgMin, int msgMax, int remove);

        [StructLayout(LayoutKind.Sequential)]
        public struct MSG {
            public IntPtr hwnd;
            public int  message;
            public IntPtr wParam;
            public IntPtr lParam;
            public int  time;
            // pt was a by-value POINT structure
            public int  pt_x;
            public int  pt_y;
        }

        [StructLayout(LayoutKind.Sequential)]
        public class COMRECT {
            public int left;
            public int top;
            public int right;
            public int bottom;

            public COMRECT() {
            }

            public COMRECT(int left, int top, int right, int bottom) {
                this.left = left;
                this.top = top;
                this.right = right;
                this.bottom = bottom;
            }

            public static COMRECT FromXYWH(int x, int y, int width, int height) {
                return new COMRECT(x,
                                   y,
                                   x + width,
                                   y + height);
            }
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public sealed class FORMATETC {
            [MarshalAs(UnmanagedType.I4)]
            public   int cfFormat;
            [MarshalAs(UnmanagedType.I4)]
            public   IntPtr ptd;
            [MarshalAs(UnmanagedType.I4)]
            public   int dwAspect;
            [MarshalAs(UnmanagedType.I4)]
            public   int lindex;
            [MarshalAs(UnmanagedType.I4)]
            public   int tymed;
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public class STGMEDIUM {
            [MarshalAs(UnmanagedType.I4)]
            public   int tymed;
            public   IntPtr unionmember;
            public   IntPtr pUnkForRelease;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct RECT {
            public int left;
            public int top;
            public int right;
            public int bottom;

            public RECT(int left, int top, int right, int bottom) {
                this.left = left;
                this.top = top;
                this.right = right;
                this.bottom = bottom;
            }

            public static RECT FromXYWH(int x, int y, int width, int height) {
                return new RECT(x,
                                y,
                                x + width,
                                y + height);
            }
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public sealed class OLECMD {
            [MarshalAs(UnmanagedType.U4)]
            public   int cmdID;
            [MarshalAs(UnmanagedType.U4)]
            public   int cmdf;
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public sealed class tagOIFI {
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.U4)]
            public int cb;
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.I4)]
            public int fMDIApp;
            public IntPtr hwndFrame;
            public IntPtr hAccel;
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.U4)]
            public int cAccelEntries;
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public sealed class tagSIZE {
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.I4)]
            public int cx;
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.I4)]
            public int cy;
        }

        [System.Runtime.InteropServices.ComVisible(true), StructLayout(LayoutKind.Sequential)]
        public sealed class tagSIZEL {
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.I4)]
            public int cx;
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.I4)]
            public int cy;
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public sealed class tagLOGPALETTE {
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.U2)]
            public short palVersion;
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.U2)]
            public short palNumEntries;

            // UNMAPPABLE: palPalEntry: Cannot be used as a structure field.
            //   /** @com.structmap(UNMAPPABLE palPalEntry) */
            //  public UNMAPPABLE palPalEntry;
        }

        public class DOCHOSTUIDBLCLICK {
            public const int DEFAULT = 0x0;
            public const int SHOWPROPERTIES = 0x1;
            public const int SHOWCODE = 0x2;
        }

        public class DOCHOSTUIFLAG {
            public const int DIALOG = 0x1;
            public const int DISABLE_HELP_MENU = 0x2;
            public const int NO3DBORDER = 0x4;
            public const int SCROLL_NO = 0x8;
            public const int DISABLE_SCRIPT_INACTIVE = 0x10;
            public const int OPENNEWWIN = 0x20;
            public const int DISABLE_OFFSCREEN = 0x40;
            public const int FLAT_SCROLLBAR = 0x80;
            public const int DIV_BLOCKDEFAULT = 0x100;
            public const int ACTIVATE_CLIENTHIT_ONLY = 0x200;
            public const int DISABLE_COOKIE = 0x400;
        }

        [System.Runtime.InteropServices.ComVisible(true), StructLayout(LayoutKind.Sequential)]
        public class DOCHOSTUIINFO {
            [MarshalAs(UnmanagedType.U4)]
            public int cbSize;
            [MarshalAs(UnmanagedType.I4)]
            public int dwFlags;
            [MarshalAs(UnmanagedType.I4)]
            public int dwDoubleClick;
            [MarshalAs(UnmanagedType.I4)]
            public int dwReserved1;
            [MarshalAs(UnmanagedType.I4)]
            public int dwReserved2;
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("BD3F23C0-D43E-11CF-893B-00AA00BDCE1A"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IDocHostUIHandler {

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int ShowContextMenu(
                               [In, MarshalAs(UnmanagedType.U4)]
                               int dwID,
                               [In]
                               POINT pt,
                               [In, MarshalAs(UnmanagedType.Interface)]
                               object pcmdtReserved,
                               [In, MarshalAs(UnmanagedType.Interface)]
                               object pdispReserved);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int GetHostInfo(
                           [In, Out]
                           DOCHOSTUIINFO info);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int ShowUI(
                      [In, MarshalAs(UnmanagedType.I4)]
                      int dwID,
                      [In]
                      IOleInPlaceActiveObject activeObject,
                      [In]
                      IOleCommandTarget commandTarget,
                      [In]
                      IOleInPlaceFrame frame,
                      [In]
                      IOleInPlaceUIWindow doc);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int HideUI();

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int UpdateUI();

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int EnableModeless(
                              [In, MarshalAs(UnmanagedType.Bool)]
                              bool fEnable);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OnDocWindowActivate(
                                   [In, MarshalAs(UnmanagedType.Bool)]
                                   bool fActivate);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OnFrameWindowActivate(
                                     [In, MarshalAs(UnmanagedType.Bool)]
                                     bool fActivate);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int ResizeBorder(
                            [In]
                            COMRECT rect,
                            [In]
                            IOleInPlaceUIWindow doc,
                            bool fFrameWindow);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int TranslateAccelerator(
                                    [In]
                                    ref MSG msg,
                                    [In]
                                    ref Guid group,
                                    [In, MarshalAs(UnmanagedType.I4)]
                                    int nCmdID);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int GetOptionKeyPath(
                                [Out, MarshalAs(UnmanagedType.LPArray)]
                                String[] pbstrKey,
                                [In, MarshalAs(UnmanagedType.U4)]
                                int dw);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int GetDropTarget(
                             [In, MarshalAs(UnmanagedType.Interface)]
                             IOleDropTarget pDropTarget,
                             [Out, MarshalAs(UnmanagedType.Interface)]
                             out IOleDropTarget ppDropTarget);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int GetExternal(
                           [Out, MarshalAs(UnmanagedType.Interface)]
                           out object ppDispatch);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int TranslateUrl(
                            [In, MarshalAs(UnmanagedType.U4)]
                            int dwTranslate,
                            [In, MarshalAs(UnmanagedType.LPWStr)]
                            string strURLIn,
                            [Out, MarshalAs(UnmanagedType.LPWStr)]
                            out string pstrURLOut);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int FilterDataObject(
                                [In, MarshalAs(UnmanagedType.Interface)]
                                IOleDataObject pDO,
                                [Out, MarshalAs(UnmanagedType.Interface)]
                                out IOleDataObject ppDORet);


        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("0000010E-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleDataObject {

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleGetData(
                          FORMATETC pFormatetc,
                          [Out] 
                          STGMEDIUM pMedium);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleGetDataHere(
                              FORMATETC pFormatetc,
                              [In, Out] 
                              STGMEDIUM pMedium);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleQueryGetData(
                               FORMATETC pFormatetc);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleGetCanonicalFormatEtc(
                                        FORMATETC pformatectIn,
                                        [Out] 
                                        FORMATETC pformatetcOut);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleSetData(
                          FORMATETC pFormatectIn,
                          STGMEDIUM pmedium,
                          [In, MarshalAs(UnmanagedType.I4)] 
                          int fRelease);

            [return: MarshalAs(UnmanagedType.Interface)]
            object OleEnumFormatEtc(
                                   [In, MarshalAs(UnmanagedType.U4)] 
                                   int dwDirection);

            [PreserveSig]
            int OleDAdvise(
                          FORMATETC pFormatetc,
                          [In, MarshalAs(UnmanagedType.U4)] 
                          int advf,
                          [In, MarshalAs(UnmanagedType.Interface)] 
                          object pAdvSink,
                          [Out, MarshalAs(UnmanagedType.LPArray)] 
                          int[] pdwConnection);

            [PreserveSig]
            int OleDUnadvise(
                            [In, MarshalAs(UnmanagedType.U4)] 
                            int dwConnection);

            [PreserveSig]
            int OleEnumDAdvise(
                              [Out, MarshalAs(UnmanagedType.LPArray)] 
                              Object[] ppenumAdvise);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000122-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleDropTarget {

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleDragEnter(
                            [In, MarshalAs(UnmanagedType.Interface)]
                            IOleDataObject pDataObj,
                            [In, MarshalAs(UnmanagedType.U4)]
                            int grfKeyState,
                            [In, MarshalAs(UnmanagedType.U8)]
                            long pt,
                            [In, Out, MarshalAs(UnmanagedType.I4)]
                            ref int pdwEffect);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleDragOver(
                           [In, MarshalAs(UnmanagedType.U4)]
                           int grfKeyState,
                           [In, MarshalAs(UnmanagedType.U8)]
                           long pt,
                           [In, Out, MarshalAs(UnmanagedType.I4)]
                           ref int pdwEffect);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleDragLeave();

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OleDrop(
                       [In, MarshalAs(UnmanagedType.Interface)]
                       IOleDataObject pDataObj,
                       [In, MarshalAs(UnmanagedType.U4)]
                       int grfKeyState,
                       [In, MarshalAs(UnmanagedType.U8)]
                       long pt,
                       [In, Out, MarshalAs(UnmanagedType.I4)]
                       ref int pdwEffect);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("B722BCCB-4E68-101B-A2BC-00AA00404770"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleCommandTarget {

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int QueryStatus(
                           ref Guid pguidCmdGroup,
                           int cCmds,
                           [In, Out] 
                           OLECMD prgCmds,
                           [In, Out] 
                           string pCmdText);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int Exec(
                    ref Guid pguidCmdGroup,
                    int nCmdID,
                    int nCmdexecopt,
                    // we need to have this an array because callers need to be able to specify NULL or VT_NULL
                    [In, MarshalAs(UnmanagedType.LPArray)]
                    Object[] pvaIn,
                    IntPtr pvaOut);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000116-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleInPlaceFrame {

            
            IntPtr GetWindow();

            
            void ContextSensitiveHelp(
                                     [In, MarshalAs(UnmanagedType.I4)]
                                     int fEnterMode);

            
            void GetBorder(
                          [Out]
                          COMRECT lprectBorder);

            
            void RequestBorderSpace(
                                   [In]
                                   COMRECT pborderwidths);

            
            void SetBorderSpace(
                               [In]
                               COMRECT pborderwidths);

            
            void SetActiveObject(
                                [In, MarshalAs(UnmanagedType.Interface)]
                                IOleInPlaceActiveObject pActiveObject,
                                [In, MarshalAs(UnmanagedType.LPWStr)]
                                string pszObjName);

            
            void InsertMenus(
                            [In]
                            IntPtr hmenuShared,
                            [In, Out]
                            object lpMenuWidths);

            
            void SetMenu(
                        [In]
                        IntPtr hmenuShared,
                        [In]
                        IntPtr holemenu,
                        [In]
                        IntPtr hwndActiveObject);

            
            void RemoveMenus(
                            [In]
                            IntPtr hmenuShared);

            
            void SetStatusText(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string pszStatusText);

            
            void EnableModeless(
                               [In, MarshalAs(UnmanagedType.I4)]
                               int fEnable);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int TranslateAccelerator(
                                    [In]
                                    ref MSG lpmsg,
                                    [In, MarshalAs(UnmanagedType.U2)]
                                    short wID);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000115-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleInPlaceUIWindow {

            
            IntPtr GetWindow();

            
            void ContextSensitiveHelp(
                                     [In, MarshalAs(UnmanagedType.I4)] 
                                     int fEnterMode);

            
            void GetBorder(
                          [Out] 
                          COMRECT lprectBorder);

            
            void RequestBorderSpace(
                                   [In] 
                                   COMRECT pborderwidths);

            
            void SetBorderSpace(
                               [In] 
                               COMRECT pborderwidths);

            
            void SetActiveObject(
                                [In, MarshalAs(UnmanagedType.Interface)] 
                                IOleInPlaceActiveObject pActiveObject,
                                [In, MarshalAs(UnmanagedType.LPWStr)] 
                                string pszObjName);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000117-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleInPlaceActiveObject {

            int GetWindow(out IntPtr hwnd);

            
            void ContextSensitiveHelp(
                                     [In, MarshalAs(UnmanagedType.I4)]
                                     int fEnterMode);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int TranslateAccelerator(
                                    [In]
                                    ref MSG lpmsg);

            
            void OnFrameWindowActivate(
                                      [In, MarshalAs(UnmanagedType.I4)]
                                      int fActivate);

            
            void OnDocWindowActivate(
                                    [In, MarshalAs(UnmanagedType.I4)]
                                    int fActivate);

            
            void ResizeBorder(
                             [In]
                             COMRECT prcBorder,
                             [In]
                             IOleInPlaceUIWindow pUIWindow,
                             [In, MarshalAs(UnmanagedType.I4)]
                             int fFrameWindow);

            
            void EnableModeless(
                               [In, MarshalAs(UnmanagedType.I4)]
                               int fEnable);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("0000011B-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleContainer {

            
            void ParseDisplayName(
                                 [In, MarshalAs(UnmanagedType.Interface)] 
                                 object pbc,
                                 [In, MarshalAs(UnmanagedType.BStr)] 
                                 string pszDisplayName,
                                 [Out, MarshalAs(UnmanagedType.LPArray)] 
                                 int[] pchEaten,
                                 [Out, MarshalAs(UnmanagedType.LPArray)] 
                                 Object[] ppmkOut);

            
            void EnumObjects(
                            [In, MarshalAs(UnmanagedType.U4)] 
                            int grfFlags,
                            [Out, MarshalAs(UnmanagedType.Interface)] 
                            out object ppenum);

            
            void LockContainer(
                              [In, MarshalAs(UnmanagedType.I4)] 
                              int fLock);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000118-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleClientSite {

            
            void SaveObject();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetMoniker(
                             [In, MarshalAs(UnmanagedType.U4)] 
                             int dwAssign,
                             [In, MarshalAs(UnmanagedType.U4)] 
                             int dwWhichMoniker);

            [PreserveSig]
            int GetContainer(
                    [System.Runtime.InteropServices.Out]
                    out IOleContainer ppContainer);

            
            void ShowObject();

            
            void OnShowWindow(
                             [In, MarshalAs(UnmanagedType.I4)] 
                             int fShow);

            
            void RequestNewObjectLayout();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("B722BCC7-4E68-101B-A2BC-00AA00404770"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleDocumentSite {

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int ActivateMe(
                          [In, MarshalAs(UnmanagedType.Interface)] 
                          IOleDocumentView pViewToActivate);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("B722BCC6-4E68-101B-A2BC-00AA00404770"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleDocumentView {

            
            void SetInPlaceSite(
                               [In, MarshalAs(UnmanagedType.Interface)] 
                               IOleInPlaceSite pIPSite);

            [return: MarshalAs(UnmanagedType.Interface)]
            IOleInPlaceSite GetInPlaceSite();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetDocument();

            
            void SetRect(
                        [In] 
                        COMRECT prcView);

            
            void GetRect(
                        [Out] 
                        COMRECT prcView);

            
            void SetRectComplex(
                               [In] 
                               COMRECT prcView,
                               [In] 
                               COMRECT prcHScroll,
                               [In] 
                               COMRECT prcVScroll,
                               [In] 
                               COMRECT prcSizeBox);

            
            void Show(
                     [In, MarshalAs(UnmanagedType.I4)] 
                     int fShow);

            
            void UIActivate(
                           [In, MarshalAs(UnmanagedType.I4)] 
                           int fUIActivate);

            
            void Open();

            
            void CloseView(
                          [In, MarshalAs(UnmanagedType.U4)] 
                          int dwReserved);

            
            void SaveViewState(
                              [In, MarshalAs(UnmanagedType.Interface)] 
                              IStream pstm);

            
            void ApplyViewState(
                               [In, MarshalAs(UnmanagedType.Interface)] 
                               IStream pstm);

            
            void Clone(
                      [In, MarshalAs(UnmanagedType.Interface)] 
                      IOleInPlaceSite pIPSiteNew,
                      [Out, MarshalAs(UnmanagedType.LPArray)] 
                      IOleDocumentView[] ppViewNew);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000119-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleInPlaceSite {

            
            IntPtr GetWindow();

            
            void ContextSensitiveHelp(
                                     [In, MarshalAs(UnmanagedType.I4)] 
                                     int fEnterMode);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int CanInPlaceActivate();

            
            void OnInPlaceActivate();

            
            void OnUIActivate();

            
            void GetWindowContext(
                                 [Out]
                                 out IOleInPlaceFrame ppFrame,
                                 [Out]
                                 out IOleInPlaceUIWindow ppDoc,
                                 [Out] 
                                 COMRECT lprcPosRect,
                                 [Out] 
                                 COMRECT lprcClipRect,
                                 [In, Out] 
                                 tagOIFI lpFrameInfo);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int Scroll(
                      [In, MarshalAs(UnmanagedType.U4)] 
                      tagSIZE scrollExtant);

            
            void OnUIDeactivate(
                               [In, MarshalAs(UnmanagedType.I4)] 
                               int fUndoable);

            
            void OnInPlaceDeactivate();

            
            void DiscardUndoState();

            
            void DeactivateAndUndo();

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int OnPosRectChange(
                               [In] 
                               COMRECT lprcPosRect);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("0000000C-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IStream {

            [return: MarshalAs(UnmanagedType.I4)]
            int Read(
                    [In] 
                    IntPtr buf,
                    [In, MarshalAs(UnmanagedType.I4)] 
                    int len);

            [return: MarshalAs(UnmanagedType.I4)]
            int Write(
                     [In] 
                     IntPtr buf,
                     [In, MarshalAs(UnmanagedType.I4)] 
                     int len);

            [return: MarshalAs(UnmanagedType.I8)]
            long Seek(
                     [In, MarshalAs(UnmanagedType.I8)] 
                     long dlibMove,
                     [In, MarshalAs(UnmanagedType.I4)] 
                     int dwOrigin);

            
            void SetSize(
                        [In, MarshalAs(UnmanagedType.I8)] 
                        long libNewSize);

            [return: MarshalAs(UnmanagedType.I8)]
            long CopyTo(
                       [In, MarshalAs(UnmanagedType.Interface)] 
                       IStream pstm,
                       [In, MarshalAs(UnmanagedType.I8)] 
                       long cb,
                       [Out, MarshalAs(UnmanagedType.LPArray)] 
                       long[] pcbRead);

            
            void Commit(
                       [In, MarshalAs(UnmanagedType.I4)] 
                       int grfCommitFlags);

            
            void Revert();

            
            void LockRegion(
                           [In, MarshalAs(UnmanagedType.I8)] 
                           long libOffset,
                           [In, MarshalAs(UnmanagedType.I8)] 
                           long cb,
                           [In, MarshalAs(UnmanagedType.I4)] 
                           int dwLockType);

            
            void UnlockRegion(
                             [In, MarshalAs(UnmanagedType.I8)] 
                             long libOffset,
                             [In, MarshalAs(UnmanagedType.I8)] 
                             long cb,
                             [In, MarshalAs(UnmanagedType.I4)] 
                             int dwLockType);

            
            void Stat(
                     [In] 
                     IntPtr pStatstg,
                     [In, MarshalAs(UnmanagedType.I4)] 
                     int grfStatFlag);

            [return: MarshalAs(UnmanagedType.Interface)]
            IStream Clone();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("00000112-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IOleObject {

            [PreserveSig]
            int SetClientSite(
                             [In, MarshalAs(UnmanagedType.Interface)]
                             IOleClientSite pClientSite);

            [PreserveSig]
            int GetClientSite(out IOleClientSite site);

            [PreserveSig]
            int SetHostNames(
                            [In, MarshalAs(UnmanagedType.LPWStr)]
                            string szContainerApp,
                            [In, MarshalAs(UnmanagedType.LPWStr)]
                            string szContainerObj);

            [PreserveSig]
            int Close(
                     [In, MarshalAs(UnmanagedType.I4)]
                     int dwSaveOption);

            [PreserveSig]
            int SetMoniker(
                          [In, MarshalAs(UnmanagedType.U4)]
                          int dwWhichMoniker,
                          [In, MarshalAs(UnmanagedType.Interface)]
                          object pmk);

            [PreserveSig]
            int GetMoniker(
                          [In, MarshalAs(UnmanagedType.U4)]
                          int dwAssign,
                          [In, MarshalAs(UnmanagedType.U4)]
                          int dwWhichMoniker,
                          out object moniker);

            [PreserveSig]
            int InitFromData(
                            [In, MarshalAs(UnmanagedType.Interface)]
                            IOleDataObject pDataObject,
                            [In, MarshalAs(UnmanagedType.I4)]
                            int fCreation,
                            [In, MarshalAs(UnmanagedType.U4)]
                            int dwReserved);

            [PreserveSig]
            int GetClipboardData(
                                [In, MarshalAs(UnmanagedType.U4)]
                                int dwReserved,
                                out IOleDataObject data);

            [PreserveSig]
            int DoVerb(
                      [In, MarshalAs(UnmanagedType.I4)]
                      int iVerb,
                      [In]
                      IntPtr lpmsg,
                      [In, MarshalAs(UnmanagedType.Interface)]
                      IOleClientSite pActiveSite,
                      [In, MarshalAs(UnmanagedType.I4)]
                      int lindex,
                      [In]
                      IntPtr hwndParent,
                      [In]
                      COMRECT lprcPosRect);

            [PreserveSig]
            int EnumVerbs(out NativeMethods.IEnumOLEVERB e);

            [PreserveSig]
            int OleUpdate();

            [PreserveSig]
            int IsUpToDate();

            [PreserveSig]
            int GetUserClassID(
                              [In, Out]
                              ref Guid pClsid);

            [PreserveSig]
            int GetUserType(
                           [In, MarshalAs(UnmanagedType.U4)]
                           int dwFormOfType,
                           [Out, MarshalAs(UnmanagedType.LPWStr)]
                           out string userType);

            [PreserveSig]
            int SetExtent(
                         [In, MarshalAs(UnmanagedType.U4)]
                         int dwDrawAspect,
                         [In]
                         tagSIZEL pSizel);

            [PreserveSig]
            int GetExtent(
                         [In, MarshalAs(UnmanagedType.U4)]
                         int dwDrawAspect,
                         [Out]
                         tagSIZEL pSizel);

            [PreserveSig]
            int Advise(
                      [In, MarshalAs(UnmanagedType.Interface)]
                      IAdviseSink pAdvSink,
                      out int cookie);

            [PreserveSig]
            int Unadvise(
                        [In, MarshalAs(UnmanagedType.U4)]
                        int dwConnection);

            [PreserveSig]
            int EnumAdvise(out object e);

            [PreserveSig]
            int GetMiscStatus(
                             [In, MarshalAs(UnmanagedType.U4)]
                             int dwAspect,
                             out int misc);

            [PreserveSig]
            int SetColorScheme(
                              [In]
                              tagLOGPALETTE pLogpal);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("0000010F-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IAdviseSink {

            
            void OnDataChange(
                             [In]
                             FORMATETC pFormatetc,
                             [In]
                             STGMEDIUM pStgmed);

            
            void OnViewChange(
                             [In, MarshalAs(UnmanagedType.U4)]
                             int dwAspect,
                             [In, MarshalAs(UnmanagedType.I4)]
                             int lindex);

            
            void OnRename(
                         [In, MarshalAs(UnmanagedType.Interface)]
                         object pmk);

            
            void OnSave();

            
            void OnClose();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("7FD52380-4E07-101B-AE2D-08002B2EC713"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IPersistStreamInit {

            
            void GetClassID(
                           [In, Out] 
                           ref Guid pClassID);

            [return: MarshalAs(UnmanagedType.I4)]
            [PreserveSig]
            int IsDirty();

            
            void Load(
                     [In, MarshalAs(UnmanagedType.Interface)] 
                     IStream pstm);

            
            void Save(
                     [In, MarshalAs(UnmanagedType.Interface)] 
                     IStream pstm,
                     [In, MarshalAs(UnmanagedType.Bool)] 
                     bool fClearDirty);

            
            void GetSizeMax(
                           [Out, MarshalAs(UnmanagedType.LPArray)] 
                           long pcbSize);

            
            void InitNew();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("25336920-03F9-11CF-8FD0-00AA00686F13")]
        public class HTMLDocument {
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("626FC520-A41E-11CF-A731-00A0C9082637"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLDocument {

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetScript();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("332C4425-26CB-11D0-B483-00C04FD90119"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLDocument2 {

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetScript();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetAll();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement GetBody();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement GetActiveElement();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetImages();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetApplets();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetLinks();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetForms();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetAnchors();

            
            void SetTitle(
                         [In, MarshalAs(UnmanagedType.BStr)]
                         string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTitle();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetScripts();

            
            void SetDesignMode(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetDesignMode();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetSelection();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetReadyState();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetFrames();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetEmbeds();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetPlugins();

            
            void SetAlinkColor(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            object GetAlinkColor();

            
            void SetBgColor(
                           [In, MarshalAs(UnmanagedType.Struct)]
                           Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            object GetBgColor();

            
            void SetFgColor(
                           [In, MarshalAs(UnmanagedType.Struct)]
                           Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            object GetFgColor();

            
            void SetLinkColor(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            object GetLinkColor();

            
            void SetVlinkColor(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetVlinkColor();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetReferrer();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetLocation();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetLastModified();

            
            void SetURL(
                       [In, MarshalAs(UnmanagedType.BStr)]
                       string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetURL();

            
            void SetDomain(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetDomain();

            
            void SetCookie(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetCookie();

            
            void SetExpando(
                           [In, MarshalAs(UnmanagedType.Bool)]
                           bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetExpando();

            
            void SetCharset(
                           [In, MarshalAs(UnmanagedType.BStr)]
                           string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetCharset();

            
            void SetDefaultCharset(
                                  [In, MarshalAs(UnmanagedType.BStr)]
                                  string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetDefaultCharset();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetMimeType();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFileSize();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFileCreatedDate();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFileModifiedDate();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFileUpdatedDate();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetSecurity();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetProtocol();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetNameProp();

            
            void DummyWrite(
                           [In, MarshalAs(UnmanagedType.I4)]
                           int psarray);

            
            void DummyWriteln(
                             [In, MarshalAs(UnmanagedType.I4)]
                             int psarray);

            [return: MarshalAs(UnmanagedType.Interface)]
            object Open(
                       [In, MarshalAs(UnmanagedType.BStr)]
                       string URL,
                       [In, MarshalAs(UnmanagedType.Struct)]
                       Object name,
                       [In, MarshalAs(UnmanagedType.Struct)]
                       Object features,
                       [In, MarshalAs(UnmanagedType.Struct)]
                       Object replace);

            
            void Close();

            
            void Clear();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool QueryCommandSupported(
                                      [In, MarshalAs(UnmanagedType.BStr)]
                                      string cmdID);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool QueryCommandEnabled(
                                    [In, MarshalAs(UnmanagedType.BStr)]
                                    string cmdID);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool QueryCommandState(
                                  [In, MarshalAs(UnmanagedType.BStr)]
                                  string cmdID);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool QueryCommandIndeterm(
                                     [In, MarshalAs(UnmanagedType.BStr)]
                                     string cmdID);

            [return: MarshalAs(UnmanagedType.BStr)]
            string QueryCommandText(
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string cmdID);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object QueryCommandValue(
                                    [In, MarshalAs(UnmanagedType.BStr)]
                                    string cmdID);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool ExecCommand(
                            [In, MarshalAs(UnmanagedType.BStr)]
                            string cmdID,
                            [In, MarshalAs(UnmanagedType.Bool)]
                            bool showUI,
                            [In, MarshalAs(UnmanagedType.Struct)]
                            Object value);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool ExecCommandShowHelp(
                                    [In, MarshalAs(UnmanagedType.BStr)]
                                    string cmdID);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement CreateElement(
                                      [In, MarshalAs(UnmanagedType.BStr)]
                                      string eTag);

            
            void SetOnhelp(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnhelp();

            
            void SetOnclick(
                           [In, MarshalAs(UnmanagedType.Struct)]
                           Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnclick();

            
            void SetOndblclick(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndblclick();

            
            void SetOnkeyup(
                           [In, MarshalAs(UnmanagedType.Struct)]
                           Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnkeyup();

            
            void SetOnkeydown(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnkeydown();

            
            void SetOnkeypress(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnkeypress();

            
            void SetOnmouseup(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmouseup();

            
            void SetOnmousedown(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmousedown();

            
            void SetOnmousemove(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmousemove();

            
            void SetOnmouseout(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmouseout();

            
            void SetOnmouseover(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmouseover();

            
            void SetOnreadystatechange(
                                      [In, MarshalAs(UnmanagedType.Struct)]
                                      Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnreadystatechange();

            
            void SetOnafterupdate(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnafterupdate();

            
            void SetOnrowexit(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnrowexit();

            
            void SetOnrowenter(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnrowenter();

            
            void SetOndragstart(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndragstart();

            
            void SetOnselectstart(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnselectstart();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement ElementFromPoint(
                                         [In, MarshalAs(UnmanagedType.I4)]
                                         int x,
                                         [In, MarshalAs(UnmanagedType.I4)]
                                         int y);

            [return: MarshalAs(UnmanagedType.Interface)]
            /*IHTMLWindow2*/ object GetParentWindow();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetStyleSheets();

            
            void SetOnbeforeupdate(
                                  [In, MarshalAs(UnmanagedType.Struct)]
                                  Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnbeforeupdate();

            
            void SetOnerrorupdate(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnerrorupdate();

            [return: MarshalAs(UnmanagedType.BStr)]
            string toString();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLStyleSheet CreateStyleSheet(
                                            [In, MarshalAs(UnmanagedType.BStr)]
                                            string bstrHref,
                                            [In, MarshalAs(UnmanagedType.I4)]
                                            int lIndex);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F1FF-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLElement {

            
            void SetAttribute(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string strAttributeName,
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object AttributeValue,
                             [In, MarshalAs(UnmanagedType.I4)]
                             int lFlags);

            
            void GetAttribute(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string strAttributeName,
                             [In, MarshalAs(UnmanagedType.I4)]
                             int lFlags,
                             [Out, MarshalAs(UnmanagedType.LPArray)]
                             Object[] pvars);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool RemoveAttribute(
                                [In, MarshalAs(UnmanagedType.BStr)]
                                string strAttributeName,
                                [In, MarshalAs(UnmanagedType.I4)]
                                int lFlags);

            
            void SetClassName(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetClassName();

            
            void SetId(
                      [In, MarshalAs(UnmanagedType.BStr)]
                      string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetId();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTagName();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement GetParentElement();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLStyle GetStyle();

            
            void SetOnhelp(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnhelp();

            
            void SetOnclick(
                           [In, MarshalAs(UnmanagedType.Struct)]
                           Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnclick();

            
            void SetOndblclick(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndblclick();

            
            void SetOnkeydown(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnkeydown();

            
            void SetOnkeyup(
                           [In, MarshalAs(UnmanagedType.Struct)]
                           Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnkeyup();

            
            void SetOnkeypress(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnkeypress();

            
            void SetOnmouseout(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmouseout();

            
            void SetOnmouseover(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmouseover();

            
            void SetOnmousemove(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmousemove();

            
            void SetOnmousedown(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmousedown();

            
            void SetOnmouseup(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmouseup();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDocument2 GetDocument();

            
            void SetTitle(
                         [In, MarshalAs(UnmanagedType.BStr)]
                         string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTitle();

            
            void SetLanguage(
                            [In, MarshalAs(UnmanagedType.BStr)]
                            string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetLanguage();

            
            void SetOnselectstart(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnselectstart();

            
            void ScrollIntoView(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object varargStart);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool Contains(
                         [In, MarshalAs(UnmanagedType.Interface)]
                         IHTMLElement pChild);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetSourceIndex();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetRecordNumber();

            
            void SetLang(
                        [In, MarshalAs(UnmanagedType.BStr)]
                        string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetLang();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetOffsetLeft();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetOffsetTop();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetOffsetWidth();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetOffsetHeight();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement GetOffsetParent();

            
            void SetInnerHTML(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetInnerHTML();

            
            void SetInnerText(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetInnerText();

            
            void SetOuterHTML(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetOuterHTML();

            
            void SetOuterText(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetOuterText();

            
            void InsertAdjacentHTML(
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string where,
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string html);

            
            void InsertAdjacentText(
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string where,
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string text);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement GetParentTextEdit();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetIsTextEdit();

            
            void Click();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetFilters();

            
            void SetOndragstart(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndragstart();

            [return: MarshalAs(UnmanagedType.BStr)]
            string toString();

            
            void SetOnbeforeupdate(
                                  [In, MarshalAs(UnmanagedType.Struct)]
                                  Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnbeforeupdate();

            
            void SetOnafterupdate(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnafterupdate();

            
            void SetOnerrorupdate(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnerrorupdate();

            
            void SetOnrowexit(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnrowexit();

            
            void SetOnrowenter(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnrowenter();

            
            void SetOndatasetchanged(
                                    [In, MarshalAs(UnmanagedType.Struct)]
                                    Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndatasetchanged();

            
            void SetOndataavailable(
                                   [In, MarshalAs(UnmanagedType.Struct)]
                                   Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndataavailable();

            
            void SetOndatasetcomplete(
                                     [In, MarshalAs(UnmanagedType.Struct)]
                                     Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndatasetcomplete();

            
            void SetOnfilterchange(
                                  [In, MarshalAs(UnmanagedType.Struct)]
                                  Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnfilterchange();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetChildren();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetAll();
        }

        [System.Runtime.InteropServices.ComVisible(false), System.Runtime.InteropServices.ComImport(), Guid("3050F434-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLElement2 {

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetScopeName();

            
            void SetCapture(
                           [In, MarshalAs(UnmanagedType.Bool)]
                           bool containerCapture);

            
            void ReleaseCapture();

            
            void SetOnlosecapture(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnlosecapture();

            [return: MarshalAs(UnmanagedType.BStr)]
            string ComponentFromPoint(
                                     [In, MarshalAs(UnmanagedType.I4)]
                                     int x,
                                     [In, MarshalAs(UnmanagedType.I4)]
                                     int y);

            
            void DoScroll(
                         [In, MarshalAs(UnmanagedType.Struct)]
                         Object component);

            
            void SetOnscroll(
                            [In, MarshalAs(UnmanagedType.Struct)]
                            Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnscroll();

            
            void SetOndrag(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndrag();

            
            void SetOndragend(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndragend();

            
            void SetOndragenter(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndragenter();

            
            void SetOndragover(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndragover();

            
            void SetOndragleave(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndragleave();

            
            void SetOndrop(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOndrop();

            
            void SetOnbeforecut(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnbeforecut();

            
            void SetOncut(
                         [In, MarshalAs(UnmanagedType.Struct)]
                         Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOncut();

            
            void SetOnbeforecopy(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnbeforecopy();

            
            void SetOncopy(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOncopy();

            
            void SetOnbeforepaste(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnbeforepaste();

            
            void SetOnpaste(
                           [In, MarshalAs(UnmanagedType.Struct)]
                           Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnpaste();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLCurrentStyle GetCurrentStyle();

            
            void SetOnpropertychange(
                                    [In, MarshalAs(UnmanagedType.Struct)]
                                    Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnpropertychange();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLRectCollection GetClientRects();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLRect GetBoundingClientRect();

            
            void SetExpression(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string propname,
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string expression,
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string language);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetExpression(
                                [In, MarshalAs(UnmanagedType.BStr)]
                                Object propname);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool RemoveExpression(
                                 [In, MarshalAs(UnmanagedType.BStr)]
                                 string propname);

            
            void SetTabIndex(
                            [In, MarshalAs(UnmanagedType.I2)]
                            short p);

            [return: MarshalAs(UnmanagedType.I2)]
            short GetTabIndex();

            
            void Focus();

            
            void SetAccessKey(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetAccessKey();

            
            void SetOnblur(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnblur();

            
            void SetOnfocus(
                           [In, MarshalAs(UnmanagedType.Struct)]
                           Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnfocus();

            
            void SetOnresize(
                            [In, MarshalAs(UnmanagedType.Struct)]
                            Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnresize();

            
            void Blur();

            
            void AddFilter(
                          [In, MarshalAs(UnmanagedType.Interface)]
                          object pUnk);

            
            void RemoveFilter(
                             [In, MarshalAs(UnmanagedType.Interface)]
                             object pUnk);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetClientHeight();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetClientWidth();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetClientTop();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetClientLeft();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool AttachEvent(
                            [In, MarshalAs(UnmanagedType.BStr)]
                            string ev,
                            [In, MarshalAs(UnmanagedType.Interface)]
                            object pdisp);

            
            void DetachEvent(
                            [In, MarshalAs(UnmanagedType.BStr)]
                            string ev,
                            [In, MarshalAs(UnmanagedType.Interface)]
                            object pdisp);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetReadyState();

            
            void SetOnreadystatechange(
                                      [In, MarshalAs(UnmanagedType.Struct)]
                                      Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnreadystatechange();

            
            void SetOnrowsdelete(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnrowsdelete();

            
            void SetOnrowsinserted(
                                  [In, MarshalAs(UnmanagedType.Struct)]
                                  Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnrowsinserted();

            
            void SetOncellchange(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOncellchange();

            
            void SetDir(
                       [In, MarshalAs(UnmanagedType.BStr)]
                       string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetDir();

            [return: MarshalAs(UnmanagedType.Interface)]
            object CreateControlRange();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetScrollHeight();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetScrollWidth();

            
            void SetScrollTop(
                             [In, MarshalAs(UnmanagedType.I4)]
                             int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetScrollTop();

            
            void SetScrollLeft(
                              [In, MarshalAs(UnmanagedType.I4)]
                              int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetScrollLeft();

            
            void ClearAttributes();

            
            void MergeAttributes(
                                [In, MarshalAs(UnmanagedType.Interface)]
                                IHTMLElement mergeThis);

            
            void SetOncontextmenu(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOncontextmenu();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement InsertAdjacentElement(
                                              [In, MarshalAs(UnmanagedType.BStr)]
                                              string where,
                                              [In, MarshalAs(UnmanagedType.Interface)]
                                              IHTMLElement insertedElement);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement ApplyElement(
                                     [In, MarshalAs(UnmanagedType.Interface)]
                                     IHTMLElement apply,
                                     [In, MarshalAs(UnmanagedType.BStr)]
                                     string where);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetAdjacentText(
                                  [In, MarshalAs(UnmanagedType.BStr)]
                                  string where);

            [return: MarshalAs(UnmanagedType.BStr)]
            string ReplaceAdjacentText(
                                      [In, MarshalAs(UnmanagedType.BStr)]
                                      string where,
                                      [In, MarshalAs(UnmanagedType.BStr)]
                                      string newText);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetCanHaveChildren();

            [return: MarshalAs(UnmanagedType.I4)]
            int AddBehavior(
                           [In, MarshalAs(UnmanagedType.BStr)]
                           string bstrUrl,
                           [In]
                           ref Object pvarFactory);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool RemoveBehavior(
                               [In, MarshalAs(UnmanagedType.I4)]
                               int cookie);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLStyle GetRuntimeStyle();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetBehaviorUrns();

            
            void SetTagUrn(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTagUrn();

            
            void SetOnbeforeeditfocus(
                                     [In, MarshalAs(UnmanagedType.Struct)]
                                     Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnbeforeeditfocus();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetReadyStateValue();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElementCollection GetElementsByTagName(
                                                       [In, MarshalAs(UnmanagedType.BStr)]
                                                       string v);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLStyle GetBaseStyle();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLCurrentStyle GetBaseCurrentStyle();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLStyle GetBaseRuntimeStyle();

            
            void SetOnmousehover(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnmousehover();

            
            void SetOnkeydownpreview(
                                    [In, MarshalAs(UnmanagedType.Struct)]
                                    Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnkeydownpreview();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetBehavior(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string bstrName,
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string bstrUrn);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F673-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLElement3 {

            
            void MergeAttributes(
                                [In, MarshalAs(UnmanagedType.Interface)]
                                IHTMLElement mergeThis,
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object pvarFlags);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetIsMultiLine();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetCanHaveHTML();

            
            void SetOnLayoutComplete(
                                    [In, MarshalAs(UnmanagedType.Struct)]
                                    Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnLayoutComplete();

            
            void SetOnPage(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnPage();

            
            void SetInflateBlock(
                                [In, MarshalAs(UnmanagedType.Bool)]
                                bool inflate);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetInflateBlock();

            
            void SetOnBeforeDeactivate(
                                      [In, MarshalAs(UnmanagedType.Struct)]
                                      Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnBeforeDeactivate();

            
            void SetActive();

            
            void SetContentEditable(
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetContentEditable();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetIsContentEditable();

            
            void SetHideFocus(
                             [In, MarshalAs(UnmanagedType.Bool)]
                             bool v);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetHideFocus();

            
            void SetDisabled(
                            [In, MarshalAs(UnmanagedType.Bool)]
                            bool v);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetDisabled();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetIsDisabled();

            
            void SetOnMove(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnMove();

            
            void SetOnControlSelect(
                                   [In, MarshalAs(UnmanagedType.Struct)]
                                   Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnControlSelect();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool FireEvent(
                          [In, MarshalAs(UnmanagedType.BStr)] 
                          string eventName,
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object eventObject);

            
            void SetOnResizeStart(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnResizeStart();

            
            void SetOnResizeEnd(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnResizeEnd();

            
            void SetOnMoveStart(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnMoveStart();

            
            void SetOnMoveEnd(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnMoveEnd();

            
            void SetOnMouseEnter(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnMouseEnter();

            
            void SetOnMouseLeave(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnMouseLeave();

            
            void SetOnActivate(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnActivate();

            
            void SetOnDeactivate(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnDeactivate();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool DragDrop();

            [return: MarshalAs(UnmanagedType.I4)]
            int GetGlyphMode();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F1D8-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLBodyElement {

            
            void SetBackground(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackground();

            
            void SetBgProperties(
                                [In, MarshalAs(UnmanagedType.BStr)]
                                string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBgProperties();

            
            void SetLeftMargin(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLeftMargin();

            
            void SetTopMargin(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetTopMargin();

            
            void SetRightMargin(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetRightMargin();

            
            void SetBottomMargin(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBottomMargin();

            
            void SetNoWrap(
                          [In, MarshalAs(UnmanagedType.Bool)]
                          bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetNoWrap();

            
            void SetBgColor(
                           [In, MarshalAs(UnmanagedType.Struct)]
                           Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBgColor();

            
            void SetText(
                        [In, MarshalAs(UnmanagedType.Struct)]
                        Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetText();

            
            void SetLink(
                        [In, MarshalAs(UnmanagedType.Struct)]
                        Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLink();

            
            void SetVLink(
                         [In, MarshalAs(UnmanagedType.Struct)]
                         Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetVLink();

            
            void SetALink(
                         [In, MarshalAs(UnmanagedType.Struct)]
                         Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetALink();

            
            void SetOnload(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnload();

            
            void SetOnunload(
                            [In, MarshalAs(UnmanagedType.Struct)]
                            Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnunload();

            
            void SetScroll(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetScroll();

            
            void SetOnselect(
                            [In, MarshalAs(UnmanagedType.Struct)]
                            Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnselect();

            
            void SetOnbeforeunload(
                                  [In, MarshalAs(UnmanagedType.Struct)]
                                  Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetOnbeforeunload();

            [return: MarshalAs(UnmanagedType.Interface)]
            object CreateTextRange();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F2E3-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLStyleSheet {

            
            void SetTitle(
                         [In, MarshalAs(UnmanagedType.BStr)] 
                         string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTitle();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLStyleSheet GetParentStyleSheet();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement GetOwningElement();

            
            void SetDisabled(
                            [In, MarshalAs(UnmanagedType.Bool)] 
                            bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetDisabled();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetReadOnly();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetImports();

            
            void SetHref(
                        [In, MarshalAs(UnmanagedType.BStr)] 
                        string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetHref();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetStyleSheetType();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetId();

            [return: MarshalAs(UnmanagedType.I4)]
            int AddImport(
                         [In, MarshalAs(UnmanagedType.BStr)] 
                         string bstrURL,
                         [In, MarshalAs(UnmanagedType.I4)] 
                         int lIndex);

            [return: MarshalAs(UnmanagedType.I4)]
            int AddRule(
                       [In, MarshalAs(UnmanagedType.BStr)] 
                       string bstrSelector,
                       [In, MarshalAs(UnmanagedType.BStr)] 
                       string bstrStyle,
                       [In, MarshalAs(UnmanagedType.I4)] 
                       int lIndex);

            
            void RemoveImport(
                             [In, MarshalAs(UnmanagedType.I4)] 
                             int lIndex);

            
            void RemoveRule(
                           [In, MarshalAs(UnmanagedType.I4)] 
                           int lIndex);

            
            void SetMedia(
                         [In, MarshalAs(UnmanagedType.BStr)] 
                         string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetMedia();

            
            void SetCssText(
                           [In, MarshalAs(UnmanagedType.BStr)] 
                           string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetCssText();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetRules();
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F25E-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLStyle {

            
            void SetFontFamily(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontFamily();

            
            void SetFontStyle(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontStyle();

            
            void SetFontObject(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontObject();

            
            void SetFontWeight(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontWeight();

            
            void SetFontSize(
                            [In, MarshalAs(UnmanagedType.Struct)]
                            Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetFontSize();

            
            void SetFont(
                        [In, MarshalAs(UnmanagedType.BStr)]
                        string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFont();

            
            void SetColor(
                         [In, MarshalAs(UnmanagedType.Struct)]
                         Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetColor();

            
            void SetBackground(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackground();

            
            void SetBackgroundColor(
                                   [In, MarshalAs(UnmanagedType.Struct)]
                                   Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBackgroundColor();

            
            void SetBackgroundImage(
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundImage();

            
            void SetBackgroundRepeat(
                                    [In, MarshalAs(UnmanagedType.BStr)]
                                    string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundRepeat();

            
            void SetBackgroundAttachment(
                                        [In, MarshalAs(UnmanagedType.BStr)]
                                        string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundAttachment();

            
            void SetBackgroundPosition(
                                      [In, MarshalAs(UnmanagedType.BStr)]
                                      string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundPosition();

            
            void SetBackgroundPositionX(
                                       [In, MarshalAs(UnmanagedType.Struct)]
                                       Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBackgroundPositionX();

            
            void SetBackgroundPositionY(
                                       [In, MarshalAs(UnmanagedType.Struct)]
                                       Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBackgroundPositionY();

            
            void SetWordSpacing(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetWordSpacing();

            
            void SetLetterSpacing(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLetterSpacing();

            
            void SetTextDecoration(
                                  [In, MarshalAs(UnmanagedType.BStr)]
                                  string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextDecoration();

            
            void SetTextDecorationNone(
                                      [In, MarshalAs(UnmanagedType.Bool)]
                                      bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetTextDecorationNone();

            
            void SetTextDecorationUnderline(
                                           [In, MarshalAs(UnmanagedType.Bool)]
                                           bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetTextDecorationUnderline();

            
            void SetTextDecorationOverline(
                                          [In, MarshalAs(UnmanagedType.Bool)]
                                          bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetTextDecorationOverline();

            
            void SetTextDecorationLineThrough(
                                             [In, MarshalAs(UnmanagedType.Bool)]
                                             bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetTextDecorationLineThrough();

            
            void SetTextDecorationBlink(
                                       [In, MarshalAs(UnmanagedType.Bool)]
                                       bool p);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool GetTextDecorationBlink();

            
            void SetVerticalAlign(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetVerticalAlign();

            
            void SetTextTransform(
                                 [In, MarshalAs(UnmanagedType.BStr)]
                                 string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextTransform();

            
            void SetTextAlign(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextAlign();

            
            void SetTextIndent(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetTextIndent();

            
            void SetLineHeight(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLineHeight();

            
            void SetMarginTop(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginTop();

            
            void SetMarginRight(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginRight();

            
            void SetMarginBottom(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginBottom();

            
            void SetMarginLeft(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginLeft();

            
            void SetMargin(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetMargin();

            
            void SetPaddingTop(
                              [In, MarshalAs(UnmanagedType.Struct)]
                              Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingTop();

            
            void SetPaddingRight(
                                [In, MarshalAs(UnmanagedType.Struct)]
                                Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingRight();

            
            void SetPaddingBottom(
                                 [In, MarshalAs(UnmanagedType.Struct)]
                                 Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingBottom();

            
            void SetPaddingLeft(
                               [In, MarshalAs(UnmanagedType.Struct)]
                               Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingLeft();

            
            void SetPadding(
                           [In, MarshalAs(UnmanagedType.BStr)]
                           string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPadding();

            
            void SetBorder(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorder();

            
            void SetBorderTop(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderTop();

            
            void SetBorderRight(
                               [In, MarshalAs(UnmanagedType.BStr)]
                               string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderRight();

            
            void SetBorderBottom(
                                [In, MarshalAs(UnmanagedType.BStr)]
                                string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderBottom();

            
            void SetBorderLeft(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderLeft();

            
            void SetBorderColor(
                               [In, MarshalAs(UnmanagedType.BStr)]
                               string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderColor();

            
            void SetBorderTopColor(
                                  [In, MarshalAs(UnmanagedType.Struct)]
                                  Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderTopColor();

            
            void SetBorderRightColor(
                                    [In, MarshalAs(UnmanagedType.Struct)]
                                    Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderRightColor();

            
            void SetBorderBottomColor(
                                     [In, MarshalAs(UnmanagedType.Struct)]
                                     Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderBottomColor();

            
            void SetBorderLeftColor(
                                   [In, MarshalAs(UnmanagedType.Struct)]
                                   Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderLeftColor();

            
            void SetBorderWidth(
                               [In, MarshalAs(UnmanagedType.BStr)]
                               string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderWidth();

            
            void SetBorderTopWidth(
                                  [In, MarshalAs(UnmanagedType.Struct)]
                                  Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderTopWidth();

            
            void SetBorderRightWidth(
                                    [In, MarshalAs(UnmanagedType.Struct)]
                                    Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderRightWidth();

            
            void SetBorderBottomWidth(
                                     [In, MarshalAs(UnmanagedType.Struct)]
                                     Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderBottomWidth();

            
            void SetBorderLeftWidth(
                                   [In, MarshalAs(UnmanagedType.Struct)]
                                   Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderLeftWidth();

            
            void SetBorderStyle(
                               [In, MarshalAs(UnmanagedType.BStr)]
                               string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderStyle();

            
            void SetBorderTopStyle(
                                  [In, MarshalAs(UnmanagedType.BStr)]
                                  string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderTopStyle();

            
            void SetBorderRightStyle(
                                    [In, MarshalAs(UnmanagedType.BStr)]
                                    string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderRightStyle();

            
            void SetBorderBottomStyle(
                                     [In, MarshalAs(UnmanagedType.BStr)]
                                     string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderBottomStyle();

            
            void SetBorderLeftStyle(
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderLeftStyle();

            
            void SetWidth(
                         [In, MarshalAs(UnmanagedType.Struct)]
                         Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetWidth();

            
            void SetHeight(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetHeight();

            
            void SetStyleFloat(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetStyleFloat();

            
            void SetClear(
                         [In, MarshalAs(UnmanagedType.BStr)]
                         string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetClear();

            
            void SetDisplay(
                           [In, MarshalAs(UnmanagedType.BStr)]
                           string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetDisplay();

            
            void SetVisibility(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetVisibility();

            
            void SetListStyleType(
                                 [In, MarshalAs(UnmanagedType.BStr)]
                                 string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyleType();

            
            void SetListStylePosition(
                                     [In, MarshalAs(UnmanagedType.BStr)]
                                     string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStylePosition();

            
            void SetListStyleImage(
                                  [In, MarshalAs(UnmanagedType.BStr)]
                                  string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyleImage();

            
            void SetListStyle(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyle();

            
            void SetWhiteSpace(
                              [In, MarshalAs(UnmanagedType.BStr)]
                              string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetWhiteSpace();

            
            void SetTop(
                       [In, MarshalAs(UnmanagedType.Struct)]
                       Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetTop();

            
            void SetLeft(
                        [In, MarshalAs(UnmanagedType.Struct)]
                        Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLeft();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPosition();

            
            void SetZIndex(
                          [In, MarshalAs(UnmanagedType.Struct)]
                          Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetZIndex();

            
            void SetOverflow(
                            [In, MarshalAs(UnmanagedType.BStr)]
                            string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetOverflow();

            
            void SetPageBreakBefore(
                                   [In, MarshalAs(UnmanagedType.BStr)]
                                   string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPageBreakBefore();

            
            void SetPageBreakAfter(
                                  [In, MarshalAs(UnmanagedType.BStr)]
                                  string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPageBreakAfter();

            
            void SetCssText(
                           [In, MarshalAs(UnmanagedType.BStr)]
                           string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetCssText();

            
            void SetPixelTop(
                            [In, MarshalAs(UnmanagedType.I4)]
                            int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetPixelTop();

            
            void SetPixelLeft(
                             [In, MarshalAs(UnmanagedType.I4)]
                             int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetPixelLeft();

            
            void SetPixelWidth(
                              [In, MarshalAs(UnmanagedType.I4)]
                              int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetPixelWidth();

            
            void SetPixelHeight(
                               [In, MarshalAs(UnmanagedType.I4)]
                               int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetPixelHeight();

            
            void SetPosTop(
                          [In, MarshalAs(UnmanagedType.R4)]
                          float p);

            [return: MarshalAs(UnmanagedType.R4)]
            float GetPosTop();

            
            void SetPosLeft(
                           [In, MarshalAs(UnmanagedType.R4)]
                           float p);

            [return: MarshalAs(UnmanagedType.R4)]
            float GetPosLeft();

            
            void SetPosWidth(
                            [In, MarshalAs(UnmanagedType.R4)]
                            float p);

            [return: MarshalAs(UnmanagedType.R4)]
            float GetPosWidth();

            
            void SetPosHeight(
                             [In, MarshalAs(UnmanagedType.R4)]
                             float p);

            [return: MarshalAs(UnmanagedType.R4)]
            float GetPosHeight();

            
            void SetCursor(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetCursor();

            
            void SetClip(
                        [In, MarshalAs(UnmanagedType.BStr)]
                        string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetClip();

            
            void SetFilter(
                          [In, MarshalAs(UnmanagedType.BStr)]
                          string p);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFilter();

            
            void SetAttribute(
                             [In, MarshalAs(UnmanagedType.BStr)]
                             string strAttributeName,
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object AttributeValue,
                             [In, MarshalAs(UnmanagedType.I4)]
                             int lFlags);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetAttribute(
                               [In, MarshalAs(UnmanagedType.BStr)]
                               string strAttributeName,
                               [In, MarshalAs(UnmanagedType.I4)]
                               int lFlags);

            [return: MarshalAs(UnmanagedType.Bool)]
            bool RemoveAttribute(
                                [In, MarshalAs(UnmanagedType.BStr)]
                                string strAttributeName,
                                [In, MarshalAs(UnmanagedType.I4)]
                                int lFlags);

        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F3DB-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLCurrentStyle {

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPosition();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetStyleFloat();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetColor();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBackgroundColor();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontFamily();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontStyle();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetFontObject();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetFontWeight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetFontSize();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundImage();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBackgroundPositionX();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBackgroundPositionY();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundRepeat();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderLeftColor();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderTopColor();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderRightColor();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderBottomColor();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderTopStyle();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderRightStyle();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderBottomStyle();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderLeftStyle();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderTopWidth();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderRightWidth();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderBottomWidth();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBorderLeftWidth();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLeft();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetTop();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetWidth();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetHeight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingLeft();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingTop();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingRight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetPaddingBottom();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextAlign();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTextDecoration();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetDisplay();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetVisibility();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetZIndex();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLetterSpacing();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetLineHeight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetTextIndent();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetVerticalAlign();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBackgroundAttachment();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginTop();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginRight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginBottom();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetMarginLeft();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetClear();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyleType();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStylePosition();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetListStyleImage();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetClipTop();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetClipRight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetClipBottom();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetClipLeft();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetOverflow();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPageBreakBefore();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetPageBreakAfter();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetCursor();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetTableLayout();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBorderCollapse();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetDirection();

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetBehavior();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetAttribute(
                               [In, MarshalAs(UnmanagedType.BStr)]
                               string strAttributeName,
                               [In, MarshalAs(UnmanagedType.I4)]
                               int lFlags);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetUnicodeBidi();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetRight();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetBottom();

        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F21F-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLElementCollection {

            [return: MarshalAs(UnmanagedType.BStr)]
            string toString();

            
            void SetLength(
                          [In, MarshalAs(UnmanagedType.I4)] 
                          int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetLength();

            [return: MarshalAs(UnmanagedType.Interface)]
            object Get_newEnum();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLElement Item(
                       [In, MarshalAs(UnmanagedType.Struct)] 
                       Object name,
                       [In, MarshalAs(UnmanagedType.Struct)] 
                       Object index);

            [return: MarshalAs(UnmanagedType.Interface)]
            object Tags(
                       [In, MarshalAs(UnmanagedType.Struct)] 
                       Object tagName);
        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F4A3-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLRect {

            
            void SetLeft(
                        [In, MarshalAs(UnmanagedType.I4)] 
                        int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetLeft();

            
            void SetTop(
                       [In, MarshalAs(UnmanagedType.I4)] 
                       int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetTop();

            
            void SetRight(
                         [In, MarshalAs(UnmanagedType.I4)] 
                         int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetRight();

            
            void SetBottom(
                          [In, MarshalAs(UnmanagedType.I4)] 
                          int p);

            [return: MarshalAs(UnmanagedType.I4)]
            int GetBottom();

        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F4A4-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLRectCollection {

            [return: MarshalAs(UnmanagedType.I4)]
            int GetLength();

            [return: MarshalAs(UnmanagedType.Interface)]
            object Get_newEnum();

            [return: MarshalAs(UnmanagedType.Struct)]
            Object Item(
                       [In]
                       ref Object pvarIndex);

        }

        [System.Runtime.InteropServices.ComVisible(true), System.Runtime.InteropServices.ComImport(), Guid("3050F5DA-98B5-11CF-BB82-00AA00BDCE0B"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsDual)]
        public interface IHTMLDOMNode {

            [return: MarshalAs(UnmanagedType.I4)]
            int GetNodeType();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode GetParentNode();

            [return: MarshalAs(UnmanagedType.Bool)]
            bool HasChildNodes();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetChildNodes();

            [return: MarshalAs(UnmanagedType.Interface)]
            object GetAttributes();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode InsertBefore(
                                     [In, MarshalAs(UnmanagedType.Interface)]
                                     IHTMLDOMNode newChild,
                                     [In, MarshalAs(UnmanagedType.Struct)]
                                     Object refChild);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode RemoveChild(
                                    [In, MarshalAs(UnmanagedType.Interface)]
                                    IHTMLDOMNode oldChild);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode ReplaceChild(
                                     [In, MarshalAs(UnmanagedType.Interface)]
                                     IHTMLDOMNode newChild,
                                     [In, MarshalAs(UnmanagedType.Interface)]
                                     IHTMLDOMNode oldChild);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode CloneNode(
                                  [In, MarshalAs(UnmanagedType.Bool)]
                                  bool fDeep);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode RemoveNode(
                                   [In, MarshalAs(UnmanagedType.Bool)]
                                   bool fDeep);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode SwapNode(
                                 [In, MarshalAs(UnmanagedType.Interface)]
                                 IHTMLDOMNode otherNode);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode ReplaceNode(
                                    [In, MarshalAs(UnmanagedType.Interface)]
                                    IHTMLDOMNode replacement);

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode AppendChild(
                                    [In, MarshalAs(UnmanagedType.Interface)]
                                    IHTMLDOMNode newChild);

            [return: MarshalAs(UnmanagedType.BStr)]
            string GetNodeName();

            
            void SetNodeValue(
                             [In, MarshalAs(UnmanagedType.Struct)]
                             Object p);

            [return: MarshalAs(UnmanagedType.Struct)]
            Object GetNodeValue();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode GetFirstChild();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode GetLastChild();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode GetPreviousSibling();

            [return: MarshalAs(UnmanagedType.Interface)]
            IHTMLDOMNode GetNextSibling();
        }

        public static readonly int WM_MOUSEENTER = Util.RegisterWindowMessage("WinFormsMouseEnter");
        public static readonly int HDN_ENDTRACK = Marshal.SystemDefaultCharSize == 1 ? NativeMethods.HDN_ENDTRACKA : NativeMethods.HDN_ENDTRACKW;

        public const int 
            WM_CAPTURECHANGED = 0x0215,
        WM_PARENTNOTIFY = 0x0210,
        WM_CREATE = 0x0001,
        WM_SETREDRAW = 0x000B,
        WM_NCACTIVATE = 0x0086,
        WM_HSCROLL = 0x0114,
        WM_VSCROLL = 0x0115,
        WM_WINDOWPOSCHANGING = 0x0046,
        WM_WINDOWPOSCHANGED = 0x0047,
        WS_CLIPSIBLINGS = 0x04000000,
        WS_CLIPCHILDREN = 0x02000000,
        NOTSRCCOPY = 0x00330008,
        SRCCOPY = 0x00CC0020,
        LVM_SETCOLUMNWIDTH = (0x1000+30),
                             LVM_GETHEADER = (0x1000+31),
                                             LVM_CREATEDRAGIMAGE = (0x1000+33),
                                                                   LVM_GETVIEWRECT = (0x1000+34),
                                                                                     LVM_GETTEXTCOLOR = (0x1000+35),
                                                                                                        LVM_SETTEXTCOLOR = (0x1000+36),
                                                                                                                           LVM_GETTEXTBKCOLOR = (0x1000+37),
                                                                                                                                                LVM_SETTEXTBKCOLOR = (0x1000+38),
                                                                                                                                                                     LVM_GETTOPINDEX = (0x1000+39),
                                                                                                                                                                                       LVM_GETCOUNTPERPAGE = (0x1000+40),
                                                                                                                                                                                                             LVM_GETORIGIN = (0x1000+41),
                                                                                                                                                                                                                             LVM_UPDATE = (0x1000+42),
                                                                                                                                                                                                                                          LVM_SETITEMSTATE = (0x1000+43),
                                                                                                                                                                                                                                                             LVM_GETITEMSTATE = (0x1000+44),
                                                                                                                                                                                                                                                                                LVM_GETITEMTEXTA = (0x1000+45),
                                                                                                                                                                                                                                                                                                   LVM_GETITEMTEXTW = (0x1000+115),
                                                                                                                                                                                                                                                                                                                      LVM_SETITEMTEXTA = (0x1000+46),
                                                                                                                                                                                                                                                                                                                                         LVM_SETITEMTEXTW = (0x1000+116),
                                                                                                                                                                                                                                                                                                                                                            LVSICF_NOINVALIDATEALL = 0x00000001,
        LVSICF_NOSCROLL = 0x00000002,
        LVM_SETITEMCOUNT = (0x1000+47),
                           LVM_SORTITEMS = (0x1000+48),
                                           LVM_SETITEMPOSITION32 = (0x1000+49),
                                                                   LVM_GETSELECTEDCOUNT = (0x1000+50),
                                                                                          LVM_GETITEMSPACING = (0x1000+51),
                                                                                                               LVM_GETISEARCHSTRINGA = (0x1000+52),
                                                                                                                                       LVM_GETISEARCHSTRINGW = (0x1000+117),
                                                                                                                                                               LVM_SETICONSPACING = (0x1000+53),
                                                                                                                                                                                    LVM_SETEXTENDEDLISTVIEWSTYLE = (0x1000+54),
                                                                                                                                                                                                                   LVM_GETEXTENDEDLISTVIEWSTYLE = (0x1000+55),
                                                                                                                                                                                                                                                  LVS_EX_GRIDLINES = 0x00000001,
        HDM_HITTEST = (0x1200+6),
                      HDM_GETITEMRECT = (0x1200+7),
                                        HDM_SETIMAGELIST = (0x1200+8),
                                                           HDM_GETIMAGELIST = (0x1200+9),
                                                                              HDM_ORDERTOINDEX = (0x1200+15),
                                                                                                 HDM_CREATEDRAGIMAGE = (0x1200+16),
                                                                                                                       HDM_GETORDERARRAY = (0x1200+17),
                                                                                                                                           HDM_SETORDERARRAY = (0x1200+18),
                                                                                                                                                               HDM_SETHOTDIVIDER = (0x1200+19),
                                                                                                                                                                                   HDN_ITEMCHANGINGA = ((0-300)-0),
                                                                                                                                                                                                       HDN_ITEMCHANGINGW = ((0-300)-20),
                                                                                                                                                                                                                           HDN_ITEMCHANGEDA = ((0-300)-1),
                                                                                                                                                                                                                                              HDN_ITEMCHANGEDW = ((0-300)-21),
                                                                                                                                                                                                                                                                 HDN_ITEMCLICKA = ((0-300)-2),
                                                                                                                                                                                                                                                                                  HDN_ITEMCLICKW = ((0-300)-22),
                                                                                                                                                                                                                                                                                                   HDN_ITEMDBLCLICKA = ((0-300)-3),
                                                                                                                                                                                                                                                                                                                       HDN_ITEMDBLCLICKW = ((0-300)-23),
                                                                                                                                                                                                                                                                                                                                           HDN_DIVIDERDBLCLICKA = ((0-300)-5),
                                                                                                                                                                                                                                                                                                                                                                  HDN_DIVIDERDBLCLICKW = ((0-300)-25),
                                                                                                                                                                                                                                                                                                                                                                                         HDN_BEGINTRACKA = ((0-300)-6),
                                                                                                                                                                                                                                                                                                                                                                                                           HDN_BEGINTRACKW = ((0-300)-26),
                                                                                                                                                                                                                                                                                                                                                                                                                             HDN_ENDTRACKA = ((0-300)-7),
                                                                                                                                                                                                                                                                                                                                                                                                                                             HDN_ENDTRACKW = ((0-300)-27),
                                                                                                                                                                                                                                                                                                                                                                                                                                                             HDN_TRACKA = ((0-300)-8),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                          HDN_TRACKW = ((0-300)-28),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       HDN_GETDISPINFOA = ((0-300)-9),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          HDN_GETDISPINFOW = ((0-300)-29),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             HDN_BEGINDRAG = ((0-300)-10),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             HDN_ENDDRAG = ((0-300)-11),
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           HIST_BACK = 0,
        HHT_ONHEADER = 0x0002,
        HHT_ONDIVIDER = 0x0004,
        HHT_ONDIVOPEN = 0x0008,
        HHT_ABOVE = 0x0100,
        HHT_BELOW = 0x0200,
        HHT_TORIGHT = 0x0400,
        HHT_TOLEFT = 0x0800,
        HWND_TOP = 0,
        HWND_BOTTOM = 1,
        HWND_TOPMOST = -1,
        HWND_NOTOPMOST = -2,
        CWP_SKIPINVISIBLE = 0x0001,
        RDW_FRAME = 0x0400,
        WM_KILLFOCUS = 0x0008,
        WM_STYLECHANGED = 0x007D,
        TVM_GETITEMRECT = (0x1100+4),
                          TVM_GETCOUNT = (0x1100+5),
                                         TVM_GETINDENT = (0x1100+6),
                                                         TVM_SETINDENT = (0x1100+7),
                                                                         TVM_GETIMAGELIST = (0x1100+8),
                                                                                            TVSIL_NORMAL = 0,
        TVSIL_STATE = 2,
        TVM_SETIMAGELIST = (0x1100+9),
                           TVM_GETNEXTITEM = (0x1100+10),
                                             TVGN_ROOT = 0x0000,
        TVHT_ONITEMICON = 0x0002,
        TVHT_ONITEMLABEL = 0x0004,
        TVHT_ONITEMINDENT = 0x0008,
        TVHT_ONITEMBUTTON = 0x0010,
        TVHT_ONITEMRIGHT = 0x0020,
        TVHT_ONITEMSTATEICON = 0x0040,
        TVHT_ABOVE = 0x0100,
        TVHT_BELOW = 0x0200,
        TVHT_TORIGHT = 0x0400,
        TVHT_TOLEFT = 0x0800,
        GW_HWNDFIRST = 0,
        GW_HWNDLAST = 1,
        GW_HWNDNEXT = 2,
        GW_HWNDPREV = 3,
        GW_OWNER = 4,
        GW_CHILD = 5,
        GW_MAX = 5,
        SB_HORZ = 0,
        SB_VERT = 1,
        SB_CTL = 2,
        SB_BOTH = 3,
        SB_LINEUP = 0,
        SB_LINELEFT = 0,
        SB_LINEDOWN = 1,
        SB_LINERIGHT = 1,
        SB_PAGEUP = 2,
        SB_PAGELEFT = 2,
        SB_PAGEDOWN = 3,
        SB_PAGERIGHT = 3,
        SB_THUMBPOSITION = 4,
        SB_THUMBTRACK = 5,
        SB_TOP = 6,
        SB_LEFT = 6,
        SB_BOTTOM = 7,
        SB_RIGHT = 7,
        SB_ENDSCROLL = 8,
        MK_LBUTTON = 0x0001,
        TVM_HITTEST = (0x1100+17),
                      MK_RBUTTON = 0x0002,
        MK_SHIFT = 0x0004,
        MK_CONTROL = 0x0008,
        MK_MBUTTON = 0x0010,
        LB_ADDSTRING = 0x0180,
        LB_INSERTSTRING = 0x0181,
        LB_DELETESTRING = 0x0182,
        LB_SELITEMRANGEEX = 0x0183,
        LB_RESETCONTENT = 0x0184,
        LB_SETSEL = 0x0185,
        LB_SETCURSEL = 0x0186,
        LB_GETSEL = 0x0187,
        LB_GETCURSEL = 0x0188,
        LB_GETTEXT = 0x0189,
        LB_GETTEXTLEN = 0x018A,
        LB_GETCOUNT = 0x018B,
        LB_SELECTSTRING = 0x018C,
        LB_DIR = 0x018D,
        LB_GETTOPINDEX = 0x018E,
        LB_FINDSTRING = 0x018F,
        LB_GETSELCOUNT = 0x0190,
        LB_GETSELITEMS = 0x0191,
        LB_SETTABSTOPS = 0x0192,
        LB_GETHORIZONTALEXTENT = 0x0193,
        LB_SETHORIZONTALEXTENT = 0x0194,
        LB_SETCOLUMNWIDTH = 0x0195,
        LB_ADDFILE = 0x0196,
        LB_SETTOPINDEX = 0x0197,
        LB_GETITEMRECT = 0x0198,
        LB_GETITEMDATA = 0x0199,
        LB_SETITEMDATA = 0x019A,
        LB_SELITEMRANGE = 0x019B,
        LB_SETANCHORINDEX = 0x019C,
        LB_GETANCHORINDEX = 0x019D,
        LB_SETCARETINDEX = 0x019E,
        LB_GETCARETINDEX = 0x019F,
        LB_SETITEMHEIGHT = 0x01A0,
        LB_GETITEMHEIGHT = 0x01A1,
        LB_FINDSTRINGEXACT = 0x01A2,
        LB_SETLOCALE = 0x01A5,
        LB_GETLOCALE = 0x01A6,
        LB_SETCOUNT = 0x01A7,
        LB_INITSTORAGE = 0x01A8,
        LB_ITEMFROMPOINT = 0x01A9,
        LB_MSGMAX = 0x01B0,
        HTHSCROLL = 6,
        HTVSCROLL = 7,
        HTERROR = (-2),
                  HTTRANSPARENT = (-1),
                                  HTNOWHERE = 0,
        HTCLIENT = 1,
        HTCAPTION = 2,
        HTSYSMENU = 3,
        HTGROWBOX = 4,
        HTSIZE = 4,
        SWP_NOSIZE = 0x0001,
        SWP_NOMOVE = 0x0002,
        SWP_NOZORDER = 0x0004,
        SWP_NOREDRAW = 0x0008,
        SWP_NOACTIVATE = 0x0010,
        SWP_FRAMECHANGED = 0x0020,
        SWP_SHOWWINDOW = 0x0040,
        SWP_HIDEWINDOW = 0x0080,
        SWP_NOCOPYBITS = 0x0100,
        SWP_NOOWNERZORDER = 0x0200,
        SWP_NOSENDCHANGING = 0x0400,
        SWP_DRAWFRAME = 0x0020,
        SWP_NOREPOSITION = 0x0200,
        SWP_DEFERERASE = 0x2000,
        SWP_ASYNCWINDOWPOS = 0x4000,
        WM_IME_ENDCOMPOSITION = 0x10E,
        WM_NCMOUSEMOVE = 0x00A0,
        WM_NCLBUTTONDOWN = 0x00A1,
        WM_NCLBUTTONUP = 0x00A2,
        WM_NCLBUTTONDBLCLK = 0x00A3,
        WM_NCRBUTTONDOWN = 0x00A4,
        WM_NCRBUTTONUP = 0x00A5,
        WM_NCRBUTTONDBLCLK = 0x00A6,
        WM_NCMBUTTONDOWN = 0x00A7,
        WM_NCMBUTTONUP = 0x00A8,
        WM_NCMBUTTONDBLCLK = 0x00A9,
        WM_NCXBUTTONDOWN               = 0x00AB,
        WM_NCXBUTTONUP                 = 0x00AC,
        WM_NCXBUTTONDBLCLK             = 0x00AD,
        WM_MOUSEHOVER = 0x02A1,
        WM_MOUSELEAVE = 0x02A3,
        WM_MOUSEFIRST = 0x0200,
        WM_LBUTTONDOWN = 0x0201,
        WM_LBUTTONUP = 0x0202,
        WM_LBUTTONDBLCLK = 0x0203,
        WM_RBUTTONDOWN = 0x0204,
        WM_RBUTTONUP = 0x0205,
        WM_RBUTTONDBLCLK = 0x0206,
        WM_MBUTTONDOWN = 0x0207,
        WM_MBUTTONUP = 0x0208,
        WM_MBUTTONDBLCLK = 0x0209,
        WM_NCMOUSEHOVER = 0x02A0,
        WM_NCMOUSELEAVE = 0x02A2,
        WM_MOUSEWHEEL = 0x020A,
        WM_MOUSELAST = 0x020A,
        WM_NCHITTEST = 0x0084,
        WM_SETCURSOR = 0x0020,
        WM_GETOBJECT = 0x003D,
        WM_CANCELMODE = 0x001F,
        WM_SETFOCUS = 0x0007,
        WM_KEYFIRST = 0x0100,
        WM_KEYDOWN = 0x0100,
        WM_KEYUP = 0x0101,
        WM_DEADCHAR = 0x0103,
        WM_SYSKEYDOWN = 0x0104,
        WM_SYSKEYUP = 0x0105,
        WM_SYSCHAR = 0x0106,
        WM_SYSDEADCHAR = 0x0107,
        WM_KEYLAST = 0x0108,
        WM_CONTEXTMENU = 0x007B,
        WM_PAINT = 0x000F,
        WM_SIZE = 0x0005,
        WM_TIMER = 0x0113;

        [DllImport(ExternDll.User32, CharSet=CharSet.Auto)]
        public static extern IntPtr PostMessage(IntPtr hWnd, int msg, int wParam, int lParam);
        
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetCursorPos([In, Out] POINT pt);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr WindowFromPoint(int x, int y);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr SendMessage(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, IntPtr wParam, [In, Out] ref RECT lParam);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, IntPtr wParam, [In, Out] HDHITTESTINFO lParam);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr SendMessage(IntPtr hWnd, int msg, int wParam, int lParam);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr SendMessage(IntPtr hWnd, int msg, int wParam, string lParam);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]        
        public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, int wParam, [In, Out] TV_HITTESTINFO lParam);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, ref short wParam, ref short lParam);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, [In, Out, MarshalAs(UnmanagedType.Bool)] bool wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public extern static IntPtr SendMessage(IntPtr hWnd, int Msg, IntPtr wParam, ListViewCompareCallback pfnCompare);
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="SendMessageW", CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern IntPtr SendMessageW(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="SendMessageA", CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
        public static extern IntPtr SendMessageA(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr DefWindowProc(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GetWindow(IntPtr hWnd, int uCmd);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern short GetKeyState(int keyCode);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int MapWindowPoints(IntPtr hWndFrom, IntPtr hWndTo, [In, Out] ref RECT rect, int cPoints);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int MapWindowPoints(IntPtr hWndFrom, IntPtr hWndTo, [In, Out] POINT pt, int cPoints);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool ValidateRect(IntPtr hwnd, ref RECT rect);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool ValidateRect(IntPtr hwnd, IntPtr prect);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool ValidateRgn(IntPtr hwnd, IntPtr hrgn);

        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="CreateRectRgn", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern IntPtr IntCreateRectRgn(int x1, int y1, int x2, int y2);
        public static IntPtr CreateRectRgn(int x1, int y1, int x2, int y2) {
            return HandleCollector.Add(IntCreateRectRgn(x1, y1, x2, y2), CommonHandles.GDI);
        }
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetUpdateRect(IntPtr hwnd, [In, Out] ref RECT rc, bool fErase);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetUpdateRgn(IntPtr hwnd, IntPtr hrgn, bool fErase);
        [DllImport(ExternDll.Gdi32, ExactSpelling=true, EntryPoint="DeleteObject", CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern bool IntDeleteObject(IntPtr hObject);
        public static bool DeleteObject(IntPtr hObject) {
            HandleCollector.Remove(hObject, CommonHandles.GDI);
            return IntDeleteObject(hObject);
        }
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr SetParent(IntPtr hWnd, IntPtr hWndParent);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool TranslateMessage([In, Out] ref MSG msg);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int DispatchMessage([In] ref MSG msg);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
        public static extern int DispatchMessageA([In] ref MSG msg);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern int DispatchMessageW([In] ref MSG msg);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr SetTimer(IntPtr hWnd, int nIDEvent, int uElapse, TimerProc lpTimerFunc);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetWindowRect(IntPtr hWnd, [In, Out] ref RECT rect);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool KillTimer(IntPtr hwnd, int idEvent);
        [DllImport(ExternDll.Ole32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int RevokeDragDrop(IntPtr hwnd);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr ChildWindowFromPointEx(IntPtr hwndParent, int x, int y, int uFlags);

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool IsWindowVisible(IntPtr hWnd);

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GetFocus();  
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public class HDHITTESTINFO {
            public int pt_x;
            public int pt_y;
            public int flags;
            public int iItem;
        }
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)/*leftover(noAutoOffset)*/]
        public sealed class tagOLEVERB {
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.I4)/*leftover(offset=0, lVerb)*/]
            public int lVerb;

            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.LPWStr)/*leftover(offset=4, customMarshal="UniStringMarshaller", lpszVerbName)*/]
            public String lpszVerbName;

            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.U4)/*leftover(offset=8, fuFlags)*/]
            public int fuFlags;

            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.U4)/*leftover(offset=12, grfAttribs)*/]
            public int grfAttribs;

        }
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto, Pack=1)]
        public class TV_HITTESTINFO {
            public int  pt_x;
            public int  pt_y;
            public int  flags;
            public int  hItem;
        }

        public delegate int ListViewCompareCallback(IntPtr lParam1, IntPtr lParam2, IntPtr lParamSort);

        public delegate void TimerProc(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);

        internal class Util {
            public static int MAKELONG(int low, int high) {
                return(high << 16) | (low & 0xffff);
            }

            public static int MAKELPARAM(int low, int high) {
                return(high << 16) | (low & 0xffff);
            }

            public static int HIWORD(int n) {
                return(n >> 16) & 0xffff;
            }

            public static int LOWORD(int n) {
                return n & 0xffff;
            }

            public static int SignedHIWORD(int n) {
                int i = (int)(short)((n >> 16) & 0xffff);

                i = i << 16;
                i = i >> 16;

                return i;
            }

            public static int SignedLOWORD(int n) {
                int i = (int)(short)(n & 0xFFFF);

                i = i << 16;
                i = i >> 16;

                return i;
            }
            [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
            private static extern int lstrlen(String s);

            [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
            internal static extern int RegisterWindowMessage(String msg);
        }
        public sealed class CommonHandles {
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Accelerator"]/*' />
            /// <devdoc>
            ///     Handle type for accelerator tables.
            /// </devdoc>
            public static readonly int Accelerator  = HandleCollector.RegisterType("Accelerator", 80, 50);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Cursor"]/*' />
            /// <devdoc>
            ///     handle type for cursors.
            /// </devdoc>
            public static readonly int Cursor       = HandleCollector.RegisterType("Cursor", 20, 500);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.EMF"]/*' />
            /// <devdoc>
            ///     Handle type for enhanced metafiles.
            /// </devdoc>
            public static readonly int EMF          = HandleCollector.RegisterType("EnhancedMetaFile", 20, 500);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Find"]/*' />
            /// <devdoc>
            ///     Handle type for file find handles.
            /// </devdoc>
            public static readonly int Find         = HandleCollector.RegisterType("Find", 0, 1000);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.GDI"]/*' />
            /// <devdoc>
            ///     Handle type for GDI objects.
            /// </devdoc>
            public static readonly int GDI          = HandleCollector.RegisterType("GDI", 90, 50);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.HDC"]/*' />
            /// <devdoc>
            ///     Handle type for HDC's that count against the Win98 limit of five DC's.  HDC's
            ///     which are not scarce, such as HDC's for bitmaps, are counted as GDIHANDLE's.
            /// </devdoc>
            public static readonly int HDC          = HandleCollector.RegisterType("HDC", 100, 2); // wait for 2 dc's before collecting

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Icon"]/*' />
            /// <devdoc>
            ///     Handle type for icons.
            /// </devdoc>
            public static readonly int Icon         = HandleCollector.RegisterType("Icon", 20, 500);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Kernel"]/*' />
            /// <devdoc>
            ///     Handle type for kernel objects.
            /// </devdoc>
            public static readonly int Kernel       = HandleCollector.RegisterType("Kernel", 0, 1000);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Menu"]/*' />
            /// <devdoc>
            ///     Handle type for files.
            /// </devdoc>
            public static readonly int Menu         = HandleCollector.RegisterType("Menu", 30, 1000);

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.CommonHandles.Window"]/*' />
            /// <devdoc>
            ///     Handle type for windows.
            /// </devdoc>
            public static readonly int Window       = HandleCollector.RegisterType("Window", 5, 1000);
        }
        [System.Runtime.InteropServices.ComVisible(false)]
        public sealed class HandleCollector {
            private static HandleType[]             handleTypes = null;
            private static int                      handleTypeCount = 0;
            private static HandleChangeEventHandler handleAdd = null;
            private static HandleChangeEventHandler handleRemove = null;

#if MULTI_THREAD_COLLECT
            private static Daemon collectorDaemon = null;
#endif

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.Add"]/*' />
            /// <devdoc>
            ///     Adds the given handle to the handle collector.  This keeps the
            ///     handle on a "hot list" of objects that may need to be garbage
            ///     collected.
            /// </devdoc>
            public static IntPtr Add(IntPtr handle, int type) {
                handleTypes[type - 1].Add(handle);

#if MULTI_THREAD_COLLECT
                if (collectorDaemon == null) {
                    lock (typeof(HandleCollector)) {
                        if (collectorDaemon == null) {
                            collectorDaemon = new Daemon();
                        }
                    }
                }
#endif

                return handle;
            }


            public static event HandleChangeEventHandler HandleAdded {
                add {
                    handleAdd += value;
                }
                remove {
                    handleAdd -= value;
                }
            }


            public static event HandleChangeEventHandler HandleRemoved {
                add {
                    handleRemove += value;
                }
                remove {
                    handleRemove -= value;
                }
            }

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.RegisterType"]/*' />
            /// <devdoc>
            ///     Registers a new type of handle with the handle collector.
            /// </devdoc>
            public static int RegisterType(string typeName, int expense, int initialThreshold) {
                lock(typeof(HandleCollector)) {
                    if (handleTypeCount == 0 || handleTypeCount == handleTypes.Length) {
                        HandleType[] newTypes = new HandleType[handleTypeCount + 10];
                        if (handleTypes != null) {
                            Array.Copy(handleTypes, 0, newTypes, 0, handleTypeCount);
                        }
                        handleTypes = newTypes;
                    }

                    handleTypes[handleTypeCount++] = new HandleType(typeName, expense, initialThreshold);
                    return handleTypeCount;
                }
            }

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.Remove"]/*' />
            /// <devdoc>
            ///     Removes the given handle from the handle collector.  Removing a
            ///     handle removes it from our "hot list" of objects that should be
            ///     frequently garbage collected.
            /// </devdoc>
            public static IntPtr Remove(IntPtr handle, int type) {
                return handleTypes[type - 1].Remove(handle);
            }

#if MULTI_THREAD_COLLECT
            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.Daemon"]/*' />
            /// <devdoc>
            ///     Private inner class that runs a deamon thread to monitor
            ///     handle usage.
            /// </devdoc>
            private class Daemon {
                private Thread thread;

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.Daemon.Daemon"]/*' />
                /// <devdoc>
                ///     Creates a new Daemon thread monitor.
                /// </devdoc>
                public Daemon() {
                    thread = new Thread(new ThreadStart(this.ThreadProc));
                    thread.Priority = Thread.PriorityLowest;
                    thread.IsBackground = true;
                    thread.Start();
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.Daemon.Collect"]/*' />
                /// <devdoc>
                ///     Forces a GC if needed.
                /// </devdoc>
                public void Collect() {
                    // See if we need to collect.
                    //
                    bool collect = false;
                    HandleType[] collectedTypes = null;

                    lock (typeof(HandleCollector)) {
                        for (int i = 0; i < HandleCollector.handleTypeCount; i++) {
                            if (HandleCollector.handleTypes[i].NeedCollection()) {
                                if (collectedTypes == null) {
                                    collectedTypes = new HandleType[HandleCollector.handleTypeCount];
                                }
                                collectedTypes[i] = HandleCollector.handleTypes[i];
                                collect = true;
                            }
                        }
                    }

                    if (collect) {
                        GC.Collect();
                        for (int i = 0; i < collectedTypes.Length; i++) {
                            if (collectedTypes[i] != null) {
                                collectedTypes[i].Collected();
                            }
                        }
                    }
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.Daemon.Dispose"]/*' />
                /// <devdoc>
                ///     Disposes this daemon object by destroying the thread.
                /// </devdoc>
                public void Dispose() {
                    lock(this) {
                        if (thread != null) {
                            thread.Stop();
                            thread = null;
                        }
                    }
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.Daemon.ThreadProc"]/*' />
                /// <devdoc>
                ///     Thread proc.  This runs in it's own thread in the background, looking
                ///     for opportune times to force GC.
                /// </devdoc>
                private void ThreadProc() {
                    while (true) {
                        Collect();
                        try {
                            Thread.Sleep(500);
                        }
                        catch (ThreadInterruptedException e1) {
                        }
                    }
                }
            }
#endif

            /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType"]/*' />
            /// <devdoc>
            ///     Represents a specific type of handle.
            /// </devdoc>
            private class HandleType {
                public readonly String name;

                private int threshHold;
                private int handleCount;
                private readonly int deltaPercent;

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType.HandleType"]/*' />
                /// <devdoc>
                ///     Creates a new handle type.
                /// </devdoc>
                public HandleType(String name, int expense, int initialThreshold) {
                    this.name = name;
                    this.threshHold = initialThreshold;
                    this.handleCount = 0;
                    this.deltaPercent = 100 - expense;
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType.Add"]/*' />
                /// <devdoc>
                ///     Adds a handle to this handle type for monitoring.
                /// </devdoc>
                public void Add(IntPtr handle) {
                    lock(this) {
                        handleCount++;
#if !MULTI_THREAD_COLLECT
                        if (NeedCollection()) {
#if DEBUG_HANDLECOLLECTOR
                            Debug.WriteLine("HC> Forcing GC");
                            Debug.WriteLine("HC>     name        :" + name);
                            Debug.WriteLine("HC>     threshHold  :" + (threshHold).ToString());
                            Debug.WriteLine("HC>     handleCount :" + (handleCount).ToString());
                            Debug.WriteLine("HC>     deltaPercent:" + (deltaPercent).ToString());
#endif
                            GC.Collect();
                            Collected();
                        }
#endif

                        if (HandleCollector.handleAdd != null) {
                            HandleCollector.handleAdd(name, handle, GetHandleCount());
                        }
                    }
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType.Collected"]/*' />
                /// <devdoc>
                ///     Called after the collector has finished it's work.  Here,
                ///     we look at the number of objects currently outstanding
                ///     and establish a new cleanup threshhold.
                /// </devdoc>
                public void Collected() {
                    lock(this) {
                        threshHold = handleCount + ((handleCount * deltaPercent) / 100);
                    }
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType.GetHandleCount"]/*' />
                /// <devdoc>
                ///     Retrieves the outstanding handle count for this
                ///     handle type.
                /// </devdoc>
                public int GetHandleCount() {
                    lock(this) {
                        return handleCount;
                    }
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType.NeedCollection"]/*' />
                /// <devdoc>
                ///     Determines if this handle type needs a GC pass.
                /// </devdoc>
                public  bool NeedCollection() {
                    lock(this) {
                        return handleCount > threshHold;
                    }
                }

                /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.HandleCollector.HandleType.Remove"]/*' />
                /// <devdoc>
                ///     Removes the given handle from our monitor list.
                /// </devdoc>
                public IntPtr Remove(IntPtr handle) {
                    lock(this) {
                        handleCount--;
                        if (HandleCollector.handleRemove != null) {
                            HandleCollector.handleRemove(name, handle, GetHandleCount());
                        }
                        return handle;
                    }
                }
            }
        }
        public delegate void HandleChangeEventHandler(string handleType, IntPtr handleValue, int currentHandleCount);

        [System.Runtime.InteropServices.ComVisible(false)]
        internal class ActiveX {

            public const   int OCM__BASE = 0x2000;
            public const   int DISPID_VALUE = unchecked((int)0x0);
            public const   int DISPID_UNKNOWN = unchecked((int)0xFFFFFFFF);
            public const   int DISPID_AUTOSIZE = unchecked((int)0xFFFFFE0C);
            public const   int DISPID_BACKCOLOR = unchecked((int)0xFFFFFE0B);
            public const   int DISPID_BACKSTYLE = unchecked((int)0xFFFFFE0A);
            public const   int DISPID_BORDERCOLOR = unchecked((int)0xFFFFFE09);
            public const   int DISPID_BORDERSTYLE = unchecked((int)0xFFFFFE08);
            public const   int DISPID_BORDERWIDTH = unchecked((int)0xFFFFFE07);
            public const   int DISPID_DRAWMODE = unchecked((int)0xFFFFFE05);
            public const   int DISPID_DRAWSTYLE = unchecked((int)0xFFFFFE04);
            public const   int DISPID_DRAWWIDTH = unchecked((int)0xFFFFFE03);
            public const   int DISPID_FILLCOLOR = unchecked((int)0xFFFFFE02);
            public const   int DISPID_FILLSTYLE = unchecked((int)0xFFFFFE01);
            public const   int DISPID_FONT = unchecked((int)0xFFFFFE00);
            public const   int DISPID_FORECOLOR = unchecked((int)0xFFFFFDFF);
            public const   int DISPID_ENABLED = unchecked((int)0xFFFFFDFE);
            public const   int DISPID_HWND = unchecked((int)0xFFFFFDFD);
            public const   int DISPID_TABSTOP = unchecked((int)0xFFFFFDFC);
            public const   int DISPID_TEXT = unchecked((int)0xFFFFFDFB);
            public const   int DISPID_CAPTION = unchecked((int)0xFFFFFDFA);
            public const   int DISPID_BORDERVISIBLE = unchecked((int)0xFFFFFDF9);
            public const   int DISPID_APPEARANCE = unchecked((int)0xFFFFFDF8);
            public const   int DISPID_MOUSEPOINTER = unchecked((int)0xFFFFFDF7);
            public const   int DISPID_MOUSEICON = unchecked((int)0xFFFFFDF6);
            public const   int DISPID_PICTURE = unchecked((int)0xFFFFFDF5);
            public const   int DISPID_VALID = unchecked((int)0xFFFFFDF4);
            public const   int DISPID_READYSTATE = unchecked((int)0xFFFFFDF3);
            public const   int DISPID_REFRESH = unchecked((int)0xFFFFFDDA);
            public const   int DISPID_DOCLICK = unchecked((int)0xFFFFFDD9);
            public const   int DISPID_ABOUTBOX = unchecked((int)0xFFFFFDD8);
            public const   int DISPID_CLICK = unchecked((int)0xFFFFFDA8);
            public const   int DISPID_DBLCLICK = unchecked((int)0xFFFFFDA7);
            public const   int DISPID_KEYDOWN = unchecked((int)0xFFFFFDA6);
            public const   int DISPID_KEYPRESS = unchecked((int)0xFFFFFDA5);
            public const   int DISPID_KEYUP = unchecked((int)0xFFFFFDA4);
            public const   int DISPID_MOUSEDOWN = unchecked((int)0xFFFFFDA3);
            public const   int DISPID_MOUSEMOVE = unchecked((int)0xFFFFFDA2);
            public const   int DISPID_MOUSEUP = unchecked((int)0xFFFFFDA1);
            public const   int DISPID_ERROREVENT = unchecked((int)0xFFFFFDA0);
            public const   int DISPID_RIGHTTOLEFT = unchecked((int)0xFFFFFD9D);
            public const   int DISPID_READYSTATECHANGE = unchecked((int)0xFFFFFD9F);
            public const   int DISPID_AMBIENT_BACKCOLOR = unchecked((int)0xFFFFFD43);
            public const   int DISPID_AMBIENT_DISPLAYNAME = unchecked((int)0xFFFFFD42);
            public const   int DISPID_AMBIENT_FONT = unchecked((int)0xFFFFFD41);
            public const   int DISPID_AMBIENT_FORECOLOR = unchecked((int)0xFFFFFD40);
            public const   int DISPID_AMBIENT_LOCALEID = unchecked((int)0xFFFFFD3F);
            public const   int DISPID_AMBIENT_MESSAGEREFLECT = unchecked((int)0xFFFFFD3E);
            public const   int DISPID_AMBIENT_SCALEUNITS = unchecked((int)0xFFFFFD3D);
            public const   int DISPID_AMBIENT_TEXTALIGN = unchecked((int)0xFFFFFD3C);
            public const   int DISPID_AMBIENT_USERMODE = unchecked((int)0xFFFFFD3B);
            public const   int DISPID_AMBIENT_UIDEAD = unchecked((int)0xFFFFFD3A);
            public const   int DISPID_AMBIENT_SHOWGRABHANDLES = unchecked((int)0xFFFFFD39);
            public const   int DISPID_AMBIENT_SHOWHATCHING = unchecked((int)0xFFFFFD38);
            public const   int DISPID_AMBIENT_DISPLAYASDEFAULT = unchecked((int)0xFFFFFD37);
            public const   int DISPID_AMBIENT_SUPPORTSMNEMONICS = unchecked((int)0xFFFFFD36);
            public const   int DISPID_AMBIENT_AUTOCLIP = unchecked((int)0xFFFFFD35);
            public const   int DISPID_AMBIENT_APPEARANCE = unchecked((int)0xFFFFFD34);
            public const   int DISPID_AMBIENT_PALETTE = unchecked((int)0xFFFFFD2A);
            public const   int DISPID_AMBIENT_TRANSFERPRIORITY = unchecked((int)0xFFFFFD28);
            public const   int DISPID_Name = unchecked((int)0xFFFFFCE0);
            public const   int DISPID_Delete = unchecked((int)0xFFFFFCDF);
            public const   int DISPID_Object = unchecked((int)0xFFFFFCDE);
            public const   int DISPID_Parent = unchecked((int)0xFFFFFCDD);
            public const   int DVASPECT_CONTENT = 0x1;
            public const   int DVASPECT_THUMBNAIL = 0x2;
            public const   int DVASPECT_ICON = 0x4;
            public const   int DVASPECT_DOCPRINT = 0x8;
            public const   int OLEMISC_RECOMPOSEONRESIZE = 0x1;
            public const   int OLEMISC_ONLYICONIC = 0x2;
            public const   int OLEMISC_INSERTNOTREPLACE = 0x4;
            public const   int OLEMISC_STATIC = 0x8;
            public const   int OLEMISC_CANTLINKINSIDE = 0x10;
            public const   int OLEMISC_CANLINKBYOLE1 = 0x20;
            public const   int OLEMISC_ISLINKOBJECT = 0x40;
            public const   int OLEMISC_INSIDEOUT = 0x80;
            public const   int OLEMISC_ACTIVATEWHENVISIBLE = 0x100;
            public const   int OLEMISC_RENDERINGISDEVICEINDEPENDENT = 0x200;
            public const   int OLEMISC_INVISIBLEATRUNTIME = 0x400;
            public const   int OLEMISC_ALWAYSRUN = 0x800;
            public const   int OLEMISC_ACTSLIKEBUTTON = 0x1000;
            public const   int OLEMISC_ACTSLIKELABEL = 0x2000;
            public const   int OLEMISC_NOUIACTIVATE = 0x4000;
            public const   int OLEMISC_ALIGNABLE = 0x8000;
            public const   int OLEMISC_SIMPLEFRAME = 0x10000;
            public const   int OLEMISC_SETCLIENTSITEFIRST = 0x20000;
            public const   int OLEMISC_IMEMODE = 0x40000;
            public const   int OLEMISC_IGNOREACTIVATEWHENVISIBLE = 0x80000;
            public const   int OLEMISC_WANTSTOMENUMERGE = 0x100000;
            public const   int OLEMISC_SUPPORTSMULTILEVELUNDO = 0x200000;
            public const   int QACONTAINER_SHOWHATCHING = 0x1;
            public const   int QACONTAINER_SHOWGRABHANDLES = 0x2;
            public const   int QACONTAINER_USERMODE = 0x4;
            public const   int QACONTAINER_DISPLAYASDEFAULT = 0x8;
            public const   int QACONTAINER_UIDEAD = 0x10;
            public const   int QACONTAINER_AUTOCLIP = 0x20;
            public const   int QACONTAINER_MESSAGEREFLECT = 0x40;
            public const   int QACONTAINER_SUPPORTSMNEMONICS = 0x80;
            public const   int XFORMCOORDS_POSITION = 0x1;
            public const   int XFORMCOORDS_SIZE = 0x2;
            public const   int XFORMCOORDS_HIMETRICTOCONTAINER = 0x4;
            public const   int XFORMCOORDS_CONTAINERTOHIMETRIC = 0x8;
            public const   int PROPCAT_Nil = unchecked((int)0xFFFFFFFF);
            public const   int PROPCAT_Misc = unchecked((int)0xFFFFFFFE);
            public const   int PROPCAT_Font = unchecked((int)0xFFFFFFFD);
            public const   int PROPCAT_Position = unchecked((int)0xFFFFFFFC);
            public const   int PROPCAT_Appearance = unchecked((int)0xFFFFFFFB);
            public const   int PROPCAT_Behavior = unchecked((int)0xFFFFFFFA);
            public const   int PROPCAT_Data = unchecked((int)0xFFFFFFF9);
            public const   int PROPCAT_List = unchecked((int)0xFFFFFFF8);
            public const   int PROPCAT_Text = unchecked((int)0xFFFFFFF7);
            public const   int PROPCAT_Scale = unchecked((int)0xFFFFFFF6);
            public const   int PROPCAT_DDE = unchecked((int)0xFFFFFFF5);
            public const   int GC_WCH_SIBLING = 0x1;
            public const   int GC_WCH_CONTAINER = 0x2;
            public const   int GC_WCH_CONTAINED = 0x3;
            public const   int GC_WCH_ALL = 0x4;
            public const   int GC_WCH_FREVERSEDIR = 0x8000000;
            public const   int GC_WCH_FONLYNEXT = 0x10000000;
            public const   int GC_WCH_FONLYPREV = 0x20000000;
            public const   int GC_WCH_FSELECTED = 0x40000000;
            public const   int OLECONTF_EMBEDDINGS = 0x1;
            public const   int OLECONTF_LINKS = 0x2;
            public const   int OLECONTF_OTHERS = 0x4;
            public const   int OLECONTF_ONLYUSER = 0x8;
            public const   int OLECONTF_ONLYIFRUNNING = 0x10;
            public const   int ALIGN_MIN = 0x0;
            public const   int ALIGN_NO_CHANGE = 0x0;
            public const   int ALIGN_TOP = 0x1;
            public const   int ALIGN_BOTTOM = 0x2;
            public const   int ALIGN_LEFT = 0x3;
            public const   int ALIGN_RIGHT = 0x4;
            public const   int ALIGN_MAX = 0x4;
            public const   int OLEVERBATTRIB_NEVERDIRTIES = 0x1;
            public const   int OLEVERBATTRIB_ONCONTAINERMENU = 0x2;

            public static Guid IID_IUnknown = new Guid("{00000000-0000-0000-C000-000000000046}");
        }
        public static bool Succeeded(int hr) {
            return(hr >= 0);
        }

        public static bool Failed(int hr) {
            return(hr < 0);
        }
        [ComImport(), Guid("00000104-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IEnumOLEVERB {


            [PreserveSig]
            int Next(
                    [MarshalAs(UnmanagedType.U4)] 
                    int celt,
                    [Out]
                    NativeMethods.tagOLEVERB rgelt,
                    [Out, MarshalAs(UnmanagedType.LPArray)]
                    int[] pceltFetched);

            [PreserveSig]
            int Skip(
                    [In, MarshalAs(UnmanagedType.U4)] 
                    int celt);


            void Reset();


            void Clone(
                      out NativeMethods.IEnumOLEVERB ppenum);


        }

        [ComImport(), Guid("00000105-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IEnumSTATDATA {


            void Next(
                     [In, MarshalAs(UnmanagedType.U4)] 
                     int celt,
                     [Out] 
                     NativeMethods.STATDATA rgelt,
                     [Out, MarshalAs(UnmanagedType.LPArray)] 
                     int[] pceltFetched);


            void Skip(
                     [In, MarshalAs(UnmanagedType.U4)] 
                     int celt);


            void Reset();


            void Clone(
                      [Out, MarshalAs(UnmanagedType.LPArray)] 
                      NativeMethods.IEnumSTATDATA[] ppenum);


        }
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        public sealed class STATDATA {

            [MarshalAs(UnmanagedType.U4)]
            public   int advf;
            [MarshalAs(UnmanagedType.U4)]
            public   int dwConnection;
        }

    
        [ComImport(), Guid("00000103-0000-0000-C000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IEnumFORMATETC {


            [PreserveSig]
            int Next(
                    [In, MarshalAs(UnmanagedType.U4)] 
                    int celt,
                    [Out] 
                    NativeMethods.FORMATETC rgelt,
                    [In, Out, MarshalAs(UnmanagedType.LPArray)] 
                    int[] pceltFetched);


            [PreserveSig]
            int Skip(
                    [In, MarshalAs(UnmanagedType.U4)] 
                    int celt);


            [PreserveSig]
            int Reset();


            [PreserveSig]
            int Clone(
                     [Out, MarshalAs(UnmanagedType.LPArray)] 
                     NativeMethods.IEnumFORMATETC[] ppenum);


        }
        
        public const int CHILDID_SELF = 0;
        public const int OBJID_WINDOW = 0x00000000;
        public const int OBJID_CLIENT = unchecked(unchecked((int)0xFFFFFFFC));
        public const string uuid_IAccessible  = "{618736E0-3C3D-11CF-810C-00AA00389B71}";
        public const string uuid_IEnumVariant = "{00020404-0000-0000-C000-000000000046}";

        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        public static extern UCOMITypeLib LoadRegTypeLib(ref Guid clsid, short majorVersion, short minorVersion, int lcid);

        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        public extern static UCOMITypeLib LoadTypeLib([In, MarshalAs(UnmanagedType.LPWStr)]
                                                 string typelib);

        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        public extern static UCOMITypeLib LoadTypeLibFromResource([In, MarshalAs(UnmanagedType.LPWStr)]
                                                             string typelib);

        [DllImport(ExternDll.Oleaut32, PreserveSig=false)]
        [return: MarshalAs(UnmanagedType.BStr)]
        public extern static string QueryPathOfRegTypeLib(ref Guid guid, short majorVersion, short minorVersion, int lcid);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\colorbuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="ColorBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.ComponentModel;
    using System.Diagnostics;

    /// <include file='doc\ColorBuilder.uex' path='docs/doc[@for="ColorBuilder"]/*' />
    /// <devdoc>
    ///   Helper class used by designers to 'build' color properties by
    ///   launching a color picker.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public sealed class ColorBuilder {

        private ColorBuilder() {
        }

        /// <include file='doc\ColorBuilder.uex' path='docs/doc[@for="ColorBuilder.BuildColor"]/*' />
        /// <devdoc>
        ///   Launches the Color Picker to build a color.
        /// </devdoc>
        public static string BuildColor(IComponent component, System.Windows.Forms.Control owner, string initialColor) {
            string result = null;

            ISite componentSite = component.Site;
            Debug.Assert(componentSite != null, "Component does not have a valid site.");

            if (componentSite == null) {
                Debug.Fail("Component does not have a valid site.");   
                return null;
            }

            if (componentSite != null) {
                IWebFormsBuilderUIService builderService = 
                    (IWebFormsBuilderUIService)componentSite.GetService(typeof(IWebFormsBuilderUIService));

                if (builderService != null) {
                    result = builderService.BuildColor(owner, initialColor);
                }
            }

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\system\design\unsafenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnsafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Design {
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [
    System.Runtime.InteropServices.ComVisible(false), 
    System.Security.SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class UnsafeNativeMethods {
    
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr PostMessage(IntPtr hwnd, int msg, IntPtr wparam, IntPtr lparam);
    
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr SendMessage(IntPtr hwnd, int msg, int wparam, NativeMethods.TV_HITTESTINFO lparam);

        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr SendMessage(IntPtr hwnd, int msg, int wparam, NativeMethods.TCHITTESTINFO lparam);
    
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GetActiveWindow();
        
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern void NotifyWinEvent(int winEvent, IntPtr hwnd, int objType, int objID);

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr SetFocus(IntPtr hWnd);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern IntPtr GetFocus();
        
        [System.Runtime.InteropServices.ComVisible(false), Flags]    
        public enum BrowseInfos {
            // Browsing for directory.
            ReturnOnlyFSDirs   = 0x0001,  // For finding a folder to start document searching
            DontGoBelowDomain  = 0x0002,  // For starting the Find Computer
            StatusText         = 0x0004,   // Top of the dialog has 2 lines of text for BROWSEINFO.lpszTitle and one line if
                                                                        // this flag is set.  Passing the message BFFM_SETSTATUSTEXTA to the hwnd can set the
                                                                        // rest of the text.  This is not used with USENEWUI and BROWSEINFO.lpszTitle gets
                                                                        // all three lines of text.
            ReturnFSAncestors  = 0x0008,
            EditBox            = 0x0010,   // Add an editbox to the dialog
            Validate           = 0x0020,   // insist on valid result (or CANCEL)

            NewDialogStyle     = 0x0040,   // Use the new dialog layout with the ability to resize
                                                    // Caller needs to call OleInitialize() before using this API

            UseNewUI           = (NewDialogStyle | EditBox),

            AllowUrls          = 0x0080,   // Allow URLs to be displayed or entered. (Requires USENEWUI)

            BrowseForComputer  = 0x1000,  // Browsing for Computers.
            BrowseForPrinter   = 0x2000,  // Browsing for Printers
            BrowseForEverything= 0x4000,  // Browsing for Everything
            ShowShares         = 0x8000   // sharable resources displayed (remote shares, requires USENEWUI)
        }
    
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        public class BROWSEINFO {
            public IntPtr   hwndOwner;       //HWND        hwndOwner;    // HWND of the owner for the dialog
            public IntPtr   pidlRoot;        //LPCITEMIDLIST pidlRoot;   // Root ITEMIDLIST
    
            // For interop purposes, send over a buffer of MAX_PATH size. 
            public IntPtr   pszDisplayName;  //LPWSTR       pszDisplayName;      // Return display name of item selected.
    
            public string   lpszTitle;       //LPCWSTR      lpszTitle;           // text to go in the banner over the tree.
            public int      ulFlags;         //UINT         ulFlags;                     // Flags that control the return stuff
            public IntPtr   lpfn;            //BFFCALLBACK  lpfn;            // Call back pointer
            public IntPtr   lParam;          //LPARAM       lParam;                      // extra info that's passed back in callbacks
            public int      iImage;          //int          iImage;                      // output var: where to return the Image index.
        }
    
        [System.Runtime.InteropServices.ComVisible(false)]
        public class Shell32 {
            [DllImport(ExternDll.Shell32)]
            public static extern int SHGetSpecialFolderLocation(IntPtr hwnd, int csidl, ref IntPtr ppidl);
            //SHSTDAPI SHGetSpecialFolderLocation(HWND hwnd, int csidl, LPITEMIDLIST *ppidl);
    
            [DllImport(ExternDll.Shell32, CharSet=CharSet.Auto)]
            public static extern bool SHGetPathFromIDList(IntPtr pidl, IntPtr pszPath);        
            //SHSTDAPI_(BOOL) SHGetPathFromIDListW(LPCITEMIDLIST pidl, LPWSTR pszPath);
            
            [DllImport(ExternDll.Shell32, CharSet=CharSet.Auto)]
            public static extern IntPtr SHBrowseForFolder([In] BROWSEINFO lpbi);        
            //SHSTDAPI_(LPITEMIDLIST) SHBrowseForFolderW(LPBROWSEINFOW lpbi);
    
            [DllImport(ExternDll.Shell32)]
            public static extern int SHGetMalloc([Out, MarshalAs(UnmanagedType.LPArray)] UnsafeNativeMethods.IMalloc[] ppMalloc);
            //SHSTDAPI SHGetMalloc(LPMALLOC * ppMalloc);
        }
        
        [ComImport(), Guid("00000002-0000-0000-c000-000000000046"), System.Runtime.InteropServices.InterfaceTypeAttribute(System.Runtime.InteropServices.ComInterfaceType.InterfaceIsIUnknown)]
        public interface IMalloc {
    
             IntPtr Alloc(
    
                     int cb);
    
             void Free(
    
                     IntPtr pv);
    
    
             IntPtr Realloc(
    
                     IntPtr pv,
    
                     int cb);
    
    
             int GetSize(
    
                     IntPtr pv);
    
    
             int DidAlloc(
    
                     IntPtr pv);
    
             void HeapMinimize();
        }
        
        [DllImport(ExternDll.Oleacc, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr LresultFromObject(ref Guid refiid, IntPtr wParam, IntPtr pAcc);

        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="BeginPaint", CharSet=CharSet.Auto)]
        public static extern IntPtr BeginPaint(IntPtr hWnd, [In, Out] ref PAINTSTRUCT lpPaint);

        [DllImport(ExternDll.User32, ExactSpelling=true, EntryPoint="EndPaint", CharSet=CharSet.Auto)]
        public static extern bool EndPaint(IntPtr hWnd, ref PAINTSTRUCT lpPaint);

        [StructLayout(LayoutKind.Sequential)]
        public struct PAINTSTRUCT {
            public IntPtr   hdc;
            public bool     fErase;
            // rcPaint was a by-value RECT structure
            public int      rcPaint_left;
            public int      rcPaint_top;
            public int      rcPaint_right;
            public int      rcPaint_bottom;
            public bool     fRestore;
            public bool     fIncUpdate;    
            public int      reserved1;
            public int      reserved2;
            public int      reserved3;
            public int      reserved4;
            public int      reserved5;
            public int      reserved6;
            public int      reserved7;
            public int      reserved8;
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\databindinghandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataBindingHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Web.UI;

    /// <include file='doc\DataBindingHandler.uex' path='docs/doc[@for="DataBindingHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public abstract class DataBindingHandler {

        /// <include file='doc\DataBindingHandler.uex' path='docs/doc[@for="DataBindingHandler.DataBindControl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract void DataBindControl(IDesignerHost designerHost, Control control);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\databindingcollectionconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataBindingCollectionConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.ComponentModel;
    using System.Globalization;

    /// <include file='doc\DataBindingCollectionConverter.uex' path='docs/doc[@for="DataBindingCollectionConverter"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides conversion functions for data binding collections.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class DataBindingCollectionConverter : TypeConverter {

        /// <include file='doc\DataBindingCollectionConverter.uex' path='docs/doc[@for="DataBindingCollectionConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts a data binding collection to the specified type.
        ///    </para>
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == typeof(string)) {
                return String.Empty;
            }
            else {
                return base.ConvertTo(context, culture, value, destinationType);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\databindingcollectioneditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataBindingCollectionEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing.Design;
    using System.Web.UI.Design.DataBindingUI;
    using System.Windows.Forms;
    using System.Windows.Forms.Design;

    using Control = System.Web.UI.Control;

    /// <include file='doc\DataBindingCollectionEditor.uex' path='docs/doc[@for="DataBindingCollectionEditor"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides editing functions for data binding collections.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class DataBindingCollectionEditor : UITypeEditor {

        /// <include file='doc\DataBindingCollectionEditor.uex' path='docs/doc[@for="DataBindingCollectionEditor.EditValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Edits a data binding within the design time
        ///       data binding collection.
        ///    </para>
        /// </devdoc>
        public override object EditValue(ITypeDescriptorContext context,  IServiceProvider  provider, object value) {
            Debug.Assert(context.Instance is Control, "Expected control");
            Control c = (Control)context.Instance;

            IServiceProvider  site = c.Site;
            if (site == null) {
                if (c.Page != null) {
                    site = c.Page.Site;
                }
                if (site == null) {
                    site = provider;
                }
            }
            if (site == null) {
                // REVIEW: What else could be done here?
                return value;
            }
            
            IDesignerHost designerHost =
                (IDesignerHost)site.GetService(typeof(IDesignerHost));
            Debug.Assert(designerHost != null, "Must always have access to IDesignerHost service");

            DesignerTransaction transaction = designerHost.CreateTransaction("(DataBindings)");

            try {
                IComponentChangeService changeService =
                    (IComponentChangeService)site.GetService(typeof(IComponentChangeService));

                if (changeService != null) {
                    try {
                        changeService.OnComponentChanging(c, null);
                    }
                    catch (CheckoutException ce) {
                        if (ce == CheckoutException.Canceled)
                            return value;
                        throw ce;
                    }
                }

                DialogResult result = DialogResult.Cancel;
                try {
                    DataBindingForm dbForm = new DataBindingForm(c, site);
                    IWindowsFormsEditorService edSvc = (IWindowsFormsEditorService)provider.GetService(typeof(IWindowsFormsEditorService));
                    result = edSvc.ShowDialog(dbForm);
                }
                finally {
                    if ((result == DialogResult.OK) && (changeService != null)) {
                        try {
                            changeService.OnComponentChanged(c, null, null, null);
                        }
                        catch {
                        }
                    }
                }
            }
            finally {
                transaction.Commit();
            }

            return value;
        }

        /// <include file='doc\DataBindingCollectionEditor.uex' path='docs/doc[@for="DataBindingCollectionEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the edit stytle for use by the editor.
        ///    </para>
        /// </devdoc>
        public override UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.Modal;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\controlparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="ControlParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Reflection;
    using System.Web.UI;

    /// <include file='doc\ControlParser.uex' path='docs/doc[@for="ControlParser"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public sealed class ControlParser {

        private static readonly object licenseManagerLock = new object();

        private ControlParser() {
        }

        private static string GetDirectives(IDesignerHost designerHost) {
            Debug.Assert(designerHost != null);

            string directives = String.Empty;

            IWebFormReferenceManager refMgr =
                (IWebFormReferenceManager)designerHost.GetService(typeof(IWebFormReferenceManager));
            Debug.Assert(refMgr != null, "Expected to be able to get IWebFormReferenceManager");

            if (refMgr != null) {
                directives = refMgr.GetRegisterDirectives();
            }

            return directives;
        }

        /// <include file='doc\ControlParser.uex' path='docs/doc[@for="ControlParser.ParseControl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Control ParseControl(IDesignerHost designerHost, string controlText) {
            if ((designerHost == null) || (controlText == null) || (controlText.Length == 0)) {
                throw new ArgumentNullException();
            }
            
            string directives = GetDirectives(designerHost);
            return ParseControl(designerHost, controlText, directives);
        }

        /// <include file='doc\ControlParser.uex' path='docs/doc[@for="ControlParser.ParseControl1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Control ParseControl(IDesignerHost designerHost, string controlText, string directives) {
            if ((designerHost == null) || (controlText == null) || (controlText.Length == 0)) {
                throw new ArgumentNullException();
            }

            if ((directives != null) && (directives.Length != 0)) {
                controlText = directives + controlText;
            }

            DesignTimeParseData parseData = new DesignTimeParseData(designerHost, controlText);
            parseData.DataBindingHandler = GlobalDataBindingHandler.Handler;
            
            Control parsedControl = null;
            lock(typeof(LicenseManager)) {
                LicenseContext originalContext = LicenseManager.CurrentContext;
                try {
                    LicenseManager.CurrentContext = new WebFormsDesigntimeLicenseContext(designerHost);
                    LicenseManager.LockContext(licenseManagerLock);

                    parsedControl = DesignTimeTemplateParser.ParseControl(parseData);
                }
                catch (TargetInvocationException e) {
                    Debug.Assert(e.InnerException != null);
                    throw e.InnerException;
                }
                finally {
                    LicenseManager.UnlockContext(licenseManagerLock);
                    LicenseManager.CurrentContext = originalContext;
                }
            }
            return parsedControl;
        }

        /// <include file='doc\ControlParser.uex' path='docs/doc[@for="ControlParser.ParseTemplate"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static ITemplate ParseTemplate(IDesignerHost designerHost, string templateText) {
            if ((designerHost == null) || (templateText == null) || (templateText.Length == 0)) {
                throw new ArgumentNullException();
            }
            
            string directives = GetDirectives(designerHost);
            return ParseTemplate(designerHost, templateText, directives);
        }

        /// <include file='doc\ControlParser.uex' path='docs/doc[@for="ControlParser.ParseTemplate1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static ITemplate ParseTemplate(IDesignerHost designerHost, string templateText, string directives) {
            if ((designerHost == null) || (templateText == null) || (templateText.Length == 0)) {
                throw new ArgumentNullException();
            }

            bool stripOutDirectives = false;
            string parseText = templateText;

            if ((directives != null) && (directives.Length != 0)) {
                parseText = directives + templateText;
                stripOutDirectives = true;
            }

            DesignTimeParseData parseData = new DesignTimeParseData(designerHost, parseText);
            parseData.DataBindingHandler = GlobalDataBindingHandler.Handler;

            ITemplate parsedTemplate = null;
            lock(typeof(LicenseManager)) {
                LicenseContext originalContext = LicenseManager.CurrentContext;
                try {
                    LicenseManager.CurrentContext = new WebFormsDesigntimeLicenseContext(designerHost);
                    LicenseManager.LockContext(licenseManagerLock);

                    parsedTemplate = DesignTimeTemplateParser.ParseTemplate(parseData);
                }
                catch (TargetInvocationException e) {
                    Debug.Assert(e.InnerException != null);
                    throw e.InnerException;
                }
                finally {
                    LicenseManager.UnlockContext(licenseManagerLock);
                    LicenseManager.CurrentContext = originalContext;
                }
            }

            if ((parsedTemplate != null) && stripOutDirectives) {
                // The parsed template contains all the text sent to the parser
                // which includes the register directives.
                // We don't want to have these directives end up in the template
                // text. Unfortunately, theres no way to pass them as a separate
                // text block to the parser, so we'll have to do some fixup here.
                
                Debug.Assert(parsedTemplate is TemplateBuilder, "Unexpected type of ITemplate implementation.");
                if (parsedTemplate is TemplateBuilder) {
                    ((TemplateBuilder)parsedTemplate).Text = templateText;
                }
            }
            
            return parsedTemplate;
        }

        private sealed class WebFormsDesigntimeLicenseContext : DesigntimeLicenseContext {
            private IServiceProvider provider;

            public WebFormsDesigntimeLicenseContext(IServiceProvider provider) {
                this.provider = provider;
            }

            public override object GetService(Type serviceClass) {
                if (provider != null) {
                    return provider.GetService(serviceClass);
                }
                else {
                    return null;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\databindingvalueuihandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataBindingValueUIHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {
    using System;
    using System.Design;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Reflection;
    using System.Web.UI;
    using System.Web.UI.WebControls;    

    /// <include file='doc\DataBindingValueUIHandler.uex' path='docs/doc[@for="DataBindingValueUIHandler"]/*' />
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class DataBindingValueUIHandler {

        private Bitmap dataBindingBitmap;
        private string dataBindingToolTip;

        private Bitmap DataBindingBitmap {
            get {
                if (dataBindingBitmap == null) {
                    dataBindingBitmap = new Bitmap(typeof(DataBindingValueUIHandler), "DataBindingGlyph.bmp");
                    dataBindingBitmap.MakeTransparent();
                }
                return dataBindingBitmap;
            }
        }

        private string DataBindingToolTip {
            get {
                if (dataBindingToolTip == null) {
                    dataBindingToolTip = SR.GetString(SR.DataBindingGlyph_ToolTip);
                }
                return dataBindingToolTip;
            }
        }

        /// <include file='doc\DataBindingValueUIHandler.uex' path='docs/doc[@for="DataBindingValueUIHandler.OnGetUIValueItem"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void OnGetUIValueItem(ITypeDescriptorContext context, PropertyDescriptor propDesc, ArrayList valueUIItemList) {
            Control ctrl = context.Instance as Control;
            if (ctrl != null) {
                IDataBindingsAccessor dbAcc = (IDataBindingsAccessor)ctrl;

                if (dbAcc.HasDataBindings) {
                    DataBinding db = dbAcc.DataBindings[propDesc.Name];

                    if (db != null) {
                        valueUIItemList.Add(new DataBindingUIItem(this));
                    }
                }
            }
        }

        private void OnValueUIItemInvoke(ITypeDescriptorContext context, PropertyDescriptor propDesc, PropertyValueUIItem invokedItem) {
            // REVIEW: Any invoke action?
        }


        private class DataBindingUIItem : PropertyValueUIItem {

            public DataBindingUIItem(DataBindingValueUIHandler handler) :
                base(handler.DataBindingBitmap, new PropertyValueUIItemInvokeHandler(handler.OnValueUIItemInvoke), handler.DataBindingToolTip) {
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\datafieldconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataFieldConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Globalization;

    /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides design-time support for a component's data field properties.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class DataFieldConverter : TypeConverter {

        /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter.DataFieldConverter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.DataFieldConverter'/>.
        ///    </para>
        /// </devdoc>
        public DataFieldConverter() {
        }

        /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this converter can
        ///       convert an object in the given source type to the native type of the converter
        ///       using the context.
        ///    </para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return false;
        }

        /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the given object to the converter's native type.
        ///    </para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value == null) {
                return String.Empty;
            }
            else if (value.GetType() == typeof(string)) {
                return (string)value;
            }
            throw GetConvertFromException(value);
        }

        /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter.GetStandardValues"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the fields present within the selected data source if information about them is available.
        ///    </para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            object[] names = null;
            
            if (context != null) {
                ArrayList list = new ArrayList();

                PropertyDescriptorCollection props = null;

                // REVIEW: We should try and support the multi-select scenario - Get the data source
                //         from each selected component. If they are the same, we can proceed,
                //         otherwise return an empty collection.

                // This converter shouldn't be used in a multi-select scenario. If it is, it simply
                // returns no standard values.

                IComponent component = context.Instance as IComponent;
                if (component != null) {
                    ISite componentSite = component.Site;
                    if (componentSite != null) {
                        IDesignerHost designerHost = (IDesignerHost)componentSite.GetService(typeof(IDesignerHost));
                        if (designerHost != null) {
                            IDesigner designer = designerHost.GetDesigner(component);

                            if (designer is IDataSourceProvider) {
                                IEnumerable dataSource = ((IDataSourceProvider)designer).GetResolvedSelectedDataSource();

                                if (dataSource != null) {
                                    props = DesignTimeData.GetDataFields(dataSource);
                                }
                            }
                        }
                    }
                }
                
                if (props != null) {
                    foreach (PropertyDescriptor propDesc in props) {
                        list.Add(propDesc.Name);
                    }
                }

                names = list.ToArray();
                Array.Sort(names, Comparer.Default);
            }
            return new StandardValuesCollection(names);
        }

        /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter.GetStandardValuesExclusive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the collection of standard values returned from
        ///    <see cref='System.ComponentModel.TypeConverter.GetStandardValues'/> is an exclusive 
        ///       list of possible values, using the specified context.
        ///    </para>
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return false;
        }

        /// <include file='doc\DataFieldConverter.uex' path='docs/doc[@for="DataFieldConverter.GetStandardValuesSupported"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this object supports a standard set of values
        ///       that can be picked from a list.
        ///    </para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            if (context.Instance is IComponent) {
                // We only support the dropdown in single-select mode.
                return true;
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\datamemberconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataMemberConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Globalization;
    using System.Runtime.InteropServices;

    /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides design-time support for a component's DataMember properties.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class DataMemberConverter : TypeConverter {

        /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter.DataMemberConverter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.DataFieldConverter'/>.
        ///    </para>
        /// </devdoc>
        public DataMemberConverter() {
        }

        /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this converter can
        ///       convert an object in the given source type to the native type of the converter
        ///       using the context.
        ///    </para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return false;
        }

        /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the given object to the converter's native type.
        ///    </para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value == null) {
                return String.Empty;
            }
            else if (value.GetType() == typeof(string)) {
                return (string)value;
            }
            throw GetConvertFromException(value);
        }

        /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter.GetStandardValues"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the fields present within the selected data source if information about them is available.
        ///    </para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            string[] names = null;
            
            if (context != null) {
                // REVIEW: We should try and support the multi-select scenario - Get the data source
                //         from each selected component. If they are the same, we can proceed,
                //         otherwise return an empty collection.

                // This converter shouldn't be used in a multi-select scenario. If it is, it simply
                // returns no standard values.
                IComponent component = context.Instance as IComponent;

                if (component != null) {
                    ISite componentSite = component.Site;
                    if (componentSite != null) {
                        IDesignerHost designerHost = (IDesignerHost)componentSite.GetService(typeof(IDesignerHost));
                        if (designerHost != null) {
                            IDesigner designer = designerHost.GetDesigner(component);

                            if (designer is IDataSourceProvider) {
                                object dataSource = ((IDataSourceProvider)designer).GetSelectedDataSource();

                                if (dataSource != null) {
                                    names = DesignTimeData.GetDataMembers(dataSource);
                                }
                            }
                        }
                    }
                }
                
                if (names == null) {
                    names = new string[0];
                }
                Array.Sort(names, Comparer.Default);
            }
            return new StandardValuesCollection(names);
        }

        /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter.GetStandardValuesExclusive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the collection of standard values returned from
        ///    <see cref='System.ComponentModel.TypeConverter.GetStandardValues'/> is an exclusive 
        ///       list of possible values, using the specified context.
        ///    </para>
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return false;
        }

        /// <include file='doc\DataMemberConverter.uex' path='docs/doc[@for="DataMemberConverter.GetStandardValuesSupported"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this object supports a standard set of values
        ///       that can be picked from a list.
        ///    </para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            if (context.Instance is IComponent) {
                // We only support the dropdown in single-select mode.
                return true;
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\globaldatabindinghandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="GlobalDataBindingHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.Reflection;
    using System.Web.UI;

    //using DataBinding = System.Web.UI.DataBinding;

    /// <include file='doc\GlobalDataBindingHandler.uex' path='docs/doc[@for="GlobalDataBindingHandler"]/*' />
    /// <devdoc>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class GlobalDataBindingHandler {

        public static readonly EventHandler Handler = new EventHandler(GlobalDataBindingHandler.OnDataBind);
        private static Hashtable dataBindingHandlerTable;

        /// <include file='doc\GlobalDataBindingHandler.uex' path='docs/doc[@for="GlobalDataBindingHandler.GlobalDataBindingHandler"]/*' />
        /// <devdoc>
        /// </devdoc>
        private GlobalDataBindingHandler() {
        }

        /// <include file='doc\GlobalDataBindingHandler.uex' path='docs/doc[@for="GlobalDataBindingHandler.DataBindingHandlerTable"]/*' />
        /// <devdoc>
        /// </devdoc>
        private static Hashtable DataBindingHandlerTable {
            get {
                if (dataBindingHandlerTable == null) {
                    dataBindingHandlerTable = new Hashtable();
                }
                return dataBindingHandlerTable;
            }
        }

        /// <include file='doc\GlobalDataBindingHandler.uex' path='docs/doc[@for="GlobalDataBindingHandler.OnDataBind"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static void OnDataBind(object sender, EventArgs e) {
            Debug.Assert(sender is Control, "DataBindings can only be present on Controls.");
            Control control = (Control)sender;

            // check if this control has any data-bindings
            IDataBindingsAccessor dataBindingsAccessor = (IDataBindingsAccessor)sender;
            if (dataBindingsAccessor.HasDataBindings == false) {
                return;
            }

            // check if the control type has an associated data-binding handler
            DataBindingHandlerAttribute handlerAttribute =
                (DataBindingHandlerAttribute)TypeDescriptor.GetAttributes(sender)[typeof(DataBindingHandlerAttribute)];
            if ((handlerAttribute == null) || (handlerAttribute.HandlerTypeName.Length == 0)) {
                return;
            }

            // components in the designer/container do not get handled here; the
            // designer for that control handles it in its own special way
            ISite site = control.Site;
            IDesignerHost designerHost = null;
            if (site == null) {
                Page page = control.Page;
                if (page != null) {
                    site = page.Site;
                }
                else {
                    // When the designer is working on a UserControl instead of a Page

                    Control parent = control.Parent;

                    // We shouldn't have to walk up the parent chain a whole lot - maybe a couple
                    // of levels on the average
                    while ((site == null) && (parent != null)) {
                        if (parent.Site != null) {
                            site = parent.Site;
                        }
                        parent = parent.Parent;
                    }
                }
            }
            if (site != null) {
                designerHost = (IDesignerHost)site.GetService(typeof(IDesignerHost));
            }
            if (designerHost == null) {
                Debug.Fail("Did not get back an IDesignerHost");
                return;
            }

            // non-top level components, such as controls within templates do not have designers
            // these are the only things that need the data-binding handler stuff
            IDesigner designer = designerHost.GetDesigner(control);
            if (designer != null) {
                return;
            }

            // get the handler and cache it the first time around
            DataBindingHandler dataBindingHandler = null;
            try {
                string handlerTypeName = handlerAttribute.HandlerTypeName;
                dataBindingHandler = (DataBindingHandler)DataBindingHandlerTable[handlerTypeName];

                if (dataBindingHandler == null) {
                    Type handlerType = Type.GetType(handlerTypeName);
                    if (handlerType != null) {
                        dataBindingHandler = (DataBindingHandler)Activator.CreateInstance(handlerType, BindingFlags.Instance | BindingFlags.Public | BindingFlags.CreateInstance, null, null, null);
                        DataBindingHandlerTable[handlerTypeName] = dataBindingHandler;
                    }
                }
            }
            catch (Exception ex) {
                Debug.Fail(ex.ToString());
                return;
            }

            // finally delegate to it to handle this particular control
            if (dataBindingHandler != null) {
                dataBindingHandler.DataBindControl(designerHost, control);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\datasourceconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DataSourceConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.CodeDom;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Data;
    using System.Diagnostics;
    using System.Runtime.InteropServices;
    using System.Globalization;

    /// <include file='doc\DataSourceConverter.uex' path='docs/doc[@for="DataSourceConverter"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides design-time support for a component's data source property.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class DataSourceConverter : TypeConverter {

        /// <include file='doc\DataSourceConverter.uex' path='docs/doc[@for="DataSourceConverter.DataSourceConverter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.Web.UI.Design.DataSourceConverter'/>.
        ///    </para>
        /// </devdoc>
        public DataSourceConverter() {
        }

        /// <include file='doc\DataSourceConverter.uex' path='docs/doc[@for="DataSourceConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this converter can
        ///       convert an object in the given source type to the native type of the converter
        ///       using the context.
        ///    </para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return false;
        }

        /// <include file='doc\DataSourceConverter.uex' path='docs/doc[@for="DataSourceConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the given object to the converter's native type.
        ///    </para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value == null) {
                return String.Empty;
            }
            else if (value.GetType() == typeof(string)) {
                return (string)value;
            }
            throw GetConvertFromException(value);
        }

        /// <include file='doc\DataSourceConverter.uex' path='docs/doc[@for="DataSourceConverter.GetStandardValues"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the standard data sources accessible to the control.
        ///    </para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            object[] names = null;
            
            if (context != null) {
                ArrayList list = new ArrayList();

                IContainer cont = context.Container;
                if (cont != null) {
                    ComponentCollection objs = cont.Components;
                    
                    foreach (IComponent comp in (IEnumerable)objs) {
                        if (((comp is IEnumerable) || (comp is IListSource))
                            && !Marshal.IsComObject(comp)) {

                            PropertyDescriptor modifierProp = TypeDescriptor.GetProperties(comp)["Modifiers"];
                            if (modifierProp != null) {
                                MemberAttributes modifiers = (MemberAttributes)modifierProp.GetValue(comp);
                                if ((modifiers & MemberAttributes.AccessMask) == MemberAttributes.Private) {
                                    // must be declared as public or protected
                                    continue;
                                }
                            }

                            ISite site = comp.Site;
                            if (site != null) {
                                string name = site.Name;
                                if (name != null) {
                                    list.Add(name);
                                }
                            }
                        }
                    }
                }

                names = list.ToArray();
                Array.Sort(names, Comparer.Default);
            }
            return new StandardValuesCollection(names);
        }

        /// <include file='doc\DataSourceConverter.uex' path='docs/doc[@for="DataSourceConverter.GetStandardValuesExclusive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the collection of standard values returned from
        ///    <see cref='System.ComponentModel.TypeConverter.GetStandardValues'/> is an exclusive 
        ///       list of possible values, using the specified context.
        ///    </para>
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return false;
        }

        /// <include file='doc\DataSourceConverter.uex' path='docs/doc[@for="DataSourceConverter.GetStandardValuesSupported"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this object supports a standard set of values
        ///       that can be picked from a list.
        ///    </para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\ihtmlcontroldesignerbehavior.cs ===
//------------------------------------------------------------------------------
// <copyright file="IHtmlControlDesignerBehavior.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;

    /// <include file='doc\IHtmlControlDesignerBehavior.uex' path='docs/doc[@for="IHtmlControlDesignerBehavior"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface IHtmlControlDesignerBehavior {
        /// <include file='doc\IHtmlControlDesignerBehavior.uex' path='docs/doc[@for="IHtmlControlDesignerBehavior.Designer"]/*' />

        HtmlControlDesigner Designer {
            get;
            set;
        }
        /// <include file='doc\IHtmlControlDesignerBehavior.uex' path='docs/doc[@for="IHtmlControlDesignerBehavior.DesignTimeElement"]/*' />

        object DesignTimeElement {
            get;
        }
        /// <include file='doc\IHtmlControlDesignerBehavior.uex' path='docs/doc[@for="IHtmlControlDesignerBehavior.GetAttribute"]/*' />

        object GetAttribute(string attribute, bool ignoreCase);
        /// <include file='doc\IHtmlControlDesignerBehavior.uex' path='docs/doc[@for="IHtmlControlDesignerBehavior.RemoveAttribute"]/*' />

        void RemoveAttribute(string attribute, bool ignoreCase);
        /// <include file='doc\IHtmlControlDesignerBehavior.uex' path='docs/doc[@for="IHtmlControlDesignerBehavior.SetAttribute"]/*' />

        void SetAttribute(string attribute, object value, bool ignoreCase);
        /// <include file='doc\IHtmlControlDesignerBehavior.uex' path='docs/doc[@for="IHtmlControlDesignerBehavior.GetStyleAttribute"]/*' />

        object GetStyleAttribute(string attribute, bool designTimeOnly, bool ignoreCase);
        /// <include file='doc\IHtmlControlDesignerBehavior.uex' path='docs/doc[@for="IHtmlControlDesignerBehavior.RemoveStyleAttribute"]/*' />

        void RemoveStyleAttribute(string attribute, bool designTimeOnly, bool ignoreCase);
        /// <include file='doc\IHtmlControlDesignerBehavior.uex' path='docs/doc[@for="IHtmlControlDesignerBehavior.SetStyleAttribute"]/*' />

        void SetStyleAttribute(string attribute, bool designTimeOnly, object value, bool ignoreCase);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\htmlcontroldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlControlDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {
    using System.Design;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using Microsoft.Win32;
    using System.Web.UI;
    using System.Web.UI.WebControls;    
    using System.ComponentModel.Design;
    using System.Drawing;
    using System.Drawing.Design;
    using System.Windows.Forms;
    using WebUIControl = System.Web.UI.Control;
    using PropertyDescriptor = System.ComponentModel.PropertyDescriptor;

    /// <include file='doc\HtmlControlDesigner.uex' path='docs/doc[@for="HtmlControlDesigner"]/*' />
    /// <devdoc>
    ///    <para>Provides a base designer class for all server/ASP controls.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class HtmlControlDesigner : ComponentDesigner {

        private IHtmlControlDesignerBehavior behavior = null;           // the DHTML/Attached Behavior associated to this designer
        private bool shouldCodeSerialize;

        /// <include file='doc\HtmlControlDesigner.uex' path='docs/doc[@for="HtmlControlDesigner.HtmlControlDesigner"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initiailizes a new instance of <see cref='System.Web.UI.Design.HtmlControlDesigner'/>.
        ///    </para>
        /// </devdoc>
        public HtmlControlDesigner() {
            shouldCodeSerialize = true;
        }

        /// <include file='doc\HtmlControlDesigner.uex' path='docs/doc[@for="HtmlControlDesigner.DesignTimeElement"]/*' />
        /// <devdoc>
        ///   <para>The design-time object representing the control associated with this designer on the design surface.</para>
        /// </devdoc>
        protected object DesignTimeElement {
            get {
                return behavior != null ? behavior.DesignTimeElement : null;
            }
        }
        
        /// <include file='doc\HtmlControlDesigner.uex' path='docs/doc[@for="HtmlControlDesigner.Behavior"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Points to the DHTML Behavior that is associated to this designer instance.
        ///    </para>
        /// </devdoc>
        public IHtmlControlDesignerBehavior Behavior {
            get {
                return behavior;
            }
            set {
                if (behavior != value) {
                    
                    if (behavior != null) {
                        OnBehaviorDetaching();

                        // A different behavior might get attached in some cases. So, make sure to
                        // reset the back pointer from the currently associated behavior to this designer.
                        behavior.Designer = null;
                        behavior = null;
                    }
                    
                    if (value != null) {
                        behavior = value;
                        OnBehaviorAttached();
                    }
                }
            }
        }

        /// <include file='doc\HtmlControlDesigner.uex' path='docs/doc[@for="HtmlControlDesigner.DataBindings"]/*' />
        /// <devdoc>
        /// </devdoc>
        public DataBindingCollection DataBindings {
            get {
                return ((IDataBindingsAccessor)Component).DataBindings;
            }
        }

        /// <include file='doc\HtmlControlDesigner.uex' path='docs/doc[@for="HtmlControlDesigner.ShouldSerialize"]/*' />
        /// <devdoc>
        /// </devdoc>
        public virtual bool ShouldCodeSerialize {
            get {
                return shouldCodeSerialize;
            }
            set {
                shouldCodeSerialize = value;
            }
        }
        
        /// <include file='doc\HtmlControlDesigner.uex' path='docs/doc[@for="HtmlControlDesigner.Dispose"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Disposes of the resources (other than memory) used by
        ///       the <see cref='System.Web.UI.Design.HtmlControlDesigner'/>.
        ///    </para>
        /// </devdoc>
        protected override void Dispose(bool disposing) {
            if (disposing) {
                if (Behavior != null) {
                    Behavior.Designer = null;
                    Behavior = null;
                }
            }

            base.Dispose(disposing);
        }
        
#if DEBUG
        /// <include file='doc\HtmlControlDesigner.uex' path='docs/doc[@for="HtmlControlDesigner.Initialize"]/*' />
        /// <devdoc>
        ///    <para>Initializes
        ///       the designer and sets the component for design.</para>
        /// </devdoc>
        public override void Initialize(IComponent component) {
            Debug.Assert(component is WebUIControl, "HtmlControlDesigner::Initialize - Invalid Control-derived class");
            base.Initialize(component);
        }
#endif

        /// <include file='doc\HtmlControlDesigner.uex' path='docs/doc[@for="HtmlControlDesigner.OnBehaviorAttached"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Notification that is called when the designer is attached to the behavior.
        ///    </para>
        /// </devdoc>
        protected virtual void OnBehaviorAttached() {
        }

        /// <include file='doc\HtmlControlDesigner.uex' path='docs/doc[@for="HtmlControlDesigner.OnBehaviorDetaching"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Notification that is called when the designer is detached from the behavior.
        ///    </para>
        /// </devdoc>
        protected virtual void OnBehaviorDetaching() {
        }

        /// <include file='doc\HtmlControlDesigner.uex' path='docs/doc[@for="HtmlControlDesigner.OnSetParent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Notification that is called when the associated control is parented.
        ///    </para>
        /// </devdoc>
        public virtual void OnSetParent() {
        }

        /// <include file='doc\HtmlControlDesigner.uex' path='docs/doc[@for="HtmlControlDesigner.PreFilterEvents"]/*' />
        protected override void PreFilterEvents(IDictionary events) {
            base.PreFilterEvents(events);

            if (ShouldCodeSerialize == false) {
                // hide all the events, if this control isn't going to be serialized to code behind,

                ICollection eventCollection = events.Values;
                if ((eventCollection != null) && (eventCollection.Count != 0)) {
                    object[] eventDescriptors = new object[eventCollection.Count];
                    eventCollection.CopyTo(eventDescriptors, 0);

                    for (int i = 0; i < eventDescriptors.Length; i++) {
                        EventDescriptor eventDesc = (EventDescriptor)eventDescriptors[i];

                        eventDesc = TypeDescriptor.CreateEvent(eventDesc.ComponentType, eventDesc, BrowsableAttribute.No);
                        events[eventDesc.Name] = eventDesc;
                    }
                }
            }
        }

        /// <include file='doc\HtmlControlDesigner.uex' path='docs/doc[@for="HtmlControlDesigner.PreFilterProperties"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Allows a designer to filter the set of member attributes
        ///       that the component it is designing will expose through the <see cref='System.ComponentModel.TypeDescriptor'/>
        ///       object.
        ///    </para>
        /// </devdoc>
        protected override void PreFilterProperties(IDictionary properties) {
            base.PreFilterProperties(properties);
            
            PropertyDescriptor prop = (PropertyDescriptor)properties["Name"];
            if (prop != null) {
                properties["Name"] = TypeDescriptor.CreateProperty(prop.ComponentType, prop, BrowsableAttribute.No);
            }

            prop = (PropertyDescriptor)properties["Modifiers"];
            if (prop != null) {
                properties["Modifiers"] = TypeDescriptor.CreateProperty(prop.ComponentType, prop, BrowsableAttribute.No);
            }

            properties["DataBindings"] =
                TypeDescriptor.CreateProperty(this.GetType(), "DataBindings", typeof(DataBindingCollection),
                                              new Attribute[] {
                                                  DesignerSerializationVisibilityAttribute.Hidden,
                                                  CategoryAttribute.Data,
                                                  new EditorAttribute(typeof(DataBindingCollectionEditor), typeof(UITypeEditor)),
                                                  new TypeConverterAttribute(typeof(DataBindingCollectionConverter)),
                                                  new ParenthesizePropertyNameAttribute(true),
                                                  MergablePropertyAttribute.No,
                                                  new DescriptionAttribute(SR.GetString(SR.Control_DataBindings))
                                              });
        }
        
        /// <include file='doc\HtmlControlDesigner.uex' path='docs/doc[@for="HtmlControlDesigner.OnBindingsCollectionChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Delegate to handle bindings collection changed event.
        ///    </para>
        /// </devdoc>
        protected virtual void OnBindingsCollectionChanged(string propName) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\htmlintrinsiccontroldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="HtmlIntrinsicControlDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;

    /// <include file='doc\HtmlIntrinsicControlDesigner.uex' path='docs/doc[@for="HtmlIntrinsicControlDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides a base designer class for all intrinsic Html controls, i.e., controls deriving from
    ///       System.Web.UI.HtmlControls.HtmlControl.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class HtmlIntrinsicControlDesigner : HtmlControlDesigner {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\imageurleditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImageUrlEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {
    
    using System.Design;
    
    /// <include file='doc\ImageUrlEditor.uex' path='docs/doc[@for="ImageUrlEditor"]/*' />
    /// <devdoc>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ImageUrlEditor: UrlEditor {

        /// <include file='doc\ImageUrlEditor.uex' path='docs/doc[@for="ImageUrlEditor.Caption"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override string Caption {
            get {
                return SR.GetString(SR.UrlPicker_ImageCaption);
            }
        }

        /// <include file='doc\ImageUrlEditor.uex' path='docs/doc[@for="ImageUrlEditor.Filter"]/*' />
        /// <devdoc>
        /// </devdoc>
        protected override string Filter {
            get {
                return SR.GetString(SR.UrlPicker_ImageFilter);
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\idatasourceprovider.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDataSourceProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {
    using System;
    using System.Collections;

    /// <include file='doc\IDataSourceProvider.uex' path='docs/doc[@for="IDataSourceProvider"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface IDataSourceProvider {
        /// <include file='doc\IDataSourceProvider.uex' path='docs/doc[@for="IDataSourceProvider.GetSelectedDataSource"]/*' />

        object GetSelectedDataSource();
        /// <include file='doc\IDataSourceProvider.uex' path='docs/doc[@for="IDataSourceProvider.GetResolvedSelectedDataSource"]/*' />

        IEnumerable GetResolvedSelectedDataSource();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\designtimedata.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignTimeData.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.Design;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using System.Data;
    using System.Diagnostics;
    using System.Reflection;
    using System.Web.UI;

    /// <include file='doc\DesignTimeData.uex' path='docs/doc[@for="DesignTimeData"]/*' />
    /// <devdoc>
    ///  Helpers used by control designers to generate sample data
    ///  for use in design time databinding.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public sealed class DesignTimeData {

        /// <include file='doc\DesignTimeData.uex' path='docs/doc[@for="DesignTimeData.DataBindingHandler"]/*' />
        /// <internalonly/>
        public static readonly EventHandler DataBindingHandler = new EventHandler(GlobalDataBindingHandler.OnDataBind);

        /// <include file='doc\DesignTimeData.uex' path='docs/doc[@for="DesignTimeData.DesignTimeData"]/*' />
        /// <devdoc>
        /// </devdoc>
        private DesignTimeData() {
        }

        /// <include file='doc\DesignTimeData.uex' path='docs/doc[@for="DesignTimeData.CreateDummyDataTable"]/*' />
        /// <devdoc>
        ///  Creates a dummy datatable.
        /// </devdoc>
        public static DataTable CreateDummyDataTable() {
            DataTable dummyDataTable = new DataTable();

            DataColumnCollection columns = dummyDataTable.Columns;
            columns.Add("Column0", typeof(string));
            columns.Add("Column1", typeof(string));
            columns.Add("Column2", typeof(string));

            return dummyDataTable;
        }

        /// <include file='doc\DesignTimeData.uex' path='docs/doc[@for="DesignTimeData.CreateSampleDataTable"]/*' />
        /// <devdoc>
        ///   Creates a sample datatable with same schema as the supplied datasource.
        /// </devdoc>
        public static DataTable CreateSampleDataTable(IEnumerable referenceData) {
            DataTable sampleDataTable = new DataTable();
            DataColumnCollection columns = sampleDataTable.Columns;

            PropertyDescriptorCollection props = GetDataFields(referenceData);
            if (props != null) {
                foreach (PropertyDescriptor propDesc in props) {
                    Type propType = propDesc.PropertyType;

                    if ((propType.IsPrimitive == false) &&
                        (propType != typeof(DateTime)) &&
                        (propType != typeof(Decimal))) {
                        // we can't handle any remaining or custom types, so
                        // we'll have to create a column of type string in the 
                        // design time table.

                        // REVIEW: This may cause databinding errors
                        propType = typeof(string);
                    }

                    columns.Add(propDesc.Name, propType);
                }
            }

            if (columns.Count != 0) {
                return sampleDataTable;
            }
            else {
                return CreateDummyDataTable();
            }
        }

        /// <include file='doc\DesignTimeData.uex' path='docs/doc[@for="DesignTimeData.GetDataFields"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static PropertyDescriptorCollection GetDataFields(IEnumerable dataSource) {
            if (dataSource is ITypedList) {
                return ((ITypedList)dataSource).GetItemProperties(new PropertyDescriptor[0]);
            }

            Type dataSourceType = dataSource.GetType();
            PropertyInfo itemProp = dataSourceType.GetProperty("Item", BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static, null, null, new Type[] { typeof(int) }, null);

            if ((itemProp != null) && (itemProp.PropertyType != typeof(object))) {
                return TypeDescriptor.GetProperties(itemProp.PropertyType);
            }

            return null;
        }

        /// <include file='doc\DesignTimeData.uex' path='docs/doc[@for="DesignTimeData.GetDataMembers"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static string[] GetDataMembers(object dataSource) {
            IListSource listSource = dataSource as IListSource;

            if ((listSource != null) && listSource.ContainsListCollection) {
                IList memberList = ((IListSource)dataSource).GetList();
                Debug.Assert(memberList != null, "Got back null from IListSource");

                ITypedList typedList = memberList as ITypedList;
                if (typedList != null) {
                    PropertyDescriptorCollection props = typedList.GetItemProperties(new PropertyDescriptor[0]);

                    if (props != null) {
                        ArrayList members = new ArrayList(props.Count);

                        foreach (PropertyDescriptor pd in props) {
                            members.Add(pd.Name);
                        }

                        return (string[])members.ToArray(typeof(string));
                    }
                }
            }

            return null;
        }

        /// <include file='doc\DesignTimeData.uex' path='docs/doc[@for="DesignTimeData.GetDataMember"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static IEnumerable GetDataMember(IListSource dataSource, string dataMember) {
            IEnumerable list = null;

            IList memberList = dataSource.GetList();

            if ((memberList != null) && (memberList is ITypedList)) {
                if (dataSource.ContainsListCollection == false) {
                    Debug.Assert((dataMember == null) || (dataMember.Length == 0), "List does not contain data members");
                    if ((dataMember != null) && (dataMember.Length != 0)) {
                        throw new ArgumentException();
                    }
                    list = (IEnumerable)memberList;
                }
                else {
                    ITypedList typedMemberList = (ITypedList)memberList;

                    PropertyDescriptorCollection propDescs = typedMemberList.GetItemProperties(new PropertyDescriptor[0]);
                    if ((propDescs != null) && (propDescs.Count != 0)) {
                        PropertyDescriptor listProperty = null;

                        if ((dataMember == null) || (dataMember.Length == 0)) {
                            listProperty = propDescs[0];
                        }
                        else {
                            listProperty = propDescs.Find(dataMember, true);
                        }

                        if (listProperty != null) {
                            object listRow = memberList[0];
                            object listObject = listProperty.GetValue(listRow);

                            if ((listObject != null) && (listObject is IEnumerable)) {
                                list = (IEnumerable)listObject;
                            }
                        }
                    }
                }
            }

            return list;
        }
        
        /// <include file='doc\DesignTimeData.uex' path='docs/doc[@for="DesignTimeData.GetDesignTimeDataSource"]/*' />
        /// <devdoc>
        ///   Adds sample rows into the specified datatable, and returns a cursor on top of it.
        /// </devdoc>
        public static IEnumerable GetDesignTimeDataSource(DataTable dataTable, int minimumRows) {
            DataView dv = null;

            int rowCount = dataTable.Rows.Count;
            if (rowCount < minimumRows) {
                int rowsToAdd = minimumRows - rowCount;

                DataRowCollection rows = dataTable.Rows;
                DataColumnCollection columns = dataTable.Columns;
                int columnCount = columns.Count;
                DataRow[] rowsArray = new DataRow[rowsToAdd];

                // add the sample rows
                for (int i = 0; i < rowsToAdd; i++) {
                    DataRow row = dataTable.NewRow();
                    int rowIndex = rowCount + i;

                    for (int c = 0; c < columnCount; c++) {
                        Type dataType = columns[c].DataType;
                        Object obj = null;

                        if (dataType == typeof(String)) {
                            obj = SR.GetString(SR.Sample_Databound_Text_Alt);
                        }
                        else if ((dataType == typeof(Int32)) ||
                                 (dataType == typeof(Int16)) ||
                                 (dataType == typeof(Int64)) ||
                                 (dataType == typeof(UInt32)) ||
                                 (dataType == typeof(UInt16)) ||
                                 (dataType == typeof(UInt64))) {
                            obj = rowIndex;
                        }
                        else if ((dataType == typeof(Byte)) ||
                                 (dataType == typeof(SByte))) {
                            obj = (rowIndex % 2) != 0 ? 1 : 0;
                        }
                        else if (dataType == typeof(Boolean)) {
                            obj = (rowIndex % 2) != 0 ? true : false;
                        }
                        else if (dataType == typeof(DateTime)) {
                            obj = DateTime.Today;
                        }
                        else if ((dataType == typeof(Double)) ||
                                 (dataType == typeof(Single)) ||
                                 (dataType == typeof(Decimal))) {
                            obj = i / 10.0;
                        }
                        else if (dataType == typeof(Char)) {
                            obj = 'x';
                        }
                        else {
                            Debug.Assert(false, "Unexpected type of column in design time datatable.");
                            obj = System.DBNull.Value;
                        }

                        row[c] = obj;
                    }

                    rows.Add(row);
                }
            }

            // create a DataView on top of the effective design time datasource
            dv = new DataView(dataTable);
            return dv;
        }

        /// <include file='doc\DesignTimeData.uex' path='docs/doc[@for="DesignTimeData.GetSelectedDataSource"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static object GetSelectedDataSource(IComponent component, string dataSource) {
            object selectedDataSource = null;

            ISite componentSite = component.Site;
            if (componentSite != null) {
                IContainer container = (IContainer)componentSite.GetService(typeof(IContainer));

                if (container != null) {
                    IComponent comp = container.Components[dataSource];
                    if ((comp is IEnumerable) || (comp is IListSource)) {
                        selectedDataSource = comp;
                    }
                }
            }

            return selectedDataSource;
        }

        /// <include file='doc\DesignTimeData.uex' path='docs/doc[@for="DesignTimeData.GetSelectedDataSource1"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static IEnumerable GetSelectedDataSource(IComponent component, string dataSource, string dataMember) {
            IEnumerable selectedDataSource = null;

            object selectedDataSourceObject = DesignTimeData.GetSelectedDataSource(component, dataSource);
            if (selectedDataSourceObject != null) {
                IListSource listSource = selectedDataSourceObject as IListSource;
                if (listSource != null) {
                    if (listSource.ContainsListCollection == false) {
                        // the returned list is itself the list we want to bind to
                        selectedDataSource = (IEnumerable)listSource.GetList();
                    }
                    else {
                        selectedDataSource = GetDataMember(listSource, dataMember);
                    }
                }
                else {
                    Debug.Assert(selectedDataSourceObject is IEnumerable);
                    selectedDataSource = (IEnumerable)selectedDataSourceObject;
                }
            }

            return selectedDataSource;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\iusercontroldesignerbehavior.cs ===
//------------------------------------------------------------------------------
// <copyright file="IUserControlDesignerBehavior.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;

    /// <include file='doc\IUserControlDesignerBehavior.uex' path='docs/doc[@for="IControlDesignerBehavior"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface IControlDesignerBehavior {
        /// <include file='doc\IUserControlDesignerBehavior.uex' path='docs/doc[@for="IControlDesignerBehavior.DesignTimeElementView"]/*' />

        object DesignTimeElementView {
            get;
        }
        /// <include file='doc\IUserControlDesignerBehavior.uex' path='docs/doc[@for="IControlDesignerBehavior.DesignTimeHtml"]/*' />

        string DesignTimeHtml {
            get;
            set;
        }
        /// <include file='doc\IUserControlDesignerBehavior.uex' path='docs/doc[@for="IControlDesignerBehavior.OnTemplateModeChanged"]/*' />

        void OnTemplateModeChanged();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\itemplateeditingframe.cs ===
//------------------------------------------------------------------------------
// <copyright file="ITemplateEditingFrame.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.Web.UI.WebControls;

    /// <include file='doc\ITemplateEditingFrame.uex' path='docs/doc[@for="ITemplateEditingFrame"]/*' />
    public interface ITemplateEditingFrame : IDisposable {

        /// <include file='doc\ITemplateEditingFrame.uex' path='docs/doc[@for="ITemplateEditingFrame.ControlStyle"]/*' />
        Style ControlStyle { get; }

        /// <include file='doc\ITemplateEditingFrame.uex' path='docs/doc[@for="ITemplateEditingFrame.Name"]/*' />
        string Name { get; }

        /// <include file='doc\ITemplateEditingFrame.uex' path='docs/doc[@for="ITemplateEditingFrame.InitialHeight"]/*' />
        int InitialHeight { get; set; }

        /// <include file='doc\ITemplateEditingFrame.uex' path='docs/doc[@for="ITemplateEditingFrame.InitialWidth"]/*' />
        int InitialWidth { get; set; }

        /// <include file='doc\ITemplateEditingFrame.uex' path='docs/doc[@for="ITemplateEditingFrame.TemplateNames"]/*' />
        string[] TemplateNames { get; }

        /// <include file='doc\ITemplateEditingFrame.uex' path='docs/doc[@for="ITemplateEditingFrame.TemplateStyles"]/*' />
        Style[] TemplateStyles { get; }

        /// <include file='doc\ITemplateEditingFrame.uex' path='docs/doc[@for="ITemplateEditingFrame.Verb"]/*' />
        TemplateEditingVerb Verb { get; set; }

        /// <include file='doc\ITemplateEditingFrame.uex' path='docs/doc[@for="ITemplateEditingFrame.Close"]/*' />
        void Close(bool saveChanges);

        /// <include file='doc\ITemplateEditingFrame.uex' path='docs/doc[@for="ITemplateEditingFrame.Open"]/*' />
        void Open();

        /// <include file='doc\ITemplateEditingFrame.uex' path='docs/doc[@for="ITemplateEditingFrame.Resize"]/*' />
        void Resize(int width, int height);

        /// <include file='doc\ITemplateEditingFrame.uex' path='docs/doc[@for="ITemplateEditingFrame.Save"]/*' />
        void Save();

        /// <include file='doc\ITemplateEditingFrame.uex' path='docs/doc[@for="ITemplateEditingFrame.UpdateControlName"]/*' />
        void UpdateControlName(string newName);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\itemplateeditingservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="ITemplateEditingService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.Web.UI;
    using System.Web.UI.WebControls;

    /// <include file='doc\ITemplateEditingService.uex' path='docs/doc[@for="ITemplateEditingService"]/*' />
    public interface ITemplateEditingService {
        /// <include file='doc\ITemplateEditingService.uex' path='docs/doc[@for="ITemplateEditingService.SupportsNestedTemplateEditing"]/*' />

        bool SupportsNestedTemplateEditing { get; }

        /// <include file='doc\ITemplateEditingService.uex' path='docs/doc[@for="ITemplateEditingService.CreateFrame"]/*' />
        ITemplateEditingFrame CreateFrame(TemplatedControlDesigner designer, string frameName, string[] templateNames);

        /// <include file='doc\ITemplateEditingService.uex' path='docs/doc[@for="ITemplateEditingService.CreateFrame1"]/*' />
        ITemplateEditingFrame CreateFrame(TemplatedControlDesigner designer, string frameName, string[] templateNames, Style controlStyle, Style[] templateStyles);

        /// <include file='doc\ITemplateEditingService.uex' path='docs/doc[@for="ITemplateEditingService.GetContainingTemplateName"]/*' />
        string GetContainingTemplateName(Control control);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\iwebformsdocumentservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IWebFormsDocumentService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    
    /// <include file='doc\IWebFormsDocumentService.uex' path='docs/doc[@for="IWebFormsDocumentService"]/*' />
    /// <devdoc>
    /// </devdoc>
    public interface IWebFormsDocumentService {

        /// <include file='doc\IWebFormsDocumentService.uex' path='docs/doc[@for="IWebFormsDocumentService.DocumentUrl"]/*' />
        string DocumentUrl { get; }

        /// <include file='doc\IWebFormsDocumentService.uex' path='docs/doc[@for="IWebFormsDocumentService.IsLoading"]/*' />
        bool IsLoading { get; }

        /// <include file='doc\IWebFormsDocumentService.uex' path='docs/doc[@for="IWebFormsDocumentService.LoadComplete"]/*' />
        event EventHandler LoadComplete;

        /// <include file='doc\IWebFormsDocumentService.uex' path='docs/doc[@for="IWebFormsDocumentService.CreateDiscardableUndoUnit"]/*' />
        object CreateDiscardableUndoUnit();

        /// <include file='doc\IWebFormsDocumentService.uex' path='docs/doc[@for="IWebFormsDocumentService.DiscardUndoUnit"]/*' />
        void DiscardUndoUnit(object discardableUndoUnit);

        /// <include file='doc\IWebFormsDocumentService.uex' path='docs/doc[@for="IWebFormsDocumentService.EnableUndo"]/*' />
        void EnableUndo(bool enable);

        /// <include file='doc\IWebFormsDocumentService.uex' path='docs/doc[@for="IWebFormsDocumentService.UpdateSelection"]/*' />
        void UpdateSelection();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\readwritecontroldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="ReadWriteControlDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {
    using System.Design;
    using System.ComponentModel;

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;    
    using System.ComponentModel.Design;
    using System.Drawing;
    using System.Web.UI.WebControls;
    using System.Globalization;
    
    /// <include file='doc\ReadWriteControlDesigner.uex' path='docs/doc[@for="ReadWriteControlDesigner"]/*' />
    /// <devdoc>
    ///    <para>Provides a base designer class for all read-write server controls.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class ReadWriteControlDesigner : ControlDesigner {
        
        /// <include file='doc\ReadWriteControlDesigner.uex' path='docs/doc[@for="ReadWriteControlDesigner.ReadWriteControlDesigner"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes an instance of the <see cref='System.Web.UI.Design.ReadWriteControlDesigner'/> class.
        ///    </para>
        /// </devdoc>
        public ReadWriteControlDesigner() {
            ReadOnly = false;
        }
        
        /// <include file='doc\ReadWriteControlDesigner.uex' path='docs/doc[@for="ReadWriteControlDesigner.OnComponentChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Delegate to handle component changed event.
        ///    </para>
        /// </devdoc>
        public override void OnComponentChanged(object sender, ComponentChangedEventArgs ce) {
            // Delegate to the base class implementation first!
            base.OnComponentChanged(sender, ce);

            if (IsIgnoringComponentChanges) {
                return;
            }
            
            if (!IsWebControl || (DesignTimeElement == null)) {
                return;
            }
            
            MemberDescriptor member = ce.Member;
            object newValue = ce.NewValue;

            // HACK: you guys need to figure out a less hacky way then looking
            // for internal types...
            Type t = Type.GetType("System.ComponentModel.ReflectPropertyDescriptor, " + AssemblyRef.System);

            if (member != null && member.GetType() == t) {
                
                PropertyDescriptor propDesc = (PropertyDescriptor)member;
                
                if (member.Name.Equals("Font")) {
                    WebControl control = (WebControl)Component;

                    newValue = control.Font.Name;
                    MapPropertyToStyle("Font.Name", newValue);

                    newValue = control.Font.Size;
                    MapPropertyToStyle("Font.Size", newValue);

                    newValue = control.Font.Bold;
                    MapPropertyToStyle("Font.Bold", newValue);

                    newValue = control.Font.Italic;
                    MapPropertyToStyle("Font.Italic", newValue);

                    newValue = control.Font.Underline;
                    MapPropertyToStyle("Font.Underline", newValue);

                    newValue = control.Font.Strikeout;
                    MapPropertyToStyle("Font.Strikeout", newValue);

                    newValue = control.Font.Overline;
                    MapPropertyToStyle("Font.Overline", newValue);
                }
                else if (newValue != null) {
                    if (propDesc.PropertyType == typeof(Color)) {
                        newValue = System.Drawing.ColorTranslator.ToHtml((System.Drawing.Color)newValue);
                    }

                    MapPropertyToStyle(propDesc.Name, newValue);
                }
            }
        }

        /// <include file='doc\ReadWriteControlDesigner.uex' path='docs/doc[@for="ReadWriteControlDesigner.MapPropertyToStyle"]/*' />
        protected virtual void MapPropertyToStyle(string propName, object varPropValue) {
            if (Behavior == null)
                return;

            Debug.Assert(propName != null && propName.Length != 0, "Invalid property name passed in!");
            Debug.Assert(varPropValue != null, "Invalid property value passed in!");
            if (propName == null || varPropValue == null) {
                return;
            }
            
            try {
                if (propName.Equals("BackColor")) {
                    Behavior.SetStyleAttribute("backgroundColor", true /* designTimeOnly */, varPropValue, true /* ignoreCase */);
                }
                else if (propName.Equals("ForeColor")) {
                    Behavior.SetStyleAttribute("color", true, varPropValue, true);
                }
                else if (propName.Equals("BorderWidth")) {
                    string strPropValue = Convert.ToString(varPropValue);
                    Behavior.SetStyleAttribute("borderWidth", true, strPropValue, true);
                }
                else if (propName.Equals("BorderStyle")) {
                    string strPropValue;
                    if ((BorderStyle)varPropValue == BorderStyle.NotSet) {
                        strPropValue = String.Empty;
                    }
                    else {
                        strPropValue = Enum.Format(typeof(BorderStyle), (BorderStyle)varPropValue, "G");
                    }
                    Behavior.SetStyleAttribute("borderStyle", true, strPropValue, true);
                }
                else if (propName.Equals("BorderColor")) {
                    Behavior.SetStyleAttribute("borderColor", true, Convert.ToString(varPropValue), true);
                } 
                else if (propName.Equals("Height")) {
                    Behavior.SetStyleAttribute("height", true, Convert.ToString(varPropValue), true);
                }
                else if (propName.Equals("Width")) {
                    Behavior.SetStyleAttribute("width", true, Convert.ToString(varPropValue), true);
                }
                else if (propName.Equals("Font.Name")) {
                    Behavior.SetStyleAttribute("fontFamily", true, Convert.ToString(varPropValue), true);
                }
                else if (propName.Equals("Font.Size")) {
                    Behavior.SetStyleAttribute("fontSize", true, Convert.ToString(varPropValue), true);
                }
                else if (propName.Equals("Font.Bold")) {
                    string styleValue;
                    if ((bool)varPropValue) {
                        styleValue = "bold";
                    }
                    else {
                        styleValue = "normal";
                    }
                    Behavior.SetStyleAttribute("fontWeight", true, styleValue, true);
                }
                else if (propName.Equals("Font.Italic")) {
                    string styleValue;
                    if ((bool)varPropValue) {
                        styleValue = "italic";
                    }
                    else {
                        styleValue = "normal";
                    }
                    Behavior.SetStyleAttribute("fontStyle", true, styleValue, true);
                }
                else if (propName.Equals("Font.Underline")) {
                    string styleValue = (string)Behavior.GetStyleAttribute("textDecoration", true, true);
                    if ((bool)varPropValue) {
                        if (styleValue == null) {
                            styleValue = "underline";
                        }
                        else if (styleValue.ToLower(CultureInfo.InvariantCulture).IndexOf("underline") < 0) {
                            styleValue += " underline";
                        }
                        Behavior.SetStyleAttribute("textDecoration", true, styleValue, true);
                    }
                    else if (styleValue != null) {
                        int index = styleValue.ToLower(CultureInfo.InvariantCulture).IndexOf("underline");
                        if (index >= 0) {
                            string newStyleValue = styleValue.Substring(0, index);
                            if (index + 9 < styleValue.Length) {
                                newStyleValue = " " + styleValue.Substring(index + 9);
                            }

                            Behavior.SetStyleAttribute("textDecoration", true, newStyleValue, true);
                        }
                    }
                }
                else if (propName.Equals("Font.Strikeout")) {
                    string styleValue = (string)Behavior.GetStyleAttribute("textDecoration", true, true);
                    if ((bool)varPropValue) {
                        if (styleValue == null) {
                            styleValue = "line-through";
                        }
                        else if (styleValue.ToLower(CultureInfo.InvariantCulture).IndexOf("line-through") < 0) {
                            styleValue += " line-through";
                        }
                        Behavior.SetStyleAttribute("textDecoration", true, styleValue, true);
                    }
                    else if (styleValue != null) {
                        int index = styleValue.ToLower(CultureInfo.InvariantCulture).IndexOf("line-through");
                        if (index >= 0) {
                            string newStyleValue = styleValue.Substring(0, index);
                            if (index + 12 < styleValue.Length) {
                                newStyleValue = " " + styleValue.Substring(index + 12);
                            }

                            Behavior.SetStyleAttribute("textDecoration", true, newStyleValue, true);
                        }
                    }
                }
                else if (propName.Equals("Font.Overline")) {
                    string styleValue = (string)Behavior.GetStyleAttribute("textDecoration", true, true);
                    if ((bool)varPropValue) {
                        if (styleValue == null) {
                            styleValue = "overline";
                        }
                        else if (styleValue.ToLower(CultureInfo.InvariantCulture).IndexOf("overline") < 0) {
                            styleValue += " overline";
                        }
                        Behavior.SetStyleAttribute("textDecoration", true, styleValue, true);
                    }
                    else if (styleValue != null) {
                        int index = styleValue.ToLower(CultureInfo.InvariantCulture).IndexOf("overline");
                        if (index >= 0) {
                            string newStyleValue = styleValue.Substring(0, index);
                            if (index + 8 < styleValue.Length) {
                                newStyleValue = " " + styleValue.Substring(index + 8);
                            }

                            Behavior.SetStyleAttribute("textDecoration", true, newStyleValue, true);
                        }
                    }
                }
            }
            catch (Exception ex) {
                Debug.Fail(ex.ToString());
            }
        }
        
        /// <include file='doc\ReadWriteControlDesigner.uex' path='docs/doc[@for="ReadWriteControlDesigner.OnBehaviorAttached"]/*' />
        /// <devdoc>
        ///    Notification that is fired upon the designer being attached to the behavior.
        /// </devdoc>
        protected override void OnBehaviorAttached() {
            base.OnBehaviorAttached();

            if (!IsWebControl) {
                return;
            }
            
            WebControl control = (WebControl)Component;
            string colorValue;
                
            colorValue = System.Drawing.ColorTranslator.ToHtml((System.Drawing.Color)control.BackColor);
            if (colorValue.Length > 0) {
                MapPropertyToStyle("BackColor", colorValue);
            }
            
            colorValue = System.Drawing.ColorTranslator.ToHtml((System.Drawing.Color)control.ForeColor);
            if (colorValue.Length > 0) {
                MapPropertyToStyle("ForeColor", colorValue);
            }
            
            colorValue = System.Drawing.ColorTranslator.ToHtml((System.Drawing.Color)control.BorderColor);
            if (colorValue.Length > 0) {
                MapPropertyToStyle("BorderColor", colorValue);
            }
            
            BorderStyle borderStyle = control.BorderStyle;
            if (borderStyle != BorderStyle.NotSet) {
                MapPropertyToStyle("BorderStyle", borderStyle);
            }
            
            Unit borderWidth = control.BorderWidth;
            if (borderWidth.IsEmpty == false && borderWidth.Value != 0) {
                MapPropertyToStyle("BorderWidth", borderWidth.ToString());
            }
        
            Unit width = control.Width;
            if (!width.IsEmpty && width.Value != 0) {
                MapPropertyToStyle("Width", width.ToString());
            }
            
            Unit height = control.Height;
            if (!height.IsEmpty && height.Value != 0) {
                MapPropertyToStyle("Height", height.ToString());
            }

            string fontName = control.Font.Name;
            if (fontName.Length != 0) {
                MapPropertyToStyle("Font.Name", fontName);
            }

            FontUnit fontSize = control.Font.Size;
            if (fontSize != FontUnit.Empty) {
                MapPropertyToStyle("Font.Size", fontSize.ToString());
            }

            bool boolValue = control.Font.Bold;
            if (boolValue) {
                MapPropertyToStyle("Font.Bold", boolValue);
            }

            boolValue = control.Font.Italic;
            if (boolValue) {
                MapPropertyToStyle("Font.Italic", boolValue);
            }

            boolValue = control.Font.Underline;
            if (boolValue) {
                MapPropertyToStyle("Font.Underline", boolValue);
            }

            boolValue = control.Font.Strikeout;
            if (boolValue) {
                MapPropertyToStyle("Font.Strikeout", boolValue);
            }

            boolValue = control.Font.Overline;
            if (boolValue) {
                MapPropertyToStyle("Font.Overline", boolValue);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\iwebformsbuilderuiservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IWebFormsBuilderUIService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */

namespace System.Web.UI.Design {

    using System.Diagnostics;

    using System;
    using System.Windows.Forms;

    /// <include file='doc\IWebFormsUIBuilderService.uex' path='docs/doc[@for="IWebFormsBuilderUIService"]/*' />
    /// <devdoc>
    ///    <para> Provides functionality to control designers
    ///       that require launching of various builders such as the
    ///       HTML Color Picker and Url Picker.</para>
    /// </devdoc>
    public interface IWebFormsBuilderUIService {

        /// <include file='doc\IWebFormsUIBuilderService.uex' path='docs/doc[@for="IWebFormsBuilderUIService.BuildColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Launches the HTML Color Picker to allow the user to select a color.
        ///    </para>
        /// </devdoc>
        string BuildColor(Control owner, string initialColor);

        /// <include file='doc\IWebFormsUIBuilderService.uex' path='docs/doc[@for="IWebFormsBuilderUIService.BuildUrl"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Launches the Url Picker to allow the user to build a Url.
        ///    </para>
        /// </devdoc>
        string BuildUrl(Control owner, string initialUrl, string baseUrl, string caption, string filter, UrlBuilderOptions options);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\iwebformreferencemanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="IWebFormReferenceManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.Reflection;
    
    /// <include file='doc\IWebFormReferenceManager.uex' path='docs/doc[@for="IWebFormReferenceManager"]/*' />
    /// <devdoc>
    /// </devdoc>
    public interface IWebFormReferenceManager {

        /// <include file='doc\IWebFormReferenceManager.uex' path='docs/doc[@for="IWebFormReferenceManager.GetObjectType"]/*' />
        Type GetObjectType(string tagPrefix, string typeName);

        /// <include file='doc\IWebFormReferenceManager.uex' path='docs/doc[@for="IWebFormReferenceManager.GetTagPrefix"]/*' />
        string GetTagPrefix(Type objectType);

        /// <include file='doc\IWebFormReferenceManager.uex' path='docs/doc[@for="IWebFormReferenceManager.GetRegisterDirectives"]/*' />
        string GetRegisterDirectives();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\templateeditingservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="TemplateEditingService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Design;
    using System.Diagnostics;
    using System.Web.UI;
    using System.Web.UI.WebControls;

    /// <include file='doc\TemplateEditingService.uex' path='docs/doc[@for="TemplateEditingService"]/*' />
    /// <internalonly/>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public sealed class TemplateEditingService : ITemplateEditingService, IDisposable {

        private IDesignerHost designerHost;

        /// <include file='doc\TemplateEditingService.uex' path='docs/doc[@for="TemplateEditingService.TemplateEditingService"]/*' />
        public TemplateEditingService(IDesignerHost designerHost) {
            if (designerHost == null) {
                throw new ArgumentNullException("designerHost");
            }
            this.designerHost = designerHost;
        }

        /// <include file='doc\TemplateEditingService.uex' path='docs/doc[@for="TemplateEditingService.SupportsNestedTemplateEditing"]/*' />
        public bool SupportsNestedTemplateEditing {
            get {
                return false;
            }
        }

        /// <include file='doc\TemplateEditingService.uex' path='docs/doc[@for="TemplateEditingService.CreateTemplateEditingFrame"]/*' />
        public ITemplateEditingFrame CreateFrame(TemplatedControlDesigner designer, string frameName, string[] templateNames) {
            return CreateFrame(designer, frameName, templateNames, null, null);
        }

        /// <include file='doc\TemplateEditingService.uex' path='docs/doc[@for="TemplateEditingService.CreateTemplateEditingFrame1"]/*' />
        public ITemplateEditingFrame CreateFrame(TemplatedControlDesigner designer, string frameName, string[] templateNames, Style controlStyle, Style[] templateStyles) {
            if (designer == null) {
                throw new ArgumentNullException("designer");
            }
            if ((frameName == null) || (frameName.Length == 0)) {
                throw new ArgumentNullException("frameName");
            }
            if ((templateNames == null) || (templateNames.Length == 0)) {
                throw new ArgumentException("templateNames");
            }
            if ((templateStyles != null) && (templateStyles.Length != templateNames.Length)) {
                throw new ArgumentException("templateStyles");
            }

            frameName = CreateFrameName(frameName);

            return new TemplateEditingFrame(designer, frameName, templateNames, controlStyle, templateStyles);
        }

        private string CreateFrameName(string frameName) {
            Debug.Assert((frameName != null) && (frameName.Length != 0));

            // Strips out the ampersand typically used for menu mnemonics

            int index = frameName.IndexOf('&');
            if (index < 0) {
                return frameName;
            }
            else if (index == 0) {
                return frameName.Substring(index + 1);
            }
            else {
                return frameName.Substring(0, index) + frameName.Substring(index + 1);
            }
        }

        /// <include file='doc\TemplateEditingService.uex' path='docs/doc[@for="TemplateEditingService.Dispose"]/*' />
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\TemplateEditingService.uex' path='docs/doc[@for="TemplateEditingService.Finalize"]/*' />
        ~TemplateEditingService() {
            Dispose(false);
        }

        private void Dispose(bool disposing) {
            if (disposing) {
                designerHost = null;
            }
        }

        /// <include file='doc\TemplateEditingService.uex' path='docs/doc[@for="TemplateEditingService.GetContainingTemplateName"]/*' />
        public string GetContainingTemplateName(Control control) {
            string containingTemplateName = String.Empty;
            HtmlControlDesigner designer = (HtmlControlDesigner)designerHost.GetDesigner(control);

            if (designer != null) {
                IHtmlControlDesignerBehavior behavior = designer.Behavior;

                NativeMethods.IHTMLElement htmlElement = (NativeMethods.IHTMLElement)behavior.DesignTimeElement;
                if (htmlElement != null) {
                    object[] varTemplateName = new Object[1];
                    NativeMethods.IHTMLElement htmlelemParentNext;
                    NativeMethods.IHTMLElement htmlelemParentCur = htmlElement.GetParentElement();
                
                    while (htmlelemParentCur != null) {
                        htmlelemParentCur.GetAttribute("templatename", /*lFlags*/ 0, varTemplateName);
                    
                        if (varTemplateName[0] != null && varTemplateName[0].GetType() == typeof(string)) {
                            containingTemplateName = varTemplateName[0].ToString();
                            break;
                        }
                    
                        htmlelemParentNext = htmlelemParentCur.GetParentElement();
                        htmlelemParentCur = htmlelemParentNext;
                    }
                }
            }

            return containingTemplateName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\templateeditingverb.cs ===
//------------------------------------------------------------------------------
// <copyright file="TemplateEditingVerb.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.Diagnostics;
    using System.ComponentModel;
    using System.ComponentModel.Design;

    /// <include file='doc\TemplateEditingVerb.uex' path='docs/doc[@for="TemplateEditingVerb"]/*' />
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class TemplateEditingVerb : DesignerVerb, IDisposable {

        private ITemplateEditingFrame editingFrame;
        private int index;
        
        /// <include file='doc\TemplateEditingVerb.uex' path='docs/doc[@for="TemplateEditingVerb.TemplateEditingVerb"]/*' />
        public TemplateEditingVerb(string text, int index, TemplatedControlDesigner designer) : base(text, designer.TemplateEditingVerbHandler) {
            this.index = index;
        }

        internal ITemplateEditingFrame EditingFrame {
            get {
                return editingFrame;
            }
            set {
                editingFrame = value;
            }
        }

        /// <include file='doc\TemplateEditingVerb.uex' path='docs/doc[@for="TemplateEditingVerb.Index"]/*' />
        public int Index {
            get {
                return index;
            }
        }

        /// <include file='doc\TemplateEditingVerb.uex' path='docs/doc[@for="TemplateEditingVerb.Dispose"]/*' />
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\TemplateEditingVerb.uex' path='docs/doc[@for="TemplateEditingVerb.Finalize"]/*' />
        ~TemplateEditingVerb() {
            Dispose(false);
        }

        /// <include file='doc\TemplateEditingVerb.uex' path='docs/doc[@for="TemplateEditingVerb.Dispose2"]/*' />
        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                if (editingFrame != null) {
                    editingFrame.Dispose();
                    editingFrame = null;
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\textcontroldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextControlDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.IO;
    using System.Reflection;
    using System.Text;
    using System.Web.UI;

    /// <include file='doc\TextControlDesigner.uex' path='docs/doc[@for="TextControlDesigner"]/*' />
    /// <devdoc>
    ///    <para>
    ///       This designer can be used for controls which provide a Text property that
    ///       is persisted as inner text. An example of such as control is the
    ///       System.Web.UI.WebControls.Label class. This designer ensures that the
    ///       Text property is set to some default value to ensure design-time visibility
    ///       while preserving the children collection intact. It also ensures correct
    ///       persistence of inner contents in both scenarios: inner text and child controls.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class TextControlDesigner : ControlDesigner {

        private PropertyInfo textPropInfo;

        /// <include file='doc\TextControlDesigner.uex' path='docs/doc[@for="TextControlDesigner.Initialize"]/*' />
        public override void Initialize(IComponent component) {
            base.Initialize(component);

            textPropInfo = component.GetType().GetProperty("Text");
            if (textPropInfo == null) {
                throw new ArgumentException();
            }
        }

        /// <include file='doc\TextControlDesigner.uex' path='docs/doc[@for="TextControlDesigner.GetDesignTimeHtml"]/*' />
        public override string GetDesignTimeHtml() {
            Control control = (Control)Component;

            string originalText = (string)textPropInfo.GetValue(control, null);
            bool blank = (originalText == null) || (originalText.Length == 0);

            bool hasControls = control.HasControls();
            Control[] children = null;

            if (blank) {
                if (hasControls) {
                    children = new Control[control.Controls.Count];
                    control.Controls.CopyTo(children, 0);
                }
                textPropInfo.SetValue(control, "[" + control.ID + "]", null);
            }

            string html;
            try {
                html = base.GetDesignTimeHtml();
            }
            finally {
                if (blank) {
                    textPropInfo.SetValue(control, originalText, null);
                    if (hasControls) {
                        foreach (Control c in children) {
                            control.Controls.Add(c);
                        }
                    }
                }
            }

            return html;
        }

        /// <include file='doc\TextControlDesigner.uex' path='docs/doc[@for="TextControlDesigner.GetPersistInnerHtml"]/*' />
        public override string GetPersistInnerHtml() {
            if (!IsDirty) {
                return null;
            }

            Control control = (Control)Component;

            if (control.HasControls()) {
                bool oldVisible = control.Visible;
                string content = String.Empty;

                // Ensure the parent control is Visible, so the inner controls don't report Visible == false
                // because they walk up their parent chain to determine visibility.
                control.Visible = true;
                try {
                    IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
                    Debug.Assert(host != null, "Did not get a valid IDesignerHost reference");

                    StringWriter sw = new StringWriter();
                    foreach (Control c in control.Controls) {
                        ControlPersister.PersistControl(sw, c, host);
                    }
            
                    IsDirty = false;
                    content = sw.ToString();
                }
                finally {
                    // Restore the parent control's visibility
                    control.Visible = oldVisible;
                }
                return content;
            }
            else {
                return base.GetPersistInnerHtml();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\urlbuilder.cs ===
//------------------------------------------------------------------------------
// <copyright file="URLBuilder.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {
    using System.Runtime.Serialization.Formatters;
    using System.ComponentModel;

    using System.Diagnostics;

    using System;
    using System.Web.UI.Design;
    using Microsoft.Win32;

    /// <include file='doc\URLBuilder.uex' path='docs/doc[@for="UrlBuilder"]/*' />
    /// <devdoc>
    ///   Helper class used by designers to 'build' Url properties by
    ///   launching a Url picker.
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public sealed class UrlBuilder {

        private UrlBuilder() {
        }

        /// <include file='doc\URLBuilder.uex' path='docs/doc[@for="UrlBuilder.BuildUrl"]/*' />
        /// <devdoc>
        ///   Launches the Url Picker to build a color.
        /// </devdoc>
        public static string BuildUrl(IComponent component, System.Windows.Forms.Control owner, string initialUrl, string caption, string filter) {
            return BuildUrl(component, owner, initialUrl, caption, filter, UrlBuilderOptions.None);
        }

        /// <include file='doc\URLBuilder.uex' path='docs/doc[@for="UrlBuilder.BuildUrl2"]/*' />
        /// <devdoc>
        ///   Launches the Url Picker to build a color.
        /// </devdoc>
        public static string BuildUrl(IComponent component, System.Windows.Forms.Control owner, string initialUrl, string caption, string filter, UrlBuilderOptions options) {
            string baseUrl = String.Empty;
            string result = null;

            ISite componentSite = component.Site;
            Debug.Assert(componentSite != null, "Component does not have a valid site.");

            if (componentSite == null) {
                Debug.Fail("Component does not have a valid site.");   
                return null;
            }

            // Work out the base Url.
            IWebFormsDocumentService wfdServices = 
                (IWebFormsDocumentService)componentSite.GetService(typeof(IWebFormsDocumentService));
            if (wfdServices != null) {
                baseUrl = wfdServices.DocumentUrl;
            }

            IWebFormsBuilderUIService builderService = 
                        (IWebFormsBuilderUIService)componentSite.GetService(typeof(IWebFormsBuilderUIService));
            if (builderService != null) {
                result = builderService.BuildUrl(owner, initialUrl, baseUrl, caption, filter, options);
            }

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\textdatabindinghandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextDataBindingHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.Design;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Reflection;
    using System.Web.UI;

    /// <include file='doc\TextDataBindingHandler.uex' path='docs/doc[@for="TextDataBindingHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public class TextDataBindingHandler : DataBindingHandler {

        /// <include file='doc\TextDataBindingHandler.uex' path='docs/doc[@for="TextDataBindingHandler.DataBindControl"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void DataBindControl(IDesignerHost designerHost, Control control) {
            DataBinding textBinding = ((IDataBindingsAccessor)control).DataBindings["Text"];

            if (textBinding != null) {
                PropertyInfo textProperty = control.GetType().GetProperty("Text");
                Debug.Assert(textProperty != null, "Did not find Text property on control");

                if (textProperty != null) {
                    Debug.Assert(textProperty.PropertyType == typeof(string), "Can only handle Text properties of type string.");

                    if (textProperty.PropertyType == typeof(string)) {
                        textProperty.SetValue(control, SR.GetString(SR.Sample_Databound_Text), null);
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\templatedcontroldesigner.cs ===
//------------------------------------------------------------------------------
// <copyright file="TemplatedControlDesigner.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {
    
    using System.Design;
    using System.Diagnostics;

    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Web.UI;
    using System.Web.UI.Design;
    using System.ComponentModel.Design;

    /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner"]/*' />
    /// <devdoc>
    ///    <para>Provides a base class for all server control designers that are template-based.</para>
    /// </devdoc>
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    public abstract class TemplatedControlDesigner : ControlDesigner {

        private bool                    templateMode;                   // True when in template mode, and false otherwise.
        private bool                    enableTemplateEditing;          // True to enable template editing, and false otherwise.
        
        private EventHandler            templateVerbHandler;            // Verb handler for (entering) the various template frames offered.
        private ITemplateEditingFrame   activeTemplateFrame;            // Currently active template editing frame object (will be null when not in template mode).

        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.TemplatedControlDesigner"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.UI.Design.TemplatedControlDesigner'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public TemplatedControlDesigner() {
            enableTemplateEditing = true;
        }
        
        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.ActiveTemplateEditingFrame"]/*' />
        /// <devdoc>
        ///     The currently active template frame object (will be null when not in template mode).
        /// </devdoc>
        public ITemplateEditingFrame ActiveTemplateEditingFrame {
            get {
                return activeTemplateFrame;
            }
        }
        
        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.CanEnterTemplateMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Whether or not this designer will allow editing of templates.
        ///    </para>
        /// </devdoc>
        public bool CanEnterTemplateMode {
            get {
                return enableTemplateEditing;
            }
        }

        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.HidePropertiesInTemplateMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///      Whether or not the properties of the control will be hidden when the control
        ///      is placed into template editing mode. The 'ID' property is never hidden.
        ///      The default implementation returns 'true.'
        ///    </para>
        /// </devdoc>
        protected virtual bool HidePropertiesInTemplateMode {
            get {
                return true;
            }
        }

        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.InTemplateMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Whether or not the designer document is in template mode.
        ///    </para>
        /// </devdoc>
        public bool InTemplateMode {
            get {
                return templateMode;
            }
        }
        
        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.TemplateEditingVerbHandler"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Verb execution handler for opening the template frames and entering template mode.
        ///    </para>
        /// </devdoc>
        internal EventHandler TemplateEditingVerbHandler {
            get {
                return templateVerbHandler;
            }
        }

        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.CreateTemplateEditingFrame"]/*' />
        protected abstract ITemplateEditingFrame CreateTemplateEditingFrame(TemplateEditingVerb verb);
        
        private void EnableTemplateEditing(bool enable) {
            enableTemplateEditing = enable;
            // REVIEW (IbrahimM/NikhilKo): Should we update the design time HTML here?
        }
        
        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.EnterTemplateMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Opens a particular template frame object for editing in the designer.
        ///    </para>
        /// </devdoc>
        public void EnterTemplateMode(ITemplateEditingFrame newTemplateEditingFrame) {
            Debug.Assert(newTemplateEditingFrame != null, "New template frame passed in is null!");
            
            // Return immediately when trying to open (again) the currently active template frame.
            if (ActiveTemplateEditingFrame == newTemplateEditingFrame) {
                return;
            }

            Debug.Assert((Behavior == null) || (Behavior is IControlDesignerBehavior), "Invalid element behavior!");
            IControlDesignerBehavior behavior = (IControlDesignerBehavior)Behavior;
            
            IWebFormsDocumentService wfServices = (IWebFormsDocumentService)GetService(typeof(IWebFormsDocumentService));
            Debug.Assert(wfServices != null, "Did not get IWebFormsDocumentService");

            try {
                bool switchingTemplates = false;
                if (InTemplateMode) {
                    // This is the case of switching from template frame to another.
                    switchingTemplates = true;
                    ExitTemplateMode(switchingTemplates, /*fNested*/ false, /*fSave*/ true);
                }
                else {
                    // Clear the design time HTML when entering template mode from read-only/preview mode.
                    if (behavior != null) {
                        behavior.DesignTimeHtml = String.Empty;
                    }
                }
                
                // Hold onto the new template frame as the currently active template frame.
                this.activeTemplateFrame = newTemplateEditingFrame;
                
                // The designer is now in template editing mode.
                if (templateMode == false) {
                    SetTemplateMode(/*templateMode*/ true, switchingTemplates);
                }
                
                // Open the new template frame and make it visible.
                ActiveTemplateEditingFrame.Open();
                
                // Mark the designer as dirty when in template mode.
                IsDirty = true;
                
                // Invalidate the type descriptor so that proper filtering of properties
                // is done when entering template mode.
                TypeDescriptor.Refresh(Component);
            }
            catch (Exception) {
            }

            if (wfServices != null) {
                wfServices.UpdateSelection();
            }
        }
        
        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.ExitNestedTemplates"]/*' />
        /// <devdoc>
        ///     This method ensures that for a particular templated control designer when exiting
        ///     its template mode handles nested templates (if any). This is done by exiting the
        ///     inner most template frames first before exiting itself. Inside-Out Model.
        /// </devdoc>
        private void ExitNestedTemplates(bool fSave) {
            try {
                IComponent component = Component;
                IDesignerHost host = (IDesignerHost)component.Site.GetService(typeof(IDesignerHost));
                
                ControlCollection children = ((Control)component).Controls;
                for (int i = 0; i < children.Count; i++) {
                    IDesigner designer = host.GetDesigner((IComponent)children[i]);
                    if (designer is TemplatedControlDesigner) {
                        TemplatedControlDesigner innerDesigner = (TemplatedControlDesigner)designer;
                        if (innerDesigner.InTemplateMode) {
                            innerDesigner.ExitTemplateMode(/*fSwitchingTemplates*/ false, /*fNested*/ true, /*fSave*/ fSave);
                        }
                    }
                }
            }
            catch (Exception ex) {
                Debug.Fail(ex.ToString());
            }
        }
        
        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.ExitTemplateMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Closes the currently active template editing frame after saving any relevant changes.      
        ///    </para>
        /// </devdoc>
        public void ExitTemplateMode(bool fSwitchingTemplates, bool fNested, bool fSave) {
            Debug.Assert(ActiveTemplateEditingFrame != null, "Invalid current template frame!");
            
            try {
                IWebFormsDocumentService wfServices = (IWebFormsDocumentService)GetService(typeof(IWebFormsDocumentService));
                Debug.Assert(wfServices != null, "Did not get IWebFormsDocumentService");

                // First let the inner/nested designers handle exiting of their template mode.
                // Note: This has to be done inside-out in order to ensure that the changes
                // made in a particular template are saved before its immediate outer level
                // control designer saves its children.
                ExitNestedTemplates(fSave);
                
                // Save the current contents of all the templates within the active frame, and
                // close the frame by removing it from the tree.
                ActiveTemplateEditingFrame.Close(fSave);
                
                // Reset the pointer to the active template frame.
                // NOTE: Do not call activeTemplateFrame.Dispose here - we're in the process of exiting template mode
                //       and calling Dispose will attempt to exit template mode again. Calling dispose would also
                //       throw away the cached html tree, which we want to hang on for perf reasons.
                activeTemplateFrame = null;
                
                if (!fSwitchingTemplates) {
                    // No longer in template editing mode.
                    // This will fire the OnTemplateModeChanged notification
                    SetTemplateMode(false, fSwitchingTemplates);
                
                    // When not switching from one template frame to another and it is the
                    // outer most designer being switched out of template editing, then
                    // update its design-time html:

                    if (!fNested) {
                        UpdateDesignTimeHtml();
                        
                        // Invalidate the type descriptor so that proper filtering of properties
                        // is done when exiting template mode.
                        TypeDescriptor.Refresh(Component);
                        
                        if (wfServices != null) {
                            wfServices.UpdateSelection();
                        }
                    }
                }
            }
            catch (Exception) {
            }
        }

        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.GetCachedTemplateEditingVerbs"]/*' />
        protected abstract TemplateEditingVerb[] GetCachedTemplateEditingVerbs();
        
        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.GetPersistInnerHtml"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the HTML to be persisted for the content present within the associated server control runtime.
        ///    </para>
        /// </devdoc>
        public override string GetPersistInnerHtml() {
            // Save the currently active template editing frame when in template mode.
            if (InTemplateMode) {
                SaveActiveTemplateEditingFrame();
            }
            
            // Call the base implementation to do the actual persistence.
            string persistHTML = base.GetPersistInnerHtml();
            
            // REVIEW (IbrahimM): The designer is always dirty when in template mode.
            if (InTemplateMode) {
                IsDirty = true;
            }
            
            return persistHTML;
        }
        
        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.GetTemplateContainerDataItemProperty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the template's container's data item property.
        ///    </para>
        /// </devdoc>
        public virtual string GetTemplateContainerDataItemProperty(string templateName) {
            return String.Empty;
        }

        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.GetTemplateContainerDataSource"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the template's container's data source.
        ///    </para>
        /// </devdoc>
        public virtual IEnumerable GetTemplateContainerDataSource(string templateName) {
            return null;
        }
        
        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.GetTemplateContent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the template's content.
        ///    </para>
        /// </devdoc>
        public abstract string GetTemplateContent(ITemplateEditingFrame editingFrame, string templateName, out bool allowEditing);

        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.GetTemplateEditingVerbs"]/*' />
        public TemplateEditingVerb[] GetTemplateEditingVerbs() {
            if (templateVerbHandler == null) {
                ITemplateEditingService teService =
                    (ITemplateEditingService)GetService(typeof(ITemplateEditingService));
                Debug.Assert(teService != null, "Host that does not implement ITemplateEditingService is asking for template verbs");
                if (teService == null) {
                    return null;
                }

                templateVerbHandler = new EventHandler(this.OnTemplateEditingVerbInvoked);
            }
            TemplateEditingVerb[] templateVerbs = GetCachedTemplateEditingVerbs();
            
            if ((templateVerbs != null) && (templateVerbs.Length > 0)) {
                ITemplateEditingFrame activeTemplateFrame = ActiveTemplateEditingFrame;
                for (int i = 0; i < templateVerbs.Length; i++) {
                    templateVerbs[i].Checked = (activeTemplateFrame != null) &&
                                               (templateVerbs[i].EditingFrame == activeTemplateFrame);
                }
            }
            
            return templateVerbs;
        }

        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.GetTemplateFromText"]/*' />
        protected ITemplate GetTemplateFromText(string text) {
            return GetTemplateFromText(text, null);
        }

        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.GetTemplateFromText1"]/*' />
        /// <internalonly/>
        internal ITemplate GetTemplateFromText(string text, ITemplate currentTemplate) {
            if ((text == null) || (text.Length == 0)) {
                throw new ArgumentException("text");
            }
            IDesignerHost host = (IDesignerHost)Component.Site.GetService(typeof(IDesignerHost));
            Debug.Assert(host != null, "no IDesignerHost!");

            try {
                ITemplate newTemplate = ControlParser.ParseTemplate(host, text);
                if (newTemplate != null) {
                    return newTemplate;
                }
            }
            catch {
            }
            return currentTemplate;
        }
        
        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.GetTemplatePropertyParentType"]/*' />
        public virtual Type GetTemplatePropertyParentType(string templateName) {
            return Component.GetType();
        }

        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.GetTextFromTemplate"]/*' />
        protected string GetTextFromTemplate(ITemplate template) {
            if (template == null) {
                throw new ArgumentNullException("template");
            }

            Debug.Assert(template is TemplateBuilder, "Unexpected ITemplate implementation");
            if (template is TemplateBuilder) {
                return ((TemplateBuilder)template).Text;
            }
            return String.Empty;
        }
        
        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.OnTemplateEditingVerbInvoked"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Delegate to handle template verb invocation.
        ///    </para>
        /// </devdoc>
        private void OnTemplateEditingVerbInvoked(object sender, EventArgs e) {
            Debug.Assert(sender is TemplateEditingVerb, "Template verb execution is not sent by TemplateEditingVerb");
            TemplateEditingVerb verb = (TemplateEditingVerb)sender;

            if (verb.EditingFrame == null) {
                verb.EditingFrame = CreateTemplateEditingFrame(verb);
                Debug.Assert(verb.EditingFrame != null, "CreateTemplateEditingFrame returned null!");
            }

            if (verb.EditingFrame != null) {
                verb.EditingFrame.Verb = verb;
                EnterTemplateMode(verb.EditingFrame);
            }
        }
        
        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.OnBehaviorAttached"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Notification that is called when the behavior is attached to the designer.
        ///    </para>
        /// </devdoc>
        protected override void OnBehaviorAttached() {
            if (InTemplateMode) {
                // REVIEW (IbrahimM): Switching to HTML/Source view when in template mode.

                Debug.Assert(ActiveTemplateEditingFrame != null, "Valid template frame should be present when in template mode!");
                activeTemplateFrame.Close(false);
                templateMode = false;

                activeTemplateFrame.Dispose();
                activeTemplateFrame = null;

                // Refresh the type descriptor so the properties are up to date when switching views.
                TypeDescriptor.Refresh(Component);
            }

            // Call the base implementation.
            base.OnBehaviorAttached();
        }
        
        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.OnComponentChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Delegate to handle the component changed event.
        ///    </para>
        /// </devdoc>
        public override void OnComponentChanged(object sender, ComponentChangedEventArgs ce) {
            // Call the base class implementation first.
            base.OnComponentChanged(sender, ce);
            
            if (InTemplateMode) {
                if ((ce.Member != null) && (ce.NewValue != null) && ce.Member.Name.Equals("ID")) {
                    // If the ID property changes when in template mode, update it in the
                    // active template editing frame.

                    Debug.Assert(ActiveTemplateEditingFrame != null, "Valid template frame should be present when in template mode");
                    ActiveTemplateEditingFrame.UpdateControlName(ce.NewValue.ToString());
                }
            }
        }

        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.OnSetParent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Notification that is called when the associated control is parented.
        ///    </para>
        /// </devdoc>
        public override void OnSetParent() {
            Control control = (Control)Component;
            Debug.Assert(control.Parent != null, "Valid parent should be present!");
            
            bool enable = false;

            IDesignerHost host = (IDesignerHost)GetService(typeof(IDesignerHost));
            Debug.Assert(host != null);

            ITemplateEditingService teService = (ITemplateEditingService)host.GetService(typeof(ITemplateEditingService));
            if (teService != null) {
                enable = true;

                Control parent = control.Parent;
                Control page = control.Page;

                while ((parent != null) && (parent != page)) {
                    IDesigner designer = host.GetDesigner(parent);
                    TemplatedControlDesigner templatedDesigner = designer as TemplatedControlDesigner;
                    
                    if (templatedDesigner != null) {
                        enable = teService.SupportsNestedTemplateEditing;
                        break;
                    }

                    parent = parent.Parent;
                }
            }

            EnableTemplateEditing(enable);
        }

        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.OnTemplateModeChanged"]/*' />
        protected virtual void OnTemplateModeChanged() {
        }
        
        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.PreFilterProperties"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Allows a designer to filter the set of member attributes the component it is
        ///       designing will expose through the TypeDescriptor object.
        ///    </para>
        /// </devdoc>
        protected override void PreFilterProperties(IDictionary properties) {
            base.PreFilterProperties(properties);

            if (InTemplateMode && HidePropertiesInTemplateMode) {
                PropertyDescriptor prop;
                
                ICollection coll = properties.Values;
                if (coll != null) {
                    object[] values = new object[coll.Count];
                    coll.CopyTo(values, 0);
                    
                    for (int i = 0; i < values.Length; i++) {
                        prop = (PropertyDescriptor)values[i];
                        if (prop != null) {
                            properties[prop.Name] = TypeDescriptor.CreateProperty(prop.ComponentType, prop, BrowsableAttribute.No);
                        }
                    }
                }
                
                prop = (PropertyDescriptor)properties["ID"];
                if (prop != null) {
                    properties["ID"] = TypeDescriptor.CreateProperty(prop.ComponentType, prop, BrowsableAttribute.Yes);
                }
            }
        }
        
        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.SaveActiveTemplateEditingFrame"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Saves the active template frame.
        ///    </para>
        /// </devdoc>
        protected void SaveActiveTemplateEditingFrame() {
            Debug.Assert(InTemplateMode, "SaveActiveTemplate should be called only when in template mode");
            Debug.Assert(ActiveTemplateEditingFrame != null, "An active template frame should be present in SaveActiveTemplate");
            
            ActiveTemplateEditingFrame.Save();
        }
        
        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.SetTemplateContent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the template content to the specified content.
        ///    </para>
        /// </devdoc>
        public abstract void SetTemplateContent(ITemplateEditingFrame editingFrame, string templateName, string templateContent);

        private void SetTemplateMode(bool templateMode, bool switchingTemplates) {
            if (this.templateMode != templateMode) {
                // NOTE: This state has to be updated before notifying the associated behavior.
                this.templateMode = templateMode;

                if (!switchingTemplates && Behavior != null) {
                    ((IControlDesignerBehavior)Behavior).OnTemplateModeChanged();
                }
                OnTemplateModeChanged();
            }
        }
        
        /// <include file='doc\TemplatedControlDesigner.uex' path='docs/doc[@for="TemplatedControlDesigner.UpdateDesignTimeHtml"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Updates the design-time HTML.
        ///    </para>
        /// </devdoc>
        public override void UpdateDesignTimeHtml() {
            if (!InTemplateMode) {
                base.UpdateDesignTimeHtml();
            }

            // REVIEW: Should we assert in the else case?
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\urlbuilderoptions.cs ===
//------------------------------------------------------------------------------
// <copyright file="UrlBuilderOptions.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {
    
    /// <include file='doc\UrlEditorOptions.uex' path='docs/doc[@for="UrlBuilderOptions"]/*' />
    /// <devdoc>
    /// <para>Options for displaying the <see cref='System.Web.UI.Design.UrlEditor'/>.</para>
    /// </devdoc>
    [
        Flags,
    ]
    public enum UrlBuilderOptions {
        /// <include file='doc\UrlEditorOptions.uex' path='docs/doc[@for="UrlBuilderOptions.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       No options.
        ///    </para>
        /// </devdoc>
        None = 0x0000,
        /// <include file='doc\UrlEditorOptions.uex' path='docs/doc[@for="UrlBuilderOptions.NoAbsolute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Don't allow absulte urls.
        ///    </para>
        /// </devdoc>
        NoAbsolute = 0x0001,
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\designer\webforms\system\web\ui\design\templateeditingframe.cs ===
//------------------------------------------------------------------------------
// <copyright file="TemplateEditingFrame.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Web.UI.Design {

    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Design;
    using System.Diagnostics;
    using System.Drawing;
    using System.Runtime.InteropServices;
    using System.Text;
    using System.Web.UI.WebControls;
    using System.Globalization;
    
    /// <include file='doc\TemplateEditingFrame.uex' path='docs/doc[@for="TemplateEditingFrame"]/*' />
    [System.Security.Permissions.SecurityPermission(System.Security.Permissions.SecurityAction.Demand, Flags=System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode)]
    internal sealed class TemplateEditingFrame : ITemplateEditingFrame {

        // {0}: Control Type
        // {1}: Frame Name
        // {2}: Info icon
        // {3}: Info tooltip
        // {4}: Top-level frame style
        private const string TemplateFrameHeaderContent =
            @"<table cellspacing=0 cellpadding=0 border=0 style=""{4}"">
              <tr>
                <td>
                  <table cellspacing=0 cellpadding=2 border=0 width=100% height=100%>
                    <tr style=""background-color:buttonshadow"">
                      <td>
                        <table cellspacing=0 cellpadding=0 border=0 width=100% height=100%>
                          <tr>
                            <td valign=middle style=""font:messagebox;font-weight:bold;color:buttonhighlight"">&nbsp;<span id=""idControlName"">{0}</span> - <span id=""idFrameName"">{1}</span>&nbsp;&nbsp;&nbsp;</td>
                            <td align=right valign=middle>&nbsp;<img src=""{2}"" height=13 width=14 title=""{3}"">&nbsp;</td>
                          </tr>
                        </table>
                      </td>
                    </tr>
                  </table>
                </td>
              </tr>";
        private const string TemplateFrameFooterContent =
            @"</table>";
        private const string TemplateFrameSeparatorContent =
            @"<tr style=""height:1px""><td style=""font-size:0pt""></td></tr>";

        // {0}: Template Name
        // {1}: Control Style
        // {2}: Template Style
        private const string TemplateFrameTemplateContent =
            @"<tr>
                <td>
                  <table cellspacing=0 cellpadding=2 border=0 width=100% height=100% style=""border:solid 1px buttonface"">
                    <tr style=""font:messagebox;background-color:buttonface;color:buttonshadow"">
                      <td style=""border-bottom:solid 1px buttonshadow"">
                        &nbsp;{0}&nbsp;&nbsp;&nbsp;
                      </td>
                    </tr>
                    <tr style=""{1}"" height=100%>
                      <td style=""{2}"">
                        <div style=""width:100%;height:100%"" id=""{0}""></div>
                      </td>
                    </tr>
                  </table>
                </td>
              </tr>";

        private static readonly string TemplateInfoToolTip = SR.GetString(SR.TemplateEdit_Tip);
        private static readonly string TemplateInfoIcon = "res://" + typeof(TemplateEditingFrame).Module.FullyQualifiedName + "//TEMPLATE_TIP";


        private string                     frameName;               // Name of the template frame (will be used in the context menu)
        private string                     frameContent;            // Content of the template frame (this skeletal content will not change during its lifetime)
        private string[]                   templateNames;           // Names of the individual templates present within the content.
        private Style                      controlStyle;            // The style associated with the control (can be null)
        private Style[]                    templateStyles;          // The styles associated with the templates (can be null)
        private TemplateEditingVerb        verb;                    // The associated verb
        private int                        initialWidth;
        private int                        initialHeight;

        private NativeMethods.IHTMLElement htmlElemFrame;           // HTML element corresponding to the template frame that contains the content.
        private NativeMethods.IHTMLElement htmlElemContent;         // HTML element corresponding to the top-level content tag (viz., the first child of the above frame element).
        private NativeMethods.IHTMLElement htmlElemParent;          // Parent HTML element of the above frame element.
        private NativeMethods.IHTMLElement htmlElemControlName;     // HTML element that displays the control name (its presence in content is optional).
        
        private object[]                    templateElements;       // Array of HTML elements corresponding to the individual templates.
        
        private bool                        fVisible = false;       // True indicates that this frame is visible in the designer, and fals when hidden.
        private TemplatedControlDesigner    owner;                  // The owner templated control designer.
        
        /// <include file='doc\TemplateEditingFrame.uex' path='docs/doc[@for="TemplateEditingFrame.TemplateEditingFrame"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Web.UI.Design.TemplateEditingFrame'/> class.
        ///    </para>
        /// </devdoc>
        public TemplateEditingFrame(TemplatedControlDesigner owner, string frameName, string[] templateNames, Style controlStyle, Style[] templateStyles) {
            Debug.Assert(owner != null, "Null TemplatedControlDesigner as owner!");
            Debug.Assert(frameName != null && frameName.Length > 0, "Invalid template editing frame name!");
            Debug.Assert(templateNames != null && templateNames.Length > 0, "Invalid templates names!");            
            Debug.Assert(templateStyles == null || templateStyles.Length == templateNames.Length, "Invalid template styles");

            this.owner = owner;
            this.frameName = frameName;
            this.controlStyle = controlStyle;
            this.templateStyles = templateStyles;
            this.verb = null;

            // Clone the template names passed in since the owner might change those dynamically.
            this.templateNames = (string[])templateNames.Clone();
            
            if (owner.Behavior != null) {
                NativeMethods.IHTMLElement viewElement = (NativeMethods.IHTMLElement)((IControlDesignerBehavior)owner.Behavior).DesignTimeElementView;
                Debug.Assert(viewElement != null, "Invalid read-only HTML element associated to the control!");

                this.htmlElemParent = viewElement;
            }

            this.htmlElemControlName = null;
        }
        
        /// <include file='doc\TemplateEditingFrame.uex' path='docs/doc[@for="TemplateEditingFrame.Content"]/*' />
        /// <devdoc>
        ///    <para>
        ///       HTML content of the template editing frame (provided by the owner). Read-only property.
        ///    </para>
        /// </devdoc>
        private string Content {
            get {
                if (frameContent == null) {
                    frameContent = CreateFrameContent();
                }
                return frameContent;
            }
        }

        /// <include file='doc\TemplateEditingFrame.uex' path='docs/doc[@for="TemplateEditingFrame.ControlStyle"]/*' />
        public Style ControlStyle {
            get {
                return controlStyle;
            }
        }

        /// <include file='doc\TemplateEditingFrame.uex' path='docs/doc[@for="TemplateEditingFrame.Name"]/*