   return;
    }
    ptcfmt[0] = '\0';
    (void) WideCharToMultiByte(CP_ACP, 0, pwzfmt, -1, ptcfmt, convert, NULL, NULL);
#else
    LPTSTR ptcfmt = pwzfmt;
#endif

    if (m_flInfoLevel & DEB_TRACE)
    {
        va_list va;
        va_start (va, pwzfmt);
        ULONG cchIndent = _GetIndent();
        smprintf(DEB_TRACE, cchIndent, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
#ifndef UNICODE
    free(ptcfmt);
#endif
}

void __cdecl CDbg::DebugOut(ULONG fDebugMask, LPSTR pszfmt, ...)
{
#ifdef UNICODE
    ULONG convert = static_cast<ULONG>(strlen(pszfmt)) + 1;
    // NTRAID#NTBUG9-2002/05/17-623723-ericb: prefast
    PWSTR ptcfmt = (PWSTR)malloc(convert * sizeof(WCHAR));
    if (!ptcfmt)
    {
       OutputDebugString(TEXT("DebugOut: out of memory!"));
       return;
    }
    ptcfmt[0] = '\0';
    (void) MultiByteToWideChar(CP_ACP, 0, pszfmt, -1, ptcfmt, convert);
#else
    LPTSTR ptcfmt = pszfmt;
#endif

    va_list va;
    va_start (va, pszfmt);
    ULONG cchIndent = _GetIndent();
    smprintf(m_flOutputOptions | (m_flInfoLevel & fDebugMask)
             | (fDebugMask & DEB_NOCOMPNAME),
             cchIndent,
             m_InfoLevelString,
             ptcfmt,
             va);
    va_end(va);
#ifdef UNICODE
    free(ptcfmt);
#endif
}


void __cdecl CDbg::DebugOut(ULONG fDebugMask, PWSTR pwzfmt, ...)
{
#ifndef UNICODE
    int convert = wcslen(pwzfmt) + 1;
    // NTRAID#NTBUG9-2002/05/17-623723-ericb: prefast
    LPSTR ptcfmt = (LPSTR)malloc(convert * sizeof(CHAR));
    if (!ptcfmt)
    {
       OutputDebugString(TEXT("DebugOut: out of memory!"));
       return;
    }
    ptcfmt[0] = '\0';
    (void) WideCharToMultiByte(CP_ACP, 0, pwzfmt, -1, ptcfmt, convert, NULL, NULL);
#else
    LPTSTR ptcfmt = pwzfmt;
#endif

    va_list va;
    va_start (va, pwzfmt);
    ULONG cchIndent = _GetIndent();
    smprintf(m_flOutputOptions | (m_flInfoLevel & fDebugMask)
             | (fDebugMask & DEB_NOCOMPNAME),
             cchIndent,
             m_InfoLevelString,
             ptcfmt,
             va);
    va_end(va);
#ifndef UNICODE
    free(ptcfmt);
#endif
}

void CDbg::DebugErrorX(LPSTR  file, ULONG line, LONG err)
{
    if (m_flInfoLevel & DEB_ERROR)
    {
        file = AnsiPathFindFileName(file);

        this->DebugOut(DEB_ERROR, "error<0x%08x> %hs, l %u\n",
                                                      err, file, line);
    }
}

void CDbg::DebugErrorL(LPSTR  file, ULONG line, LONG err)
{
    if (m_flInfoLevel & DEB_ERROR)
    {
        file = AnsiPathFindFileName(file);

        this->DebugOut(DEB_ERROR, "error<%uL> %hs, l %u\n", err, file, line);
    }
}

void CDbg::DebugMsg(LPSTR  file, ULONG line, LPSTR  msg)
{
    file = AnsiPathFindFileName(file);

    this->DebugOut(DEB_FORCE, "asrt %hs, l %u, <%s>\n", file, line, msg);
}

void CDbg::DebugMsg(LPSTR  file, ULONG line, PWSTR  msg)
{
    file = AnsiPathFindFileName(file);

    this->DebugOut(DEB_FORCE, _T("asrt %hs, l %u, <%s>\n"), file, line, msg);
}

void CDbg::AssertEx(LPSTR pszFile, int iLine, LPTSTR pszMsg)
{
#if 0
    LPTSTR ptcMsg = NULL;

#ifdef UNICODE
    int convert = strlen(pszMsg) + 1;
    // NTRAID#NTBUG9-2002/05/17-623723-ericb: prefast
    ptcMsg = (PWSTR)malloc(convert * sizeof(WCHAR));
    if (!ptcMsg)
    {
       OutputDebugString(TEXT("AssertEx: out of memory!"));
       return;
    }
    ptcMsg[0] = '\0';
    (void) MultiByteToWideChar(CP_ACP, 0, pszMsg, -1, ptcMsg, convert);
#else
    ptcMsg = pszMsg;
#endif

    AdminAssertEx(pszFile, iLine, ptcMsg);
#ifdef UNICODE
    free(ptcMsg);
#endif
#endif //0

    AdminAssertEx(pszFile, iLine, pszMsg);

}


ULONG
CDbg::_GetIndent()
{
    ULONG cchIndent = 0;

    if (s_idxTls != 0xFFFFFFFF)
    {
        cchIndent = static_cast<ULONG>
                        (reinterpret_cast<ULONG_PTR>
                            (TlsGetValue(s_idxTls)));
    }
    return cchIndent;
}

void CDbg::IncIndent()
{
    if (s_idxTls != 0xFFFFFFFF)
    {
        ULONG_PTR cchIndent = reinterpret_cast<ULONG_PTR>(TlsGetValue(s_idxTls));
        cchIndent++;
        TlsSetValue(s_idxTls, reinterpret_cast<PVOID>(cchIndent));
    }
}

void CDbg::DecIndent()
{
    if (s_idxTls != 0xFFFFFFFF)
    {
        ULONG_PTR cchIndent = reinterpret_cast<ULONG_PTR>(TlsGetValue(s_idxTls));
        cchIndent--;
        TlsSetValue(s_idxTls, reinterpret_cast<PVOID>(cchIndent));
    }
}

#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\catsrc.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       catsrc.cxx
//
//  Contents:   Implementations of classes to read & cache the category
//              and sources strings of a log.
//
//  Classes:    CSources
//              CCategories
//
//  History:    1-05-1997   DavidMun   Created
//
//  Notes:      CAUTION: the CSources object is demand-initialized.  If you
//              add a method which accesses any members modified by
//              CSources::_Init(), you must check _fInitialized first.
//
//---------------------------------------------------------------------------

//
// Don't store multisz string read from registry as a blob.  instead, store
// each string as an entry in the string array.  that way sources that have
// been discovered in a saved or remote log can be returned seamlessly.
//
// Note the quality of CStringArray that once a string has been added and its
// pointer returned, that pointer is valid for the lifetime of the object,
// even if the array is expanded, is critical.
//
// Doing this will allow the light rec cache to store a source string pointer
// to source strings that were discovered in a saved or remote log.  This
// fixes a bug in els.
//
// It also allows the user to do find/filter on discovered sources, something
// which the legacy event viewer doesn't handle.
//






#include "headers.hxx"
#pragma hdrstop

DEBUG_DECLARE_INSTANCE_COUNTER(CSources)
DEBUG_DECLARE_INSTANCE_COUNTER(CSourceInfo)
DEBUG_DECLARE_INSTANCE_COUNTER(CCategories)


//===========================================================================
//
// CSources implementation
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CSources::CSources
//
//  Synopsis:   ctor
//
//  History:    1-05-1997   DavidMun   Created
//
//  Notes:      JonN 3/21/01 Note that _pwszServer and _pwszLogName are liable
//              to be bad pointers immediately after this constructor.
//              This constructor is called from the CLogInfo constructor,
//              which passes wszServer and wszLogName parameters as pointers
//              to member variables in CLogInfo which have not yet been
//              initialized.
//
//---------------------------------------------------------------------------

CSources::CSources(
    LPCWSTR wszServer,
    LPCWSTR wszLogName):
        _pwszServer(wszServer),
        _pwszLogName(wszLogName),
        _fInitialized(FALSE),
        _hrInitFailure(S_OK),
        _pSourceInfos(NULL),
        _psiPrimary(NULL)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CSources);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSources::~CSources
//
//  Synopsis:   Free all resources.
//
//  History:    1-05-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CSources::~CSources()
{
    Clear();
    DEBUG_DECREMENT_INSTANCE_COUNTER(CSources);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSources::Clear
//
//  Synopsis:   Return to the uninitialized state (the state this is in
//              just after the ctor returns.
//
//  History:    3-14-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSources::Clear()
{
    _saSources.Clear();

    CSourceInfo *psi = _pSourceInfos;

    while (psi)
    {
        CSourceInfo *pNext = psi->Next();

        psi->UnLink();
        delete psi;
        psi = pNext;
    }

    _pSourceInfos = NULL;
    _psiPrimary = NULL;
    _fInitialized = FALSE;
    _hrInitFailure = S_OK;
}

#if (DBG == 1)

VOID
CSources::Dump()
{
    Dbg(DEB_FORCE, "Dumping CSources(%x):\n", this);
    Dbg(DEB_FORCE, "  _fInitialized = %u\n", _fInitialized);
    Dbg(DEB_FORCE, "  _hrInitFailure = 0x%x\n", _hrInitFailure);
    Dbg(DEB_FORCE, "  _pwszServer = '%ws'\n", _pwszServer);
    Dbg(DEB_FORCE, "  _pwszLogName = '%ws'\n", _pwszLogName);
    Dbg(DEB_FORCE, "  _saSources:\n");
    _saSources.Dump();

    CSourceInfo *psi;

    for (psi = _pSourceInfos; psi; psi = psi->Next())
    {
        psi->Dump();
    }
}


VOID
CSourceInfo::Dump()
{
    Dbg(DEB_FORCE, "  CSourceInfo(%x)\n", this);
    Dbg(DEB_FORCE, "    _pwszName = '%ws'\n", _pwszName);
    Dbg(DEB_FORCE, "    _flTypesSupported = %u\n", _flTypesSupported);

    if (_pCategories)
    {
        _pCategories->Dump();
    }
    else
    {
        Dbg(DEB_FORCE, "    No categories for source '%ws'\n", _pwszName);
    }
}


VOID
CCategories::Dump()
{
    Dbg(DEB_FORCE, "  CCategories(%x)\n", this);

    for (ULONG i = 0; i < _cCategories; i++)
    {
        Dbg(DEB_FORCE, "    %ws\n", _apwszCategories[i]);
    }
}

#endif // (DBG == 1)

//+--------------------------------------------------------------------------
//
//  Member:     CSources::GetCategories
//
//  Synopsis:   Return the categories container object for source
//              [wszSource], or NULL if no categories are associated with
//              [wszSource].
//
//  Arguments:  [wszSource] - source for which to retrieve categories.
//
//  Returns:    Categories container or NULL.
//
//  History:    1-05-1997   DavidMun   Created
//
//  Notes:      If source [wszSource] defines categories, those will be
//              returned.  If it doesn't, but the log in which the source
//              resides has a default subkey which defines categories,
//              those categories are returned.
//
//---------------------------------------------------------------------------

CCategories *
CSources::GetCategories(LPCWSTR wszSource)
{
    CCategories *pCategories = NULL;

    do
    {
        if (!_fInitialized)
        {
            HRESULT hr;

            hr = _Init();
            BREAK_ON_FAIL_HRESULT(hr);
        }

        CSourceInfo *psi;

        psi = _FindSourceInfo(wszSource);

        if (!psi)
        {
            break;
        }

        pCategories = psi->GetCategories();

        if (!pCategories && _psiPrimary)
        {
            pCategories = _psiPrimary->GetCategories();
        }
    } while (0);

    return pCategories;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSources::GetCount
//
//  Synopsis:   Return the count of source strings.
//
//  History:    07-23-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

USHORT
CSources::GetCount()
{
    if (!_fInitialized)
    {
        HRESULT hr = _Init();

        if (FAILED(hr))
        {
            return 0;
        }
    }
    return (USHORT) _saSources.GetCount();
}



//+--------------------------------------------------------------------------
//
//  Member:     CSources::GetSourceHandle
//
//  Synopsis:   Return a "handle" to the source string [pwszSourceName].
//
//  Arguments:  [pwszSourceName] - source string to search for
//
//  Returns:    handle for GetSourceStrFromHandle, or 0 if name not found
//
//  History:    07-13-1997   DavidMun   Created
//
//  Notes:      Because the handle is a USHORT and 0 is reserved to indicate
//              an invalid value, the maximum number of sources per log is
//              64K - 1.
//
//              If [pwszSourceName] cannot be found in the source infos, a
//              new one will be created.
//
//---------------------------------------------------------------------------

USHORT
CSources::GetSourceHandle(
    LPCWSTR pwszSourceName)
{
    ASSERT(pwszSourceName && *pwszSourceName);

    if (!_fInitialized)
    {
        HRESULT hr = _Init();

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            return 0;
        }
    }

    return (USHORT) _saSources.Add(pwszSourceName);
}



//+--------------------------------------------------------------------------
//
//  Member:     GetSourceStrFromHandle
//
//  Synopsis:   Return the source string associated with [hSource]
//
//  Arguments:  [hSource] - 0 or valid handle.
//
//  Returns:    Source string, or L"" if [hSource] is invalid (0).
//
//  History:    07-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LPCWSTR
CSources::GetSourceStrFromHandle(
    USHORT hSource)
{
    if (!_fInitialized)
    {
        HRESULT hr = _Init();

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            return L"";
        }
    }

    return _saSources.GetStringFromIndex(hSource);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSources::GetPrimarySourceStr
//
//  Synopsis:   Return the name of the PrimaryModule, or NULL if there is
//              none.
//
//  Returns:    NULL or source name
//
//  History:    4-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LPCWSTR
CSources::GetPrimarySourceStr()
{
    if (!_fInitialized)
    {
        (void) _Init();
    }

    if (_psiPrimary)
    {
        return _psiPrimary->GetName();
    }
    return NULL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSources::GetTypesSupported
//
//  Synopsis:   Return a bitmask indicating the types supported by source
//              [wszSource].
//
//  Arguments:  [wszSource] - source for which to return data
//
//  Returns:    Types supported by source, or specified by primary, or
//              ALL_LOG_TYPE_BITS on error.
//
//  History:    4-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CSources::GetTypesSupported(LPCWSTR wszSource)
{
    ULONG flTypesSupported = ALL_LOG_TYPE_BITS;

    do
    {
        if (!_fInitialized)
        {
            HRESULT hr = _Init();
            BREAK_ON_FAIL_HRESULT(hr);
        }

        CSourceInfo *psi = _FindSourceInfo(wszSource);

        if (!psi)
        {
            break;
        }

        if (psi->GetTypesSupported())
        {
            flTypesSupported = psi->GetTypesSupported();
            break;
        }

        if (!_psiPrimary)
        {
            break;
        }

        if (_psiPrimary->GetTypesSupported())
        {
            flTypesSupported = _psiPrimary->GetTypesSupported();
        }
    } while (0);

    return flTypesSupported;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSources::_FindSourceInfo
//
//  Synopsis:   Return a pointer to the source info object for source
//              [pwszSource], or NULL if there is none.
//
//  Arguments:  [pwszSource] - source to search for
//
//  Returns:    Pointer to source info object for source named [pwszSource]
//              or NULL.
//
//  History:    1-05-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CSourceInfo *
CSources::_FindSourceInfo(LPCWSTR pwszSource)
{
    CSourceInfo *psi;

    for (psi = _pSourceInfos; psi; psi = psi->Next())
    {
        if (psi->IsSource(pwszSource))
        {
            return psi;
        }
    }
    return NULL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSources::_Init
//
//  Synopsis:   Build the data structures representing the sources and
//              categories defined by this log.
//
//  Returns:    HRESULT
//
//  History:    1-05-1997   DavidMun   Created
//              3-04-1997   DavidMun   Handle remote machine
//
//---------------------------------------------------------------------------

HRESULT
CSources::_Init()
{
    TRACE_METHOD(CSources, _Init);

    // JonN 12/6/01 482607
    // remember init failure and do not retry operation
    if (S_OK != _hrInitFailure)
        return _hrInitFailure;

    HRESULT  hr = S_OK;
    CSafeReg shkEventLog;
    CSafeReg shkLog;
    CSafeReg shkRemoteHKLM;
    WCHAR    wszPrimarySource[MAX_PATH + 1] = L"";
    WCHAR    wszRemoteSystemRoot[MAX_PATH] = L"";
    LPWSTR   pmwszSources = NULL;
    bool     fReadFromLocalRegistry = false;

    ASSERT(!_pSourceInfos);
    ASSERT(!_psiPrimary);

    do
    {
        if (*_pwszServer)
        {
            //
            // JonN 12/6/01 482607
            // If the attempt to open the remote source fails, we should
            // fall back on the local source.  The problem is that we need
            // _pwszServer to correspond to the actual source machine,
            // since CCategories::Init() uses it to call
            // ExpandSystemRootAndConvertToUnc.  Unfortunately, the
            // CLogInfo, CSources, CSourceInfo and CCategories objects
            // all contain pointers to the same buffer.  We break the chain
            // by passing L"" to CSourceInfo::Init() if the remote connect
            // fails.
            //

            hr = shkRemoteHKLM.Connect(_pwszServer, HKEY_LOCAL_MACHINE);
            if (SUCCEEDED(hr))
            {
                hr = shkEventLog.Open(shkRemoteHKLM, EVENTLOG_KEY, KEY_QUERY_VALUE);
                if (SUCCEEDED(hr))
                {
                    hr = GetRemoteSystemRoot(shkRemoteHKLM,
                                             wszRemoteSystemRoot,
                                             ARRAYLEN(wszRemoteSystemRoot));
                }
            }
            if (!SUCCEEDED(hr))
            {
                shkEventLog.Close();
                shkRemoteHKLM.Close();
            }
        }

        if (!*_pwszServer || !SUCCEEDED(hr))
        {
            fReadFromLocalRegistry = true;
            hr = shkEventLog.Open(HKEY_LOCAL_MACHINE,
                                  EVENTLOG_KEY,
                                  KEY_QUERY_VALUE);
        }
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkLog.Open(shkEventLog, _pwszLogName, KEY_QUERY_VALUE);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Allocate and fill the multi-sz string containing the sources for
        // this log.
        //

        ULONG cbData = 0;

        hr = shkLog.QueryBufSize(L"Sources", &cbData);
        BREAK_ON_FAIL_HRESULT(hr);

        ULONG cchSources = (cbData + sizeof(WCHAR)) / sizeof(WCHAR);
        pmwszSources = new WCHAR [cchSources];

        if (!pmwszSources)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        hr = shkLog.QueryStr(L"Sources", pmwszSources, cchSources);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Check for the optional primary source value
        //

        hr = shkLog.QueryStr(L"PrimaryModule",
                             wszPrimarySource,
                             ARRAYLEN(wszPrimarySource));

        if (FAILED(hr))
        {
            ASSERT(!*wszPrimarySource);
            hr = S_OK;
        }

        //
        // Now try and open each of the sources subkeys and create a
        // corresponding CSourceInfo object for it
        //

        LPWSTR pwszSource = pmwszSources;

        for (; *pwszSource; pwszSource += lstrlen(pwszSource) + 1)
        {
            CSafeReg shkSource;

            hr = shkSource.Open(shkLog, pwszSource, KEY_QUERY_VALUE);

            if (FAILED(hr))
            {
                Dbg(DEB_WARN,
                    "CSources::_Init warning: 0x%x opening reg key for source '%s'\n",
                    hr,
                    pwszSource);
                hr = S_OK;
                continue;
            }

            ULONG idxSourceStr = _saSources.Add(pwszSource);

            //
            // Note pmwszSource points into pmwszSources, which we'll
            // deallocate on exit.  Since the CSourceInfo needs a string
            // pointer which will be valid for its lifetime, give it a
            // pointer to the copy that the string array just made.
            //

            CSourceInfo *psiNew = new CSourceInfo(
                                    _saSources.GetStringFromIndex(idxSourceStr));

            if (!psiNew)
            {
                hr = E_OUTOFMEMORY;
                DBG_OUT_HRESULT(hr);
                break;
            }

            hr = psiNew->Init(shkSource,
                              // JonN 12/6/01 482607
                              (fReadFromLocalRegistry) ? L"" : _pwszServer,
                              wszRemoteSystemRoot);

            if (FAILED(hr))
            {
                delete psiNew;
                continue;
            }

            if (!_pSourceInfos)
            {
                _pSourceInfos = psiNew;
            }
            else
            {
                psiNew->LinkAfter(_pSourceInfos);
            }

            //
            // See if this is the primary key.
            //

            if (!_psiPrimary        &&
                *wszPrimarySource   &&
                !lstrcmpi(pwszSource, wszPrimarySource))
            {
                _psiPrimary = psiNew;
            }
        }

        BREAK_ON_FAIL_HRESULT(hr);
        _fInitialized = TRUE;
    } while (0);

    delete [] pmwszSources;

    if (FAILED(hr))
    {
        Clear();
    }

    // JonN 12/6/01 482607
    // remember init failure and do not retry operation
    _hrInitFailure = hr;

    return hr;
}



//===========================================================================
//
// CSourceInfo implementation
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CSourceInfo::CSourceInfo
//
//  Synopsis:   ctor
//
//  Arguments:  [pwszName] -
//
//  History:    4-21-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CSourceInfo::CSourceInfo(LPCWSTR pwszName):
    _pwszName(pwszName),
    _flTypesSupported(0),
    _pCategories(NULL)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CSourceInfo);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSourceInfo::~CSourceInfo
//
//  Synopsis:   dtor
//
//  History:    4-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CSourceInfo::~CSourceInfo()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CSourceInfo);
    delete _pCategories;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSourceInfo::Init
//
//  Synopsis:
//
//  Arguments:  [hkSource]            -
//              [wszServer]           -
//              [wszRemoteSystemRoot] -
//
//  Returns:    HRESULT
//
//  History:    4-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSourceInfo::Init(
    HKEY hkSource,
    LPCWSTR wszServer,
    LPCWSTR wszRemoteSystemRoot)
{
    HRESULT hr = S_OK;
    LONG    lr;
    ULONG   cbData = sizeof _flTypesSupported;

    do
    {
        //
        // Check for a TypesSupported value.  This is optional, so if it
        // is not found, represent it as 0.  Then filter will know to
        // ask for default subkey's TypesSupported.
        //

        lr = RegQueryValueEx(hkSource,
                             L"TypesSupported",
                             NULL,
                             NULL,
                             (LPBYTE) &_flTypesSupported,
                             &cbData);

        if (lr != ERROR_SUCCESS)
        {
            if (lr != ERROR_FILE_NOT_FOUND)
            {
                DBG_OUT_LRESULT(lr);
            }
            _flTypesSupported = 0;
        }

        //
        // Read the number of categories
        //

        ULONG cCategories;

        cbData = sizeof cCategories;

        lr = RegQueryValueEx(hkSource,
                             L"CategoryCount",
                             NULL,
                             NULL,
                             (LPBYTE) &cCategories,
                             &cbData);

        if (lr != ERROR_SUCCESS)
        {
            if (lr != ERROR_FILE_NOT_FOUND)
            {
                DBG_OUT_LRESULT(lr);
            }
            break;
        }

        if (!cCategories)
        {
            Dbg(DEB_WARN,
                "CSourceInfo::Init: Source '%s' has CategoryCount value of 0\n",
                _pwszName);
            break;
        }

        //
        // This source has categories, so create a category object.
        //

        _pCategories = new CCategories();

        if (!_pCategories)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        //
        // Ask the new category object to read the category strings from the
        // module specified by the CategoryMessageFile value on hkSource.
        //

        hr = _pCategories->Init(hkSource,
                                wszServer,
                                wszRemoteSystemRoot,
                                cCategories);

        if (FAILED(hr))
        {
            delete _pCategories;
            _pCategories = NULL;

            //
            // Reset the error to treat the sourceinfo for this source as one
            // that doesn't have categories.
            //

            hr = S_OK;
        }
    } while (0);

    return hr;
}



//===========================================================================
//
// CCategories implementation
//
//===========================================================================


//+--------------------------------------------------------------------------
//
//  Member:     CCategories::CCategories
//
//  Synopsis:   ctor
//
//  History:    1-05-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CCategories::CCategories():
        _cCategories(0),
        _apwszCategories(NULL)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CCategories);
}




//+--------------------------------------------------------------------------
//
//  Member:     CCategories::~CCategories
//
//  Synopsis:   dtor
//
//  History:    1-05-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CCategories::~CCategories()
{
    ULONG i;

    //
    // Free the category strings, which were allocated by FormatMessage
    //

    for (i = 0; i < _cCategories; i++)
    {
        LocalFree(_apwszCategories[i]);
    }

    // free the array of pointers to category strings

    delete [] _apwszCategories;

    // do not delete _pwszAssociatedSource, it is owned by CSources

    _apwszCategories = NULL;
    _cCategories = 0;
    DEBUG_DECREMENT_INSTANCE_COUNTER(CCategories);
}




//+--------------------------------------------------------------------------
//
//  Member:     CCategories::GetValue
//
//  Synopsis:   Convert from category name to category value.
//
//  Arguments:  [pwszCategoryName] - category name
//
//  Returns:    category value, or 0 if name not found.
//
//  History:    1-11-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

USHORT
CCategories::GetValue(LPCWSTR pwszCategoryName)
{
    ULONG i;

    for (i = 0; i < _cCategories; i++)
    {
        if (!lstrcmp(pwszCategoryName, _apwszCategories[i]))
        {
            return (USHORT) (i + 1);
        }
    }
    Dbg(DEB_ERROR,
        "CCategories(%x) GetValue: invalid category name '%s'\n",
        this,
        pwszCategoryName);
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CCategories::Init
//
//  Synopsis:   Read the [cCategories] category strings from the file
//              named by the CategoryMessageFile value of event log source
//              reg key [hkSource].
//
//  Arguments:  [hkSource]      - open reg key on an event log source
//              [wszServer]     - NULL or server name
//              [wszSystemRoot] - value for %SystemRoot% if [pwszServer] is
//                                  not NULL.
//              [cCategories]   - key's CategoryCount value
//
//  Returns:    HRESULT
//
//  History:    1-05-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CCategories::Init(
        HKEY hkSource,
        LPCWSTR wszServer,
        LPCWSTR wszSystemRoot,
        ULONG cCategories)
{
    HRESULT     hr = S_OK;
    HINSTANCE   hinstCategoryMsgFile = NULL;
    LONG        lr;

    ASSERT(!_apwszCategories);

    do
    {
        _apwszCategories = new LPWSTR [cCategories];

        if (!_apwszCategories)
        {
            DBG_OUT_HRESULT(E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }

        ZeroMemory(_apwszCategories, sizeof(LPWSTR) * cCategories);

        DWORD dwType;
        WCHAR wszCatMsgFileUnexpanded[MAX_PATH + 1];
        DWORD cbCatMsgFileUnexpanded = sizeof(wszCatMsgFileUnexpanded);

        lr = RegQueryValueEx(hkSource,
                             L"CategoryMessageFile",
                             NULL,
                             &dwType,
                             (LPBYTE) wszCatMsgFileUnexpanded,
                             &cbCatMsgFileUnexpanded);
        if (lr != ERROR_SUCCESS)
        {
            DBG_OUT_LRESULT(lr);
            hr = HRESULT_FROM_WIN32(lr);
            break;
        }

        ASSERT(dwType == REG_EXPAND_SZ || dwType == REG_SZ);

        //
        // Expand the filename
        //

        WCHAR wszCatMsgFile[MAX_PATH + 1];

        if (*wszServer)
        {
            lstrcpy(wszCatMsgFile, wszCatMsgFileUnexpanded);
            hr = ExpandSystemRootAndConvertToUnc(wszCatMsgFile,
                                                 ARRAYLEN(wszCatMsgFile),
                                                 wszServer,
                                                 wszSystemRoot);
        }
        else
        {
            BOOL fOk;

            fOk = ExpandEnvironmentStrings(wszCatMsgFileUnexpanded,
                                           wszCatMsgFile,
                                           ARRAYLEN(wszCatMsgFile));
            if (!fOk)
            {
                hr = HRESULT_FROM_LASTERROR;
                DBG_OUT_LASTERROR;
            }
        }
        BREAK_ON_FAIL_HRESULT(hr);

        hinstCategoryMsgFile = LoadLibraryEx(wszCatMsgFile,
                                             NULL,
                                             DONT_RESOLVE_DLL_REFERENCES |
                                              LOAD_LIBRARY_AS_DATAFILE);

        if (!hinstCategoryMsgFile)
        {
            hr = HRESULT_FROM_LASTERROR;
            Dbg(DEB_ERROR,
                "CCategories::Init: LoadLibraryEx('%s') err %uL\n",
                wszCatMsgFile,
                GetLastError());
            break;
        }

        //
        // Retrieve all the category strings from the source's category
        // string file.
        //

        ULONG i;
        for (i = 0; i < cCategories; i++)
        {
            lr = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER   |
                                 FORMAT_MESSAGE_FROM_HMODULE    |
                                 FORMAT_MESSAGE_IGNORE_INSERTS  |
                                 FORMAT_MESSAGE_MAX_WIDTH_MASK,
                               (LPCVOID) hinstCategoryMsgFile,
                               i + 1, // categories are 1-based
                               0,
                               (LPWSTR) &_apwszCategories[i],
                               1,
                               NULL);

            if (!lr)
            {
               Dbg(DEB_ERROR,
                   "CCategories::Init: looking for %u strings from %s,"
                   " only got %u (error %ul)\n",
                   cCategories,
                   wszCatMsgFile,
                   i,   // not i+1: the last iteration was last successful
                   GetLastError());
                break;
            }
        }

        //
        // Record the number of categories successfully read
        //

        _cCategories = i;
    } while (0);

    if (hinstCategoryMsgFile && !FreeLibrary(hinstCategoryMsgFile))
    {
        DBG_OUT_LASTERROR;
    }

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CCategories::GetName
//
//  Synopsis:   Return category string [ulCat], a 1-based index.
//
//  History:    1-05-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LPCWSTR
CCategories::GetName(ULONG ulCat)
{
//    ASSERT(ulCat && ulCat <= _cCategories);

   if (ulCat > _cCategories)
   {
      //Dbg(DEB_ERROR, "CCategories::GetName: category %u is unnamed.\n", ulCat);

      static WCHAR wszLastReturnedString[64];
      wnsprintf(wszLastReturnedString, ARRAYLEN(wszLastReturnedString), L"(%u)", ulCat);
      return wszLastReturnedString;
   }

    return _apwszCategories[ulCat - 1];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\cdlink.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       cdlink.cxx
//
//  Contents:
//
//  Classes:    CDlink
//
//  History:    16-Oct-91  KevinRo Created
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+-------------------------------------------------------------------------
//
// Member:      CDLink::LinkAfter
//
// Purpose:     Links this after dlPrev and before dlPrev->_dlNext
//
// Returns:     this
//
// Note:        None.
//
//--------------------------------------------------------------------------
VOID CDLink::LinkAfter(CDLink * dlPrev)
{
    _dlPrev = dlPrev;

    if(dlPrev != NULL)
    {
        _dlNext = dlPrev->_dlNext;
        dlPrev->_dlNext = this;

        if(_dlNext != NULL) {
            _dlNext->_dlPrev = this;
        }
    }
    else
    {
        _dlNext = NULL;
    }
}
//+-------------------------------------------------------------------------
//
// Member:      CDLink::LinkBefore
//
// Purpose:     Links this Before dlNext and after dlNext->_dlPrev
//
// Returns:     this
//
//--------------------------------------------------------------------------
VOID CDLink::LinkBefore(CDLink * dlNext)
{
    _dlNext = dlNext;

    if(dlNext != NULL)
    {
        _dlPrev = dlNext->_dlPrev;

        dlNext->_dlPrev = this;

        if(_dlPrev != NULL) {
            _dlPrev->_dlNext = this;
        }
    }
    else
    {
        _dlPrev = NULL;
    }
}

//+-------------------------------------------------------------------------
//
// Member:      CDLink::Unlink()
//
// Purpose:     Removes this from double linked list
//
// Returns:     this
//
//--------------------------------------------------------------------------
VOID CDLink::UnLink()
{
    if(_dlNext != NULL) {
        _dlNext->_dlPrev = _dlPrev;
    }
    if(_dlPrev != NULL) {
        _dlPrev->_dlNext = _dlNext;
    }
    _dlNext = _dlPrev = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\choosert.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by chooser.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\chooserd.h ===
// chooserd.h - Contains default resource IDs for chooser.rc
//
// HISTORY
// 26-May-1997	t-danm		Creation.
//

//
// The _CHOOSER_BASE_RESOURCE_ID is there to allow relocatable resource IDs
//
#ifndef _CHOOSER_BASE_RESOURCE_ID
	#define _CHOOSER_BASE_RESOURCE_ID	970	// Arbitrary chosen
#endif

// Proppage ID
#ifndef IDD_PROPPAGE_CHOOSE_MACHINE
	#define IDD_PROPPAGE_CHOOSE_MACHINE 		970
#endif

// Dialog ID
#ifndef IDD_DIALOG_CHOOSE_MACHINE
	#define IDD_DIALOG_CHOOSE_MACHINE 		971
#endif

// Dialog Controls
#ifndef IDC_CHOOSER_STATIC
	#define IDC_CHOOSER_STATIC						(_CHOOSER_BASE_RESOURCE_ID+0)
	#define IDC_CHOOSER_GROUP_TARGET_MACHINE		(_CHOOSER_BASE_RESOURCE_ID+1)
	#define IDC_CHOOSER_RADIO_LOCAL_MACHINE			(_CHOOSER_BASE_RESOURCE_ID+2)
	#define IDC_CHOOSER_RADIO_SPECIFIC_MACHINE		(_CHOOSER_BASE_RESOURCE_ID+3)
	#define IDC_CHOOSER_EDIT_MACHINE_NAME			(_CHOOSER_BASE_RESOURCE_ID+4)
	#define IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES	(_CHOOSER_BASE_RESOURCE_ID+5)
	#define IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME (_CHOOSER_BASE_RESOURCE_ID+6)
#endif

// Strings
#ifndef IDS_CHOOSER_INVALID_COMPUTERNAME
	#define IDS_CHOOSER_INVALID_COMPUTERNAME		(_CHOOSER_BASE_RESOURCE_ID+0)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\chooser.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       chooser.cxx
//
//  Contents:   Implementation of Machine Chooser dialog class
//
//  Classes:    CChooserDlg
//
//  History:    11-16-1998   JonN       Copied from wizard.cxx
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop
#include "chooser.hxx" // CChooserDlg

DEBUG_DECLARE_INSTANCE_COUNTER(CChooserDlg)

extern UINT g_cfDsObjectPicker; // from wizard.cxx

static ULONG
s_aulHelpIds[] =
{
    IDC_CHOOSER_STATIC,                      HCHOOSER_STATIC,
    IDC_CHOOSER_GROUP_TARGET_MACHINE,        HCHOOSER_GROUP_TARGET_MACHINE,
    IDC_CHOOSER_RADIO_LOCAL_MACHINE,         HCHOOSER_RADIO_LOCAL_MACHINE,
    IDC_CHOOSER_RADIO_SPECIFIC_MACHINE,      HCHOOSER_RADIO_SPECIFIC_MACHINE,
    IDC_CHOOSER_EDIT_MACHINE_NAME,           HCHOOSER_EDIT_MACHINE_NAME,
    IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES,  HCHOOSER_BUTTON_BROWSE_MACHINENAMES,
    IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME, HCHOOSER_CHECK_OVERRIDE_MACHINE_NAME,
    0,0
};

struct SObjectPickerResult
{
    wstring wstrNetBIOS;
    wstring wstrDNS;
};


//+--------------------------------------------------------------------------
//
//  Member:     CChooserDlg::CChooserDlg
//
//  Synopsis:   ctor
//
//  Arguments:  [pcd] - parent componentdata
//              [hsi] - scope node from which the dlg is invoked
//              [pDataObject] - pDataObject the dlg is associated with
//
//  History:    11-16-1998   JonN       Copied from wizard.cxx
//
//---------------------------------------------------------------------------

CChooserDlg::CChooserDlg(
    CComponentData *pcd,
    HSCOPEITEM      hsi,
    LPDATAOBJECT    pDataObject) :
        _pcd(pcd),
        _hsi(hsi),
        _pDataObject(pDataObject),
        _fChangeFocusFailed(FALSE)
{
    TRACE_CONSTRUCTOR(CChooserDlg);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CChooserDlg);
    ASSERT(pcd);

    // save current focus in case switching fails

    PCWSTR pwzCurFocus = _pcd->GetCurrentFocus();

    lstrcpyn(_wszInitialFocus,
             pwzCurFocus ? pwzCurFocus : L"",
             ARRAYLEN(_wszInitialFocus));
}



//+--------------------------------------------------------------------------
//
//  Member:     CChooserDlg::~CChooserDlg
//
//  Synopsis:   dtor
//
//  History:    11-16-1998   JonN       Copied from wizard.cxx
//
//---------------------------------------------------------------------------

CChooserDlg::~CChooserDlg()
{
    TRACE_DESTRUCTOR(CChooserDlg);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CChooserDlg);
}



void
CChooserDlg::OnChooseTargetMachine(
    CComponentData *pcd,
    HSCOPEITEM      hsi,
    LPDATAOBJECT    pDataObject)
{
    CChooserDlg dlg(pcd, hsi, pDataObject);
    HWND hwndMmcFrame = NULL;

#if (DBG == 1)
    HRESULT hr =
#endif // (DBG == 1)
        pcd->GetConsole()->GetMainWindow(&hwndMmcFrame);
    CHECK_HRESULT(hr);
    dlg._DoModalDlg(hwndMmcFrame, IDD_DIALOG_CHOOSE_MACHINE);
}




VOID
CChooserDlg::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    InvokeWinHelp(message, wParam, lParam, HELP_FILENAME, s_aulHelpIds);
}




//+--------------------------------------------------------------------------
//
//  Member:     CChooserDlg::_OnInit
//
//  Synopsis:   Handle property page dialog initialization.
//
//  Arguments:  [pfSetFocus] - set to FALSE to prevent system from setting
//                              focus
//
//  History:    11-16-1998   JonN       Copied from wizard.cxx
//
//---------------------------------------------------------------------------

HRESULT
CChooserDlg::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CChooserDlg, _OnInit);

    //
    // Default to remote machine
    //

    Button_SetCheck(_hCtrl(IDC_CHOOSER_RADIO_SPECIFIC_MACHINE), BST_CHECKED);
    SetFocus(_hCtrl(IDC_CHOOSER_EDIT_MACHINE_NAME));

    //
    // Prevent user from entering more than machine name chars, allowing
    // +2 chars for leading backslashes
    //

    Edit_LimitText(_hCtrl(IDC_CHOOSER_EDIT_MACHINE_NAME), CCH_COMPUTER_MAX + 2);

    *pfSetFocus = FALSE;
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CChooserDlg::_OnSetActive
//
//  Synopsis:   Handle notification that this page is being activated.
//
//  History:    11-16-1998   JonN       Copied from wizard.cxx
//
//---------------------------------------------------------------------------

ULONG
CChooserDlg::_OnSetActive()
{
    TRACE_METHOD(CChooserDlg, _OnSetActive);
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CChooserDlg::_OnCommand
//
//  Synopsis:   Respond to notifications from controls in dialog
//
//  Arguments:  [wParam] - specifies control
//              [lParam] - unused
//
//  Returns:    0
//
//  History:    11-16-1998   JonN       Copied from wizard.cxx
//
//---------------------------------------------------------------------------

BOOL
CChooserDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CChooserDlg, _OnCommand);

    switch (LOWORD(wParam))
    {
    case IDC_CHOOSER_RADIO_LOCAL_MACHINE:
        EnableWindow(_hCtrl(IDC_CHOOSER_EDIT_MACHINE_NAME), FALSE);
        EnableWindow(_hCtrl(IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES), FALSE);
        break;

    case IDC_CHOOSER_RADIO_SPECIFIC_MACHINE:
        EnableWindow(_hCtrl(IDC_CHOOSER_EDIT_MACHINE_NAME), TRUE);
        EnableWindow(_hCtrl(IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES), TRUE);
        break;

    case IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES:
        _OnBrowseForMachine();
        break;

    case IDOK:
    {
        WCHAR wszEditCtrl[CCH_COMPUTER_MAX + 3];
        ZeroMemory(wszEditCtrl, sizeof(wszEditCtrl));
        LPWSTR pwszNameStart = wszEditCtrl;
        SObjectPickerResult *pOPR = NULL;

        if (!IsDlgButtonChecked(_hwnd, IDC_CHOOSER_RADIO_LOCAL_MACHINE))
        {
            HWND hwndEdit = _hCtrl(IDC_CHOOSER_EDIT_MACHINE_NAME);

            Edit_GetText(hwndEdit, wszEditCtrl, ARRAYLEN(wszEditCtrl));

            StripLeadTrailSpace(wszEditCtrl);

            if (*wszEditCtrl)
            {

                for (pwszNameStart = wszEditCtrl;
                     *pwszNameStart == L'\\';
                     pwszNameStart++)
                {
                }
            }
            else
            {
                MsgBox(_hwnd, IDS_NO_SERVERNAME, MB_ICONERROR | MB_OK);
                break;
            }

            LONG_PTR lpOPR = GetWindowLongPtr(hwndEdit, GWLP_USERDATA);

            if (lpOPR)
            {
                pOPR = reinterpret_cast<SObjectPickerResult *>(lpOPR);
            }
        }

        //
        // If the user hasn't changed what we put in the edit control
        // from the Object Picker, use the DNS name from the Object Picker
        // first.
        //

        HRESULT hr = E_FAIL;

        if (pOPR &&
            !pOPR->wstrDNS.empty() &&
            !lstrcmpi(pOPR->wstrNetBIOS.c_str(), pwszNameStart))
        {
            _pcd->_SelectScopeItem(_hsi);
            _pcd->_RemoveLogSetFromScopePane(0);
            _pcd->SetServerFocus(pOPR->wstrDNS.c_str());
            _pcd->_SetFlag(COMPDATA_USER_RETARGETTED);
            hr = _pcd->_OnExpand(_hsi, _pDataObject, _hwnd);  // EricB 1/24/02 bug 526145
        }

        //
        // If that failed or wasn't available try NetBIOS
        //

        if (FAILED(hr))
        {
            _pcd->_SelectScopeItem(_hsi);
            _pcd->_RemoveLogSetFromScopePane(0);
            _pcd->SetServerFocus(pwszNameStart);
            _pcd->_SetFlag(COMPDATA_USER_RETARGETTED);
            hr = _pcd->_OnExpand(_hsi, _pDataObject, _hwnd);
        }

        _fChangeFocusFailed = FAILED(hr);
        BREAK_ON_FAIL_HRESULT(hr);

        (void) ::EndDialog( _hwnd, IDOK );
        break;
    }

    case IDCANCEL:
        if (_fChangeFocusFailed)
        {
            // last attempt to change focus failed, try to revert to original
            // focus

            _pcd->_SelectScopeItem(_hsi);
            _pcd->_RemoveLogSetFromScopePane(0);
            _pcd->SetServerFocus(_wszInitialFocus);
            _pcd->_SetFlag(COMPDATA_USER_RETARGETTED);
            _pcd->_OnExpand(_hsi, _pDataObject, _hwnd);
        }
        (void) ::EndDialog( _hwnd, IDCANCEL );
        break;
    }
    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CChooserDlg::_OnBrowseForMachine
//
//  Synopsis:   Fill the machine name edit control with the machine chosen
//              from the computer object selector dialog by the user.
//
//  History:    11-16-1998   JonN       Copied from wizard.cxx
//
//---------------------------------------------------------------------------

VOID
CChooserDlg::_OnBrowseForMachine()
{
    HRESULT hr;
    static const int     SCOPE_INIT_COUNT = 1;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Since we just want computer objects from every scope, combine them
    // all in a single scope initializer.
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                           | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                           | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_WORKGROUP
                           | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                           | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    PCWSTR apwzAttributesToFetch[] =
    {
        L"dNSHostName"
    };

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;
    InitInfo.cAttributesToFetch = ARRAYLEN(apwzAttributesToFetch);
    InitInfo.apwzAttributeNames = apwzAttributesToFetch;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    IDsObjectPicker *pDsObjectPicker = NULL;
    IDataObject *pdo = NULL;
    bool fGotStgMedium = false;
    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    do
    {
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pDsObjectPicker->Initialize(&InitInfo);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pDsObjectPicker->InvokeDialog(_hwnd, &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

        // Quit if user hit Cancel

        if (hr == S_FALSE)
        {
            break;
        }

        FORMATETC formatetc =
        {
            (CLIPFORMAT)g_cfDsObjectPicker,
            NULL,
            DVASPECT_CONTENT,
            -1,
            TYMED_HGLOBAL
        };

        hr = pdo->GetData(&formatetc, &stgmedium);
        BREAK_ON_FAIL_HRESULT(hr);

        fGotStgMedium = true;

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        if (!pDsSelList)
        {
            DBG_OUT_LRESULT(GetLastError());
            break;
        }

        ASSERT(pDsSelList->cItems == 1);

        //
        // Put the netbios machine name in the edit control
        //

        HWND hwndEdit = _hCtrl(IDC_CHOOSER_EDIT_MACHINE_NAME);

        Edit_SetText(hwndEdit, pDsSelList->aDsSelection[0].pwzName);

        //
        // Also save the DNS name of the machine, if we got it, since that
        // is what we'll try to connect to first.  (Per CliffV this is a
        // good strategy--try DNS then NetBIOS.)
        //

        LONG_PTR lpOPR = GetWindowLongPtr(hwndEdit, GWLP_USERDATA);

        if (lpOPR)
        {
            SObjectPickerResult *pOPR= reinterpret_cast<SObjectPickerResult *>(lpOPR);
            delete pOPR;
            lpOPR = NULL;
        }

        if (V_VT(pDsSelList->aDsSelection[0].pvarFetchedAttributes) == VT_BSTR &&
            V_BSTR(pDsSelList->aDsSelection[0].pvarFetchedAttributes))
        {
            SObjectPickerResult *pOPR = new SObjectPickerResult;

            if (pOPR)
            {
                pOPR->wstrNetBIOS = pDsSelList->aDsSelection[0].pwzName;
                pOPR->wstrDNS = V_BSTR(pDsSelList->aDsSelection[0].pvarFetchedAttributes);
                lpOPR = reinterpret_cast<LONG_PTR>(pOPR);
            }
            else
            {
                DBG_OUT_HRESULT(E_OUTOFMEMORY);
            }
        }

        SetWindowLongPtr(hwndEdit, GWLP_USERDATA, lpOPR);
        GlobalUnlock(stgmedium.hGlobal);

    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }

    if (pdo)
    {
        pdo->Release();
    }

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CChooserDlg::_OnDestroy
//
//  Synopsis:   Do cleanup as page closes
//
//  History:    11-16-1998   JonN       Copied from wizard.cxx
//
//---------------------------------------------------------------------------

VOID
CChooserDlg::_OnDestroy()
{
    TRACE_METHOD(CChooserDlg, _OnDestroy);

    HWND hwndEdit = _hCtrl(IDC_CHOOSER_EDIT_MACHINE_NAME);
    LONG_PTR lpOPR = GetWindowLongPtr(hwndEdit, GWLP_USERDATA);

    if (lpOPR)
    {
        SObjectPickerResult *pOPR = reinterpret_cast<SObjectPickerResult *>(lpOPR);
        delete pOPR;
        pOPR = NULL;
        SetWindowLongPtr(hwndEdit, GWLP_USERDATA, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\cmpdtacf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       cmpdtacf.cxx
//
//  Contents:   Implementation of class factory for ComponentData object.
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


DEBUG_DECLARE_INSTANCE_COUNTER(CComponentDataCF)


//============================================================================
//
// IUnknown implementation
//
//============================================================================




//+---------------------------------------------------------------------------
//
//  Member:     CComponentDataCF::QueryInterface
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CComponentDataCF::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    TRACE_METHOD(CComponentDataCF, QueryInterface);
    HRESULT hr = S_OK;

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppvObj = (IUnknown *)(IClassFactory *)this;
        }
        else if (IsEqualIID(riid, IID_IClassFactory))
        {
            *ppvObj = (IUnknown *)(IClassFactory *)this;
        }
        else
        {
#if (DBG == 1)
            LPOLESTR pwszIID;
            StringFromIID(riid, &pwszIID);
            Dbg(DEB_ERROR, "CComponentDataCF::QI no interface %ws\n", pwszIID);
            CoTaskMemFree(pwszIID);
#endif // (DBG == 1)
            hr = E_NOINTERFACE;
            DBG_OUT_HRESULT(hr);
            *ppvObj = NULL;
            break;
        }

        //
        // If we got this far we are handing out a new interface pointer on
        // this object, so addref it.
        //

        AddRef();
    } while (0);

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Member:     CComponentDataCF::AddRef
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CComponentDataCF::AddRef()
{
    return InterlockedIncrement((LONG *) &_cRefs);
}




//+---------------------------------------------------------------------------
//
//  Member:     CComponentDataCF::Release
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CComponentDataCF::Release()
{
    ULONG cRefsTemp;

    cRefsTemp = InterlockedDecrement((LONG *)&_cRefs);

    if (0 == cRefsTemp)
    {
        delete this;
    }

    return cRefsTemp;
}




//============================================================================
//
// IClassFactory implementation
//
//============================================================================




//+---------------------------------------------------------------------------
//
//  Member:     CComponentDataCF::CreateInstance
//
//  Synopsis:   Create a new instance of a data source object.
//
//  Arguments:  [pUnkOuter] - must be NULL
//              [riid]      - must be interface supported by DSO
//              [ppvObj]    - filled with requested interface on success
//
//  Returns:    CLASS_E_NOAGGREGATION among others
//
//  Modifies:   *[ppvObj]
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CComponentDataCF::CreateInstance(
    IUnknown    *pUnkOuter,
    REFIID       riid,
    LPVOID      *ppvObj)
{
    TRACE_METHOD(CComponentDataCF, CreateInstance);
    HRESULT hr = S_OK;
    CComponentData *pcd = NULL;

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        // Init for failure case

        *ppvObj = NULL;

        if (pUnkOuter != NULL)
        {
            hr = CLASS_E_NOAGGREGATION;
            DBG_OUT_HRESULT(hr);
            break;
        }

        pcd = new CComponentData();

        if (NULL == pcd)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        //
        // Try to get the requested interface.  Since the CComponentData
        // object starts with a refcount of 1, release after the QI.  If
        // the QI succeeded, the ComponentData will end up with a refcount
        // of 1.  If it failed, the ComponentData will have self-destructed.
        //

        hr = pcd->QueryInterface(riid, ppvObj);
        pcd->Release();
        CHECK_HRESULT(hr);
    } while (0);

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Member:     CComponentDataCF::LockServer
//
//  Synopsis:   Inc or dec the DLL lock count
//
//  Arguments:  [fLock] - TRUE increment, FALSE decrement
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CComponentDataCF::LockServer(
    BOOL fLock)
{
    TRACE_METHOD(CComponentDataCF, LockServer);
    CDll::LockServer(fLock);

    return S_OK;
}



//============================================================================
//
// Non-interface member function implementation
//
//============================================================================



//+---------------------------------------------------------------------------
//
//  Member:     CComponentDataCF::CComponentDataCF
//
//  Synopsis:   ctor
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

CComponentDataCF::CComponentDataCF():
    _cRefs(1)
{
    TRACE_CONSTRUCTOR(CComponentDataCF);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentDataCF);
}




//+---------------------------------------------------------------------------
//
//  Member:     CComponentDataCF::~CComponentDataCF
//
//  Synopsis:   dtor
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

CComponentDataCF::~CComponentDataCF()
{
    TRACE_DESTRUCTOR(CComponentDataCF);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentDataCF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\compdata.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:       cd.cxx
//
//  Contents:   Implementation of component data class
//
//  Classes:    CComponentData
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop
#include "chooser.hxx" // CChooserDlg

#define DISPLAY_PATH_STR    L"DisplayNameFile"
#define DISPLAY_MSGID_STR   L"DisplayNameID"

static ULONG
s_aulHelpIds[] =
{
    open_type_txt,          Hopen_type_combo,
    open_type_combo,        Hopen_type_combo,
    open_display_name_txt,  Hopen_display_name_edit,
    open_display_name_edit, Hopen_display_name_edit,
    0,0
};

//
// s_acmiChildFolderScope - context menu items for child folders to be
//      added only when the user clicked in the scope pane
//

CMENUITEM s_acmiChildFolderScope[] =
{
    {
        0,0,0,0,0,0
    }
};


//
// CAUTION: the following manifest constants must be kept in sync with
// the 0-based index of the CMENUITEM structs they represent.
//

#define MNU_VIEW_ALL        0
#define MNU_VIEW_FILTER     1
// --------------------------
#define MNU_VIEW_NEWEST     3
#define MNU_VIEW_OLDEST     4
// --------------------------
#define MNU_VIEW_FIND       6
#define MNU_TOP_OPEN        7
#define MNU_TOP_SAVE_AS     8
#define MNU_TOP_COPY_VIEW   9
#define MNU_TOP_CLEAR_ALL   10

CMENUITEM s_acmiChildFolderBoth[] =
{
    // 0 View>All Records

    {
        IDS_CMENU_VIEW_ALL,
        IDS_SBAR_VIEW_ALL,
        IDM_VIEW_ALL,
        CCM_INSERTIONALLOWED_VIEW,
        CCM_INSERTIONPOINTID_PRIMARY_VIEW,
        MFS_ENABLED,
        0
    },

    // 1 View>Filter

    {
        IDS_CMENU_VIEW_FILTER,
        IDS_SBAR_VIEW_FILTER,
        IDM_VIEW_FILTER,
        CCM_INSERTIONALLOWED_VIEW,
        CCM_INSERTIONPOINTID_PRIMARY_VIEW,
        MFS_ENABLED,
        0
    },

    // 2 View>Separator

    {
        static_cast<ULONG>(-1L),
        0,
        0,
        CCM_INSERTIONALLOWED_VIEW,
        CCM_INSERTIONPOINTID_PRIMARY_VIEW,
        MFS_ENABLED,
        CCM_SPECIAL_SEPARATOR
    },

    // 3 View>Newest First

    {
        IDS_CMENU_VIEW_NEWEST,
        IDS_SBAR_VIEW_NEWEST,
        IDM_VIEW_NEWEST,
        CCM_INSERTIONALLOWED_VIEW,
        CCM_INSERTIONPOINTID_PRIMARY_VIEW,
        MFS_ENABLED,
        0
    },

    // 4 View>Oldest First

    {
        IDS_CMENU_VIEW_OLDEST,
        IDS_SBAR_VIEW_OLDEST,
        IDM_VIEW_OLDEST,
        CCM_INSERTIONALLOWED_VIEW,
        CCM_INSERTIONPOINTID_PRIMARY_VIEW,
        MFS_ENABLED,
        0
    },

    // 5 View>Separator

    {
        static_cast<ULONG>(-1L),
        0,
        0,
        CCM_INSERTIONALLOWED_VIEW,
        CCM_INSERTIONPOINTID_PRIMARY_VIEW,
        MFS_ENABLED,
        CCM_SPECIAL_SEPARATOR
    },

    // 6 View>Find

    {
        IDS_CMENU_VIEW_FIND,
        IDS_SBAR_VIEW_FIND,
        IDM_VIEW_FIND,
        CCM_INSERTIONALLOWED_VIEW,
        CCM_INSERTIONPOINTID_PRIMARY_VIEW,
        MFS_ENABLED,
        0
    },

    // 7 Top>Open Saved Log File
    {
        IDS_CMENU_OPEN,
        IDS_SBAR_OPEN,
        IDM_OPEN,
        CCM_INSERTIONALLOWED_TOP,
        CCM_INSERTIONPOINTID_PRIMARY_TOP,
        MFS_ENABLED,
        0
    },

    // 8 Top>Save As

    {
        IDS_CMENU_SAVEAS,
        IDS_SBAR_SAVEAS,
        IDM_SAVEAS,
        CCM_INSERTIONALLOWED_TOP,
        CCM_INSERTIONPOINTID_PRIMARY_TOP,
        MFS_ENABLED,
        0
    },

    // 9 Top>Copy this Log View
    {
        IDS_CMENU_COPY_VIEW,
        IDS_SBAR_COPY_VIEW,
        IDM_COPY_VIEW,
        CCM_INSERTIONALLOWED_TOP,
        CCM_INSERTIONPOINTID_PRIMARY_TOP,
        MFS_ENABLED,
        0
    },

    // 10 Top>Clear All Events

    {
        IDS_CMENU_CLEARLOG,
        IDS_SBAR_CLEARLOG,
        IDM_CLEARLOG,
        CCM_INSERTIONALLOWED_TOP,
        CCM_INSERTIONPOINTID_PRIMARY_TOP,
        MFS_ENABLED,
        0
    },

#if (DBG == 1) && (DBG_DUMP == 1)
    // 11 Task>Dump

    {
        IDS_CMENU_DUMP,
        IDS_SBAR_DUMP,
        IDM_DUMP_LOGINFO,
        CCM_INSERTIONALLOWED_TASK,
        CCM_INSERTIONPOINTID_PRIMARY_TASK,
        MFS_ENABLED,
        0
    },
#endif // (DBG == 1) && (DBG_DUMP == 1)

    {
        0,0,0,0,0,0,0
    }
};


CMENUITEM s_acmiRootFolder[] =
{
#if (DBG == 1) && (DBG_DUMP == 1)
    // 0 Task>Dump

    {
        IDS_CMENU_DUMP,
        IDS_SBAR_DUMP,
        IDM_DUMP_COMPONENTDATA,
        CCM_INSERTIONALLOWED_TASK,
        CCM_INSERTIONPOINTID_PRIMARY_TASK,
        MFS_ENABLED,
        0
    },
#endif // (DBG == 1) && (DBG_DUMP == 1)

    // 1 Top>Connect to another computer
    {
        IDS_CMENU_RETARGET,
        IDS_SBAR_RETARGET,
        IDM_RETARGET,
        CCM_INSERTIONALLOWED_TOP,
        CCM_INSERTIONPOINTID_PRIMARY_TOP,
        MFS_ENABLED,
        0
    },

    // 2 Top>Open Saved Log File
    {
        IDS_CMENU_OPEN,
        IDS_SBAR_OPEN,
        IDM_OPEN,
        CCM_INSERTIONALLOWED_TOP,
        CCM_INSERTIONPOINTID_PRIMARY_TOP,
        MFS_ENABLED,
        0
    },

    {
       0,0,0,0,0,0,0
    }
};


CMENUITEM s_acmiExtensionRootFolder[] =
{
#if (DBG == 1) && (DBG_DUMP == 1)
    // 0 Task>Dump

    {
        IDS_CMENU_DUMP,
        IDS_SBAR_DUMP,
        IDM_DUMP_COMPONENTDATA,
        CCM_INSERTIONALLOWED_TASK,
        CCM_INSERTIONPOINTID_PRIMARY_TASK,
        MFS_ENABLED,
        0
    },
#endif // (DBG == 1) && (DBG_DUMP == 1)

    // 1 Top>Open Saved Log File
    {
        IDS_CMENU_OPEN,
        IDS_SBAR_OPEN,
        IDM_OPEN,
        CCM_INSERTIONALLOWED_TOP,
        CCM_INSERTIONPOINTID_PRIMARY_TOP,
        MFS_ENABLED,
        0
    },

    {
       0,0,0,0,0,0,0
    }
};



DEBUG_DECLARE_INSTANCE_COUNTER(CComponentData)


//
// Forward references
//

void
_PopulateOpenSavedLogTypeCombo(
    HWND hdlg);

void
_GetOpenSavedServer(
    HWND  hdlg,
    PWSTR wzServer,
    USHORT wcchServer); // JonN 2/1/01 256032

void
_ResetOpenSavedLogTypeCombo(
    HWND hwndTypeCombo);

VOID
_AddRegKeysToLogTypeCombo(
    HWND            hwndTypeCombo,
    const CSafeReg &shkTargetEventLog,
    PCWSTR          wzServer,
    PCWSTR          wszRemoteSystemRoot,
    BOOL            fCheckForDuplicates);

//============================================================================
//
// IUnknown implementation
//
//============================================================================


//+---------------------------------------------------------------------------
//
//  Member:     CComponentData::QueryInterface
//
//  Synopsis:   Return the requested interface
//
//  History:    1-20-97   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CComponentData::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    TRACE_METHOD(CComponentData, QueryInterface);

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppvObj = (IUnknown*)(IPersistStream*)this;
        }
        else if (IsEqualIID(riid, IID_IComponentData))
        {
            *ppvObj = (IUnknown*)(IComponentData*)this;
        }
        else if (IsEqualIID(riid, IID_IExtendPropertySheet))
        {
            *ppvObj = (IUnknown*)(IExtendPropertySheet*)this;
        }
        else if (IsEqualIID(riid, IID_IExtendContextMenu))
        {
            *ppvObj = (IUnknown*)(IExtendContextMenu*)this;
        }
        else if (IsEqualIID(riid, IID_IPersist))
        {
            *ppvObj = (IUnknown*)(IPersist*)(IPersistStream*)this;
            Dbg(DEB_STORAGE,
                "CComponentData::QI(%x): giving out IPersist\n",
                this);
        }
        else if (IsEqualIID(riid, IID_IPersistStream))
        {
            *ppvObj = (IUnknown*)(IPersistStream*)this;
            Dbg(DEB_STORAGE,
                "CComponentData::QI(%x): giving out IPersistStream\n",
                this);
        }
        else if (IsEqualIID(riid, IID_INamespacePrshtActions))
        {
            *ppvObj = (IUnknown*)(INamespacePrshtActions *)this;
        }
        else if (IsEqualIID(riid, IID_IExternalConnection))
        {
            *ppvObj = (IUnknown *)(IExternalConnection *)this;
        }
        else if (IsEqualIID(riid, IID_ISnapinHelp))
        {
            *ppvObj = (IUnknown *)(ISnapinHelp *) this;
        }
        else
        {
            hr = E_NOINTERFACE;
#if (DBG == 1)
            LPOLESTR pwszIID;
            StringFromIID(riid, &pwszIID);
            Dbg(DEB_ERROR, "CComponentData::QI no interface %ws\n", pwszIID);
            CoTaskMemFree(pwszIID);
#endif // (DBG == 1)
        }

        if (FAILED(hr))
        {
            *ppvObj = NULL;
            break;
        }

        //
        // If we got this far we are handing out a new interface pointer on
        // this object, so addref it.
        //

        AddRef();
    } while (0);

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Member:     CComponentData::AddRef
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *) &_cRefs);
}




//+---------------------------------------------------------------------------
//
//  Member:     CComponentData::Release
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CComponentData::Release()
{
    ULONG cRefsTemp;

    cRefsTemp = InterlockedDecrement((LONG *)&_cRefs);

    if (0 == cRefsTemp)
    {
        delete this;
    }

    return cRefsTemp;
}




//============================================================================
//
// IPersist implementation
//
//============================================================================


//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::GetClassID
//
//  Synopsis:   Return this object's class ID.
//
//  History:    12-11-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CComponentData::GetClassID(
    CLSID *pClassID)
{
    *pClassID = CLSID_EventLogSnapin;
    return S_OK;
}



//============================================================================
//
// IPersistStream implementation
//
//============================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::IsDirty
//
//  Synopsis:   Return S_OK if object is dirty, S_FALSE otherwise.
//
//  History:    12-11-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CComponentData::IsDirty()
{
    TRACE_METHOD(CComponentData, IsDirty);

    return _IsFlagSet(COMPDATA_DIRTY) ? S_OK : S_FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::Load
//
//  Synopsis:   Initialize this from stream [pstm].
//
//  Arguments:  [pstm] - stream from which to read.
//
//  Returns:    HRESULT
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CComponentData::Load(
    IStream *pstm)
{
    Dbg(DEB_STORAGE, "CComponentData::Load (%x)\n", this);

    HRESULT hr = S_OK;

    //
    // We should not already have created logsets
    //

    ASSERT(!_pLogSets);

    do
    {
        // version

        USHORT usSavedVersion;

        hr = pstm->Read(&usSavedVersion, sizeof USHORT, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        Dbg(DEB_TRACE,
            "CComponentData::Load: Stream version %#x\n",
            usSavedVersion);

        //
        // This code has a version defined in FILE_VERSION.
        // We can understand any other versions which reside
        // in the same range [FILE_VERSION_MIN, FILE_VERSION_MAX]
        //

        if (usSavedVersion < FILE_VERSION_MIN ||
            usSavedVersion > FILE_VERSION_MAX)
        {
          //
          // we're looking at a file format that is not compatible with current version
          //
            Dbg(DEB_ERROR,
                "CComponentData::Load: Stream version %#x but binary version %#x\n",
                usSavedVersion,
                FILE_VERSION);
            break;
        }

        //
        // Persisted flags
        //

        USHORT usPersistedFlags;

        hr = pstm->Read(&usPersistedFlags, sizeof USHORT, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        _flFlags |= usPersistedFlags;

        //
        // length of wchar string, including NULL
        //

        USHORT cch;

        hr = pstm->Read(&cch, sizeof USHORT, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        if (cch > ARRAYLEN(_wszServerFocus))
        {
            hr = E_FAIL;
            DBG_OUT_HRESULT(hr);
            break;
        }

        //
        // Machine name on which we're focused
        //

        hr = pstm->Read(_wszServerFocus, sizeof(WCHAR) * cch, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Focused server system root
        //

        hr = pstm->Read(&cch, sizeof cch, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        if (cch > ARRAYLEN(_wszCurFocusSystemRoot))
        {
            hr = E_FAIL;
            DBG_OUT_HRESULT(hr);
            break;
        }

        hr = pstm->Read(_wszCurFocusSystemRoot, sizeof(WCHAR) * cch, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // If computer name override is allowed, and the user has specified
        // one, replace the focus system root just read with the user's
        // override
        //

        if (g_fMachineNameOverride && _IsFlagSet(COMPDATA_ALLOW_OVERRIDE))
        {
            Dbg(DEB_ITRACE,
                "CComponentData::Load: Overriding saved server focus with '%ws'\n",
                g_wszMachineNameOverride);

            _UpdateCurFocusSystemRoot();
        }

        //
        // Read the count of LogSets
        //

        USHORT cLogSets;

        hr = pstm->Read(&cLogSets, sizeof USHORT, NULL);
        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            return hr;
        }

        //
        // Read the logsets themselves
        //

        for (USHORT i = 0; i < cLogSets; i++)
        {
            CLogSet *plsNew = new CLogSet(this);
            if (!plsNew)
            {
                hr = E_OUTOFMEMORY;
                DBG_OUT_HRESULT(hr);
                break;
            }

            hr = plsNew->Load(pstm, usSavedVersion, _pStringTable);

            if (FAILED(hr))
            {
                DBG_OUT_HRESULT(hr);
                delete plsNew;
                break;
            }

            //
            // Add it to the llist
            //

            _AddLogSetToList(plsNew);
        }

    } while (0);

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::Save
//
//  Synopsis:   Persist this object to [pStm].
//
//  Arguments:  [pStm]        - stream to write to
//              [fClearDirty] - if TRUE, internal dirty flag cleared on
//                                successful write.
//
//  Returns:    HRESULT
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CComponentData::Save(
    IStream *pStm,
    BOOL fClearDirty)
{
    Dbg(DEB_STORAGE, "CComponentData::Save(%x)\n", this);

    HRESULT hr = S_OK;

    //
    // Stream contents:
    //
    // version, USHORT
    // persisted flags, USHORT
    // length of focused server, including terminating null, USHORT
    // focused server string (null-terminated WCHAR string)
    // length of focused server sysroot value, including terminating null, USHORT
    // focused server system root (null-terminated WCHAR string)
    // n = Number of CLogSets, ULONG
    // n logsets
    // n = number of snapins, USHORT
    // n snapins
    //

    do
    {
        //
        // Clear the string table and let the loginfos rebuild it
        //

        // JonN 1/17/01 Windows Bugs 158623 / WinSERAID 14773
        for (int i = ((int)_listStringIDs.length()); i > 0; i--)
        {
            MMC_STRING_ID strid = _listStringIDs[i-1];
            ASSERT(strid > 0);
            hr = _pStringTable->DeleteString(strid);
            BREAK_ON_FAIL_HRESULT(hr);
        }
        BREAK_ON_FAIL_HRESULT(hr);
        _listStringIDs.erase();

        //
        // version
        //

        hr = pStm->Write(&FILE_VERSION, sizeof USHORT, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        Dbg(DEB_TRACE,
            "CComponentData::Write: Writing stream version %#x\n",
            FILE_VERSION);

        //
        // Persisted flags
        //

        USHORT usPersistedFlags = _flFlags & COMPDATA_PERSISTED_FLAG_MASK;

        hr = pStm->Write(&usPersistedFlags, sizeof usPersistedFlags, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Focused server name
        //

        USHORT cch = static_cast<USHORT>(lstrlen(_wszServerFocus) + 1);

        hr = pStm->Write(&cch, sizeof cch, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pStm->Write(_wszServerFocus, sizeof(WCHAR) * cch, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Focused server system root
        //

        cch = static_cast<USHORT>(lstrlen(_wszCurFocusSystemRoot) + 1);

        hr = pStm->Write(&cch, sizeof cch, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pStm->Write(_wszCurFocusSystemRoot, sizeof(WCHAR) * cch, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // count the number of logsets and write the count
        //

        CLogSet *plsCur;
        USHORT cLogSets = 0;

        for (plsCur = _pLogSets; plsCur; plsCur = plsCur->Next())
        {
            if (plsCur->ShouldSave())
            {
               cLogSets++;
            }
        }

        hr = pStm->Write(&cLogSets, sizeof USHORT, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // LogSets
        //

        for (plsCur = _pLogSets; plsCur; plsCur = plsCur->Next())
        {
            if (plsCur->ShouldSave())
            {
               hr = plsCur->Save(pStm, _pStringTable);
               BREAK_ON_FAIL_HRESULT(hr);
            }
        }
    } while (0);

    if (SUCCEEDED(hr) && fClearDirty)
    {
        _ClearFlag(COMPDATA_DIRTY);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::GetSizeMax
//
//  Synopsis:   Write the size, in bytes, needed to save this object into
//              *[pcbSize].
//
//  History:    12-11-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CComponentData::GetSizeMax(
    ULARGE_INTEGER *pcbSize)
{
    TRACE_METHOD(CComponentData, GetSizeMax);

    pcbSize->QuadPart = (ULONGLONG) sizeof(FILE_VERSION) + sizeof(ULONG);

    CLogSet *plsCur;

    for (plsCur = _pLogSets; plsCur; plsCur = plsCur->Next())
    {
        pcbSize->QuadPart += plsCur->GetMaxSaveSize();
    }

    return S_OK;
}




//============================================================================
//
// IComponentData overrides
//
//============================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::Initialize
//
//  Synopsis:   Snap-in entry point.
//
//  Arguments:  [punk] - can QI this for IConsole & IConsoleNameSpace
//
//  Returns:    HRESULT
//
//  Derivation: IComponentData
//
//  History:    1-21-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::Initialize(
    LPUNKNOWN punk)
{
    TRACE_METHOD(CComponentData, Initialize);

    HRESULT     hr = S_OK;
    LPIMAGELIST pScopeImage = NULL;

    do
    {
        hr = g_SynchWnd.Register(this);

        if (SUCCEEDED(hr))
        {
            _SetFlag(COMPDATA_SYNC_REGISTERED);
        }

        //
        // Save away all the interfaces we'll need
        //

        hr = punk->QueryInterface(IID_IConsoleNameSpace, (VOID**)&_pConsoleNameSpace);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = punk->QueryInterface(IID_IConsole2, (VOID**)&_pConsole);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = _pConsole->QueryInterface(IID_IPropertySheetProvider,
                                     (VOID**)&_pPrshtProvider);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = _pConsole->QueryInterface(IID_IStringTable,
                                     (VOID**)&_pStringTable);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Add the bitmap we need in the scope pane.  It's done here because
        // unlike the result pane icons, it only needs to be set once.
        //

        hr = _pConsole->QueryScopeImageList(&pScopeImage);
        BREAK_ON_FAIL_HRESULT(hr);

        // Load the bitmaps from the dll
        HBITMAP hbmp16x16 = LoadBitmap(g_hinst,
                                       MAKEINTRESOURCE(IDB_SCOPE_16x16));

        if (!hbmp16x16)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DBG_OUT_LASTERROR;
            break;
        }

        hr = pScopeImage->ImageListSetStrip((LONG_PTR*)hbmp16x16,
                                            (LONG_PTR*)hbmp16x16,
                                            IDX_SDI_BMP_FIRST,
                                            BITMAP_MASK_COLOR);
        VERIFY(DeleteObject(hbmp16x16)); // JonN 11/29/00 243763
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    if (pScopeImage)
    {
        pScopeImage->Release();
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::CreateComponent
//
//  Synopsis:   Create a Componet for this ComponetData
//
//  Arguments:  [ppComponent] - filled with new component
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//  Modifies:   *[ppComponent]
//
//  Derivation: IComponentData
//
//  History:    1-21-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::CreateComponent(
    LPCOMPONENT* ppComponent)
{
    TRACE_METHOD(CComponentData, CreateComponent);

    HRESULT hr = S_OK;
    CSnapin *pNewSnapin = new CSnapin(this);
    *ppComponent = pNewSnapin;

    if (!pNewSnapin)
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(hr);
    }
    else
    {
        pNewSnapin->AddRef();
        SetActiveSnapin(pNewSnapin);

        if (!_pSnapins)
        {
            _pSnapins = pNewSnapin;
        }
        else
        {
            pNewSnapin->LinkAfter(_pSnapins);
        }
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::Notify
//
//  Synopsis:   Handle notification from the console of an event
//
//  Arguments:  [lpDataObject] - object affected by event
//              [event]        - MMCN_*
//              [arg]          - depends on [event]
//              [param]        - depends on [event]
//
//  Returns:    HRESULT
//
//  History:    3-07-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::Notify(
      LPDATAOBJECT lpDataObject,
      MMC_NOTIFY_TYPE event,
      LPARAM arg,
      LPARAM param)
{
    TRACE_METHOD(CComponentData, Notify);

    HRESULT hr = S_OK;

    switch (event)
    {
    case MMCN_DELETE:
        Dbg(DEB_NOTIFY, "ComponentData::Notify: MMCN_DELETE\n");
        hr = _OnDelete(lpDataObject);
        break;

    case MMCN_REFRESH:
        Dbg(DEB_NOTIFY, "ComponentData::Notify: MMCN_REFRESH\n");
        hr = _OnRefresh(lpDataObject);
        break;

    case MMCN_RENAME:
        Dbg(DEB_NOTIFY, "ComponentData::Notify: MMCN_RENAME\n");
        hr = _OnRename(lpDataObject, (BOOL) arg, (LPWSTR) param);
        break;

    case MMCN_EXPAND:
        Dbg(DEB_NOTIFY, "ComponentData::Notify: MMCN_EXPAND\n");
        if (arg /*&& !_IsFlagSet(COMPDATA_ENUMERATED_ROOT)*/)
        {
            hr = _OnExpand((HSCOPEITEM) param, lpDataObject);
        }
        break;

    case MMCN_SELECT:
        Dbg(DEB_NOTIFY, "ComponentData::Notify: MMCN_SELECT\n");
        break;

    case MMCN_PROPERTY_CHANGE:
        Dbg(DEB_NOTIFY, "ComponentData::Notify: MMCN_PROPERTY_CHANGE\n");
        break;

    case MMCN_REMOVE_CHILDREN:
        Dbg(DEB_NOTIFY, "ComponentData::Notify: MMCN_REMOVE_CHILDREN\n");
        _RemoveLogSetFromScopePane((HSCOPEITEM)arg);
        _hsiRoot = NULL;
        break;

    case MMCN_PRELOAD:
        Dbg(DEB_NOTIFY, "ComponentData::Notify: MMCN_PRELOAD\n");
        ASSERT(!_hsiRoot);
        _hsiRoot = (HSCOPEITEM) arg;
        _UpdateRootDisplayName();
        break;

    case MMCN_EXPANDSYNC:
        Dbg(DEB_NOTIFY, "ComponentData::Notify: MMCN_EXPANDSYNC\n");
        break;

    default:
        Dbg(DEB_ERROR,
            "CComponentData::Notify: unexpected event %x\n",
            event);
        ASSERT(FALSE);
        hr = E_UNEXPECTED;
        break;
    }
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::Destroy
//
//  Synopsis:   Remove this from the list of componentdatas that will
//              receive notifications via the synch window, since this
//              component data object is going away.
//
//  Returns:    S_OK
//
//  History:    3-17-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::Destroy()
{
    TRACE_METHOD(CComponentData, Destroy);

    if (_IsFlagSet(COMPDATA_SYNC_REGISTERED))
    {
        g_SynchWnd.Unregister(this);
        _ClearFlag(COMPDATA_SYNC_REGISTERED);
    }
    _SetFlag(COMPDATA_DESTROYED);

    //
    // Because this is a cache of OLE interfaces, it must be cleared (and
    // the interfaces released) before CoUninitialize is called.  Therefore
    // we can't wait for the global variable's dtor to be called.
    //

    g_DirSearchCache.Clear();


    // JonN 8/20/01 458926
    // MMC-Event Viewer: AV when use "New TaskPad View"
    // Code moved from destructor to Destroy()

    ASSERT(!_pSnapins);

    Dbg(DEB_TRACE, "CComponentData::Destroy _pLogSets=%x\n", _pLogSets);
    _ClearLogSets();

    //
    // Release all snapins
    //

    {
        CSnapin *pCur;
        CSnapin *pNext;

        for (pCur = _pSnapins; pCur; pCur = pNext)
        {
            pNext = pCur->Next();
            pCur->UnLink();
#if (DBG == 1)
            ULONG cRefs =
#endif // (DBG == 1)
            pCur->Release();
            ASSERT(!cRefs);
        }
        _pSnapins = NULL;
    }

    //
    // Release any interface pointers we got
    //

    if (_pConsole)
    {
        _pConsole->Release();
        _pConsole = NULL;
    }

    if (_pConsoleNameSpace)
    {
        _pConsoleNameSpace->Release();
        _pConsoleNameSpace = NULL;
    }

    if (_pPrshtProvider)
    {
        _pPrshtProvider->Release();
        _pPrshtProvider = NULL;
    }

    if (_pStringTable)
    {
        _pStringTable->Release();
        _pStringTable = NULL;
    }

    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::QueryDataObject
//
//  Synopsis:   Create a data object to describe a scope pane item
//
//  Arguments:  [cookie]       - NULL or CLogInfo *
//              [type]         - CCT_*
//              [ppDataObject] - filled with new data object
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppDataObject]
//
//  Derivation: IComponentData
//
//  History:    1-21-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::QueryDataObject(
    MMC_COOKIE cookie,
    DATA_OBJECT_TYPES type,
    LPDATAOBJECT* ppDataObject)
{
    // TRACE_METHOD(CComponentData, QueryDataObject);

    HRESULT hr = S_OK;
    CDataObject *pdoNew = NULL;

    do
    {
        pdoNew = new CDataObject;
        *ppDataObject = pdoNew;

        if (!pdoNew)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        //
        // The cookie represents a snapin manager or scope pane item (a log).
        //
        // If the passed-in cookie is non-NULL, then it should be one we
        // created when we added a node to the scope pane.
        //
        // Otherwise the cookie refers to the event logs folder (this snapin's
        // static folder in the scope pane or snapin manager).
        //

        if (cookie && cookie != EXTENSION_EVENT_VIEWER_FOLDER_PARAM)
        {
            CLogInfo *pli = (CLogInfo *) cookie;

            ASSERT(IsValidLogInfo(pli));
            pdoNew->SetCookie((MMC_COOKIE)pli, CCT_SCOPE, COOKIE_IS_LOGINFO);
        }
        else
        {
            pdoNew->SetCookie(0, type, COOKIE_IS_ROOT);
        }

        //
        // Give the data object a backpointer so that it can ask this for
        // the server name when it has to provide the display name of the
        // logs folder.  That display name is either "Event Logs on this
        // computer" or "Event logs on \\servername".
        //

        pdoNew->SetComponentData(this);

    } while (0);

    return hr;
}





//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::GetDisplayInfo
//
//  Synopsis:   The snap-in's scope tree callback handler
//
//  Arguments:  [pItem] - describes item for which to return info, and
//                          holds the returned info.
//
//  Returns:    S_OK
//
//  Modifies:   *[pItem]
//
//  Derivation: IComponentData
//
//  History:    1-21-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::GetDisplayInfo(
    LPSCOPEDATAITEM pItem)
{
    // TRACE_METHOD(CComponentData, GetDisplayInfo);
    // Dbg(DEB_ITRACE,
    // "CComponentData::GetDisplayInfo: psdi->mask = %x\n",
    //                                  pItem->mask);

    //
    // If we're an extension snapin, then the scope data item may be for the
    // "event viewer" folder, in which case the lParam will be a special
    // value.
    //

    if (IsExtension() && pItem->lParam == EXTENSION_EVENT_VIEWER_FOLDER_PARAM)
    {
        if (pItem->mask & SDI_STR)
        {
            pItem->displayname = g_wszEventViewer;
        }
        ASSERT((pItem->mask & (SDI_IMAGE | SDI_OPENIMAGE)) == 0);
        pItem->nImage     = IDX_SDI_BMP_FOLDER;
        pItem->nOpenImage = IDX_SDI_BMP_FOLDER;
        return S_OK;
    }

    CLogInfo *pli = (CLogInfo *) pItem->lParam;
    ASSERT(IsValidLogInfo(pli));

    if (pItem->mask & (SDI_IMAGE | SDI_OPENIMAGE))
    {
        if (pli->IsEnabled())
        {
            pItem->nImage     = IDX_SDI_BMP_LOG_CLOSED;
            pItem->nOpenImage = IDX_SDI_BMP_LOG_OPEN;
        }
        else
        {
            pItem->nImage     = IDX_SDI_BMP_LOG_DISABLED;
            pItem->nOpenImage = IDX_SDI_BMP_LOG_DISABLED;
        }
    }

    if (pItem->mask & SDI_STR)
    {
        pItem->displayname = pli->GetDisplayName();
    }
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::CompareObjects
//
//  Synopsis:   Return S_OK if both data objects refer to the same managed
//              object, S_FALSE otherwise.
//
//  Arguments:  [lpDataObjectA] - first data object to check
//              [lpDataObjectB] - second data object to check
//
//  Returns:    S_OK or S_FALSE
//
//  Derivation: IComponentData
//
//  History:    1-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT CComponentData::CompareObjects(
    LPDATAOBJECT lpDataObjectA,
    LPDATAOBJECT lpDataObjectB)
{
    TRACE_METHOD(CComponentData, CompareObjects);

    CDataObject *pdoA = ExtractOwnDataObject(lpDataObjectA);
    CDataObject *pdoB = ExtractOwnDataObject(lpDataObjectB);

    //
    // At least one of these data objects is supposed to be ours, so one
    // of the extracted pointers should be non-NULL.
    //

    ASSERT(pdoA || pdoB);

    //
    // If extraction failed for one of them, then that one is foreign and
    // can't be equal to the other one.  (Or else ExtractOwnDataObject
    // returned NULL because it ran out of memory, but the most conservative
    // thing to do in that case is say they're not equal.)
    //

    if (!pdoA || !pdoB)
    {
        return S_FALSE;
    }

    //
    // The data objects should not reference event records, since
    // IComponent::CompareObjects should get those.
    //

    ASSERT(pdoA->GetCookieType() != COOKIE_IS_RECNO);
    ASSERT(pdoB->GetCookieType() != COOKIE_IS_RECNO);

    //
    // The cookie type could be COOKIE_IS_ROOT or COOKIE_IS_OBJECT.  If they
    // differ then the objects refer to different things.
    //

    if (pdoA->GetCookieType() != pdoB->GetCookieType())
    {
        return S_FALSE;
    }

    //
    // Either both objects refer to the root (cookie == 0) or they refer
    // to log folders (cookie == CLogInfo *).  The spec warns that the
    // managed objects in the data objects may be deleted, so it is not
    // safe to dereference the CLogInfo pointers in these data objects,
    // nor is it guaranteed that IsValidLogCookie will return TRUE.
    //
    // For our purposes, however, it is safe to simply compare the
    // two pointers.
    //

    if (pdoA->GetCookie() != pdoB->GetCookie())
    {
        return S_FALSE;
    }

    return S_OK;
}




//============================================================================
//
// IExtendPropertySheet implementation
//
//============================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::CreatePropertyPages
//
//  Synopsis:   Create property pages appropriate to the object described
//              by [pIDataObject].
//
//  Arguments:  [lpProvider]   - callback for adding pages
//              [handle]       - used with MMCPropertyChangeNotify
//              [pIDataObject] - describes object on which prop sheet is
//                                  being opened.
//
//  Returns:    HRESULT
//
//  Derivation: IExtendPropertySheet
//
//  History:    1-20-1997   DavidMun   Created
//
//  Notes:      The object described by [pIDataObject] must be a folder.
//              The CSnapin class also implements the IExtendPropertySheet
//              interface, and it may be called for anything that can
//              appear in the result pane, i.e. folders and records.
//
//---------------------------------------------------------------------------

STDMETHODIMP
CComponentData::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle,
    LPDATAOBJECT pIDataObject)
{
    TRACE_METHOD(CComponentData, CreatePropertyPages);

    CDataObject *pdo = ExtractOwnDataObject(pIDataObject);

    //
    // If this isn't a data object we created, ignore it.
    //

    if (!pdo)
    {
        Dbg(DEB_IWARN,
            "CComponentData::CreatePropertyPages: Ignoring foreign data object %x\n",
            pIDataObject);
        MMCFreeNotifyHandle(handle);
        return S_OK;
    }

    //
    // Is this the snapin manager asking us to create a wizard page?
    //

    if (pdo->GetContext() == CCT_SNAPIN_MANAGER)
    {
        ASSERT(pdo->GetCookieType() == COOKIE_IS_ROOT);
        return _CreateWizardPage(lpProvider, handle);
    }

    //
    // A context of result pane should go to the IComponent, not the
    // IComponentData.  The user should not be able to open a propsheet
    // in snapin manager context, so at this point we expect the context
    // was scope pane.
    //

    ASSERT(pdo->GetContext() == CCT_SCOPE);

    //
    // We don't provide a property sheet on the static node.
    //

    if (pdo->GetCookieType() == COOKIE_IS_ROOT)
    {
        MMCFreeNotifyHandle(handle);
        return S_OK;
    }

    //
    // Since we expect context to be scope, the cookie should be for
    // a log folder.
    //

    CLogInfo *pli = (CLogInfo *)pdo->GetCookie();

    ASSERT(pdo->GetCookieType() == COOKIE_IS_LOGINFO);
    ASSERT(IsValidLogInfo(pli));

    //
    // If there's already a property sheet open on the cookie (perhaps opened
    // via Tasks/View/Filter) then make it the foreground window and bail.
    //

    if (pli->GetPropSheetWindow())
    {
        SetForegroundWindow(pli->GetPropSheetWindow());
        MMCFreeNotifyHandle(handle);
        return S_OK;
    }

    //
    // No prop sheet was open, so create the pages for a new one.
    //

    HRESULT             hr = S_OK;
    PROPSHEETPAGE       psp;
    HPROPSHEETPAGE      hGeneralPage = NULL;
    HPROPSHEETPAGE      hFilterPage = NULL;
    CGeneralPage       *pGeneralPage = NULL;
    CFilterPage        *pFilterPage = NULL;
    BOOL                fAddedGeneralPage = FALSE;
    LPSTREAM            pstmGeneral = NULL;
    LPSTREAM            pstmFilter = NULL;

    do
    {
        //
        // Marshal the private interface implemented by this for
        // each of the property sheet pages.
        //

        hr = CoMarshalInterThreadInterfaceInStream(
                                    IID_INamespacePrshtActions,
                                    (INamespacePrshtActions *) this,
                                    &pstmGeneral);
        BREAK_ON_FAIL_HRESULT(hr);

        pGeneralPage = new CGeneralPage(pstmGeneral, pli);

        if (!pGeneralPage)
        {
            hr = E_OUTOFMEMORY;
            MMCFreeNotifyHandle(handle);
            break;
        }

        pstmGeneral = NULL;

        hr = CoMarshalInterThreadInterfaceInStream(
                                    IID_INamespacePrshtActions,
                                    (INamespacePrshtActions *) this,
                                    &pstmFilter);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            MMCFreeNotifyHandle(handle);
            break;
        }

        pFilterPage = new CFilterPage(pstmFilter, pli);

        if (!pFilterPage)
        {
            hr = E_OUTOFMEMORY;
            MMCFreeNotifyHandle(handle);
            break;
        }

        pstmFilter = NULL;

        pGeneralPage->SetNotifyHandle(handle, TRUE);
        pFilterPage->SetNotifyHandle(handle, FALSE);

        ZeroMemory(&psp, sizeof psp);

        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_USECALLBACK;
        psp.hInstance   = g_hinst;
        psp.pfnDlgProc  = CPropSheetPage::DlgProc;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_GENERAL);
        psp.lParam      = (LPARAM) pGeneralPage;
        psp.pfnCallback = PropSheetCallback;

        //
        // Create and add the General page
        //

        hGeneralPage = CreatePropertySheetPage(&psp);

        if (!hGeneralPage)
        {
            DBG_OUT_LASTERROR;
            hr = E_FAIL;
            break;
        }

        hr = lpProvider->AddPage(hGeneralPage);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            VERIFY(DestroyPropertySheetPage(hGeneralPage));
            break;
        }

        fAddedGeneralPage = TRUE;

        //
        // Create and add the Filter page
        //

        psp.pszTemplate = MAKEINTRESOURCE(IDD_FILTER);
        psp.lParam      = (LPARAM) pFilterPage;

        hFilterPage = CreatePropertySheetPage(&psp);

        if (!hFilterPage)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        hr = lpProvider->AddPage(hFilterPage);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            VERIFY(DestroyPropertySheetPage(hFilterPage));
            break;
        }
    } while (0);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);

        if (pstmGeneral)
        {
            pstmGeneral->Release();
        }

        if (pstmFilter)
        {
            pstmFilter->Release();
        }

        if (!fAddedGeneralPage)
        {
            delete pGeneralPage;
        }
        delete pFilterPage;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::QueryPagesFor
//
//  Synopsis:   Return S_OK if we have one or more property pages for the
//              item represented by [lpDataObject], or S_FALSE if we
//              have no pages to contribute.
//
//  Returns:    S_OK or S_FALSE.
//
//  History:    12-13-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CComponentData::QueryPagesFor(
    LPDATAOBJECT lpDataObject)
{
    TRACE_METHOD(CComponentData, QueryPagesFor);

    CDataObject *pdo = ExtractOwnDataObject(lpDataObject);

    //
    // If this isn't a data object we created, ignore it.
    //

    if (!pdo)
    {
        return S_FALSE;
    }

    //
    // Cookie represents either the static node or a log folder.  If it's a
    // log folder that is not disabled, then yes, we have the general and
    // filter pages.
    //

    if (pdo->GetCookieType() == COOKIE_IS_LOGINFO)
    {
        CLogInfo * pli = (CLogInfo *) pdo->GetCookie();
        ASSERT(IsValidLogInfo(pli));

#if (DBG == 1)

        //
        // The log prop sheet will allow the user to attempt to change log
        // settings if the log isn't marked as disabled.  Since being
        // disabled implies being readonly, it should be safe to open the
        // property sheet even if the log is disabled.
        //

        // JonN 4/28/01 377513
        // corrupted eventlogs do not have
        //    "clear" and "properties" in popup menu
        // Skip this test; corrupt eventlogs are disabled but not read-only
        /*
        if (!pli->IsEnabled())
        {
            ASSERT(pli->IsReadOnly());
        }
        */
#endif // (DBG == 1)

        //
        // If we've already got a prop sheet open, don't open another.
        //

        HRESULT hr = _pPrshtProvider->FindPropertySheet((MMC_COOKIE)pli, NULL, lpDataObject);

        if (hr == S_OK)
        {
            return S_FALSE;
        }

        return S_OK;
    }

    //
    // Cookie represents static node.  If the context is the snapin manager,
    // then the snapin manager wizard is asking us for a page, and we have
    // do have one: the local/remote machine page.
    //

    ASSERT(pdo->GetCookieType() == COOKIE_IS_ROOT);

    if (pdo->GetContext() == CCT_SNAPIN_MANAGER)
    {
        return S_OK;
    }

    //
    // No property pages on the static node in the scope pane.
    //

    ASSERT(pdo->GetContext() == CCT_SCOPE);
    return S_FALSE;
}




//============================================================================
//
// IExtendContextMenu implementation
//
//============================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::AddMenuItems
//
//  Synopsis:   Add context menu items for object described by
//              [pDataObject].
//
//  Arguments:  [pDataObject]       - describes object for which to add context
//                                      menu items
//              [pCallback]         - callback used to create items
//              [pInsertionAllowed] - on input, specifies which insertion
//                                      points may be used.  If we're
//                                      running as primary snapin, then on
//                                      output cleared insertion points
//                                      will prevent extensions from adding
//                                      at that point.
//
//  Returns:    HRESULT
//
//  History:    1-20-1997   DavidMun   Created
//
//  Notes:      IComponent implementation delegates to this function, so
//              [pDataObject] may describe an event record.
//
//---------------------------------------------------------------------------

STDMETHODIMP
CComponentData::AddMenuItems(
    LPDATAOBJECT pDataObject,
    LPCONTEXTMENUCALLBACK pCallback,
    long *pInsertionAllowed)
{
    HRESULT hr = S_OK;

    //
    // Look at the data object and determine in what context menu items need
    // to be added.
    //

    CDataObject *pdo = ExtractOwnDataObject(pDataObject);

    if (!pdo)
    {
        return hr;
    }

    switch (pdo->GetContext())
    {
    case CCT_SCOPE:
    {
        //
        // We need to add items appropriate to something in the scope pane.
        // The cookie should represent one of our folders, either the static
        // node or one of our child folders.
        //

        if (pdo->GetCookieType() == COOKIE_IS_ROOT)
        {
            hr = _AddRootFolderContextMenuItems(pCallback,
                                                *pInsertionAllowed);
        }
        else
        {
            CLogInfo *pli = (CLogInfo*)pdo->GetCookie();

            ASSERT(pdo->GetCookieType() == COOKIE_IS_LOGINFO);
            ASSERT(IsValidLogInfo(pli));

            _UpdateCMenuItems(pli);
            hr = _AddChildFolderContextMenuItems(pCallback,
                                                 *pInsertionAllowed,
                                                 CCT_SCOPE);
        }
        break;
    }

    case CCT_RESULT:

        //
        // Add context menu items appropriate for either an event record
        // (currently there are none) or a child folder.  We should never
        // be called for the root node.
        //
        // Even if the user clicks on the root node in the scope pane, it
        // comes in as a CCT_SCOPE context. (TODO: this is a console bug,
        // change this code if the console bug is fixed.)
        //

        if (pdo->GetCookieType() == COOKIE_IS_LOGINFO)
        {
            ASSERT(IsValidLogInfo((CLogInfo *)pdo->GetCookie()));
            _UpdateCMenuItems((CLogInfo *)pdo->GetCookie());
            hr = _AddChildFolderContextMenuItems(pCallback,
                                                 *pInsertionAllowed,
                                                 CCT_RESULT);
        }
#if (DBG == 1) && (DBG_DUMP == 1)
        else
        {
            ASSERT(pdo->GetCookieType() == COOKIE_IS_RECNO);

            CMENUITEM amiDump[] =
            {
                {
                    IDS_CMENU_DUMP_RECORD,
                    IDS_SBAR_DUMP_RECORD,
                    IDM_DUMP_RECORD,
                    CCM_INSERTIONALLOWED_TASK,
                    CCM_INSERTIONPOINTID_PRIMARY_TASK,
                    MFS_ENABLED,
                    0
                },

                {
                    IDS_CMENU_DUMP_RECLIST,
                    IDS_SBAR_DUMP_RECLIST,
                    IDM_DUMP_RECLIST,
                    CCM_INSERTIONALLOWED_TASK,
                    CCM_INSERTIONPOINTID_PRIMARY_TASK,
                    MFS_ENABLED,
                    0
                },

                {
                    IDS_CMENU_DUMP_LIGHTCACHE,
                    IDS_SBAR_DUMP_LIGHTCACHE,
                    IDM_DUMP_LIGHTCACHE,
                    CCM_INSERTIONALLOWED_TASK,
                    CCM_INSERTIONPOINTID_PRIMARY_TASK,
                    MFS_ENABLED,
                    0
                }
            };

            AddCMenuItem(pCallback, &amiDump[0]);
            AddCMenuItem(pCallback, &amiDump[1]);
            AddCMenuItem(pCallback, &amiDump[2]);
        }
#endif // (DBG == 1) && (DBG_DUMP == 1)
        break;

    case CCT_SNAPIN_MANAGER:
        ASSERT(FALSE);
        Dbg(DEB_TRACE, "AddMenuItems: SNAPIN_MGR cookie=%x\n", pdo->GetCookie());
        break;

    default:
        Dbg(DEB_ERROR,
            "AddMenuItems: Invalid context 0x%x\n",
            pdo->GetContext());
        break;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::Command
//
//  Synopsis:   Process command [lCommandID] performed on object
//              [pDataObject].
//
//  Arguments:  [lCommandID]  - command to perform
//              [pDataObject] - object on which to perform it
//
//  Returns:    E_INVALIDARG if lCommandID isn't recognized, S_OK otherwise
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CComponentData::Command(
    long lCommandID,
    LPDATAOBJECT pDataObject)
{
    TRACE_METHOD(CComponentData, Command);
    HRESULT hr = S_OK;
    CDataObject *pdo = ExtractOwnDataObject(pDataObject);

    if (!pdo)
    {
        return hr;
    }

    switch (lCommandID)
    {
    case IDM_COPY_VIEW:
    {
        CLogInfo *pli = (CLogInfo *) pdo->GetCookie();
        ASSERT(pli && IsValidLogInfo(pli)); // NULL == root
        _OnNewView(pli);
        break;
    }

    case IDM_CLEARLOG:
    {
        CLogInfo *pli = (CLogInfo *) pdo->GetCookie();
        ASSERT(IsValidLogInfo(pli));
        SAVE_TYPE SaveType;
        WCHAR wszSaveFilename[MAX_PATH];
        HWND hwndMmcFrame = NULL;

        hr = _pConsole->GetMainWindow(&hwndMmcFrame);
        CHECK_HRESULT(hr);
        hr = S_OK;

        LONG lr = PromptForLogClear(hwndMmcFrame,
                                    pli,
                                    &SaveType,
                                    wszSaveFilename,
                                    ARRAYLEN(wszSaveFilename));

        if (lr != IDCANCEL)
        {
            HRESULT hr2 = ClearLog((ULONG_PTR) pli,
                                   (ULONG) SaveType,
                                   (ULONG_PTR) wszSaveFilename);

            if (FAILED(hr2))
            {
                DBG_OUT_HRESULT(hr2);

                wstring msg = ComposeErrorMessgeFromHRESULT(hr2);

                ConsoleMsgBox(_pConsole,
                              IDS_CLEAR_FAILED,
                              MB_ICONERROR | MB_OK,
                              msg.c_str());
            }
        }
        break;
    }

    case IDM_SAVEAS:
    {
        HWND hwndMmcFrame = NULL;

        CLogInfo *pli = (CLogInfo *) pdo->GetCookie();
        ASSERT(IsValidLogInfo(pli));

        hr = _pConsole->GetMainWindow(&hwndMmcFrame);
        CHECK_HRESULT(hr);
        hr = S_OK;

        (void) _SaveAs(hwndMmcFrame, pli);
        break;
    }

    case IDM_VIEW_ALL:
    {
        CLogInfo *pli = (CLogInfo *) pdo->GetCookie();
        ASSERT(IsValidLogInfo(pli));

        pli->Filter(FALSE);
        g_SynchWnd.Post(ELSM_LOG_DATA_CHANGED,
                        LDC_FILTER_CHANGE,
                        reinterpret_cast<LPARAM>(pli));
        break;
    }

    case IDM_VIEW_FILTER:
    {
        CLogInfo *pli = (CLogInfo *) pdo->GetCookie();
        ASSERT(IsValidLogInfo(pli));

        //
        // The property sheet will post ELSM_LOG_DATA_CHANGED
        // if the filter is actually applied.
        //

        _InvokePropertySheet(pli, pDataObject);
        break;
    }

    case IDM_VIEW_FIND:
    {
        CLogInfo *pli = (CLogInfo *) pdo->GetCookie();
        ASSERT(pli && IsValidLogInfo(pli)); // NULL == root
        _OnFind(pli);
        break;
    }

    case IDM_VIEW_NEWEST:
        _pActiveSnapin->SetDisplayOrder(NEWEST_FIRST);
        break;

    case IDM_VIEW_OLDEST:
        _pActiveSnapin->SetDisplayOrder(OLDEST_FIRST);
        break;

    case IDM_RETARGET:
        ASSERT(!IsExtension());
        CChooserDlg::OnChooseTargetMachine(this, _hsiRoot, pDataObject);
        _UpdateRootDisplayName();
        break;

    case IDM_OPEN:
    {
        CLogInfo *pli = (CLogInfo *) pdo->GetCookie();

        if (pli)
        {
            ASSERT(IsValidLogInfo(pli));
            _OnOpenSavedLog(pli->GetLogSet());
        }
        else
        {
            //
            // Open was invoked on "Event Viewer" node.  Find the log set
            // associated with this node
            //

            CLogSet *pLogSet;

            for (pLogSet = _pLogSets; pLogSet; pLogSet = pLogSet->Next())
            {
                if (_hsiRoot == pLogSet->GetHSI())
                {
                    _OnOpenSavedLog(pLogSet);
                    break;
                }
            }
        }
        break;
    }

#if (DBG == 1)
    case IDM_DUMP_COMPONENTDATA:
    {
        _Dump();
        break;
    }

    case IDM_DUMP_LOGINFO:
    {
        CLogInfo *pli = (CLogInfo *) pdo->GetCookie();
        ASSERT(IsValidLogInfo(pli));
        pli->Dump();
        break;
    }

    case IDM_DUMP_RECLIST:
        _pActiveSnapin->DumpRecList();
        break;

    case IDM_DUMP_LIGHTCACHE:
        _pActiveSnapin->DumpLightCache();
        break;

    case IDM_DUMP_RECORD:
        _pActiveSnapin->DumpCurRecord();
        break;
#endif // (DBG == 1)

    default:
        Dbg(DEB_ERROR,
            "CComponentData::Command: Invalid command %uL\n",
            lCommandID);
        hr = E_INVALIDARG;
        break;
    }
    return hr;
}


DWORD CComponentData::AddConnection(
    /* [in] */ DWORD extconn,
    /* [in] */ DWORD reserved)
{
    TRACE_METHOD(CComponentData, AddConnection);
    return 0;
}

DWORD CComponentData::ReleaseConnection(
    /* [in] */ DWORD extconn,
    /* [in] */ DWORD reserved,
    /* [in] */ BOOL fLastReleaseCloses)
{
    TRACE_METHOD(CComponentData, ReleaseConnection);
    return 0;
}

//============================================================================
//
// Non-interface member function implementation
//
//============================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_AddChildFolderContextMenuItems
//
//  Synopsis:   Add the context menu items appropriate for a chile (log)
//              folder item.
//
//  Arguments:  [pCallback]           - callback for adding context menu item
//              [flAllowedInsertions] - CCM_INSERTIONALLOWED_*
//              [Context]             - indicates whether context menu is
//                                       being opened in the scope or the
//                                       result pane.
//
//  Returns:    HRESULT
//
//  History:    1-20-1997   DavidMun   Created
//              4-09-1997   DavidMun   Add flAllowedInsertions
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::_AddChildFolderContextMenuItems(
   LPCONTEXTMENUCALLBACK pCallback,
   ULONG flAllowedInsertions,
   DATA_OBJECT_TYPES Context)
{
    TRACE_METHOD(CComponentData, _AddChildFolderContextMenuItems);

    HRESULT hr = S_OK;
    CMENUITEM *pItem;

    // Insert scope-only items

    if (Context == CCT_SCOPE)
    {
        for (pItem = s_acmiChildFolderScope;
             pItem->idsMenu && SUCCEEDED(hr);
             pItem++)
        {
            if (pItem->flAllowed & flAllowedInsertions)
            {
                hr = AddCMenuItem(pCallback, pItem);
            }
        }
    }

    // Insert items which appear on context menu in both scope & result pane

    for (pItem = s_acmiChildFolderBoth;
         pItem->idsMenu && SUCCEEDED(hr);
         pItem++)
    {
        if (pItem->flAllowed & flAllowedInsertions)
        {
            hr = AddCMenuItem(pCallback, pItem);
        }
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_OnExpand
//
//  Synopsis:   MMCN_EXPAND handler, discovers all the event logs
//              under the eventlog key in the registry
//              and add a scope item for each of them.
//
//  Arguments:  [hsi] - HSCOPEITEM for expanded node
//              [lpDataObject] - expanded node
//
//  Returns:    HRESULT
//
//  History:    12-06-1996   DavidMun   Created
//
//  Notes:      This is called when opening a new snapin.
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::_OnExpand(
    HSCOPEITEM hsi,
    LPDATAOBJECT pDataObject,
    HWND hWnd) // EricB 1/24/02 bug 526145)
{
    TRACE_METHOD(CComponentData, _OnExpand);

    CDataObject *pdo = ExtractOwnDataObject(pDataObject);

    if (!pdo)
    {
        return _ScopePaneAddExtensionRoot(hsi, pDataObject);
    }

    // If this is not the root node, don't add children
    if (COOKIE_IS_ROOT != pdo->GetCookieType())
    {
        return S_OK;
    }

    // JonN 5/22/01 400340
    // comment out ASSERT( NULL == _hsiRoot || hsi == _hsiRoot );

    _hsiRoot = hsi;

    if (!_IsFlagSet(COMPDATA_EXTENSION))
    {
        //
        // treat standalone as a special case, its hsiParent is 0
        //
        HRESULT hr = _CreateLogSet(pDataObject, hsi, NULL);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            return hr;
        }
    }

     return _ScopePaneAddLogSet(hWnd);
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_CreateLogSet
//
//  Synopsis:   Create an CLogSet instance
//
//  History:    4-16-1999   LinanT   Created
//
//---------------------------------------------------------------------------
HRESULT
CComponentData::_CreateLogSet(
    LPDATAOBJECT pDataObject,
    HSCOPEITEM hsi,
    HSCOPEITEM hsiParent)
{
    TRACE_METHOD(CComponentData, _CreateLogSet);
    Dbg(DEB_TRACE, "CComponentData::_CreateLogSet pDataObject=%x, hsi=%x, hsiParent=%x\n",
        pDataObject, hsi, hsiParent);

    HRESULT hr = S_OK;
    BOOL bFound = false;

    HGLOBAL szExtendedNodeType = NULL;
    hr = ExtractFromDataObject(pDataObject,
                               RegisterClipboardFormat(CCF_SZNODETYPE),
                               sizeof(TCHAR) * STD_GUID_SIZE,
                               &szExtendedNodeType);
    if (FAILED(hr))
    {
      DBG_OUT_HRESULT(hr);
      return hr;
    }

    CLogSet *plsCur;
    for (plsCur = _pLogSets; plsCur; plsCur = plsCur->Next())
    {
        //
        // If an instance extending the same GUID already exists (e.g.,
        // loaded from persisted stream), update its parameters (e.g.,
        // hsi, hsiParent, pLogInfos).
        //
        // JonN 1/31/01 300327
        // This code does not successfully relink CLogSets related to
        // extended nodes.
        //
        if (!_wcsicmp((PWSTR)szExtendedNodeType, plsCur->GetExtendedNodeType()) &&
            plsCur->GetParentHSI() == hsiParent)
        {
            plsCur->SetHSI(hsi);
            plsCur->SetParentHSI(hsiParent);
            //
            // See if the snapin we're extending wants to specify what log
            // views and filters should appear in the scope pane.  If so, "load"
            // them from the data object.
            //
            if (_IsFlagSet(COMPDATA_EXTENSION))
            {
                plsCur->GetViewsFromDataObject(pDataObject);
            }

            bFound = true;
            break;
        }
    }

    if (!bFound)
    {
        //
        // Create a new CLogSet instance
        // Add it to _pLogSets
        //
        CLogSet *plsNew = new CLogSet(this);

        if (plsNew)
        {
            plsNew->SetHSI(hsi);
            plsNew->SetParentHSI(hsiParent);
            plsNew->SetExtendedNodeType((LPTSTR)szExtendedNodeType);

            //
            // See if the snapin we're extending wants to specify what log
            // views and filters should appear in the scope pane.  If so, "load"
            // them from the data object.
            //

            if (_IsFlagSet(COMPDATA_EXTENSION))
            {
                plsNew->GetViewsFromDataObject(pDataObject);
            }

            _AddLogSetToList(plsNew);
        }
        else
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
        }
    }

    GlobalFree(szExtendedNodeType);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_ScopePaneAddExtensionRoot
//
//  Synopsis:   Adds the Event Viewer root node in the extension case
//
//  Arguments:  [lpDataObject] - determines which snapin is expanded
//
//  Returns:    HRESULT
//
//  History:    11-18-1998   JonN       split from _PopulateRootNode
//
//  Notes:      This is called when opening a new snapin.
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::_ScopePaneAddExtensionRoot(
    HSCOPEITEM hsi,
    LPDATAOBJECT pDataObject)
{
    HRESULT hr = S_OK;

    //
    // We're an extension snapin.  Since we haven't been inserted using
    // the eventlog snapin wizard, the server focus hasn't been set.
    // Get the server focus from the data object.
    //

    _SetFlag(COMPDATA_EXTENSION);
    VERIFY( SUCCEEDED(_SetServerFocusFromDataObject(pDataObject)) );

    //
    // As an extension snapin, the loginfo nodes should be added
    // beneath an "event viewer" node.  Insert that node, and remember
    // it as the root of the event viewer namespace.
    //

    SCOPEDATAITEM sdi;

    ZeroMemory(&sdi, sizeof sdi);
    sdi.mask        = SDI_STR       |
                      SDI_PARAM     |
                      SDI_IMAGE     |
                      SDI_PARENT;
    sdi.relativeID  = hsi;
    sdi.displayname = MMC_CALLBACK;
    sdi.nImage      = IDX_SDI_BMP_FOLDER;
    sdi.nOpenImage  = IDX_SDI_BMP_FOLDER;
    sdi.lParam      = EXTENSION_EVENT_VIEWER_FOLDER_PARAM;

    hr = _pConsoleNameSpace->InsertItem(&sdi);

    if (SUCCEEDED(hr))
    {
        _hsiRoot = sdi.ID;

        hr = _CreateLogSet(pDataObject, sdi.ID, hsi);
    }
    else
    {
        DBG_OUT_HRESULT(hr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_ScopePaneAddLogSet
//
//  Synopsis:   Adds the LogInfo nodes under the root node
//
//  Returns:    HRESULT
//
//  History:    4-16-1999   LinanT  Updated
//
//  Notes:      This is called when expanding the root node.
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::_ScopePaneAddLogSet(HWND hWnd)
{
    TRACE_METHOD(CComponentData, _ScopePaneAddLogSet);

    HRESULT hr = S_OK;

    //
    // Locate the CLogSet instance corresponding to the root node we're expanding
    //
    // JonN 1/31/01 300327
    // This code does not successfully relink CLogSets related to
    // extended nodes.
    //
    CLogInfo *pLogInfos = NULL;

    CLogSet *plsCur = _pLogSets;
    for ( ; plsCur; plsCur = plsCur->Next())
    {
        if (plsCur->GetHSI() == _hsiRoot)
        {
            //
            // update its _pLogInfos
            //

            //
            // JonN 5/22/01 400340
            // Workaround:
            // Set the server focus to the server of the first loginfo
            //
            // I expect that there will still be problems with related
            // scenarios.  There simply should not be a _wszServerFocus
            // or _hsiRoot associated with the IComponentData.
            //
            if (_IsFlagSet(COMPDATA_EXTENSION) &&
                plsCur->GetLogInfos() &&
                plsCur->GetLogInfos()->GetLogServerName())
            {
                SetServerFocus( plsCur->GetLogInfos()->GetLogServerName() );
            }
            else
            {
                _UpdateCurFocusSystemRoot();
            }

            hr = plsCur->MergeLogInfos(hWnd);

            if (FAILED(hr))
            {
              DBG_OUT_HRESULT(hr);
              return hr;
            }

            pLogInfos = plsCur->GetLogInfos();
            break;
        }
    }

    //
    // Add its _pLogInfos to scope pane
    //

    CLogInfo *pliCur = pLogInfos;
    for ( ; pliCur; pliCur = pliCur->Next())
    {
        _AddLogInfoToScopePane(pliCur);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_AddLogInfoToScopePane
//
//  Synopsis:   Add an item to the scope pane with a cookie of [pli]
//
//  Arguments:  [pli] - LogInfo to add
//
//  Returns:    HRESULT
//
//  History:    4-07-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::_AddLogInfoToScopePane(
    CLogInfo *pli)
{
    TRACE_METHOD(CComponentData, _AddLogInfoToScopePane);

    ASSERT(IsValidLogInfo(pli));

    HRESULT hr = S_OK;
    SCOPEDATAITEM sdi;

    ZeroMemory(&sdi, sizeof sdi);
    sdi.mask        = SDI_STR           |
                          SDI_PARAM     |
                          SDI_IMAGE     |
                          SDI_OPENIMAGE |
                          SDI_CHILDREN  |
                          SDI_PARENT;
    sdi.relativeID  = _hsiRoot;

    if (pli->IsEnabled())
    {
        sdi.nImage      = IDX_SDI_BMP_LOG_CLOSED;
        sdi.nOpenImage  = IDX_SDI_BMP_LOG_OPEN;
    }
    else
    {
        sdi.nImage      = IDX_SDI_BMP_LOG_DISABLED;
        sdi.nOpenImage  = IDX_SDI_BMP_LOG_DISABLED;
    }
    sdi.displayname = MMC_CALLBACK;
    sdi.lParam = (LPARAM) pli;

    hr = _pConsoleNameSpace->InsertItem(&sdi);

    if (SUCCEEDED(hr))
    {
        pli->SetHSI(sdi.ID);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_RemoveLogSetFromScopePane
//
//  Synopsis:   Removes the root node from the scope pane
//
//  History:    4-16-1999  LinanT       Created
//
//---------------------------------------------------------------------------
VOID
CComponentData::_RemoveLogSetFromScopePane(HSCOPEITEM hsiParent)
{
    TRACE_METHOD(CComponentData, _RemoveLogSetFromScopePane);

    CLogSet *plsNext = _pLogSets;
    CLogSet *plsCur;

    while (plsNext)
    {
      plsCur = plsNext;
      plsNext = plsCur->Next();

      if (hsiParent == plsCur->GetParentHSI())
      {
          ASSERT( NULL != plsCur->GetHSI() );

          //
          // Remove the extension root node from scope pane.
          // In case of standalone, the root node cannot be deleted (static),
          // only its children (i.e., loginfo nodes) are deletable.
          //
          if (_IsFlagSet(COMPDATA_EXTENSION))
              _pConsoleNameSpace->DeleteItem(plsCur->GetHSI(), TRUE);

          //
          // remove it from _pLogSets
          //
          _RemoveLogSetFromList(plsCur);

          //
          // destroy the CLogSet instance, which will
          // 1. remove related loginfos from scope pane
          // 2. destroy related loginfos
          //
          delete plsCur;
      }
    }

}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::DeleteLogInfo
//
//  Synopsis:   Removes the loginfo from the scope pane
//
//  History:    4-16-1999  LinanT       Created
//
//---------------------------------------------------------------------------
void
CComponentData::DeleteLogInfo(CLogInfo *pli)
{
    //
    // Notify all snapins log info pli is going away
    //

    CSnapin *pCur;
    for (pCur = _pSnapins; pCur; pCur = pCur->Next())
    {
        pCur->HandleLogDeletion(pli);
    }

    //
    // Delete it from scope pane
    //

    _pConsoleNameSpace->DeleteItem(pli->GetHSI(), TRUE);
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_AddRootFolderContextMenuItems
//
//  Synopsis:   Add the context menu items appropriate for the static node
//              context menu.
//
//  Arguments:  [pCallback]           - callback for adding context menu item
//              [flAllowedInsertions] - CCM_INSERTIONALLOWED_*
//
//  Returns:    HRESULT
//
//  History:    1-20-1997   DavidMun   Created
//              4-09-1997   DavidMun   Add flAllowedInsertions
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::_AddRootFolderContextMenuItems(
    LPCONTEXTMENUCALLBACK pCallback,
    ULONG flAllowedInsertions)
{
    TRACE_METHOD(CComponentData, _AddRootFolderContextMenuItems);

    HRESULT hr = S_OK;
    CMENUITEM *pItem;

    for (pItem = (IsExtension()) ? s_acmiExtensionRootFolder : s_acmiRootFolder;
         pItem->idsMenu && SUCCEEDED(hr);
         pItem++)
    {
        if (pItem->flAllowed & flAllowedInsertions)
        {
            hr = AddCMenuItem(pCallback, pItem);
        }
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::CComponentData
//
//  Synopsis:   ctor
//
//  History:    4-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CComponentData::CComponentData():
    _cRefs(1),
    _pSnapins(NULL),
    _pLogSets(NULL),
    _pActiveSnapin(NULL),
    _pConsole(NULL),
    _pPrshtProvider(NULL),
    _pConsoleNameSpace(NULL),
    _pStringTable(NULL),
    _hsiRoot(NULL),
    _ulNextNodeId(1)
{
    TRACE_CONSTRUCTOR(CComponentData);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentData);

    _wszServerFocus[0] = L'\0';     // default to local machine
    _wszCurFocusSystemRoot[0] = L'\0';
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::UpdateScopeBitmap
//
//  Synopsis:   Change the scope pane bitmaps for loginfo [lParam] to match
//              the loginfo's current state (enabled or disabled).
//
//  Arguments:  [lParam] - CLogInfo *
//
//  History:    4-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CComponentData::UpdateScopeBitmap(
    LPARAM lParam)
{
    TRACE_METHOD(CComponentData, UpdateScopeBitmap);

    CLogInfo *pli = (CLogInfo *) lParam;
    ASSERT(IsValidLogInfo(pli));

    HRESULT hr;
    SCOPEDATAITEM sdi;

    ZeroMemory(&sdi, sizeof sdi);

    sdi.mask        = SDI_IMAGE | SDI_OPENIMAGE | SDI_PARENT;
    sdi.ID          = pli->GetHSI();
    sdi.relativeID  = _hsiRoot;

    if (pli->IsEnabled())
    {
        sdi.nImage      = IDX_SDI_BMP_LOG_CLOSED;
        sdi.nOpenImage  = IDX_SDI_BMP_LOG_OPEN;
    }
    else
    {
        sdi.nImage      = IDX_SDI_BMP_LOG_DISABLED;
        sdi.nOpenImage  = IDX_SDI_BMP_LOG_DISABLED;
    }

    hr = _pConsoleNameSpace->SetItem(&sdi);
    CHECK_HRESULT(hr);
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_ClearLogSets
//
//  Synopsis:   This MMCN_REMOVE_CHILDREN handler removes all the nodes
//              and information added by the extension snapin.
//
//  Arguments:  [lpDataObject] - determines which snapin is removed
//
//  Returns:    HRESULT
//
//  History:    11-05-1998   JonN       Created
//
//  Notes:      This is called when the parent snapin retargets or closes.
//
//---------------------------------------------------------------------------
HRESULT CComponentData::_ClearLogSets()
{
    //
    // Release every remaining cookie once.
    //

    CLogSet *pls;

    for (pls = _pLogSets; pls; )
    {
        CLogSet *plsNext = pls->Next();

        delete pls;

        pls = plsNext;
    }
    _pLogSets = NULL;

    return S_OK;
}



//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::~CComponentData
//
//  Synopsis:   dtor
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CComponentData::~CComponentData()
{
    TRACE_DESTRUCTOR(CComponentData);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentData);

    // JonN 8/20/01 458926
    // MMC-Event Viewer: AV when use "New TaskPad View"
    // Code moved from destructor to Destroy()
}




//+--------------------------------------------------------------------------
//
//  Function:   PromptForLogClear
//
//  Synopsis:   Ask the user to confirm a log clear command, whether to save
//              the log before clearing, and if so, to what filename and in
//              what type.
//
//  Arguments:  [hwndParent]      - parent window for confirm & filename
//                                   dialogs
//              [pli]             - loginfo of log being cleared
//              [pSaveType]       - Filled with type of save requested
//              [wszSaveFilename] - Filled with filename for saved log
//              [cchSaveFilename] - size, in wchars, of [wszSaveFilename].
//
//  Returns:    IDCANCEL - do not clear log
//              IDYES    - save to [wszSaveFilename] using [pSaveType]
//                          before clearing
//              IDNO     - clear without saving
//
//  Modifies:   *[pSaveType], *[wszSaveFilename]
//
//  History:    06-23-1997   DavidMun   Created
//
//  Notes:      This UI work is separated from CComponentData::ClearLog in
//              case the caller is running in a different thread than
//              ClearLog.
//
//              Specifically, if the caller is the General property sheet
//              page, then its UI must be all in the same thread.  This is
//              required by the CloseEventViewerChildDialogs routine,
//              which enumerates and closes thread windows.
//
//              The purpose of that routine is to automatically close all
//              message boxes & dialogs still open when the component is
//              being destroyed.
//
//---------------------------------------------------------------------------

LONG
PromptForLogClear(
    HWND hwndParent,
    CLogInfo *pli,
    SAVE_TYPE *pSaveType,
    LPWSTR wszSaveFilename,
    ULONG cchSaveFilename)
{
    //
    // Discourage user from popping up other instances of clear/save until the
    // current one is done.  User can still go to another view (or another
    // machine!), and log can always be cleared asynchronously, so the
    // clear/save code must be written with the knowledge that concurrent
    // clear and save operations cannot be prevented.
    //

    s_acmiChildFolderBoth[MNU_TOP_CLEAR_ALL].flMenuFlags =
        MFS_DISABLED | MF_GRAYED;
    s_acmiChildFolderBoth[MNU_TOP_SAVE_AS].flMenuFlags =
        MFS_DISABLED | MF_GRAYED;

    *pSaveType = SAVEAS_NONE;

    LONG lr = MsgBox((HWND)hwndParent,
                     IDS_CLEAR_CONFIRM,
                     MB_YESNOCANCEL | MB_ICONQUESTION,
                     pli->GetDisplayName());

    if (lr == IDYES)
    {
        HRESULT hr = GetSaveFileAndType(hwndParent,
                                        pli,
                                        pSaveType,
                                        wszSaveFilename,
                                        cchSaveFilename);

        //
        // If user hit cancel in save dialog (hr == S_FALSE) or there was an
        // error, bail.
        //

        if (hr != S_OK)
        {
            lr = IDCANCEL;
        }
    }

    s_acmiChildFolderBoth[MNU_TOP_CLEAR_ALL].flMenuFlags = MFS_ENABLED;
    s_acmiChildFolderBoth[MNU_TOP_SAVE_AS  ].flMenuFlags = MFS_ENABLED;

    return lr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::ClearLog
//
//  Synopsis:   Delete all records in log represented by [pli].
//
//  Arguments:  [ul_pli]             - CLogInfo identifying log to clear
//              [ul_SaveType]        - whether and how to save
//              [ul_wszSaveFilename] - ignored if [ul_SaveType] is
//                                      SAVEAS_NONE
//
//  Returns:    S_FALSE - user cancelled operation
//              S_OK    - log cleared
//              E_*     - failure
//
//  History:    01-20-1997   DavidMun   Created
//              06-23-1997   DavidMun   Move ui components to caller
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::ClearLog(
    ULONG_PTR ul_pli,
    ULONG ul_SaveType,
    ULONG_PTR ul_wszSaveFilename)
{
    TRACE_METHOD(CComponentData, ClearLog);

    HRESULT     hr = S_OK;
    CEventLog   logTemp;

    //
    // Save typing by aliasing the input arguments with vars of the correct
    // type.
    //

    CLogInfo   *pli = (CLogInfo *) ul_pli;
    LPWSTR      wszSaveFilename = (LPWSTR) ul_wszSaveFilename;
    SAVE_TYPE   SaveType = (SAVE_TYPE) ul_SaveType;

    do
    {
        if (SaveType != SAVEAS_NONE)
        {
            //
            // If we're to save as a tab or comma delimited file, do so now.
            // Otherwise we can save as a log file in the process of clearing.
            //

            if (SaveType != SAVEAS_LOGFILE)
            {
                DIRECTION Direction = BACKWARD;

                if (_pActiveSnapin &&
                    _pActiveSnapin->GetSortOrder() == OLDEST_FIRST)
                {
                    Direction = FORWARD;
                }

                hr = pli->SaveLogAs(SaveType, wszSaveFilename, Direction);

                if (FAILED(hr))
                {
                    DisplayLogAccessError(hr, _pConsole, pli);
                    break;
                }
            }
        }

        //
        // OK to clear log, which has already been saved
        //

        hr = logTemp.Open(pli);

        if (SUCCEEDED(hr))
        {
            hr = logTemp.Clear(SaveType == SAVEAS_LOGFILE ?
                                    wszSaveFilename       :
                                    NULL);

            //
            // JonN 4/26/01 377513
            // corrupted eventlogs do not have
            //   "clear" and "properties" in popup menu
            // Now that the corrupt log has been cleared, re-enable it
            //
            if (SUCCEEDED(hr) && !pli->IsEnabled())
            {
                pli->Enable(TRUE);
            }

        }
        else
        {
            //
            // If the log couldn't be opened because of insufficient
            // access, disable it.
            //

            if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
            {
                pli->Enable(FALSE);
                pli->SetReadOnly(TRUE);
                PostScopeBitmapUpdate(this, pli);
            }
            DisplayLogAccessError(hr, _pConsole, pli);
        }
    } while (0);

    //
    // If the event log just cleared is being displayed, the display must be
    // updated.  If in addition to being displayed, there is an inspector open
    // on one of the events in the log to be cleared, then that inspector must
    // be notified that it's now open on an empty log.
    //

    if (SUCCEEDED(hr) && hr != S_FALSE)
    {
        g_SynchWnd.Post(ELSM_LOG_DATA_CHANGED,
                        LDC_CLEARED,
                        reinterpret_cast<LPARAM>(pli));
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_CreateWizardPage
//
//  Synopsis:   Add the local/remote machine selection page.
//
//  Arguments:  [lpProvider] -
//              [handle]     -
//
//  Returns:    HRESULT
//
//  History:    1-29-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::_CreateWizardPage(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle)
{
    HRESULT             hr = S_OK;
    PROPSHEETPAGE       psp;
    HPROPSHEETPAGE      hWizardPage = NULL;
    CWizardPage        *pWizardPage = new CWizardPage(this);

    do
    {
        if (!pWizardPage)
        {
            hr = E_OUTOFMEMORY;
            MMCFreeNotifyHandle(handle);
            break;
        }

        pWizardPage->SetNotifyHandle(handle, TRUE);

        ZeroMemory(&psp, sizeof psp);

        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_USECALLBACK;
        psp.hInstance   = g_hinst;
        psp.pfnDlgProc  = CPropSheetPage::DlgProc;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_CHOOSE_MACHINE);
        psp.lParam      = (LPARAM) pWizardPage;
        psp.pfnCallback = PropSheetCallback;

        //
        // Create and add the Wizard page
        //

        hWizardPage = CreatePropertySheetPage(&psp);

        if (!hWizardPage)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        hr = lpProvider->AddPage(hWizardPage);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            VERIFY(DestroyPropertySheetPage(hWizardPage));
            break;
        }
    } while (0);
    return hr;
}




#if (DBG == 1)
//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_Dump
//
//  Synopsis:   Dump information about this object to the debugger.
//
//  History:    06-04-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CComponentData::_Dump()
{
    Dbg(DEB_FORCE, "CComponentData(%x):\n", this);
    Dbg(DEB_FORCE, "  _cRefs                 = %uL\n",  _cRefs);
    Dbg(DEB_FORCE, "  _flFlags               = 0x%x\n", _flFlags);
    Dbg(DEB_FORCE, "  _pSnapins              = 0x%x\n", _pSnapins);
    Dbg(DEB_FORCE, "  _pActiveSnapin         = 0x%x\n", _pActiveSnapin);
    Dbg(DEB_FORCE, "  _pLogSets           = 0x%x\n", _pLogSets);
    Dbg(DEB_FORCE, "  _wszServerFocus        = '%s'\n", _wszServerFocus);
    Dbg(DEB_FORCE, "  _wszCurFocusSystemRoot    = '%s'\n", _wszCurFocusSystemRoot);
    Dbg(DEB_FORCE, "  _hsiRoot               = 0x%x\n", _hsiRoot);
    Dbg(DEB_FORCE, "  _pConsole              = 0x%x\n", _pConsole);
    Dbg(DEB_FORCE, "  _pConsoleNameSpace     = 0x%x\n", _pConsoleNameSpace);
    Dbg(DEB_FORCE, "  _pPrshtProvider        = 0x%x\n", _pPrshtProvider);
}
#endif // (DBG == 1)




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_InvokePropertySheet
//
//  Synopsis:   Pop up a property sheet on folder represented by [pli].
//
//  Arguments:  [pli]     - folder for which propsheet should be
//                                  displayed
//              [pDataObject] - data object corresponding to [pli]
//
//  Returns:    HRESULT
//
//  History:    1-20-1997   DavidMun   Created
//
//  Notes:      If a property sheet is already open on [pli], sets
//              focus to that.
//
//              This routine is used to bring up the folder prop sheet
//              in response to the View/Filter context menu command.
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::_InvokePropertySheet(
    CLogInfo *pli,
    LPDATAOBJECT pDataObject)
{
    TRACE_METHOD(CComponentData, _InvokePropertySheet);

    return InvokePropertySheet(_pPrshtProvider,
                               pli->GetDisplayName(),
                               (LONG) pli->GetHSI(),
                               pDataObject,
                               (IExtendPropertySheet*) this,
                               1);
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::IsValidLogInfo
//
//  Synopsis:   Return TRUE if [pCookieToCheck] is found in this object's
//              collection of cookies.
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CComponentData::IsValidLogInfo(
        const CLogInfo *pCookieToCheck)
{
    CLogSet *plsCur;
    CLogInfo *pliCur;

    for (plsCur = _pLogSets; plsCur; plsCur = plsCur->Next())
    {
      for (pliCur = plsCur->GetLogInfos(); pliCur; pliCur = pliCur->Next())
      {
          if (pCookieToCheck == pliCur)
          {
              ASSERT(pliCur->GetLogType() != ELT_INVALID);
              return TRUE;
          }
      }
    }

    Dbg(DEB_ERROR,
        "IsValidLogInfo: cookie pointer 0x%x not found in llist\n",
        pCookieToCheck);
    return FALSE;
}



//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_AddLogSetToList
//
//  Synopsis:   Insert [plsNew] into the linked list of logset objects.
//
//---------------------------------------------------------------------------
VOID
CComponentData::_AddLogSetToList(
    CLogSet *plsNew)
{
    if (!_pLogSets)
    {
        _pLogSets = plsNew;
    }
    else
    {
        plsNew->LinkAfter(_pLogSets);
    }
}

//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_RemoveLogSetFromList
//
//  Synopsis:   Remove [pls] from the linked list of logset objects.
//
//---------------------------------------------------------------------------
VOID
CComponentData::_RemoveLogSetFromList(
    CLogSet *pls)
{
    if (_pLogSets)
    {
      if (_pLogSets == pls)
        _pLogSets = pls->Next();

      pls->UnLink();
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::GetCurFocusSystemRoot
//
//  Synopsis:   Access function
//
//  History:    4-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LPCWSTR
CComponentData::GetCurFocusSystemRoot()
{
    return _wszCurFocusSystemRoot;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::GetCurrentFocus
//
//  Synopsis:   Access function for retrieving name of machine that this
//              instance of the viewer is pointed at.
//
//  History:    3-11-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LPCWSTR
CComponentData::GetCurrentFocus()
{
    //
    // If computer name override is allowed, and the user has specified one,
    // return the user's override, UNLESS the user has retargetted the
    // componentdata (see IDM_RETARGET), which, uh, overrides the override.
    //

    if (g_fMachineNameOverride
        && _IsFlagSet(COMPDATA_ALLOW_OVERRIDE)
        && !_IsFlagSet(COMPDATA_USER_RETARGETTED))
    {
        if (*g_wszMachineNameOverride)
        {
            return g_wszMachineNameOverride;
        }
        return NULL;
    }

    if (*_wszServerFocus)
    {
        return _wszServerFocus;
    }
    return NULL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_OnDelete
//
//  Synopsis:   Handle user's request to delete the loginfo contained in
//              [pDataObject].
//
//  Arguments:  [pDataObject] - describes user-created loginfo to delete
//
//  Returns:    HRESULT
//
//  History:    3-21-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::_OnDelete(
    LPDATAOBJECT pDataObject)
{
    TRACE_METHOD(CComponentData, _OnDelete);
    CDataObject *pdo = ExtractOwnDataObject(pDataObject);

    //
    // Let extensions decide whether foreign object can be deleted
    //

    if (!pdo)
    {
        return S_OK;
    }

    //
    // Do nothing if this is an extension and we're being removed
    //

    if (pdo->GetCookieType() == COOKIE_IS_ROOT)
    {
        ASSERT(IsExtension());
        return S_OK;
    }

    //
    // Delete the item from the scope pane, then delete it internally.
    //

    ASSERT(pdo->GetCookieType() == COOKIE_IS_LOGINFO);

    CLogInfo *pli = (CLogInfo *) pdo->GetCookie();
    ASSERT(IsValidLogInfo(pli));

    if (!pli->GetAllowDelete())
    {
        Dbg(DEB_ERROR,
            "CComponentData::_OnDelete: deletion of item 0x%x not allowed\n",
            pli);
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    if (_pConsoleNameSpace)
    {
        Dbg(DEB_ITRACE, "Deleting item %x\n", pli->GetHSI());
        hr = _pConsoleNameSpace->DeleteItem(pli->GetHSI(), TRUE);
        CHECK_HRESULT(hr);

        if (SUCCEEDED(hr))
        {
            CSnapin *pCur;

            //
            // Notify all snapins log info pli is going away
            //

            for (pCur = _pSnapins; pCur; pCur = pCur->Next())
            {
                pCur->HandleLogDeletion(pli);
            }

            //
            // Remove the loginfo from its associated CLogSet instance
            //
            CLogSet *pLogSet = pli->GetLogSet();
            if (pLogSet)
            {
                pLogSet->RemoveLogInfoFromList(pli);
            }

            pli->Release();
        }
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_OnFind
//
//  Synopsis:   Invoke the find dialog for the loginfo [pli].
//
//  Arguments:  [pli] - log info on which to invoke find.  must not be NULL
//
//  Returns:    HRESULT
//
//  History:    3-19-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::_OnFind(
    CLogInfo *pli)
{
    TRACE_METHOD(CComponentData, _OnFind);

    //
    // It should not be possible to invoke the find command without some
    // snapin window being active.
    //

    ASSERT(_pActiveSnapin);

    if (!_pActiveSnapin)
    {
        return E_UNEXPECTED;
    }

    //
    // Route the find request to the correct snapin
    //

    return _pActiveSnapin->OnFind(pli);
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_OnNewView
//
//  Synopsis:   Create a new loginfo which is a copy of [pli] and add it to
//              the scope pane.
//
//  Arguments:  [pli] - log info on which context menu item was invoked.
//
//  Returns:    HRESULT
//
//  History:    1-29-1997   DavidMun   Created
//              5-25-1999   davidmun   Recast as copy view
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::_OnNewView(
    CLogInfo *pliToCopy)
{
    TRACE_METHOD(CComponentData, _OnNewView);

    HRESULT     hr = S_OK;

    do
    {
        //
        // If we're in the process of shutting down, don't try to use any
        // console interfaces.
        //

        if (_IsFlagSet(COMPDATA_DESTROYED))
        {
            break;
        }

        CLogInfo    *pliNew = new CLogInfo(pliToCopy);

        if (!pliNew)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        pliNew->SetUserCreated();
        pliNew->SetAllowDelete(TRUE);

        CLogSet *pLogSet = pliToCopy->GetLogSet();

        if (pLogSet)
        {
            pLogSet->AddLogInfoToList(pliNew);
        }

        //
        // Modify name of copy with (n) to prevent any collisions
        // with names of existing log infos.
        //

        ULONG ulCopyNo = 2;
        WCHAR wzNewDisplayName[MAX_PATH];
        BOOL  fNameCollision;

        do
        {
            wsprintf(wzNewDisplayName,
                     L"%.200ws (%u)", // 256032
                     pliNew->GetDisplayName(),
                     ulCopyNo++);

            CLogInfo *pliCur;

            fNameCollision = FALSE;

            for (pliCur = pLogSet->GetLogInfos(); pliCur; pliCur = pliCur->Next())
            {
                // NTRAID#NTBUG9-2002/05/17-623723-ericb: prefast, don't use lstrcmpi
                if (!_wcsicmp(pliCur->GetDisplayName(), wzNewDisplayName))
                {
                    fNameCollision = TRUE;
                    break;
                }
            }
        } while (fNameCollision);

        pliNew->SetDisplayName(wzNewDisplayName);

        //
        // If the user has not expanded the static node yet, then we
        // won't have received the static node's scope pane handle (which
        // arrives in the MMCN_EXPAND notification).  If that is the case
        // don't try to put it in the scope pane; as soon as the user does
        // expand us, the new loginfo will be added by _OnExpand.
        //

        if (_hsiRoot)
        {
            SCOPEDATAITEM sdi;
            ZeroMemory(&sdi, sizeof sdi);

            sdi.mask        = SDI_STR           |
                                SDI_PARAM       |
                                SDI_IMAGE       |
                                SDI_OPENIMAGE   |
                                SDI_CHILDREN    |
                                SDI_PARENT;
            sdi.relativeID  = _hsiRoot;

            // JonN 9/25/01 469661
            // Event Viewer: wrong log icon for unavailable and
            // corrupted logs when use New Log View
            if (pliNew->IsEnabled())
            {
                sdi.nImage     = IDX_SDI_BMP_LOG_CLOSED;
                sdi.nOpenImage = IDX_SDI_BMP_LOG_OPEN;
            }
            else
            {
                sdi.nImage     = IDX_SDI_BMP_LOG_DISABLED;
                sdi.nOpenImage = IDX_SDI_BMP_LOG_DISABLED;
            }

            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM) pliNew;

            hr = _pConsoleNameSpace->InsertItem(&sdi);
            pliNew->SetHSI(sdi.ID);
            BREAK_ON_FAIL_HRESULT(hr);

            //
            // Make the node we just added to the scope pane the
            // currently selected node.  Failure is benign.
            //
#if (DBG == 1)
            HRESULT hr2 =
#endif // (DBG == 1)
                _pConsole->SelectScopeItem(sdi.ID);
            CHECK_HRESULT(hr2);
        }
    } while (0);

    return hr;
}



typedef struct OPENSAVEDLOGINFO
{
    WCHAR           wzDisplayName[MAX_PATH];
    // This modification is not necessary in W2K code. #256032
    wstring         wstrLogRegKeyName;
    WCHAR           wzLogServerName[MAX_PATH];

    // corresponds to CLogInfo LOGINFO_FLAG_USE_LOCAL_REGISTRY
    BOOL            fUseLocalRegistry;

    EVENTLOGTYPE    LogType;
} *POPENSAVEDLOGINFO;



//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_OnOpenSavedLog
//
//  Synopsis:   Create a new log view for an archived log.
//
//  Arguments:  [pOwningSet] - log set into which new log info should be
//                              inserted.
//
//  History:    5-25-1999   davidmun   Created
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::_OnOpenSavedLog(
        CLogSet *pOwningSet)
{
    TRACE_METHOD(CComponentData, _OnOpenSavedLog);

    HRESULT             hr = S_OK;
    OPENFILENAME        ofn;
    HWND                hwndMmcFrame = NULL;
    WCHAR               wszFilters[MAX_PATH];
    WCHAR               wszFile[MAX_PATH] = L"";
    BOOL                fOk = TRUE;
    OPENSAVEDLOGINFO    osli;

    do
    {
        ZeroMemory(wszFilters, ARRAYLEN(wszFilters));
        ZeroMemory(&osli, sizeof osli);

        hr = _pConsole->GetMainWindow(&hwndMmcFrame);
        CHECK_HRESULT(hr);

        hr = LoadStr(IDS_OPENFILTER, wszFilters, ARRAYLEN(wszFilters));
        BREAK_ON_FAIL_HRESULT(hr);

        ZeroMemory(&ofn, sizeof ofn);
        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner = hwndMmcFrame;
        ofn.hInstance = g_hinst;
        ofn.lpstrFilter = wszFilters;
        ofn.nFilterIndex = 1;
        ofn.lpstrFile = wszFile;
        ofn.nMaxFile = ARRAYLEN(wszFile);
        ofn.Flags = OFN_ENABLETEMPLATE
                    | OFN_ENABLEHOOK
                    | OFN_EXPLORER
                    | OFN_PATHMUSTEXIST
                    | OFN_FILEMUSTEXIST
                    | OFN_HIDEREADONLY;
        ofn.lpTemplateName = MAKEINTRESOURCE(IDD_OPEN);
        ofn.lpfnHook = _OpenDlgHookProc;
        ofn.lCustData = (LPARAM) &osli;

        fOk = GetOpenFileName(&ofn);

        if (!fOk)
        {
            ULONG ulErr = CommDlgExtendedError();

            Dbg(DEB_ERROR, "GetOpenFileName %u\n", ulErr);
            break;
        }

        //
        // Got all data we need to open log.  Create a new node for it.
        //

        CLogInfo *pliNew = new CLogInfo(this,
                                        pOwningSet,
                                        osli.LogType,
                                        TRUE,
                                        osli.fUseLocalRegistry);

        if (!pliNew)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        pliNew->SetUserCreated();
        pliNew->SetAllowDelete(TRUE);
        pliNew->SetReadOnly(TRUE);
        pliNew->SetLogServerName(osli.wzLogServerName);
        pliNew->SetDisplayName(osli.wzDisplayName);
        // This modification is not necessary in W2K code. #256032.
        pliNew->SetLogName(osli.wstrLogRegKeyName.c_str());
        pliNew->SetFileName(wszFile);

        //
        // Add the node to the log set to which it should belong
        //

        pOwningSet->AddLogInfoToList(pliNew);

        //
        // Add the node to the namespace
        //

        if (_hsiRoot)
        {
            SCOPEDATAITEM sdi;
            ZeroMemory(&sdi, sizeof sdi);

            sdi.mask        = SDI_STR           |
                                SDI_PARAM       |
                                SDI_IMAGE       |
                                SDI_OPENIMAGE   |
                                SDI_CHILDREN    |
                                SDI_PARENT;
            sdi.relativeID  = _hsiRoot;
            sdi.nImage      = IDX_SDI_BMP_LOG_CLOSED;
            sdi.nOpenImage  = IDX_SDI_BMP_LOG_OPEN;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM) pliNew;

            hr = _pConsoleNameSpace->InsertItem(&sdi);
            pliNew->SetHSI(sdi.ID);
            BREAK_ON_FAIL_HRESULT(hr);

            //
            // Make the node we just added to the scope pane the
            // currently selected node.  Failure is benign.
            //

#if (DBG == 1)
            HRESULT hr2 =
#endif // (DBG == 1)
                _pConsole->SelectScopeItem(sdi.ID);
            CHECK_HRESULT(hr2);
        }
    } while (0);

    return hr;
}



class CLogTypeComboData
{
public:

    CLogTypeComboData(
        PCWSTR pwzRegKey,
        BOOL fLocal):
            _strRegKey(pwzRegKey),
            _fLocalMachineRegistry(fLocal) {};

    BOOL
    UseLocalMachineRegistry() const { return _fLocalMachineRegistry; };

    PCWSTR
    GetRegKey() const { return _strRegKey.c_str(); };

private:

    BOOL    _fLocalMachineRegistry;
    wstring _strRegKey;
};



//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_OpenDlgHookProc
//
//  Synopsis:   Callback for file open dialog.
//
//  Arguments:  Standard Windows.
//
//  Returns:    Varies per message.
//
//  History:    5-26-1999   davidmun   Created
//
//---------------------------------------------------------------------------

UINT_PTR CALLBACK
CComponentData::_OpenDlgHookProc(
    HWND hdlg,
    UINT uiMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    UINT uiHandled = 0;

    switch (uiMsg)
    {
    case WM_INITDIALOG:
    {
        WCHAR       wszUnspecified[MAX_PATH];

        LoadStr(IDS_UNSPECIFIED_TYPE,
                wszUnspecified,
                ARRAYLEN(wszUnspecified),
                L"(Unspecified)");
        ComboBox_AddString(GetDlgItem(hdlg, open_type_combo), wszUnspecified);
        ComboBox_SetCurSel(GetDlgItem(hdlg, open_type_combo), 0);
        break;
    }

    case WM_NOTIFY:
        switch (((NMHDR*)lParam)->code)
        {
        case CDN_INITDONE:

            //
            // fix up the tab order: make extension dialog come after file
            // filter combo.  Note doing this on receipt of WM_INITDIALOG
            // is too late and would have no effect.
            //

            SetWindowPos(hdlg,
                         GetDlgItem(GetParent(hdlg), cmb1),
                         0, 0, 0, 0,
                         SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

            {
                HWND hwndTool;

                // EricB 9/19/01: This code doesn't work, but the tab order works
                // OK nonetheless.
                hwndTool = FindWindowEx(GetParent(hdlg),
                                        GetDlgItem(GetParent(hdlg), cmb1),
                                        L"ToolbarWindow32",
                                        L"");

                if (hwndTool)
                {
                    SetWindowPos(hwndTool,
                                 GetDlgItem(GetParent(hdlg), cmb1),
                                 0, 0, 0, 0,
                                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

                    SetWindowPos(hdlg,
                                 hwndTool,
                                 0, 0, 0, 0,
                                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
                }
                else
                {
                    DBG_OUT_LASTERROR;
                }
            }
            break;

        case CDN_FILEOK:
        {
            //
            // Reject the attempt to close the Open dialog with OK if the
            // log type is (Unspecified).
            //

            HWND hwndType = GetDlgItem(hdlg, open_type_combo);
            int  iCurSel = ComboBox_GetCurSel(hwndType);

            if (!iCurSel)
            {
                MsgBox(hdlg, IDS_INVALID_TYPE, MB_OK | MB_ICONERROR);
                SetWindowLongPtr(hdlg, DWLP_MSGRESULT, 1);
                return 1;
            }

            OPENSAVEDLOGINFO *posli = (POPENSAVEDLOGINFO)
                                      ((OFNOTIFY*)lParam)->lpOFN->lCustData;

            //
            // Retrieve the saved log's display name, complain if it is
            // empty.
            //

            Edit_GetText(GetDlgItem(hdlg, open_display_name_edit),
                         posli->wzDisplayName,
                         ARRAYLEN(posli->wzDisplayName));

            StripLeadTrailSpace(posli->wzDisplayName);

            if (!*posli->wzDisplayName)
            {
                MsgBox(hdlg, IDS_NEED_DISPLAY_NAME, MB_OK | MB_ICONERROR);
                SetWindowLongPtr(hdlg, DWLP_MSGRESULT, 1);
                return 1;
            }

            //
            // Retrieve the saved log's registry key name and type
            //

            CLogTypeComboData *pltcd = (CLogTypeComboData*)
                ComboBox_GetItemData(hwndType, iCurSel);
            ASSERT(pltcd);

            posli->LogType = DetermineLogType(pltcd->GetRegKey());

            // This modification is not necessary in W2K code. #256032.
            posli->wstrLogRegKeyName.assign(pltcd->GetRegKey());

            //
            // Get flag indicating whether reg key is on local machine
            //

            posli->fUseLocalRegistry = pltcd->UseLocalMachineRegistry();

            //
            // Retrieve saved log's server (name of machine on which saved
            // log resides).  This is an empty string for the local machine.
            //

            _GetOpenSavedServer(hdlg, posli->wzLogServerName, ARRAYLEN(posli->wzLogServerName));
            break;
        }

        case CDN_SELCHANGE:
        case CDN_FOLDERCHANGE:
            // EricB 9/19/01 466453 Don't change log type and display name values unless
            // retargetted to a new server.
            _PopulateOpenSavedLogTypeCombo(hdlg);
            break;
        }
        break;

    case WM_COMMAND:
        switch (HIWORD(wParam))
        {
        case CBN_SETFOCUS:
            _PopulateOpenSavedLogTypeCombo(hdlg);
            break;

        case CBN_SELENDOK:
        {
            WCHAR   wzTypeStr[MAX_PATH];
            WCHAR   wzServer[MAX_PATH];

            _GetOpenSavedServer(hdlg, wzServer, ARRAYLEN(wzServer));

            ComboBox_GetText(GetDlgItem(hdlg, open_type_combo),
                             wzTypeStr,
                             ARRAYLEN(wzTypeStr));
            StripLeadTrailSpace(wzTypeStr);

            wstring wstrBuf;

            if (*wzServer)
            {
                wstrBuf = FormatString(IDS_DISPLAYNAME_ARCHIVED_REMOTE_FMT, wzTypeStr, wzServer);
            }
            else
            {
                wstrBuf = FormatString(IDS_DISPLAYNAME_ARCHIVED_LOCAL_FMT, wzTypeStr);
            }
            Edit_SetText(GetDlgItem(hdlg, open_display_name_edit),
                         wstrBuf.c_str());
            break;
        }
        }
        break;

    case WM_DESTROY:
        _ResetOpenSavedLogTypeCombo(GetDlgItem(hdlg, open_type_combo));
        break;

    case WM_CONTEXTMENU:
    case WM_HELP:
        InvokeWinHelp(uiMsg, wParam, lParam, HELP_FILENAME, s_aulHelpIds);
        break;

    default:
        break;
    }

    return uiHandled;
}


//+--------------------------------------------------------------------------
//
//  Function:   _GetOpenSavedServer
//
//  Synopsis:   Fill [wzServer] with the name of the server on which the
//              saved log file to open resides, or an empty string if the
//              saved log file is on the local machine.
//
//  Arguments:  [hdlg]     - common file open dialog handle
//              [wzServer] - filled with server name or L""
//
//  History:    5-28-1999   davidmun   Created
//  Modifies:   1/25/2001 Add wcchServer for #256032.
//---------------------------------------------------------------------------

void
_GetOpenSavedServer(
    HWND  hdlg,
    PWSTR wzServer,
    USHORT wcchServer)
{
    TRACE_FUNCTION(_GetOpenSavedServer);

    WCHAR   wzPath[MAX_PATH];
    HWND    hdlgParent = GetParent(hdlg);

    ASSERT(IsWindow(hdlg));
    ASSERT(wzServer);
    ASSERT(IsWindow(hdlgParent));

    //
    // Get the string in the edit control
    //

    GetDlgItemText(hdlgParent, cmb13, wzPath, ARRAYLEN(wzPath));
    StripLeadTrailSpace(wzPath);
    DeleteQuotes(wzPath);

    //
    // If the file is remote (UNC or on redirected drive) extract the server
    // name.
    //

    HRESULT hr = RemoteFileToServerAndUNCPath(wzPath, wzServer, wcchServer, NULL, 0);

    if (hr != S_OK)
    {
        //
        // Path doesn't specify server via UNC or remoted drive.  See if
        // the Open dialog's Look In control is pointing at a remote
        // location.
        //

        LRESULT lr = SendMessage(hdlgParent,
                                 CDM_GETFOLDERPATH,
                                 (WPARAM) ARRAYLEN(wzPath),
                                 (LPARAM) wzPath);
        if (lr <= 0)
        {
            DBG_OUT_LASTERROR;
        }

        hr = RemoteFileToServerAndUNCPath(wzPath, wzServer, wcchServer, NULL, 0);

        if (hr != S_OK)
        {
            // nope, the Look In is pointing to local machine

            wzServer[0] = L'\0';
        }
    }
    Dbg(DEB_TRACE, "Server is '%ws'\n", wzServer);
}




void
_ResetOpenSavedLogTypeCombo(
    HWND hwndTypeCombo)
{
    ULONG   cComboItems = ComboBox_GetCount(hwndTypeCombo);
    ULONG   i;

    for (i = 0; i < cComboItems; i++)
    {
        if (i)
        {
            delete (CLogTypeComboData *)ComboBox_GetItemData(hwndTypeCombo, i);
        }
        else
        {
        PWSTR pwz = (PWSTR)ComboBox_GetItemData(hwndTypeCombo, i);
        delete [] pwz;
        }
    }

    ComboBox_ResetContent(hwndTypeCombo);
}




//+--------------------------------------------------------------------------
//
//  Function:   _PopulateOpenSavedLogTypeCombo
//
//  Synopsis:   Refresh the log type combo if the server focus has changed.
//              Server focus is determined by the path in the file edit
//              control, or if there is no path there, the server indicated
//              by the Look In combobox.
//
//  Arguments:  [hdlg] - handle to custom dialog, a child of common file
//                          open dialog
//
//  History:    5-26-1999   davidmun   Created
//
//---------------------------------------------------------------------------

void
_PopulateOpenSavedLogTypeCombo(
    HWND hdlg)
{
    TRACE_FUNCTION(_PopulateOpenSavedLogTypeCombo);

    WCHAR   wzServer[MAX_PATH];

    // JonN 3/21/01 350614
    // Use message dlls and DS, FRS and DNS log types from specified computer
    if (*g_wszAuxMessageSource)
        lstrcpyn(wzServer, g_wszAuxMessageSource, ARRAYLEN(wzServer));
    else
        _GetOpenSavedServer(hdlg, wzServer, ARRAYLEN(wzServer));

    //
    // wzServer is the machine to check for log types.  (It is an empty
    // string if that machine is the local machine.)  If the types combo
    // is empty, this is the first call and we have to populate it.
    //
    // Otherwise, check the data stored with the first entry in the
    // types combo--it's the name of the last server used to populate
    // it.  If that server is the same as wzServer, no work needs to be
    // done.
    //

    HWND    hwndTypeCombo = GetDlgItem(hdlg, open_type_combo);
    ULONG   cComboItems = ComboBox_GetCount(hwndTypeCombo);

    if (cComboItems > 1)
    {
        PWSTR pwzComboServer = (PWSTR)ComboBox_GetItemData(hwndTypeCombo, 0);
        ASSERT(pwzComboServer);

        if (!_wcsicmp(pwzComboServer, wzServer))
        {
            Dbg(DEB_TRACE,
                "Type combo already populated from %ws, returning\n",
                *pwzComboServer ? pwzComboServer : L"local machine");
            return;
        }
    }

    //
    // Must populate type combo.
    //

    _ResetOpenSavedLogTypeCombo(hwndTypeCombo);

    HRESULT     hr = S_OK;
    CSafeReg    shkTargetEventLog;
    WCHAR       wszRemoteSystemRoot[MAX_PATH] = L"";

    do
    {
        CSafeReg    shkRemote;
        WCHAR       wszUnspecified[MAX_PATH];

        LoadStr(IDS_UNSPECIFIED_TYPE,
                wszUnspecified,
                ARRAYLEN(wszUnspecified),
                L"(Unspecified)");

        PWSTR pwzNewServer = new WCHAR[lstrlen(wzServer) + 1];

        if (!pwzNewServer)
        {
            DBG_OUT_HRESULT(E_OUTOFMEMORY);
            break;
        }

        lstrcpy(pwzNewServer, wzServer);
        ComboBox_AddString(hwndTypeCombo, wszUnspecified);
        ComboBox_SetCurSel(hwndTypeCombo, 0);
        ComboBox_SetItemData(hwndTypeCombo, 0, pwzNewServer);
        // EricB 9/19/01 466453 Don't change log type and display name values unless
        // retargetted to a new server.
        Edit_SetText(GetDlgItem(hdlg, open_display_name_edit), L"");

        if (*wzServer)
        {
            CWaitCursor Hourglass; // remote reg connect can be slow

            hr = shkRemote.Connect((LPWSTR)wzServer, HKEY_LOCAL_MACHINE);
            if (SUCCEEDED(hr))
            {
                hr = GetRemoteSystemRoot(shkRemote,
                                         wszRemoteSystemRoot,
                                         ARRAYLEN(wszRemoteSystemRoot));
                if (SUCCEEDED(hr))
                {
                    hr = shkTargetEventLog.Open(shkRemote,
                                                EVENTLOG_KEY,
                                                KEY_ENUMERATE_SUB_KEYS);
                }
            }
        }

        if (!*wzServer || !SUCCEEDED(hr))
        {
            // JonN 12/5/01 Fall back to retrieving from local machine
            wzServer[0] = L'\0';
            hr = shkTargetEventLog.Open(HKEY_LOCAL_MACHINE,
                                        EVENTLOG_KEY,
                                        KEY_ENUMERATE_SUB_KEYS);
        }
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // For each log registry key on the target machine, add a
        // (preferably localized) string to the log type combo.  Also add
        // the actual registry key name as a parameter, since later
        // we'll need that.
        //

        _AddRegKeysToLogTypeCombo(hwndTypeCombo,
                                  shkTargetEventLog,
                                  wzServer,
                                  wszRemoteSystemRoot,
                                  FALSE);
    } while (0);


    //
    // If the target machine is not the local machine, also add any
    // keys the local machine has which the target does not.
    //

    if (*wzServer)
    {
        shkTargetEventLog.Close();

        hr = shkTargetEventLog.Open(HKEY_LOCAL_MACHINE,
                                    EVENTLOG_KEY,
                                    KEY_ENUMERATE_SUB_KEYS);

        if (SUCCEEDED(hr))
        {
            _AddRegKeysToLogTypeCombo(hwndTypeCombo,
                                      shkTargetEventLog,
                                      L"",
                                      L"",
                                      TRUE);
        }
        else
        {
            DBG_OUT_HRESULT(hr);
        }
    }

}



/**
 * Adds entries for the event log registry keys under
 * <code>shkTargetEventLog</code> to the log type combobox.
 *
 * @param hwndTypeCombo
 *                 Handle to the log type combobox
 * @param shkTargetEventLog
 *                 Event log registry key open for enumeration
 * @param wzServer
 *                 Empty string for local machine or name of remote target
 * @param wszRemoteSystemRoot
 *                 If <code>wzServer</code> is not an empty string, contains the value of the
 *                 remote machine's SystemRoot environment variable.
 * @param fCheckForDuplicates
 *                 if nonzero, avoid adding any registry keys that are
 *                 already present in the combobox.
 */
VOID
_AddRegKeysToLogTypeCombo(
    HWND            hwndTypeCombo,
    const CSafeReg &shkTargetEventLog,
    PCWSTR          wzServer,
    PCWSTR          wszRemoteSystemRoot,
    BOOL            fCheckForDuplicates)
{
    TRACE_FUNCTION(_AddRegKeysToLogTypeCombo);

    HRESULT hr = S_OK;
    WCHAR   wzSubkeyName[MAX_PATH + 1]; // per SDK on RegEnumKey
    ULONG   idxSubkey;

    for (idxSubkey = 0; hr == S_OK; idxSubkey++)
    {
        hr = shkTargetEventLog.Enum(idxSubkey,
                                    wzSubkeyName,
                                    ARRAYLEN(wzSubkeyName));

        if (hr != S_OK) // S_FALSE means no more items
        {
            break;
        }

        if (fCheckForDuplicates)
        {
            ULONG   cComboItems = ComboBox_GetCount(hwndTypeCombo);
            ULONG   idxCombo;
            BOOL    fFoundDuplicate = FALSE;

            // skip first item, since it's "(Unspecified)"

            for (idxCombo = 1; idxCombo < cComboItems; idxCombo++)
            {
                CLogTypeComboData *pltcd = (CLogTypeComboData *)
                ComboBox_GetItemData(hwndTypeCombo, idxCombo);

                ASSERT(pltcd);

                if (!_wcsicmp(wzSubkeyName, pltcd->GetRegKey()))
                {
                    fFoundDuplicate = TRUE;
                    break;
                }
            }

            if (fFoundDuplicate)
            {
                continue;
            }
        }

        //
        // Try to get a localized string for the log's display name.
        // Note we always look on the local machine first, since the
        // remote machine's locale may differ from the local machine's.
        //

        LPWSTR pwzLogDisplayName = GetLogDisplayName(shkTargetEventLog,
                                                     wzServer,
                                                     wszRemoteSystemRoot,
                                                     wzSubkeyName);
        //
        // Add an entry for this log type
        //

        INT idxNewItem;

        CLogTypeComboData *pltcd = new CLogTypeComboData(wzSubkeyName,
                                                         *wzServer == L'\0');

        if (!pltcd)
        {
            if (pwzLogDisplayName)
            {
                LocalFree(pwzLogDisplayName);
                pwzLogDisplayName = NULL;
            }
            DBG_OUT_HRESULT(E_OUTOFMEMORY);
            continue;
        }

        if (pwzLogDisplayName)
        {
            idxNewItem = ComboBox_AddString(hwndTypeCombo, pwzLogDisplayName);
            LocalFree(pwzLogDisplayName);
            pwzLogDisplayName = NULL;
        }
        else
        {
            idxNewItem = ComboBox_AddString(hwndTypeCombo, wzSubkeyName);
        }

        ComboBox_SetItemData(hwndTypeCombo, idxNewItem, pltcd);
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_OnRefresh
//
//  Synopsis:   Force all snapins owned by this componentdata which are
//              viewing data in the log specified by [pDataObject] to
//              discard their caches and repopulate their result panes.
//
//  Arguments:  [pDataObject] - log to refresh views of, or record in
//                               log to refresh
//
//  Returns:    S_OK
//
//  History:    3-14-1997   DavidMun   Created
//              09-03-1997   DavidMun   Support refresh on result pane
//
//  Notes:      Implements the refresh by leveraging the code to handle
//              asynchronous changes in the event log.
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::_OnRefresh(
    LPDATAOBJECT pDataObject)
{
    TRACE_METHOD(CComponentData, _OnRefresh);

    CDataObject *pdo = ExtractOwnDataObject(pDataObject);

    if (pdo)
    {
        CLogInfo *pli;

        //
        // If user selected Refresh on a scope pane item, pdo contains the
        // log to refresh.  Otherwise pdo should have a record number in it,
        // and the active snapin's currently selected loginfo is the one to
        // refresh.
        //

        if (pdo->GetCookieType() == COOKIE_IS_LOGINFO)
        {
            pli = (CLogInfo *) pdo->GetCookie();
            ASSERT(IsValidLogInfo(pli));
        }
        else
        {
            ASSERT(pdo->GetCookieType() == COOKIE_IS_RECNO);

            _pActiveSnapin->GetCurSelLogInfo((ULONG_PTR) &pli);
            ASSERT(pli);
        }

        //
        // Clear out the global caches
        //

        g_SidCache.Clear();
        g_DllCache.Clear();

        //
        // Ask the loginfo to refresh itself
        //

        pli->Refresh();

        //
        // Tell the snapins that pli just got refreshed
        //

        NotifySnapinsLogChanged((WPARAM) LDC_CLEARED,
                                (LPARAM) pli,
                                FALSE);
    }
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_OnRename
//
//  Synopsis:   Handle a scope item rename request or notification
//
//  Arguments:  [lpDataObject] - item to be or which has been renamed
//              [fRenamed]     - FALSE if console is asking permission to
//                                rename
//              [pwszNewName]  - if [fRenamed] == TRUE, new name
//
//  Returns:    S_OK    - item may be renamed/item rename handled
//              S_FALSE - item may not be renamed
//
//  History:    4-19-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::_OnRename(
    LPDATAOBJECT lpDataObject,
    BOOL         fRenamed,
    LPWSTR       pwszNewName)
{
    HRESULT hr = S_OK;
    CDataObject *pdo = ExtractOwnDataObject(lpDataObject);

    if (!pdo)
    {
        return hr;
    }

    if (!fRenamed)
    {
        //
        // Console's asking if rename should be allowed.
        // Only loginfo scope items may be renamed.
        //

        if (pdo->GetCookieType() == COOKIE_IS_ROOT)
        {
            hr = S_FALSE;
        }
    }
    else
    {
        //
        // The rename has occurred.
        //

        CLogInfo *pli = (CLogInfo *) pdo->GetCookie();
        ASSERT(pdo->GetCookieType() == COOKIE_IS_LOGINFO);
        ASSERT(IsValidLogInfo(pli));

        pli->SetDisplayName(pwszNewName);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::NotifySnapinsLogChanged
//
//  Synopsis:   Handle a notification sent by the eventlog snapin to itself
//              via the hidden synchronized notification window.
//
//  Algorithm:  Iterate through the snapins owned by this componentdata and
//              notify each that the data for log identified by
//              [pliAffectedLog] has changed (so it can reset its cache and
//              result pane if it happens to be displaying that log).
//
//  Arguments:  [wParam]      - reason for notification
//              [lParam]      - identifies log whose data has changed.
//              [fNotifyUser] - TRUE if the first snapin owned by this
//                                should notify the user of a data change
//
//  Returns:    TRUE if user was notified, FALSE otherwise
//
//  History:    2-18-1997   DavidMun   Created
//
//  Notes:      When this member is called it is because the console's
//              message pump has dispatched a message to this snapin's
//              hidden window (see CSynchWindow class).  This means it is
//              safe to do things like empty the result pane.
//
//              CAUTION: [pliAffectedLog] may be owned by a different
//              instance of CComponentData than this.  If a user inserts
//              multiple Event Log snapins into the scope pane, any one of
//              them can detect a log change and post a message to the
//              global CSynchWindow object.
//
//---------------------------------------------------------------------------

BOOL
CComponentData::NotifySnapinsLogChanged(
    WPARAM wParam,
    LPARAM lParam,
    BOOL fNotifyUser)
{
    CLogInfo   *pliAffectedLog = (CLogInfo *) lParam;
    LOGDATACHANGE ldc = (LOGDATACHANGE) wParam;

    if (ldc == LDC_DISPLAY_NAME)
    {
        // 678734-2002/08/19-JonN
        // MMC in .NET Server no longer tolerates IConsoleNameSpace::GetItem()
        // with an invalid sdi.ID.  We add this additional check to make sure
        // that the loginfo has not been removed.
        if (!IsValidLogInfo(pliAffectedLog))
        {
            return FALSE;
        }

        SCOPEDATAITEM sdi;
        CLogInfo *pli = reinterpret_cast<CLogInfo *>(lParam);

        ZeroMemory(&sdi, sizeof sdi);
        sdi.mask        = SDI_PARAM;
        sdi.relativeID  = _hsiRoot;
        sdi.lParam      = lParam;
        sdi.ID          = pli->GetHSI();

        HRESULT hr = _pConsoleNameSpace->GetItem(&sdi);

        if (SUCCEEDED(hr))
        {
            sdi.mask        = SDI_STR           |
                                  SDI_PARAM     |
                                  SDI_IMAGE     |
                                  SDI_OPENIMAGE |
                                  SDI_PARENT;

            if (pli->IsEnabled())
            {
                sdi.nImage      = IDX_SDI_BMP_LOG_CLOSED;
                sdi.nOpenImage  = IDX_SDI_BMP_LOG_OPEN;
            }
            else
            {
                sdi.nImage      = IDX_SDI_BMP_LOG_DISABLED;
                sdi.nOpenImage  = IDX_SDI_BMP_LOG_DISABLED;
            }
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam = lParam;

            hr = _pConsoleNameSpace->SetItem(&sdi);
            CHECK_HRESULT(hr);
        }
        else
        {
            DBG_OUT_HRESULT(hr);
        }
        return FALSE;
    }

    CSnapin    *pCur;
    BOOL        fNotifiedUser = FALSE;

    for (pCur = _pSnapins; pCur; pCur = pCur->Next())
    {
        //
        // If we're supposed to notify the user and haven't done so yet,
        // let this snapin know it should pop up a msgbox if it processes
        // this log change (i.e., if its current selection ==
        // pliAffectedLog).
        //
        // Otherwise just tell the snapin to handle the change without
        // first alerting the user.
        //

        if (fNotifyUser && !fNotifiedUser)
        {
            fNotifiedUser = pCur->HandleLogChange(ldc,
                                                  pliAffectedLog,
                                                  fNotifyUser);
        }
        else
        {
            pCur->HandleLogChange(ldc, pliAffectedLog, FALSE);
        }
    }
    return fNotifiedUser;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::NotifySnapinsResetPending
//
//  Synopsis:   Ask all owned snapins that are currently displaying events
//              for log [pliAffected] to go into reset-pending mode (i.e.,
//              to turn on their SNAPIN_RESET_PENDING bit on).
//
//  Arguments:  [pliAffected] - log that is being reset
//
//  History:    2-19-1997   DavidMun   Created
//
//  Notes:      Typically this is called by a CSnapin instance just after
//              it has received ERROR_EVENTLOG_FILE_CHANGED while attempting
//              to read from the log.  Once the SNAPIN_RESET_PENDING bit is
//              set on all the other snapins of the component that are
//              focused on [pliAffected], they will avoid any operations
//              that read from the log.  This prevents multiple CSnapins
//              from causing a message to be posted to the synchronization
//              window.
//
//---------------------------------------------------------------------------

VOID
CComponentData::NotifySnapinsResetPending(
    CLogInfo *pliAffected)
{
    TRACE_METHOD(CComponentData, NotifySnapinsResetPending);

    CSnapin    *pCur;

    for (pCur = _pSnapins; pCur; pCur = pCur->Next())
    {
        pCur->ResetPending(pliAffected);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_SaveAs
//
//  Synopsis:   Prompt the user for the type and filename to save the log
//              as, then do the save.
//
//  Arguments:  [hwndParent] - NULL or parent window for save dialog
//              [pli]    - log to save
//
//  Returns:    HRESULT
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::_SaveAs(
    HWND hwndParent,
    CLogInfo *pli)
{
    HRESULT     hr = S_OK;
    SAVE_TYPE   SaveType = SAVEAS_NONE;
    WCHAR       wszSaveFilename[MAX_PATH + 1] = L"";

    hr = GetSaveFileAndType(hwndParent,
                            pli,
                            &SaveType,
                            wszSaveFilename,
                            ARRAYLEN(wszSaveFilename));

    //
    // Do the save unless user hit cancel in save dialog (hr == S_FALSE) or
    // there was an error.
    //

    if (hr == S_FALSE)
    {
        hr = S_OK; // remap to avoid debug assert in mmc
    }
    else if (SUCCEEDED(hr))
    {
        DIRECTION Direction = BACKWARD;

        if (_pActiveSnapin && _pActiveSnapin->GetSortOrder() == OLDEST_FIRST)
        {
            Direction = FORWARD;
        }

        hr = pli->SaveLogAs(SaveType, wszSaveFilename, Direction);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_SetServerFocusFromDataObject
//
//  Synopsis:   Extract the machine name from [pDataObject] and make it the
//              focused server.
//
//  Arguments:  [pDataObject] - data object with server name
//
//  Returns:    HRESULT
//
//  History:    4-19-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CComponentData::_SetServerFocusFromDataObject(
    LPDATAOBJECT pDataObject)
{
    TRACE_METHOD(CComponentData, _SetServerFocusFromDataObject);

    HRESULT hr = S_OK;
    HGLOBAL hMachineName;

    // #256032. Function "SetServerFocus" try to assign "hMachineName" to a
    // WCHAR[CCH_COMPUTER_MAX + 1] variable. It means "hMachineName" may have
    // a CCH_COMPUTER_MAX + 1 size string.
    hr = ExtractFromDataObject(pDataObject,
                               CDataObject::s_cfMachineName,
                               sizeof(WCHAR) * (CCH_COMPUTER_MAX + 1),
                               &hMachineName);

    if (SUCCEEDED(hr))
    {
        SetServerFocus((LPCWSTR) hMachineName);
#if (DBG == 1)
        HGLOBAL hReturn =
#endif // (DBG == 1)
        GlobalFree(hMachineName);
        ASSERT(!hReturn);  // returns NULL on success, valid handle on failure
    }
    else
    {
        DBG_OUT_HRESULT(hr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::SetServerFocus
//
//  Synopsis:   Note the name of the server at which this component data
//              is focused.
//
//  Arguments:  [pwszServerName] - machine name
//
//  History:    3-12-1997   DavidMun   Created
//
//  Notes:      Strips leading backslashes.
//
//---------------------------------------------------------------------------

VOID
CComponentData::SetServerFocus(
    LPCWSTR pwszServerName)
{
    Dbg(DEB_TRACE,
        "CComponentData::SetServerFocus(%x) '%s'\n",
        this,
        pwszServerName ? pwszServerName : L"<NULL>");

    //
    // Skip leading backslashes.
    //

    while (pwszServerName && *pwszServerName == L'\\')
    {
        pwszServerName++;
    }

    //
    // Set persisted server focus.  The current server focus is the persisted
    // server focus unless the command line override is being used.
    //

    if (pwszServerName && *pwszServerName)
    {
        lstrcpyn(_wszServerFocus, pwszServerName, ARRAYLEN(_wszServerFocus));
    }
    else
    {
        _wszServerFocus[0] = L'\0';
    }

    //
    // Since the (non-override) focus has changed, make the system root
    // matches the focus in use.
    //

    _UpdateCurFocusSystemRoot();
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_UpdateCurFocusSystemRoot
//
//  Synopsis:   Initialize the _wszCurFocusSystemRoot member
//
//  History:    08-26-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CComponentData::_UpdateCurFocusSystemRoot()
{
    LPCWSTR wszServer = GetCurrentFocus();

    if (wszServer && *wszServer)
    {
        HRESULT hr;
        CSafeReg shkRemoteHKLM;

        hr = shkRemoteHKLM.Connect(wszServer, HKEY_LOCAL_MACHINE);

        if (SUCCEEDED(hr))
        {
            GetRemoteSystemRoot(shkRemoteHKLM,
                                _wszCurFocusSystemRoot,
                                ARRAYLEN(_wszCurFocusSystemRoot));
        }
    }
    else
    {
        _wszCurFocusSystemRoot[0] = L'\0';
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_UpdateRootDisplayName
//
//  Synopsis:   Ensure that the "Event Log (x)" root node name is up to date
//              such that "x" is the name of the server on which the
//              snapin is focused.
//
//  History:    02-02-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CComponentData::_UpdateRootDisplayName()
{
    TRACE_METHOD(CComponentData, _UpdateRootDisplayName);

    wstring wstrRootDisplayName;
    LPCWSTR pwszServer = GetCurrentFocus();
    wstring wstrLocal = GetComputerNameAsString();

    pwszServer = pwszServer ? pwszServer : wstrLocal.c_str();

    if (_wcsicmp(pwszServer, wstrLocal.c_str()) == 0)
    {
        // "Event Viewer (Local)"
        wstrRootDisplayName = FormatString(IDS_ROOT_LOCAL_DISPLAY_NAME);
    }
    else
    {
        // "Event Viewer (machine)"
        wstrRootDisplayName = FormatString(IDS_ROOT_REMOTE_DISPLAY_NAME_FMT, pwszServer);
    }

    SCOPEDATAITEM sdi;

    ZeroMemory(&sdi, sizeof sdi);
    sdi.mask = SDI_STR;
    sdi.displayname = (LPOLESTR)(wstrRootDisplayName.c_str());
    sdi.ID = _hsiRoot;
#if (DBG == 1)
    HRESULT hr =
#endif // (DBG == 1)
        _pConsoleNameSpace->SetItem(&sdi);
    CHECK_HRESULT(hr);
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::UnlinkSnapin
//
//  Synopsis:   Remove snapin [pSnapin] from the llist
//
//  Arguments:  [pSnapin] - snapin to remove
//
//  History:    1-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CComponentData::UnlinkSnapin(CSnapin *pSnapin)
{
    TRACE_METHOD(CComponentData, UnlinkSnapin);

    if (_pSnapins == pSnapin)
    {
        _pSnapins = _pSnapins->Next();
    }
    pSnapin->UnLink();
    // EricB 9/21/01 469577 AV after creating and then closing "new window
    // from here".
    SetActiveSnapin(NULL);
}




//+--------------------------------------------------------------------------
//
//  Member:     CComponentData::_UpdateCMenuItems
//
//  Synopsis:   Make the context menu items have the correct state for the
//              item [pli].
//
//  Arguments:  [pli] - object context menu's being opened on
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CComponentData::_UpdateCMenuItems(
    CLogInfo *pli)
{
    //
    // JonN 4/26/01 377513
    // corrupted eventlogs do not have
    //   "clear" and "properties" in popup menu
    //
    // Enable Clear Log for corrupt logs
    //
    s_acmiChildFolderBoth[MNU_TOP_CLEAR_ALL].flMenuFlags =
        (pli->IsBackupLog()) ? (MFS_DISABLED | MF_GRAYED) : MFS_ENABLED;

    //
    // If the loginfo is disabled or readonly, then disable context
    // menu items that don't apply.
    //

    if (!pli->IsEnabled())
    {
        /*
        // JonN 12/20/01 506708 - corrupted systemevent log can not be cleared
        // Unfortunately, corrupt logs follow this same codepath.  I will
        // have to regress 468078 since clearing corrupt logs is more
        // important.  Eric says that the major issue with 468078 is that
        // when you call the API to clear a log but that log does not exist,
        // the API clears another log instead.  Sounds like an eventlog
        // service bug to me...
        //
        // Ericb 9/19/01 468078 - Choosing clear on a log that cannot be found
        // (because the saved console was copied from another machine) causes
        // the application log to be cleared. Don't allow clear on disabled logs.
        s_acmiChildFolderBoth[MNU_TOP_CLEAR_ALL].flMenuFlags =
            MFS_DISABLED | MF_GRAYED;
        */
        s_acmiChildFolderBoth[MNU_TOP_SAVE_AS].flMenuFlags =
            MFS_DISABLED | MF_GRAYED;
    }
    //
    // JonN 3/21/01
    // 95391: user delegated to manage security log can't use event viewer to clear log
    //
    // I discussed this at some length with BogdanT.  The problem is that
    // the test to open the registry key does not really answer the question
    // whether the user can clear the log.  This is really arbitrated by the
    // SE_SECURITY_NAME privilege.  Through W2K this was held by
    // administrators, but with Whistler it might be held by some non-admins.
    // For local logs, we can check for this privilege directly on the token,
    // but there is no solution for remote logs.  I will simply enable these
    // operations in the "read-only" case, and allow them to fail.
    // IsReadOnly() is now relevant only to the General Properties page.
    //
    // JonN 4/16/01
    // 368549: Event Viewer: Saved Log File should not have the option to clear log file
    //
    // Backup log files can perform "Save As" but not "Clear All"
    //
    else if (pli->IsBackupLog())
    {
        s_acmiChildFolderBoth[MNU_TOP_SAVE_AS].flMenuFlags =
            MFS_ENABLED;
    }
    else
    {
        s_acmiChildFolderBoth[MNU_TOP_SAVE_AS].flMenuFlags =
            MFS_ENABLED;
    }

    //
    // Make sure exactly one of the view filtered or view all items is
    // checked
    //

    if (pli->IsFiltered())
    {
        s_acmiChildFolderBoth[MNU_VIEW_FILTER].flMenuFlags =
                MFT_RADIOCHECK | MFS_CHECKED | MFS_ENABLED;
        s_acmiChildFolderBoth[MNU_VIEW_ALL].flMenuFlags =
                MFS_ENABLED;
    }
    else
    {
        s_acmiChildFolderBoth[MNU_VIEW_FILTER].flMenuFlags =
                MFS_ENABLED;
        s_acmiChildFolderBoth[MNU_VIEW_ALL].flMenuFlags =
                MFT_RADIOCHECK | MFS_CHECKED | MFS_ENABLED;
    }

    //
    // Check either the view newest or the view oldest items, or check
    // neither if the sort order is by column.
    //
    // If there is no snapin active (user may have just expanded root
    // node and not yet left clicked on a snapin in the scope pane),
    // or if the user is opening the context menu on a scope pane item
    // which is not the current selection, disable the newest/oldest
    // first items.
    //

    SORT_ORDER soLog;

    CLogInfo *pliCurSel = NULL;

    if (_pActiveSnapin)
    {
        _pActiveSnapin->GetCurSelLogInfo((ULONG_PTR) &pliCurSel);
    }

    if (!_pActiveSnapin || pli != pliCurSel)
    {
        s_acmiChildFolderBoth[MNU_VIEW_NEWEST].flMenuFlags =
            MFS_DISABLED | MF_GRAYED;
        s_acmiChildFolderBoth[MNU_VIEW_OLDEST].flMenuFlags =
            MFS_DISABLED | MF_GRAYED;
    }
    else
    {
        soLog = _pActiveSnapin->GetSortOrder();

        if (soLog == NEWEST_FIRST)
        {
            s_acmiChildFolderBoth[MNU_VIEW_NEWEST].flMenuFlags =
                MFS_ENABLED | MFS_CHECKED;
            s_acmiChildFolderBoth[MNU_VIEW_OLDEST].flMenuFlags =
                MFS_ENABLED;
        }
        else if (soLog == OLDEST_FIRST)
        {
            s_acmiChildFolderBoth[MNU_VIEW_NEWEST].flMenuFlags =
                MFS_ENABLED;
            s_acmiChildFolderBoth[MNU_VIEW_OLDEST].flMenuFlags =
                MFS_ENABLED | MFS_CHECKED;
        }
        else
        {
            s_acmiChildFolderBoth[MNU_VIEW_NEWEST].flMenuFlags =
                MFS_ENABLED;
            s_acmiChildFolderBoth[MNU_VIEW_OLDEST].flMenuFlags =
                MFS_ENABLED;
        }
    }
}



HRESULT __stdcall
CComponentData::GetHelpTopic(LPOLESTR* compiledHelpFilename)
{
   TRACE_METHOD(CComponentData, GetHelpTopic);
   ASSERT(compiledHelpFilename);

   if (!compiledHelpFilename)
   {
      return E_POINTER;
   }

   *compiledHelpFilename = 0;
   wstring::value_type buf[MAX_PATH + 1];
   UINT result = ::GetSystemWindowsDirectory(buf, MAX_PATH);
   ASSERT(result != 0 && result <= MAX_PATH);

   if (result)
   {
      wstring help = wstring(buf) + HTML_HELP_FILE_NAME;
      size_t len = help.length();

      *compiledHelpFilename =
         reinterpret_cast<LPOLESTR>(
            ::CoTaskMemAlloc((len + 1) * sizeof(wstring::value_type)));
      if (*compiledHelpFilename)
      {
         help.copy(*compiledHelpFilename, len);
         (*compiledHelpFilename)[len] = 0;
         return S_OK;
      }
   }

   return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\debug.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//  
//  File:       debug.cxx
//
//  Contents:   Debugging routines, not present in retail build.
//
//  History:    12-06-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#if (DBG == 1)


//+--------------------------------------------------------------------------
//
//  Function:   GetNotifyTypeStr
//
//  Synopsis:   Return human-readable string representing [event].
//
//  History:    12-06-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

LPWSTR GetNotifyTypeStr(MMC_NOTIFY_TYPE event)
{
    switch (event)
    {
    case MMCN_ACTIVATE:
        return L"MMCN_ACTIVATE";
           
    case MMCN_ADD_IMAGES:
        return L"MMCN_ADD_IMAGES";
         
    case MMCN_BTN_CLICK:
        return L"MMCN_BTN_CLICK";
          
    case MMCN_CLICK:
        return L"MMCN_CLICK";
              
    case MMCN_COLUMN_CLICK:
        return L"MMCN_COLUMN_CLICK";
       
    case MMCN_CONTEXTMENU:
        return L"MMCN_CONTEXTMENU";
        
    case MMCN_CUTORMOVE:
        return L"MMCN_CUTORMOVE";
          
    case MMCN_DBLCLICK:
        return L"MMCN_DBLCLICK";
           
    case MMCN_DELETE:
        return L"MMCN_DELETE";
             
    case MMCN_DESELECT_ALL:
        return L"MMCN_DESELECT_ALL";
       
    case MMCN_EXPAND:
        return L"MMCN_EXPAND";
             
    case MMCN_HELP:
        return L"MMCN_HELP";
               
    case MMCN_MENU_BTNCLICK:
        return L"MMCN_MENU_BTNCLICK";
      
    case MMCN_MINIMIZED:
        return L"MMCN_MINIMIZED";
          
    case MMCN_PASTE:
        return L"MMCN_PASTE";
              
    case MMCN_PROPERTY_CHANGE:
        return L"MMCN_PROPERTY_CHANGE";
    
    case MMCN_QUERY_PASTE:
        return L"MMCN_QUERY_PASTE";
        
    case MMCN_REFRESH:
        return L"MMCN_REFRESH";
            
    case MMCN_REMOVE_CHILDREN:
        return L"MMCN_REMOVE_CHILDREN";
    
    case MMCN_RENAME:
        return L"MMCN_RENAME";
             
    case MMCN_SELECT:
        return L"MMCN_SELECT";
             
    case MMCN_SHOW:
        return L"MMCN_SHOW";
               
    case MMCN_VIEW_CHANGE:
        return L"MMCN_VIEW_CHANGE";
    
    case MMCN_SNAPINHELP:
        return L"MMCN_SNAPINHELP";

    case MMCN_CONTEXTHELP:
        return L"MMCN_CONTEXTHELP";

    default:
        return L"**UNKNOWN NOTIFICATION**";
    }
}




CTimer::CTimer(LPCSTR pszTitle):
    _ulStart(GetTickCount()),
    _pszTitle(pszTitle)
{
}




CTimer::~CTimer()
{
    ULONG ulStop = GetTickCount();
    ULONG ulElapsedMS = ulStop - _ulStart;

    ULONG ulSec = ulElapsedMS / 1000;
    ULONG ulMillisec = ulElapsedMS - (ulSec * 1000);

    Dbg(DEB_ITRACE, 
        "Timer '%S': %u.%03us\n", 
        _pszTitle,
        ulSec, 
        ulMillisec);
}

#endif // (DBG == 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\dataobj.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       dataobj.cxx
//
//  Contents:   Implementation of data object class
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


const UINT CDataObject::s_cfNodeType           = RegisterClipboardFormat(CCF_NODETYPE);
const UINT CDataObject::s_cfNodeId2            = RegisterClipboardFormat(CCF_NODEID2);
const UINT CDataObject::s_cfNodeTypeString     = RegisterClipboardFormat(CCF_SZNODETYPE);
const UINT CDataObject::s_cfDisplayName        = RegisterClipboardFormat(CCF_DISPLAY_NAME);
const UINT CDataObject::s_cfSnapinClsid        = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
const UINT CDataObject::s_cfSnapinPreloads     = RegisterClipboardFormat(CCF_SNAPIN_PRELOADS);
const UINT CDataObject::s_cfMachineName        = RegisterClipboardFormat(CF_MACHINE_NAME);
const UINT CDataObject::s_cfExportScopeAbbrev  = RegisterClipboardFormat(CF_EV_SCOPE);
const UINT CDataObject::s_cfExportScopeFilter  = RegisterClipboardFormat(CF_EV_SCOPE_FILTER);
const UINT CDataObject::s_cfExportResultRecNo  = RegisterClipboardFormat(CF_EV_RESULT_RECNO);
const UINT CDataObject::s_cfImportViews        = RegisterClipboardFormat(CF_EV_VIEWS);


DEBUG_DECLARE_INSTANCE_COUNTER(CDataObject)


//============================================================================
//
// IUnknown implementation
//
//============================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::QueryInterface
//
//  Synopsis:   Standard OLE
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    // TRACE_METHOD(CDataObject, QueryInterface);
    HRESULT hr = S_OK;

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppvObj = (IUnknown *)(IDataObject *)this;
        }
        else if (IsEqualIID(riid, IID_IDataObject))
        {
            *ppvObj = (IUnknown *)(IDataObject *)this;
        }
        else
        {
            hr = E_NOINTERFACE;
#if (DBG == 1)
            LPOLESTR pwszIID;
            StringFromIID(riid, &pwszIID);
            Dbg(DEB_ERROR, "CDataObject::QI no interface %ws\n", pwszIID);
            CoTaskMemFree(pwszIID);
#endif // (DBG == 1)
            *ppvObj = NULL;
            break;
        }

        //
        // If we got this far we are handing out a new interface pointer on
        // this object, so addref it.
        //

        AddRef();
    } while (0);

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Member:     CDataObject::AddRef
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *) &_cRefs);
}




//+---------------------------------------------------------------------------
//
//  Member:     CDataObject::Release
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDataObject::Release()
{
    ULONG cRefsTemp;

    cRefsTemp = InterlockedDecrement((LONG *)&_cRefs);

    if (0 == cRefsTemp)
    {
        delete this;
    }

    return cRefsTemp;
}




//============================================================================
//
// IDataObject implementation
//
//============================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::GetData
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::GetData(
        FORMATETC *pformatetcIn,
        STGMEDIUM *pmedium)
{
    TRACE_METHOD(CDataObject, GetData);
    HRESULT hr = S_OK;
    const CLIPFORMAT cf = pformatetcIn->cfFormat;
    IStream *pstm = NULL;

    pmedium->pUnkForRelease = NULL; // by OLE spec

    do
    {
        hr = CreateStreamOnHGlobal(pmedium->hGlobal, FALSE, &pstm);
        BREAK_ON_FAIL_HRESULT(hr);

        if (cf == s_cfNodeId2 &&
            pformatetcIn->tymed == TYMED_HGLOBAL )
        {
            hr = _WriteNodeId2(pmedium);
        }
        else
        {
            hr = DV_E_FORMATETC;
#if (DBG == 1)
            WCHAR wszClipFormat[MAX_PATH];
            GetClipboardFormatName(cf, wszClipFormat, ARRAYLEN(wszClipFormat));
            Dbg(DEB_IWARN,
                "CDataObject::GetData: unrecognized cf '%s'\n",
                wszClipFormat);
#endif // (DBG == 1)
        }
    } while (0);

    if (pstm)
    {
        pstm->Release();
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::GetDataHere
//
//  Synopsis:   Fill the hGlobal in [pmedium] with the requested data
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::GetDataHere(
        FORMATETC *pFormatEtc,
        STGMEDIUM *pMedium)
{
    // TRACE_METHOD(CDataObject, GetDataHere);
    HRESULT hr = S_OK;
    const CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pstm = NULL;

    pMedium->pUnkForRelease = NULL; // by OLE spec

    do
    {
        hr = CreateStreamOnHGlobal(pMedium->hGlobal, FALSE, &pstm);
        BREAK_ON_FAIL_HRESULT(hr);

        if (cf == s_cfDisplayName)
        {
            hr = _WriteDisplayName(pstm);
        }
        else if (cf == s_cfInternal)
        {
            hr = _WriteInternal(pstm);
        }
        else if (cf == s_cfExportScopeAbbrev)
        {
            hr = _WriteScopeAbbrev(pstm);
        }
        else if (cf == s_cfExportScopeFilter)
        {
            hr = _WriteScopeFilter(pstm);
        }
        else if (cf == s_cfExportResultRecNo)
        {
            hr = _WriteResultRecNo(pstm);
        }
        else if (cf == s_cfNodeType)
        {
            hr = _WriteNodeType(pstm);
        }
        else if (cf == s_cfNodeId2)
        {
            hr = _WriteNodeId2(pMedium);
        }
        else if (cf == s_cfNodeTypeString)
        {
            hr = _WriteNodeTypeString(pstm);
        }
        else if (cf == s_cfSnapinClsid)
        {
            hr = _WriteClsid(pstm);
        }
        else if (cf == s_cfSnapinPreloads)
        {
            Dbg(DEB_TRACE, "CCF_SNAPIN_PRELOADS\n");
            // indicate we do want to get MMCN_PRELOAD
            BOOL fPreload = TRUE;
            hr = pstm->Write((PVOID)&fPreload, sizeof(BOOL), NULL);
        }
        else
        {
            hr = DV_E_FORMATETC;
#if (DBG == 1)
            WCHAR wszClipFormat[MAX_PATH];
            GetClipboardFormatName(cf, wszClipFormat, ARRAYLEN(wszClipFormat));
            Dbg(DEB_IWARN,
                "CDataObject::GetDataHere: unrecognized cf '%s'\n",
                wszClipFormat);
#endif // (DBG == 1)
        }
    } while (0);

    if (pstm)
    {
        pstm->Release();
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::_WriteDisplayName
//
//  Synopsis:   Write the display (user-visible) name for this object's
//              data to [pstm].
//
//  Arguments:  [pstm] - stream in which to write
//
//  Returns:    HRESULT
//
//  History:    06-09-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDataObject::_WriteDisplayName(
    IStream *pstm)
{
    HRESULT hr = S_OK;
    wstring wstrRootDisplayName;
    LPWSTR pwszName;

    if (_Cookie)
    {
        CLogInfo *pli = (CLogInfo *) _Cookie;
        pwszName = pli->GetDisplayName();
    }
    else
    {
        ASSERT(_pcd);

        LPCWSTR pwszServer = _pcd->GetCurrentFocus();
        wstring wstrLocal = GetComputerNameAsString();

        pwszServer = pwszServer ? pwszServer : wstrLocal.c_str();

        if (_wcsicmp(pwszServer, wstrLocal.c_str()) == 0)
        {
            // "Event Viewer (Local)"
            wstrRootDisplayName = FormatString(IDS_ROOT_LOCAL_DISPLAY_NAME);
        }
        else
        {
            // "Event Viewer (machine)"
            wstrRootDisplayName = FormatString(IDS_ROOT_REMOTE_DISPLAY_NAME_FMT, pwszServer);
        }
        pwszName = (LPWSTR)(wstrRootDisplayName.c_str());
    }

    ULONG ulSizeofName = lstrlen(pwszName);
    ulSizeofName++; // count null
    ulSizeofName *= sizeof(WCHAR);

    hr = pstm->Write(pwszName, ulSizeofName, NULL);
    CHECK_HRESULT(hr);
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::_WriteScopeAbbrev
//
//  Synopsis:   Write abbreviated information about the scope pane entry
//              that this object has data on to [pstm].
//
//  Arguments:  [pstm] - stream in which to write data
//
//  Returns:    HRESULT
//
//  History:    06-09-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDataObject::_WriteScopeAbbrev(
    IStream *pstm)
{
    //
    // This data format isn't supported unless the data object represents
    // a scope object.
    //

    if (_Type != COOKIE_IS_LOGINFO)
    {
        DBG_OUT_HRESULT(DV_E_CLIPFORMAT);
        return DV_E_CLIPFORMAT;
    }

    //
    // Write the scope information:
    //
    // ULONG flViewFlags
    // ULONG logtype
    // USHORT cchServerName
    // WCHAR wszServerName
    // USHORT cchSourceName
    // WCHAR wszSourceName
    // USHORT cchFileName
    // WCHAR wszFileName
    // USHORT cchDisplayName
    // WCHAR wszDisplayName
    //

    HRESULT hr = S_OK;
    CLogInfo *pli = (CLogInfo *) _Cookie;

    do
    {
        ULONG flFlags = pli->GetExportedFlags();

        hr = pstm->Write(&flFlags, sizeof flFlags, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        ULONG ulType = pli->GetLogType();

        hr = pstm->Write(&ulType, sizeof ulType, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        LPWSTR pwszServerName = pli->GetLogServerName();

        if (!pwszServerName)
        {
            pwszServerName = L"";
        }

        hr = WriteString(pstm, pwszServerName);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = WriteString(pstm, pli->GetLogName());
        BREAK_ON_FAIL_HRESULT(hr);

        hr = WriteString(pstm, pli->GetFileName());
        BREAK_ON_FAIL_HRESULT(hr);

        hr = WriteString(pstm, pli->GetDisplayName());
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::_WriteScopeFilter
//
//  Synopsis:   Write the filter selections for the log this object has data
//              about.
//
//  Arguments:  [pstm] - stream in which to write
//
//  Returns:    HRESULT
//
//  History:    06-09-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDataObject::_WriteScopeFilter(
    IStream *pstm)
{
    //
    // This data format isn't supported unless the data object represents
    // a scope object.
    //

    if (_Type != COOKIE_IS_LOGINFO)
    {
        DBG_OUT_HRESULT(DV_E_CLIPFORMAT);
        return DV_E_CLIPFORMAT;
    }

    CLogInfo *pli = (CLogInfo *) _Cookie;
    CFilter *pFilter = pli->GetFilter();
    return pFilter->Save(pstm);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::_WriteNodeType
//
//  Synopsis:   Write the node type GUID which describes the data contained
//              in this object to [pstm].
//
//  History:    06-09-1997   DavidMun   Created
//              06-13-1997   DavidMun   Write guid by type
//
//---------------------------------------------------------------------------

HRESULT
CDataObject::_WriteNodeType(
    IStream *pstm)
{
    HRESULT hr;
    const GUID *pguid = NULL;

    switch (_Type)
    {
    case COOKIE_IS_ROOT:
        pguid = &GUID_EventViewerRootNode;
        break;

    case COOKIE_IS_LOGINFO:
        pguid = &GUID_ScopeViewNode;
        break;

    case COOKIE_IS_RECNO:
        pguid = &GUID_ResultRecordNode;
        break;

    default:
        Dbg(DEB_ERROR,
            "CDataObject::_WriteNodeType: type %uL invalid\n",
            _Type);
        return E_UNEXPECTED;
    }

    hr = pstm->Write((PVOID) pguid, sizeof(GUID), NULL);
    CHECK_HRESULT(hr);
    return hr;
}




HRESULT
CDataObject::_WriteNodeId2(
    STGMEDIUM *pmedium)
{
    TRACE_METHOD(CDataObject, _WriteNodeId2);

    HRESULT hr = S_OK;

    do
    {
        //
        // JonN 10/4/01 476865
        // The old handling of CCF_NODEID2 is totally wrong.  This identifier
        // should be based on real semantic information rather than an
        // arbitrary ULONG.
        //
        // CODEWORK remove GetNodeId() framework
        //
        wstring wstrID;
        CLogInfo *pLogInfo = reinterpret_cast<CLogInfo*>(_Cookie);
        if (IsBadReadPtr(pLogInfo,sizeof(CLogInfo)))
            pLogInfo = NULL;
        if (NULL != pLogInfo)
        {
            LPCWSTR pszLogServerName = pLogInfo->GetLogServerName();
            if (NULL != pszLogServerName)
                wstrID = pszLogServerName;
        }
        wstrID += L"\\";
        if (NULL != pLogInfo)
        {
            LPCWSTR pszLogName = pLogInfo->GetLogName();
            if (NULL != pszLogName)
                wstrID += pszLogName;
        }
        _wcsupr( const_cast<WCHAR*>(wstrID.c_str()) );
        ULONG cbString = (ULONG)(wstrID.length()+1) * sizeof(WCHAR);

        pmedium->hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(SNodeID2) + cbString);

        if (!pmedium->hGlobal)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        SNodeID2 *pNodeId = static_cast<SNodeID2*>(GlobalLock(pmedium->hGlobal));

        if (!pNodeId)
        {
            hr = HRESULT_FROM_LASTERROR;
            DBG_OUT_HRESULT(hr);
            GlobalFree(pmedium->hGlobal);
            pmedium->hGlobal = NULL;
            break;
        }

        pNodeId->cBytes = cbString;
        pNodeId->dwFlags = 0;

        CopyMemory(&pNodeId->id[0], wstrID.c_str(), cbString);
        GlobalUnlock(pmedium->hGlobal);
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::_WriteNodeTypeString
//
//  Synopsis:   Write this snapin's node type GUID as a string to [pstm].
//
//  History:    06-09-1997   DavidMun   Created
//              06-13-1997   DavidMun   Write guid by type
//
//---------------------------------------------------------------------------

HRESULT
CDataObject::_WriteNodeTypeString(
    IStream *pstm)
{
    HRESULT hr;
    LPCWSTR pwszGUID = NULL;

    switch (_Type)
    {
    case COOKIE_IS_ROOT:
        pwszGUID = ROOT_NODE_GUID_STR;
        break;

    case COOKIE_IS_LOGINFO:
        pwszGUID = SCOPE_NODE_GUID_STR;
        break;

    case COOKIE_IS_RECNO:
        pwszGUID = RESULT_NODE_GUID_STR;
        break;

    default:
        Dbg(DEB_ERROR,
            "CDataObject::_WriteNodeTypeString: type %uL invalid\n",
            _Type);
        return E_UNEXPECTED;
    }

    // All guid strings are the same size

    hr = pstm->Write((PVOID) pwszGUID, sizeof ROOT_NODE_GUID_STR, NULL);
    CHECK_HRESULT(hr);
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::_WriteResultRecNo
//
//  Synopsis:   Write the event log record number of the result item
//              represented by this object.
//
//  Arguments:  [pstm] - stream in which to write
//
//  Returns:    HRESULT
//
//  History:    06-09-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDataObject::_WriteResultRecNo(
    IStream *pstm)
{
    //
    // This data format isn't supported unless the data object represents
    // an event log record.
    //

    if (_Type != COOKIE_IS_RECNO)
    {
        DBG_OUT_HRESULT(DV_E_CLIPFORMAT);
        return DV_E_CLIPFORMAT;
    }

    return pstm->Write(&_Cookie, sizeof _Cookie, NULL);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::QueryGetData
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::QueryGetData(
        FORMATETC *pformatetc)
{
    TRACE_METHOD(CDataObject, QueryGetData);
    return E_NOTIMPL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::GetCanonicalFormatEtc
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::GetCanonicalFormatEtc(
        FORMATETC *pformatectIn,
        FORMATETC *pformatetcOut)
{
    TRACE_METHOD(CDataObject, GetCanonicalFormatEtc);
    return E_NOTIMPL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::SetCookie
//
//  Synopsis:
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CDataObject::SetCookie(
        MMC_COOKIE Cookie,
        DATA_OBJECT_TYPES Context,
        COOKIETYPE Type)
{
    ASSERT(!_Cookie);
    _Cookie = Cookie;
    _Type = Type;
    _Context = Context;

    if (_Type == COOKIE_IS_LOGINFO)
    {
        ASSERT(_Cookie);
        CLogInfo *pli = (CLogInfo *)Cookie;
        pli->AddRef();
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::SetData
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::SetData(
    FORMATETC *pformatetc,
    STGMEDIUM *pmedium,
    BOOL fRelease)
{
    TRACE_METHOD(CDataObject, SetData);
    return E_NOTIMPL;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::EnumFormatEtc
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::EnumFormatEtc(
    DWORD dwDirection,
    IEnumFORMATETC **ppenumFormatEtc)
{
    TRACE_METHOD(CDataObject, EnumFormatEtc);
    return E_NOTIMPL;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::DAdvise
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::DAdvise(
    FORMATETC *pformatetc,
    DWORD advf,
    IAdviseSink *pAdvSink,
    DWORD *pdwConnection)
{
    TRACE_METHOD(CDataObject, DAdvise);
    return E_NOTIMPL;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::DUnadvise
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::DUnadvise(
    DWORD dwConnection)
{
    TRACE_METHOD(CDataObject, DUnadvise);
    return E_NOTIMPL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::EnumDAdvise
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::EnumDAdvise(
    IEnumSTATDATA **ppenumAdvise)
{
    TRACE_METHOD(CDataObject, EnumDAdvise);
    return E_NOTIMPL;
}




//============================================================================
//
// Non interface method implementation
//
//============================================================================


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CDataObject
//
//  Synopsis:   ctor
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDataObject::CDataObject():
    _cRefs(1),
    _Cookie(0),
    _Context(CCT_UNINITIALIZED),
    _Type(COOKIE_IS_RECNO),
    _pcd(NULL)
{
    // TRACE_CONSTRUCTOR(CDataObject);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDataObject);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::~CDataObject
//
//  Synopsis:   dtor
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDataObject::~CDataObject()
{
    // TRACE_DESTRUCTOR(CDataObject);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CDataObject);

    if (_Type == COOKIE_IS_LOGINFO)
    {
        ASSERT(_Cookie);
        ((CLogInfo *)_Cookie)->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\dlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       dlg.cxx
//
//  Contents:   Implementation of modeless dialog base class
//
//  Classes:    CDlg
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop





//+--------------------------------------------------------------------------
//
//  Member:     CDlg::CDlg
//
//  Synopsis:   ctor
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDlg::CDlg():
    _hwnd(NULL)
{
    TRACE_CONSTRUCTOR(CDlg);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::~CDlg
//
//  Synopsis:   dtor
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDlg::~CDlg()
{
    TRACE_DESTRUCTOR(CDlg);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_DoModalDlg
//
//  Synopsis:   Run the dialog
//
//  Arguments:  [hwnd]  - parent
//              [idd]   - resource id of dialog template
//
//  Returns:    return value from ::EndDialog, or -1 on failure
//
//  History:    11-18-1998  JonN       Created
//
//---------------------------------------------------------------------------

INT_PTR
CDlg::_DoModalDlg(
    HWND hwnd,
    INT idd)
{
    TRACE_METHOD(CDlg, _DoModalDlg);

    INT_PTR retval;

    retval = DialogBoxParam( g_hinst,
                             MAKEINTRESOURCE(idd),
                             hwnd,
                             CDlg::_DlgProc,
                             (LPARAM) this);

    if (-1 == retval)
    {
        DBG_OUT_LASTERROR;
    }
    return retval;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_DoModelessDlg
//
//  Synopsis:   Create the dialog and return its window handle
//
//  Arguments:  [idd] - resource id of dialog template
//
//  Returns:    Dialog window handle, or NULL on failure
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HWND
CDlg::_DoModelessDlg(
    INT idd)
{
    TRACE_METHOD(CDlg, _DoModelessDlg);

    HWND hwnd;

    hwnd = CreateDialogParam(g_hinst,
                             MAKEINTRESOURCE(idd),
                             NULL,
                             CDlg::_DlgProc,
                             (LPARAM) this);

    if (!hwnd)
    {
        DBG_OUT_LASTERROR;
    }
    return hwnd;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_DlgProc
//
//  Synopsis:   Dispatch selected messages to derived class
//
//  Arguments:  standard windows dialog
//
//  Returns:    standard windows dialog
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

INT_PTR CALLBACK
CDlg::_DlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fHandled = TRUE;
    CDlg *pThis = (CDlg *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (message)
    {
    case WM_GETDLGCODE:
        fHandled = FALSE;
        Dbg(DEB_TRACE, "WM_GETDLGCODE\n");
        break;

    case WM_INITDIALOG:
    {
        HRESULT hr = S_OK;

        //
        // pThis isn't valid because we haven't set DWLP_USER yet.  Make
        // it valid.
        //

        pThis = (CDlg*) lParam;
        ASSERT(pThis);

        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR) pThis);
        pThis->_hwnd = hwnd;
        hr = pThis->_OnInit(&fHandled);

        //
        // If the initialization failed do not allow the dialog to start.
        // TODO: failures should be reported in the _OnInit implementations.
        //

        if (FAILED(hr))
        {
            DestroyWindow(hwnd);
        }
        break;
    }

    case WM_COMMAND:
        if (pThis)
        {
            fHandled = pThis->_OnCommand(wParam, lParam);
        }
        break;

    case WM_DESTROY:
        //
        // It's possible to get a WM_DESTROY message without having gotten
        // a WM_INITDIALOG if loading a dll that the dialog needs (e.g.
        // comctl32.dll) fails, so guard pThis access here.
        //

        if (pThis)
        {
            pThis->_OnDestroy();
            pThis->_hwnd = NULL;
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        if (pThis)
        {
            pThis->_OnHelp(message, wParam, lParam);
        }
        break;

    default:
        fHandled = FALSE;
        break;
    }
    return fHandled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\dllcache.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//  
//  File:       dllcache.cxx
//
//  Contents:   Implementation of module handle caching class
//
//  Classes:    CDllCache
//
//  History:    2-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------


#include "headers.hxx"
#pragma hdrstop




//===========================================================================
//
// CDllCacheItem implementation
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CDllCacheItem::CDllCacheItem
//
//  Synopsis:   ctor
//
//  History:    2-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDllCacheItem::CDllCacheItem(
    LPCWSTR pwszModuleName,
    HINSTANCE hinst)
{
    TRACE_CONSTRUCTOR(CDllCacheItem);
    ASSERT(hinst);

    lstrcpyn(_wszModuleName, pwszModuleName, ARRAYLEN(_wszModuleName));
    _hinst = hinst;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDllCacheItem::~CDllCacheItem
//
//  Synopsis:   dtor
//
//  History:    2-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDllCacheItem::~CDllCacheItem()
{
    TRACE_DESTRUCTOR(CDllCacheItem);
    if (_hinst)
    {
        FreeLibrary(_hinst);
        _hinst = NULL;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CDllCacheItem::Copy
//
//  Synopsis:   Copy the cache item in [pitem], addrefing its module handle.
//
//  Arguments:  [pitem] - item to copy
//
//  Returns:    HRESULT
//
//  History:    3-04-1997   DavidMun   Created
//
//  Notes:      Releases currently owned module handle, if any.
//
//---------------------------------------------------------------------------

HRESULT
CDllCacheItem::Copy(
    CLruCacheItem *pitem)
{
    HRESULT hr = S_OK;
    CDllCacheItem *pDllItem = (CDllCacheItem *) pitem;

    //
    // first try to addref the item to copy
    //

    HINSTANCE hinstAddRef;

    hinstAddRef = LoadLibraryEx(pDllItem->_wszModuleName,
                                NULL,
                                LOAD_LIBRARY_AS_DATAFILE | 
                                 DONT_RESOLVE_DLL_REFERENCES);

    // 
    // If that succeeded, let go of the hinstance in this and remember
    // the new one.
    //

    if (hinstAddRef)
    {
        if (_hinst)
        {
            VERIFY(FreeLibrary(_hinst));
        }
        _hinst = hinstAddRef;
        lstrcpy(_wszModuleName, pDllItem->_wszModuleName);
    }
    else 
    {
        hr = HRESULT_FROM_LASTERROR;
        DBG_OUT_LASTERROR;
    }
   
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDllCacheItem::GetValue
//
//  Synopsis:   Fill [pvBuf] with cached hinstance.
//
//  Arguments:  [pvBuf] - buffer to fill
//              [cbBuf] - must be sizeof(HINSTANCE)
//
//  Returns:    S_OK
//
//  Modifies:   *[pvBuf]
//
//  History:    3-04-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDllCacheItem::GetValue(
    LPVOID pvBuf,
    ULONG cbBuf)
{
    ASSERT(cbBuf == sizeof(HINSTANCE));
    _ulLastAccess = GetTickCount();
    *(HINSTANCE *)pvBuf = _hinst;
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDllCacheItem::IsEqual
//
//  Synopsis:   Return true if this item's key matches [pvKey]
//
//  History:    3-04-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CDllCacheItem::IsEqual(
    LPVOID pvKey)
{
    return 0 == lstrcmpi((LPCWSTR) pvKey, _wszModuleName);
}




//===========================================================================
//
// CDllCache implementation
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CDllCache::CDllCache
//
//  Synopsis:   ctor
//
//  History:    2-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDllCache::CDllCache():
    CLruCache(MAX_DLL_CACHE)
{
    TRACE_CONSTRUCTOR(CDllCache);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDllCache::~CDllCache
//
//  Synopsis:   dtor
//
//  History:    2-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDllCache::~CDllCache()
{
    TRACE_DESTRUCTOR(CDllCache);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDllCache::_Add, private
//
//  Synopsis:   Add new item to cache
//
//  Arguments:  [pwszModuleName] - identifies item
//              [hinst]          - item's value
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//
//  History:    2-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDllCache::_Add(
    LPCWSTR pwszModuleName,
    HINSTANCE hinst)
{
    HRESULT hr = S_OK;
    CLruCacheItem *pNew = new CDllCacheItem(pwszModuleName, hinst);

    if (pNew)
    {
        hr = CLruCache::Add(pNew);
    }
    else 
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(hr);
    }
    return hr;
}





//+--------------------------------------------------------------------------
//
//  Member:     CDllCache::Fetch
//
//  Synopsis:   Retrieve the module handle of [pwszModuleName], adding it to
//              the cache if it is not already present.
//
//  Arguments:  [pwszModuleName] - name of module
//              [psch]           - safe module handle class
//
//  Returns:    HRESULT
//
//  History:    2-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDllCache::Fetch(
    LPCWSTR pwszModuleName,
    CSafeCacheHandle *psch)
{
    //
    // Take the critical section so the module handle can't be
    // freed by an LRU replacement between the time it is returned
    // and the time its ref count is incremented by the LoadLibraryEx
    // call.
    //

    CAutoCritSec CritSec(&_cs);
    HINSTANCE hinst;
    HRESULT hr;

    hr = CLruCache::Fetch((LPVOID) pwszModuleName,
                          (LPVOID) &hinst,
                          sizeof hinst);

    //
    // If the module is in the cache, give it to psch.  Otherwise
    // try to load it, give it to psch, and add it to the cache.
    //

    if (hr == S_OK)
    {
        Dbg(DEB_ITRACE, 
            "CDllCache::Fetch: cache hit for module '%s'\n", 
            pwszModuleName);
        hr = psch->Set(pwszModuleName);
    }
    else 
    {
        Dbg(DEB_ITRACE, 
            "CDllCache::Fetch: cache miss for module '%s'\n", 
            pwszModuleName);
        hinst = LoadLibraryEx(pwszModuleName, 
                              NULL,
                              LOAD_LIBRARY_AS_DATAFILE | 
                               DONT_RESOLVE_DLL_REFERENCES);
        
        if (hinst)
        {
            //
            // Got the module handle; put it in the safe handle object,
            // which will do another loadlibrary on it to addref it. This
            // means that although subsequent operations may free it from
            // the cache, the handle in psch will remain valid.
            //

            hr = psch->Set(pwszModuleName);

            //
            // Now try to cache it.  If it can't be added to the cache,
            // free it so only psch is holding a reference.  If it is
            // added to the cache, it will be freed by the CDllCacheItem
            // object when it is overwritten or in the dtor.
            //

            HRESULT hrAdd = _Add(pwszModuleName, hinst);

            if (FAILED(hrAdd))
            {
                FreeLibrary(hinst);
            }
        }
        else 
        {
            hr = HRESULT_FROM_LASTERROR;
            DBG_OUT_LASTERROR;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\details.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       details.cxx
//
//  Contents:   Functions to implement the record details property sheet
//              page.
//
//  Classes:    CDetailsPage
//              CDetailsPage
//
//  History:    12-13-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//
// Forward references
//

ULONG
ByteDisplaySize(ULONG cbData);

void
FormatBufferToBytes(
    const BYTE *pbBuf,
    ULONG       cbBufSize,
    WCHAR       wszFormatStr[],
    ULONG       cchFormatStr);

ULONG
WordDisplaySize(ULONG cbData);

void
FormatBufferToWords(
    const BYTE *pbBuf,
    ULONG       cbBufSize,
    WCHAR       wszFormatStr[],
    ULONG       cchFormatStr);

ULONG
YesNoConfirm(
    HWND hwnd,
    ULONG idsTitle,
    ULONG idsMsg);

void
AppendToClipboardString(
    wstring &strClipboard,
    ULONG idsLabel,
    PCWSTR pwzText,
    BOOL fNewlineBeforeText = FALSE);

BOOL
ButtonFaceColorIsDark();

//
// Debug object tracking.
//

DEBUG_DECLARE_INSTANCE_COUNTER(CDetailsPage)

ULONG
s_aulHelpIDs[] =
{
    detail_user_lbl,            Hdetail_user_lbl,
    detail_user_txt,            Hdetail_user_edit,
    detail_computer_lbl,        Hdetail_computer_lbl,
    detail_computer_txt,        Hdetail_computer_edit,
    detail_date_lbl,            Hdetail_date_lbl,
    detail_date_txt,            Hdetail_date_txt,
    detail_event_id_lbl,        Hdetail_event_id_lbl,
    detail_event_id_txt,        Hdetail_event_id_txt,
    detail_time_lbl,            Hdetail_time_lbl,
    detail_time_txt,            Hdetail_time_txt,
    detail_source_lbl,          Hdetail_source_lbl,
    detail_source_txt,          Hdetail_source_txt,
    detail_type_lbl,            Hdetail_type_lbl,
    detail_type_txt,            Hdetail_type_txt,
    detail_category_lbl,        Hdetail_category_lbl,
    detail_category_txt,        Hdetail_category_txt,
    detail_description_lbl,     Hdetail_description_lbl,
    detail_description_edit,    Hdetail_description_edit,
    detail_noprops_lbl,         Hdetail_noprops_lbl,
    detail_data_lbl,            Hdetail_data_lbl,
    detail_data_edit,           Hdetail_data_edit,
    detail_byte_rb,             Hdetail_byte_rb,
    detail_word_rb,             Hdetail_word_rb,
    detail_noprops_lbl,         Hdetail_noprops_lbl,
    detail_prev_pb,             Hdetail_prev_pb,
    detail_next_pb,             Hdetail_next_pb,
    detail_copy_pb,             Hdetail_copy_pb,
    0,0
};



//+--------------------------------------------------------------------------
//
//  Member:     CDetailsPage::CDetailsPage
//
//  Synopsis:   ctor
//
//  Arguments:  [pstm] - contains marshaled IResultPrshtActions itf
//
//  History:    3-27-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDetailsPage::CDetailsPage(
    IStream *pstm):
        _pstm(pstm),
        _prpa(NULL),
        _nByteFmtReqVScroll(-1),
        _nWordFmtReqVScroll(-1),
        _pwszDataInByteFormat(NULL),
        _cchDataInByteFormat(0),
        _pwszDataInWordFormat(NULL),
        _cchDataInWordFormat(0),
        _cchsWithVScroll(DEFAULT_CCH_WITH_VSCROLL),
        _cchsWithNoVScroll(DEFAULT_CCH_WITHOUT_VSCROLL),
        _ulSelectedFormat(detail_byte_rb)
{
    TRACE_CONSTRUCTOR(CDetailsPage);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDetailsPage);
    ASSERT(pstm);

    ZeroMemory(&_chrgLastLinkClick, sizeof _chrgLastLinkClick);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDetailsPage::~CDetailsPage
//
//  Synopsis:   dtor
//
//  History:    3-27-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDetailsPage::~CDetailsPage()
{
    TRACE_DESTRUCTOR(CDetailsPage);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CDetailsPage);

    if (_pstm)
    {
        ASSERT(!_prpa);

        PVOID pvrpa;
        HRESULT hr;

        hr = CoGetInterfaceAndReleaseStream(_pstm,
                                            IID_IResultPrshtActions,
                                            &pvrpa);
        CHECK_HRESULT(hr);
    }
    delete [] _pwszDataInWordFormat;
    delete [] _pwszDataInByteFormat;
}




void
SetButtonImage(
    HWND hwndBtn,
    ULONG idIcon)
{
    HICON hIcon = (HICON) LoadImage(g_hinst,
                                    MAKEINTRESOURCE(idIcon),
                                    IMAGE_ICON,
                                    16,
                                    16,
                                    LR_DEFAULTCOLOR);
    if (hIcon)
    {
        HICON hIconPrev = (HICON) SendMessage(hwndBtn,
                                              BM_SETIMAGE,
                                              (WPARAM)IMAGE_ICON,
                                              (LPARAM)hIcon);

        if (hIconPrev)
        {
            DestroyIcon(hIconPrev);
        }
    }
    else
    {
        DBG_OUT_LASTERROR;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CDetailsPage::_OnInit
//
//  Synopsis:   Initialize the page.
//
//  Arguments:  [pPSP] - original struct used to create this page
//
//  History:    4-21-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CDetailsPage::_OnInit(LPPROPSHEETPAGE pPSP)
{
    TRACE_METHOD(CDetailsPage, _OnInit);

    //
    // Make sure the page starts out displaying "no properties".  If there
    // are properties to display, then the properties controls will be
    // made visible and filled with data when _SetActive is called.
    //

    _SetFlag(PAGE_NEEDS_REFRESH);
    _ShowProperties(FIRST_DETAILS_PROP_CTRL,
                    LAST_DETAILS_PROP_CTRL,
                    FALSE);

    //
    // Unmarshal the private interface to the CSnapin object
    //

    PVOID pvrpa;
    HRESULT hr;

    hr = CoGetInterfaceAndReleaseStream(_pstm,
                                        IID_IResultPrshtActions,
                                        &pvrpa);

    //
    // The stream has been released; don't let the destructor release
    // it again.
    //

    _pstm = NULL;

    if (SUCCEEDED(hr))
    {
        _prpa = (IResultPrshtActions *)pvrpa;
    }
    else
    {
        DBG_OUT_HRESULT(hr);
    }

    //
    // Tell the rich edit control we want to receive notifications of clicks
    // on text that has the link (hyperlink, aka URL) format.   Also, set the
    // background color of the rich edit to match the background color of
    // the dialog.
    //

    HWND hwndRichEdit = _hCtrl(detail_description_edit);

    SendMessage(hwndRichEdit, EM_SETEVENTMASK, 0, ENM_LINK);
    SendMessage(hwndRichEdit, EM_SETBKGNDCOLOR, 0, GetSysColor(COLOR_BTNFACE));
    // JonN 03/01/01 539485 SendMessage(hwndRichEdit, EM_AUTOURLDETECT, TRUE, 0);

    //
    // Give snapin thread our window handle.  That way it can ping us
    // when it gets a notification that the result view selection
    // has changed.
    //

    if (_prpa)
    {
        _prpa->SetInspectorWnd((ULONG_PTR) _hwnd);
    }

    //
    // be sure the appropriate radio button is selected
    //

    CheckRadioButton(_hwnd,
                     detail_byte_rb,
                     detail_word_rb,
                     _ulSelectedFormat);

    //
    // Ensure dialog box is using a fixed pitch font so the alpha chars
    // in the byte display all line up nicely.
    //

    HWND hEdit = _hCtrl(detail_data_edit);

    ConvertToFixedPitchFont(hEdit);

    //
    //  Determine the number of chars that can fit in a single line.
    //

    RECT rect;
    GetWindowRect(hEdit, &rect);

    int nWindowWidth = rect.right - rect.left;

    //
    // To ensure that tm.tmAveCharWidth & GetWindowRect are both in
    // screen coordinates, set the map mode to MM_TEXT
    //

    TEXTMETRIC  tm;
    HDC hdc = GetDC(hEdit);

    if (hdc)
    {
        if (GetMapMode(hdc) != MM_TEXT)
        {
            VERIFY(SetMapMode(hdc, MM_TEXT));
        }

        VERIFY(GetTextMetrics(hdc, &tm));

        ReleaseDC(hEdit, hdc);

        //
        // Prevent divide by 0 exception in case of error. _cchsWithNoVScroll
        // and _cchsWithVScroll have reasonable defaults from the ctor.
        //

        if (tm.tmAveCharWidth <= 0)
        {
            Dbg(DEB_ERROR,
                "CDetailsPage::_OnInit: tm.tmAveCharWidth == 0\n");
            return;
        }

        _cchsWithNoVScroll = nWindowWidth / tm.tmAveCharWidth;

        int nVScrollBarWidth = GetSystemMetrics(SM_CXVSCROLL);

        _cchsWithVScroll = (nWindowWidth - nVScrollBarWidth)
                                         / tm.tmAveCharWidth;
    }

    //
    // Set the icons for the icon pushbuttons
    //

    if (ButtonFaceColorIsDark())
    {
        SetButtonImage(_hCtrl(detail_prev_pb), IDI_PREVIOUS_HC);
        SetButtonImage(_hCtrl(detail_next_pb), IDI_NEXT_HC);
    }
    else
    {
        SetButtonImage(_hCtrl(detail_prev_pb), IDI_PREVIOUS);
        SetButtonImage(_hCtrl(detail_next_pb), IDI_NEXT);
    }
    SetButtonImage(_hCtrl(detail_copy_pb), IDI_COPY);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDetailsPage::_OnNotify
//
//  Synopsis:   Handle notification messages.
//
//  Arguments:  [pnmh] - notification message header
//
//  Returns:    per-message value
//
//  History:    4-29-1999   davidmun   Created
//
//---------------------------------------------------------------------------

ULONG
CDetailsPage::_OnNotify(
    LPNMHDR pNmHdr)
{
    ULONG ulReturn = 0;

    if (pNmHdr->idFrom == detail_description_edit && pNmHdr->code == EN_LINK)
    {
        ENLINK *pEnLink = (ENLINK*)pNmHdr;

        if (pEnLink->msg == WM_LBUTTONDOWN)
        {
            //
            // Rich edit notification user has left clicked on link
            //

            _chrgLastLinkClick = pEnLink->chrg;
        }
        else if (pEnLink->msg == WM_LBUTTONUP)
        {
            if (pEnLink->chrg.cpMax == _chrgLastLinkClick.cpMax &&
                pEnLink->chrg.cpMin == _chrgLastLinkClick.cpMin)
            {
                ZeroMemory(&_chrgLastLinkClick, sizeof _chrgLastLinkClick);
                _HandleLinkClick((ENLINK*)pNmHdr);
            }
        }
    }

    return ulReturn;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDetailsPage::_HandleLinkClick
//
//  Synopsis:   Handle notification that the user has clicked on text
//              in the richedit control that is marked with the hyperlink
//              attribute.
//
//  Arguments:  [pEnLink] - contains information about link clicked
//
//  History:    6-16-1999   davidmun   Created
//
//---------------------------------------------------------------------------

void
CDetailsPage::_HandleLinkClick(
    ENLINK *pEnLink)
{
    TRACE_METHOD(CDetailsPage, _HandleLinkClick);
    ASSERT(pEnLink->chrg.cpMax > pEnLink->chrg.cpMin);

    PWSTR pwzLink = NULL;

    do
    {
        //
        // Get the text of the link.
        //

        ULONG cch = pEnLink->chrg.cpMax - pEnLink->chrg.cpMin + 1;

        pwzLink = new WCHAR[cch];
        Dbg(DEB_TRACE,
            "allocating %u chars @ %#x for link text\n",
            cch,
            pwzLink);

        if (!pwzLink)
        {
            DBG_OUT_HRESULT(E_OUTOFMEMORY);
            break;
        }

        pwzLink[0] = L'\0';

        TEXTRANGE tr;
        ZeroMemory(&tr, sizeof tr);
        tr.chrg = pEnLink->chrg;
        tr.lpstrText = pwzLink;

        VERIFY(SendMessage(_hCtrl(detail_description_edit),
                           EM_GETTEXTRANGE,
                           0,
                           (LPARAM)&tr));

        // 537248-JonN-2002/04/17 We no longer pass URLs to ShellExecute

        //
        // For security we don't want to send random parameters, so truncate
        // the URL at the parameter marker.
        //

        PWSTR pwzColon = wcschr(pwzLink, L':');

        if (!pwzColon)
        {
            DBG_OUT_HRESULT(E_INVALIDARG);
            break;
        }

        PWSTR pwzQuestion = wcschr(pwzColon, L'?');

        if (pwzQuestion)
        {
            *pwzQuestion = L'\0';
        }

        // 537248-JonN-2002/04/17 We don't care whether the link is
        //   an IP link.  There is no real security concern here.
        //   The code which did this test has been removed.

        //
        // Create an object which appends data from event to the URL
        //

        CEventUrl  Url(pwzLink, _prpa, _strMessageFile);

        delete [] pwzLink;    // Url has its own copy now
        pwzLink = NULL;

        //
        // If the user hasn't disabled confirmation (via HKCU) ask for it,
        // then invoke url.
        //

        CConfirmUrlDlg  ConfirmDlg;

        if (!Url.IsAugmented() ||
            !ConfirmDlg.ShouldConfirm() ||
            ConfirmDlg.GetConfirmation(_hwnd, &Url))
        {
            Url.Invoke();
        }
    } while (0);

    delete [] pwzLink;
}




//+--------------------------------------------------------------------------
//
//  Function:   CDetailsPage::_OnSysColorChange
//
//  Synopsis:   Forward syscolorchange message to common controls.
//
//  History:    5-25-1999   davidmun   Created
//
//---------------------------------------------------------------------------

void
CDetailsPage::_OnSysColorChange()
{
    TRACE_METHOD(CDetailsPage, _OnSysColorChange);

    if (ButtonFaceColorIsDark())
    {
        SetButtonImage(_hCtrl(detail_prev_pb), IDI_PREVIOUS_HC);
        SetButtonImage(_hCtrl(detail_next_pb), IDI_NEXT_HC);
    }
    else
    {
        SetButtonImage(_hCtrl(detail_prev_pb), IDI_PREVIOUS);
        SetButtonImage(_hCtrl(detail_next_pb), IDI_NEXT);
    }
    SendMessage(_hCtrl(detail_description_edit),
                EM_SETBKGNDCOLOR,
                0,
                GetSysColor(COLOR_BTNFACE));
}




//+--------------------------------------------------------------------------
//
//  Member:     CDetailsPage::_EnableNextPrev
//
//  Synopsis:   Enable or disable the Next and Prev event record pushbuttons.
//
//  History:    4-21-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CDetailsPage::_EnableNextPrev(BOOL fEnable)
{
    EnableWindow(_hCtrl(detail_prev_pb), fEnable);
    EnableWindow(_hCtrl(detail_next_pb), fEnable);
    EnableWindow(_hCtrl(detail_copy_pb), fEnable);
}





//+--------------------------------------------------------------------------
//
//  Member:     CDetailsPage::_OnCommand
//
//  Synopsis:   Handle command messages common to both pages.
//
//  Arguments:  [wParam] - loword has control id
//              [lParam] - unused
//
//  Returns:    TRUE  - message NOT handled
//              FALSE - message handled
//
//  History:    4-21-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CDetailsPage::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    BOOL    fUnhandled = FALSE;
    WORD wID = LOWORD(wParam);

    switch (wID)
    {
    case detail_next_pb:
    case detail_prev_pb:
    {
        //
        // Do a prev/next command.  If carrying it out would cause the current
        // selection to wrap from top to bottom or bottom to top, get the user's
        // OK before wrapping.
        //

        HRESULT hrWouldWrap;

        hrWouldWrap = _prpa->InspectorAdvance(wID, FALSE);

        if (hrWouldWrap == S_OK)
        {
            ULONG ulQuestion = (wID == detail_next_pb) ?
                                IDS_WRAP_TO_END     :
                                IDS_WRAP_TO_START;
            ULONG ulAnswer = YesNoConfirm(_hwnd, IDS_VIEWER, ulQuestion);

            if (ulAnswer == IDYES)
            {
                _prpa->InspectorAdvance(wID, TRUE);
            }
        }
        break;
    }

    //
    // JonN 6/11/01 412818 Accelerator keys are disabled if focus is on
    //                     a UI element that becomes disabled
    //

    case detail_byte_rb:
    case detail_word_rb:
        switch (HIWORD(wParam)) {
        case BN_CLICKED:
            if (_ulSelectedFormat != wID)
            {
                LPWSTR pwszData = (wID == detail_byte_rb)
                                        ? _pwszDataInByteFormat
                                        : _pwszDataInWordFormat;
                if (pwszData && *pwszData)
                {
                    Edit_SetText(_hCtrl(detail_data_edit), pwszData);
                    _ulSelectedFormat = wID;
                }
                else
                {
                    _RefreshControls();
                }
            }
            break;
        default:
            break;
        } // switch (HIWORD(wParam))
        break;

    case detail_data_edit:
        break;

    case detail_copy_pb:
        _CopyToClipboard();
        break;

    case IDCANCEL:
        //
        // Hitting escape when the focus is in the richedit sends the cancel
        // command to this dialog, instead of frame, so forward it.
        //
        PostMessage(GetParent(_hwnd), WM_COMMAND, IDCANCEL, 0);
        break;

    default:
        fUnhandled = TRUE;
        break;
    }

    return fUnhandled;
}



const wstring c_strCRLF(L"\r\n");

//+--------------------------------------------------------------------------
//
//  Member:     CDetailsPage::_CopyToClipboard
//
//  Synopsis:   Copy the current event to the system clipboard.
//
//  History:    5-24-1999   davidmun   Created
//
//---------------------------------------------------------------------------

// ISSUE-2002/03/01-JonN Can't we just take the data from the active controls?
void
CDetailsPage::_CopyToClipboard()
{
    TRACE_METHOD(CDetailsPage, _CopyToClipboard);
    ASSERT(_IsFlagSet(PAGE_SHOWING_PROPERTIES));

    EVENTLOGRECORD *pelr = NULL;
    BOOL            fOpenedClipboard = FALSE;
    BOOL            fOk = TRUE;
    HGLOBAL         hUnicode = NULL;

    do
    {
        if (!_prpa)
        {
            break;
        }

        _prpa->GetCurSelRecCopy((ULONG_PTR) &pelr);

        if (!pelr)
        {
            Dbg(DEB_ERROR, "No selected record to copy to clipboard\n");
            break;
        }

        fOpenedClipboard = OpenClipboard(_hwnd);

        if (!fOpenedClipboard)
        {
#if (DBG == 1)
            ULONG ulLastError = GetLastError();
            Dbg(DEB_ERROR,
                "Can't open clipboard (lasterror %u), currently owned by %#x\n",
                ulLastError,
                GetClipboardOwner());
#endif (DBG == 1)
            break;
        }

        fOk = EmptyClipboard();

        if (!fOk)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        //
        // Create data to copy to clipboard
        //

        wstring strClipboard;
        WCHAR   wszBuf[MAX_DETAILS_STR];
        ::ZeroMemory(wszBuf,sizeof(wszBuf)); // JonN 7/10/01 437696

        AppendToClipboardString(strClipboard,
                                IDS_CLP_EVENT_TYPE,
                                GetTypeStr(GetEventType(pelr)));

        AppendToClipboardString(strClipboard,
                                IDS_CLP_EVENT_SOURCE,
                                GetSourceStr(pelr));

        // JonN 7/17/01 437696
        // AV when open event properties and retargeting to another computer
        // In this scenario, pliSelected is NULL, and we need to soldier on
        CLogInfo *pliSelected = NULL;
        if (_prpa)
            _prpa->GetCurSelLogInfo((ULONG_PTR) &pliSelected);
        if (pliSelected)
            GetCategoryStr(pliSelected,
                           pelr,
                           wszBuf,
                           ARRAYLEN(wszBuf));
        AppendToClipboardString(strClipboard, IDS_CLP_EVENT_CATEGORY, wszBuf);

        GetEventIDStr((USHORT) pelr->EventID, wszBuf, ARRAYLEN(wszBuf));
        AppendToClipboardString(strClipboard, IDS_CLP_EVENT_ID, wszBuf);

        GetDateStr(pelr->TimeGenerated, wszBuf, ARRAYLEN(wszBuf));
        AppendToClipboardString(strClipboard, IDS_CLP_DATE, wszBuf);

        GetTimeStr(pelr->TimeGenerated, wszBuf, ARRAYLEN(wszBuf));
        AppendToClipboardString(strClipboard, IDS_CLP_TIME, wszBuf);

        GetUserStr(pelr, wszBuf, ARRAYLEN(wszBuf), TRUE);
        AppendToClipboardString(strClipboard, IDS_CLP_USER, wszBuf);

        AppendToClipboardString(strClipboard,
                                IDS_CLP_COMPUTER,
                                GetComputerStr(pelr));

        // JonN 7/17/01 437696
        LPWSTR pwszDescr = NULL;
        if (pliSelected)
            pwszDescr = GetDescriptionStr(pliSelected,
                                          pelr,
                                          &_strMessageFile);

        if (pwszDescr)
        {
            AppendToClipboardString(strClipboard,
                                    IDS_CLP_DESCRIPTION,
                                    pwszDescr,
                                    TRUE);
            LocalFree(pwszDescr);
            pwszDescr = NULL;
        }

        if (pelr->DataLength)
        {
            PWSTR pwzData;

            if (IsDlgButtonChecked(_hwnd, detail_word_rb))
            {
                pwzData = _pwszDataInWordFormat;
            }
            else
            {
                pwzData = _pwszDataInByteFormat;
            }

            if (pwzData)
            {
                AppendToClipboardString(strClipboard,
                                        IDS_CLP_DATA,
                                        pwzData,
                                        TRUE);
            }
            else
            {
                ASSERT(0 && "expected _pwszDataInByteFormat/_pwszDataInWordFormat to be initialized");
            }
        }

        //
        // Clipboard needs this as HGLOBAL
        //

        hUnicode = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                               sizeof(WCHAR) * (strClipboard.length() + 1));

        if (!hUnicode)
        {
            DBG_OUT_HRESULT(E_OUTOFMEMORY);
        }

        PWSTR pwzUnicode = (PWSTR)GlobalLock(hUnicode);

        if (!pwzUnicode)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        lstrcpy(pwzUnicode, strClipboard.c_str());
        GlobalUnlock(hUnicode);

        //
        // Put it on the clipboard
        //

        if (SetClipboardData(CF_UNICODETEXT, hUnicode))
        {
            hUnicode = NULL; // system owns it now
        }

    } while (0);

    if (fOpenedClipboard)
    {
        VERIFY(CloseClipboard());
    }

    if (hUnicode)
    {
        GlobalFree(hUnicode);
    }
    delete pelr;
}



//+--------------------------------------------------------------------------
//
//  Function:   AppendToClipboardString
//
//  Synopsis:   Append the resource string with id [idsLabel] followed by the
//              text pointed to by [pwzText] to [strClipboard].
//
//  Arguments:  [strClipboard]       - text for clipboard we're building up
//              [idsLabel]           - resource id of string to prefix
//                                      [pwzText]
//              [pwzText]            - data to append after label
//              [fNewlineBeforeText] - TRUE => insert cr/lf between label
//                                      and [pwzText].
//
//  History:    5-24-1999   davidmun   Created
//
//---------------------------------------------------------------------------

void
AppendToClipboardString(
    wstring &strClipboard,
    ULONG idsLabel,
    PCWSTR pwzText,
    BOOL fNewlineBeforeText)
{
    WCHAR wzLabel[MAX_PATH];

    LoadStr(idsLabel, wzLabel, ARRAYLEN(wzLabel));
    strClipboard += wzLabel;

    if (fNewlineBeforeText)
    {
        strClipboard += c_strCRLF;
    }
    strClipboard += pwzText;
    strClipboard += c_strCRLF;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDetailsPage::_OnQuerySiblings
//
//  Synopsis:   When the snapin needs to notify the property inspector that
//              the current selection has changed, it sends a query
//              siblings message.
//
//  Arguments:  [wParam] - unused
//              [lParam] - unused
//
//  Returns:    0 (continue forwarding message)
//
//  History:    4-21-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CDetailsPage::_OnQuerySiblings(
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CDetailsPage, _OnQuerySiblings);

    if (_IsFlagSet(PAGE_IS_ACTIVE))
    {
        _RefreshControls();
        _ClearFlag(PAGE_NEEDS_REFRESH);
    }
    else
    {
        _SetFlag(PAGE_NEEDS_REFRESH);
    }
    return 0; // continue forwarding message
}




//+--------------------------------------------------------------------------
//
//  Member:     CDetailsPage::_OnSetActive
//
//  Synopsis:   Handle page becoming active (visible).
//
//  Returns:    0 (always accept activation)
//
//  History:    4-21-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CDetailsPage::_OnSetActive()
{
    TRACE_METHOD(CDetailsPage, _OnSetActive);

    //
    // This page is about to be activated.  Update its controls if
    // necessary.
    //

    _SetFlag(PAGE_IS_ACTIVE);

    if (_IsFlagSet(PAGE_NEEDS_REFRESH))
    {
        _RefreshControls();
        _ClearFlag(PAGE_NEEDS_REFRESH);
    }
    return 0; // accept activation
}




//+--------------------------------------------------------------------------
//
//  Member:     CDetailsPage::_ShowProperties
//
//  Synopsis:   Show or hide the property display controls and the "no
//              record selected" message.
//
//  Arguments:  [ulFirst] - control id of first prop control
//              [ulLast]  - control id of last prop control
//              [fShow]   - TRUE => show props, FALSE => hide
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CDetailsPage::_ShowProperties(
    ULONG ulFirst,
    ULONG ulLast,
    BOOL fShow)
{
    ULONG i;
    INT   iShowState = fShow ? SW_SHOW : SW_HIDE;

    for (i = ulFirst; i <= ulLast; i++)
    {
        ShowWindow(_hCtrl(i), iShowState);
    }

    //
    // If we are showing properties and were able to obtain the
    // interface required for implementing the prev/next actions,
    // enable the prev/next buttons.
    //

    _EnableNextPrev(fShow && _prpa);

    //
    // Set the visibility of the "no object selected" text string to the
    // opposite of fShow.
    //

    ShowWindow(_hCtrl(detail_noprops_lbl), fShow ? SW_HIDE : SW_SHOW);

    //
    // Remember current state; some operations are not valid if we're not
    // showing properties.
    //

    if (fShow)
    {
        _SetFlag(PAGE_SHOWING_PROPERTIES);
    }
    else
    {
        _ClearFlag(PAGE_SHOWING_PROPERTIES);
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CDetailsPage::_OnKillActive
//
//  Synopsis:   Track active/inactive state of this page
//
//  Returns:    0 (accept deactivation)
//
//  History:    4-25-1997   DavidMun   Created
//
//  Notes:      There's no need for validation, since the record details
//              property sheet pages are read-only.
//
//---------------------------------------------------------------------------

ULONG
CDetailsPage::_OnKillActive()
{
    TRACE_METHOD(CDetailsPage, _OnKillActive);

    _ClearFlag(PAGE_IS_ACTIVE);
    return 0; // accept deactivation
}




//+--------------------------------------------------------------------------
//
//  Member:     CDetailsPage::_OnHelp
//
//  Synopsis:   Invoke context help for controls on this page
//
//  Arguments:  [message] -
//              [wParam]  -
//              [lParam]  - LPHELPINFO
//
//  History:    07-27-1999   davidmun   Created
//
//---------------------------------------------------------------------------

VOID
CDetailsPage::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    InvokeWinHelp(message, wParam, lParam, HELP_FILENAME, s_aulHelpIDs);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDetailsPage::_RefreshControls
//
//  Synopsis:   Update the data displayed in the string page.
//
//  History:    4-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CDetailsPage::_RefreshControls()
{
    TRACE_METHOD(CDetailsPage, _RefreshControls);

    EVENTLOGRECORD *pelr = NULL;
    HWND hEdit = _hCtrl(detail_data_edit);

    do
    {
        ZeroMemory(&_chrgLastLinkClick, sizeof _chrgLastLinkClick);

        if (_prpa)
        {
            // in case of error we'll display 'no record'

            _prpa->GetCurSelRecCopy((ULONG_PTR) &pelr);
        }

        if (!pelr)
        {
            if (!_IsFlagSet(PAGE_SHOWING_PROPERTIES))
            {
                // we are already not showing props
                break;
            }

            // Hide property controls, show "no data" control

            _ShowProperties(FIRST_DETAILS_PROP_CTRL,
                            LAST_DETAILS_PROP_CTRL,
                            FALSE);
            break;
        }

        // ensure string data page is displayed

        if (!_IsFlagSet(PAGE_SHOWING_PROPERTIES))
        {
            _ShowProperties(FIRST_DETAILS_PROP_CTRL,
                            LAST_DETAILS_PROP_CTRL,
                            TRUE);
        }

        WCHAR wszBuf[MAX_DETAILS_STR];
        ::ZeroMemory(wszBuf,sizeof(wszBuf)); // JonN 7/10/01 437696

        GetDateStr(pelr->TimeGenerated, wszBuf, ARRAYLEN(wszBuf));
        SetDlgItemText(_hwnd, detail_date_txt, wszBuf);

        WCHAR wzTimeSep[5];     // per SDK max length is 4
        WCHAR wzLeadingZero[3]; // per SDK max length is 2

        VERIFY(GetLocaleInfo(LOCALE_USER_DEFAULT,
                             LOCALE_STIME,
                             wzTimeSep,
                             ARRAYLEN(wzTimeSep)));

        VERIFY(GetLocaleInfo(LOCALE_USER_DEFAULT,
                             LOCALE_ITLZERO,
                             wzLeadingZero,
                             ARRAYLEN(wzLeadingZero)));

        // JonN 4/12/01 367162
        // Event Viewer, Property Sheet shows time in wrong format
        GetTimeStr(pelr->TimeGenerated, wszBuf, ARRAYLEN(wszBuf));
        SetDlgItemText(_hwnd, detail_time_txt, wszBuf);

        GetUserStr(pelr, wszBuf, ARRAYLEN(wszBuf), TRUE);
        SetDlgItemText(_hwnd, detail_user_txt, wszBuf);

        SetDlgItemText(_hwnd, detail_computer_txt, GetComputerStr(pelr));

        GetEventIDStr((USHORT) pelr->EventID, wszBuf, ARRAYLEN(wszBuf));
        SetDlgItemText(_hwnd, detail_event_id_txt, wszBuf);

        SetDlgItemText(_hwnd, detail_source_txt, GetSourceStr(pelr));

        SetDlgItemText(_hwnd, detail_type_txt, GetTypeStr(GetEventType(pelr)));

        //
        // Note _pSnapin->GetCurSelLogInfo() returns NULL if the currently
        // selected scope pane item is not a log folder, but in that
        // case pelr should == NULL and we would've returned up at the
        // top of this routine.
        //

        CLogInfo *pliSelected = NULL;
        if (_prpa)
            _prpa->GetCurSelLogInfo((ULONG_PTR) &pliSelected);
        ::ZeroMemory(wszBuf,sizeof(wszBuf)); // JonN 7/10/01 437696

        if (pliSelected)
            GetCategoryStr(pliSelected,
                           pelr,
                           wszBuf,
                           ARRAYLEN(wszBuf));
        SetDlgItemText(_hwnd, detail_category_txt, wszBuf);

        LPWSTR pwszUnexpandedDescriptionText = NULL;
        LPWSTR pwszDescr = GetDescriptionStr(
                    pliSelected,
                    pelr,
                    &_strMessageFile,
                    TRUE,
                    &pwszUnexpandedDescriptionText);

        if (pwszDescr)
        {
            _RefreshDescriptionControl( pwszDescr,
                                        pwszUnexpandedDescriptionText );

            LocalFree(pwszDescr);
            pwszDescr = NULL;
        }
        else
        {
            SetDlgItemText(_hwnd, detail_description_edit, L"");
        }
        if (pwszUnexpandedDescriptionText)
        {
            LocalFree(pwszUnexpandedDescriptionText);
            pwszUnexpandedDescriptionText = NULL;
        }

        //
        // pelr is a valid record.  If it has no binary data, disable the
        // controls for byte & word format selection, ensure that the displayed
        // string is empty, and quit.
        //

        if (!pelr->DataLength)
        {
            Edit_SetText(hEdit, L"");
            _EnableBinaryControls(FALSE);
            break;
        }

        //
        // page is a valid record with binary data.  put it in the edit box.
        //

        _EnableBinaryControls(TRUE);


        ULONG ulDisplayAs;

        if (IsDlgButtonChecked(_hwnd, detail_word_rb))
        {
            ulDisplayAs = detail_word_rb;
        }
        else
        {
            ulDisplayAs = detail_byte_rb;
        }

        BOOL fDisplayByte = (ulDisplayAs == detail_byte_rb);

        LPWSTR *ppwszExistingBuf;
        ULONG  *pcchExistingBuf;
        ULONG cchNeeded;

        if (fDisplayByte)
        {
            ppwszExistingBuf = &_pwszDataInByteFormat;
            pcchExistingBuf = &_cchDataInByteFormat;
            cchNeeded = ByteDisplaySize(pelr->DataLength);
        }
        else
        {
            ppwszExistingBuf = &_pwszDataInWordFormat;
            pcchExistingBuf = &_cchDataInWordFormat;
            cchNeeded = WordDisplaySize(pelr->DataLength);
        }

        //
        // If the buffer allocated for the current display mode is too small,
        // reallocate it.  If there is no buffer yet, allocate one.
        //

        if (*ppwszExistingBuf && *pcchExistingBuf < cchNeeded)
        {
            //
            // There is a buffer allocated for the requested format, but it
            // is too small.  Try to allocate a new one.  If that fails,
            // terminate the old buffer but leave it in place.  It may
            // be big enough to display some other record.
            //

            Dbg(DEB_TRACE,
                "Allocating replacement buffer of length %u bytes\n",
                cchNeeded * sizeof(WCHAR));
            LPWSTR pwszNew = new WCHAR[cchNeeded];

            if (!pwszNew)
            {
                **ppwszExistingBuf = L'\0';
                DBG_OUT_HRESULT(E_OUTOFMEMORY);
                _ulSelectedFormat = ulDisplayAs;
                Edit_SetText(hEdit, *ppwszExistingBuf);
                break;
            }

            //
            // Free the old buffer and replace it with the new
            //

            delete [] *ppwszExistingBuf;
            *ppwszExistingBuf = pwszNew;
            *pcchExistingBuf = cchNeeded;
        }
        else if (!*ppwszExistingBuf)
        {
            //
            // A buffer for the requested format data hasn't been allocated yet.
            // Try to create one.
            //

            ASSERT(!*pcchExistingBuf);

            Dbg(DEB_TRACE,
                "Allocating new buffer of length %u bytes\n",
                cchNeeded * sizeof(WCHAR));
            *ppwszExistingBuf = new WCHAR[cchNeeded];

            if (!*ppwszExistingBuf)
            {
                DBG_OUT_HRESULT(E_OUTOFMEMORY);
                break;
            }
            *pcchExistingBuf = cchNeeded;
        }

        //
        // Update the contents of the buffer.  Terminate the string
        // for the buffer not being displayed as a signal that it
        // needs to be refreshed when (if) it is selected.
        //

        if (fDisplayByte)
        {
            FormatBufferToBytes(GetData(pelr),
                                pelr->DataLength,
                                *ppwszExistingBuf,
                                cchNeeded);

            if (_pwszDataInWordFormat)
            {
                *_pwszDataInWordFormat = L'\0';
            }
        }
        else
        {
            FormatBufferToWords(GetData(pelr),
                                pelr->DataLength,
                                *ppwszExistingBuf,
                                cchNeeded);

            if (_pwszDataInByteFormat)
            {
                *_pwszDataInByteFormat = L'\0';
            }
        }

        //
        // Set the text in the edit window
        //

        Edit_SetText(hEdit, *ppwszExistingBuf);
        _ulSelectedFormat = ulDisplayAs;
    } while (0);

    delete pelr;
}

//+--------------------------------------------------------------------------
//
//  Member:     RetrieveRicheditText
//
//  Synopsis:   Retrieve text from a richedit field
//
//  Returns:    LocalAlloc'ed string
//
//  History:    03-01-2002   JonN       Created per 539485
//
//---------------------------------------------------------------------------
LPWSTR RetrieveRicheditText( HWND hwndRichEdit,
                             LONG cpMin,
                             LONG cpMax )
{
    if (cpMin > cpMax)
    {
        ASSERT(FALSE);
        return NULL;

    }
    LPWSTR pwszText = (WCHAR*)LocalAlloc(LPTR,
                        ((cpMax-cpMin)+2) * sizeof(WCHAR));
    if (NULL == pwszText)
    {
        ASSERT(FALSE);
        return NULL;
    }
    TEXTRANGE textrange = { {cpMin, cpMax}, pwszText };
    LRESULT lr = SendMessage(hwndRichEdit,
                             EM_GETTEXTRANGE,
                             0,
                             (LPARAM)&textrange);
    if (lr != (cpMax-cpMin))
    {
        ASSERT(FALSE);
        LocalFree(pwszText);
        return NULL;
    }
    return pwszText;
}

//+--------------------------------------------------------------------------
//
//  Member:     FindNextLink
//
//  Synopsis:   Find the next hotlink in a richedit field
//
//  Returns:    true iif next link is in *pcpMin, *pcpMax
//
//  History:    03-01-2002   JonN       Created per 539485
//
//---------------------------------------------------------------------------
bool FindNextLink( HWND hwndRichEdit,
                   LRESULT cchTotal,
                   LONG cpStart,
                   LONG* pcpMin,
                   LONG* pcpMax,
                   LPWSTR* ppwszLink )
{
    if (!pcpMin || !pcpMax || cchTotal < (LRESULT)cpStart || !ppwszLink)
    {
        ASSERT(FALSE);
        return false;
    }

    LONG cpMin = -1;
    CHARFORMAT2 charformat2;
    for (LONG cpChar = cpStart; (LRESULT)cpChar < cchTotal; cpChar++)
    {
        CHARRANGE charrange = { cpChar, cpChar+1 };
        (void) SendMessage(hwndRichEdit, EM_EXSETSEL, 0, (LPARAM)&charrange);
        ZeroMemory( &charformat2, sizeof(charformat2) );
        charformat2.cbSize = sizeof(charformat2);
        (void) SendMessage(hwndRichEdit,
                           EM_GETCHARFORMAT,
                           SCF_SELECTION,
                           (LPARAM)&charformat2);
        if (charformat2.dwEffects & CFE_LINK)
        {
            if (-1 == cpMin)
                cpMin = cpChar;
        }
        else
        {
            if (-1 != cpMin)
            {
                // URL in the middle of the text
                *pcpMin = cpMin;
                *pcpMax = cpChar;
                if (NULL != ppwszLink)
                {
                    *ppwszLink = RetrieveRicheditText(
                            hwndRichEdit, cpMin, cpChar );
                }
                return true;
            }
        }
    } // for
    if (-1 != cpMin)
    {
        // URL at the end of the text
        *pcpMin = cpMin;
        *pcpMax = (LONG)cchTotal;
        if (NULL != ppwszLink)
        {
            *ppwszLink = RetrieveRicheditText(
                            hwndRichEdit, cpMin, (LONG)cchTotal );
        }
        return true;
    }
    return false; // no link found
}

//+--------------------------------------------------------------------------
//
//  Member:     RemoveLink
//
//  Synopsis:   Removes the hotlink property from text in a richedit field
//
//  History:    03-04-2002   JonN       Created per 539485
//
//---------------------------------------------------------------------------
VOID RemoveLink( HWND hwndRichEdit,
                 LONG cpMin,
                 LONG cpMax )
{
    CHARRANGE charrange = { cpMin, cpMax };
    (void) SendMessage(hwndRichEdit, EM_EXSETSEL, 0, (LPARAM)&charrange);
    CHARFORMAT2 charformat2;
    ZeroMemory( &charformat2, sizeof(charformat2) );
    charformat2.cbSize = sizeof(charformat2);
    charformat2.dwMask = CFM_LINK;
    (void) SendMessage(hwndRichEdit,
                       EM_SETCHARFORMAT,
                       SCF_SELECTION,
                       (LPARAM)&charformat2);
}

//+--------------------------------------------------------------------------
//
//  Member:     CDetailsPage::_RefreshDescriptionControl
//
//  Synopsis:   Update the data displayed in the description field,
//              and activate URLs as appropriate.
//
//  History:    03-01-2002   JonN       Created per 539485
//
//---------------------------------------------------------------------------
VOID CDetailsPage::_RefreshDescriptionControl(
            LPCWSTR pcwszDescriptionText,
            LPCWSTR pcwszUnexpandedDescriptionText )
{
    if ( IsBadStringPtr(pcwszDescriptionText,(UINT_PTR)-1)
      || IsBadStringPtr(pcwszUnexpandedDescriptionText,(UINT_PTR)-1)
       )
    {
        ASSERT(FALSE);
        return;
    }

    // ISSUE-2002/03/01-JonN CODEWORK use EM_GETOLEINTERFACE to send
    // ITextDocument::Freeze and prevent screen flicker

    HWND hwndRichEdit = _hCtrl(detail_description_edit);
    SendMessage(hwndRichEdit,
                EM_AUTOURLDETECT,
                TRUE, 0);

    //
    // First harvest the list of URLs in the unexpanded text
    //

    SetDlgItemText(_hwnd, detail_description_edit,
                   pcwszUnexpandedDescriptionText);
    GETTEXTLENGTHEX gettextlengthex = { GTL_NUMCHARS, 1200 /* UNICODE CP */ };
    LRESULT cchTotal = SendMessage(hwndRichEdit,
                                   EM_GETTEXTLENGTHEX,
                                   (LPARAM)&gettextlengthex,
                                   FALSE);
    if (E_INVALIDARG == cchTotal)
    {
        ASSERT(false);
        return; // CODEWORK should reset all URLs
    }
    CStringArray strarrayUnexpandedURLs;
    LONG cpMin = 0;
    LONG cpMax = 0;
    LPWSTR pwszLink = NULL;
    while (FindNextLink(hwndRichEdit, cchTotal, cpMin,
                        &cpMin, &cpMax, &pwszLink))
    {
        // add link to list
        if (NULL != pwszLink)
        {
            if ( 0 == strarrayUnexpandedURLs.Add(pwszLink) )
            {
                ASSERT(FALSE);
            }
            ::LocalFree(pwszLink);
        }
        else
        {
            ASSERT(FALSE);
        }
        cpMin = cpMax;
    }


    //
    // Now check the links in the complete text
    //

    SetDlgItemText(_hwnd, detail_description_edit,
                   pcwszDescriptionText);

    // JonN 03/01/01 539485
    SendMessage(hwndRichEdit,
                EM_AUTOURLDETECT,
                FALSE, 0);

    cchTotal = SendMessage(hwndRichEdit,
                           EM_GETTEXTLENGTHEX,
                           (LPARAM)&gettextlengthex,
                           FALSE);
    if (E_INVALIDARG == cchTotal)
    {
        ASSERT(false);
        return; // CODEWORK should reset all URLs
    }

    cpMin = 0;
    cpMax = 0;
    pwszLink = NULL;
    while (FindNextLink(hwndRichEdit, cchTotal, cpMin,
                        &cpMin, &cpMax, &pwszLink))
    {
        if (NULL != pwszLink)
        {
            //
            // 537248-JonN-2002/04/17 Remove invalid links
            //
            // First test: all links must start with a valid header
            bool fRemoveLink =
                   (0 != _wcsnicmp(pwszLink, L"http:", 5))
                && (0 != _wcsnicmp(pwszLink, L"https:", 6))
                && (0 != _wcsicmp( pwszLink, g_wszRedirectionURL));
            // Second test: all links must originate in secure source file
            if (!fRemoveLink)
                fRemoveLink = (0 == strarrayUnexpandedURLs.Query( pwszLink ));
            if (fRemoveLink)
            {
                RemoveLink( hwndRichEdit, cpMin, cpMax );
            }
            ::LocalFree(pwszLink);
        }
        else
        {
            ASSERT(FALSE);
        }
        cpMin = cpMax;
    }

    Edit_SetSel(hwndRichEdit, 0, 0);
    // JonN 12/11/01 495191
    const POINT pointUpperLeft = {0,0};
    SendMessage(hwndRichEdit,
                EM_SETSCROLLPOS,
                0,
                (LPARAM)&pointUpperLeft);
}




void
FreeButtonImage(
    HWND hwndBtn)
{
    HANDLE hIcon = (HANDLE) SendMessage(hwndBtn, BM_GETIMAGE, IMAGE_ICON, 0);

    if (!hIcon)
    {
        return;
    }

    SendMessage(hwndBtn, BM_SETIMAGE, IMAGE_ICON, 0);
    VERIFY(DestroyIcon((HICON)hIcon));
}




//+--------------------------------------------------------------------------
//
//  Member:     CDetailsPage::_OnDestroy
//
//  Synopsis:   Notify owning snapin that the sheet is going away.
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CDetailsPage::_OnDestroy()
{
    TRACE_METHOD(CDetailsPage, _OnDestroy);

    //
    // Notify snapin we're closing so it can free copy of the currently
    // selected record, and so it knows not to try and notify us when
    // the selection changes.
    //

    if (_prpa)
    {
        _prpa->SetInspectorWnd(NULL);
    }

    //
    // Destroy the images loaded for the icon pushbuttons
    //

    FreeButtonImage(_hCtrl(detail_prev_pb));
    FreeButtonImage(_hCtrl(detail_next_pb));
    FreeButtonImage(_hCtrl(detail_copy_pb));
}



//+--------------------------------------------------------------------------
//
//  Member:     CDetailsPage::_EnableBinaryControls
//
//  Synopsis:   Enable or disable the controls allowing the user to switch
//              from byte to word format.
//
//  Arguments:  [fEnable] - TRUE => enable, FALSE => disable
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CDetailsPage::_EnableBinaryControls(
    BOOL fEnable)
{
    // JonN 12/04/01 500720/412818
    HWND hwndFocus = ::GetFocus();
    if ( _hCtrl(detail_data_lbl) == hwndFocus
      || _hCtrl(detail_byte_rb)  == hwndFocus
      || _hCtrl(detail_word_rb)  == hwndFocus )
    {
        SetFocus(_hCtrl(detail_date_txt));
    }

    EnableWindow(_hCtrl(detail_data_lbl), fEnable);
    EnableWindow(_hCtrl(detail_byte_rb), fEnable);
    EnableWindow(_hCtrl(detail_word_rb), fEnable);
}







#define ANSI_SET_START          0x20

//+--------------------------------------------------------------------------
//
//  Function:   AddressDisplaySize
//
//  Synopsis:   Return the number of characters needed to represent the
//              address for [cbOffset] bytes.  Returns at least 4.
//
//  History:    4-19-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
AddressDisplaySize(
    ULONG cbOffset)
{
    ULONG cBits;
    ULONG cbOffsetCopy = cbOffset;

    for (cBits = 0; cbOffsetCopy; cBits++, cbOffsetCopy >>= 1)
    {
    }

    ULONG cch = (cBits + 3) / 4;  // each character represents 4 bits

    if (cch < 4)
    {
        cch = 4;
    }
    Dbg(DEB_TRACE,
        "AddressDisplaySize of %#x bytes is %u characters (%u bits)\n",
        cbOffset,
        cch,
        cBits);

    return cch;
}

//+--------------------------------------------------------------------------
//
//  Function:   ByteDisplaySize
//
//  Synopsis:   Return the number of characters needed for a string buffer
//              that will be filled by giving FormatBufferToBytes [cbData]
//              bytes to format.  Includes space for null terminator.
//
//  History:    12-17-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
ByteDisplaySize(ULONG cbData)
{
    //
    // cbData will be displayed as a set of 8 byte lines.
    // Each line of the form:
    //
    //     'xxxx: xx xx xx xx xx xx xx xx   ........\r\n'
    //                                   ^^^
    // Which is:
    //

    ULONG cchAddress = AddressDisplaySize(cbData);

    ULONG cchPerLine = cchAddress + // 'xxxx'
                       2 +          // ': '
                       8 * 3 +      // 'xx xx xx xx xx xx xx xx '
                       2 +          // '  ' (last two of ^ in example above)
                       8 +          // '........'
                       2;           // '\r\n'


    //
    // There will be cbData / 8 full lines, and if cbData is not evenly
    // divisible by 8, there will be 1 partial line.
    //

    ULONG cLines = cbData / 8 + (cbData % 8 ? 1 : 0);
    ULONG cchToDisplay = cchPerLine * cLines;

    return cchToDisplay + 1;
}




//+--------------------------------------------------------------------------
//
//  Function:   WordDisplaySize
//
//  Synopsis:   Return the count of characters required to hold a word
//              display of [cbData] bytes.
//
//  Arguments:  [cbData] - size of data to display
//
//  Returns:    Count of characters, including null terminator.
//
//  History:    4-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
WordDisplaySize(ULONG cbData)
{
    //
    // cbData will be displayed as a set of 4 word lines.
    // Each line of the form:
    //
    //     'xxxx: xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx \r\n'
    //
    // Which is:
    //

    ULONG cchAddress = AddressDisplaySize(cbData);

    ULONG cchPerLine = cchAddress + // 'xxxx'
                       2 +          // ': '
                       4 * 9 +      // 4 of 'xxxxxxxx '
                       2;           // '\r\n'

    //
    // There will be cbData / 16 full lines, and if cbData is not evenly
    // divisible by 16, there will be 1 partial line.
    //

    ULONG cLines = cbData / 16 + (cbData % 16 ? 1 : 0);
    ULONG cchToDisplay = cchPerLine * cLines;

    return cchToDisplay + 1;
}




//+---------------------------------------------------------------------------
//
//  Function:   FormatBufferToBytes
//
//  Synopsis:   This function will fill [wszFormatStr] with a hex byte dump
//              of the [cbBufSize] bytes starting at [pbBuf], using this
//              format:
//
//              0000: 14 08 FF 02 30 0D 04 00  ....0...
//              0008: 56 00 20 00 00 00 00 00  V. .....
//
//  Arguments:  [pbBuf]        - pointer to the byte buffer
//              [cbBufSize]    - number of bytes pointed to by [pbBuf]
//              [wszFormatStr] - place to store the resultant string,
//                                at least as large as
//                                ByteDisplaySize(cbBufSize) wchars.
//
//  History:    12-16-1996   DavidMun   Created
//
//  Notes:      CAUTION: if you change the output of this function you must
//              also change ByteDisplaySize to match.
//
//----------------------------------------------------------------------------

VOID
FormatBufferToBytes(
    const BYTE *pbBuf,
    ULONG       cbBufSize,
    WCHAR       wszFormatStr[],
    ULONG       cchFormatStr)
{
    TRACE_FUNCTION(FormatBufferToBytes);
    TIMER(FormatBufferToBytes);

    // NTRAID#NTBUG9-546298-2002/05/04-ericb
    if (IsBadReadPtr(pbBuf, cbBufSize))
    {
       LoadStr(IDS_EVENTLOG_FILE_CORRUPT, wszFormatStr, cchFormatStr, L"---");
       return;
    }

    WCHAR *pwszNext = &wszFormatStr[0];
    const BYTE *pbNext = pbBuf;
    ULONG i;
    USHORT cchAddress = static_cast<USHORT>(AddressDisplaySize(cbBufSize));

    ASSERT(cbBufSize);

    WCHAR wszFormat[] = L"%04x: %02x %02x %02x %02x %02x %02x %02x %02x   ";
    ASSERT(cchAddress < 10);
    wszFormat[2] = L'0' + cchAddress;

    if (cbBufSize >= 8)
    {
        const BYTE *pbEnd = pbBuf + (cbBufSize & ~7UL);

        for (; pbNext < pbEnd; pbNext += 8)
        {
            pwszNext += wsprintf(pwszNext,
                                 wszFormat,
                                 pbNext - pbBuf,
                                 pbNext[0],
                                 pbNext[1],
                                 pbNext[2],
                                 pbNext[3],
                                 pbNext[4],
                                 pbNext[5],
                                 pbNext[6],
                                 pbNext[7]);

            for (i = 0; i < 8; i++)
            {
                if (pbNext[i] >= ANSI_SET_START)
                {
                    *pwszNext++ = (WCHAR) pbNext[i];
                }
                else
                {
                    *pwszNext++ = L'.';
                }
            }

            *pwszNext++ = L'\r';
            *pwszNext++ = L'\n';
        }
    }
    Dbg(DEB_TRACE, "null terminating\n");
    *pwszNext = L'\0';

    // do 1..7 bytes

    ULONG cbRemain = cbBufSize & 7;

    Dbg(DEB_TRACE, "%u bytes remain\n", cbRemain);
    if (!cbRemain)
    {
        // overwrite trailing CR LF

        pwszNext[-2] = L'\0';
        return;
    }

    WCHAR wszShortFormat[] = L"%04x: ";
    wszShortFormat[2] = L'0' + cchAddress;

    pwszNext += wsprintf(pwszNext, wszShortFormat, pbNext - pbBuf);

    for (i = 0; i < cbRemain; i++)
    {
        pwszNext += wsprintf(pwszNext, L"%02x ", pbNext[i]);
    }

    //
    // Pad from the last 'xx ' (3 chars each) entered to the starting
    // column of the '........' display.  Add an extra 2 to get the
    // total of 3 spaces between the last hex digit and the first of
    // the byte ('.') display.
    //

    for (i = 2 + 3 * (8 - cbRemain); i; i--)
    {
        *pwszNext++ = L' ';
    }

    //
    // Do the dot display
    //

    for (i = 0; i < cbRemain; i++)
    {
        if (pbNext[i] >= ANSI_SET_START)
        {
            *pwszNext++ = (WCHAR) pbNext[i];
        }
        else
        {
            *pwszNext++ = L'.';
        }
    }

    //
    // Pad with spaces to the last column of the byte display, then null-
    // terminate.
    //

    for (i = 8 - cbRemain; i; i--)
    {
        *pwszNext++ = L' ';
    }
    *pwszNext = L'\0';
}




//+---------------------------------------------------------------------------
//
//  Function:   FormatBufferToWords
//
//  Synopsis:   This function will format the buffer into a null terminated
//              wide char string in the format:
//
//              0000: 1408FF02 300D0400 000f0000 00000b00
//              0010: 00000000 00101100 006bffff 0900bfe0
//
//  Arguments:  [pbBuf]        -- IN pointer to the byte buffer
//              [cbBufSize]    -- IN buffer size
//              [wszFormatStr] -- OUT place to store the resultant string
//
//  History:    12-17-1996   DavidMun   Created
//
//  Notes:      [pbBuf] must be dword aligned
//
//----------------------------------------------------------------------------

VOID
FormatBufferToWords(
    const BYTE *pbBuf,
    ULONG       cbBufSize,
    WCHAR       wszFormatStr[],
    ULONG       cchFormatStr)
{
    TRACE_FUNCTION(FormatBufferToWords);
    TIMER(FormatBufferToWords);

    // NTRAID#NTBUG9-546298-2002/05/04-ericb
    if (IsBadReadPtr(pbBuf, cbBufSize))
    {
       LoadStr(IDS_EVENTLOG_FILE_CORRUPT, wszFormatStr, cchFormatStr, L"---");
       return;
    }

    WCHAR *pwszNext = &wszFormatStr[0];
    UNALIGNED64 const DWORD *pdwNext = (DWORD *) pbBuf;
    USHORT cchAddress = static_cast<USHORT>(AddressDisplaySize(cbBufSize));
    ULONG i;

    ASSERT(cbBufSize);

    WCHAR wszFormat[] = L"%04x: %08x %08x %08x %08x\r\n";
    ASSERT(cchAddress < 10);
    wszFormat[2] = L'0' + cchAddress;

    if (cbBufSize >= 16)
    {
        UNALIGNED64 const DWORD *pdwEnd = (DWORD *) (pbBuf + (cbBufSize & ~15UL));

        for (; pdwNext < pdwEnd; pdwNext += 4)
        {
            pwszNext += wsprintf(pwszNext,
                                 wszFormat,
                                 (BYTE *)pdwNext - pbBuf,
                                 pdwNext[0],
                                 pdwNext[1],
                                 pdwNext[2],
                                 pdwNext[3]);
        }
    }

    ULONG cbRemain = cbBufSize & 15UL;

    if (!cbRemain)
    {
        // overwrite trailing CR LF

        pwszNext[-2] = L'\0';
        return;
    }

    // do 1..15 bytes

    WCHAR wszShortFormat[] = L"%04x: ";
    wszShortFormat[2] = L'0' + cchAddress;

    pwszNext += wsprintf(pwszNext,
                         wszShortFormat,
                         (BYTE *)pdwNext - pbBuf);

    BYTE *pbNext = (BYTE *) pdwNext;

    for (i = cbRemain; i; )
    {
        if (i / 4)
        {
            pwszNext += wsprintf(pwszNext, L"%08x ", *(UNALIGNED64 const DWORD *)pbNext);
            pbNext += 4;
            i -= 4;
        }
        else if (i == 3)
        {
            WORD wLow = *(UNALIGNED64 const WORD *)pbNext;

            pbNext += 2;
            i -= 2;

            WORD wHigh = *pbNext;
            pbNext++;
            i--;

            DWORD dwFull = (((DWORD)wHigh) << 16) | (DWORD)wLow;

            pwszNext += wsprintf(pwszNext, L"%06x", dwFull);
        }
        else if (i / 2)
        {
            pwszNext += wsprintf(pwszNext, L"%04x", *(UNALIGNED64 const WORD *)pbNext);
            pbNext += 2;
            i -= 2;
        }
        else
        {
            pwszNext += wsprintf(pwszNext, L"%02x", *pbNext);
            i--;
            ASSERT(!i);
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   YesNoConfirm
//
//  Synopsis:   Ask the user to confirm wrapping to continue a prev/next
//              operation.
//
//  Arguments:  [hwnd]     - parent
//              [idsTitle] - caption
//              [idsMsg]   - text
//
//  Returns:    IDYES or IDNO
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
YesNoConfirm(
    HWND hwnd,
    ULONG idsTitle,
    ULONG idsMsg)
{
    ULONG ulResult = IDNO;
    HRESULT hr;
    WCHAR wszMsg[160];
    WCHAR wszTitle[160];

    do
    {
        hr = LoadStr(idsTitle, wszTitle, ARRAYLEN(wszTitle));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = LoadStr(idsMsg, wszMsg, ARRAYLEN(wszMsg));
        BREAK_ON_FAIL_HRESULT(hr);

        ulResult = MessageBox(hwnd,
                              wszMsg,
                              wszTitle,
                              MB_YESNO | MB_ICONQUESTION);
    } while (0);


    return ulResult;
}




//+--------------------------------------------------------------------------
//
//  Function:   ButtonFaceColorIsDark
//
//  Synopsis:   Return TRUE if the button face color is dark (implying that
//              the light colored button icons should be used).
//
//  History:    09-08-1999   davidmun   Created
//
//---------------------------------------------------------------------------

BOOL
ButtonFaceColorIsDark()
{
    COLORREF    rgbBtnFace = GetSysColor(COLOR_BTNFACE);

    ULONG   ulColors = GetRValue(rgbBtnFace) +
                       GetGValue(rgbBtnFace) +
                       GetBValue(rgbBtnFace);

    return ulColors < 300;  // arbitrary threshold
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\dllmain.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       dllmain.cxx
//
//  Contents:   DLL entry point
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+----------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Provide a DllMain for Win32
//
//  Arguments:  hInstance - HANDLE to this dll
//              dwReason  - Reason this function was called. Can be
//                          Process/Thread Attach/Detach.
//
//  Returns:    BOOL - TRUE if no error, FALSE otherwise
//
//  History:    24-May-95 EricB created.
//              12-05-1996   DavidMun   Stolen for this project
//
//-----------------------------------------------------------------------------
BOOL
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        Dbg(DEB_ITRACE, ">DllMain: DLL_PROCESS_ATTACH\n");

        //
        // Get instance handle
        //

        g_hinst = hInstance;

        //
        // Disable thread notification from OS
        //

        DisableThreadLibraryCalls(hInstance);
        Dbg(DEB_ITRACE, "<DllMain: DLL_PROCESS_ATTACH\n");
        break;

    case DLL_PROCESS_DETACH:
        Dbg(DEB_ITRACE, "DllMain: >DLL_PROCESS_DETACH\n");
        DEBUG_VERIFY_INSTANCE_COUNT(CSources);
        DEBUG_VERIFY_INSTANCE_COUNT(CSourceInfo);
        DEBUG_VERIFY_INSTANCE_COUNT(CCategories);
        DEBUG_VERIFY_INSTANCE_COUNT(CComponentDataCF);
        DEBUG_VERIFY_INSTANCE_COUNT(CComponentData);
        DEBUG_VERIFY_INSTANCE_COUNT(CDataObject);
        DEBUG_VERIFY_INSTANCE_COUNT(CDetailsPage);
        DEBUG_VERIFY_INSTANCE_COUNT(CFindFilterBase);
        DEBUG_VERIFY_INSTANCE_COUNT(CFilter);
        DEBUG_VERIFY_INSTANCE_COUNT(CFilterPage);
        DEBUG_VERIFY_INSTANCE_COUNT(CFindInfo);
        DEBUG_VERIFY_INSTANCE_COUNT(CFindDlg);
        DEBUG_VERIFY_INSTANCE_COUNT(CGeneralPage);
        DEBUG_VERIFY_INSTANCE_COUNT(CInspectorInfo);
        DEBUG_VERIFY_INSTANCE_COUNT(CEventLog);
        DEBUG_VERIFY_INSTANCE_COUNT(CLogCache);
        DEBUG_VERIFY_INSTANCE_COUNT(CLogInfo);
        DEBUG_VERIFY_INSTANCE_COUNT(CSnapin);
        DEBUG_VERIFY_INSTANCE_COUNT(CWizardPage);

        //
        // These are owned by globals and haven't been destructed yet:
        //

        // DEBUG_VERIFY_INSTANCE_COUNT(CDllCacheItem);
        // DEBUG_VERIFY_INSTANCE_COUNT(CSidCacheItem);

        //
        // The globals will make these calls themselves in their
        // dtors.
        //
        Dbg(DEB_ITRACE, "DllMain: <DLL_PROCESS_DETACH\n");
        break;
    }
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\consts.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       consts.cxx
//
//  Contents:   Definitions of constants.
//
//  History:    07-03-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

const CLSID
CLSID_EventLogSnapin =
{
    0x975797fc,
    0x4e2a,
    0x11d0,
    { 0xb7, 0x02, 0x00, 0xc0, 0x4f, 0xd8, 0xdb, 0xf7 }
};

const GUID
GUID_EventViewerRootNode = /* DC1C6BEC-4E2A-11D0-B702-00C04FD8DBF7 */
{
    0xdc1c6bec,
    0x4e2a,
    0x11d0,
    { 0xb7, 0x02, 0x00, 0xc0, 0x4f, 0xd8, 0xdb, 0xf7 }
};

const GUID
GUID_ScopeViewNode = /* 7AB4A1FC-E403-11D0-9A97-00C04FD8DBF7 */
{
    0x7ab4a1fc,
    0xe403,
    0x11d0,
    { 0x9a, 0x97, 0x00, 0xc0, 0x4f, 0xd8, 0xdb, 0xf7 }
};

const GUID
GUID_ResultRecordNode = /* 7D7FE374-E403-11D0-9A97-00C04FD8DBF7 */
{
    0x7d7fe374,
    0xe403,
    0x11d0,
    { 0x9a, 0x97, 0x00, 0xc0, 0x4f, 0xd8, 0xdb, 0xf7 }
};

const CLSID
CLSID_SysToolsExt =
{
    0x394c052e,
    0xb830,
    0x11d0,
    { 0x9a, 0x86, 0x00, 0xc0, 0x4f, 0xd8, 0xdb, 0xf7 }
};

const CLSID
CLSID_SnapinAbout =
{
    0xf778c6b4,
    0xc08b,
    0x11d2,
    { 0x97, 0x6c, 0x00, 0xc0, 0x4f, 0x79, 0xdb, 0x19 }
};

const USHORT BETA3_FILE_VERSION = 0x0200;
const USHORT FILE_VERSION_MIN = 0x0200;
const USHORT FILE_VERSION_MAX = 0x03FF;
const USHORT FILE_VERSION = 0x0300;



const TCHAR SNAPINS_KEY[]               = TEXT("Software\\Microsoft\\MMC\\SnapIns");
const TCHAR g_szNodeType[]              = TEXT("NodeType");
const TCHAR g_szNodeTypes[]             = TEXT("NodeTypes");
const TCHAR g_szStandAlone[]            = TEXT("StandAlone");
const TCHAR g_szNameString[]            = TEXT("NameString");
const TCHAR g_szNameStringIndirect[]    = TEXT("NameStringIndirect");
const TCHAR g_szAbout[]                 = TEXT("About");
const TCHAR NODE_TYPES_KEY[]            = TEXT("Software\\Microsoft\\MMC\\NodeTypes");
const TCHAR g_szExtensions[]            = TEXT("Extensions");
const TCHAR g_szNameSpace[]             = TEXT("NameSpace");
const TCHAR g_szOverrideCommandLine[]   = TEXT("/Computer=");   // Not subject to localization
const TCHAR g_szAuxMessageSourceSwitch[] = TEXT("/AuxSource="); // Not subject to localization
const TCHAR g_szLocalMachine[]          = TEXT("LocalMachine"); // Not subject to localization
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\elsrc.h ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       resource.h
//
//  Contents:   Resource ids
//
//  History:    12-06-1996   DavidMun   Created
//
//---------------------------------------------------------------------------


#ifndef __ELSRC_H_
#define __ELSRC_H_

/////////////////////////////////////////////////////////////////////////////
//
// Strings
//

//
// !!!CAUTION!!!: IDS_SYSTEM_DEFAULT_DISPLAY_NAME through
// IDS_CUSTOM_DEFAULT_DISPLAY_NAME must match in order and number
// IDS_SYSTEM_DESCRIPTION through IDS_CUSTOM_DESCRIPTION.
//

#define IDS_SYSTEM_DEFAULT_DISPLAY_NAME         101
#define IDS_SECURITY_DEFAULT_DISPLAY_NAME       102
#define IDS_APPLICATION_DEFAULT_DISPLAY_NAME    103
#define IDS_CUSTOM_DEFAULT_DISPLAY_NAME         104

#define IDS_NAME_STR                            110
#define IDS_EXTENSION_NAME_STR                  111
#ifdef ELS_TASKPAD
#define IDS_VIEW_EXTENSION_STR                  112
#endif // ELS_TASKPAD

#define IDS_SYSTEM_DESCRIPTION                  120
#define IDS_SECURITY_DESCRIPTION                121
#define IDS_APPLICATION_DESCRIPTION             122
#define IDS_CUSTOM_DESCRIPTION                  123

#define IDS_ROOT_REMOTE_DISPLAY_NAME_FMT        124

#define IDS_FIRST_FOLDER_HDR                    130
#define IDS_FOLDER_HDR_NAME                     IDS_FIRST_FOLDER_HDR + 0
#define IDS_FOLDER_HDR_TYPE                     IDS_FIRST_FOLDER_HDR + 1
#define IDS_FOLDER_HDR_DESCRIPTION              IDS_FIRST_FOLDER_HDR + 2
#define IDS_FOLDER_HDR_SIZE                     IDS_FIRST_FOLDER_HDR + 3

#define IDS_FIRST_RECORD_HDR                    140
#define IDS_RECORD_HDR_TYPE                     IDS_FIRST_RECORD_HDR + 0
#define IDS_RECORD_HDR_DATE                     IDS_FIRST_RECORD_HDR + 1
#define IDS_RECORD_HDR_TIME                     IDS_FIRST_RECORD_HDR + 2
#define IDS_RECORD_HDR_SOURCE                   IDS_FIRST_RECORD_HDR + 3
#define IDS_RECORD_HDR_CATEGORY                 IDS_FIRST_RECORD_HDR + 4
#define IDS_RECORD_HDR_EVENT                    IDS_FIRST_RECORD_HDR + 5
#define IDS_RECORD_HDR_USER                     IDS_FIRST_RECORD_HDR + 6
#define IDS_RECORD_HDR_COMPUTER                 IDS_FIRST_RECORD_HDR + 7

#define IDS_USER_NA                             200
#define IDS_NONE                                201

//
// The following event log type string ids must be consecutive and remain in
// this order.
//

#define IDS_SUCCESS_TYPE                        202
#define IDS_FAILURE_TYPE                        203
#define IDS_INFORMATION_TYPE                    204
#define IDS_WARNING_TYPE                        205
#define IDS_ERROR_TYPE                          206
#define IDS_NO_TYPE                             207

//
// Other strings
//

#define IDS_LOG                                 215
#define IDS_FILTERED                            216
#define IDS_CMENU_CLEARLOG                      217
#define IDS_CMENU_SAVEAS                        219
#define IDS_CMENU_VIEW                          220
#define IDS_CMENU_VIEW_ALL                      221
#define IDS_CMENU_VIEW_FILTER                   222
#define IDS_CMENU_VIEW_NEWEST                   223
#define IDS_CMENU_VIEW_OLDEST                   224
#define IDS_SBAR_CLEARLOG                       225
#define IDS_SBAR_LOGOPEN                        226
#define IDS_SBAR_SAVEAS                         228
#define IDS_SBAR_VIEW                           229
#define IDS_SBAR_VIEW_ALL                       230
#define IDS_SBAR_VIEW_FILTER                    231
#define IDS_SBAR_VIEW_NEWEST                    232
#define IDS_SBAR_VIEW_OLDEST                    233
#define IDS_DESCR_NOTFOUND                      234
#define IDS_VIEWER                              235
#define IDS_WRAP_TO_START                       236
#define IDS_WRAP_TO_END                         237
#define IDS_FIRST_EVENT                         238
#define IDS_LAST_EVENT                          239
#define IDS_EVENTS_ON                           240
#define IDS_ALL                                 241
#define IDS_INVALID_FROM_TO                     242
#define IDS_FMT_SIZE                            243
#define IDS_CONFIRM_SETTING_RESET               244
#define IDS_MIN_SIZE_LIMIT_WARN                 245
#define IDS_MAX_SIZE_LIMIT_WARN                 246
#define IDS_SIZE_LIMIT_64K_WARN                 247
#define IDS_MIN_RETENTION_WARN                  248
#define IDS_MAX_RETENTION_WARN                  249
#define IDS_LOG_SIZE_REDUCED                    250
#define IDS_CANT_WRITE_SETTINGS                 251
#define IDS_CLEAR_CONFIRM                       252
#define IDS_SAVEAS                              253
#define IDS_SAVEFILTER                          254
#define IDS_CMENU_VIEW_FIND                     255
#define IDS_SBAR_VIEW_FIND                      256
#define IDS_CANTSAVE                            257
#define IDS_UNSPECIFIED_TYPE                    258
#define IDS_DISPLAYNAME_REMOTE_FMT              259
#define IDS_DISPLAYNAME_LOCAL_FMT               260
#define IDS_OPENFILTER                          261
#define IDS_DEFOPENEXT                          262
#define IDS_OPEN                                263
#define IDS_INVALID_TYPE                        264
#define IDS_NO_FILENAME                         265
#define IDS_INVALID_FILE                        266
#if (DBG == 1)
#define IDS_CMENU_DUMP                          267
#define IDS_SBAR_DUMP                           268
#endif // (DBG == 1)
#define IDS_NO_SERVERNAME                       269
#define IDS_CANTOPENLOG                         270
#define IDS_DISPLAYNAME_ARCHIVED_REMOTE_FMT     271
#define IDS_DISPLAYNAME_ARCHIVED_LOCAL_FMT      272
#define IDS_DISPLAYNAME_ARCHIVED_REMOTE_UNK_FMT 273
#define IDS_INVALID_EVENTID                     275
#define IDS_FIND_CAPTION_FMT                    278
#define IDS_REMOTE_FIND_CAPTION_FMT             279
#define IDS_SEARCH_FAIL_FORWARD                 280
#define IDS_SEARCH_FAIL_BACKWARD                281
#define IDS_ILLEGAL_REMOTE_BACKUP               282
#define IDS_COULD_NOT_OPEN                      283
#define IDS_DETAILS_CAPTION                     284
#define IDS_LOCAL_COMPUTER                      285
#define IDS_LOG_GENERIC_ERROR                   286
#define IDS_LOG_SYSMSG_ERROR                    287
#define IDS_DESCBAR_DISABLED                    288
#define IDS_DESCBAR_FILTERED                    289
#define IDS_DESCBAR_NORMAL                      290
#define IDS_EVENTLOG_FILE_CORRUPT               291
#if (DBG == 1)
#define IDS_CMENU_DUMP_RECLIST                  292
#define IDS_SBAR_DUMP_RECLIST                   293
#define IDS_CMENU_DUMP_LIGHTCACHE               294
#define IDS_SBAR_DUMP_LIGHTCACHE                295
#endif // (DBG == 1)
#define IDS_FALLBACK_DESCR_TERMINATOR           296
#define IDS_ROOT_LOCAL_DISPLAY_NAME             297
#define IDS_CANT_CONNECT                        298
#define IDS_UNKNOWN_ERROR_CODE                  299
#define IDS_HRESULT_SANS_MESSAGE                300
#define IDS_HELP_OVERVIEW_TOPIC                 301
#define IDS_SBAR_RETARGET                       302
#define IDS_CMENU_RETARGET                      303
#define IDS_CLEAR_FAILED                        304
#define IDS_SNAPIN_ABOUT_DESCRIPTION            305
#define IDS_SNAPIN_ABOUT_PROVIDER_NAME          306
#define IDI_SNAPIN                              308
#define IDS_SNAPIN_ABOUT_CLSID_FRIENDLY_NAME    311
#define IDS_TOOLBAR_CAPTION                     312
#define IDS_CLP_EVENT_TYPE                      313
#define IDS_CLP_EVENT_SOURCE                    314
#define IDS_CLP_EVENT_CATEGORY                  315
#define IDS_CLP_EVENT_ID                        316
#define IDS_CLP_DATE                            317
#define IDS_CLP_TIME                            318
#define IDS_CLP_USER                            319
#define IDS_CLP_COMPUTER                        320
#define IDS_CLP_DESCRIPTION                     321
#define IDS_CLP_DATA                            322
#define IDS_PREV_TOOLTIP                        323
#define IDS_NEXT_TOOLTIP                        324
#define IDS_COPY_TOOLTIP                        325
#define IDS_CMENU_OPEN                          326
#define IDS_SBAR_OPEN                           327
#define IDS_CMENU_COPY_VIEW                     328
#define IDS_SBAR_COPY_VIEW                      329
#define IDS_NEED_DISPLAY_NAME                   330
#define IDS_VN_FILEVERSIONKEY                   332
#define IDS_EVENT_ID                            333
#define IDS_FILE_VERSION                        334
#define IDS_PRODUCT_VERSION                     335
#define IDS_COMPANY_NAME                        336
#define IDS_PRODUCT_NAME                        337
#define IDS_LVCOLUMN_0                          338
#define IDS_LVCOLUMN_1                          339
#if (DBG == 1)
#define IDS_CMENU_DUMP_RECORD                   340
#define IDS_SBAR_DUMP_RECORD                    341
#endif // (DBG == 1)
#define IDS_EXTENSION                           342
#define IDS_PROP_OUTOFMEMORY                    343
#define IDS_KB_FORMAT                           344
#define IDS_MB_FORMAT                           345
#define IDS_GB_FORMAT                           346
#define IDS_REDIRECT_URL_MESSAGE                347
#define IDS_FILE_NAME                           348
#define IDS_DESCRIPTION_TEXT                    349
#define IDS_DATA                                350
#define IDS_NAME_OF_SECURITY_LOG                351

/////////////////////////////////////////////////////////////////////////////
//
// Bitmaps
//

#define IDB_16x16                               100
#define IDB_32x32                               101
#define IDB_SCOPE_16x16                         102
#define IDB_NEXT_BUTTON                         103
#define IDB_PREV_BUTTON                         104
#define IDB_COPY_BUTTON                         105
#define IDB_STATIC_FOLDER_CLOSED                309
#define IDB_STATIC_FOLDER_OPEN                  310

/////////////////////////////////////////////////////////////////////////////
//
// Icons
//

#define IDI_EVENT_VIEWER                        100
#define IDI_PREVIOUS                            101
#define IDI_NEXT                                102
#define IDI_COPY                                103
#define IDI_PREVIOUS_HC                         104
#define IDI_NEXT_HC                             105

/////////////////////////////////////////////////////////////////////////////
//
// Menu IDs
//

#define IDM_CASCADE_VIEW                        101
#define IDM_CLEARLOG                            102
#define IDM_SAVEAS                              103
#define IDM_VIEW_ALL                            104
#define IDM_VIEW_FILTER                         105
#define IDM_VIEW_NEWEST                         106
#define IDM_VIEW_OLDEST                         107
#define IDM_VIEW_FIND                           108
#if (DBG == 1)
#define IDM_DUMP_LOGINFO                        109
#define IDM_DUMP_COMPONENTDATA                  111
#define IDM_DUMP_RECLIST                        112
#define IDM_DUMP                                113
#define IDM_DUMP_LIGHTCACHE                     114
#define IDM_DUMP_RECORD                         115
#endif // (DBG == 1)
#define IDM_RETARGET                            117
#define IDM_OPEN                                118
#define IDM_COPY_VIEW                           119


/////////////////////////////////////////////////////////////////////////////
//
// Help IDs
//

#define Hdetail_prev_pb                         1000
#define Hdetail_next_pb                         1001
#define Hdetail_noprops_lbl                     1002
#define Hdetail_date_lbl                        1003
#define Hdetail_date_txt                        1004
#define Hdetail_time_lbl                        1005
#define Hdetail_time_txt                        1006
#define Hdetail_user_lbl                        1007
#define Hdetail_user_edit                       1008
#define Hdetail_computer_lbl                    1009
#define Hdetail_computer_edit                   1010
#define Hdetail_event_id_lbl                    1011
#define Hdetail_event_id_txt                    1012
#define Hdetail_source_lbl                      1013
#define Hdetail_source_txt                      1014
#define Hdetail_type_lbl                        1015
#define Hdetail_type_txt                        1016
#define Hdetail_category_lbl                    1017
#define Hdetail_category_txt                    1018
#define Hdetail_description_lbl                 1019
#define Hdetail_description_edit                1020
#define Hdetail_data_lbl                        1021
#define Hdetail_data_edit                       1022
#define Hdetail_byte_rb                         1023
#define Hdetail_word_rb                         1024
#define Hfilter_from_lbl                        1025
#define Hfilter_from_combo                      1026
#define Hfilter_from_date_dp                    1027
#define Hfilter_from_time_dp                    1028
#define Hfilter_to_lbl                          1029
#define Hfilter_to_combo                        1030
#define Hfilter_to_date_dp                      1031
#define Hfilter_to_time_dp                      1032
#define Hfilter_types_grp                       1033
#define Hfilter_information_ckbox               1034
#define Hfilter_warning_ckbox                   1035
#define Hfilter_error_ckbox                     1036
#define Hfilter_success_ckbox                   1037
#define Hfilter_failure_ckbox                   1038
#define Hfilter_source_lbl                      1039
#define Hfilter_source_combo                    1040
#define Hfilter_category_lbl                    1041
#define Hfilter_category_combo                  1042
#define Hfilter_user_lbl                        1043
#define Hfilter_user_edit                       1044
#define Hfilter_computer_lbl                    1045
#define Hfilter_computer_edit                   1046
#define Hfilter_eventid_lbl                     1047
#define Hfilter_eventid_edit                    1048
#define Hfilter_clear_pb                        1049
#define Hfilter_view_lbl                        1050
#define Hgeneral_accessed_lbl                   1051
#define Hgeneral_accessed_txt                   1052
#define Hgeneral_clear_pb                       1053
#define Hgeneral_created_lbl                    1054
#define Hgeneral_created_txt                    1055
#define Hgeneral_days_lbl                       1056
#define Hgeneral_displayname_edit               1057
#define Hgeneral_displayname_lbl                1058
#define Hgeneral_kilobytes_lbl                  1059
#define Hgeneral_logname_edit                   1060
#define Hgeneral_logname_lbl                    1061
#define Hgeneral_lowspeed_chk                   1062
#define Hgeneral_asneeded_rb                    1063
#define Hgeneral_olderthan_rb                   1064
#define Hgeneral_manual_rb                      1065
#define Hgeneral_maxsize_edit                   1066
#define Hgeneral_maxsize_lbl                    1067
#define Hgeneral_maxsize_spin                   1068
#define Hgeneral_modified_lbl                   1069
#define Hgeneral_modified_txt                   1070
#define Hgeneral_olderthan_edit                 1071
#define Hgeneral_olderthan_spin                 1072
#define Hgeneral_size_lbl                       1073
#define Hgeneral_size_txt                       1074
#define Hgeneral_wrapping_grp                   1075
#define Hgeneral_default_pb                     1076
#define Hgeneral_sep                            1077
#define Hopen_display_name_edit                 1082
#define Hopen_type_combo                        1087
#define Hfind_information_ckbox                 1089
#define Hfind_warning_ckbox                     1090
#define Hfind_error_ckbox                       1091
#define Hfind_success_ckbox                     1092
#define Hfind_failure_ckbox                     1093
#define Hfind_source_combo                      1094
#define Hfind_category_combo                    1095
#define Hfind_eventid_edit                      1096
#define Hfind_computer_edit                     1097
#define Hfind_user_edit                         1098
#define Hfind_type_grp                          1099
#define Hfind_source_lbl                        1100
#define Hfind_category_lbl                      1101
#define Hfind_eventid_lbl                       1102
#define Hfind_computer_lbl                      1103
#define Hfind_user_lbl                          1104
#define Hfind_description_lbl                   1105
#define Hfind_description_edit                  1106
#define Hfind_direction_grp                     1107
#define Hfind_up_rb                             1108
#define Hfind_down_rb                           1109
#define Hfind_next_pb                           1110
#define Hfind_clear_pb                          1111
#define HCHOOSER_STATIC                         1112
#define HCHOOSER_GROUP_TARGET_MACHINE           1113
#define HCHOOSER_RADIO_LOCAL_MACHINE            1114
#define HCHOOSER_RADIO_SPECIFIC_MACHINE         1115
#define HCHOOSER_EDIT_MACHINE_NAME              1116
#define HCHOOSER_BUTTON_BROWSE_MACHINENAMES     1117
#define HCHOOSER_CHECK_OVERRIDE_MACHINE_NAME    1118
#define Hfind_close_pb                          1119
#define Hdetail_copy_pb                         1120



/////////////////////////////////////////////////////////////////////////////
//
// Dialog IDs
//

#define IDD_DETAILS                             100

#define FIRST_DETAILS_PROP_CTRL                 110
#define detail_date_lbl                         (FIRST_DETAILS_PROP_CTRL + 0)
#define detail_date_txt                         (FIRST_DETAILS_PROP_CTRL + 1)
#define detail_time_lbl                         (FIRST_DETAILS_PROP_CTRL + 2)
#define detail_time_txt                         (FIRST_DETAILS_PROP_CTRL + 3)
#define detail_user_lbl                         (FIRST_DETAILS_PROP_CTRL + 4)
#define detail_user_txt                        (FIRST_DETAILS_PROP_CTRL + 5)
#define detail_computer_lbl                     (FIRST_DETAILS_PROP_CTRL + 6)
#define detail_computer_txt                    (FIRST_DETAILS_PROP_CTRL + 7)
#define detail_event_id_lbl                     (FIRST_DETAILS_PROP_CTRL + 8)
#define detail_event_id_txt                     (FIRST_DETAILS_PROP_CTRL + 9)
#define detail_source_lbl                       (FIRST_DETAILS_PROP_CTRL + 10)
#define detail_source_txt                       (FIRST_DETAILS_PROP_CTRL + 11)
#define detail_type_lbl                         (FIRST_DETAILS_PROP_CTRL + 12)
#define detail_type_txt                         (FIRST_DETAILS_PROP_CTRL + 13)
#define detail_category_lbl                     (FIRST_DETAILS_PROP_CTRL + 14)
#define detail_category_txt                     (FIRST_DETAILS_PROP_CTRL + 15)
#define detail_description_lbl                  (FIRST_DETAILS_PROP_CTRL + 16)
#define detail_description_edit                 (FIRST_DETAILS_PROP_CTRL + 17)
#define detail_data_lbl                         (FIRST_DETAILS_PROP_CTRL + 18)
#define detail_data_edit                        (FIRST_DETAILS_PROP_CTRL + 19)
#define detail_byte_rb                          (FIRST_DETAILS_PROP_CTRL + 20)
#define detail_word_rb                          (FIRST_DETAILS_PROP_CTRL + 21)
#define detail_toolbar                          (FIRST_DETAILS_PROP_CTRL + 22)
#define LAST_DETAILS_PROP_CTRL                  detail_toolbar

#define detail_prev_pb                          IDS_PREV_TOOLTIP
#define detail_next_pb                          IDS_NEXT_TOOLTIP
#define detail_copy_pb                          IDS_COPY_TOOLTIP
#define detail_noprops_lbl                      (detail_copy_pb + 1)


#define IDD_FILTER                              102

#define filter_from_lbl                         110
#define filter_from_combo                       111
#define filter_from_date_dp                     112
#define filter_from_time_dp                     113
#define filter_to_lbl                           114
#define filter_to_combo                         115
#define filter_to_date_dp                       116
#define filter_to_time_dp                       117
#define filter_types_grp                        118
#define filter_information_ckbox                119
#define filter_warning_ckbox                    120
#define filter_error_ckbox                      121
#define filter_success_ckbox                    122
#define filter_failure_ckbox                    123
#define filter_source_lbl                       124
#define filter_source_combo                     125
#define filter_category_lbl                     126
#define filter_category_combo                   127
#define filter_user_lbl                         128
#define filter_user_edit                        129
#define filter_computer_lbl                     130
#define filter_computer_edit                    131
#define filter_eventid_lbl                      132
#define filter_eventid_edit                     133
#define filter_clear_pb                         134
#define filter_view_lbl                         135


#define IDD_GENERAL                             103


#define general_accessed_lbl                    110
#define general_accessed_txt                    111
#define general_clear_pb                        112
#define general_created_lbl                     113
#define general_created_txt                     114
#define general_days_lbl                        115
#define general_displayname_edit                116
#define general_displayname_lbl                 117
#define general_kilobytes_lbl                   118
#define general_logname_edit                    119
#define general_logname_lbl                     120
#define general_lowspeed_chk                    121
#define general_asneeded_rb                     122
#define general_olderthan_rb                    123
#define general_manual_rb                       124
#define general_maxsize_edit                    125
#define general_maxsize_lbl                     126
#define general_maxsize_spin                    127
#define general_modified_lbl                    128
#define general_modified_txt                    129
#define general_olderthan_edit                  130
#define general_olderthan_spin                  131
#define general_size_lbl                        132
#define general_size_txt                        133
#define general_wrapping_grp                    134
#define general_default_pb                      135
#define general_sep                             136
#define general_logsize_txt                     137


#include "chooserd.h"

#define IDD_FIND                                106

#define find_information_ckbox                  filter_information_ckbox
#define find_warning_ckbox                      filter_warning_ckbox
#define find_error_ckbox                        filter_error_ckbox
#define find_success_ckbox                      filter_success_ckbox
#define find_failure_ckbox                      filter_failure_ckbox
#define find_source_combo                       filter_source_combo
#define find_category_combo                     filter_category_combo
#define find_eventid_edit                       filter_eventid_edit
#define find_computer_edit                      filter_computer_edit
#define find_user_edit                          filter_user_edit
#define find_type_grp                           200
#define find_source_lbl                         201
#define find_category_lbl                       202
#define find_eventid_lbl                        203
#define find_computer_lbl                       204
#define find_user_lbl                           205
#define find_description_lbl                    206
#define find_description_edit                   207
#define find_direction_grp                      208
#define find_up_rb                              209
#define find_down_rb                            210
#define find_next_pb                            211
#define find_clear_pb                           212



#define IDD_OPEN                                107

#define open_type_combo                         101
#define open_display_name_edit                  102
#define open_type_txt                           103
#define open_display_name_txt                   104


#define IDD_CONFIRMURL                          108

#define urlconfirm_dontask_ckbox                101
#define urlconfirm_data_lv                      102

#endif // __ELSRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\ffbase.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       ffbase.cxx
//
//  Contents:   Implmentation of base class for the find and filter classes
//
//  Classes:    CFindFilterBase
//
//  History:    3-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------


#include "headers.hxx"
#pragma hdrstop


DEBUG_DECLARE_INSTANCE_COUNTER(CFindFilterBase)


//+--------------------------------------------------------------------------
//
//  Member:     CFindFilterBase::CFindFilterBase
//
//  Synopsis:   ctor
//
//  History:    3-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CFindFilterBase::CFindFilterBase()
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CFindFilterBase);
    //
    // WARNING: if any pointer values are added to this class, they
    // must be initialized here, and deleted & set to null in _Reset.
    //

    _Reset();
}



//+--------------------------------------------------------------------------
//
//  Member:     CFindFilterBase::~CFindFilterBase
//
//  Synopsis:   dtor
//
//  History:    3-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CFindFilterBase::~CFindFilterBase()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CFindFilterBase);

    _Reset();
}




//+--------------------------------------------------------------------------
//
//  Member:     CFindFilterBase::_Reset
//
//  Synopsis:   Reinitialize
//
//  History:    3-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CFindFilterBase::_Reset()
{
    _ulType            = ALL_LOG_TYPE_BITS;
    _ulEventID         = 0;
    _usCategory        = 0;
    _fEventIDSpecified = FALSE;
    _wszSource[0]      = L'\0';
    _wszUser[0]        = L'\0';
    _wszUserLC[0]      = L'\0';
    _wszComputer[0]    = L'\0';
}




//+--------------------------------------------------------------------------
//
//  Member:     CFindFilterBase::Passes
//
//  Synopsis:   Return TRUE if [pelr] meets the restrictions specified in
//              this object.
//
//  Arguments:  [pResultRecs] - positioned at record to check
//
//  Returns:    TRUE or FALSE
//
//  History:    3-26-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CFindFilterBase::Passes(
    CFFProvider *pFFP)
{
    if (TypeSpecified())
    {
        // EricB 9/25/01 470346 Treat EVENTLOG_SUCCESS the same as
        // EVENTLOG_INFORMATION_TYPE.
        if (!(EVENTLOG_SUCCESS == pFFP->GetEventType() &&
              EVENTLOG_INFORMATION_TYPE & _ulType))
        {
            if (!(pFFP->GetEventType() & _ulType))
            {
                return FALSE;
            }
        }
    }

    if (CategorySpecified())
    {
        if (pFFP->GetEventCategory() != _usCategory)
        {
            return FALSE;
        }
    }

    if (EventIDSpecified())
    {
        if (LOWORD(pFFP->GetEventID()) != _ulEventID)
        {
            return FALSE;
        }
    }

    if (SourceSpecified())
    {
        if (lstrcmpi(pFFP->GetSourceStr(), _wszSource))
        {
            return FALSE;
        }
    }

    //
    // Computer name comparison is not case sensitive, but does look for
    // the entire string.
    //

    if (ComputerSpecified())
    {
        if (lstrcmpi(pFFP->GetComputerStr(), _wszComputer))
        {
            return FALSE;
        }
    }

    //
    // The user string comparison is not only case insensitive but also a
    // substring match.
    //

    if (UserSpecified())
    {
        WCHAR wszUser[CCH_USER_MAX];

        pFFP->GetUserStr(wszUser, ARRAYLEN(wszUser), TRUE);

        CharLowerBuff(wszUser, lstrlen(wszUser));

        if (!wcsstr(wszUser, _wszUserLC))
        {
            return FALSE;
        }
    }
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFindFilterBase::SetComputer
//
//  Synopsis:   Store the computer name, less lead and trail spaces.
//
//  Arguments:  [pwszComputer] - computer name
//
//  History:    3-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CFindFilterBase::SetComputer(
    LPCWSTR pwszComputer)
{
    if (pwszComputer && *pwszComputer)
    {
        CopyStrippingLeadTrailSpace(_wszComputer,
                                    pwszComputer,
                                    ARRAYLEN(_wszComputer));
    }
    else
    {
        _wszComputer[0] = L'\0';
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CFindFilterBase::SetEventID
//
//  Synopsis:   Store a flag indicating whether to filter on event id, and
//              if so, the event id value to look for.
//
//  Arguments:  [fEventIDSpecified] - whether or not to use event id for
//                                      find/filter.
//              [ulEventID]         - event id value (0 is valid)
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CFindFilterBase::SetEventID(
    BOOL fEventIDSpecified,
    ULONG ulEventID)
{
    _fEventIDSpecified = fEventIDSpecified;

    if (_fEventIDSpecified)
    {
        _ulEventID = ulEventID;
    }
    else
    {
        _ulEventID = 0;
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CFindFilterBase::SetSource
//
//  Synopsis:   Set or clear filtering by source.
//
//  Arguments:  [pwszSource] - source name to filter by, or NULL for none
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CFindFilterBase::SetSource(
    LPCWSTR pwszSource)
{
    if (pwszSource)
    {
        lstrcpyn(_wszSource, pwszSource, ARRAYLEN(_wszSource));
    }
    else
    {
        _wszSource[0] = L'\0';
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CFindFilterBase::SetUser
//
//  Synopsis:   Set or clear filtering by user name.
//
//  Arguments:  [pwszUser] - user name to filter by, or NULL for none
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CFindFilterBase::SetUser(
    LPCWSTR pwszUser)
{
    if (pwszUser && *pwszUser)
    {
        CopyStrippingLeadTrailSpace(_wszUser,
                                    pwszUser,
                                    ARRAYLEN(_wszUser));
    }
    else
    {
        _wszUser[0] = L'\0';
    }
    lstrcpy(_wszUserLC, _wszUser);
    CharLowerBuff(_wszUserLC, lstrlen(_wszUserLC));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\eventurl.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999 - 1999.
//
//  File:       eventurl.cxx
//
//  Contents:   Helper classes for invoking URLs from the event details
//              property sheet.
//
//  Classes:    CEventUrl
//              CConfirmUrlDlg
//
//  History:    6-03-1999   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

const WCHAR c_wzFileVersion[] = L"FileVersion";

BOOL
_DetermineSubBlockPrefix(
    PWSTR wzSubBlockPrefix,
    ULONG cchSubBlockPrefix,
    PVOID pbData);

HRESULT
EscapeUrlComponent(
    wstring *pwstr);

void
EscapeByteBuffer(
    const BYTE *pBufferToEncode,
    const DWORD ccbBytesInBuffer,
    wstring *pwstr,
    const DWORD cchMaxLength);

void
TruncateEscapedUTF8String(
    wstring *pwstr,
    const DWORD cchMaxLength);

void UrlEscape( /*[out]*/ wstring& strAppendTo    ,
                /*[in]*/  LPCWSTR  szToEscape     ,
                /*[in]*/  bool     fAsQueryString = FALSE );


#define ADD_VER_STR(ParamName, Value)                           \
        if ((Value).length())                                   \
        {                                                       \
            if (fAddedVerStr)                                   \
            {                                                   \
                strHTTPQuery += L"&";                           \
            }                                                   \
            strHTTPQuery += ParamName L"=" + Value;             \
            fAddedVerStr = TRUE;                                \
        }




//+--------------------------------------------------------------------------
//
//  Member:     CEventUrl::CEventUrl
//
//  Synopsis:   ctor
//
//  History:    6-03-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CEventUrl::CEventUrl(
        PCWSTR               pwzUrl,
        IResultPrshtActions *prpa,
        const wstring       &strMessageFile):
            _strUrl(pwzUrl),
            _strMessageFile(strMessageFile),
            _fAddedParameters(FALSE),
            _fIsMSRedirProg(FALSE)
{
    TRACE_CONSTRUCTOR(CEventUrl);

    WCHAR           wszBuf[1024];
    EVENTLOGRECORD *pelr = NULL;
    BOOL            fEventStringsValid = FALSE;
    BOOL            fVersionStringsValid = FALSE;
    BOOL            fOk = FALSE;
    PBYTE           pbData = NULL;

    do
    {
        //
        // Get a copy of the event record.  If that fails, the url will
        // remain unmodified.
        //

        if (!prpa)
        {
            Dbg(DEB_ERROR, "IResultPrshtActions NULL\n");
            break;
        }

        prpa->GetCurSelRecCopy((ULONG_PTR) &pelr);

        if (!pelr)
        {
            Dbg(DEB_ERROR, "can't get event record copy\n");
            break;
        }

        //
        // Init members which take their values directly from the event
        // record.
        //

        _strSource = (LPCWSTR) (&pelr->DataOffset + 1);
        _strEscapedSource = _strSource;
        EscapeUrlComponent(&_strEscapedSource);

        GetEventIDStr((USHORT) pelr->EventID, wszBuf, ARRAYLEN(wszBuf));
        _strEventID = wszBuf;
        _strEscapedEventID = _strEventID;
        EscapeUrlComponent(&_strEscapedEventID);

        CLogInfo *pliSelected = NULL;
        prpa->GetCurSelLogInfo((ULONG_PTR) &pliSelected);
        //
        // JonN 9/05/01 464348 (see 437696)
        // Assertion Failed when computer retargeted and click on
        // Event Properties->Description->links
        //
        // It is possible that ELS has been retargeted since this details
        // page was created.  We simply skip the category in this case.
        //
        wszBuf[0] = L'\0';
        if (pliSelected
#ifdef DEBUG
            && pliSelected->IsValid()
#endif
           )
        {
            GetCategoryStr(pliSelected,
                           pelr,
                           wszBuf,
                           ARRAYLEN(wszBuf));
        }
        _strCategory = wszBuf;
        _strEscapedCategory = _strCategory;
        EscapeUrlComponent(&_strEscapedCategory);

        GetCategoryIDStr(pelr,
                         wszBuf,
                         ARRAYLEN(wszBuf));
        _strCategoryID = wszBuf;
        _strEscapedCategoryID = _strCategoryID;
        EscapeUrlComponent(&_strEscapedCategoryID);

//      GetUserStr(pelr,
//                 wszBuf,
//                 ARRAYLEN(wszBuf),
//                 TRUE);
//      _strUser = wszBuf;
//      _strEscapedUser = _strUser;
//      EscapeUrlComponent(&_strEscapedUser);

//      _strComputer = GetComputerStr(pelr);
//      _strEscapedComputer = _strComputer;
//      EscapeUrlComponent(&_strEscapedComputer);

        _strType = GetTypeStr(GetEventType(pelr));
        _strEscapedType = _strType;
        EscapeUrlComponent(&_strEscapedType);

        GetTypeIDStr(pelr,
                     wszBuf,
                     ARRAYLEN(wszBuf));
        _strTypeID = wszBuf;
        _strEscapedTypeID = _strTypeID;
        EscapeUrlComponent(&_strEscapedTypeID);

        GetDateStr(pelr->TimeGenerated,
                   wszBuf,
                   ARRAYLEN(wszBuf));
        _strDate = wszBuf;
        _strEscapedDate = _strDate;
        EscapeUrlComponent(&_strEscapedDate);

        GetTimeStr(pelr->TimeGenerated,
                   wszBuf,
                   ARRAYLEN(wszBuf));
        _strTime = wszBuf;
        _strEscapedTime = _strTime;
        EscapeUrlComponent(&_strEscapedTime);

        _strDateAndTime = _ultow(pelr->TimeGenerated, wszBuf, 10);
        _strEscapedDateAndTime = _strDateAndTime;
        EscapeUrlComponent(&_strEscapedDateAndTime);

        TIME_ZONE_INFORMATION tzi;
        DWORD dwRet;
        LONG iBias;

        dwRet = GetTimeZoneInformation(&tzi);

        if (dwRet == TIME_ZONE_ID_STANDARD)
            iBias = tzi.Bias + tzi.StandardBias;
        else if (dwRet == TIME_ZONE_ID_DAYLIGHT)
            iBias = tzi.Bias + tzi.DaylightBias;
        else
            iBias = 0;

        _strTimeZoneBias = _itow(iBias, wszBuf, 10);
        _strEscapedTimeZoneBias = _strTimeZoneBias;
        EscapeUrlComponent(&_strEscapedTimeZoneBias);

//      DWORD dwNumInsStrs = 0;
//      WCHAR *pwszInsStr = NULL;
//      wstring strInsStr;
//      wstring strEscapedInsStr;
//      DWORD dwTotalLength = 0;
//
//      for (int iIndex = 0; iIndex < pelr->NumStrings; iIndex++)
//      {
//          if (iIndex == 0)
//              pwszInsStr = GetFirstInsertString(pelr);
//          else
//              pwszInsStr = pwszInsStr + wcslen(pwszInsStr) + 1;
//
//          strInsStr = pwszInsStr;
//          strEscapedInsStr = pwszInsStr;
//          EscapeUrlComponent(&strEscapedInsStr);
//          TruncateEscapedUTF8String(&strEscapedInsStr, (1024 - dwTotalLength > 256) ? 256 : (1024 - dwTotalLength));
//
//          if (strEscapedInsStr.length() <= 0 && strInsStr.length() > 0)
//              break;
//
//          _arrInsStrings.insert(_arrInsStrings.end(), strInsStr);
//          _arrEscapedInsStrings.insert(_arrEscapedInsStrings.end(), strEscapedInsStr);
//
//          dwTotalLength += strEscapedInsStr.length();
//          dwNumInsStrs++;
//      }
//
//      _strNumInsStrs = _ultow(dwNumInsStrs, wszBuf, 10);
//      _strEscapedNumInsStrs = _strNumInsStrs;
//      EscapeUrlComponent(&_strEscapedNumInsStrs);

//      if (pelr->DataLength > 0)
//      {
//          WCHAR *pwszBuf = (WCHAR *) HeapAlloc(GetProcessHeap(), 0, pelr->DataLength * 3 * sizeof(WCHAR));
//
//          if (pwszBuf != NULL)
//          {
//              BYTE *pData = ((BYTE *) pelr) + pelr->DataOffset;
//
//              for (DWORD dwIndex = 0; dwIndex < pelr->DataLength; dwIndex++)
//              {
//                  pwszBuf[dwIndex * 3]     = (pData[dwIndex] >> 4) + ((pData[dwIndex] >> 4) <= 9 ? L'0' : (L'a' - 10));
//                  pwszBuf[dwIndex * 3 + 1] = (pData[dwIndex] & 0X0F) + ((pData[dwIndex] & 0X0F) <= 9 ? L'0' : (L'a' - 10));
//                  pwszBuf[dwIndex * 3 + 2] = L' ';
//              }
//
//              pwszBuf[pelr->DataLength * 3 - 1] = 0;
//
//              _strData = pwszBuf;
//              HeapFree(GetProcessHeap(), 0, pwszBuf);
//
//              EscapeByteBuffer(pData, pelr->DataLength, &_strEscapedData, 256);
//          }
//      }

        if (_strEscapedSource.length() &&
            _strEscapedEventID.length() &&
            _strEscapedCategory.length() &&
            _strEscapedCategoryID.length() &&
            _strEscapedType.length() &&
            _strEscapedTypeID.length())
//          _strEscapedNumInsStrs.length())
        {
            fEventStringsValid = TRUE;
        }

        //
        // Init members which take their value from the module used to
        // get the description string
        //

        if (_strMessageFile.empty())
        {
            Dbg(DEB_TRACE, "no message file\n");
            break;
        }

        WCHAR *pwszFileName = wcsrchr(_strMessageFile.c_str(), L'\\');

        if (pwszFileName == NULL)
            _strFileName = _strMessageFile;
        else
            _strFileName = pwszFileName + 1;

        _strEscapedFileName = _strFileName;
        EscapeUrlComponent(&_strEscapedFileName);

        ULONG ulDummyVar;
        ULONG cbSize = GetFileVersionInfoSize((PWSTR)_strMessageFile.c_str(),
                                              &ulDummyVar);

        if (!cbSize)
        {
            Dbg(DEB_TRACE, "no version info (%u)\n", GetLastError());
            break;
        }

        pbData = new BYTE[cbSize];

        if (!pbData)
        {
            DBG_OUT_HRESULT(E_OUTOFMEMORY);
            break;
        }

        fOk = GetFileVersionInfo((PWSTR)_strMessageFile.c_str(),
                                      ulDummyVar,
                                      cbSize,
                                      pbData);

        if (!fOk)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        PVOID pvValue = NULL;
        UINT cchValue = 0;

        //
        // Get the fixed version info for file and product.  This is locale
        // independent.
        //

        fOk = VerQueryValue(pbData, L"\\", &pvValue, &cchValue);

        if (!fOk || !cchValue)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        VS_FIXEDFILEINFO *pffi = (VS_FIXEDFILEINFO *)pvValue;

        wnsprintf(wszBuf,
                  ARRAYLEN(wszBuf),
                  TEXT("%u.%u.%u.%u"),
                  HIWORD(pffi->dwFileVersionMS),
                  LOWORD(pffi->dwFileVersionMS),
                  HIWORD(pffi->dwFileVersionLS),
                  LOWORD(pffi->dwFileVersionLS));

        _strFileVersion = wszBuf;
        _strEscapedFileVersion = _strFileVersion;
        Dbg(DEB_TRACE, "file version %ws\n", wszBuf);
        EscapeUrlComponent(&_strEscapedFileVersion);

        wnsprintf(wszBuf,
                  ARRAYLEN(wszBuf),
                  TEXT("%u.%u.%u.%u"),
                  HIWORD(pffi->dwProductVersionMS),
                  LOWORD(pffi->dwProductVersionMS),
                  HIWORD(pffi->dwProductVersionLS),
                  LOWORD(pffi->dwProductVersionLS));

        _strProductVersion = wszBuf;
        _strEscapedProductVersion = _strProductVersion;
        Dbg(DEB_TRACE, "product version %ws\n", wszBuf);
        EscapeUrlComponent(&_strEscapedProductVersion);

        //
        // Now get company and product name.  These are localized.
        //

        WCHAR wzSubBlockPrefix[MAX_PATH];

        fOk = _DetermineSubBlockPrefix(wzSubBlockPrefix,
                                       ARRAYLEN(wzSubBlockPrefix),
                                       pbData);

        if (!fOk)
        {
            break;
        }

        wstring strSubBlock(wzSubBlockPrefix);

        strSubBlock += L"CompanyName"; // block names not localized

        fOk = VerQueryValue(pbData,
                            (PWSTR) strSubBlock.c_str(),
                            &pvValue,
                            &cchValue);

        if (fOk && cchValue)
        {
            _strCompanyName = (PWSTR)pvValue;
            _strEscapedCompanyName = _strCompanyName;
            EscapeUrlComponent(&_strEscapedCompanyName);
        }

        strSubBlock = wzSubBlockPrefix;
        strSubBlock += L"ProductName"; // block names not localized

        fOk = VerQueryValue(pbData,
                            (PWSTR)strSubBlock.c_str(),
                            &pvValue,
                            &cchValue);

        if (fOk && cchValue)
        {
            _strProductName = (PWSTR)pvValue;
            _strEscapedProductName = _strProductName;
            EscapeUrlComponent(&_strEscapedProductName);
        }

        if (_strEscapedFileVersion.length()
            || _strEscapedProductVersion.length()
            || _strEscapedCompanyName.length()
            || _strEscapedProductName.length())
        {
            fVersionStringsValid = TRUE;
        }
    } while (0);

    delete [] pbData;

    //
    // Build the HTTP query string and append it to the URL.
    //

    wstring strHTTPQuery;

    if (fEventStringsValid)
    {
        //
        // Build up a parameter string to paste to the URL.
        //

        strHTTPQuery += L"?EvtSrc=" + _strEscapedSource;
        strHTTPQuery += L"&EvtCat=" + _strEscapedCategory;
        strHTTPQuery += L"&EvtID=" + _strEscapedEventID;
        strHTTPQuery += L"&EvtCatID=" + _strEscapedCategoryID;
//      strHTTPQuery += L"&EvtUser=" + _strEscapedUser;
//      strHTTPQuery += L"&EvtComp=" + _strEscapedComputer;
        strHTTPQuery += L"&EvtType=" + _strEscapedType;
        strHTTPQuery += L"&EvtTypeID=" + _strEscapedTypeID;
//      strHTTPQuery += L"&EvtInsStrs=" + _strEscapedNumInsStrs;
        strHTTPQuery += L"&EvtRptTime=" + _strEscapedDateAndTime;
        strHTTPQuery += L"&EvtTZBias=" + _strEscapedTimeZoneBias;

//      for (DWORD dwIndex = 0; dwIndex < _arrEscapedInsStrings.size(); dwIndex++)
//      {
//          strHTTPQuery += L"&EvtInsStr";
//          strHTTPQuery += _itow(dwIndex + 1, wszBuf, 10);
//          strHTTPQuery += L"=" + _arrEscapedInsStrings[dwIndex];
//      }

//      strHTTPQuery += L"&EvtData=" + _strEscapedData;
    }

    if (fVersionStringsValid)
    {
        if (!fEventStringsValid)
        {
            strHTTPQuery += L"?";
        }

        BOOL fAddedVerStr = fEventStringsValid;

        ADD_VER_STR(L"CoName",   _strEscapedCompanyName);
        ADD_VER_STR(L"ProdName", _strEscapedProductName);
        ADD_VER_STR(L"ProdVer",  _strEscapedProductVersion);
        ADD_VER_STR(L"FileName", _strEscapedFileName);
        ADD_VER_STR(L"FileVer",  _strEscapedFileVersion);
    }

    _strUrl += strHTTPQuery;

    //
    // If necessary, format the command line for the Microsoft redirection
    // program.
    //

    if ((g_wszRedirectionProgram[0] != 0) && (g_wszRedirectionCmdLineParams[0] != 0))
    {
        wstring strUrlEscaped;
        UrlEscape(strUrlEscaped, _strUrl.c_str(), TRUE);

        WCHAR *pwszCmdLine;

        pwszCmdLine = (WCHAR *) HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR) * 4096);
        if (pwszCmdLine != NULL)
        {
            if (_snwprintf(pwszCmdLine,
                           4096,
                           g_wszRedirectionCmdLineParams,
                           strUrlEscaped.c_str())
                      > 0)
                
            {
                _fIsMSRedirProg = TRUE;
                _strMSRedirProgCmdLine = pwszCmdLine;
            }
            HeapFree(GetProcessHeap(), 0, pwszCmdLine);
        }
    }

    _fAddedParameters = fEventStringsValid || fVersionStringsValid;
    Dbg(DEB_TRACE, "Escaped URL:\n%ws\n", _strUrl.c_str());
}



//+--------------------------------------------------------------------------
//
//  Function:   UrlEscape
//
//  Synopsis:   Add escaping to the URL passed to HelpCenter as topic=<URL>.
//
//  Arguments:  [strAppendTo]      - escaped URL
//              [szToEscape]       - input URL
//              [fAsQueryString]   - special handler for '+'
//
//  History:    5-05-2004   jonn       381390 Adapted from admin\pchealth\
//                                     core\MPC_Common\HtmlUtil.cpp
//
//---------------------------------------------------------------------------
void UrlEscape( /*[out]*/ wstring& strAppendTo    ,
                /*[in]*/  LPCWSTR  szToEscape     ,
                /*[in]*/  bool     fAsQueryString )
{
    // This is a bit field for the hex values: 00-29, 2C, 3A-3F, 5B-5E, 60, 7B-FF
    // These are the values escape encodes using the default mask (or mask >= 4)
    static const BYTE s_grfbitEscape[] =
    {
        0xFF, 0xFF, // 00 - 0F
        0xFF, 0xFF, // 10 - 1F
        0xFF, 0x13, // 20 - 2F
        0x00, 0xFC, // 30 - 3F
        0x00, 0x00, // 40 - 4F
        0x00, 0x78, // 50 - 5F
        0x01, 0x00, // 60 - 6F
        0x00, 0xF8, // 70 - 7F
        0xFF, 0xFF, // 80 - 8F
        0xFF, 0xFF, // 90 - 9F
        0xFF, 0xFF, // A0 - AF
        0xFF, 0xFF, // B0 - BF
        0xFF, 0xFF, // C0 - CF
        0xFF, 0xFF, // D0 - DF
        0xFF, 0xFF, // E0 - EF
        0xFF, 0xFF, // F0 - FF
    };
    static const WCHAR s_rgchHex[] = L"0123456789ABCDEF";

    ////////////////////

    if(szToEscape)
    {
        WCHAR ch;

        while(L'\0' != (ch = *szToEscape++))
        {
            if(fAsQueryString && ch == ' ')
            {
                strAppendTo += '+';
            }
            else if(0 != (ch & 0xFF00))
            {
                strAppendTo += L"%u";
                strAppendTo += s_rgchHex[(ch >> 12) & 0x0F];
                strAppendTo += s_rgchHex[(ch >>  8) & 0x0F];
                strAppendTo += s_rgchHex[(ch >>  4) & 0x0F];
                strAppendTo += s_rgchHex[ ch        & 0x0F];
            }
            else if((s_grfbitEscape[ch >> 3] & (1 << (ch & 7))) || (fAsQueryString && ch == '+'))
            {
                strAppendTo += L"%";
                strAppendTo += s_rgchHex[(ch >>  4) & 0x0F];
                strAppendTo += s_rgchHex[ ch        & 0x0F];
            }
            else
            {
                strAppendTo += ch;
            }
        }
    }
} // UrlEscape



//+--------------------------------------------------------------------------
//
//  Function:   _GetVersionValue
//
//  Synopsis:   Return a pointer within the version data [pbData] to the
//              value named [wzValueName].
//
//  Arguments:  [pbData]           - data returned by GetFileVersionInfo
//              [wzSubBlockPrefix] - prefix to use for value
//              [wzValueName]      - name of value
//
//  Returns:    Pointer to value, or NULL if it could not be found.
//
//  History:    6-04-1999   davidmun   Created
//
//---------------------------------------------------------------------------

PWSTR
_GetVersionValue(PVOID pbData,
                PCWSTR wzSubBlockPrefix,
                PCWSTR wzValueName)
{
    wstring strSubBlock(wzSubBlockPrefix);
    PVOID   pvValue = NULL;
    UINT    cchValue = 0;
    BOOL    fOk = FALSE;

    strSubBlock += wzValueName;

    fOk = VerQueryValue(pbData,
                        (PWSTR)strSubBlock.c_str(),
                        &pvValue,
                        &cchValue);

    if (fOk && cchValue)
    {
        return (PWSTR) pvValue;
    }
    return NULL;
}




//+--------------------------------------------------------------------------
//
//  Function:   _DetermineSubBlockPrefix
//
//  Synopsis:   Fill [wzSubBlockPrefix] with the version subblock prefix
//              which enables retrieval of the FileVersion string.
//
//  Arguments:  [wzSubBlockPrefix]  - buffer to fill with version subblock
//                                      prefix.
//              [cchSubBlockPrefix] - size of [wzSubBlockPrefix], in chars
//              [pbData]            - version data returned by
//                                      GetFileVersionInfo
//
//  Returns:    TRUE if [wzSubBlockPrefix] has been filled with a valid
//              string, FALSE if no such string could be determined.
//
//  Modifies:   *[wzSubBlockPrefix]
//
//  History:    6-04-1999   davidmun   Created
//
//  Notes:      See nt\private\shell\shell32\version.c
//
//              The FileVersion string is mandatory; if it can be retrieved
//              using the returned [wzSubBlockPrefix], then other version
//              values should be accessible using it.
//
//---------------------------------------------------------------------------

BOOL
_DetermineSubBlockPrefix(
    PWSTR wzSubBlockPrefix,
    ULONG cchSubBlockPrefix,
    PVOID pbData)
{
    BOOL fOk = TRUE;
    PVOID pvValue = NULL;
    UINT cchValue = 0;

    // Try same language as this program
    LoadStr(IDS_VN_FILEVERSIONKEY,
            wzSubBlockPrefix,
            cchSubBlockPrefix,
            L"\\StringFileInfo\\040904E4\\");

    fOk = VerQueryValue(pbData,
                        wzSubBlockPrefix,
                        &pvValue,
                        &cchValue);

    if (fOk && cchValue)
    {
        return TRUE;
    }

    // Look for translations

    fOk = VerQueryValue(pbData,
                        L"\\VarFileInfo\\Translation",
                        &pvValue,
                        &cchValue);

    if (fOk && cchValue)
    {
        struct _VERXLATE
        {
            WORD wLanguage;
            WORD wCodePage;
        } *pXlatePair;                     /* ptr to translations data */

        pXlatePair = (_VERXLATE*) pvValue;

        // Try first language this supports

        wsprintf(wzSubBlockPrefix,
                 L"\\StringFileInfo\\%04X%04X\\",
                 pXlatePair->wLanguage,
                 pXlatePair->wCodePage);

        if (_GetVersionValue(pbData, wzSubBlockPrefix, c_wzFileVersion))
        {
            return TRUE;
        }
    }


    // try English, unicode code page
    lstrcpy(wzSubBlockPrefix, TEXT("\\StringFileInfo\\040904B0\\"));
    if (_GetVersionValue(pbData, wzSubBlockPrefix, c_wzFileVersion))
    {
        return TRUE;
    }

    // try English
    lstrcpy(wzSubBlockPrefix, TEXT("\\StringFileInfo\\040904E4\\"));
    if (_GetVersionValue(pbData, wzSubBlockPrefix, c_wzFileVersion))
    {
        return TRUE;
    }

    // try English, null codepage
    lstrcpy(wzSubBlockPrefix, TEXT("\\StringFileInfo\\04090000\\"));
    if (_GetVersionValue(pbData, wzSubBlockPrefix, c_wzFileVersion))
    {
        return TRUE;
    }

    // Could not find FileVersion info in a reasonable format
    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Function:   MustEncode
//
//  Synopsis:   Return TRUE if [ch] is a character that must be encoded.
//
//  History:    11-03-1999   davidmun   Created
//
//---------------------------------------------------------------------------

inline BOOL
MustEncode(
    UCHAR ch)
{
    //
    // From RFC1738
    //
    // The octets 80-FF hexadecimal are not used in US-ASCII, and the octets
    // 00-1F and 7F hexadecimal represent control characters;
    // these must be encoded.
    //

    if (ch <= 0x1F || ch >= 0x80 || ch == 0x7f)
    {
        return TRUE;
    }

    //
    // The unsafe and reserved characters in this constant are
    // specified by RFC1738, but also contain "&" and "=" since
    // they're used as delimiters in our scheme.
    //

    const wstring strUnsafeAndReservedChars = L" <>\"#%{}|\\^~[]`/;?&=";

    return strUnsafeAndReservedChars.find((WCHAR)ch) != wstring::npos;
}




//+--------------------------------------------------------------------------
//
//  Function:   EscapeUrlComponent
//
//  Synopsis:   Convert [pwstr] from a UNICODE string to a UTF-8 string and
//              then escape the UTF-8 string for an HTTP URL per RFC 1738.
//
//  Arguments:  [pwstr] - on input, the string to escape.  on output, the
//                          escaped string.
//
//  Returns:    S_OK if escapement succeeded
//
//  Modifies:   *[pwstr]
//
//  History:    11-03-1999   davidmun   Created
//
//  Notes:      If [pwstr] contains Unicode characters which do not map
//              directly to the ANSI codepage, they will be discarded or
//              replaced with the system default character.
//
//              If the escapement fails, *[pwstr] is set to an empty string.
//
//              RFC 2043 defines UTF-8.
//
//---------------------------------------------------------------------------

HRESULT
EscapeUrlComponent(
    wstring *pwstr)
{
    HRESULT hr = S_OK;
    PSTR    pzAnsi = NULL;

    do
    {
        if (pwstr->empty())
        {
            break;
        }

        //
        // URLs are ASCII, but we're building one out of Unicode parts which
        // might contain non-ASCII characters.  Convert to UTF8 first.
        //

        ULONG cchUTF8;

        cchUTF8 = WideCharToMultiByte(CP_UTF8,
                                      0,
                                      pwstr->c_str(),
                                      static_cast<int>(pwstr->length()) + 1,
                                      NULL,
                                      0,
                                      NULL,
                                      NULL);

        if (!cchUTF8)
        {
            hr = HRESULT_FROM_LASTERROR;
            DBG_OUT_HRESULT(hr);
            break;
        }

        pzAnsi = new CHAR[cchUTF8];

        if (!pzAnsi)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        ULONG   cbWritten;

        cbWritten = WideCharToMultiByte(CP_UTF8,
                                        0,
                                        pwstr->c_str(),
                                        static_cast<int>(pwstr->length()) + 1,
                                        pzAnsi,
                                        cchUTF8,
                                        NULL,
                                        NULL);

        if (!cbWritten)
        {
            hr = HRESULT_FROM_LASTERROR;
            DBG_OUT_HRESULT(hr);
            break;
        }

        //
        // Now examine every character to see if it must be encoded.
        //

        ULONG iAnsi;
        ULONG iWstr = 0;

        for (iAnsi = 0; iAnsi < cchUTF8 - 1; iAnsi++)
        {
            UCHAR chCur = pzAnsi[iAnsi];

            if (MustEncode(chCur))
            {
                WCHAR wzEncoding[4];

                wsprintf(wzEncoding, L"%%%02x", (WCHAR)chCur);
                ASSERT(lstrlen(wzEncoding) == 3);
                pwstr->replace(iWstr, 1, wzEncoding);
                iWstr += 3;
            }
            else
            {
                pwstr->replace(iWstr, 1, 1, (WCHAR)chCur);
                ++iWstr;
            }
        }

    } while (0);

    delete [] pzAnsi;

    if (FAILED(hr))
    {
        pwstr->erase();
    }
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Function:   EscapeByteBuffer
//
//  Synopsis:   Escape the first [ccbBytesInBuffer] characters in
//              [pBufferToEncode] for an HTTP URL per RFC 1738.  Store the
//              result in [pwstr].
//
//  Arguments:  [pBufferToEncode]  - buffer to escape.
//              [ccbBytesInBuffer] - number of bytes in the buffer to escape.
//              [pwstr]            - string in which the escaped buffer will
//                                   be stored.
//              [cchMaxLength]     - maximum number of characters to store
//                                   in [pwstr], not including the
//                                   terminating NULL character.  pwstr->npos
//                                   indicates there is no maximum length.
//
//  Modifies:   *[pwstr]
//
//  History:    09-20-2000              Created
//
//---------------------------------------------------------------------------

void
EscapeByteBuffer(
    const BYTE *pBufferToEncode,
    const DWORD ccbBytesInBuffer,
    wstring *pwstr,
    const DWORD cchMaxLength)
{
    WCHAR wszEncoding[4];

    pwstr->erase();

    for (DWORD dwIndex = 0; dwIndex < ccbBytesInBuffer; dwIndex++)
        if (MustEncode(pBufferToEncode[dwIndex]))
        {
            if (cchMaxLength != pwstr->npos && pwstr->length() + 3 > cchMaxLength)
                break;

            wsprintf(wszEncoding, L"%%%02x", (WCHAR) pBufferToEncode[dwIndex]);
            (*pwstr) += wszEncoding;
        }
        else
        {
            if (cchMaxLength != pwstr->npos && pwstr->length() + 1 > cchMaxLength)
                break;

            (*pwstr) += (WCHAR) pBufferToEncode[dwIndex];
        }
}



//+--------------------------------------------------------------------------
//
//  Function:   TruncateEscapedUTF8String
//
//  Synopsis:   [pwstr] is a string already processed by the
//              EscapeUrlComponent() function.  Truncate [pwstr] to a maximum
//              length of [cchMaxLength] not including the terminating NULL
//              character.  Be sure not to "cut off" [pwstr] in the middle of
//              an escape character.
//
//  Arguments:  [pwstr]        - string to truncate.
//              [cchMaxLength] - number of characters to truncate [pwstr] to,
//                               not including the terminating NULL character.
//
//  Modifies:   *[pwstr]
//
//  History:    10-05-2000              Created
//
//  Notes:      Because [pwstr] is a UNICODE string converted to UTF-8 and
//              then escaped per RFC 1738, our truncation logic is triple
//              funk because we have to be careful not to truncate in the
//              middle of an encoded UNICODE character.
//
//              RFC 2043 defines UTF-8.
//
//---------------------------------------------------------------------------

void
TruncateEscapedUTF8String(
    wstring *pwstr,
    const DWORD cchMaxLength)
{
    //
    // If the pwstr does not need to be truncated, return now.
    //

    if (pwstr->length() <= cchMaxLength)
        return;

    //
    // If cchMaxLength is less than 3, handle it as a special case.
    //

    if (cchMaxLength == 0)
    {
        pwstr->erase();
        return;
    }

    if (cchMaxLength == 1)
    {
        if (pwstr->at(0) == L'%')
            pwstr->erase();

        return;
    }

    if (cchMaxLength == 2)
    {
        if (pwstr->at(0) == L'%')
            pwstr->erase();

        else if (pwstr->at(1) == L'%')
            pwstr->erase(1);

        return;
    }

    //
    // cchMaxLength is >= 3.  Truncate to cchMaxLength or one or two
    // characters less than that if cchMaxLength falls in the middle of an RFC
    // 1738 escape sequence.
    //

    if (pwstr->at(cchMaxLength - 2) == L'%')
        pwstr->erase(cchMaxLength - 2);

    else if (pwstr->at(cchMaxLength - 1) == L'%')
        pwstr->erase(cchMaxLength - 1);

    else
        pwstr->erase(cchMaxLength);

    //
    // We are guaranteed to not be positioned in the middle of an RFC 1738
    // escape sequence.  If we are at the end of one, it could be the first,
    // second, or third character in a two- or three-character UTF-8 sequence.
    // If so, be sure to truncate the remainer of that sequence.
    //

    WCHAR ch = 0x0080;

    while (pwstr->length() >= 3 &&
           pwstr->at(pwstr->length() - 3) == L'%' &&
           ch == 0x0080)
    {
        ch = pwstr->at(pwstr->length() - 2) & 0x00C0;

        if (ch == 0x00C0 || ch == 0x0080)
            pwstr->erase(pwstr->length() - 3);
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CEventUrl::~CEventUrl
//
//  Synopsis:   dtor
//
//  History:    6-03-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CEventUrl::~CEventUrl()
{
    TRACE_DESTRUCTOR(CEventUrl);
}




//+--------------------------------------------------------------------------
//
//  Member:     CEventUrl::Invoke
//
//  Synopsis:   Invoke the stored URL.
//
//  History:    6-03-1999   davidmun   Created
//
//---------------------------------------------------------------------------

void
CEventUrl::Invoke() const
{
    TRACE_METHOD(CEventUrl, Invoke);

    if (!_strUrl.empty())
    {
        if (_fIsMSRedirProg)
        {
            // NTRAID#NTBUG9-2002/05/17-623723-ericb: prefast, GetWindowsDir can fail.
            WCHAR wszWindowsDir[MAX_PATH+1] = {0};

            (void)GetWindowsDirectory(wszWindowsDir, MAX_PATH);

            ShellExecute(NULL, NULL, g_wszRedirectionProgram, _strMSRedirProgCmdLine.c_str(), wszWindowsDir, SW_NORMAL);
        }
        else
            ShellExecute(NULL, NULL, _strUrl.c_str(), NULL, NULL, SW_NORMAL);
    }
}








//+--------------------------------------------------------------------------
//
//  Member:     CConfirmUrlDlg::CConfirmUrlDlg
//
//  Synopsis:   ctor
//
//  History:    6-03-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CConfirmUrlDlg::CConfirmUrlDlg()
{
    TRACE_CONSTRUCTOR(CConfirmUrlDlg);
}




//+--------------------------------------------------------------------------
//
//  Member:     CConfirmUrlDlg::~CConfirmUrlDlg
//
//  Synopsis:   dtor
//
//  History:    6-03-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CConfirmUrlDlg::~CConfirmUrlDlg()
{
    TRACE_DESTRUCTOR(CConfirmUrlDlg);
}


const WCHAR c_wzUserSettingsKey[] =
    L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Event Viewer";

const WCHAR c_wzConfirmUrlValue[] = L"ConfirmUrl";

//+--------------------------------------------------------------------------
//
//  Member:     CConfirmUrlDlg::ShouldConfirm
//
//  Synopsis:   Return TRUE if registry flag indicating user doesn't want
//              to be asked for confirmation has been set.
//
//  Returns:    TRUE or FALSE
//
//  History:    6-04-1999   davidmun   Created
//
//  Notes:      Failure to read key or value is treated as if value exists
//              and was set to require confirmation.
//
//---------------------------------------------------------------------------

BOOL
CConfirmUrlDlg::ShouldConfirm()
{
    HRESULT     hr = S_OK;
    BOOL        fConfirm = TRUE;
    CSafeReg    shkUserSettings;

    do
    {
        hr = shkUserSettings.Open(HKEY_CURRENT_USER,
                                  c_wzUserSettingsKey,
                                  KEY_READ);
        BREAK_ON_FAIL_HRESULT(hr);

        BOOL fConfirmValue;

        hr = shkUserSettings.QueryDword((PWSTR)c_wzConfirmUrlValue,
                                        (PDWORD)&fConfirmValue);
        BREAK_ON_FAIL_HRESULT(hr);

        fConfirm = fConfirmValue;
    } while (0);

    return fConfirm;
}




//+--------------------------------------------------------------------------
//
//  Member:     CConfirmUrlDlg::GetConfirmation
//
//  Synopsis:   Return TRUE or FALSE to indicate user's confirmation of
//              the request to invoke the URL they clicked on.
//
//  Arguments:  [hwndParent] - dialog's parent window
//              [pUrl]       - information about URL to get confirmed
//
//  Returns:    TRUE if OK to invoke, FALSE otherwise
//
//  History:    6-16-1999   davidmun   Created
//
//---------------------------------------------------------------------------

BOOL
CConfirmUrlDlg::GetConfirmation(
    HWND hwndParent,
    const CEventUrl *pUrl)
{
    _pUrl = pUrl;
    return static_cast<BOOL>(_DoModalDlg(hwndParent, IDD_CONFIRMURL));
}




//+--------------------------------------------------------------------------
//
//  Member:     CConfirmUrlDlg::_OnHelp
//
//  Synopsis:   Implement if context help is created for this dialog.
//
//  History:    6-16-1999   davidmun   Created
//
//---------------------------------------------------------------------------

VOID
CConfirmUrlDlg::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
}




//+--------------------------------------------------------------------------
//
//  Member:     CConfirmUrlDlg::_OnInit
//
//  Synopsis:   Populate the URL confirmation dialog with info from the URL
//              to confirm.
//
//  Arguments:  [pfSetFocus] - not used
//
//  Returns:    S_OK
//
//  History:    6-16-1999   davidmun   Created
//
//---------------------------------------------------------------------------

HRESULT
CConfirmUrlDlg::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CConfirmUrlDlg, _OnInit);

    HWND        hwndLV = _hCtrl(urlconfirm_data_lv);
    WCHAR       wszBuffer[MAX_PATH + 1];
    LV_COLUMN   lvc;
    RECT        rcLV;

    //
    // Create the listview control columns
    //

    ListView_SetExtendedListViewStyleEx(hwndLV, LVS_EX_LABELTIP, LVS_EX_LABELTIP);

    VERIFY(GetClientRect(hwndLV, &rcLV));
    rcLV.right -= GetSystemMetrics(SM_CXVSCROLL);

    ZeroMemory(&lvc, sizeof lvc);
    lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt  = LVCFMT_LEFT;
    lvc.pszText = wszBuffer;
    lvc.cchTextMax = ARRAYLEN(wszBuffer);

    LoadStr(IDS_LVCOLUMN_0, wszBuffer, ARRAYLEN(wszBuffer));
    lvc.cx = rcLV.right / 2;
    ListView_InsertColumn(hwndLV, 0, &lvc);

    LoadStr(IDS_LVCOLUMN_1, wszBuffer, ARRAYLEN(wszBuffer));
    lvc.cx = rcLV.right / 2;
    ListView_InsertColumn(hwndLV, 1, &lvc);

    //
    // Fill it with item name/value pairs from the Url
    //

    _AddToListview(IDS_RECORD_HDR_SOURCE,     _pUrl->GetSource());
    _AddToListview(IDS_RECORD_HDR_CATEGORY,   _pUrl->GetCategory());
//  _AddToListview(IDS_RECORD_HDR_USER,       _pUrl->GetUser());
//  _AddToListview(IDS_RECORD_HDR_COMPUTER,   _pUrl->GetComputer());
    _AddToListview(IDS_RECORD_HDR_TYPE,       _pUrl->GetType());
    _AddToListview(IDS_EVENT_ID,              _pUrl->GetEventID());
    _AddToListview(IDS_RECORD_HDR_DATE,       _pUrl->GetDate());
    _AddToListview(IDS_RECORD_HDR_TIME,       _pUrl->GetTime());
    _AddToListview(IDS_FILE_NAME,             _pUrl->GetFileName());
    _AddToListview(IDS_FILE_VERSION,          _pUrl->GetFileVersion());
    _AddToListview(IDS_PRODUCT_VERSION,       _pUrl->GetProductVersion());
    _AddToListview(IDS_COMPANY_NAME,          _pUrl->GetCompanyName());
    _AddToListview(IDS_PRODUCT_NAME,          _pUrl->GetProductName());

//  for (int iIndex = 0; iIndex < _pUrl->GetCountInsStrs(); iIndex++)
//      _AddToListview(IDS_DESCRIPTION_TEXT,  _pUrl->GetInsStr(iIndex));

//  _AddToListview(IDS_DATA,                  _pUrl->GetData());

    return S_OK;
}



//+--------------------------------------------------------------------------
//
//  Member:     CConfirmUrlDlg::_AddToListview
//
//  Synopsis:   Add a row describing a piece of information which is to be
//              sent along with the URL to the listview.
//
//  Arguments:  [idsItem]  - string id of label for item
//              [pwzValue] - value of item
//
//  History:    6-16-1999   davidmun   Created
//
//---------------------------------------------------------------------------

void
CConfirmUrlDlg::_AddToListview(
    ULONG idsItem,
    PCWSTR pwzValue)
{
    if (!pwzValue || !*pwzValue)
    {
        return;
    }

    WCHAR wzItem[MAX_PATH];
    HWND  hwndLV = _hCtrl(urlconfirm_data_lv);

    LoadStr(idsItem, wzItem, ARRAYLEN(wzItem));

    LV_ITEM lvi;

    ZeroMemory(&lvi, sizeof lvi);

    lvi.mask = LVIF_TEXT;
    lvi.pszText = wzItem;

    int iItem = ListView_InsertItem(hwndLV, &lvi);
    ListView_SetItemText(hwndLV, iItem, 1, (PWSTR) pwzValue);
}




//+--------------------------------------------------------------------------
//
//  Member:     CConfirmUrlDlg::_OnCommand
//
//  Synopsis:   Handle dialog control clicks
//
//  Arguments:  [wParam] - standard windows
//              [lParam] -
//
//  Returns:    TRUE if command was not handled, FALSE otherwise
//
//  History:    6-16-1999   davidmun   Created
//
//---------------------------------------------------------------------------

BOOL
CConfirmUrlDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CConfirmUrlDlg, _OnCommand);

    BOOL fUnhandled = FALSE;

    switch (LOWORD(wParam))
    {
    case IDYES:
        EndDialog(_hwnd, TRUE);
        break;

    case IDNO:
        EndDialog(_hwnd, FALSE);
        break;

    default:
        fUnhandled = TRUE;
        break;
    }
    return fUnhandled;
}




//+--------------------------------------------------------------------------
//
//  Member:     CConfirmUrlDlg::_OnDestroy
//
//  Synopsis:   Handle dialog destruction by persisting "don't ask me again"
//              flag if it's set.
//
//  History:    6-16-1999   davidmun   Created
//
//---------------------------------------------------------------------------

VOID
CConfirmUrlDlg::_OnDestroy()
{
    TRACE_METHOD(CConfirmUrlDlg, _OnDestroy);

    HRESULT     hr = S_OK;
    CSafeReg    shkCurUser;
    CSafeReg    shkUserSettings;

    do
    {
        if (!IsDlgButtonChecked(_hwnd, urlconfirm_dontask_ckbox))
        {
            break;
        }

        hr = shkCurUser.Open(HKEY_CURRENT_USER,
                             NULL,
                             KEY_CREATE_SUB_KEY);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkCurUser.Create(c_wzUserSettingsKey, &shkUserSettings);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkUserSettings.SetDword((PWSTR)c_wzConfirmUrlValue, FALSE);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\eventmsg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       desc.cxx
//
//  Contents:
//
//  History:    2-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <malloc.h>

#define TEMP_STR_BUF                    MAX_PATH
#define EVENT_MSGFILE_DELIMETERS        L";,"
#define PARAM_MSG_FILE_VALUE            L"ParameterMessageFile"
#define MAX_INSERT_OPS                  100
#define FMT_MSG_MIN_ALLOC               256
#define KERNEL32_DLL                    L"kernel32.dll"

//
// Types
//
// PSK - used to track the use of the Primary Source Key.  This allows the
//  code to initialize it on demand.
//
// SDescriptionStr - holds string and information about string as it is
//  being built up.
//
// MODULE_LOAD_STATUS - describes whether a module has been loaded or
//  if the attempt failed.
//
// MODULE_TYPE - identifies the type of message file module being used
//
// SParamModule - used to track handle to and status of a message file
//  module.
//

enum PSK
{
    PSK_NOT_EXAMINED,
    PSK_NONE,
    PSK_IS_LOCAL_SOURCE,
    PSK_OPEN_FAILED,
    PSK_VALID
};

struct SDescriptionStr
{
    LPWSTR pwszExpanded;
    LPWSTR pwszCur;
    ULONG  cchBuf;
    ULONG  cchRemain;
};


enum MODULE_LOAD_STATUS
{
    LOAD_NOT_ATTEMPTED,
    LOAD_SUCCEEDED,
    LOAD_FAILED
};

enum MODULE_TYPE
{
    REMOTE,
    LOCAL,
    PRIMARY
};

struct SParamModule
{
    MODULE_LOAD_STATUS  mls;
    MODULE_TYPE         mt;
    CSafeReg           *pshkSource;
    CSafeCacheHandle    schModule;
};

//
// Forward references
//

HRESULT
GetRemoteSystemRoot(
    HKEY    hkRemoteHKLM,
    LPWSTR  wszRemoteSystemRoot,
    ULONG   cch);

HRESULT
GetEventMessageFileList(
    CSafeReg *pshkSource,
    LPCWSTR   pwszServerName,
    LPWSTR    wszRemoteSystemRoot,
    LPWSTR  **apwszEventMessageFiles);

MODULE_LOAD_STATUS
LoadRemoteParamModule(
    LPCWSTR   wszServerName,
    CSafeReg *pshkRemote,
    LPCWSTR   wszRemoteSystemRoot,
    LPWSTR    wszRemoteParamMsgFilePath,
    ULONG     cchRemoteParamMsgFilePath,
    CSafeCacheHandle *pschRemoteModule);

PSK
OpenPrimarySourceKey(
    LPCWSTR pwszPrimarySourceName,
    LPCWSTR pwszLocalSourceName,
    LPCWSTR pwszLogName,
    CSafeReg *pshkPrimarySource);


VOID
ReplaceAllInserts(
    EVENTLOGRECORD *pelr,
    CLogInfo       *pli,
    LPWSTR          wszRemoteSystemRoot,
    CSafeReg       *pshkRemoteSource,
    CSafeReg       *pshkLocalSource,
    CSafeReg       *pshkPrimarySource,
    PSK             psk,
    LPWSTR         *ppwszMsg);

HRESULT
ReplaceStringInsert(
    SDescriptionStr *pds,
    EVENTLOGRECORD  *pelr);

VOID
ReplaceParameterInsert(
    SDescriptionStr *pds,
    EVENTLOGRECORD  *pelr,
    CLogInfo        *pli,
    LPWSTR          wszRemoteSystemRoot,
    SParamModule    *ppmRemote,
    SParamModule    *ppmLocal,
    SParamModule    *ppmPrimary,
    PSK             *pPSK);

HRESULT
ReplaceSubStr(
    LPCWSTR pwszToInsert,
    LPWSTR *ppwszBuf,
    LPWSTR *ppwszInsertPoint,
    LPCWSTR pwszSubStrEnd,
    ULONG  *pcchBuf,
    ULONG  *pcchRemain);

ULONG
TerminatePathStrings(
    LPWSTR pwszUnexpanded);

IDirectorySearch *
DeriveGcFromServer(
    PCWSTR pwzMachine);

wstring
DoLdapQueryForSid(
    IDirectorySearch *pDirSearch,
    PSID psid);



//+--------------------------------------------------------------------------
//
//  Function:   AppendRedirectionURLText
//
//  Synopsis:   Uses the g_IsMicrosoftDllCache to find out if Microsoft
//              created pwszMessageFile.  If so, reallocates *ppwszMsg and
//              appends the redirection URL text that instructs the user to
//              to to the Microsoft web site for more information.
//
//  Arguments:  [pwszMessageFile] - module filename
//              [ppwszMsg]        - holds result
//
//  Modifies:   *[ppwszMsg], accesses "is Microsoft" dll cache
//
//  History:    9-16-2000              Created
//
//---------------------------------------------------------------------------

static VOID
AppendRedirectionURLText(
    LPCWSTR pwszMessageFile,
    LPWSTR *ppwszMsg)
{
    TRACE_FUNCTION(AppendRedirectionURLText);

    //
    // If we previously failed to load the redirection URL text, just return.
    //

    if (g_wszRedirectionTextToAppend[0] == 0)
        return;

    //
    // Use the cache to determine if the DLL was created by Microsoft.  If not
    // just return.
    //

    BOOL fIsMicrosoftDll = FALSE;

    (void) g_IsMicrosoftDllCache.Fetch(pwszMessageFile, &fIsMicrosoftDll);

    if (!fIsMicrosoftDll)
        return;

    // 714804-2002/10/04-JonN Suppress FWLINK if Exchange's
    //   CONTENTREDIRECT link is present
    //   Note that this test could in theory trigger if the CONTENTREDIRECT
    //   string is present as a substring which is not linked, e.g.
    //   "foobar\http://www.microsoft.com...".  This would cause the FWLINK
    //   to be suppressed incorrectly.  This is extremely unlikely however,
    //   especially since *ppwszMsg at this point comes directly from the
    //   EventMessageFile and has not yet been expanded.
    if (NULL != wcsistr(*ppwszMsg,
                    L"http://www.microsoft.com/contentredirect.asp"))
        return;

    //
    // Allocate a new buffer large enough to hold the original description
    // plus the redirection URL text.
    //

    LPWSTR pwszNewMsg = (LPWSTR) LocalAlloc(0, (wcslen(*ppwszMsg) + wcslen(g_wszRedirectionTextToAppend) + 1) * sizeof(WCHAR));

    if (pwszNewMsg == NULL)
        return;

    //
    // Some applications such as IIS already hard-code the redirection URL in
    // their event descriptions.  If we find the URL in the original
    // description, just return.
    //
    
    //This modification is not necessary in W2K code. #256032.
    WCHAR wszUpperCaseURL[MAX_PATH];

    wcscpy(wszUpperCaseURL, g_wszRedirectionURL);
    _wcsupr(wszUpperCaseURL);

    wcscpy(pwszNewMsg, *ppwszMsg);
    _wcsupr(pwszNewMsg);

    if (wcsstr(pwszNewMsg, wszUpperCaseURL) != NULL) {
        LocalFree(pwszNewMsg);
        return;
    }

    //
    // Fill the new buffer with the original text and append the URL
    // redirection text.  Deallocate the original buffer and return the new
    // one to the caller.
    //

    wcscpy(pwszNewMsg, *ppwszMsg);
    wcscat(pwszNewMsg, g_wszRedirectionTextToAppend);

    LocalFree(*ppwszMsg);

    *ppwszMsg = pwszNewMsg;
}




//+--------------------------------------------------------------------------
//
//  Function:   AttemptFormatMessage
//
//  Synopsis:   Perform a FormatMessage against message id [ulEventID] in
//              module [pwszMessageFile], putting the LocalAlloced result
//              in [ppwszMsg].
//
//  Arguments:  [ulEventID]           - message id
//              [pwszMessageFile]     - module filename
//              [ppwszMsg]            - holds result
//              [fAppendURL]          - TRUE if formatting and event descr.
//
//  Returns:    TRUE  - *[ppwszMsg] valid
//              FALSE - *[ppwszMsg] is NULL
//
//  Modifies:   *[ppwszMsg], accesses dll cache
//
//  History:    2-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
AttemptFormatMessage(
    ULONG ulEventID,
    LPCWSTR pwszMessageFile,
    LPWSTR *ppwszMsg,
    BOOL fAppendURL)
{
    TRACE_FUNCTION(AttemptFormatMessage);

    BOOL        fOk = FALSE; // init for failure
    CSafeCacheHandle schMsgFile;

    *ppwszMsg = NULL;

    (void) g_DllCache.Fetch(pwszMessageFile, &schMsgFile);

    if ((HINSTANCE) schMsgFile)
    {
        ULONG cch = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE       |
                                   FORMAT_MESSAGE_IGNORE_INSERTS    |
                                   FORMAT_MESSAGE_ALLOCATE_BUFFER   |
                                   FORMAT_MESSAGE_MAX_WIDTH_MASK,
                                  (LPCVOID) (HINSTANCE) schMsgFile,
                                  ulEventID,
                                  0,
                                  (LPWSTR) ppwszMsg,
                                  FMT_MSG_MIN_ALLOC,
                                  NULL);

        if (cch)
        {
            // successfully got event message string
            fOk = TRUE;

            // JonN 11/21/00 213436
            // Event Viewer: Trailing spaces in strings within results pane
            if (*ppwszMsg && (L' ' == (*ppwszMsg)[cch-1]))
                (*ppwszMsg)[cch-1] = TEXT('\0');

            if (fAppendURL)
                AppendRedirectionURLText(pwszMessageFile, ppwszMsg);
        }
        else
        {
            Dbg(DEB_ITRACE,
                "AttemptFormatMessage: error %uL for eventid %uL\n",
                GetLastError(),
                ulEventID);
        }
    }

    return fOk;
}



#define CCH_PUNCTUATION_MAX     10

//+--------------------------------------------------------------------------
//
//  Function:   CreateFallbackMessage
//
//  Synopsis:   Create a string that lists all inserts found in [pelr].
//
//  Arguments:  [pelr]     - event log record for which to construct string
//              [ppwszMsg] - filled with LocalAlloced message or NULL
//
//  Modifies:   *[ppwszMsg]
//
//  History:    2-24-1997   DavidMun   Created
//              2-01-2001   JonN/YangGao 256032 buffer overrun cleanup
//              3-01-2002   JonN       Added pstrUnexpandedDescriptionStr
//                                     parameter (539485)
//
//---------------------------------------------------------------------------

VOID
CreateFallbackMessage(
    EVENTLOGRECORD *pelr,
    LPWSTR *ppwszMsg,
    LPWSTR *ppstrUnexpandedDescriptionStr)
{
    TRACE_FUNCTION(CreateFallbackMessage);

    *ppwszMsg = NULL; // init for failure

    LPWSTR pwszSrcName = GetSourceStr(pelr);

    wstring wstrNotFound = FormatString(IDS_DESCR_NOTFOUND, (WORD)pelr->EventID, pwszSrcName);

    if(wstrNotFound.empty()) 
    {
        return;
    }

    // 2002/03/12-JonN 539485
    if (NULL != ppstrUnexpandedDescriptionStr)
    {
        *ppstrUnexpandedDescriptionStr = (WCHAR*)
            LocalAlloc(LMEM_FIXED, (wcslen(wstrNotFound.c_str())+1)
                    * sizeof(WCHAR));
        ASSERT( NULL != *ppstrUnexpandedDescriptionStr );
        if (*ppstrUnexpandedDescriptionStr)
        {
            lstrcpy( *ppstrUnexpandedDescriptionStr, wstrNotFound.c_str() );
        }
    }

    // +6 for extra room
    size_t cchRequired = wcslen(wstrNotFound.c_str()) + 6;

    wstring strErr;
    LPWSTR pwszCurInsert = GetFirstInsertString(pelr);
    if (IsBadStringPtr(pwszCurInsert, (UINT_PTR)-1))
    {
       // NTRAID#NTBUG9-546298-2002/05/04-ericb
       strErr = load_wstring(IDS_EVENTLOG_FILE_CORRUPT);
       pwszCurInsert = const_cast<LPWSTR>(strErr.c_str());
       pelr->NumStrings = 1;
    }
    USHORT i;

    //
    // Get the localized strings for separating a list and ending a sentence.
    //

    WCHAR wszListSeparator[CCH_PUNCTUATION_MAX];
    ULONG cchSeparator;
    WCHAR wszTerminator[CCH_PUNCTUATION_MAX];
    ULONG cchTerminator;

    GetLocaleStr(LOCALE_SLIST,
                 wszListSeparator,
                 ARRAYLEN(wszListSeparator),
                 L",");

    cchSeparator = lstrlen(wszListSeparator);

    LoadStr(IDS_FALLBACK_DESCR_TERMINATOR,
            wszTerminator,
            ARRAYLEN(wszTerminator),
            L".");

    cchTerminator = lstrlen(wszTerminator);

    if (!pelr->NumStrings)
    {
        cchRequired++; // for space before terminator
    }
    else
    {
        for (i = 0; i < pelr->NumStrings; i++)
        {
            //
            //  each insert string is preceeded by a space
            //  & followed by a list separator.
            //
            if (IsBadStringPtr(pwszCurInsert, (UINT_PTR)-1))
            {
               ASSERT(false && "bad insert string pointer!");
               pelr->NumStrings = i - 1;
               break;
            }
            size_t cchCurInsert = wcslen(pwszCurInsert);
            cchRequired += 1 + cchCurInsert + cchSeparator;
            pwszCurInsert += cchCurInsert + 1;
        }
    }

    cchRequired += cchTerminator;

    *ppwszMsg = (WCHAR*)
                LocalAlloc(LMEM_FIXED, cchRequired * sizeof(WCHAR));

    if (!*ppwszMsg)
    {
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return;
    }

    wcscpy( *ppwszMsg, wstrNotFound.c_str() );

    //
    // If there are no inserts, terminate the sentence and leave.
    //

    if (!pelr->NumStrings)
    {
        wcscat(*ppwszMsg, L" ");
        wcscat(*ppwszMsg, wszTerminator);
        return;
    }

    pwszCurInsert = GetFirstInsertString(pelr);
    if (IsBadStringPtr(pwszCurInsert, (UINT_PTR)-1))
    {
       // NTRAID#NTBUG9-546298-2002/05/04-ericb
       if (strErr.empty()) strErr = load_wstring(IDS_EVENTLOG_FILE_CORRUPT);
       pwszCurInsert = const_cast<LPWSTR>(strErr.c_str());
       pelr->NumStrings = 1;
    }

    for (i = 0; i < pelr->NumStrings; i++)
    {
        //
        //  for each insert string: preceed it by a space
        //                          & follow it by a comma/period.
        //

        wcscat(*ppwszMsg, L" ");
        wcscat(*ppwszMsg, pwszCurInsert);

        if (i == (pelr->NumStrings - 1))
        {
            wcscat(*ppwszMsg, wszTerminator);
        }
        else
        {
            wcscat(*ppwszMsg, wszListSeparator);
        }
        pwszCurInsert += wcslen(pwszCurInsert) + 1;
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   ExpandStringArray
//
//  Synopsis:   Convert the multi-sz string [pwszUnexpanded] containing
//              path names into an array of paths or UNCs with expanded
//              environment variables.
//
//  Arguments:  [pwszUnexpanded]      - multi-sz string
//              [cPaths]              - number of non-empty paths in
//                                        [pwszUnexpanded]
//              [pwszServerName]      - NULL or name of server if paths
//                                        are on remote machine
//              [wszRemoteSystemRoot] - value of remote systemroot
//              [ppwszExpanded]       - array of [cPaths] pointers,
//                                        all NULL on entry
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppwszExpanded]
//
//  History:    3-04-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
ExpandStringArray(
    LPWSTR pwszUnexpanded,
    ULONG cPaths,
    LPCWSTR pwszServerName,
    LPWSTR wszRemoteSystemRoot,
    LPWSTR *ppwszExpanded)
{
    TRACE_FUNCTION(ExpandStringArray);

    HRESULT hr = S_OK;
    ULONG   i;
    LPWSTR  pwszCurUnexpanded = pwszUnexpanded;

    for (i = 0; i < cPaths; i++)
    {
        //
        // skip multiple terminators.  If the value is "c:\foo;;d:\bar"
        // TerminatePathStrings will return 2 and leave the string as
        // "c:\foo\0\0d:\bar".
        //

        while (!*pwszCurUnexpanded)
        {
            pwszCurUnexpanded++;
        }

        //
        // Allocate enough space to hold a max length UNC name.  This
        // wastes a small amount of space for the local machine, but
        // this array only exists temporarily.
        //

        ppwszExpanded[i] = new WCHAR[MAX_PATH];

        if (!ppwszExpanded[i])
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (pwszServerName)
        {
            hr = ExpandRemoteSystemRoot(pwszCurUnexpanded,
                                        wszRemoteSystemRoot,
                                        ppwszExpanded[i],
                                        MAX_PATH);
            BREAK_ON_FAIL_HRESULT(hr);

            hr = ConvertPathToUNC(pwszServerName,
                                  ppwszExpanded[i],
                                  MAX_PATH);
            BREAK_ON_FAIL_HRESULT(hr);
        }
        else
        {
            ULONG cch = ExpandEnvironmentStrings(pwszCurUnexpanded,
                                                 ppwszExpanded[i],
                                                 MAX_PATH);

            if (!cch)
            {
                hr = HRESULT_FROM_LASTERROR;
                DBG_OUT_LASTERROR;
                break;
            }

            if (cch > MAX_PATH)
            {
                hr = E_FAIL;
                Dbg(DEB_ERROR,
                    "ExpandEnvironmentStrings of '%s' requires %u chars\n",
                    pwszCurUnexpanded,
                    cch);
                break;
            }
        }

        //
        // Advance within the multi-terminated string to the next
        // unexpanded path.
        //

        pwszCurUnexpanded += wcslen(pwszCurUnexpanded) + 1;
    }
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Function:   FreeStringArray
//
//  Synopsis:   Delete the strings in [apwsz], then delete [apwsz] itself.
//
//  Arguments:  [apwsz] - array of pointers to strings, last element is
//                          NULL.
//
//  History:    2-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
FreeStringArray(LPWSTR *apwsz)
{
    TRACE_FUNCTION(FreeStringArray);

    if (!apwsz)
    {
        return;
    }

    LPWSTR *ppwszCur = apwsz;

    while (*ppwszCur)
    {
        delete [] *ppwszCur;
        ppwszCur++;
    }
    delete [] apwsz;
}




//+--------------------------------------------------------------------------
//
//  Function:   GetDescriptionStr
//
//  Synopsis:   Return a LocalAlloced description string for record [pelr]
//              read from log described by [pli].
//
//  Arguments:  [pli]  - info about log containing [pelr]
//              [pelr] - event containing description to expand
//
//  Returns:    String allocated with LocalAlloc, or NULL on error
//
//  Modifies:   Uses dll cache.
//
//  History:    2-24-1997   DavidMun   Created
//              4-17-2001   JonN       Added fAppendURL parameter
//              3-01-2002   JonN       Added pstrUnexpandedDescriptionStr
//                                     parameter (539485)
//
//  Notes:      Caller must LocalFree returned string.
//
//---------------------------------------------------------------------------

LPWSTR
GetDescriptionStr(
    CLogInfo *pli,
    EVENTLOGRECORD *pelr,
    wstring *pstrMessageFile,
    BOOL fAppendURL,
    LPWSTR *ppstrUnexpandedDescriptionStr)
{
    TRACE_FUNCTION(GetDescriptionStr);

    // JonN 3/21/01 350614
    // Use message dlls and DS, FRS and DNS log types from specified computer
    LPWSTR pwszRemoteMessageServer = pli->GetLogServerName();
    if ( pli->IsBackupLog() && *g_wszAuxMessageSource )
    {
        pwszRemoteMessageServer = g_wszAuxMessageSource;
    }

    HRESULT  hr                              = S_OK;
    BOOL     fRemote                         = pwszRemoteMessageServer != NULL;
    BOOL     fRemoteMessageFilesToTry        = fRemote;
    BOOL     fLocalMessageFilesToTry         = TRUE;
    BOOL     fFoundMsg                       = FALSE;
    LPWSTR  *apwszRemoteEventMessageFiles    = NULL;
    LPWSTR  *ppwszCurRemote                  = NULL;
    LPWSTR  *apwszLocalEventMessageFiles     = NULL;
    LPWSTR  *ppwszCurLocal                   = NULL;
    LPWSTR   pwszMsg                         = NULL;
    WCHAR    wszRemoteSystemRoot[MAX_PATH+1] = L"";
    CSafeReg shkRemoteHKLM;
    CSafeReg shkLocalSource;
    CSafeReg shkRemoteSource;

    if (pstrMessageFile)
    {
        pstrMessageFile->erase();
    }

    //
    // Build the name of the source registry key so we can read the parameter
    // message file and event message file names.
    //

    // JonN 12/18/00 256032: Buffer overrun in Event Viewer
    LPCWSTR pwszLogName = pli->GetLogName();
    LPCWSTR pwszSourceStr = GetSourceStr(pelr);
    if (!pwszLogName || !pwszSourceStr)
    {
        DBG_OUT_LRESULT(E_UNEXPECTED);
        CreateFallbackMessage(pelr, &pwszMsg, ppstrUnexpandedDescriptionStr);
        return pwszMsg;
    }
    // NTRAID#NTBUG9-2002/05/17-623723-ericb: prefast
    WCHAR* wszSourceKeyName = (WCHAR*)malloc(
            (wcslen(EVENTLOG_KEY)+wcslen(pwszLogName)+wcslen(pwszSourceStr)+3)
            * sizeof(WCHAR) );
    if (!wszSourceKeyName)
    {
        DBG_OUT_LRESULT(E_OUTOFMEMORY);
        CreateFallbackMessage(pelr, &pwszMsg, ppstrUnexpandedDescriptionStr);
        return pwszMsg;
    }
    wsprintf(wszSourceKeyName,
             L"%s\\%s\\%s",
             EVENTLOG_KEY,
             pwszLogName,
             pwszSourceStr);

    //
    // Attempt to open the key on the local machine.  It will be used if
    // the log is local, or if the log is remote and there is a problem
    // loading the remote message files.
    //

    hr = shkLocalSource.Open(HKEY_LOCAL_MACHINE,
                             wszSourceKeyName,
                             KEY_QUERY_VALUE);

    if (FAILED(hr))
    {
        fLocalMessageFilesToTry = FALSE;
        Dbg(DEB_ITRACE,
            "Error 0x%x attempting to open local key '%s'\n",
            hr,
            wszSourceKeyName);
        hr = S_OK; // this error has been processed, reset hr
    }

    //
    // If the log lies on a remote machine, get the information needed to
    // read event message files and parameter message files from the machine:
    // a connection to its HKEY_LOCAL_MACHINE, the value of its SystemRoot
    // environment variable, and a list of event message files for the source
    // in pelr.
    //
    // If any of these fail, use only the local machine.
    //

    do
    {
        if (!fRemoteMessageFilesToTry) // JonN 3/20/01 350614
        {
            break;
        }

        hr = shkRemoteHKLM.Connect(pwszRemoteMessageServer, HKEY_LOCAL_MACHINE);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = GetRemoteSystemRoot(shkRemoteHKLM,
                                 wszRemoteSystemRoot,
                                 ARRAYLEN(wszRemoteSystemRoot));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkRemoteSource.Open(shkRemoteHKLM,
                                  wszSourceKeyName,
                                  KEY_QUERY_VALUE);
        if (FAILED(hr))
        {
            Dbg(DEB_ITRACE,
                "Error 0x%x attempting to open remote source key '%s'\n",
                hr,
                wszSourceKeyName);
            break;
        }
        Dbg(DEB_ITRACE, "Opened remote source key '%s'\n", wszSourceKeyName);

        hr = GetEventMessageFileList(&shkRemoteSource,
                                     pwszRemoteMessageServer,
                                     wszRemoteSystemRoot,
                                     &apwszRemoteEventMessageFiles);
        BREAK_ON_FAIL_HRESULT(hr);

        ppwszCurRemote = apwszRemoteEventMessageFiles;
    } while (0);

    free(wszSourceKeyName);
    if (FAILED(hr))
    {
        fRemoteMessageFilesToTry = FALSE;
    }

    while (!fFoundMsg &&
           (fRemoteMessageFilesToTry || fLocalMessageFilesToTry))
    {
        //
        // If we're looking at a log on a remote machine, were able to get
        // a list of the event message files for pelr's source, and haven't
        // exhausted that list yet, see if a string for pelr->EventID is in
        // the next remote machine module.
        //

        if (fRemoteMessageFilesToTry)
        {
            if (*ppwszCurRemote)
            {
                fFoundMsg = AttemptFormatMessage(pelr->EventID,
                                                 *ppwszCurRemote,
                                                 &pwszMsg,
                                                 fAppendURL);
                if (fFoundMsg)
                {
                    Dbg(DEB_ITRACE,
                        "Found event id 0x%x message '%s' in remote file '%s'\n",
                        pelr->EventID,
                        pwszMsg,
                        *ppwszCurRemote);

                    //
                    // If caller wants message file used to get message,
                    // fill it in.
                    //

                    if (pstrMessageFile)
                    {
                        *pstrMessageFile = *ppwszCurRemote;
                    }
                }
                ppwszCurRemote++;
            }
            else
            {
                fRemoteMessageFilesToTry = FALSE;
            }
        }

        //
        // If the log is remote and we didn't just get the message string from
        // the remote machine, or if the log is local, try the local machine,
        // assuming we haven't already and failed to get the local event file
        // message list.
        //

        if (!fFoundMsg && fLocalMessageFilesToTry)
        {
            if (!ppwszCurLocal)
            {
                hr = GetEventMessageFileList(&shkLocalSource,
                                             NULL,
                                             L"",
                                             &apwszLocalEventMessageFiles);
                if (FAILED(hr))
                {
                    fLocalMessageFilesToTry = FALSE;
                }
                else
                {
                    ppwszCurLocal = apwszLocalEventMessageFiles;
                }
            }

            if (fLocalMessageFilesToTry && *ppwszCurLocal)
            {
                fFoundMsg = AttemptFormatMessage(pelr->EventID,
                                                 *ppwszCurLocal,
                                                 &pwszMsg,
                                                 fAppendURL);
                if (fFoundMsg)
                {
                    Dbg(DEB_ITRACE,
                        "Found event id 0x%x message '%s' in local file '%s'\n",
                        pelr->EventID,
                        pwszMsg,
                        *ppwszCurLocal);

                    // JonN 3/20/01 CODEWORK I don't understand why only if !fRemote
                    if (!fRemote && pstrMessageFile)
                    {
                        *pstrMessageFile = *ppwszCurLocal;
                    }
                }

                ppwszCurLocal++;
            }
            else
            {
                fLocalMessageFilesToTry = FALSE;
            }
        }
    }

    FreeStringArray(apwszRemoteEventMessageFiles);
    FreeStringArray(apwszLocalEventMessageFiles);

    //
    // If we couldn't find it on the remote or local machines using the
    // source named in the eventlog record itself, look in the primary
    // source on the local machine, if it exists.
    //

    PSK      PrimarySourceKey                = PSK_NOT_EXAMINED;
    LPWSTR  *apwszPrimaryEventMessageFiles   = NULL;
    LPWSTR  *ppwszCurPrimary                 = NULL;
    BOOL     fPrimaryMessageFilesToTry       = FALSE;
    CSafeReg shkPrimarySource;

    do
    {
        //
        // Don't bother with primary source if we've already found the
        // message.
        //

        if (fFoundMsg)
        {
            break;
        }

        PrimarySourceKey = OpenPrimarySourceKey(pli->GetPrimarySourceStr(),
                                                pwszSourceStr,
                                                pwszLogName,
                                                &shkPrimarySource);

        if (PrimarySourceKey != PSK_VALID)
        {
            break;
        }

        //
        // Get the primary source's message file list
        //
        hr = GetEventMessageFileList(&shkPrimarySource,
                                     NULL,
                                     L"",
                                     &apwszPrimaryEventMessageFiles);
        BREAK_ON_FAIL_HRESULT(hr);

        ppwszCurPrimary = apwszPrimaryEventMessageFiles;
        fPrimaryMessageFilesToTry = TRUE;
    } while (0);

    while (!fFoundMsg && ppwszCurPrimary && *ppwszCurPrimary)
    {
        fFoundMsg = AttemptFormatMessage(pelr->EventID,
                                         *ppwszCurPrimary,
                                         &pwszMsg,
                                         fAppendURL);
#if (DBG == 1)
        if (fFoundMsg)
        {
            Dbg(DEB_ITRACE,
                "Found event id 0x%x message '%s' in primary file '%s'\n",
                pelr->EventID,
                pwszMsg,
                *ppwszCurPrimary);
        }
#endif // (DBG == 1)
        ppwszCurPrimary++;
    }
    FreeStringArray(apwszPrimaryEventMessageFiles);

    //
    // If we still didn't find it use the fallback message (localized
    // string like "couldn't find message string for event id %u")
    //

    if (!fFoundMsg)
    {
        CreateFallbackMessage(pelr, &pwszMsg, ppstrUnexpandedDescriptionStr);
    }

    //
    // Replace the strings inserts (they are of the form %n) and the
    // parameter inserts (they are of the form %%n).  Note that
    // ReplaceAllInserts will realloc pwszMsg if it finds any inserts.
    //

    if (pwszMsg)
    {
        // 2002/03/12-JonN 539485
        if (fFoundMsg && NULL != ppstrUnexpandedDescriptionStr)
        {
            *ppstrUnexpandedDescriptionStr = (WCHAR*)
                LocalAlloc(LMEM_FIXED, (wcslen(pwszMsg)+1) * sizeof(WCHAR));
            ASSERT( NULL != *ppstrUnexpandedDescriptionStr );
            if (*ppstrUnexpandedDescriptionStr)
            {
                lstrcpy( *ppstrUnexpandedDescriptionStr, pwszMsg );
            }
        }
        ReplaceAllInserts(pelr,
                          pli,
                          wszRemoteSystemRoot,
                          &shkRemoteSource,
                          &shkLocalSource,
                          &shkPrimarySource,
                          PrimarySourceKey,
                          &pwszMsg);
    }

    return pwszMsg;
} // GetDescriptionStr




//+--------------------------------------------------------------------------
//
//  Function:   GetEventMessageFileList
//
//  Synopsis:   Create an array of paths to the event message files
//              specified by the arguments; for a remote machine, the paths
//              will be UNCs.
//
//  Arguments:  [pshkSource]             - source reg key (may be remote)
//              [pwszServerName]         - server name or NULL for local
//              [hkRemoteHKLM]           - connection to remote HKLM
//              [wszRemoteSystemRoot]    - value for remote %SystemRoot%
//              [apwszEventMessageFiles] - filled with array of msg files
//                                          or NULL on error
//
//  Returns:    HRESULT
//
//  Modifies:   *[apwszEventMessageFiles]
//
//  History:    2-24-1997   DavidMun   Created
//
//  Notes:      Caller must free with FreeStringArray.
//
//---------------------------------------------------------------------------

HRESULT
GetEventMessageFileList(
    CSafeReg *pshkSource,
    LPCWSTR   pwszServerName,
    LPWSTR    wszRemoteSystemRoot,
    LPWSTR  **apwszEventMessageFiles)
{
    TRACE_FUNCTION(GetEventMessageFileList);

    HRESULT  hr             = S_OK;
    LPWSTR  *ppwszExpanded  = NULL;
    LPWSTR   pwszUnexpanded = NULL;

    do
    {
        //
        // Read the EventMessageFile value, which is a REG_EXPAND_SZ string
        // containing multiple comma or semicolon separated filenames.
        //

        ULONG cbUnexpanded;

        hr = pshkSource->QueryBufSize(MESSAGEFILE_VALUE, &cbUnexpanded);
        BREAK_ON_FAIL_HRESULT(hr);

        ULONG cchUnexpanded = cbUnexpanded / sizeof(WCHAR) + 1;

        pwszUnexpanded = new WCHAR[cchUnexpanded];

        if (!pwszUnexpanded)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        hr = pshkSource->QueryPath(MESSAGEFILE_VALUE,
                                   pwszUnexpanded,
                                   cchUnexpanded,
                                   FALSE);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Count the number of paths so we can allocate the array and
        // each of the individual path strings, and change the delimiters
        // to null chars.
        //

        ULONG cPaths = TerminatePathStrings(pwszUnexpanded);

        if (!cPaths)
        {
            hr = E_FAIL;
            Dbg(DEB_IWARN, "Messagefile value has no paths\n");
            DBG_OUT_HRESULT(hr);
            break;
        }

        ppwszExpanded = new LPWSTR[cPaths + 1]; // +1 for sentinel

        if (!ppwszExpanded)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        ZeroMemory(ppwszExpanded, sizeof(LPWSTR) * (cPaths + 1));

        hr = ExpandStringArray(pwszUnexpanded,
                               cPaths,
                               pwszServerName,
                               wszRemoteSystemRoot,
                               ppwszExpanded);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            FreeStringArray(ppwszExpanded);
            ppwszExpanded = NULL;
            break;
        }
    } while (0);

    delete [] pwszUnexpanded;
    *apwszEventMessageFiles = ppwszExpanded;
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   GetInsertStr
//
//  Synopsis:   Return a pointer to the specified insert string within
//              [pelr].
//
//  Arguments:  [pelr]      - points to event log record
//              [idxString] - 0-based index of string to get
//
//  Returns:    Pointer to requested string
//
//  History:    3-04-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LPWSTR
GetInsertStr(
    EVENTLOGRECORD *pelr,
    ULONG idxString)
{
    TRACE_FUNCTION(GetInsertStr);
    ASSERT(pelr);
    ASSERT(pelr->NumStrings > idxString);

    LPWSTR pwszCur = GetFirstInsertString(pelr);

    if (!pwszCur)
    {
        Dbg(DEB_ERROR, "First insert string not found\n");
        return L"";
    }

    ULONG cToSkip;

    for (cToSkip = idxString; cToSkip; cToSkip--)
    {
        pwszCur += lstrlen(pwszCur) + 1;
    }
    return pwszCur;
}




//+--------------------------------------------------------------------------
//
//  Function:   LoadRemoteParamModule
//
//  Synopsis:   Load the module containing parameter inserts on remote
//              machine [wszServerName].
//
//  Arguments:  [wszServerName]             - remote machine name (less \\)
//              [pshkRemoteSource]          - source reg key on [wszServerName]
//              [wszRemoteSystemRoot]       - %SystemRoot% on [wszServerName]
//              [wszRemoteParamMsgFilePath] - filled with remote source key's
//                                              parameter msg file value
//              [cchRemoteParamMsgFilePath] - size of buffer in characters
//              [pschRemoteModule]          - filled with module handle
//
//  Returns:    LOAD_SUCCEEDED or LOAD_FAILED
//
//  Modifies:   [pschRemoteModule]
//
//  History:    3-06-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

MODULE_LOAD_STATUS
LoadRemoteParamModule(
    LPCWSTR   wszServerName,
    CSafeReg *pshkRemoteSource,
    LPCWSTR   wszRemoteSystemRoot,
    LPWSTR    wszRemoteParamMsgFilePath,
    ULONG     cchRemoteParamMsgFilePath,
    CSafeCacheHandle *pschRemoteModule)
{
    HRESULT hr = S_OK;
    WCHAR   wszTemp[MAX_PATH + 1] = L"";

    do
    {
        //
        // If the handle to the remote system's source reg key couldn't
        // be opened we won't be able to query it for the parameter
        // message file value, so bail.
        //

        if (!(HKEY)*pshkRemoteSource)
        {
            hr = E_FAIL;
            break;
        }

        ASSERT(*wszRemoteSystemRoot);

        //
        // Determine the file name of the remote parameter file
        //

        hr = pshkRemoteSource->QueryPath(PARAM_MSG_FILE_VALUE,
                                         wszTemp,
                                         ARRAYLEN(wszTemp),
                                         FALSE);
        if (FAILED(hr))
        {
            //
            // Since the ParameterMessageFile value is optional, this
            // is an acceptable "error."
            //

            Dbg(DEB_ITRACE,
                "Result 0x%x attempting to get remote parameter file\n",
                hr);
            break;
        }

        //
        // Expand the filename into a UNC and try to load the module
        // via the dll cache.
        //

        hr = ExpandRemoteSystemRoot(wszTemp,
                                    wszRemoteSystemRoot,
                                    wszRemoteParamMsgFilePath,
                                    cchRemoteParamMsgFilePath);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = ConvertPathToUNC(wszServerName,
                              wszRemoteParamMsgFilePath,
                              cchRemoteParamMsgFilePath);

        Dbg(DEB_ITRACE,
            "Expanded remote parameter file is '%s'\n",
            wszRemoteParamMsgFilePath);

        //
        // Ignore the return value except for a debug out, since
        // schRemoteParam will either contain a valid module handle
        // or NULL.
        //

        hr = g_DllCache.Fetch(wszRemoteParamMsgFilePath, pschRemoteModule);
        CHECK_HRESULT(hr);
    } while (0);

    return FAILED(hr) ? LOAD_FAILED : LOAD_SUCCEEDED;
}




//+--------------------------------------------------------------------------
//
//  Function:   OpenPrimarySourceKey
//
//  Synopsis:   Attempt to open the registry key for the primary source
//              named [pwszPrimarySourceName] under HKLM, but only if
//              there is a primary source and it differs from the local
//              source key.
//
//  Arguments:  [pwszPrimarySourceName] - name of primary source, may be NULL
//              [pwszLocalSourceName]   - name of local source
//              [pwszLogName]           - name of log sources live in
//              [pshkPrimarySource]     - valid unopened CSafeReg object
//
//  Returns:    Enumeration value describing resulting status of
//              *[pshkPrimarySource].
//
//  History:    2-27-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

PSK
OpenPrimarySourceKey(
    LPCWSTR pwszPrimarySourceName,
    LPCWSTR pwszLocalSourceName,
    LPCWSTR pwszLogName,
    CSafeReg *pshkPrimarySource)
{
    TRACE_FUNCTION(OpenPrimarySourceKey);

    PSK   PrimarySourceKey = PSK_NONE;
    wstring wstrPrimarySourceKeyName;

    do
    {
        //
        // If this record's log doesn't have a primary source, quit.
        //

        if (!pwszPrimarySourceName)
        {
            break;
        }

        //
        // Quit if the source we have already looked under is the same
        // as the primary source.
        //

        // NTRAID#NTBUG9-2002/05/17-623723-ericb: prefast, don't use lstrcmpi
        if (!_wcsicmp(pwszLocalSourceName, pwszPrimarySourceName))
        {
            PrimarySourceKey = PSK_IS_LOCAL_SOURCE;
            break;
        }
        //
        // Open the primary source's reg key
        //

        wstrPrimarySourceKeyName = EVENTLOG_KEY;
        wstrPrimarySourceKeyName += L"\\";
        wstrPrimarySourceKeyName += pwszLogName;
        wstrPrimarySourceKeyName += L"\\";
        wstrPrimarySourceKeyName += pwszPrimarySourceName;

        HRESULT hr;
        hr = pshkPrimarySource->Open(HKEY_LOCAL_MACHINE,
                                     (LPCTSTR)(wstrPrimarySourceKeyName.c_str()),
                                     KEY_QUERY_VALUE);
        if (FAILED(hr))
        {
            PrimarySourceKey = PSK_OPEN_FAILED;
        }
        else
        {
            PrimarySourceKey = PSK_VALID;
        }
    } while (0);

    return PrimarySourceKey;
}



// convert a string of the form returned by StringFromGUID2 (e.g.
// {c200e360-38c5-11ce-ae62-08002b2b79ef} ) to a GUID.
//
// Returns true on success, false on failure.

bool
wstringToGUID(const wstring& guidString, GUID& guid)
{
   ASSERT(!guidString.empty());
   memset(&guid, 0, sizeof(guid));

   // you'd think there'd be a GUIDFromString, but nooooo....
   HRESULT hr =
      ::IIDFromString(
         const_cast<wstring::value_type*>(guidString.c_str()),
         &guid);

   return SUCCEEDED(hr) ? true : false;
}



// class wrapping a handle bound to the directory service on a given domain
// controller.  Used to give the binding nice lifetime semantics such that
// when the wrapper instance is destroyed, the handle is unbound.

class CDsBindingHandle
{
   public:

   // initally unbound

   CDsBindingHandle()
      :
      m_hDS(0)
   {
   }

   ~CDsBindingHandle()
   {
      ::DsUnBind(&m_hDS);
   }

   // only re-binds if the dc name differs...

   DWORD
   Bind(const wstring& strDcName);

   // don't call DsUnBind on an instance of this class: you'll only regret
   // it later.  Let the dtor do the unbind.

   operator HANDLE()
   {
      return m_hDS;
   }

   private:

   HANDLE   m_hDS;
   wstring  m_strDcName;
};

DWORD
CDsBindingHandle::Bind(const wstring &strDcName)
{
    TRACE_METHOD(CDsBindingHandle, Bind);

    if (m_strDcName != strDcName || !m_hDS)
    {
        if (m_hDS)
        {
            ::DsUnBind(&m_hDS);
            m_hDS = NULL;
        }

        PWSTR pwzDcName = (PWSTR)strDcName.c_str();

        if (!*pwzDcName)
        {
            Dbg(DEB_TRACE, "binding with NULL\n");
            pwzDcName = NULL;
        }
        else
        {
            Dbg(DEB_TRACE, "binding to %s\n", pwzDcName);
        }

        DWORD err = ::DsBind(pwzDcName, 0, &m_hDS);

        if (err == NO_ERROR)
        {
            m_strDcName = strDcName;
        }
        else
        {
            DBG_OUT_LRESULT(err);
            ASSERT(!m_hDS);
            m_hDS = NULL;
        }

        return err;
    }

    return NO_ERROR;
}


// Call DsCrackNames to attempt to resolve a guid to its DN.  Returns the
// error code returned by DsCrackNames, and is successful, sets the result
// parameter to the DN of the object represented by the guid.
//
// handle - the handle to use, must already be opened by a prior call to
// DsBind.
//
// pwzGuid - the stringized guid
//
// strResult - receives the resulting DN upon success, cleared otherwise.

DWORD
CrackGuid(
   HANDLE   handle,
   PWSTR    pwzGuid,
   wstring  *pstrResult)

{
    TRACE_FUNCTION(CrackGuid);
    ASSERT(pwzGuid);
    ASSERT(pstrResult);

    pstrResult->erase();

    DS_NAME_RESULT* name_result = 0;
    DWORD err = ::DsCrackNames(
                      handle,
                      DS_NAME_NO_FLAGS,
                      DS_UNIQUE_ID_NAME,
                      DS_FQDN_1779_NAME,
                      1,                   // only 1 name to crack
                      &pwzGuid,
                      &name_result);

    if (err == NO_ERROR && name_result)
    {
        DS_NAME_RESULT_ITEM* item = name_result->rItems;

        if (item)
        {
            // the API may return success, but each cracked name also carries
            // an error code, which we effectively check by checking the name
            // field for a value.

            if (item->pName)
            {
                *pstrResult = item->pName;
            }
            else
            {
                Dbg(DEB_ERROR,
                    "DsCrackNames status %#x\n",
                    name_result->rItems[0].status);
            }
        }
        else
        {
            Dbg(DEB_ERROR, "DsCrackNames returned no items\n");
        }

        ::DsFreeNameResult(name_result);
    }
    else if (err != NO_ERROR)
    {
        Dbg(DEB_ERROR, "DsCrackNames of '%s' %u\n", pwzGuid, err);
    }

    return err;
}




//+--------------------------------------------------------------------------
//
//  Function:   GetMappedGUID
//
//  Synopsis:   Map a GUID to the name of the directory object the GUID
//              represents by appealing to the given domain controller to
//              provide this information.
//
//  Arguments:  [strDcName] - domain controller from the domain where the
//                            object represented by the GUID exists.
//              [strGuid]   - GUID of the object as a string.
//
//  Returns:    String containing mapped name
//
//  History:    ??-??-199?   SBurns     Created
//
//---------------------------------------------------------------------------

wstring
GetMappedGUID(const wstring& strDcName, const wstring& strGuid)
{
    TRACE_FUNCTION(GetMappedGUID);
    ASSERT(!strGuid.empty());

    GUID guid;

    if (!wstringToGUID(strGuid, guid))
    {
        return wstring();
    }

    wstring strResult;
    static CDsBindingHandle s_hDS;
    ULONG ulError = NO_ERROR;
    PWSTR pwzGuid = const_cast<wstring::value_type*>(strGuid.c_str());

    do
    {
        Dbg(DEB_ITRACE, "attempting to map the guid\n");

        ulError = s_hDS.Bind(strDcName);

        if (ulError != NO_ERROR)
        {
            Dbg(DEB_IWARN,
                "Binding to %s gave error %u\n",
                strDcName.c_str(),
                ulError);
            break;
        }

        DS_SCHEMA_GUID_MAP* guidmap = 0;
        ulError = ::DsMapSchemaGuids(s_hDS, 1, &guid, &guidmap);
        if (ulError != NO_ERROR)
        {
            Dbg(DEB_IWARN, "DsMapSchemaGuids failed with 0x%X\n", ulError);
            break;
        }

        if (guidmap->pName)
        {
            strResult = guidmap->pName;
        }

        ::DsFreeSchemaGuidMap(guidmap);

        if (!strResult.empty())
        {
            // the guid mapped as a schema guid: we're done
            break;
        }

        // the guid is not a schema guid.  Proabably an object guid.
        Dbg(DEB_ITRACE, "attempting to crack the guid\n");
        ulError = CrackGuid(s_hDS, pwzGuid, &strResult);
    }
    while (0);

    do
    {
        //
        // If we've got a string from the guid already, we're done.
        //

        if (!strResult.empty())
        {
            break;
        }

        //
        // one last try.  in this case, we bind to a GC to try to crack the
        // name.

        Dbg(DEB_ITRACE, "Attempting to crack the guid using GC\n");
        static CDsBindingHandle s_hGC;

        // empty string implies GC
        if (s_hGC.Bind(L"") != NO_ERROR)
        {
            Dbg(DEB_IWARN, "Unable to bind to GC\n");
            break;
        }

        Dbg(DEB_TRACE, "s_hGC = %#x\n", (HANDLE)s_hGC);
        ulError = CrackGuid(s_hGC, pwzGuid, &strResult);
        if (ulError != NO_ERROR)
        {
            DBG_OUT_LRESULT(ulError);
        }
    }
    while (0);

    return strResult;
}



//+--------------------------------------------------------------------------
//
//  Function:   GetMappedSID
//
//  Synopsis:   Return a friendly name for sid [psid].
//
//  Arguments:  [pwzServer1] - first server to base search on, NULL==local
//              [pwzServer2] - backup server to base search on, NULL==local
//              [psid]       - points to SID to look up
//
//  Returns:    Possibly empty string
//
//  History:    08-09-1999   davidmun   Created
//
//  Notes:      If [pwzServer1] and [pwzServer2] represent the same machine,
//              only one search will be done.
//
//---------------------------------------------------------------------------

wstring
GetMappedSID(
    PCWSTR pwzServer1,
    PCWSTR pwzServer2,
    const PSID psid)
{
    TRACE_FUNCTION(GetMappedSID);

    HRESULT     hr = S_OK;
    wstring     strResult;
    BOOL        fDirSearchInCache1 = FALSE;
    BOOL        fDirSearchInCache2 = FALSE;

    do
    {
        CWaitCursor Hourglass;

        //
        // See if there's a name for this sid already in the cache
        //

        WCHAR wzName[DNLEN + 1 + UNLEN];
        hr = g_SidCache.Fetch(psid, wzName, ARRAYLEN(wzName));

        if (hr == S_OK)
        {
            strResult = wzName;
            break;
        }

        //
        // Figure out whether Server1 and Server2 are different
        // machines.
        //

        BOOL fServersDiffer = FALSE;
        BOOL fServer1IsLocal = FALSE;
        BOOL fServer2IsLocal = FALSE;

        wstring wstrThisComputer = GetComputerNameAsString();

        if (!pwzServer1)
        {
            fServer1IsLocal = TRUE;
        }
        // This is an insufficient comparison; see the many forms of computer
        // names provided by GetComputerNameEx. However, the cost of missing a
        // valid match is just a redundant lookup.
        else if (!_wcsicmp(pwzServer1, wstrThisComputer.c_str()))
        {
            fServer1IsLocal = TRUE;
        }

        if (!pwzServer2)
        {
            fServer2IsLocal = TRUE;
        }
        else if (!_wcsicmp(pwzServer2, wstrThisComputer.c_str()))
        {
            fServer2IsLocal = TRUE;
        }

        fServersDiffer = (fServer1IsLocal && !fServer2IsLocal) ||
                         (!fServer1IsLocal && fServer2IsLocal) ||
                         (!fServer1IsLocal && !fServer2IsLocal &&
                          _wcsicmp(pwzServer1, pwzServer2));

        //
        // Try to obtain it with a simple lookup.
        //

        WCHAR wszName[MAX_PATH];
        ULONG cchName = ARRAYLEN(wszName);
        WCHAR wszDomain[MAX_PATH];
        ULONG cchDomain = ARRAYLEN(wszDomain);
        SID_NAME_USE snuUnused;

        BOOL fOk;

        fOk = LookupAccountSid(pwzServer1,
                               psid,
                               &wszName[0],
                               &cchName,
                               &wszDomain[0],
                               &cchDomain,
                               &snuUnused);

        if (fOk)
        {
            if (*wszDomain)
            {
                strResult = wszDomain;
                strResult += L"\\";
            }
            strResult += wszName;
            break;
        }

        //
        // If server2 != server1, retry the lookup using server2.
        //

        if (fServersDiffer)
        {
            fOk = LookupAccountSid(pwzServer2,
                                   psid,
                                   &wszName[0],
                                   &cchName,
                                   &wszDomain[0],
                                   &cchDomain,
                                   &snuUnused);

            if (fOk)
            {
                if (*wszDomain)
                {
                    strResult = wszDomain;
                    strResult += L"\\";
                }
                strResult += wszName;
                break;
            }
        }

        //
        // Lookups failed.  Have to try searching a GC.
        //
        // If there's a cached IDirectorySearch instance for either
        // server name, use those to do a search (checking to ensure that
        // if both have the same cached interface, we don't search it
        // twice).
        //
        // Note that failure to obtain an IDirectorySearch interface instance
        // is cached because attempting to get one is an expensive operation and we
        // don't want to retry it.  Therefore, Fetch can return
        // TRUE with a NULL interface pointer, meaning the failure was cached.
        //
        // TODO: it would be better if doing a Refresh command in the UI
        // would clear all cached failures.
        //

        IDirectorySearch *pDirSearch1 = NULL;
        IDirectorySearch *pDirSearch2 = NULL;

        fDirSearchInCache1 = g_DirSearchCache.Fetch(pwzServer1 ?
                                                        pwzServer1 :
                                                        wstrThisComputer.c_str(),
                                                    &pDirSearch1);

        if (pDirSearch1)
        {
            strResult = DoLdapQueryForSid(pDirSearch1, psid);

            if (!strResult.empty())
            {
                break;
            }
        }

        if (fServersDiffer)
        {
            fDirSearchInCache2 = g_DirSearchCache.Fetch(pwzServer2 ?
                                                            pwzServer2 :
                                                            wstrThisComputer.c_str(),
                                                        &pDirSearch2);

            if (pDirSearch2)
            {
                //
                // If both server names are supported by the same GC, then
                // don't search it again.
                //

                if (pDirSearch1 == pDirSearch2)
                {
                    break;
                }

                strResult = DoLdapQueryForSid(pDirSearch2, psid);

                //
                // If the search succeeded, we're done.
                //

                if (!strResult.empty())
                {
                    break;
                }

                //
                // If we just searched both GCs, there's nothing more to do.
                //

                if (fDirSearchInCache1)
                {
                    break;
                }
            }
        }

        //
        // Calling LookupAccountSid failed using both servers, and we have
        // searched either zero or one GC.
        //
        // Search the GCs associated with the two servers, making sure that
        // we don't search the same GC twice.
        //

        ASSERT(!fDirSearchInCache1 || !fDirSearchInCache2);

        if (!fDirSearchInCache1)
        {
            ASSERT(!pDirSearch1);
            pDirSearch1 = DeriveGcFromServer(pwzServer1);
            g_DirSearchCache.Add(pwzServer1 ? pwzServer1 : wstrThisComputer.c_str(),
                                 pDirSearch1);

            if (pDirSearch1)
            {
                strResult = DoLdapQueryForSid(pDirSearch1, psid);

                if (!strResult.empty())
                {
                    break;
                }
            }
        }

        if (!fDirSearchInCache2)
        {
            ASSERT(!pDirSearch2);
            pDirSearch2 = DeriveGcFromServer(pwzServer2);
            g_DirSearchCache.Add(pwzServer2 ? pwzServer2 : wstrThisComputer.c_str(),
                                 pDirSearch2);

            if (pDirSearch2)
            {
                strResult = DoLdapQueryForSid(pDirSearch2, psid);
            }
        }

    } while (0);


    //
    // Add the resulting string to the cache.  Even if we failed and
    // ended up with an empty string, we want it in the cache to
    // prevent further attempts to translate this sid to a name,
    // because they are expensive.
    //

    g_SidCache.Add(psid, strResult.c_str());
    return strResult;
}



//+--------------------------------------------------------------------------
//
//  Function:   DeriveGcFromServer
//
//  Synopsis:   Return an IDirectorySearch instance bound to the GC which
//              represents the enterprise to which [pwzMachine] belongs,
//              or NULL on error.
//
//  Arguments:  [pwzMachine] - machine used to determine GC
//
//  Returns:    NULL or interface which caller must release
//
//  History:    08-17-1999   davidmun   Created
//
//---------------------------------------------------------------------------

IDirectorySearch *
DeriveGcFromServer(
    PCWSTR pwzMachine)
{
    HRESULT                             hr = S_OK;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDsRole = NULL;
    PDOMAIN_CONTROLLER_INFO             pdci = NULL;
    ULONG                               ulResult;
    IDirectorySearch                   *pDirSearch = NULL;

    do
    {
        ulResult = DsRoleGetPrimaryDomainInformation(
                    pwzMachine,
                    DsRolePrimaryDomainInfoBasic,
                    (PBYTE *)&pDsRole);

        if (ulResult != NO_ERROR)
        {
            DBG_OUT_LRESULT(ulResult);
            hr = HRESULT_FROM_WIN32(ulResult);
            break;
        }

        //
        // If machine is in a workgroup, we're done.
        //

        if (pDsRole->MachineRole == DsRole_RoleStandaloneWorkstation ||
            pDsRole->MachineRole == DsRole_RoleStandaloneServer)
        {
            Dbg(DEB_TRACE, "Target machine is not joined to a domain\n");
            break;
        }

        //
        // Target machine is joined to a domain.  Find out if it's joined
        // to an NT4 or an NT5 domain by getting the name of a DC, and
        // requesting that we get one which supports DS.
        //

        PWSTR pwzDomainNameForDsGetDc;
        ULONG flDsGetDc = DS_DIRECTORY_SERVICE_REQUIRED;

        if (pDsRole->DomainNameDns)
        {
            pwzDomainNameForDsGetDc = pDsRole->DomainNameDns;
            flDsGetDc |= DS_IS_DNS_NAME;
        }
        else
        {
            pwzDomainNameForDsGetDc = pDsRole->DomainNameFlat;
            flDsGetDc |= DS_IS_FLAT_NAME;
        }

        ulResult = DsGetDcName(NULL,
                               pwzDomainNameForDsGetDc,
                               NULL,
                               NULL,
                               flDsGetDc,
                               &pdci);

        if (ulResult == ERROR_NO_SUCH_DOMAIN)
        {
            Dbg(DEB_ERROR,
                "DsGetDcName for domain %ws returned ERROR_NO_SUCH_DOMAIN, treating target machine as no-net\n",
                pwzDomainNameForDsGetDc);
            break;
        }

        if (ulResult != NO_ERROR)
        {
            Dbg(DEB_ERROR,
                "DsGetDcName for domain %ws returned %uL\n",
                pwzDomainNameForDsGetDc,
                ulResult);
            break;
        }

        if (pdci->Flags & DS_DS_FLAG)
        {
            PDOMAIN_CONTROLLER_INFO pdci2 = NULL;

            ulResult = DsGetDcName(NULL,
                                   pwzDomainNameForDsGetDc,
                                   NULL,
                                   NULL,
                                   flDsGetDc | DS_RETURN_DNS_NAME,
                                   &pdci2);


            if (ulResult == NO_ERROR)
            {
                NetApiBufferFree(pdci);
                pdci = pdci2;
            }
            else
            {
                ASSERT(!pdci2);
            }
        }

        if (ulResult != NO_ERROR)
        {
            Dbg(DEB_ERROR,
                "DsGetDcName for domain %ws (second call) returned %uL\n",
                pwzDomainNameForDsGetDc,
                ulResult);
            break;
        }

        ASSERT(pdci->Flags & DS_DS_FLAG);

        wstring strTargetDomainDns;
        wstring strTargetForest;

        if (pDsRole->DomainNameDns)
        {
            strTargetDomainDns = pDsRole->DomainNameDns;
        }
        else if (pdci->DomainName)
        {
            strTargetDomainDns = pdci->DomainName;
        }

        while (!strTargetDomainDns.empty() &&
               strTargetDomainDns.end() && // 655675-2002/07/08-JonN PREFIX
               *(strTargetDomainDns.end() - 1) == L'.')
        {
            strTargetDomainDns.erase(strTargetDomainDns.end() - 1);
        }

        strTargetForest = pdci->DnsForestName;

        while (!strTargetForest.empty() && *(strTargetForest.end() - 1) == L'.')
        {
            strTargetForest.erase(strTargetForest.end() - 1);
        }

        // reuse this for call to find GC server
        NetApiBufferFree(pdci);
        pdci = NULL;

        PCWSTR pwzTargetDomain = strTargetForest.c_str();

        if (!pwzTargetDomain[0])
        {
            pwzTargetDomain = NULL;
        }

        wstring strGcPath;

        DWORD dwResult;

        Dbg(DEB_TRACE,
            "DsGetDcName with DomainName=%ws\n",
            pwzTargetDomain ? pwzTargetDomain : L"<NULL>");

        dwResult = DsGetDcName(NULL,
                               pwzTargetDomain,
                               NULL,
                               NULL,
                               DS_GC_SERVER_REQUIRED,
                               &pdci);

        if (dwResult != NO_ERROR)
        {
            DBG_OUT_LRESULT(dwResult);
            break;
        }

        Dbg(DEB_TRACE,
            "Domain '%s' DC hosting GC is '%s'\n",
            pdci->DomainName,
            pdci->DomainControllerName);

        strGcPath = L"GC://";
        PWSTR pwzDomainName = pdci->DomainName;

        while (*pwzDomainName == L'\\')
        {
            pwzDomainName++;
        }
        strGcPath += pwzDomainName;

        size_t idxLastDot = strGcPath.rfind(L'.');

        if (idxLastDot == strGcPath.length() - 1)
        {
            strGcPath.erase(strGcPath.length() - 1, 1);
        }
        NetApiBufferFree(pdci);
        pdci = NULL;

        WCHAR wzPort[20];
        wsprintf(wzPort, L":%u", LDAP_GC_PORT);
        strGcPath += wzPort;

        //
        // Now bind to the GC for a search interface
        //

        hr = ADsOpenObject((PWSTR)strGcPath.c_str(),
                            NULL,
                            NULL,
                            ADS_SECURE_AUTHENTICATION,
                            IID_IDirectorySearch,
                            (void**)&pDirSearch);
        CHECK_HRESULT(hr);
    } while (0);

    if (pdci)
    {
        NetApiBufferFree(pdci);
    }

    if (pDsRole)
    {
        DsRoleFreeMemory(pDsRole);
    }

    return pDirSearch;
}


//+--------------------------------------------------------------------------
//
//  Function:   DoLdapQueryForSid
//
//  Synopsis:   Locate the GC for the enterprise to which [strServer] belongs
//              and perform a query among the deleted (and active) objects
//              for one with a sid of [psid], asking for the object's name.
//
//  Arguments:  [strServer] - target machine
//              [psid]      - SID for which to search
//
//  Returns:    Name of object having sid [psid].
//
//  History:    08-03-1999   davidmun   Created
//
//---------------------------------------------------------------------------

wstring
DoLdapQueryForSid(
    IDirectorySearch *pDirSearch,
    PSID psid)
{
    HRESULT                             hr = S_OK;
    PWSTR                               pwzSidBlob = NULL;
    ADS_SEARCH_HANDLE                   hSearch = NULL;
    wstring                             strResult;

    ASSERT(pDirSearch);
    ASSERT(psid && IsValidSid(psid));

    do
    {
        //
        // Set up the preferences for the search
        //

        ADS_SEARCHPREF_INFO aSearchPrefs[3];

        ZeroMemory(aSearchPrefs, sizeof aSearchPrefs);

        //
        // Always follow aliases
        //

        aSearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_DEREF_ALIASES;
        aSearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
        aSearchPrefs[0].vValue.Integer = ADS_DEREF_ALWAYS;

        //
        // Search down the subtree
        //

        aSearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
        aSearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
        aSearchPrefs[1].vValue.Integer = ADS_SCOPE_SUBTREE;

        //
        // Look through tombstone data
        //

        aSearchPrefs[2].dwSearchPref = ADS_SEARCHPREF_TOMBSTONE;
        aSearchPrefs[2].vValue.dwType = ADSTYPE_BOOLEAN;
        aSearchPrefs[2].vValue.Integer = TRUE;

        hr = pDirSearch->SetSearchPreference(aSearchPrefs,
                                             ARRAYLEN(aSearchPrefs));
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Build the search filter
        //

        wstring strFilter;

        hr = ADsEncodeBinaryData((PBYTE)psid, GetLengthSid(psid), &pwzSidBlob);
        BREAK_ON_FAIL_HRESULT(hr);

        strFilter = L"(objectSid=";
        strFilter += pwzSidBlob;
        strFilter += L")";

        PWSTR apwzAttrs[] = { L"name" };

        Dbg(DEB_TRACE, "searching for '%ws'\n", strFilter.c_str());

        hr = pDirSearch->ExecuteSearch((PWSTR)strFilter.c_str(),
                                       apwzAttrs,
                                       ARRAYLEN(apwzAttrs),
                                       &hSearch);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pDirSearch->GetFirstRow(hSearch);
        BREAK_ON_FAIL_HRESULT(hr);

        if (hr == S_ADS_NOMORE_ROWS)
        {
            Dbg(DEB_TRACE, "No matches\n");
            break;
        }

        ADS_SEARCH_COLUMN Column;

        hr = pDirSearch->GetColumn(hSearch, apwzAttrs[0], &Column);
        BREAK_ON_FAIL_HRESULT(hr);

        strResult = Column.pADsValues[0].CaseIgnoreString;

        hr = pDirSearch->FreeColumn(&Column);
        CHECK_HRESULT(hr);
    } while (0);

    if (hSearch)
    {
        pDirSearch->CloseSearchHandle(hSearch);
    }

    if (pwzSidBlob)
    {
        FreeADsMem(pwzSidBlob);
    }

    return strResult;
}



//+--------------------------------------------------------------------------
//
//  Function:   ReplaceAllInserts
//
//  Synopsis:   Replace all inserts of the form %n with insert strings in
//              the event itself and of the form %%n with insert strings
//              in the parameter message file associated with the source in
//              the event.
//
//  Arguments:  [pelr]              - record containing insert strings
//              [pli]               - decribes log containing record
//              [wszRemoteSystemRoot] - value of SystemRoot environment var
//                                        on remote machine
//              [pshkRemoteSource]  - hkey to remote source key
//              [pshkLocalSource]   - hkey to local source key
//              [pshkPrimarySource] - hkey to primary source key
//              [psk]               - status of primary source key
//              [ppwszMsg]          - points to description string to use
//
//  Modifies:   Frees *[ppwszMsg] (using LocalFree) and replaces it with a
//              new copy (allocated with LocalAlloc) if the insertion
//              string replacement is completed without error.  In case
//              of error, or if no insertion markers are present in the
//              description, *[ppwszMsg] is untouched.
//
//  History:    2-25-1997   DavidMun   Created
//
//  Notes:      The source hkeys may be NULL.
//
//              The original log viewer arbitrarily limits the number of
//              insertion strings it will handle to 99.  This code has no
//              limit on the number of insert strings, but does limit the
//              number of insertion operations.  This allows it to safely
//              process insert strings which reference parameter strings or
//              other insert strings, and parameter strings which reference
//              other parameter strings.
//
//              If the creator of the message file or insert strings makes a
//              circular reference, this code will follow that reference
//              until it hits the limit of insertion operations, then
//              stop following that trail of insertions.
//
//              Insertion string and parameter values start at 1. Zero
//              values will not be transferred to the final string.
//
//---------------------------------------------------------------------------

VOID
ReplaceAllInserts(
    EVENTLOGRECORD *pelr,
    CLogInfo       *pli,
    LPWSTR          wszRemoteSystemRoot,
    CSafeReg       *pshkRemoteSource,
    CSafeReg       *pshkLocalSource,
    CSafeReg       *pshkPrimarySource,
    PSK             psk,
    LPWSTR         *ppwszMsg)
{
    TRACE_FUNCTION(ReplaceAllInserts);

    // JonN 3/21/01 350614
    // Use message dlls and DS, FRS and DNS log types from specified computer
    LPWSTR pwszRemoteMessageServer = pli->GetLogServerName();
    if ( pli->IsBackupLog() && *g_wszAuxMessageSource )
    {
        pwszRemoteMessageServer = g_wszAuxMessageSource;
    }

    HRESULT          hr = S_OK;
    SDescriptionStr  ds;
    SParamModule     pmRemote;
    SParamModule     pmLocal;
    SParamModule     pmPrimary;

    pmRemote.mls        = LOAD_NOT_ATTEMPTED;
    pmRemote.mt         = REMOTE;
    pmRemote.pshkSource = pshkRemoteSource;

    pmLocal.mls        = LOAD_NOT_ATTEMPTED;
    pmLocal.mt         = LOCAL;
    pmLocal.pshkSource = pshkLocalSource;

    pmPrimary.mls        = LOAD_NOT_ATTEMPTED;
    pmPrimary.mt         = PRIMARY;
    pmPrimary.pshkSource = pshkPrimarySource;

    //
    // If the message doesn't have any percent signs, it can't have any
    // insertions.
    //

    if (!wcschr(*ppwszMsg, L'%'))
    {
        return;
    }

    //
    // Give the insert strings some room initially.  Strike a compromise
    // between wasting memory and doing more reallocs than necessary.
    //

    ds.cchBuf = lstrlen(*ppwszMsg) + 1;
    ds.cchRemain = ds.cchBuf / 2; // amount extra we'll start with
    ds.cchBuf += ds.cchRemain;

    //
    // Allocate the initial buffer for the expanded string.  We'll grow it
    // with LocalReAlloc as necessary.
    //

    ds.pwszExpanded = (LPWSTR) LocalAlloc(LPTR, ds.cchBuf * sizeof(WCHAR));

    if (!ds.pwszExpanded)
    {
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return;
    }

    lstrcpy(ds.pwszExpanded, *ppwszMsg);
    ds.pwszCur = ds.pwszExpanded;

    ULONG  cInsertOps = 0;

    while (ds.pwszCur && *ds.pwszCur)
    {
        ds.pwszCur = wcschr(ds.pwszCur, L'%');

        //
        // If there are no more insertion markers in the source string,
        // we're done.
        //

        if (!ds.pwszCur)
        {
            break;
        }

        //
        // Found a possible insertion marker.  If it's followed by a
        // number, it's an insert string.  If it's followed by another
        // percent, it could be a parameter insert.
        //

        if (IsDigit(ds.pwszCur[1]))
        {
            // JonN 7/17/01 435941
            // Object with percent-sign in name messes up object access audit
            // This might fail because an inserted string itself contained
            // text which looks like an insertion parameter, such as "%20".
            // Ignore the return value and continue with further replacements.
            (void) ReplaceStringInsert(&ds, pelr);

            //
            // If we've reached the limit of insertion operations, quit.
            // This shouldn't normally happen and could indicate that
            // the insert strings or parameter strings are self referencing
            // and would create an infinite loop.
            //

            if (++cInsertOps >= MAX_INSERT_OPS)
            {
                Dbg(DEB_IWARN,
                    "ReplaceAllInserts: hit max replacements\n");
                break;
            }

            //
            // Note ds.pwszCur has not moved (unless there was an error), so
            // we will process the contents of the insertion string.
            //
        }
        else if (ds.pwszCur[1] == L'%')
        {
            //
            // Found %%.  If that is followed by a digit, it's a parameter string.
            //

            if (IsDigit(ds.pwszCur[2]))
            {
                ReplaceParameterInsert(&ds,
                                       pelr,
                                       pli,
                                       wszRemoteSystemRoot,
                                       &pmRemote,
                                       &pmLocal,
                                       &pmPrimary,
                                       &psk);

                if (++cInsertOps >= MAX_INSERT_OPS)
                {
                    break;
                }
            }
            else if (ds.pwszCur[2] == L'%' && IsDigit(ds.pwszCur[3]))
            {
                //
                // Got %%%n, where n is a number.  For compatibility with
                // old event viewer, must replace this with %%x, where x
                // is insertion string n.  If insertion string n is itself
                // a number m, this becomes %%m, which is treated as parameter
                // message number m.
                //

                //
                // JonN 1/22/02 524570
                // DavidMun made a terrible goof here!  You can't just store
                // ds.pwszCur and restore it later; ReplaceStringInsert
                // is liable to reallocate the string somewhere else!
                //
                // PWSTR pwszStartOfTriplePct = ds.pwszCur;
                int cch = static_cast<int>(ds.pwszCur - ds.pwszExpanded);
                ds.pwszCur += 2; // point at %n

                hr = ReplaceStringInsert(&ds, pelr);

                if (SUCCEEDED(hr))
                {
                    // ds.pwszCur = pwszStartOfTriplePct;
                    ds.pwszCur = ds.pwszExpanded + cch;

                    if (++cInsertOps >= MAX_INSERT_OPS)
                    {
                        break;
                    }
                }
            }
            else
            {
                //
                // Got %%x, where x is non-digit. skip first percent;
                // maybe x is % and is followed by digit.
                //

                ds.pwszCur++;
            }
        }
        else if (ds.pwszCur[1] == L'{' && ds.pwszCur[2] != L'S')
        {
            // Parameters of form %{guid}, where {guid} is a string of
            // hex digits in the form returned by ::StringFromGUID2 (e.g.
            // {c200e360-38c5-11ce-ae62-08002b2b79ef}), and represents a
            // unique object in the Active Directory.
            //
            // These parameters are only found in the security event logs
            // of NT5 domain controllers.  We will attempt to map the guid
            // to the human-legible name of the DS object.  Failing to find
            // a mapping, we will leave the parameter untouched.

            // look for closing }
            PWSTR pwszEnd = wcschr(ds.pwszCur + 2, L'}');
            if (!pwszEnd)
            {
                Dbg(DEB_ERROR,
                    "ReplaceAllInserts: ignoring invalid guid insert string %s\n",
                    ds.pwszCur);
                ds.pwszCur++;
            }
            else
            {
               wstring guid(ds.pwszCur + 1, pwszEnd - (ds.pwszCur));

               // JonN 3/21/01 350614
               // Use message dlls and DS, FRS and DNS log types
               // from specified computer
               PWSTR pwszServer = pwszRemoteMessageServer;

               wstring strReplacement =
                  GetMappedGUID(
                     pwszServer ? pwszServer : GetComputerNameAsString(),
                     guid);

               if (!strReplacement.empty())
               {
                  pwszEnd++;   // now points past '}'
                  hr = ReplaceSubStr(
                     strReplacement.c_str(),
                     &ds.pwszExpanded,
                     &ds.pwszCur,
                     pwszEnd,
                     &ds.cchBuf,
                     &ds.cchRemain);
                  BREAK_ON_FAIL_HRESULT(hr);
               }
               else
               {
                  // couldn't get a replacement, so skip it.
                  ds.pwszCur = pwszEnd;
               }
            }
        }
        else if (ds.pwszCur[1] == L'{' && ds.pwszCur[2] == L'S')
        {
            //
            // Parameters of form %{S}, where S is a string-ized SID returned
            // by ConvertSidToStringSid, are converted to an object name if
            // possible.
            //

            // look for closing }
            PWSTR pwszEnd = wcschr(ds.pwszCur + 2, L'}');

            if (!pwszEnd)
            {
                Dbg(DEB_ERROR,
                    "ReplaceAllInserts: ignoring invalid SID insert string %s.  See Kumar.\n",
                    ds.pwszCur);
                ds.pwszCur++;
            }
            else
            {
               wstring strSID(ds.pwszCur + 2, pwszEnd - (ds.pwszCur) - 2);
               wstring strReplacement;
               PSID    psid = NULL;

               BOOL fOk = ConvertStringSidToSid(strSID.c_str(), &psid);

               if (!fOk)
               {
                   DBG_OUT_LASTERROR;
                   ds.pwszCur = pwszEnd;
                   continue;
               }

               // JonN 3/21/01 350614
               // Use message dlls and DS, FRS and DNS log types
               // from specified computer
               strReplacement = GetMappedSID(GetComputerStr(pelr),
                                             pwszRemoteMessageServer,
                                             psid);


               LocalFree(psid);
               psid = NULL;

               if (!strReplacement.empty())
               {
                  pwszEnd++;   // now points past '}'
                  hr = ReplaceSubStr(
                     strReplacement.c_str(),
                     &ds.pwszExpanded,
                     &ds.pwszCur,
                     pwszEnd,
                     &ds.cchBuf,
                     &ds.cchRemain);
                  BREAK_ON_FAIL_HRESULT(hr);
               }
               else
               {
                  // couldn't get a replacement, so skip it.
                  ds.pwszCur = pwszEnd;
               }
            }

        }
        else
        {
            //
            // Found %x where x is neither a % nor a digit.  Just keep moving.
            //

            ds.pwszCur++;
        }
    }

    if (ds.pwszExpanded)
    {
        ASSERT(wcslen(ds.pwszExpanded) < ds.cchBuf);
        ASSERT((LONG)ds.cchRemain >= 0L);

        LocalFree(*ppwszMsg);
        *ppwszMsg = ds.pwszExpanded;
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   ReplaceStringInsert
//
//  Synopsis:   Replace the string insert (%n, where n is a number) at
//              [pds.pwszCur] with insert string number n from the event
//              log record [pelr].
//
//  Arguments:  [pds]  - contains information about string with insert
//                        escape
//              [pelr] - event record that contains insert strings
//
//  Modifies:   Values in [pds]
//
//  History:    01-20-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
ReplaceStringInsert(
    SDescriptionStr *pds,
    EVENTLOGRECORD  *pelr)
{
    HRESULT hr = S_OK;
    LPWSTR  pwszEnd = NULL;
    ULONG   idxInsertStr = wcstoul(pds->pwszCur + 1, &pwszEnd, 10);

    ASSERT(pwszEnd);

    if (idxInsertStr && idxInsertStr <= pelr->NumStrings)
    {
        LPWSTR  pwszInsertStr = GetInsertStr(pelr, idxInsertStr - 1);

        Dbg(DEB_ITRACE,
            "Replacing %%%u with %u length string\n",
            idxInsertStr,
            lstrlen(pwszInsertStr));

        hr = ReplaceSubStr(pwszInsertStr,
                           &pds->pwszExpanded,
                           &pds->pwszCur,
                           pwszEnd,
                           &pds->cchBuf,
                           &pds->cchRemain);
        CHECK_HRESULT(hr);
    }
    else
    {
        Dbg(DEB_ERROR,
            "ignoring invalid insert string index %u\n",
            idxInsertStr);
        pds->pwszCur++; // move past %
        hr = E_INVALIDARG;
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   ReplaceParameterInsert
//
//  Synopsis:   Replace the parameter insert (double percent sign number) at
//              [pds.pwszCur] with a string loaded from a parameter message
//              file module.
//
//  Arguments:  [pds]                 - contains information about string
//                                       with parameter insert
//              [pelr]                - event record that the description
//                                       string is being built for
//              [pli]                 - describes log in which [pelr] lives
//              [wszRemoteSystemRoot] - for remote log, %SystemRoot% value
//                                       of its machine
//              [ppmRemote]           - describes remote parameter module
//              [ppmLocal]            - describes local parameter module
//              [ppmPrimary]          - describes primary parameter module
//              [pPSK]                - describes [ppmPrimary->pshkSource]
//
//  Modifies:   Values in [pds], [ppmRemote], [ppmLocal], and [ppmPrimary]
//
//  History:    3-06-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
ReplaceParameterInsert(
    SDescriptionStr *pds,
    EVENTLOGRECORD  *pelr,
    CLogInfo        *pli,
    LPWSTR          wszRemoteSystemRoot,
    SParamModule    *ppmRemote,
    SParamModule    *ppmLocal,
    SParamModule    *ppmPrimary,
    PSK             *pPSK)
{
    LPWSTR pwszEnd;
    ULONG idxParameterStr = wcstoul(pds->pwszCur + 2, &pwszEnd, 10);
    ASSERT(pwszEnd);

    // JonN 3/21/01 350614
    // Use message dlls and DS, FRS and DNS log types from specified computer
    LPWSTR pwszRemoteMessageServer = pli->GetLogServerName();
    if ( pli->IsBackupLog() && *g_wszAuxMessageSource )
    {
        pwszRemoteMessageServer = g_wszAuxMessageSource;
    }

    BOOL   fRemote = pwszRemoteMessageServer != NULL;

    // JonN 10/12/01 Allow "%%0"
    if (!idxParameterStr && (L'0' != *(pds->pwszCur + 2)))
    {
        Dbg(DEB_ERROR,
            "ReplaceParameterInsert: Skipping invalid parameter index 0\n");
        pds->pwszCur++;
        return;
    }

    LPWSTR pwszParameter = NULL;

    ULONG  flFmtMsgFlags = FORMAT_MESSAGE_FROM_HMODULE      |
                           FORMAT_MESSAGE_IGNORE_INSERTS    |
                           FORMAT_MESSAGE_ALLOCATE_BUFFER   |
                           FORMAT_MESSAGE_MAX_WIDTH_MASK;

    //
    // Demand load the parameter message file modules in this order: remote,
    // local, primary.
    //

    WCHAR wszRemoteParamMsgFilePath[MAX_PATH + 1] = L"";

    if (fRemote && ppmRemote->mls == LOAD_NOT_ATTEMPTED)
    {
        ASSERT(!(HINSTANCE)ppmRemote->schModule);

        //
        // If caller was unable to determine the value of the remote system's
        // SystemRoot environment variable, or if it was unable to open the
        // registry key on the remote machine for the event source used by
        // pelr, then it will not be possible to determine the UNC of the
        // parameter message file module, so consider it a failed load.
        //
        // Otherwise attempt to get the UNC and do a LoadLibrary on it.
        //

        if (!*wszRemoteSystemRoot || !(HKEY)*ppmRemote->pshkSource)
        {
            ppmRemote->mls = LOAD_FAILED;
        }
        else
        {
            ppmRemote->mls = LoadRemoteParamModule(pwszRemoteMessageServer,
                                                   ppmRemote->pshkSource,
                                                   wszRemoteSystemRoot,
                                                   wszRemoteParamMsgFilePath,
                                                   ARRAYLEN(wszRemoteParamMsgFilePath),
                                                   &ppmRemote->schModule);
        }
    }

    //
    // If the log is remote and we loaded the remote parameter message file,
    // see if we can extract the parameter value from it.
    //

    if (fRemote && ppmRemote->mls == LOAD_SUCCEEDED)
    {
        FormatMessage(flFmtMsgFlags,
                     (LPCVOID) (HINSTANCE) ppmRemote->schModule,
                     idxParameterStr,
                     0,
                     (LPWSTR) &pwszParameter,
                     FMT_MSG_MIN_ALLOC,
                     NULL);

        if (!pwszParameter)
        {
            //
            // Parameter value not in remote file; we'll continue to try
            // to get a value.
            //

            DBG_OUT_LASTERROR;
        }
        else
        {
            Dbg(DEB_ITRACE,
                "Replacing %%%%%u with remote parameter '%s'\n",
                idxParameterStr,
                pwszParameter);
        }
    }

    //
    // If the parameter value hasn't been found yet (remote load failed or
    // not remote or message not in remote file) try the local.  If its
    // module hasn't been loaded yet, attempt to do so.
    //

    HRESULT hr;
    WCHAR   wszLocalParamMsgFilePath[MAX_PATH + 1] = L"";

    if (!pwszParameter && ppmLocal->mls == LOAD_NOT_ATTEMPTED)
    {
        if ((HKEY)*ppmLocal->pshkSource)
        {
            hr = ppmLocal->pshkSource->QueryPath(PARAM_MSG_FILE_VALUE,
                                                 wszLocalParamMsgFilePath,
                                                 ARRAYLEN(wszLocalParamMsgFilePath),
                                                 TRUE);

            if (SUCCEEDED(hr))
            {
                hr = g_DllCache.Fetch(wszLocalParamMsgFilePath, &ppmLocal->schModule);

                if (SUCCEEDED(hr))
                {
                    ppmLocal->mls = LOAD_SUCCEEDED;
                }
                else
                {
                    ppmLocal->mls = LOAD_FAILED;
                }
            }
            else
            {
                ppmLocal->mls = LOAD_FAILED;
            }
        }
        else
        {
            ppmLocal->mls = LOAD_FAILED;
        }
    }

    if (!pwszParameter && ppmLocal->mls == LOAD_SUCCEEDED)
    {
        FormatMessage(flFmtMsgFlags,
                     (LPCVOID) (HINSTANCE) ppmLocal->schModule,
                     idxParameterStr,
                     0,
                     (LPWSTR) &pwszParameter,
                     FMT_MSG_MIN_ALLOC,
                     NULL);

        if (!pwszParameter)
        {
            DBG_OUT_LASTERROR;
        }
        else
        {
            Dbg(DEB_ITRACE,
                "Replacing %%%%%u with local parameter '%s'\n",
                idxParameterStr,
                pwszParameter);
        }
    }

    //
    // If the parameter wasn't obtained from a remote or local message file,
    // see if there is a primary module to load from.
    //

    WCHAR   wszPrimaryParamMsgFilePath[MAX_PATH + 1] = L"";

    if (!pwszParameter && ppmPrimary->mls == LOAD_NOT_ATTEMPTED)
    {
        //
        // The primary module has a little twist: unlike the remote and
        // local cases, if the primary source key is null it can be
        // because the primary source was never used.
        //
        // If this is so first try and open the primary source key.
        //

        if (*pPSK == PSK_NOT_EXAMINED)
        {
            *pPSK = OpenPrimarySourceKey(pli->GetPrimarySourceStr(),
                                         GetSourceStr(pelr),
                                         pli->GetLogName(),
                                         ppmPrimary->pshkSource);
        }

        //
        // If ppmPrimary->pshkSource is valid, we can now attempt to
        // load the primary module.
        //

        if (*pPSK == PSK_VALID)
        {
            hr = ppmPrimary->pshkSource->QueryPath(PARAM_MSG_FILE_VALUE,
                                                   wszPrimaryParamMsgFilePath,
                                                   ARRAYLEN(wszPrimaryParamMsgFilePath),
                                                   TRUE);

            if (SUCCEEDED(hr))
            {
                hr = g_DllCache.Fetch(wszPrimaryParamMsgFilePath,
                                      &ppmPrimary->schModule);

                if (SUCCEEDED(hr))
                {
                    ppmPrimary->mls = LOAD_SUCCEEDED;
                }
                else
                {
                   ppmPrimary->mls = LOAD_FAILED;
                }
            }
            else
            {
                ppmPrimary->mls = LOAD_FAILED;
            }
        }
        else
        {
            ppmPrimary->mls = LOAD_FAILED;
        }
    }

    if (!pwszParameter && ppmPrimary->mls == LOAD_SUCCEEDED)
    {
        FormatMessage(flFmtMsgFlags,
                     (LPCVOID) (HINSTANCE) ppmPrimary->schModule,
                     idxParameterStr,
                     0,
                     (LPWSTR) &pwszParameter,
                     FMT_MSG_MIN_ALLOC,
                     NULL);

        if (!pwszParameter)
        {
            DBG_OUT_LASTERROR;
        }
        else
        {
            Dbg(DEB_ITRACE,
                "Replacing %%%%%u with primary parameter '%s'\n",
                idxParameterStr,
                pwszParameter);
        }
    }

    //
    // It is common practice to write events with an insertion string whose
    // value is %%n, where n is a win32 error code, and to specify a
    // parameter message file of kernel32.dll.  Unfortunately, kernel32.dll
    // doesn't contain messages for all win32 error codes.
    //
    // So if the parameter wasn't found, and the parameter message file was
    // kernel32.dll, attempt a format message from system.
    //

    if (!pwszParameter &&
        (wcsistr(wszRemoteParamMsgFilePath, KERNEL32_DLL) ||
         wcsistr(wszLocalParamMsgFilePath, KERNEL32_DLL) ||
         wcsistr(wszPrimaryParamMsgFilePath, KERNEL32_DLL)))
    {
        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
                      | FORMAT_MESSAGE_IGNORE_INSERTS
                      | FORMAT_MESSAGE_ALLOCATE_BUFFER
                      | FORMAT_MESSAGE_MAX_WIDTH_MASK,
                     NULL,
                     idxParameterStr,
                     0,
                     (LPWSTR) &pwszParameter,
                     FMT_MSG_MIN_ALLOC,
                     NULL);

        if (!pwszParameter)
        {
            DBG_OUT_LASTERROR;
        }
        else
        {
            Dbg(DEB_ITRACE,
                "Replacing %%%%%u with system string '%s'\n",
                idxParameterStr,
                pwszParameter);
        }
    }

    if (pwszParameter)
    {
        ReplaceSubStr(pwszParameter,
                      &pds->pwszExpanded,
                      &pds->pwszCur,
                      pwszEnd,
                      &pds->cchBuf,
                      &pds->cchRemain);
        LocalFree(pwszParameter);
    }
    else
    {
        pds->pwszCur = pwszEnd; // move past whole parameter
    }
}


//+--------------------------------------------------------------------------
//
//  Function:   ReplaceSubStr
//
//  Synopsis:   Replace the characters from *[ppwszInsertPoint] to just
//              before [pwszSubStrEnd] with the string [pwszToInsert].
//
//  Arguments:  [pwszToInsert]     - string to insert; may be L"" but not
//                                      NULL.
//              [ppwszBuf]         - buffer in which insertion occurs
//              [ppwszInsertPoint] - point in *[ppwszBuf] to insert
//              [pwszSubStrEnd]    - first character beyond
//                                      *[ppwszInsertPoint] which should not
//                                      be deleted.
//              [pcchBuf]          - total size, in WCHARs, of *[ppwszBuf]
//              [pcchRemain]       - unused space, in WCHARs, in *[ppwszBuf]
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//
//  Modifies:   [ppwszBuf], [ppwszInsertPoint], [pcchBuf], [pcchRemain]
//
//  History:    2-27-1997   DavidMun   Created
//
//  Notes:      The substring to be replaced must be > 0 chars in length.
//
//              The replacement string can be >= 0 chars.
//
//              Therefore if the substring to replace is "%%12" and the
//              string to insert is "C:", on exit *[pcchRemain] will have
//              been incremented by 2.
//
//              If there are insufficient characters remaining to replace
//              the substring with the insert string, reallocates the
//              buffer.
//
//---------------------------------------------------------------------------

HRESULT
ReplaceSubStr(
    LPCWSTR pwszToInsert,
    LPWSTR *ppwszBuf,
    LPWSTR *ppwszInsertPoint,
    LPCWSTR pwszSubStrEnd,
    ULONG  *pcchBuf,
    ULONG  *pcchRemain)
{
    TRACE_FUNCTION(ReplaceSubStr);
    ASSERT(pwszSubStrEnd > *ppwszInsertPoint);
    ASSERT(pwszSubStrEnd < *ppwszBuf + *pcchBuf);

    size_t cchToDelete = pwszSubStrEnd - *ppwszInsertPoint;
    ULONG cchToInsert = lstrlen(pwszToInsert);

    Dbg(DEB_ITRACE, "cchToDelete = %u\n", cchToDelete);
    Dbg(DEB_ITRACE, "cchToInsert = %u\n", cchToInsert);
    Dbg(DEB_ITRACE, "cchBuf = %u\n", *pcchBuf);
    Dbg(DEB_ITRACE, "cchRemain = %u\n", *pcchRemain);

    //
    // Grow the string buffer if necessary.
    //

    if (cchToInsert > *pcchRemain + cchToDelete)
    {
        LPWSTR pwszNew;

        Dbg(DEB_ITRACE,
            "Allocating %u wchars for new buffer\n",
            (*pcchBuf + 2 * (cchToInsert - cchToDelete)));

        pwszNew = (LPWSTR) LocalAlloc(LPTR,
                                      sizeof(WCHAR) *
                                            (*pcchBuf +
                                             2 *
                                             (cchToInsert - cchToDelete)));

        if (!pwszNew)
        {
            Dbg(DEB_ERROR, "Can't alloc %uL bytes\n",
                sizeof(WCHAR) * (*pcchBuf + 2 * (cchToInsert - cchToDelete)));
            DBG_OUT_HRESULT(E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }

        *ppwszInsertPoint = pwszNew + (*ppwszInsertPoint - *ppwszBuf);
        pwszSubStrEnd = pwszNew + (pwszSubStrEnd - *ppwszBuf);
        lstrcpy(pwszNew, *ppwszBuf);
        LocalFree(*ppwszBuf);

        *ppwszBuf = pwszNew;
        *pcchBuf += static_cast<ULONG>(2 * (cchToInsert - cchToDelete));
        *pcchRemain += static_cast<ULONG>(2 * (cchToInsert - cchToDelete));
    }

    //
    // Adjust the space between the insert point and the start of the
    // remainder of the string after the substring to delete so that
    // it exactly matches the length of the string to insert.
    //
    // Note that this may mean moving left or right, or if the length of
    // the string to insert is the same as the length of the substring,
    // not at all.
    //
    // Notice also the null terminator is included in the move.
    //

    ASSERT(*ppwszInsertPoint + cchToInsert + lstrlen(pwszSubStrEnd) + 1 <=
           *ppwszBuf + *pcchBuf);

    if (*ppwszInsertPoint + cchToInsert != pwszSubStrEnd)
    {
        MoveMemory(*ppwszInsertPoint + cchToInsert,
                   pwszSubStrEnd,
                   sizeof(WCHAR) * (lstrlen(pwszSubStrEnd) + 1));
    }

    ASSERT((ULONG) lstrlen(*ppwszBuf) < *pcchBuf);

    //
    // Overwrite the memory at the insertion point with the string to
    // insert, less its null terminator.
    //

    if (cchToInsert)
    {
        CopyMemory(*ppwszInsertPoint,
                   pwszToInsert,
                   sizeof(WCHAR) * cchToInsert);
    }

    //
    // Keep track of the space consumed (or made available) in the buffer.
    //

    *pcchRemain = static_cast<ULONG>(*pcchRemain - cchToInsert + cchToDelete);
    ASSERT((LONG) *pcchRemain >= 0);
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Function:   TerminatePathStrings
//
//  Synopsis:   Change delimiters into null characters and return a count
//              of the number of resulting non-empty strings.
//
//  Arguments:  [pwszUnexpanded] -
//
//  Returns:    Count of strings ("a;b;c" and "a;;b;c" both give 3)
//
//  Modifies:   *[pwszUnexpanded]
//
//  History:    2-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
TerminatePathStrings(
    LPWSTR pwszUnexpanded)
{
    TRACE_FUNCTION(TerminatePathStrings);

    //
    // If the multi-sz string is empty, just return quickly
    //

    if (!*pwszUnexpanded)
    {
        return 0;
    }

    //
    // Since the string isn't empty, it is considered (by this routine) to
    // have at least one path.
    //

    LPWSTR pwszCurDelim;
    ULONG  cPaths = 1;

    for (pwszCurDelim = wcspbrk(pwszUnexpanded, EVENT_MSGFILE_DELIMETERS);
         pwszCurDelim;
         pwszCurDelim = wcspbrk(pwszCurDelim, EVENT_MSGFILE_DELIMETERS))
    {
        //
        // As long as this is not a leading delimiter, increment the count
        // of paths found.
        //

        if (pwszCurDelim > pwszUnexpanded)
        {
            cPaths++;
        }

        //
        // Null terminate at the current and all trailing delimiters for
        // the current path.
        //

        while (wcschr(EVENT_MSGFILE_DELIMETERS, *pwszCurDelim))
        {
            *pwszCurDelim++ = L'\0';
        }
    }
    return cPaths;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\filter.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       filter.cxx
//
//  Contents:   Filter property sheet page.
//
//  Classes:    CFilterPage
//
//  History:    12-19-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#define MAX_STATIC_TEXT_STRING  MAX_PATH

DEBUG_DECLARE_INSTANCE_COUNTER(CFilter)
DEBUG_DECLARE_INSTANCE_COUNTER(CFilterPage)

static ULONG
s_aulHelpIds[] =
{
    filter_from_lbl,            Hfilter_from_lbl,
    filter_from_combo,          Hfilter_from_combo,
    filter_from_date_dp,        Hfilter_from_date_dp,
    filter_from_time_dp,        Hfilter_from_time_dp,
    filter_to_lbl,              Hfilter_to_lbl,
    filter_to_combo,            Hfilter_to_combo,
    filter_to_date_dp,          Hfilter_to_date_dp,
    filter_to_time_dp,          Hfilter_to_time_dp,
    filter_types_grp,           Hfilter_types_grp,
    filter_information_ckbox,   Hfilter_information_ckbox,
    filter_warning_ckbox,       Hfilter_warning_ckbox,
    filter_error_ckbox,         Hfilter_error_ckbox,
    filter_success_ckbox,       Hfilter_success_ckbox,
    filter_failure_ckbox,       Hfilter_failure_ckbox,
    filter_source_lbl,          Hfilter_source_lbl,
    filter_source_combo,        Hfilter_source_combo,
    filter_category_lbl,        Hfilter_category_lbl,
    filter_category_combo,      Hfilter_category_combo,
    filter_user_lbl,            Hfilter_user_lbl,
    filter_user_edit,           Hfilter_user_edit,
    filter_computer_lbl,        Hfilter_computer_lbl,
    filter_computer_edit,       Hfilter_computer_edit,
    filter_eventid_lbl,         Hfilter_eventid_lbl,
    filter_eventid_edit,        Hfilter_eventid_edit,
    filter_clear_pb,            Hfilter_clear_pb,
    filter_view_lbl,            Hfilter_view_lbl,
    0,0
};


//===========================================================================
//
// CFilter implementation
//
//===========================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CFilter::CFilter
//
//  Synopsis:   ctor
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CFilter::CFilter()
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CFilter);
    Reset();
}



//+--------------------------------------------------------------------------
//
//  Member:     CFilter::CFilter
//
//  Synopsis:   copy ctor
//
//  History:    5-25-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CFilter::CFilter(
    const CFilter &ToCopy):
        _ulFrom(ToCopy._ulFrom),
        _ulTo(ToCopy._ulTo)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CFilter);

    _ulType             = ToCopy._ulType;
    _usCategory         = ToCopy._usCategory;
    _fEventIDSpecified  = ToCopy._fEventIDSpecified;
    _ulEventID          = ToCopy._ulEventID;

    lstrcpy(_wszSource,   ToCopy._wszSource);
    lstrcpy(_wszUser,     ToCopy._wszUser);
    lstrcpy(_wszUserLC,   ToCopy._wszUserLC);
    lstrcpy(_wszComputer, ToCopy._wszComputer);
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilter::~CFilter
//
//  Synopsis:   dtor
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CFilter::~CFilter()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CFilter);
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilter::Load
//
//  Synopsis:   Initialize from stream.
//
//  Arguments:  [pStm] - stream opened for reading
//
//  Returns:    HRESULT
//
//  History:    3-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CFilter::Load(
    IStream *pStm)
{
    HRESULT hr = S_OK;

    do
    {
        ALIGN_PTR(pStm, __alignof(ULONG));
        hr = pStm->Read(&_ulType, sizeof _ulType, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(USHORT));
        pStm->Read(&_usCategory, sizeof _usCategory, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(BOOL));
        pStm->Read(&_fEventIDSpecified, sizeof _fEventIDSpecified, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(ULONG));
        pStm->Read(&_ulEventID, sizeof _ulEventID, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(WCHAR));
        hr = ReadString(pStm, _wszSource, ARRAYLEN(_wszSource));
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(WCHAR));
        hr = ReadString(pStm, _wszUser, ARRAYLEN(_wszUser));
        BREAK_ON_FAIL_HRESULT(hr);

        lstrcpy(_wszUserLC, _wszUser);
        CharLowerBuff(_wszUserLC, lstrlen(_wszUserLC));

        ALIGN_PTR(pStm, __alignof(WCHAR));
        hr = ReadString(pStm, _wszComputer, ARRAYLEN(_wszComputer));
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(ULONG));
        hr = pStm->Read(&_ulFrom, sizeof _ulFrom, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(ULONG));
        hr = pStm->Read(&_ulTo, sizeof _ulTo, NULL);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilter::Save
//
//  Synopsis:   Persist this object in the stream [pStm].
//
//  Arguments:  [pStm] - stream opened for writing
//
//  Returns:    HRESULT
//
//  History:    3-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CFilter::Save(
    IStream *pStm)
{
    HRESULT hr = S_OK;

    do
    {
        ALIGN_PTR(pStm, __alignof(ULONG));
        hr = pStm->Write(&_ulType, sizeof _ulType, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(USHORT));
        pStm->Write(&_usCategory, sizeof _usCategory, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(BOOL));
        pStm->Write(&_fEventIDSpecified, sizeof _fEventIDSpecified, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(ULONG));
        pStm->Write(&_ulEventID, sizeof _ulEventID, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(WCHAR));
        hr = WriteString(pStm, _wszSource);
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(WCHAR));
        hr = WriteString(pStm, _wszUser);
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(WCHAR));
        hr = WriteString(pStm, _wszComputer);
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(ULONG));
        hr = pStm->Write(&_ulFrom, sizeof _ulFrom, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(ULONG));
        hr = pStm->Write(&_ulTo, sizeof _ulTo, NULL);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilter::Passes
//
//  Synopsis:   Return TRUE if [pelr] meets the restrictions set by this
//              filter.
//
//  Arguments:  [pResultRecs] - positioned at record to check
//
//  Returns:    TRUE or FALSE
//
//  History:    1-11-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CFilter::Passes(
    CFFProvider *pFFP)
{
    //
    // For better performance, do the quicker comparisons first in
    // hopes of rejecting a record before the string comparisons have
    // to be done.
    //
    // Start with items specific to filtering.
    //

    if (FromSpecified())
    {
        if (pFFP->GetTimeGenerated() < _ulFrom)
        {
            return FALSE;
        }
    }

    if (ToSpecified())
    {
        if (pFFP->GetTimeGenerated() > _ulTo)
        {
            return FALSE;
        }
    }

    //
    // Check the items common to both filter and find
    //

    return CFindFilterBase::Passes(pFFP);
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilter::GetFrom
//
//  Synopsis:   Return filter from date in [pst].
//
//  Arguments:  [pst] - filled with from date, if any.
//
//  Returns:    S_FALSE - not being filtered by from date
//              S_OK    - [pst] contains filtered by from date value
//
//  Modifies:   *[pst]
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CFilter::GetFrom(
    SYSTEMTIME *pst)
{
    if (!_ulFrom)
    {
        return S_FALSE;
    }

    SecondsSince1970ToSystemTime(_ulFrom, pst);
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilter::GetTo
//
//  Synopsis:   Return filter to date in [pst].
//
//  Arguments:  [pst] - filled with to date, if any.
//
//  Returns:    S_FALSE - not being filtered by to date
//              S_OK    - [pst] contains filtered by to date value
//
//  Modifies:   *[pst]
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CFilter::GetTo(
    SYSTEMTIME *pst)
{
    if (!_ulTo)
    {
        return S_FALSE;
    }

    SecondsSince1970ToSystemTime(_ulTo, pst);
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilter::SetFrom
//
//  Synopsis:   Set the filter from date to [pst].
//
//  Arguments:  [pst] - valid date, or NULL to turn off from date filtering
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CFilter::SetFrom(
    SYSTEMTIME *pst)
{
    if (pst)
    {
        SystemTimeToSecondsSince1970(pst, &_ulFrom);
    }
    else
    {
        _ulFrom = 0;
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CFilter::SetFrom
//
//  Synopsis:   Set the filter to date to [pst].
//
//  Arguments:  [pst] - valid date, or NULL to turn off to date filtering
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CFilter::SetTo(
    SYSTEMTIME *pst)
{
    if (pst)
    {
        SystemTimeToSecondsSince1970(pst, &_ulTo);
    }
    else
    {
        _ulTo = 0;
    }
}


//+--------------------------------------------------------------------------
//
//  Member:     CFilter::Reset
//
//  Synopsis:   Clear all filtering (set members so that any event record
//              would pass this filter).
//
//  History:    1-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CFilter::Reset()
{
    CFindFilterBase::_Reset();
    _ulFrom = 0;
    _ulTo   = 0;
}


//===========================================================================
//
// CFilterPage implementation
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CFilterPage::CFilterPage
//
//  Synopsis:   ctor
//
//  History:    3-27-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CFilterPage::CFilterPage(
    IStream *pstm,
    CLogInfo *pli):
        _pstm(pstm),
        _pnpa(NULL),
        _pli(pli)
{
    TRACE_CONSTRUCTOR(CFilterPage);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CFilterPage);
    ASSERT(_pstm);
    ASSERT(_pli);

    //
    // Do not unmarshal the stream here; see comments in CGeneralPage ctor
    //
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterPage::~CFilterPage
//
//  Synopsis:   dtor
//
//  History:    3-27-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CFilterPage::~CFilterPage()
{
    TRACE_DESTRUCTOR(CFilterPage);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CFilterPage);

    if (_pstm)
    {
        PVOID pvnpa;
        HRESULT hr;

        hr = CoGetInterfaceAndReleaseStream(_pstm,
                                            IID_INamespacePrshtActions,
                                            &pvnpa);
        CHECK_HRESULT(hr);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterPage::_EnableDateTime
//
//  Synopsis:   Enable or disable the specified date and time datepicker
//              controls.
//
//  Arguments:  [FromOrTo] - FROM or TO, to indicate which set of controls
//              [fEnable]  - TRUE to enable, FALSE to disable
//
//  History:    1-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CFilterPage::_EnableDateTime(
    FROMTO FromOrTo,
    BOOL fEnable)
{
    // JonN 12/04/01 500639
    int iDate = (FromOrTo == FROM) ? filter_from_date_dp : filter_to_date_dp;
    int iTime = (FromOrTo == FROM) ? filter_from_time_dp : filter_to_time_dp;
    HWND hwndFocus = ::GetFocus();
    if (_hCtrl(iDate) == hwndFocus || _hCtrl(iTime) == hwndFocus)
    {
        ::SetFocus(_hCtrl( (FromOrTo == FROM) ? filter_from_combo
                                              : filter_to_combo)  );
    }
    EnableWindow(_hCtrl(iDate), fEnable);
    EnableWindow(_hCtrl(iTime), fEnable);
}




VOID
CFilterPage::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    InvokeWinHelp(message, wParam, lParam, HELP_FILENAME, s_aulHelpIds);
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterPage::_OnInit
//
//  Synopsis:   Initialize the controls in the property sheet page.
//
//  Arguments:  [pPSP] - pointer to prop sheet page structure used to
//                       create this.
//
//  History:    1-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CFilterPage::_OnInit(
    LPPROPSHEETPAGE pPSP)
{
    TRACE_METHOD(CFilterPage, _OnInit);

    //
    // Unmarshal the private interface
    //

    //
    // Unmarshal the private interface to the CComponentData object
    //

    PVOID pvnpa;
    HRESULT hr;

    hr = CoGetInterfaceAndReleaseStream(_pstm,
                                        IID_INamespacePrshtActions,
                                        &pvnpa);
    _pstm = NULL;

    if (SUCCEEDED(hr))
    {
        _pnpa = (INamespacePrshtActions *)pvnpa;
    }
    else
    {
        DBG_OUT_HRESULT(hr);
    }

    //
    // Tell the cookie that there is a property page open on it
    //

    _pli->SetPropSheetWindow(_hwnd);

    WCHAR wszInitStr[MAX_STATIC_TEXT_STRING];

    //
    // Stuff the comboboxes for view from/to.  Note these comboboxes
    // do not have the CBS_SORT style, so, regardless of the locale,
    // the "Events On" string will always be the second string in
    // both comboboxes.
    //

    LoadStr(IDS_FIRST_EVENT, wszInitStr, ARRAYLEN(wszInitStr));
    ComboBox_AddString(_hCtrl(filter_from_combo), wszInitStr);

    LoadStr(IDS_LAST_EVENT, wszInitStr, ARRAYLEN(wszInitStr));
    ComboBox_AddString(_hCtrl(filter_to_combo), wszInitStr);

    LoadStr(IDS_EVENTS_ON, wszInitStr, ARRAYLEN(wszInitStr));
    ComboBox_AddString(_hCtrl(filter_from_combo), wszInitStr);
    ComboBox_AddString(_hCtrl(filter_to_combo), wszInitStr);

   SYSTEMTIME times[2];
   memset(times, 0, sizeof(times));
   times[0].wYear = 1970;
   times[0].wMonth = 1; // January
   times[0].wDay = 1;
   times[1].wYear = 2105;
   times[1].wMonth = 1; // January
   times[1].wDay = 1;

   VERIFY(
      DateTime_SetRange(
         _hCtrl(filter_from_date_dp),
         GDTR_MIN | GDTR_MAX,
         times));
   VERIFY(
      DateTime_SetRange(
         _hCtrl(filter_from_time_dp),
         GDTR_MIN | GDTR_MAX,
         times));
   VERIFY(
      DateTime_SetRange(
         _hCtrl(filter_to_date_dp),
         GDTR_MIN | GDTR_MAX,
         times));
   VERIFY(
      DateTime_SetRange(
         _hCtrl(filter_to_time_dp),
         GDTR_MIN | GDTR_MAX,
         times));

    //
    // Set the From/To date/time controls
    //

    SYSTEMTIME st;
    CFilter *pFilter = _pli->GetFilter();

    hr = pFilter->GetFrom(&st);

    if (S_FALSE == hr)
    {
        _SetFromTo(FROM, NULL);
    }
    else
    {
        _SetFromTo(FROM, &st);
    }

    hr = pFilter->GetTo(&st);

    if (S_FALSE == hr)
    {
        _SetFromTo(TO, NULL);
    }
    else
    {
        _SetFromTo(TO, &st);
    }

    InitFindOrFilterDlg(_hwnd, _pli->GetSources(), pFilter);
}



void
CFilterPage::_OnSettingChange(WPARAM wParam, LPARAM lParam)
{
   ::SendMessage(_hCtrl(filter_to_date_dp), WM_SETTINGCHANGE, wParam, lParam);
   ::SendMessage(_hCtrl(filter_to_time_dp), WM_SETTINGCHANGE, wParam, lParam);
   ::SendMessage(_hCtrl(filter_from_date_dp), WM_SETTINGCHANGE, wParam, lParam);
   ::SendMessage(_hCtrl(filter_from_time_dp), WM_SETTINGCHANGE, wParam, lParam);
}



//+--------------------------------------------------------------------------
//
//  Member:     CFilterPage::_OnSetActive
//
//  Synopsis:   Handle notification that this property page is becoming
//              active (visible).
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CFilterPage::_OnSetActive()
{
    TRACE_METHOD(CFilterPage, _OnSetActive);
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterPage::_OnApply
//
//  Synopsis:   Save settings if valid, otherwise complain and prevent page
//              from changing.
//
//  Returns:    PSNRET_NOERROR or PSNRET_INVALID_NOCHANGEPAGE
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CFilterPage::_OnApply()
{
    TRACE_METHOD(CFilterPage, _OnApply);
    ULONG ulRet = PSNRET_NOERROR;


    if (!_IsFlagSet(PAGE_IS_DIRTY))
    {
        Dbg(DEB_TRACE, "CFilterPage: page not dirty; ignoring Apply\n");
        return PSNRET_NOERROR;
    }

    _pli->Filter(TRUE);
    CFilter *pFilter = _pli->GetFilter();

    BOOL fOk = ReadFindOrFilterValues(_hwnd, _pli->GetSources(), pFilter);

    if (fOk)
    {
        _ClearFlag(PAGE_IS_DIRTY);

        //
        // If the log we're filtering is currently being displayed, then it
        // should be redisplayed.  Ping the snapins so they can check.
        //

        g_SynchWnd.Post(ELSM_LOG_DATA_CHANGED,
                        LDC_FILTER_CHANGE,
                        reinterpret_cast<LPARAM>(_pli));
    }
    else
    {
        // JonN 4/12/01 367216
        // MsgBox(_hwnd, IDS_INVALID_EVENTID, MB_TOPMOST | MB_ICONERROR | MB_OK);
        ulRet = PSNRET_INVALID_NOCHANGEPAGE;
    }

    return ulRet;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterPage::_Validate
//
//  Synopsis:   Return TRUE if all settings on the page are valid, FALSE
//              otherwise.
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CFilterPage::_Validate()
{
    if (!_IsFlagSet(PAGE_IS_DIRTY))
    {
        return TRUE;
    }

    CFilter *pFilter = _pli->GetFilter();

    //
    // Get the From/To values
    //

    if (ComboBox_GetCurSel(_hCtrl(filter_from_combo)))
    {
        SYSTEMTIME stDate;
        SYSTEMTIME st;

        DateTime_GetSystemtime(_hCtrl(filter_from_date_dp), &stDate);
        DateTime_GetSystemtime(_hCtrl(filter_from_time_dp), &st);

        st.wMonth = stDate.wMonth;
        st.wDay = stDate.wDay;
        st.wYear = stDate.wYear;
        pFilter->SetFrom(&st);
    }
    else
    {
        pFilter->SetFrom(NULL);
    }

    if (ComboBox_GetCurSel(_hCtrl(filter_to_combo)))
    {
        SYSTEMTIME stDate;
        SYSTEMTIME st;

        DateTime_GetSystemtime(_hCtrl(filter_to_date_dp), &stDate);
        DateTime_GetSystemtime(_hCtrl(filter_to_time_dp), &st);

        st.wMonth = stDate.wMonth;
        st.wDay = stDate.wDay;
        st.wYear = stDate.wYear;
        pFilter->SetTo(&st);
    }
    else
    {
        pFilter->SetTo(NULL);
    }

    //
    // Now we can do validation.
    //
    // Enforce rule that From date <= To date
    //

    if (!pFilter->FromToValid())
    {
        pFilter->SetFrom(NULL);
        pFilter->SetTo(NULL);
        MsgBox(_hwnd, MB_TOPMOST | IDS_INVALID_FROM_TO, MB_OK | MB_ICONERROR);
        return FALSE;
    }

    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterPage::_OnCommand
//
//  Synopsis:   Handle a notification that the user has touched one of the
//              controls.
//
//  Arguments:  [wParam] - identifies control
//              [lParam] - unused
//
//  Returns:    0
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CFilterPage::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CFilterPage, _OnCommand);

    switch (LOWORD(wParam))
    {
    case filter_source_combo:
    {
        if (HIWORD(wParam) != CBN_SELCHANGE)
        {
            break;
        }

        _EnableApply(TRUE);

        //
        // get source value from filter combo
        //

        HWND  hwndSourceCombo = _hCtrl(filter_source_combo);
        WCHAR wszSource[CCH_SOURCE_NAME_MAX];

        ComboBox_GetText(hwndSourceCombo, wszSource, CCH_SOURCE_NAME_MAX);

        //
        // Set category combo contents according to new source, and set
        // category filter selection to (All).
        //

        SetCategoryCombobox(_hwnd, _pli->GetSources(), wszSource, 0);

        //
        // turn off type filtering
        //

        SetTypesCheckboxes(_hwnd, _pli->GetSources(), ALL_LOG_TYPE_BITS);
        break;
    }

    case filter_from_combo:
    case filter_to_combo:
        if (HIWORD(wParam) == CBN_SELCHANGE)
        {
            _EnableApply(TRUE);
            _EnableDateTimeControls(LOWORD(wParam));
        }
        break;

    case filter_category_combo:
        if (HIWORD(wParam) == CBN_SELCHANGE)
        {
            _EnableApply(TRUE);
        }
        break;

    case filter_user_edit:
    case filter_computer_edit:
    case filter_eventid_edit:
        if (HIWORD(wParam) == EN_CHANGE)
        {
            _EnableApply(TRUE);
        }
        break;

    case filter_information_ckbox:
    case filter_warning_ckbox:
    case filter_error_ckbox:
    case filter_success_ckbox:
    case filter_failure_ckbox:
        _EnableApply(TRUE);
        break;

    case filter_clear_pb:
        _EnableApply(TRUE);
        _OnClear();
        break;
    }
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterPage::_OnClear
//
//  Synopsis:   Reset all controls to default state
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CFilterPage::_OnClear()
{
    TRACE_METHOD(CFilterPage, _OnClear);

    //
    // Set the date/time for from/to to be the first and last event
    // times in the log.
    //

    _SetFromTo(FROM, NULL);
    _SetFromTo(TO, NULL);

    //
    // Reset all the controls which are common to both find and filter
    //

    ClearFindOrFilterDlg(_hwnd, _pli->GetSources());

    //
    // Clearing the filter dirties it (this has already been done
    // because the above set commands generated notifications of
    // control changes).
    //
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterPage::_SetFromTo
//
//  Synopsis:   Set the combobox, date control, and time control of either
//              the filter from or the filter to fields.
//
//  Arguments:  [FromOrTo] - identifies which set of controls to change
//              [pst]      - NULL or date/time value to set
//
//  History:    4-25-1997   DavidMun   Created
//
//  Notes:      If [pst] is NULL, the control is set to the oldest event
//              record timestamp, if filtering FROM, or the newest time-
//              stamp, if filtering TO.
//
//---------------------------------------------------------------------------

VOID
CFilterPage::_SetFromTo(
    FROMTO FromOrTo,
    SYSTEMTIME *pst)
{
    HWND hwndCombo;
    HWND hwndDate;
    HWND hwndTime;

    if (FromOrTo == FROM)
    {
        hwndCombo = _hCtrl(filter_from_combo);
        hwndDate  = _hCtrl(filter_from_date_dp);
        hwndTime  = _hCtrl(filter_from_time_dp);
    }
    else
    {
        hwndCombo = _hCtrl(filter_to_combo);
        hwndDate  = _hCtrl(filter_to_date_dp);
        hwndTime  = _hCtrl(filter_to_time_dp);
    }

    SYSTEMTIME st;
    SYSTEMTIME *pstToUse;

    if (pst)
    {
        pstToUse = pst;
    }
    else
    {
        HRESULT    hr;

        if (FromOrTo == FROM)
        {
            hr = _pli->GetOldestTimestamp(&st);
        }
        else
        {
            hr = _pli->GetNewestTimestamp(&st);
        }

        if (FAILED(hr))
        {
            GetLocalTime(&st);
        }

        pstToUse = &st;
    }

    VERIFY(DateTime_SetSystemtime(hwndDate, GDT_VALID, pstToUse));
    VERIFY(DateTime_SetSystemtime(hwndTime, GDT_VALID, pstToUse));

    ComboBox_SetCurSel(hwndCombo, pst != NULL);
    _EnableDateTime(FromOrTo, pst != NULL);
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterPage::_OnNotify
//
//  Synopsis:   Handle control notification
//
//  Arguments:  [pnmh] - standard notification header
//
//  Returns:    0
//
//  History:    4-25-1997   DavidMun   Created
//
//  Notes:      This is only necessary to detect when the user has touched
//              the filter from/to date or time controls.
//
//---------------------------------------------------------------------------

ULONG
CFilterPage::_OnNotify(
    LPNMHDR pnmh)
{
    switch (pnmh->idFrom)
    {
    case filter_from_date_dp:
    case filter_from_time_dp:
    case filter_to_date_dp:
    case filter_to_time_dp:

        if (pnmh->code == DTN_DATETIMECHANGE)
        {
            _EnableApply(TRUE);
        }
        break;
    }
    return 0;
}





//+--------------------------------------------------------------------------
//
//  Member:     CFilterPage::_OnKillActive
//
//  Synopsis:   Return bool indicating whether it is permissible for this
//              page to no longer be the active page.
//
//  Returns:    FALSE if page contains valid data, TRUE otherwise
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CFilterPage::_OnKillActive()
{
    TRACE_METHOD(CFilterPage, _OnKillActive);

    //
    // FALSE allows page to lose focus, TRUE prevents it.
    //

    return !_Validate();
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterPage::_OnQuerySiblings
//
//  Synopsis:   Handle notification from other page.
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CFilterPage::_OnQuerySiblings(
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CFilterPage, _OnQuerySiblings);
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterPage::_OnDestroy
//
//  Synopsis:   Notify the loginfo on which this page is open that the
//              sheet is closing.
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CFilterPage::_OnDestroy()
{
    TRACE_METHOD(CFilterPage, _OnDestroy);

    //
    // Tell cookie its prop sheet is closing
    //

    _pli->SetPropSheetWindow(NULL);
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterPage::_EnableDateTimeControls
//
//  Synopsis:   Enable or disable the filter from or to date/time controls
//              according to the current selection in the combobox with
//              control id [idCombo].
//
//  Arguments:  [idCombo] - filter_from_combo or filter_to_combo.
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CFilterPage::_EnableDateTimeControls(
    ULONG idCombo)
{
    FROMTO FromOrTo;

    if (idCombo == filter_from_combo)
    {
        FromOrTo = FROM;
    }
    else
    {
        FromOrTo = TO;
    }

    //
    // If the selection is the first item, (item 0), disable the controls,
    // since it is either "first event" or "Last event".  If it is item 1,
    // enable the controls, since it is "events on".
    //

    _EnableDateTime(FromOrTo, ComboBox_GetCurSel(_hCtrl(idCombo)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\general.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       general.cxx
//
//  Contents:   Implementation of general property page class
//
//  Classes:    CGeneralPage
//
//  History:    1-14-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


#define MIN_SIZE_LIMIT                64UL
#define MAX_SIZE_LIMIT                4194240UL
// JonN 12/5/01 500682 changed from OVERWRITE_OLDER_THAN
#define DEFAULT_MAX_SIZE              16384UL
#define DEFAULT_OVERWRITE             OVERWRITE_AS_NEEDED
#define DEFAULT_RETENTION_DAYS        7

#define MAXSIZE_DIGITS                7
#define OLDERTHAN_DIGITS              3

// 601050-2002/04/17-JonN from base\eventlog\server\elfcg.h
#define     ELF_DEFAULT_MAX_FILE_SIZE         512*1024
#define     ELF_DEFAULT_RETENTION_PERIOD      7*24*3600


DEBUG_DECLARE_INSTANCE_COUNTER(CGeneralPage)

static ULONG
s_aulHelpIds[] =
{
    general_accessed_lbl,               Hgeneral_accessed_lbl,
    general_accessed_txt,               Hgeneral_accessed_txt,
    general_clear_pb,               Hgeneral_clear_pb,
    general_created_lbl,                Hgeneral_created_lbl,
    general_created_txt,                Hgeneral_created_txt,
    general_days_lbl,               Hgeneral_days_lbl,
    general_displayname_edit,   Hgeneral_displayname_edit,
    general_displayname_lbl,    Hgeneral_displayname_lbl,
    general_kilobytes_lbl,              Hgeneral_kilobytes_lbl,
    general_logname_edit,               Hgeneral_logname_edit,
    general_logname_lbl,                Hgeneral_logname_lbl,
    general_lowspeed_chk,               Hgeneral_lowspeed_chk,
    general_asneeded_rb,                Hgeneral_asneeded_rb,
    general_olderthan_rb,               Hgeneral_olderthan_rb,
    general_manual_rb,              Hgeneral_manual_rb,
    general_maxsize_edit,               Hgeneral_maxsize_edit,
    general_maxsize_lbl,                Hgeneral_maxsize_lbl,
    general_maxsize_spin,               Hgeneral_maxsize_spin,
    general_modified_lbl,               Hgeneral_modified_lbl,
    general_modified_txt,               Hgeneral_modified_txt,
    general_olderthan_edit,             Hgeneral_olderthan_edit,
    general_olderthan_spin,             Hgeneral_olderthan_spin,
    general_size_lbl,               Hgeneral_size_lbl,
    general_size_txt,               Hgeneral_size_txt,
    general_wrapping_grp,               Hgeneral_wrapping_grp,
    general_default_pb,             Hgeneral_default_pb,
    0,0
};




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::CGeneralPage
//
//  Synopsis:   ctor
//
//  Arguments:  [pstm] - contains marshalled interface on CComponentData
//              [pli]  - log on which property sheet being opened
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CGeneralPage::CGeneralPage(
    LPSTREAM pstm,
    CLogInfo *pli):
        _pstm(pstm),
        _pnpa(NULL),
        _pli(pli),
        _ulLogSizeLimit(0),
        _ulLogSizeLimitInReg(DEFAULT_MAX_SIZE),
        _OverwriteInReg(DEFAULT_OVERWRITE),
        _cRetentionDaysInReg(DEFAULT_RETENTION_DAYS)
{
    TRACE_CONSTRUCTOR(CGeneralPage);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CGeneralPage);
    ASSERT(pstm);
    ASSERT(_pli);

    //
    // Use an addref to keep the loginfo alive for the life of the property
    // sheet, otherwise _pli would become invalid if the user deleted the
    // log view.
    //

    _pli->AddRef();

    //
    // Note that this constructor is called by the main thread; the property
    // sheet doesn't exist yet.  So we must wait to unmarshal the interface
    // until _OnInit, which is called within the context of the property
    // sheet thread.
    //
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::~CGeneralPage
//
//  Synopsis:   dtor
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CGeneralPage::~CGeneralPage()
{
    TRACE_DESTRUCTOR(CGeneralPage);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CGeneralPage);

    _pli->Release();

    if (_pstm)
    {
        PVOID pvnpa;
        HRESULT hr;

        hr = CoGetInterfaceAndReleaseStream(_pstm,
                                            IID_INamespacePrshtActions,
                                            &pvnpa);

        CHECK_HRESULT(hr);
    }
}




VOID
CGeneralPage::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CGeneralPage, _OnHelp);

    InvokeWinHelp(message, wParam, lParam, HELP_FILENAME, s_aulHelpIds);
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_OnInit
//
//  Synopsis:   Initialize controls and their contents
//
//  Arguments:  [pPSP] - unused (required for signature of virtual func)
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CGeneralPage::_OnInit(LPPROPSHEETPAGE pPSP)
{
    TRACE_METHOD(CGeneralPage, _OnInit);

    HRESULT hr;
    WIN32_FILE_ATTRIBUTE_DATA fadLog;

    //
    // Unmarshal the private interface to the CComponentData object
    //

    PVOID pvnpa;
    hr = CoGetInterfaceAndReleaseStream(_pstm,
                                        IID_INamespacePrshtActions,
                                        &pvnpa);
    _pstm = NULL;

    if (SUCCEEDED(hr))
    {
        _pnpa = (INamespacePrshtActions *)pvnpa;
    }
    else
    {
        DBG_OUT_HRESULT(hr);
    }

    //
    // Set the display and filename
    //

    Edit_SetText(_hCtrl(general_displayname_edit),
                 _pli->GetDisplayName());
    Edit_LimitText(_hCtrl(general_displayname_edit), MAX_PATH);

    Edit_SetText(_hCtrl(general_logname_edit),
                 _pli->GetFileName());

    //
    // Set the file information
    //

    hr = _pli->GetLogFileAttributes(&fadLog);

    if (SUCCEEDED(hr))
    {
        //
        // Set the file size static text
        //

        WCHAR wszAbbrev[20];
        WCHAR wszWithSep[MAX_PATH];

        AbbreviateNumber(fadLog.nFileSizeLow,
                         wszAbbrev,
                         ARRAYLEN(wszAbbrev));

        FormatNumber(fadLog.nFileSizeLow,
                     wszWithSep,
                     ARRAYLEN(wszWithSep));

        wstring wstrBoth = FormatString(IDS_FMT_SIZE, wszAbbrev, wszWithSep); 
        Edit_SetText(_hCtrl(general_size_txt), wstrBoth.c_str());

        //
        // Set the created, modified, and accessed static texts.
        //

        WCHAR wszTimestamp[MAX_PATH];

        MakeTimestamp(&fadLog.ftCreationTime,
                      wszTimestamp,
                      ARRAYLEN(wszTimestamp));
        Edit_SetText(_hCtrl(general_created_txt), wszTimestamp);

        MakeTimestamp(&fadLog.ftLastAccessTime,
                      wszTimestamp,
                      ARRAYLEN(wszTimestamp));
        Edit_SetText(_hCtrl(general_accessed_txt), wszTimestamp);

        MakeTimestamp(&fadLog.ftLastWriteTime,
                      wszTimestamp,
                      ARRAYLEN(wszTimestamp));
        Edit_SetText(_hCtrl(general_modified_txt), wszTimestamp);
    }

    // JonN 436429
    if (_pli->IsReadOnly())
    {
        EnableWindow(_hCtrl(general_maxsize_lbl), FALSE);
        EnableWindow(_hCtrl(general_maxsize_edit), FALSE);
        EnableWindow(_hCtrl(general_maxsize_spin), FALSE);
        EnableWindow(_hCtrl(general_kilobytes_lbl), FALSE);
        EnableWindow(_hCtrl(general_wrapping_grp), FALSE);
        EnableWindow(_hCtrl(general_asneeded_rb), FALSE);
        EnableWindow(_hCtrl(general_olderthan_rb), FALSE);
        EnableWindow(_hCtrl(general_manual_rb), FALSE);
        EnableWindow(_hCtrl(general_olderthan_edit), FALSE);
        EnableWindow(_hCtrl(general_olderthan_spin), FALSE);
        EnableWindow(_hCtrl(general_days_lbl), FALSE);
        EnableWindow(_hCtrl(general_default_pb), FALSE);
        EnableWindow(_hCtrl(general_clear_pb), FALSE);
    }

    if (_pli->IsBackupLog())
    {
        ShowWindow(_hCtrl(general_sep), SW_HIDE);
        ShowWindow(_hCtrl(general_maxsize_lbl), SW_HIDE);
        ShowWindow(_hCtrl(general_maxsize_edit), SW_HIDE);
        ShowWindow(_hCtrl(general_maxsize_spin), SW_HIDE);
        ShowWindow(_hCtrl(general_kilobytes_lbl), SW_HIDE);
        ShowWindow(_hCtrl(general_wrapping_grp), SW_HIDE);
        ShowWindow(_hCtrl(general_asneeded_rb), SW_HIDE);
        ShowWindow(_hCtrl(general_olderthan_rb), SW_HIDE);
        ShowWindow(_hCtrl(general_manual_rb), SW_HIDE);
        ShowWindow(_hCtrl(general_olderthan_edit), SW_HIDE);
        ShowWindow(_hCtrl(general_olderthan_spin), SW_HIDE);
        ShowWindow(_hCtrl(general_days_lbl), SW_HIDE);
        ShowWindow(_hCtrl(general_default_pb), SW_HIDE);
        ShowWindow(_hCtrl(general_clear_pb), SW_HIDE);
        ShowWindow(_hCtrl(general_logsize_txt), SW_HIDE);
    }
    else
    {
        if (!_pli->IsReadOnly())
        {
            CSafeReg shkWrite;
            HRESULT hrTest = _GetLogKeyForWrite(&shkWrite);

            if (FAILED(hrTest))
            {
                _pli->SetReadOnly(TRUE);
            }

            //
            // Set the spin control ranges
            //

            UpDown_SetRange(_hCtrl(general_maxsize_spin), -1, 1);
            UpDown_SetRange(_hCtrl(general_olderthan_spin), 1, 365);

            //
            // Limit the length of chars in the buddy edit controls
            //

            Edit_LimitText(_hCtrl(general_maxsize_edit), MAXSIZE_DIGITS);
            Edit_LimitText(_hCtrl(general_olderthan_edit), OLDERTHAN_DIGITS);

            //
            // Set the user-changeable values
            //

            _InitLogSettingsFromRegistry();
            _SetValues(_ulLogSizeLimitInReg, _OverwriteInReg, _cRetentionDaysInReg);
        }
    }

    CheckDlgButton(_hwnd,
                   general_lowspeed_chk,
                   _pli->GetLowSpeed() ? MF_CHECKED : MF_UNCHECKED);
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_SetValues
//
//  Synopsis:   Set the values of the controls and enable the appropriate
//              controls to correspond to the arguments.
//
//  Arguments:  [kbMaxSize]      - value for max log size edit
//              [Overwrite]      - which overwrite method radio btn to chk
//              [cRetentionDays] - value for overwrite days edit/spin
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CGeneralPage::_SetValues(
    ULONG kbMaxSize,
    OVERWRITE_METHOD Overwrite,
    ULONG cRetentionDays)
{
    BOOL fOk;

    fOk = SetDlgItemInt(_hwnd, general_maxsize_edit, kbMaxSize, FALSE);
    ASSERT(fOk);

    fOk = SetDlgItemInt(_hwnd, general_olderthan_edit, cRetentionDays, FALSE);
    ASSERT(fOk);

    UpDown_SetPos(_hCtrl(general_maxsize_spin), 0);
    _ulLogSizeLimit = (INT) kbMaxSize;

    UpDown_SetPos(_hCtrl(general_olderthan_spin), cRetentionDays);

    fOk = CheckRadioButton(_hwnd,
                           general_asneeded_rb,
                           general_manual_rb,
                           Overwrite);
    ASSERT(fOk);

    _EnableOlderThanCtrls(Overwrite == general_olderthan_rb);
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_InitLogSettingsFromRegistry
//
//  Synopsis:   Read the registry to get the values to use for initializing
//              the controls.
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CGeneralPage::_InitLogSettingsFromRegistry()
{
    TRACE_METHOD(CGeneralPage, _InitLogSettingsFromRegistry);

    HRESULT hr = S_OK;
    CSafeReg regLog;
    CSafeReg regRemoteHKLM;

    do
    {
        //
        // Init to default values in case of error
        //

        _ulLogSizeLimitInReg = DEFAULT_MAX_SIZE;
        _OverwriteInReg = DEFAULT_OVERWRITE;
        _cRetentionDaysInReg = DEFAULT_RETENTION_DAYS;

        //
        //  Get Max size
        //

        wstring wstrKey;

        wstrKey = EVENTLOG_KEY;
        wstrKey += L"\\";
        wstrKey +=  _pli->GetLogName();
        
        if (_pli->GetLogServerName())
        {
            hr = regRemoteHKLM.Connect(_pli->GetLogServerName(),
                                       HKEY_LOCAL_MACHINE);
            BREAK_ON_FAIL_HRESULT(hr);

            hr = regLog.Open(regRemoteHKLM, (LPCTSTR)(wstrKey.c_str()), KEY_QUERY_VALUE);
        }
        else
        {
            hr = regLog.Open(HKEY_LOCAL_MACHINE, (LPCTSTR)(wstrKey.c_str()), KEY_QUERY_VALUE);
        }
        BREAK_ON_FAIL_HRESULT(hr);

        hr = regLog.QueryDword(L"MaxSize", (PDWORD)&_ulLogSizeLimitInReg);
        // 601032-2002/04/17-JonN
        // DNS Server does not register this value for the DNS log.
        //   Handle failure gracefully according to Event Log Service default.
        if (FAILED(hr)) // returns E_FAIL if no such value
            _ulLogSizeLimitInReg = ELF_DEFAULT_MAX_FILE_SIZE;

        //
        // the size is in bytes convert it to kb
        //

        _ulLogSizeLimitInReg >>= 10;

        //
        // Get retention, the length of time that a record must exist
        // before being overwritten.
        //

        hr = regLog.QueryDword(L"Retention", &_cRetentionDaysInReg);
        // 601032-2002/04/17-JonN
        // DNS Server does not register this value for the DNS log.
        //   Handle failure gracefully according to Event Log Service default.
        if (FAILED(hr)) // returns E_FAIL if no such value
            _cRetentionDaysInReg = ELF_DEFAULT_RETENTION_PERIOD;

        //
        // Derive overwrite status from retention, and convert retention
        // (if used) from seconds to days.
        //
        //  Note: the retention is in seconds.
        //

        if (_cRetentionDaysInReg == (ULONG)-1)
        {
            _OverwriteInReg = OVERWRITE_NEVER;
            _cRetentionDaysInReg = DEFAULT_RETENTION_DAYS;
        }
        else if (!_cRetentionDaysInReg)
        {
            _OverwriteInReg = OVERWRITE_AS_NEEDED;
            _cRetentionDaysInReg = DEFAULT_RETENTION_DAYS;
        }
        else
        {
            _OverwriteInReg = OVERWRITE_OLDER_THAN;
            _cRetentionDaysInReg /= SECS_IN_DAY;

            if (_cRetentionDaysInReg > 365)
            {
                _cRetentionDaysInReg = 365;
            }
        }
    } while (0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_OnSetActive
//
//  Synopsis:   Handle notification that page is gaining activation.
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CGeneralPage::_OnSetActive()
{
    TRACE_METHOD(CGeneralPage, _OnSetActive);
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_OnCommand
//
//  Synopsis:   Respond to user's action
//
//  Arguments:  [wParam] - from WM_COMMAND
//              [lParam] - from WM_COMMAND
//
//  Returns:    Value depending on command.
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CGeneralPage::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    TRACE_METHOD(CGeneralPage, _OnCommand);

    switch (LOWORD(wParam))
    {
    case general_maxsize_edit:
        if (HIWORD(wParam) == EN_UPDATE)
        {
            ULONG ulNewLimit = (ULONG) GetDlgItemInt(_hwnd,
                                                     general_maxsize_edit,
                                                     NULL,
                                                     FALSE);

            if (_ulLogSizeLimit == ulNewLimit)
            {
                break;
            }

            _EnableApply(TRUE);

            //
            // Force _ulLogSizeLimit to be a multiple of 64 (0x40) by
            // rounding to the nearest value.
            //

            _ulLogSizeLimit = (ulNewLimit + 32) & 0xFFFFFFC0;

            //
            // Keep it within the upper/lower limit
            //

            if (_ulLogSizeLimit < MIN_SIZE_LIMIT)
            {
                _ulLogSizeLimit = MIN_SIZE_LIMIT;
            }
            else if (_ulLogSizeLimit > MAX_SIZE_LIMIT)
            {
                _ulLogSizeLimit = MAX_SIZE_LIMIT;
            }
        }
        break;

    case general_asneeded_rb:
    case general_manual_rb:
        _EnableApply(TRUE);
        _EnableOlderThanCtrls(FALSE);
        break;

    case general_olderthan_rb:
        _EnableApply(TRUE);
        _EnableOlderThanCtrls(TRUE);
        break;

    case general_displayname_edit:
    case general_olderthan_edit:
        if (HIWORD(wParam) == EN_UPDATE)
        {
            _EnableApply(TRUE);
        }
        break;

    case general_lowspeed_chk:
        _EnableApply(TRUE);
        break;

    case general_default_pb:
    {
        INT iAnswer = MsgBox(_hwnd,
                             IDS_CONFIRM_SETTING_RESET,
                             // JonN 12/04/01 500649 added MB_DEFBUTTON2
                             MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2);

        if (iAnswer == IDYES)
        {
            _SetValues(DEFAULT_MAX_SIZE,
                       DEFAULT_OVERWRITE,
                       DEFAULT_RETENTION_DAYS);
            _EnableApply(TRUE);
        }
        break;
    }

    case general_clear_pb:
        if (_pnpa)
        {
            SAVE_TYPE SaveType;
            WCHAR wszSaveFilename[MAX_PATH];

            LONG lr = PromptForLogClear(_hwnd,
                                        _pli,
                                        &SaveType,
                                        wszSaveFilename,
                                        ARRAYLEN(wszSaveFilename));

            if (lr != IDCANCEL)
            {
                HRESULT hr = _pnpa->ClearLog((ULONG_PTR)_pli,
                                             (ULONG) SaveType,
                                             (ULONG_PTR) wszSaveFilename);

                if (FAILED(hr))
                {
                    DBG_OUT_HRESULT(hr);

                    wstring msg = ComposeErrorMessgeFromHRESULT(hr);

                    MsgBox(_hwnd,
                           IDS_CLEAR_FAILED,
                           MB_ICONERROR | MB_OK,
                           msg.c_str());
                }
            }
        }
        break;
    }
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_EnableOlderThanCtrls
//
//  Synopsis:   Enable or disable the edit and spin controls used for
//              the retention days value.
//
//  Arguments:  [fEnable] - TRUE enable, FALSE disable
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CGeneralPage::_EnableOlderThanCtrls(BOOL fEnable)
{
    if (fEnable)
    {
        Edit_Enable(_hCtrl(general_olderthan_edit), TRUE);
        UpDown_Enable(_hCtrl(general_olderthan_spin), TRUE);
    }
    else
    {
        Edit_Enable(_hCtrl(general_olderthan_edit), FALSE);
        UpDown_Enable(_hCtrl(general_olderthan_spin), FALSE);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_OnKillActive
//
//  Synopsis:   Validate settings of controls; warn user if any must be
//              corrected.
//
//  Returns:    0 (always allow page to lose focus)
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CGeneralPage::_OnKillActive()
{
    TRACE_METHOD(CGeneralPage, _OnKillActive);

    //
    // FALSE allows page to lose focus, TRUE prevents it.
    //

    if (_pli->IsBackupLog() || _pli->IsReadOnly())
    {
        return FALSE;
    }

    //
    // Notify the user if we had to modify the value specified in
    // the max size edit.  This can happen if the user enters a
    // value < min, > max, or not a multiple of 64.
    //

    ULONG ulLogSizeLimit = (ULONG) GetDlgItemInt(_hwnd,
                                                general_maxsize_edit,
                                                NULL,
                                                FALSE);

    if (ulLogSizeLimit < MIN_SIZE_LIMIT)
    {
        MsgBox(_hwnd, IDS_MIN_SIZE_LIMIT_WARN, MB_OK | MB_ICONWARNING);
    }
    else if (ulLogSizeLimit > MAX_SIZE_LIMIT)
    {
        MsgBox(_hwnd, IDS_MAX_SIZE_LIMIT_WARN, MB_OK | MB_ICONWARNING);
    }
    else if (ulLogSizeLimit != _ulLogSizeLimit)
    {
        MsgBox(_hwnd, IDS_SIZE_LIMIT_64K_WARN, MB_OK | MB_ICONWARNING);
    }

    if (ulLogSizeLimit != _ulLogSizeLimit)
    {
        SetDlgItemInt(_hwnd,
                      general_maxsize_edit,
                      _ulLogSizeLimit,
                      FALSE);
    }

    //
    // Notify the user if we're overriding the value in the retention days
    // edit.
    //

    if (IsDlgButtonChecked(_hwnd, general_olderthan_rb))
    {
        INT iDays = GetDlgItemInt(_hwnd,
                                  general_olderthan_edit,
                                  NULL,
                                  FALSE);

        if (iDays < 1)
        {
            MsgBox(_hwnd, IDS_MIN_RETENTION_WARN, MB_OK | MB_ICONWARNING);
            SetDlgItemInt(_hwnd, general_olderthan_edit, 1, FALSE);
            UpDown_SetPos(_hCtrl(general_olderthan_spin), 1);
        }
        else if (iDays > 365)
        {
            MsgBox(_hwnd, IDS_MAX_RETENTION_WARN, MB_OK | MB_ICONWARNING);
            SetDlgItemInt(_hwnd, general_olderthan_edit, 365, FALSE);
            UpDown_SetPos(_hCtrl(general_olderthan_spin), 365);
        }
    }

    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_OnApply
//
//  Synopsis:   Apply the values in the page to the log.
//
//  Returns:    PSNRET_NOERROR
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CGeneralPage::_OnApply()
{
    TRACE_METHOD(CGeneralPage, _OnApply);

    if (!_IsFlagSet(PAGE_IS_DIRTY))
    {
        Dbg(DEB_TRACE, "CGeneralPage: page not dirty; ignoring Apply\n");
        return PSNRET_NOERROR;
    }

    //
    // Update the LogInfo's displayname, but only if the user actually
    // changed it.  (This will mark the snapin as dirty, causing it to
    // persist itself.)
    //
    // Notify all other views that a log string has changed.
    //


    WCHAR wszDisplayName[MAX_PATH + 1];

    Edit_GetText(_hCtrl(general_displayname_edit),
                 wszDisplayName,
                 MAX_PATH + 1);

    if (lstrcmp(wszDisplayName, _pli->GetDisplayName()))
    {
        _pli->SetDisplayName(wszDisplayName);

        // via the message pump, ask the component data to update the
        // display if necessary
        g_SynchWnd.Post(ELSM_LOG_DATA_CHANGED,
                        LDC_DISPLAY_NAME,
                        reinterpret_cast<LPARAM>(_pli));
    }

    //
    // Update the cookie's connection speed info.  This is used by the
    // log record cache, when opened on the folder represented by the
    // cookie, to determine the size of the buffer it uses.
    //

    BOOL fLowSpeed = IsDlgButtonChecked(_hwnd, general_lowspeed_chk);

    if (fLowSpeed && !_pli->GetLowSpeed() ||
        !fLowSpeed && _pli->GetLowSpeed())
    {
        _pli->SetLowSpeed(fLowSpeed);
    }

    //
    // Set each of the values that actually changed.  For an archived
    // log or for one which we don't have permission to modify,
    // none of these are applicable.
    //

    HRESULT hr = S_OK;
    CSafeReg regLog;

    do
    {
        if (_pli->IsBackupLog() || _pli->IsReadOnly())
        {
            break;
        }

        hr = _GetLogKeyForWrite(&regLog);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            _pli->SetReadOnly(TRUE);
            break;
        }

        //
        // Log size limit
        //

        if (_ulLogSizeLimit != _ulLogSizeLimitInReg)
        {
            if (_ulLogSizeLimit < _ulLogSizeLimitInReg)
            {
                MsgBox(_hwnd,
                       IDS_LOG_SIZE_REDUCED,
                       MB_OK | MB_ICONEXCLAMATION);
            }

            // Note actual reg value is in bytes

            hr = regLog.SetDword(L"MaxSize", _ulLogSizeLimit << 10);
            BREAK_ON_FAIL_HRESULT(hr);

            _ulLogSizeLimitInReg = _ulLogSizeLimit;
        }

        //
        // Overwrite/Retention.  Note there's only one value in the
        // registry, the retention.  Retention of -1 means overwrite
        // never, retention of 0 means overwrite as needed.
        //

        OVERWRITE_METHOD OverwriteInUI = _GetOverwriteInUI();

        ULONG cRetentionDaysInUI = GetDlgItemInt(_hwnd,
                                                 general_olderthan_edit,
                                                 NULL,
                                                 FALSE);
        ASSERT(cRetentionDaysInUI);

        if (OverwriteInUI != _OverwriteInReg ||
            (OverwriteInUI == OVERWRITE_OLDER_THAN &&
            cRetentionDaysInUI != _cRetentionDaysInReg))
        {
            switch (OverwriteInUI)
            {
            case OVERWRITE_NEVER:
                hr = regLog.SetDword(L"Retention", (DWORD) -1);
                break;

            case OVERWRITE_AS_NEEDED:
                hr = regLog.SetDword(L"Retention", 0);
                break;

            case OVERWRITE_OLDER_THAN:
                hr = regLog.SetDword(L"Retention",
                                     cRetentionDaysInUI * SECS_IN_DAY);
                break;
            }
            BREAK_ON_FAIL_HRESULT(hr);

            _cRetentionDaysInReg = cRetentionDaysInUI;
            _OverwriteInReg = OverwriteInUI;
        }
    } while (0);


    if (FAILED(hr))
    {
        MsgBox(_hwnd,
               IDS_CANT_WRITE_SETTINGS,
               MB_OK | MB_ICONERROR,
               _pli->GetDisplayName(),
               hr);
    }
    return PSNRET_NOERROR;
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_GetLogKeyForWrite
//
//  Synopsis:   Attempt to open the event log key with write access.
//
//  Arguments:  [pshkWrite] - object to do open with
//
//  Returns:    HRESULT
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CGeneralPage::_GetLogKeyForWrite(
    CSafeReg *pshkWrite)
{
    HRESULT     hr = S_OK;
    wstring     wstrKey;
    CSafeReg    regRemoteHKLM;

    wstrKey = EVENTLOG_KEY;
    wstrKey += L"\\";
    wstrKey += _pli->GetLogName();

    if (_pli->GetLogServerName())
    {
        hr = regRemoteHKLM.Connect(_pli->GetLogServerName(), HKEY_LOCAL_MACHINE);

        if (SUCCEEDED(hr))
        {
            hr = pshkWrite->Open(regRemoteHKLM, (LPCTSTR)(wstrKey.c_str()), KEY_SET_VALUE);
        }
        else
        {
            DBG_OUT_HRESULT(hr);
        }
    }
    else
    {
        hr = pshkWrite->Open(HKEY_LOCAL_MACHINE, (LPCTSTR)(wstrKey.c_str()), KEY_SET_VALUE);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_GetOverwriteInUI
//
//  Synopsis:   Translate from which radio button is checked to the
//              OVERWRITE_METHOD enum.
//
//  Returns:    Value representing currently checked radio button.
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

OVERWRITE_METHOD
CGeneralPage::_GetOverwriteInUI()
{
    if (IsDlgButtonChecked(_hwnd, general_manual_rb))
    {
        return OVERWRITE_NEVER;
    }

    if (IsDlgButtonChecked(_hwnd, general_asneeded_rb))
    {
        return OVERWRITE_AS_NEEDED;
    }

    return OVERWRITE_OLDER_THAN;
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_OnQuerySiblings
//
//  Synopsis:   Handle inter-page communication.
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CGeneralPage::_OnQuerySiblings(WPARAM wParam, LPARAM lParam)
{
    TRACE_METHOD(CGeneralPage, _OnQuerySiblings);
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_OnDestroy
//
//  Synopsis:   Handle notification this page is going away.
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CGeneralPage::_OnDestroy()
{
    TRACE_METHOD(CGeneralPage, _OnDestroy);
}




//+--------------------------------------------------------------------------
//
//  Member:     CGeneralPage::_OnNotify
//
//  Synopsis:   Handle notification from a control.
//
//  Arguments:  [pnmh] - notification header.
//
//  Returns:    Varies by notification.
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CGeneralPage::_OnNotify(LPNMHDR pnmh)
{
    TRACE_METHOD(CGeneralPage, _OnNotify);

    ULONG ulResult = 0;

    switch (pnmh->idFrom)
    {
    case general_maxsize_spin:
        if (pnmh->code == UDN_DELTAPOS)
        {
            NM_UPDOWN *pnmud = (NM_UPDOWN *) pnmh;

            _ulLogSizeLimit += 64 * pnmud->iDelta;

            if (_ulLogSizeLimit < MIN_SIZE_LIMIT)
            {
                _ulLogSizeLimit = MAX_SIZE_LIMIT;
            }
            else if (_ulLogSizeLimit > MAX_SIZE_LIMIT)
            {
                _ulLogSizeLimit = MIN_SIZE_LIMIT;
            }

            SetDlgItemInt(_hwnd,
                          general_maxsize_edit,
                          _ulLogSizeLimit,
                          FALSE);
            _EnableApply(TRUE);
            ulResult = TRUE;
        }
        break;

    case general_olderthan_spin:
        if (pnmh->code == UDN_DELTAPOS)
        {
            _EnableApply(TRUE);
        }
        break;
    }
    return ulResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\globals.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       globals.cxx
//
//  Contents:   Globals used by multiple modules
//
//  History:    12-04-1996   DavidMun   Created
//
//---------------------------------------------------------------------------


#include "headers.hxx"
#pragma hdrstop

DECLARE_INFOLEVEL(els)
#if (DBG == 1)
ULONG CDbg::s_idxTls = TlsAlloc();
#endif // (DBG == 1)

class CCritSecHolder
{
public:

    CCritSecHolder() { InitializeCriticalSection(&m_cs); }
    ~CCritSecHolder() { DeleteCriticalSection(&m_cs); }
    LPCRITICAL_SECTION get() { return &m_cs; }

private:

    CRITICAL_SECTION    m_cs;
};

CCritSecHolder g_csInitFreeGlobals;

ULONG CDll::s_cObjs;
ULONG CDll::s_cLocks;
const UINT CDataObject::s_cfInternal =
        RegisterClipboardFormat(L"EVENT_SNAPIN_RAW_COOKIE");

HINSTANCE g_hinst;
HINSTANCE g_hinstRichEdit;

CSynchWindow g_SynchWnd;
CSidCache g_SidCache;
CDllCache g_DllCache;
CIsMicrosoftDllCache g_IsMicrosoftDllCache;
CIDsCache g_DirSearchCache;
WCHAR g_awszEventType[NUM_EVENT_TYPES][MAX_EVENTTYPE_STR];
WCHAR g_wszAll[CCH_SOURCE_NAME_MAX];
WCHAR g_wszNone[CCH_CATEGORY_MAX];
WCHAR g_wszEventViewer[MAX_PATH];
WCHAR g_wszSnapinType[MAX_PATH];
WCHAR g_wszSnapinDescr[MAX_PATH];
WCHAR g_wszMachineNameOverride[MAX_PATH];
BOOL  g_fMachineNameOverride;
WCHAR g_wszRedirectionURL[MAX_PATH];
WCHAR g_wszRedirectionProgram[MAX_PATH];
WCHAR g_wszRedirectionCmdLineParams[MAX_PATH];
WCHAR g_wszRedirectionTextToAppend[1024];

// JonN 3/21/01 350614
// Use message dlls and DS, FRS and DNS log types from specified computer
WCHAR g_wszAuxMessageSource[MAX_PATH];

//
// Forward references
//

VOID
InitMachineNameOverride();

//+--------------------------------------------------------------------------
//
//  Function:   InitGlobals
//
//  Synopsis:   Initialize public globals
//
//  History:    12-17-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
InitGlobals()
{
    TRACE_FUNCTION(InitGlobals);

    CAutoCritSec Lock(g_csInitFreeGlobals.get());
    ULONG i;

    for (i = 0; i < NUM_EVENT_TYPES; i++)
    {
        LoadStr(IDS_SUCCESS_TYPE + i,
                g_awszEventType[i],
                ARRAYLEN(g_awszEventType[i]));
    }

    LoadStr(IDS_ALL, g_wszAll, ARRAYLEN(g_wszAll));
    LoadStr(IDS_NONE, g_wszNone, ARRAYLEN(g_wszNone));
    LoadStr(IDS_VIEWER, g_wszEventViewer, ARRAYLEN(g_wszEventViewer));
    LoadStr(IDS_EXTENSION, g_wszSnapinType, ARRAYLEN(g_wszSnapinType));
    LoadStr(IDS_SNAPIN_ABOUT_DESCRIPTION, g_wszSnapinDescr, ARRAYLEN(g_wszSnapinDescr));

    InitMachineNameOverride();

    //
    // Load the redirection URL, program, and command-line parameters from the
    // registry, and format the text to append to event descriptions.
    //

    g_wszRedirectionURL[0] = 0;
    g_wszRedirectionProgram[0] = 0;
    g_wszRedirectionCmdLineParams[0] = 0;
    g_wszRedirectionTextToAppend[0] = 0;

    CSafeReg Reg;

    if (Reg.Open(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Event Viewer", KEY_READ) == S_OK)
    {
        WCHAR wszRedirectionProgram[ARRAYLEN(g_wszRedirectionProgram)];

        Reg.QueryStr(L"MicrosoftRedirectionURL", g_wszRedirectionURL, ARRAYLEN(g_wszRedirectionURL));
        Reg.QueryStr(L"MicrosoftRedirectionProgram", wszRedirectionProgram, ARRAYLEN(wszRedirectionProgram));
        Reg.QueryStr(L"MicrosoftRedirectionProgramCommandLineParameters", g_wszRedirectionCmdLineParams, ARRAYLEN(g_wszRedirectionCmdLineParams));

        if ((g_wszRedirectionURL[0] == 0) ||
            (wszRedirectionProgram[0] == 0) ||
            (g_wszRedirectionCmdLineParams[0] == 0) ||
            ExpandEnvironmentStrings(wszRedirectionProgram, g_wszRedirectionProgram, ARRAYLEN(g_wszRedirectionProgram)) == 0)
        {
            g_wszRedirectionProgram[0] = 0;
            g_wszRedirectionCmdLineParams[0] = 0;
        }
    }

    if (g_wszRedirectionURL[0] != 0)
    {
        WCHAR wszFmt[ARRAYLEN(g_wszRedirectionURL)];

        LoadStr(IDS_REDIRECT_URL_MESSAGE, wszFmt, ARRAYLEN(wszFmt));

        if ((wszFmt[0] == 0) ||
            (_snwprintf(g_wszRedirectionTextToAppend, ARRAYLEN(g_wszRedirectionTextToAppend), wszFmt, g_wszRedirectionURL) < 0))
        {
            g_wszRedirectionURL[0] = 0;
            g_wszRedirectionProgram[0] = 0;
            g_wszRedirectionCmdLineParams[0] = 0;
            g_wszRedirectionTextToAppend[0] = 0;
        }
        else
        {
        }
    }

    //
    // Initialize common controls
    //

    InitCommonControls();

    INITCOMMONCONTROLSEX icce;

    icce.dwSize = sizeof(icce);
    icce.dwICC = ICC_DATE_CLASSES | ICC_BAR_CLASSES | ICC_TAB_CLASSES;
    VERIFY(InitCommonControlsEx(&icce));

    ASSERT(!g_hinstRichEdit);
    g_hinstRichEdit = LoadLibrary(L"riched32.dll");
    g_SynchWnd.CreateSynchWindow();
}



//+--------------------------------------------------------------------------
//
//  Function:   FreeGlobals
//
//  Synopsis:   Free resources associated with globals.
//
//  History:    4-29-1999   davidmun   Created
//
//  Notes:      Only applies to globals which don't free their associated
//              resources in their destructors.
//
//---------------------------------------------------------------------------

VOID
FreeGlobals()
{
    TRACE_FUNCTION(FreeGlobals);

    CAutoCritSec Lock(g_csInitFreeGlobals.get());

    if (g_hinstRichEdit)
    {
        VERIFY(FreeLibrary(g_hinstRichEdit));
        g_hinstRichEdit = NULL;
    }
    g_SynchWnd.DestroySynchWindow();
}




//+--------------------------------------------------------------------------
//
//  Function:   InitMachineNameOverride
//
//  Synopsis:   Scan the command line for a /computer=<machine> switch,
//              and store <machine> in g_wszMachineNameOverride.
//
//  History:    07-31-1997   DavidMun   Created
//              03-20-2001   JonN       added AuxMessageSource command
//
//  Notes:      Sets g_fMachineNameOverride to TRUE if a valid /computer
//              switch is found.
//
//              If multiple /computer switches appear on the command line,
//              the last one wins.
//
//---------------------------------------------------------------------------

VOID
InitMachineNameOverride()
{
    //
    // Initialize the machine name override.
    //

    LPWSTR * pwszServiceArgVectors;         // Array of pointers to string
    int cArgs = 0;                          // Count of arguments

    // JonN 3/21/01 350614
    // Use message dlls and DS, FRS and DNS log types from specified computer
    g_wszMachineNameOverride[0] = L'\0'; 
    g_fMachineNameOverride = FALSE;
    g_wszAuxMessageSource[0] = L'\0'; 

    pwszServiceArgVectors = CommandLineToArgvW(GetCommandLineW(), &cArgs);

    if (pwszServiceArgVectors)
    {
        int i;
        ULONG cchOverrideSwitch = lstrlen(g_szOverrideCommandLine);
        ULONG cchAuxMessageSourceSwitch = lstrlen(g_szAuxMessageSourceSwitch);

        //
        // Process all arguments, so that last machine name override argument
        // wins.
        //

        for (i = 1; i < cArgs; i++)
        {
            ASSERT(pwszServiceArgVectors[i]);

            //
            // JonN 3/21/01 350614
            // Use message dlls and DS, FRS and DNS log types from specified computer
            // Check for the "AuxSource=" switch
            //
            if ((ULONG)lstrlen(pwszServiceArgVectors[i]) > cchAuxMessageSourceSwitch )
            {
                WCHAR wchSaved = pwszServiceArgVectors[i][cchAuxMessageSourceSwitch];
                pwszServiceArgVectors[i][cchAuxMessageSourceSwitch] = L'\0';
                int icmp = lstrcmpi(pwszServiceArgVectors[i], g_szAuxMessageSourceSwitch);
                pwszServiceArgVectors[i][cchAuxMessageSourceSwitch] = wchSaved;
                if (!icmp)
                {
                    lstrcpyn(g_wszAuxMessageSource,
                             &pwszServiceArgVectors[i][cchAuxMessageSourceSwitch],
                             ARRAYLEN(g_wszAuxMessageSource));
                    HRESULT hr = CanonicalizeComputername(g_wszAuxMessageSource, FALSE);
                    if (FAILED(hr))
                    {
                        g_wszAuxMessageSource[0] = L'\0';
                    }
                }
            }

            //
            // See if the argument string starts with the override switch.
            // If it's no longer than the switch we're looking for, ignore
            // it.
            //

            if ((ULONG)lstrlen(pwszServiceArgVectors[i]) <= cchOverrideSwitch)
            {
                continue;
            }

            //
            // Temporarily null terminate the argument just after what would
            // be the last switch character, then compare the argument
            // against the switch.
            //
            // If they differ, go on to the next argument.
            //

            WCHAR wchSaved = pwszServiceArgVectors[i][cchOverrideSwitch];
            pwszServiceArgVectors[i][cchOverrideSwitch] = L'\0';

            if (lstrcmpi(pwszServiceArgVectors[i], g_szOverrideCommandLine))
            {
                continue;
            }

            //
            // Found the switch!  Restore the character that was replaced
            // with a NULL, and note that an override has been specified.
            //

            g_fMachineNameOverride = TRUE;
            pwszServiceArgVectors[i][cchOverrideSwitch] = wchSaved;

            //
            // Now look at the switch value, if it specifies local machine,
            // the override value is just an empty string.
            //

            if (!lstrcmpi(g_szLocalMachine,
                          &pwszServiceArgVectors[i][cchOverrideSwitch]))
            {
                g_wszMachineNameOverride[0] = L'\0';
                continue;
            }

            //
            // The switch value should specify an actual computer name.  If
            // it looks invalid, consider the switch not to have been
            // specified.
            //

            lstrcpyn(g_wszMachineNameOverride,
                     &pwszServiceArgVectors[i][cchOverrideSwitch],
                     ARRAYLEN(g_wszMachineNameOverride));

            HRESULT hr;

            hr = CanonicalizeComputername(g_wszMachineNameOverride, FALSE);

            if (FAILED(hr))
            {
                g_wszMachineNameOverride[0] = L'\0';
                g_fMachineNameOverride = FALSE;
            }
        }
        LocalFree(pwszServiceArgVectors);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\find.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       find.cxx
//
//  Contents:   Implementation of find-next-record dialog
//
//  Classes:    CFindInfo
//              CFindDlg
//
//  History:    3-19-1997   DavidMun   Created
//
//---------------------------------------------------------------------------


#include "headers.hxx"
#pragma hdrstop


DEBUG_DECLARE_INSTANCE_COUNTER(CFindInfo)
DEBUG_DECLARE_INSTANCE_COUNTER(CFindDlg)


static ULONG
s_aulHelpIDs[] =
{
    find_information_ckbox,     Hfind_information_ckbox,
    find_warning_ckbox,         Hfind_warning_ckbox,
    find_error_ckbox,           Hfind_error_ckbox,
    find_success_ckbox,         Hfind_success_ckbox,
    find_failure_ckbox,         Hfind_failure_ckbox,
    find_source_combo,          Hfind_source_combo,
    find_category_combo,        Hfind_category_combo,
    find_eventid_edit,          Hfind_eventid_edit,
    find_computer_edit,         Hfind_computer_edit,
    find_user_edit,             Hfind_user_edit,
    find_type_grp,              Hfind_type_grp,
    find_source_lbl,            Hfind_source_lbl,
    find_category_lbl,          Hfind_category_lbl,
    find_eventid_lbl,           Hfind_eventid_lbl,
    find_computer_lbl,          Hfind_computer_lbl,
    find_user_lbl,              Hfind_user_lbl,
    find_description_lbl,       Hfind_description_lbl,
    find_description_edit,      Hfind_description_edit,
    find_direction_grp,         Hfind_direction_grp,
    find_up_rb,                 Hfind_up_rb,
    find_down_rb,               Hfind_down_rb,
    find_next_pb,               Hfind_next_pb,
    find_clear_pb,              Hfind_clear_pb,
    IDCLOSE,                    Hfind_close_pb,
    0,0
};

//===========================================================================
//
// CFindInfo implementation
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CFindInfo::CFindInfo
//
//  Synopsis:   ctor
//
//  History:    3-19-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CFindInfo::CFindInfo(
    CSnapin  *pSnapin,
    CLogInfo *pli):
        _pSnapin(pSnapin),
        _pli(pli)
{
    TRACE_CONSTRUCTOR(CFindInfo);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CFindInfo);
    ASSERT(pli);
    ASSERT(pSnapin);

    _FindDlg.SetParent(this);

    //
    // WARNING: all pointers must be initialized before calling Reset
    //

    _pwszDescription = NULL;
    Reset();
}




//+--------------------------------------------------------------------------
//
//  Member:     CFindInfo::~CFindInfo
//
//  Synopsis:   dtor
//
//  History:    3-19-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CFindInfo::~CFindInfo()
{
    TRACE_DESTRUCTOR(CFindInfo);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CFindInfo);

    Reset();
}



#if (DBG == 1)

//+--------------------------------------------------------------------------
//
//  Member:     CFindInfo::Dump
//
//  Synopsis:   Dump this data structure to the debugger.
//
//  History:    3-26-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CFindInfo::Dump()
{
    Dbg(DEB_ITRACE, "_ulType          = %x\n", _ulType);
    Dbg(DEB_ITRACE, "_wszSource       = '%s'\n", _wszSource);
    Dbg(DEB_ITRACE, "_usCategory      = %u\n", _usCategory);
    Dbg(DEB_ITRACE, "_wszUser         = '%s'\n", _wszUser);
    Dbg(DEB_ITRACE, "_wszUserLC       = '%s'\n", _wszUserLC);
    Dbg(DEB_ITRACE, "_wszComputer     = '%s'\n", _wszComputer);
    if (_fEventIDSpecified)
    {
        Dbg(DEB_ITRACE, "_ulEventID   = %u\n", _ulEventID);
    }
    else
    {
        Dbg(DEB_ITRACE, "_ulEventID not specified\n");
    }
    Dbg(DEB_ITRACE, "_pwszDescription = '%s'\n", _pwszDescription ? _pwszDescription : L"<NULL>");
    Dbg(DEB_ITRACE, "_FindDirection   = %s\n", _FindDirection == FORWARD ? L"FORWARD" : L"BACKWARD");
    Dbg(DEB_ITRACE, "hwndFindDlg      = %x\n", _FindDlg.GetDlgWindow());
    Dbg(DEB_ITRACE, "_pli             = %x\n", _pli);
}

#endif // (DBG == 1)




//+--------------------------------------------------------------------------
//
//  Member:     CFindInfo::OnFind
//
//  Synopsis:   Make the find dialog owned by this the foreground window,
//              or if one doesn't exist, create it.
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CFindInfo::OnFind()
{
    TRACE_METHOD(CFindInfo, OnFind);

    HWND    hwndFindDlg = _FindDlg.GetDlgWindow();

    if (hwndFindDlg)
    {
        ASSERT(IsWindow(hwndFindDlg));
        VERIFY(SetForegroundWindow(hwndFindDlg));
        return S_OK;
    }

    //
    // No dialog open yet.  Create one.
    //

    return _FindDlg.DoModelessDlg(_pSnapin);
}




//+--------------------------------------------------------------------------
//
//  Member:     CFindInfo::Passes
//
//  Synopsis:   Return TRUE if [pelr] meets the restrictions set by this
//              object.
//
//  Arguments:  [pFFP] - positioned at record to check
//
//  Returns:    TRUE or FALSE
//
//  History:    3-26-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CFindInfo::Passes(
    CFFProvider *pFFP)
{
    BOOL fPass = CFindFilterBase::Passes(pFFP);

    //
    // For a record to pass it must pass all criteria.  So if the base
    // passed and a description has been specified, require that the
    // description string match, too.
    //

    if (fPass && _pwszDescription)
    {
        LPWSTR pwszDescription = pFFP->GetDescriptionStr();

        if (pwszDescription)
        {
            CharLowerBuff(pwszDescription, lstrlen(pwszDescription));
            fPass = (NULL != wcsstr(pwszDescription, _pwszDescription));
        }
        LocalFree(pwszDescription);
    }

    return fPass;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFindInfo::Reset
//
//  Synopsis:   Clear all find info (so any record would be found).
//
//  History:    3-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CFindInfo::Reset()
{
    TRACE_METHOD(CFindInfo, Reset);

    CFindFilterBase::_Reset();
    _FindDirection = FORWARD;
    delete [] _pwszDescription;
    _pwszDescription = NULL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFindInfo::SetDescription
//
//  Synopsis:   Take ownership of the string [pwszDescription].
//
//  Arguments:  [pwszDescription] - string to hold, can be NULL
//
//  History:    3-25-1997   DavidMun   Created
//
//  Notes:      String will be freed on clear or in dtor.
//
//---------------------------------------------------------------------------

VOID
CFindInfo::SetDescription(
    LPWSTR pwszDescription)
{
    delete [] _pwszDescription;
    _pwszDescription = pwszDescription;

    if (_pwszDescription)
    {
        CharLowerBuff(_pwszDescription, lstrlen(_pwszDescription));
    }
}



VOID
CFindInfo::Shutdown()
{
    if (!_FindDlg.GetDlgWindow())
    {
        return;
    }

    //
    // If there is a modal popup (e.g. item not found) over the
    // find dialog, get rid of it first.
    //

    HWND hwndPopup = GetWindow(_FindDlg.GetDlgWindow(), GW_ENABLEDPOPUP);

    if (hwndPopup)
    {
        SendMessage(hwndPopup, WM_COMMAND, IDCANCEL, 0);
    }

    SendMessage(_FindDlg.GetDlgWindow(), WM_COMMAND, IDCANCEL, 0);
}





//===========================================================================
//
// CFindDlg implementation
//
//===========================================================================


//+--------------------------------------------------------------------------
//
//  Member:     CFindDlg::CFindDlg
//
//  Synopsis:   ctor
//
//  History:    3-19-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CFindDlg::CFindDlg():
        _pfi(NULL),
        _prpa(NULL),
        _pstm(NULL),
        _fNonDescDirty(FALSE)
{
    TRACE_CONSTRUCTOR(CFindDlg);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CFindDlg);
}




//+--------------------------------------------------------------------------
//
//  Member:     CFindDlg::~CFindDlg
//
//  Synopsis:   dtor
//
//  History:    3-19-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CFindDlg::~CFindDlg()
{
    TRACE_DESTRUCTOR(CFindDlg);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CFindDlg);
    ASSERT(!_prpa);
    ASSERT(!_pstm);
}




//+--------------------------------------------------------------------------
//
//  Member:     CFindDlg::DoModelessDlg
//
//  Synopsis:   Invokes the find dialog.
//
//  Returns:    HRESULT
//
//  History:    3-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CFindDlg::DoModelessDlg(
    CSnapin *pSnapin)
{
    TRACE_METHOD(CFindDlg, DoModelessDlg);
    ASSERT(!_pstm);
    ASSERT(!IsBadReadPtr(pSnapin, sizeof(*pSnapin)));
    if (IsBadReadPtr(pSnapin, sizeof(*pSnapin))) // PREFIX 56320
    {
        Dbg(DEB_ERROR, "CFindDlg::DoModelessDlg bad pSnapin\n");
        return E_POINTER;
    }

    HRESULT hr = S_OK;

    hr = CoMarshalInterThreadInterfaceInStream(IID_IResultPrshtActions,
                                               (IResultPrshtActions *) pSnapin,
                                               &_pstm);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    ULONG idThread;

    HANDLE hThread = CreateThread(NULL,
                                  0,
                                  _ThreadFunc,
                                  (LPVOID) this,
                                  0,
                                  &idThread);

    if (hThread)
    {
        CloseHandle(hThread);
    }
    else
    {
        hr = HRESULT_FROM_LASTERROR;
        DBG_OUT_LASTERROR;
        PVOID pvrpa;

        hr = CoGetInterfaceAndReleaseStream(_pstm,
                                            IID_IResultPrshtActions,
                                            &pvrpa);
        CHECK_HRESULT(hr);
        _pstm = NULL;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFindDlg::_ThreadFunc, static
//
//  Synopsis:   Invoke the modeless find dialog and run a message pump for
//              it.
//
//  Arguments:  [pvThis] - pointer to CFindDlg
//
//  Returns:    0
//
//  History:    06-17-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

DWORD WINAPI
CFindDlg::_ThreadFunc(
    LPVOID pvThis)
{
    HRESULT      hr = S_OK;
    CFindDlg    *pThis = (CFindDlg *)pvThis;
    BOOL         fInitializedOle = FALSE;

    do
    {
        hr = CoInitialize(NULL);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            pThis->_pstm->Release();
            pThis->_pstm = NULL;
            break;
        }

        fInitializedOle = TRUE;

        //
        // Unmarshal the private interface to the CComponentData object
        //

        PVOID pvrpa;
        hr = CoGetInterfaceAndReleaseStream(pThis->_pstm,
                                            IID_IResultPrshtActions,
                                            &pvrpa);
        pThis->_pstm = NULL; // just released by above call

        if (SUCCEEDED(hr))
        {
            pThis->_prpa = (IResultPrshtActions *)pvrpa;
        }
        else
        {
            DBG_OUT_HRESULT(hr);
            break;
        }

        HWND hdlg = pThis->_DoModelessDlg(IDD_FIND);

        if (!hdlg)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        MSG msg;

        while (GetMessage(&msg, NULL, 0, 0) > 0)
        {
            if (!IsDialogMessage(hdlg, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    } while (0);

    if (fInitializedOle)
    {
        CoUninitialize();
    }

    return 0;
}




VOID
CFindDlg::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    InvokeWinHelp(message, wParam, lParam, HELP_FILENAME, s_aulHelpIDs);
}




#define MAX_FIND_PREFIX 80

//+--------------------------------------------------------------------------
//
//  Member:     CFindDlg::_OnInit
//
//  Synopsis:   Initialize the find dialog from the information in the
//              find info.
//
//  Arguments:  [pfSetFocus] - set to TRUE if this function sets focus
//
//  Returns:    HRESULT
//
//  Modifies:   *[pfSetFocus]
//
//  History:    3-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CFindDlg::_OnInit(BOOL *pfSetFocus)
{
    TRACE_METHOD(CFindDlg, _OnInit);

    HRESULT     hr = S_OK;

    //
    // Initialize the portion of the dialog that's the same for both the
    // find dialog and filter page.
    //

    InitFindOrFilterDlg(
        _hwnd,
        _pfi->GetLogInfo()->GetSources(),
        _pfi);

    //
    // Init the find-specific controls.  There's no length limit on the
    // description.
    //

    if (_pfi->GetDescription())
    {
        Edit_SetText(_hCtrl(find_description_edit), _pfi->GetDescription());
    }

    if (_pfi->GetDirection() == FORWARD)
    {
        CheckDlgButton(_hwnd, find_down_rb, BST_CHECKED);
    }
    else
    {
        CheckDlgButton(_hwnd, find_up_rb, BST_CHECKED);
    }

    //
    // Init the dialog caption to indicate which logview this dialog
    // operates on.
    //

    CLogInfo *pli = _pfi->GetLogInfo();

    wstring wstrCaption;

    if (pli->GetLogServerName())
    {
        // JonN 01/30/2001 This text is a little odd, but I won't change it
        wstrCaption = FormatString(IDS_REMOTE_FIND_CAPTION_FMT,
                                   pli->GetLogServerName(),
                                   pli->GetDisplayName());
    }
    else
    {
        wstrCaption = FormatString(IDS_FIND_CAPTION_FMT, pli->GetDisplayName());
    }

	VERIFY(SetWindowText(_hwnd, (LPCTSTR)(wstrCaption.c_str())));

    //
    // The Find Next pushbutton is disabled in the RC file.  Enable
    // it if the log on which this dialog is being opened is the
    // currently selected log in the scope pane.
    //

    CLogInfo *pliCurSel;
    _prpa->GetCurSelLogInfo((ULONG_PTR) &pliCurSel);

    if (pliCurSel == pli)
    {
        EnableWindow(_hCtrl(find_next_pb), TRUE);
    }

    //
    // The initialization commands could have caused notifications which
    // marked the dialog as dirty
    //

    _fNonDescDirty = FALSE;
    _fDescDirty = FALSE;
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFindDlg::_OnCommand
//
//  Synopsis:   Process a dialog control message
//
//  Arguments:  [wParam] - identifies control
//              [lParam] - not used
//
//  Returns:    TRUE - message NOT handled
//              FALSE - message handled
//
//  History:    3-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CFindDlg::_OnCommand(
        WPARAM wParam,
        LPARAM lParam)
{
    TRACE_METHOD(CFindDlg, _OnCommand);
    BOOL fUnhandled = FALSE;

    switch (LOWORD(wParam))
    {
    case IDCANCEL: // this comes from window-close widget
    case IDCLOSE:  // this comes from close pushbutton
        Dbg(DEB_TRACE, "CFindDlg::_OnCommand: IDCLOSE or IDCANCEL\n");
        DestroyWindow(_hwnd);
        break;

    case ELS_ENABLE_FIND_NEXT:
        EnableWindow(_hCtrl(find_next_pb), static_cast<BOOL>(lParam));
        break;

    case find_source_combo:
    {
        if (HIWORD(wParam) != CBN_SELCHANGE)
        {
            break;
        }

        _fNonDescDirty = TRUE;

        //
        // get source value from filter combo
        //

        HWND  hwndSourceCombo = _hCtrl(find_source_combo);
        WCHAR wszSource[CCH_SOURCE_NAME_MAX];

        ComboBox_GetText(hwndSourceCombo, wszSource, CCH_SOURCE_NAME_MAX);

        //
        // Set category combo contents according to new source, and set
        // category filter selection to (All).
        //

        CSources *pSources = _pfi->GetLogInfo()->GetSources();
        SetCategoryCombobox(_hwnd, pSources, wszSource, 0);

        //
        // turn off type filtering
        //

        SetTypesCheckboxes(_hwnd, pSources, ALL_LOG_TYPE_BITS);
        break;
    }

    case find_category_combo:
        if (HIWORD(wParam) == CBN_SELCHANGE)
        {
            _fNonDescDirty = TRUE;
        }
        break;

    case find_description_edit:
        if (HIWORD(wParam) == EN_CHANGE)
        {
            _fDescDirty = TRUE;
        }
        break;

    case find_user_edit:
    case find_computer_edit:
    case find_eventid_edit:
        if (HIWORD(wParam) == EN_CHANGE)
        {
            _fNonDescDirty = TRUE;
        }
        break;

    case find_up_rb:
    case find_down_rb:
    case find_information_ckbox:
    case find_warning_ckbox:
    case find_error_ckbox:
    case find_success_ckbox:
    case find_failure_ckbox:
        _fNonDescDirty = TRUE;
        break;

    case find_clear_pb:
        _fNonDescDirty = TRUE;
        _OnClear();
        break;

    case find_next_pb:
        _OnNext();
        break;

    default:
        fUnhandled = TRUE;
        break;

    }
    return fUnhandled;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFindDlg::_OnClear
//
//  Synopsis:   Reset the contents of the dialog
//
//  History:    3-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CFindDlg::_OnClear()
{
    ClearFindOrFilterDlg(_hwnd, _pfi->GetLogInfo()->GetSources());
    SetDlgItemText(_hwnd, find_description_edit, L"");
    CheckRadioButton(_hwnd, find_up_rb, find_down_rb, find_down_rb);
    _fNonDescDirty = TRUE;
    _fDescDirty = TRUE;
}



//+--------------------------------------------------------------------------
//
//  Member:     CFindDlg::_OnDestroy
//
//  Synopsis:   Do terminal processing before dialog closes
//
//  History:    3-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CFindDlg::_OnDestroy()
{
    TRACE_METHOD(CFindDlg, _OnDestroy);

    if (_prpa)
    {
        _prpa->Release();
        _prpa = NULL;
    }
    //
    // CAUTION: _pfi may point to freed memory at this time.  This will
    // occur if the find dialog is open when the user closes the
    // snapin.
    //
    PostQuitMessage(0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CFindDlg::_OnNext
//
//  Synopsis:   Set the result pane selection to the next record that
//              matches the find criteria.
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CFindDlg::_OnNext()
{
    BOOL fOk = TRUE;

    //
    // Update all of the find criteria except the description string
    //

    if (_fNonDescDirty)
    {
        //
        // Get the common values, bail if they are invalid
        //

        fOk = ReadFindOrFilterValues(_hwnd,
                                     _pfi->GetLogInfo()->GetSources(),
                                     _pfi);

        if (!fOk)
        {
            return;
        }

        if (IsDlgButtonChecked(_hwnd, find_up_rb))
        {
            _pfi->SetDirection(BACKWARD);
        }
        else
        {
            _pfi->SetDirection(FORWARD);
        }
        _fNonDescDirty = FALSE;
    }

    //
    // Update the description string if it has changed
    //

    if (_fDescDirty)
    {
        ULONG cchDescription =
                    Edit_GetTextLength(_hCtrl(find_description_edit)) + 1;

        if (cchDescription < 2)
        {
            _pfi->SetDescription(NULL);
            _fDescDirty = FALSE;
        }
        else
        {
            LPWSTR pwszDescription = new WCHAR[cchDescription];

            if (pwszDescription)
            {
                Edit_GetText(_hCtrl(find_description_edit),
                                    pwszDescription,
                                    cchDescription);
                //
                // Find info takes ownership of this string and will free it.
                //

                _pfi->SetDescription(pwszDescription);
                _fDescDirty = FALSE;
            }
            else
            {
                //
                // Leave the description string marked as dirty, maybe
                // we will be able to get it on next try.
                //

                _pfi->SetDescription(NULL);
                DBG_OUT_HRESULT(E_OUTOFMEMORY);
            }
        }
    }

    //
    // Ask the snapin to perform a find
    //

    _prpa->FindNext((ULONG_PTR)_pfi);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\inspinfo.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       inspinfo.cxx
//
//  Contents:   Implementatioon
//
//  Classes:
//
//  Functions:
//
//  History:    4-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


DEBUG_DECLARE_INSTANCE_COUNTER(CInspectorInfo)


//+--------------------------------------------------------------------------
//
//  Member:     CInspectorInfo::CInspectorInfo
//
//  Synopsis:   ctor
//
//  History:    4-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CInspectorInfo::CInspectorInfo():
    _fOpenInProgress(FALSE),
    _hwndDetailsPage(NULL),
    _pCurResultRecCopy(NULL)
{
    TRACE_CONSTRUCTOR(CInspectorInfo);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CInspectorInfo);

    InitializeCriticalSection(&_cs);
}




//+--------------------------------------------------------------------------
//
//  Member:     CInspectorInfo::~CInspectorInfo
//
//  Synopsis:   dtor
//
//  History:    4-02-1997   DavidMun   Created
//
//  Notes:      Property inspector should have been forced closed, causing
//              a setinspector wnd of null, causing _pCurResultRecCopy to
//              be freed already.
//
//---------------------------------------------------------------------------

CInspectorInfo::~CInspectorInfo()
{
    TRACE_DESTRUCTOR(CInspectorInfo);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CInspectorInfo);
    ASSERT(!_hwndDetailsPage);
    ASSERT(!_pCurResultRecCopy);

    delete [] (BYTE *) _pCurResultRecCopy;
    DeleteCriticalSection(&_cs);
}




//+--------------------------------------------------------------------------
//
//  Member:     CInspectorInfo::BringToForeground
//
//  Synopsis:   If inspector window is open, make it foreground window.
//
//  History:    4-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CInspectorInfo::BringToForeground()
{
    if (_hwndDetailsPage && GetParent(_hwndDetailsPage))
    {
        VERIFY(SetForegroundWindow(GetParent(_hwndDetailsPage)));
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CInspectorInfo::CopyCurResultRec
//
//  Synopsis:   Make a copy of the currently selected event log record.
//
//  Arguments:  [ppelr] - filled with copy of record or NULL.
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  Modifies:   *[ppelr]
//
//  History:    4-02-1997   DavidMun   Created
//
//  Notes:      This routine is necessary because the property sheet which
//              uses the currently selected record runs in a separate
//              thread.  The CSnapin class will delete and reallocate
//              the result record copy whenever it receives a notification
//              of selection change; it is possible this could occur while
//              the inspector property sheet is accessing the copy to
//              update its display.
//
//              To prevent the CSnapin class from deleting the current
//              result record copy while the property sheet is accessing
//              it, this routine gives the property sheet its own copy.
//
//---------------------------------------------------------------------------

HRESULT
CInspectorInfo::CopyCurResultRec(
    EVENTLOGRECORD **ppelr)
{
    HRESULT hr = S_OK;

    //
    // Critical section protection is not necessary here, since the
    // current result record copy is only set from within this (the
    // main) thread.
    //

    if (!_pCurResultRecCopy)
    {
        *ppelr = NULL;
    }
    else
    {
        *ppelr = (EVENTLOGRECORD *) new BYTE[_pCurResultRecCopy->Length];

        if (!*ppelr)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
        }

        CopyMemory(*ppelr, _pCurResultRecCopy, _pCurResultRecCopy->Length);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CInspectorInfo::UpdateCurResultRec
//
//  Synopsis:   Take ownership of copy of current result record [pelr].
//
//  Arguments:  [pelr]          - copy of current result record
//              [fBringToFront] - if TRUE and inspector open, make it
//                                  the foreground window.
//
//  History:    4-02-1997   DavidMun   Created
//
//  Notes:      This object will free [pelr].
//
//---------------------------------------------------------------------------

VOID
CInspectorInfo::UpdateCurResultRec(
    EVENTLOGRECORD *pelr,
    BOOL fBringToFront)
{
    TRACE_METHOD(CInspectorInfo, UpdateCurResultRec);

    BOOL fDifferentData = FALSE;

    if (_pCurResultRecCopy && !pelr ||
        !_pCurResultRecCopy && pelr ||
            (_pCurResultRecCopy &&
             pelr &&
             _pCurResultRecCopy->RecordNumber != pelr->RecordNumber))
    {
        fDifferentData = TRUE;
    }

    if (_pCurResultRecCopy)
    {
        delete [] (BYTE *) _pCurResultRecCopy;
    }

    _pCurResultRecCopy = pelr;

    //
    // NOTE: SendMessage can fail with error
    // RPC_E_CANTCALLOUT_ININPUTSYNCCALL.  This is because the caller may
    // be the sender of an inter-thread message; it is waiting for us to
    // return.  See KB article:
    //
    // PRB: Synch OLE Call Fails in Inter-Process/Thread SendMessage
    // Article ID: Q131056
    //

    if (_hwndDetailsPage && fDifferentData)
    {
        PostMessage(GetParent(_hwndDetailsPage), PSM_QUERYSIBLINGS, 0, 0);
    }

    if (fBringToFront)
    {
        BringToForeground();
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CInspectorInfo::SetInspectorWnd
//
//  Synopsis:   Remember the window handle of the inspector, so we can
//              send it notification changes when the current result
//              record changes.
//
//  Arguments:  [hwnd] - details property sheet string page handle, or NULL
//                          if property sheet closing.
//
//  History:    4-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CInspectorInfo::SetInspectorWnd(
    HWND hwnd)
{
    ASSERT((hwnd && !_hwndDetailsPage) || (!hwnd && _hwndDetailsPage));

    //
    // Either the open just finished and hwnd is non-null, or
    // the property sheet is closing.  In either case we are no
    // longer waiting for the property sheet to open.
    //

    _fOpenInProgress = FALSE;

    _hwndDetailsPage = hwnd;

    //
    // Note this is always called from the main thread
    //

    if (!_hwndDetailsPage)
    {
        delete [] (BYTE*) _pCurResultRecCopy;
        _pCurResultRecCopy = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\log.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       log.cxx
//
//  Contents:   Implementation of class to handle event log operations
//
//  Classes:    CEventLog
//
//  History:    12-14-1996   DavidMun   Created
//
//---------------------------------------------------------------------------


#include "headers.hxx"
#pragma hdrstop

#define DEFAULT_SEEKREAD_BUFSIZE    512

DEBUG_DECLARE_INSTANCE_COUNTER(CEventLog)



//+--------------------------------------------------------------------------
//
//  Member:     CEventLog::CEventLog
//
//  Synopsis:   ctor
//
//  History:    1-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CEventLog::CEventLog():
    _pLogInfo(NULL),
    _hLog(NULL)
{
    TRACE_CONSTRUCTOR(CEventLog);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CEventLog);
}




//+--------------------------------------------------------------------------
//
//  Member:     CEventLog::~CEventLog
//
//  Synopsis:   dtor
//
//  History:    1-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CEventLog::~CEventLog()
{
    TRACE_DESTRUCTOR(CEventLog);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CEventLog);

    Close();
}




//+--------------------------------------------------------------------------
//
//  Member:     CEventLog::Backup
//
//  Synopsis:   Write log to backup event log file.
//
//  Arguments:  [wszSaveFileName] - name of backup file to create.
//
//  Returns:    HRESULT
//
//  History:    1-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CEventLog::Backup(LPCWSTR wszSaveFileName, HWND hWnd) // EricB 1/24/02 bug 526133
{
    TRACE_METHOD(CEventLog, Backup);
    ASSERT(_hLog);

    BOOL fOk = BackupEventLog(_hLog, wszSaveFileName);
    HRESULT hr = S_OK;

    if (!fOk)
    {
        ULONG ulLastError = GetLastError();

        Dbg(DEB_ERROR,
            "BackupEventLog(0x%x, '%ws') error %uL\n",
            _hLog,
            wszSaveFileName,
            ulLastError);

        wstring strMessage = ComposeErrorMessgeFromHRESULT(
                                HRESULT_FROM_WIN32(ulLastError));

        MsgBox(hWnd,
               IDS_CANTSAVE,
               MB_OK | MB_ICONERROR,
               wszSaveFileName,
               strMessage.c_str());

        hr = HRESULT_FROM_WIN32(ulLastError);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CEventLog::Clear
//
//  Synopsis:   Clear the event log, then reaquire a handle to it.
//
//  Arguments:  [wszSaveFileName] - NULL or name of file to create backup
//                                  log.
//
//  Returns:    Result of attempting to clear and reopen log.
//
//  History:    1-17-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CEventLog::Clear(LPCWSTR wszSaveFileName)
{
    TRACE_METHOD(CEventLog, Clear);
    ASSERT(_hLog);

    //
    // ClearEventLog will fail if given a save file name of an existing
    // file, so delete it first.
    //

    if (wszSaveFileName)
    {
        DeleteFile(wszSaveFileName);
    }

    BOOL fOk = ClearEventLog(_hLog, wszSaveFileName);
    HRESULT hr = S_OK;

    if (fOk)
    {
        CLogInfo *pLogInfo = _pLogInfo;

        pLogInfo->AddRef();
        {
            Close();
            hr = Open(pLogInfo);
        }
        pLogInfo->Release();
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBG_OUT_LASTERROR;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CEventLog::Close
//
//  Synopsis:   Close the event log.
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CEventLog::Close()
{
    TRACE_METHOD(CEventLog, Close);

    if (_hLog)
    {
        ASSERT(_pLogInfo);
        if (!CloseEventLog(_hLog))
        {
            DBG_OUT_LASTERROR;
        }
        _hLog = NULL;
    }

    if (_pLogInfo)
    {
        _pLogInfo->Release();
        _pLogInfo = NULL;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CEventLog::CopyRecord
//
//  Synopsis:   Return a copy of eventlog record [ulRecNo].
//
//  Arguments:  [ulRecNo] - identifies record to copy
//
//  Returns:    Copy of record or NULL.
//
//  History:    1-13-1997   DavidMun   Created
//
//  TODO: make pelr and out ptr and return HRESULT so event log cleared
//        error can be detected by the caller.
//---------------------------------------------------------------------------

EVENTLOGRECORD *
CEventLog::CopyRecord(ULONG ulRecNo)
{
    TRACE_METHOD(CEventLog, CopyRecord);

    HRESULT hr = S_OK;
    BYTE    *pbRec = NULL;
    ULONG   cbRec = 0;
    ULONG   cbRead;

    hr = SeekRead(ulRecNo, FORWARD, &pbRec, &cbRec, &cbRead);

    if (FAILED(hr))
    {
        delete [] pbRec;
        pbRec = NULL;
    }
    return (EVENTLOGRECORD *) pbRec;
}




//+--------------------------------------------------------------------------
//
//  Member:     CEventLog::GetNumberOfRecords
//
//  Synopsis:   Wrapper for GetNumberOfEventLogRecords API.
//
//  Arguments:  [pcRecs] - filled with number of records in log.
//
//  Returns:    S_OK or winerror HRESULT
//
//  Modifies:   *[pcRecs]
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CEventLog::GetNumberOfRecords(ULONG *pcRecs)
{
    TRACE_METHOD(CEventLog, GetNumberOfRecords);
    ASSERT(_hLog);

    BOOL fOk = GetNumberOfEventLogRecords(_hLog, pcRecs);

    HRESULT hr = S_OK;

    if (!fOk)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBG_OUT_LASTERROR;
        *pcRecs = 0;
    }
    else
    {
        Dbg(DEB_TRACE,
            "%s log has %u records\n",
            _pLogInfo->GetLogName(),
            *pcRecs);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CEventLog::GetOldestRecordNo
//
//  Synopsis:   Wrapper for GetOldestEventLogRecord API.
//
//  Arguments:  [pidOldest] - filled with record number of oldest record.
//
//  Returns:    S_OK or winerror HRESULT
//
//  Modifies:   *[pidOldest]
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CEventLog::GetOldestRecordNo(ULONG *pidOldest)
{
    TRACE_METHOD(CEventLog, GetOldestRecordNo);
    ASSERT(_hLog);

    BOOL fOk = GetOldestEventLogRecord(_hLog, pidOldest);

    HRESULT hr = S_OK;

    if (!fOk)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBG_OUT_LASTERROR;
        *pidOldest = 0;
    }
    else
    {
        Dbg(DEB_TRACE, "Oldest record is %u\n", *pidOldest);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CEventLog::Open
//
//  Synopsis:   Open the eventlog specified by [pLogInfo].
//
//  Arguments:  [pLogInfo] - identifies log to open
//
//  Returns:    HRESULT
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CEventLog::Open(CLogInfo *pLogInfo)
{
    TRACE_METHOD(CEventLog, Open);
    ASSERT(!_hLog);
    ASSERT(!_pLogInfo);

    HRESULT hr = S_OK;

    _pLogInfo = pLogInfo;
    _pLogInfo->AddRef();

    if (_pLogInfo->IsBackupLog())
    {
        _hLog = OpenBackupEventLog(NULL, pLogInfo->GetFileName());

        if (!_hLog)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            Dbg(DEB_ERROR,
                "CEventLog::Open: OpenBackupEventLog(%ws) error %#x\n",
                pLogInfo->GetFileName(),
                hr);
        }
    }
    else
    {
        //
        // Note that OpenEventLog wants a source name, but we give it a log
        // name.  This should work because the standard is that every log
        // has a source name subkey the same as its log name.
        //

        Dbg(DEB_TRACE,
            "CEventLog::Open: calling OpenEventLog('%s','%s')\n",
            pLogInfo->GetLogServerName() ? pLogInfo->GetLogServerName() : L"<NULL>",
            pLogInfo->GetLogName());

        _hLog = OpenEventLog(pLogInfo->GetLogServerName(),
                             pLogInfo->GetLogName());
        if (!_hLog)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            Dbg(DEB_ERROR,
                "CEventLog::Open: OpenEventLog(%s,%s) error %#x\n",
                pLogInfo->GetLogServerName() ? pLogInfo->GetLogServerName() : L"<NULL>",
                pLogInfo->GetLogName(),
                hr);
        }
    }

    if (_hLog)
    {
        Dbg(DEB_TRACE, "CEventLog::Open: got event log handle 0x%x\n", _hLog);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CEventLog::SeekRead
//
//  Synopsis:   Do an event log seek read for record [ulRecNo].
//
//  Arguments:  [ulRecNo]       - record to seek to & read
//              [ReadDirection] - FORWARD or BACKWARD
//              [ppbBuf]        - NULL or valid buffer
//              [pcbBuf]        - if [ppbBuf] non-NULL, size of [ppbBuf]
//              [pcbRead]       - filled with number of bytes read
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppbBuf], *[pcbBuf], *[pcbRead]
//
//  History:    1-13-1997   DavidMun   Created
//
//  Notes:      If [ppbBuf] is NULL, a buffer will be allocated and a pointer
//              to it placed in *[ppbBuf]; *[pcbBuf] will contain the size
//              of the allocated buffer.  Caller must free this buffer with
//              delete.
//
//---------------------------------------------------------------------------

HRESULT
CEventLog::SeekRead(
        ULONG ulRecNo,
        DIRECTION ReadDirection,
        BYTE **ppbBuf,
        ULONG *pcbBuf,
        ULONG *pcbRead)
{
    TRACE_METHOD(CEventLog, SeekRead);
    ASSERT(_hLog);

    HRESULT hr = S_OK;
    BOOL    fOk;
    ULONG   cbRequired;
    BYTE   *pbTempBuf = NULL;

    //
    // ReadEventLog ZEROES the buffer passed to it on error, but the
    // buffer is (generally) the caller's cache.  Preserve the cache on
    // error with use of a temporary buffer for the actual read.
    //

    do
    {
        if (!*ppbBuf)
        {
            //
            // Caller didn't provide a buffer.  If this is the first
            // pass through the loop, create a temp buffer for the
            // read.
            //

            if (!pbTempBuf)
            {
                pbTempBuf = new BYTE [DEFAULT_SEEKREAD_BUFSIZE];
                *pcbBuf = DEFAULT_SEEKREAD_BUFSIZE;
            }
        }
        else
        {
            ASSERT(*pcbBuf);
            pbTempBuf = new BYTE [*pcbBuf];
        }

        if (!pbTempBuf)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        fOk = ReadEventLog(_hLog,
                           EVENTLOG_SEEK_READ | ReadDirection,
                           ulRecNo,
                           pbTempBuf,
                           *pcbBuf,
                           pcbRead,
                           &cbRequired);
        if (!fOk)
        {
            LONG lError = GetLastError();

            if (lError != ERROR_INSUFFICIENT_BUFFER)
            {
                hr = HRESULT_FROM_WIN32(lError);
                DBG_OUT_HRESULT(hr);
                delete [] pbTempBuf;
                pbTempBuf = NULL;
                break;
            }

            Dbg(DEB_ITRACE,
                "CEventLog::SeekRead: Buffer size of %u is too small, growing to %u\n",
                *pcbBuf,
                cbRequired);

            delete [] pbTempBuf;
            pbTempBuf = new BYTE[cbRequired];

            if (!pbTempBuf)
            {
                *pcbBuf = 0;
                hr = E_OUTOFMEMORY;
                DBG_OUT_HRESULT(hr);
                break;
            }

            *pcbBuf = cbRequired;
        }
    }
    while (!fOk);

    if (SUCCEEDED(hr))
    {
        delete [] *ppbBuf;
        *ppbBuf = pbTempBuf;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\logcache.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       logcache.cxx
//
//  Contents:   Implementation of event log record caching class
//
//  Classes:    CLogCache
//
//  History:    12-08-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#define HIGH_SPEED_CACHE_SIZE   (64 * 1024)
#define LOW_SPEED_CACHE_SIZE    (32 * 1024)


DEBUG_DECLARE_INSTANCE_COUNTER(CLogCache)


//+--------------------------------------------------------------------------
//
//  Member:     CLogCache::CLogCache
//
//  Synopsis:   ctor
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CLogCache::CLogCache():
    _pConsole(NULL)
{
    TRACE_CONSTRUCTOR(CLogCache);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CLogCache);

#if (DBG == 1)
    _cHits = 0;
    _cMisses = 0;
#endif // (DBG == 1)

    //
    // CAUTION: the critsec should be initialized before calling
    // any other methods!
    //

    InitializeCriticalSection(&_csCache);

    //
    // CAUTION: pointers to heap should be initialized before first call to
    // _FreeResources.
    //

    _pbCache = NULL;
    _ppelrIndex = NULL;

    _FreeResources();
}



//+--------------------------------------------------------------------------
//
//  Member:     CLogCache::~CLogCache
//
//  Synopsis:   dtor
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CLogCache::~CLogCache()
{
    TRACE_DESTRUCTOR(CLogCache);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CLogCache);

#if (DBG == 1)
    ULONG cAccesses = _cHits + _cMisses;

    if (cAccesses)
    {
        Dbg(DEB_TRACE,
            "Raw Record Cache(%x) hits=%u (%u%%), misses=%u\n",
            this,
            _cHits,
            MulDiv(100, _cHits, cAccesses),
            _cMisses);
    }
#endif // (DBG == 1)

    Close();
    DeleteCriticalSection(&_csCache);
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogCache::Close
//
//  Synopsis:   Close the event log and free all cache memory.
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CLogCache::Close()
{
    TRACE_METHOD(CLogCache, Close);

    CAutoCritSec Lock(&_csCache);
    _FreeResources();
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogCache::Reset
//
//  Synopsis:   Close and reopen the cache on the current log, using the
//              read direction specified.
//
//  Arguments:  [ReadDirection] - new read direction
//
//  Returns:    S_OK    - cache closed & reopened
//              S_FALSE - cache not open, no-op
//              E_*     - error from Open method
//
//  History:    2-12-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CLogCache::Reset(
    DIRECTION ReadDirection)
{
    TRACE_METHOD(CLogCache, Reset);

    CLogInfo *pliSaved = _Log.GetLogInfo();

    if (!pliSaved)
    {
        return S_OK;
    }

    Close();
    return Open(pliSaved, ReadDirection);
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogCache::Next
//
//  Synopsis:   Advance the internal current record pointer to the next
//              record in the log.
//
//  Returns:    S_FALSE - the pointer cannot be advanced further
//              S_OK    - pointer advanced
//              E_*     - read error
//
//  History:    1-17-1997   DavidMun   Created
//
//  Notes:      If the current record pointer has not been set since the
//              last Open, set it to the initial record.
//
//              The read direction determines the initial record and
//              direction of advance.
//
//---------------------------------------------------------------------------

HRESULT
CLogCache::Next()
{
    //
    // If there is already a current record, move to the next record, as
    // determined by the read direction.
    //

    if (_pCurRec)
    {
        ULONG ulRecNo = _pCurRec->RecordNumber;

        if (_ReadDirection == FORWARD)
        {
            ulRecNo++;

            if (ulRecNo >= _ulOldestRecNoInLog + _cRecsInLog)
            {
                return S_FALSE;
            }
        }
        else
        {
            ulRecNo--;

            if (ulRecNo < _ulOldestRecNoInLog)
            {
                return S_FALSE;
            }
        }

        return Seek(ulRecNo);
    }

    //
    // There's no current record.  If the log is empty, indicate "eof"
    //

    if (!_cRecsInLog)
    {
        return S_FALSE;
    }

    //
    // Position at the oldest or youngest record in the log, as specified by
    // the read direction.
    //

    if (_ReadDirection == FORWARD)
    {
        return Seek(_ulOldestRecNoInLog);
    }

    return Seek(_ulOldestRecNoInLog + _cRecsInLog - 1);
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogCache::Open
//
//  Synopsis:   Open the cache on the log specified by [pLogInfo].
//
//  History:    12-14-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CLogCache::Open(
    CLogInfo *pLogInfo,
    DIRECTION ReadDirection)
{
    TRACE_METHOD(CLogCache, Open);

    HRESULT hr = S_OK;

    do
    {
        _fLowSpeed = pLogInfo->GetLowSpeed();
        _ReadDirection = ReadDirection;

        hr = _Log.Open(pLogInfo);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = _Log.GetNumberOfRecords(&_cRecsInLog);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = _Log.GetOldestRecordNo(&_ulOldestRecNoInLog);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogCache::_SearchCache
//
//  Synopsis:   Search for record number [ulRecNo] in the cache, and return
//              a pointer to it if found.
//
//  Arguments:  [ulRecNo] - event log record number to search for
//
//  Returns:    Pointer to event log structure with RecordNumber value of
//              [ulRecNo], or NULL if no such record is in cache.
//
//  History:    12-09-1996   DavidMun   Created
//
//  Notes:      CAUTION: caller must take _csCache
//
//---------------------------------------------------------------------------

inline EVENTLOGRECORD *
CLogCache::_SearchCache(
    ULONG ulRecNo)
{
    if (_ReadDirection == FORWARD)
    {
        // record numbers are INCREASING from first to last

        if (ulRecNo >= _ulFirstRecNoInCache && ulRecNo <= _ulLastRecNoInCache)
        {
            return _ppelrIndex[ulRecNo - _ulFirstRecNoInCache];
        }
        return NULL;

    }

    // record numbers are DECREASING from first to last

    if (ulRecNo <= _ulFirstRecNoInCache && ulRecNo >= _ulLastRecNoInCache)
    {
        return _ppelrIndex[_ulFirstRecNoInCache - ulRecNo];
    }

    return NULL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogCache::Seek
//
//  Synopsis:   Attempt to position the current record pointer within the
//              cache to point at a record with number [ulRecNo], reading
//              from the event log if necessary.
//
//  Arguments:  [ulRecNo] -
//
//  Returns:    S_OK - record [ulRecNo] exists within the cache and will
//                      be the source of data for the next Get* calls.
//              E_*  - record does not exist in cache and could not be
//                      loaded from disk.
//
//  Modifies:   Cache.
//
//  History:    12-09-1996   DavidMun   Created
//              12-16-1996   DavidMun   Add 'back up' logic for when we
//                                       miss a record just before the
//                                       start of records in the cache.
//
//---------------------------------------------------------------------------

HRESULT
CLogCache::Seek(
    ULONG ulRecNo)
{
    //TRACE_METHOD(CLogCache, Seek);

    //
    // Lock down the cache so it can't change while we're searching or
    // filling it.
    //

    CAutoCritSec Lock(&_csCache);

    //
    // See if the requested record is in the cache.
    //

    _pCurRec = _SearchCache(ulRecNo);

    if (_pCurRec)
    {
        // Yes, we found it so are done.

#if (DBG == 1)
        _cHits++;  // found requested record :-)
#endif
        return S_OK;
    }

#if (DBG == 1)
        _cMisses++;  // requested record not in cache :-(
#endif

    //
    // _pCurRec is now NULL.
    //
    // The requested record is not in the cache.  Read a chunk of
    // records from the log that contain the requested record.
    //
    // If the miss was before the first record in the log, read
    // further upstream than that.  Otherwise, read from the
    // requested record on.
    //

    Dbg(DEB_TRACE, "Cache(%x) miss on record %u\n", this, ulRecNo);

    ULONG ulRecNoToRead = ulRecNo;

    if (_ReadDirection == FORWARD)
    {
        if (ulRecNo < _ulFirstRecNoInCache)
        {
            ULONG cRecsToBackUp = (_ulLastRecNoInCache - _ulFirstRecNoInCache) / 2;

            if (cRecsToBackUp > ulRecNoToRead ||
                (ulRecNoToRead - cRecsToBackUp) < _ulOldestRecNoInLog)
            {
                ulRecNoToRead = _ulOldestRecNoInLog;
            }
            else
            {
                ulRecNoToRead -= cRecsToBackUp;
            }
        }
    }
    else
    {
        if (ulRecNo > _ulFirstRecNoInCache)
        {
            ULONG ulNewest = _ulOldestRecNoInLog + _cRecsInLog - 1;

            ULONG cRecsToBackUp = (_ulFirstRecNoInCache - _ulLastRecNoInCache) / 2;

            if (ulRecNoToRead + cRecsToBackUp > ulNewest)
            {
                ulRecNoToRead = ulNewest;
            }
            else
            {
                ulRecNoToRead += cRecsToBackUp;
            }
        }
    }

    HRESULT hr = S_OK;

    Dbg(DEB_TRACE, "Reading record %u\n", ulRecNoToRead);
    hr = _SeekRead(ulRecNoToRead);

    if (FAILED(hr))
    {
        //
        // Perhaps the log has been cleared, or it's on a remote machine
        // and the network connection is broken.  Also could be out of
        // memory.
        //
        return hr;
    }

    //
    // We read the cache OK, so now see if we got the record we
    // originally missed.
    //

    _pCurRec = _SearchCache(ulRecNo);
    ASSERT(_pCurRec || ulRecNoToRead != ulRecNo);

    if (!_pCurRec && ulRecNoToRead != ulRecNo)
    {
        //
        // Our fancy backup strategy backfired.  we backed up too far
        // and didn't get the record that caused the miss in the
        // first place.  Count this as another miss and just read
        // starting at the requested record number.
        //

#if (DBG == 1)
        _cMisses++;
        Dbg(DEB_TRACE, "Backup read missed, reading %u\n", ulRecNo);
#endif

        hr = _SeekRead(ulRecNo);

        if (SUCCEEDED(hr))
        {
            _pCurRec = _SearchCache(ulRecNo);
            ASSERT(_pCurRec);
        }
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogCache::CopyRecFromCache
//
//  Synopsis:   Return a copy of record [ulRecNo] if it is in the cache,
//              or NULL if it isn't in the cache.
//
//  Arguments:  [ulRecNo] - record number to copy
//
//  Returns:    Copy of EVENTLOGRECORD [ulRecNo], or NULL if record can't
//              be found or there is insufficient memory to copy the record.
//
//  History:    12-14-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

EVENTLOGRECORD *
CLogCache::CopyRecFromCache(
    ULONG ulRecNo)
{
    TRACE_METHOD(CLogCache, CopyRecFromCache);

    EVENTLOGRECORD *pelrCopy = NULL;

    //
    // Lock down the cache so the search/read operations are atomic
    //

    CAutoCritSec Lock(&_csCache);

    do
    {
        //
        // Search for caller's record.  If it isn't in the cache, bail.
        //

        EVENTLOGRECORD *pelrOriginal = _SearchCache(ulRecNo);

        if (!pelrOriginal)
        {
            break;
        }

        pelrCopy = (EVENTLOGRECORD *)new BYTE[pelrOriginal->Length];

        if (pelrCopy)
        {
            CopyMemory(pelrCopy, pelrOriginal, pelrOriginal->Length);
        }
        else
        {
            DBG_OUT_HRESULT(E_OUTOFMEMORY);
        }
    } while (0);

    return pelrCopy;
}



//+--------------------------------------------------------------------------
//
//  Member:     CLogCache::_FreeResources
//
//  Synopsis:   Close the event log, free all memory, and reset all members
//              to initial state.
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID CLogCache::_FreeResources()
{
    TRACE_METHOD(CLogCache, _FreeResources);

    _Log.Close();
    delete [] _pbCache;
    _pbCache = NULL;
    _cbCache = 0;
    delete [] _ppelrIndex;
    _ppelrIndex = NULL;
    _cpIndex = 0;
    _fLowSpeed = FALSE;
    _pCurRec = NULL;
    _ulFirstRecNoInCache = 0;
    _ulLastRecNoInCache = 0;
    _ReadDirection = FORWARD;
    _wszLastReturnedString[0] = L'\0';
    _cRecsInLog = 0;
    _ulOldestRecNoInLog = 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogCache::_SeekRead
//
//  Synopsis:   Read a cache-load of records from the event log such that
//              record [ulRecNo] is included among them.
//
//  Arguments:  [ulRecNo] - record number to ensure will appear in cache
//
//  Returns:    S_OK - cache contains record with number [ulRecNo].
//              E_OUTOFMEMORY - couldn't allocate cache
//              E_*  - couldn't read cache or record no longer exists.
//
//  History:    12-09-1996   DavidMun   Created
//
//  Notes:      CAUTION: caller must take _csCache
//
//---------------------------------------------------------------------------

HRESULT
CLogCache::_SeekRead(
    ULONG ulRecNo)
{
    TRACE_METHOD(CLogCache, _SeekRead);

    HRESULT hr = S_OK;
    ULONG   cbRead;

    do
    {
        if (!_pbCache)
        {
            ASSERT(!_cpIndex);
            ASSERT(!_ppelrIndex);
            ASSERT(!_ulFirstRecNoInCache);
            ASSERT(!_ulLastRecNoInCache);

            if (_fLowSpeed)
            {
                _cbCache = LOW_SPEED_CACHE_SIZE;
            }
            else
            {
                _cbCache = HIGH_SPEED_CACHE_SIZE;
            }

            _pbCache = new BYTE[_cbCache];

            if (!_pbCache)
            {
                hr = E_OUTOFMEMORY;
                DBG_OUT_HRESULT(hr);
                break;
            }
        }

        hr = _Log.SeekRead(ulRecNo,
                           _ReadDirection,
                           &_pbCache,
                           &_cbCache,
                           &cbRead);

        //
        // 11/16/00 JonN 234391
        // Event Viewer: Handle ReadEventLog hidden failure with corrupt log per 27859
        //
        if (!FAILED(hr))
        {
            ULONG tmpFirstRecNoInCache = ((EVENTLOGRECORD*)_pbCache)->RecordNumber;
            ULONG tmpcbLastRecord = *(DWORD *)(_pbCache + cbRead - sizeof(DWORD));
            ULONG tmpLastRecNoInCache = ((EVENTLOGRECORD*)
                        (_pbCache + cbRead - tmpcbLastRecord))->RecordNumber;
            ULONG lower = (_ReadDirection == FORWARD)
                ? tmpFirstRecNoInCache : tmpLastRecNoInCache;
            ULONG upper = (_ReadDirection == FORWARD)
                ? tmpLastRecNoInCache : tmpFirstRecNoInCache;
            // CODEWORK should preserve these values rather than
            // recalculating them below
            if (   (lower > upper)
                || (ulRecNo < lower)
                || (ulRecNo > upper) )
            {
                ASSERT(FALSE && L"Invalid record numbers retrieved");
                hr = HRESULT_FROM_WIN32(ERROR_EVENTLOG_FILE_CORRUPT);
                delete [] _pbCache;
                _pbCache = NULL;
                _cbCache = cbRead = 0;
                // fall through to FILE_CORRUPT handler below
            }
        }

        if (hr == HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) ||
            hr == HRESULT_FROM_WIN32(ERROR_EVENTLOG_FILE_CORRUPT) ||
            hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF) || // NTRAID#NTBUG9-549851-2002/05/07-ericb
            hr == HRESULT_FROM_WIN32(ERROR_EVENTLOG_FILE_CHANGED))
        {
            LOGDATACHANGE ldc = LDC_RECORDS_CHANGED;

            if (hr == HRESULT_FROM_WIN32(ERROR_EVENTLOG_FILE_CORRUPT) ||
                hr == HRESULT_FROM_WIN32(ERROR_HANDLE_EOF)) // NTRAID#NTBUG9-549851-2002/05/07-ericb)
            {
                //
                // Assume that the records from the oldest record up to
                // but not including the one we tried to seek to and read
                // (ulRecNo) are valid.
                //

                _cRecsInLog = ulRecNo - _ulOldestRecNoInLog;
                ldc = LDC_CORRUPT;
            }
            else
            {
                HRESULT hr2;

                // JonN 4/23/01 375800
                ULONG ulPrevOldestRecNoInLog = _ulOldestRecNoInLog;
                ULONG cPrevRecsInLog = _cRecsInLog;

                hr2 = _Log.GetOldestRecordNo(&_ulOldestRecNoInLog);
                CHECK_HRESULT(hr2);

                hr2 = _Log.GetNumberOfRecords(&_cRecsInLog);
                CHECK_HRESULT(hr2);

                if (!_cRecsInLog || !_ulOldestRecNoInLog)
                {
                    _cRecsInLog = _ulOldestRecNoInLog = 0;
                    _ulFirstRecNoInCache = _ulLastRecNoInCache = 0;
                }
                // JonN 4/23/01 375800
                else if (ulPrevOldestRecNoInLog == _ulOldestRecNoInLog
                      && cPrevRecsInLog == _cRecsInLog)
                {
                    _cRecsInLog = _ulOldestRecNoInLog = 0;
                    _ulFirstRecNoInCache = _ulLastRecNoInCache = 0;
                    ldc = LDC_CORRUPT;
                }
            }

            g_SynchWnd.Post(ELSM_LOG_DATA_CHANGED,
                            ldc,
                            (LPARAM) _Log.GetLogInfo());
            break;
        }

        if (FAILED(hr))
        {
            _ulFirstRecNoInCache = _ulLastRecNoInCache = 0;
            break;
        }

        //
        // Update the members that have the range of record numbers contained
        // in the buffer.  Since it is full of EVENTLOGRECORD structures,
        // the first and last dwords of all the bytes read must be record
        // numbers.
        //

        _ulFirstRecNoInCache = ((EVENTLOGRECORD*)_pbCache)->RecordNumber;

        ULONG cbLastRecord;

        cbLastRecord = *(DWORD *)(_pbCache + cbRead - sizeof(DWORD));
        _ulLastRecNoInCache = ((EVENTLOGRECORD*)
                        (_pbCache + cbRead - cbLastRecord))->RecordNumber;

        Dbg(DEB_TRACE,
            "CLogCache::_SeekRead: caching %u-%u\n",
            _ulFirstRecNoInCache,
            _ulLastRecNoInCache);

        //
        // See how many records we got, so we can tell whether the existing
        // offset array is big enough.
        //

        ULONG cRecs;

        if (_ReadDirection == FORWARD)
        {
            ASSERT(_ulFirstRecNoInCache <= _ulLastRecNoInCache);
            ASSERT(ulRecNo >= _ulFirstRecNoInCache && ulRecNo <= _ulLastRecNoInCache);

            cRecs = _ulLastRecNoInCache - _ulFirstRecNoInCache + 1;
        }
        else
        {
            ASSERT(_ulFirstRecNoInCache >= _ulLastRecNoInCache);
            ASSERT(ulRecNo <= _ulFirstRecNoInCache && ulRecNo >= _ulLastRecNoInCache);

            cRecs = _ulFirstRecNoInCache - _ulLastRecNoInCache + 1;
        }

        //
        // If the index has enough room for pointers to all the records
        // we read, update it and quit.
        //

        if (cRecs <= _cpIndex)
        {
            _GenerateRecIndex(cRecs);
            break;
        }

        //
        // Must grow the index.
        //

        delete [] _ppelrIndex;
        _ppelrIndex = new PEVENTLOGRECORD [cRecs];

        if (!_ppelrIndex)
        {
            _cpIndex = 0;
            delete [] _pbCache;
            _pbCache = NULL;
            _ulFirstRecNoInCache = _ulLastRecNoInCache = 0;
            Dbg(DEB_ERROR,
                "CLogCache::_SeekRead out of memory, discarding cache\n");
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        _cpIndex = cRecs;
        _GenerateRecIndex(cRecs);
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogCache::_GenerateRecIndex
//
//  Synopsis:   Fill in the array of pointers into the cache.
//
//  Arguments:  [cRecs] - number of records in cache
//
//  History:    1-13-1997   DavidMun   Created
//
//  Notes:      Since the cache always contains consecutive records of
//              varying length, and the record numbers of the first and last
//              records in the cache are known, the cache can return a
//              pointer to the start of a desired record much faster if it
//              simply returns the correct array value, instead of hopping
//              through the cache the appropriate number of records.  This
//              makes cache hits faster, but misses slower, since this
//              routine must be called every time the cache is reloaded.
//
//---------------------------------------------------------------------------

VOID
CLogCache::_GenerateRecIndex(
    ULONG cRecs)
{
    ULONG i;
    EVENTLOGRECORD *pelr= (EVENTLOGRECORD *)_pbCache;
    PEVENTLOGRECORD *ppelr = _ppelrIndex;

    for (i = 0; i < cRecs; i++)
    {
        *ppelr++ = pelr;
        pelr = (EVENTLOGRECORD *) (((BYTE *) pelr) + pelr->Length);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\literec.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       literec.cxx
//
//  Contents:   Implementation of class to maintain a cache of stripped-down
//              event log records.
//
//  Classes:    CLightRecCache
//
//  History:    07-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


#define LIGHT_REC_CACHE_ENTRIES 500




//+--------------------------------------------------------------------------
//
//  Member:     CLightRecCache::_FillRecord
//
//  Synopsis:   Initialize light record [pRec] from raw event log record
//              [pelr].
//
//  Arguments:  [pRec] - record to init
//              [pelr] - raw event log record
//
//  Modifies:   *[pRec]
//
//  History:    07-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CLightRecCache::_FillRecord(
    LIGHT_RECORD *pRec,
    EVENTLOGRECORD *pelr)
{
    // TRACE_METHOD(CLightRecCache, _FillRecord);
    ASSERT(pRec);
    ASSERT(pelr);
    ASSERT(_pli);

    CSources *pSources = _pli->GetSources();
    LPWSTR pwszSource = ::GetSourceStr(pelr);
    ASSERT(pwszSource);

    pRec->hSource = pSources->GetSourceHandle(pwszSource);

#if (DBG == 1)
    //
    // Round trip conversion should yield same string
    //

    LPCWSTR pwszFromSources = pSources->GetSourceStrFromHandle(pRec->hSource);

    if (lstrcmpi(pwszSource, pwszFromSources))
    {
        Dbg(DEB_ERROR,
            "*** Error _FillRecord: original source str '%ws' became '%ws'\n",
            pwszSource,
            pwszFromSources);
    }
#endif // (DBG == 1)

    pRec->ulTimeGenerated = pelr->TimeGenerated;
    pRec->usCategory = pelr->EventCategory;

    {
        WCHAR wszUser[CCH_USER_MAX];
        ::GetUserStr(pelr, wszUser, ARRAYLEN(wszUser), FALSE);
        pRec->hUser = _pssUserName->GetHandle(wszUser);
    }

    pRec->hComputer = _pssComputerName->GetHandle(::GetComputerStr(pelr));
    pRec->usEventID = LOWORD(pelr->EventID);

    switch (pelr->EventType)
    {
    case EVENTLOG_AUDIT_SUCCESS:
        pRec->bType = IDX_RDI_BMP_SUCCESS_AUDIT;
        break;

    case EVENTLOG_AUDIT_FAILURE:
        pRec->bType = IDX_RDI_BMP_FAIL_AUDIT;
        break;

    default:
        Dbg(DEB_ERROR,
            "Unknown event type 0x%x in record number %uL\n",
            pelr->EventType,
            pelr->RecordNumber);
        // fall through
    case EVENTLOG_SUCCESS:
    case EVENTLOG_INFORMATION_TYPE:
        pRec->bType = IDX_RDI_BMP_INFO;
        break;

    case EVENTLOG_WARNING_TYPE:
        pRec->bType = IDX_RDI_BMP_WARNING;
        break;

    case EVENTLOG_ERROR_TYPE:
        pRec->bType = IDX_RDI_BMP_ERROR;
        break;
    }

    pRec->bFlags = LR_VALID;

    if (pelr->DataLength)
    {
        pRec->bFlags |= LR_HAS_DATA;
    }

    if (pelr->NumStrings)
    {
        pRec->bFlags |= LR_HAS_STRINGS;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CLightRecCache::CLightRecCache
//
//  Synopsis:   ctor
//
//  History:    07-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CLightRecCache::CLightRecCache():
    _plrBufStart(NULL),
    _plrBufEnd(NULL),
    _plrHead(NULL),
    _plrCur(NULL),
    _plrTail(NULL),
    _cRecs(0),
    _idxStart(0),
    _pli(NULL),
    _pRecList(NULL),
    _pLogCache(NULL)
{
    TRACE_CONSTRUCTOR(CLightRecCache);

    _wszLastReturnedString[0] = L'\0';

#if (DBG == 1)
    _cHits = 0;
    _cMisses = 0;
#endif // (DBG == 1)
}



//+--------------------------------------------------------------------------
//
//  Member:     CLightRecCache::~CLightRecCache
//
//  Synopsis:   dtor
//
//  History:    07-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CLightRecCache::~CLightRecCache()
{
    TRACE_DESTRUCTOR(CLightRecCache);

    delete [] _plrBufStart;

#if (DBG == 1)
    ULONG cAccesses = _cHits + _cMisses;

    if (cAccesses)
    {
        Dbg(DEB_TRACE,
            "Light Record Cache(%x) hits=%u (%u%%), misses=%u\n",
            this,
            _cHits,
            MulDiv(100, _cHits, cAccesses),
            _cMisses);
    }
#endif // (DBG == 1)
}



//+--------------------------------------------------------------------------
//
//  Member:     CLightRecCache::Init
//
//  Synopsis:   Complete initialization of this.
//
//  Arguments:  [pRecList]        - pointer to sibling object
//              [pRecordCache]    - pointer to sibling object
//              [pssComputerName] - pointer to sibling object
//              [pssUserName]     - pointer to sibling object
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  History:    07-14-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CLightRecCache::Init(
    CRecList    *pRecList,
    CLogCache   *pRecordCache,
    CSharedStringArray *pssComputerName,
    CSharedStringArray *pssUserName)
{
    TRACE_METHOD(CLightRecCache, Init);

    _pRecList = pRecList;
    _pLogCache = pRecordCache;
    _pssComputerName = pssComputerName;
    _pssUserName = pssUserName;

    _plrBufStart = new LIGHT_RECORD[LIGHT_REC_CACHE_ENTRIES];

    if (!_plrBufStart)
    {
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    _plrBufEnd = _plrBufStart + LIGHT_REC_CACHE_ENTRIES - 1;
    _cRecs = LIGHT_REC_CACHE_ENTRIES;
    _plrHead = _plrBufStart;
    _plrTail = _plrBufEnd;
    ZeroMemory(_plrBufStart, _cRecs * sizeof(LIGHT_RECORD));
    return S_OK;
}



//+--------------------------------------------------------------------------
//
//  Member:     CLightRecCache::_InvalidateRange
//
//  Synopsis:   Mark records in specified range (inclusive) as invalid.
//
//  History:    07-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CLightRecCache::_InvalidateRange(
    LIGHT_RECORD *plrFirst,
    LIGHT_RECORD *plrLast)
{
    if (plrFirst <= plrLast)
    {
        LIGHT_RECORD *plr;

        for (plr = plrFirst; plr <= plrLast; plr++)
        {
            if (plr->bFlags & LR_VALID)
            {
                _pssComputerName->ReleaseHandle(plr->hComputer);
                _pssUserName->ReleaseHandle(plr->hUser);
                plr->bFlags = 0;
            }
        }
    }
    else
    {
        _InvalidateRange(plrFirst, _plrBufEnd);
        _InvalidateRange(_plrBufStart, plrLast);
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CLightRecCache::Close
//
//  Synopsis:   Stop focussing on loginfo specified in Open.
//
//  History:    07-14-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CLightRecCache::Close()
{
    TRACE_METHOD(CLightRecCache, Close);

    _pli = NULL;
    _idxStart = 0;
    _plrHead = _plrBufStart;
    _plrTail = _plrBufEnd;

    if (_plrBufStart)
    {
        _InvalidateAll();
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CLightRecCache::_BufPtrAdd
//
//  Synopsis:   Add [ul] to circular buffer pointer [plr].
//
//  Arguments:  [plr] - pointer into buffer
//              [ul]  - amount to add
//
//  Returns:    new pointer value
//
//  History:    07-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LIGHT_RECORD *
CLightRecCache::_BufPtrAdd(
    LIGHT_RECORD *plr,
    ULONG ul)
{
    plr += ul;

    if (plr > _plrBufEnd)
    {
        plr = _plrBufStart + (plr - _plrBufEnd);
    }
    ASSERT(plr >= _plrBufStart && plr <= _plrBufEnd);
    return plr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLightRecCache::_BufPtrSub
//
//  Synopsis:   Subtract [ul] from circular buffer pointer [plr].
//
//  Arguments:  [plr] - pointer into buffer
//              [ul]  - amount to subtract
//
//  Returns:    new pointer value
//
//  History:    07-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LIGHT_RECORD *
CLightRecCache::_BufPtrSub(
    LIGHT_RECORD *plr,
    ULONG ul)
{
    plr -= ul;

    if (plr < _plrBufStart)
    {
        plr = _plrBufEnd - (_plrBufStart - plr);
    }
    ASSERT(plr >= _plrBufStart && plr <= _plrBufEnd);
    return plr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLightRecCache::SeekToRecNo
//
//  Synopsis:   Set the internal current record pointer to the cached item
//              for event log record number [ulRecNo].
//
//  Arguments:  [ulRecNo] - record number to search for
//
//  Returns:    S_OK - pointer positioned successfully
//              E_*  - record [ulRecNo] no longer available
//
//  History:    07-07-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CLightRecCache::SeekToRecNo(
    ULONG ulRecNo)
{
    ULONG ulIndex;
    HRESULT hr = _pRecList->RecNoToIndex(ulRecNo, &ulIndex);

    if (SUCCEEDED(hr))
    {
        hr = SeekToIndex(ulIndex);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLightRecCache::SeekToIndex
//
//  Synopsis:   Set the internal current record pointer to the cached item
//              representing listview index [idxSeekTo].
//
//  Arguments:  [idxSeekTo] - target listview index
//
//  Returns:    S_OK
//
//  History:    07-15-1997   DavidMun   Created
//              06-29-2000   DavidMun   Never return failure; simply remove
//                                        unavailable records from cache.
//
//---------------------------------------------------------------------------

HRESULT
CLightRecCache::SeekToIndex(
    ULONG idxSeekTo)
{
    // TRACE_METHOD(CLightRecCache, SeekToIndex);
    ASSERT(_plrBufStart);
    ASSERT(_cRecs);
    ASSERT(_cRecs == _plrBufEnd - _plrBufStart + 1UL);

    if (idxSeekTo < _idxStart)
    {
        //
        // List view index lies outside range of those being cached.
        // Specifically, it is less than the start of the range, so the range
        // must be moved left so it starts at idxSeekTo.
        //
        // If, after moving, the right end of the range overlaps with the
        // left end of the pre-move range, then the overlapping entries will
        // still be valid in the moved range.  In that case, mark all entries
        // between idxSeekTo and the first overlapping record as invalid.
        //
        // If there is no overlap then reset the pointers and mark all
        // entries other than idxSeekTo as invalid.
        //

        ULONG cRecsToShift = _idxStart - idxSeekTo;

        if (cRecsToShift < _cRecs)
        {
            LIGHT_RECORD *plrEndInvalidRange;

            //
            // New range overlaps old one.  Figure out what to mark as
            // invalid.  Note the record we're trying to seek to is marked
            // as invalid, it will be read later.
            //

            plrEndInvalidRange = _BufPtrSub(_plrHead, 1);
            _plrHead = _BufPtrSub(_plrHead, cRecsToShift);
            ASSERT(_plrHead >= _plrBufStart && _plrHead <= _plrBufEnd);

            _InvalidateRange(_plrHead, plrEndInvalidRange);
            _plrTail = _BufPtrSub(_plrTail, cRecsToShift);
            ASSERT(_plrTail >= _plrBufStart && _plrTail <= _plrBufEnd);

            _plrCur = _plrHead;
            _idxStart = idxSeekTo;
        }
        else
        {
            //
            // There's no overlap between the currently cached range of
            // listview indexes and the range of indexes starting with
            // idxSeekTo.  Reset the pointers and invalidate the entire
            // cache.
            //

            _plrHead = _plrBufStart;
            _plrTail = _plrBufEnd;
            _InvalidateAll();

            //
            // If the range 0.._cRecs contains idxSeekTo, then set
            // _idxStart to 0.  Otherwise, set _idxStart to idxSeekTo.
            //

            if (idxSeekTo < _cRecs)
            {
                _idxStart = 0;
                _plrCur = _plrHead + idxSeekTo;
                ASSERT(_plrCur >= _plrHead && _plrCur <= _plrTail);
            }
            else
            {
                _idxStart = idxSeekTo;
                _plrCur = _plrHead;
            }
        }
    }
    else if (idxSeekTo >= (_idxStart + _cRecs))
    {
        //
        // Desired list view index lies to right of last record in cache.
        // See if there's any overlap with the currently cached range.
        //

        ULONG cRecsToShift = idxSeekTo - (_idxStart + _cRecs - 1);

        if (cRecsToShift < _cRecs)
        {
            LIGHT_RECORD *plrStartInvalidRange;

            //
            // Yes, if we make the last listview index in the cache
            // idxSeekTo, then at least one of the entries at the start
            // of the cache will be valid.
            //

            plrStartInvalidRange = _plrHead;
            _plrHead = _BufPtrAdd(_plrHead, cRecsToShift);
            ASSERT(_plrHead >= _plrBufStart && _plrHead <= _plrBufEnd);

            _InvalidateRange(plrStartInvalidRange, _plrHead);
            _plrTail = _BufPtrAdd(_plrTail, cRecsToShift);
            ASSERT(_plrTail >= _plrBufStart && _plrTail <= _plrBufEnd);

            _plrCur = _plrTail;
            _idxStart = idxSeekTo - (_cRecs - 1);
        }
        else
        {
            // no overlap

            _plrHead = _plrBufStart;
            _plrTail = _plrBufEnd;
            _InvalidateAll();

            if (idxSeekTo < _cRecs)
            {
                _idxStart = 0;
                _plrCur = _plrHead + idxSeekTo;
            }
            else
            {
                _idxStart = idxSeekTo;
                _plrCur = _plrHead;
            }

            ASSERT(_plrCur >= _plrHead && _plrCur <= _plrTail);
        }
    }
    else
    {
        ASSERT(_plrHead >= _plrBufStart && _plrHead <= _plrBufEnd);
        ASSERT(_plrTail >= _plrBufStart && _plrTail <= _plrBufEnd);

        _plrCur = _BufPtrAdd(_plrHead, idxSeekTo - _idxStart);

#if (DBG == 1)
        if (_plrHead < _plrTail)
        {
            ASSERT(_plrCur >= _plrHead && _plrCur <= _plrTail);
        }
        else
        {
            ASSERT( (_plrCur >= _plrHead && _plrCur <= _plrBufEnd) ||
                    (_plrCur >= _plrBufStart && _plrCur <= _plrTail) );
        }
#endif // (DBG == 1)
    }

    //
    // _plrCur points to the record in the cache that represents idxSeekTo.
    // If that record has been read into the cache, the seek has succeeded.
    //

    if (_plrCur->bFlags & LR_VALID)
    {
#if (DBG == 1)
        _cHits++;
#endif // (DBG == 1)
        return S_OK;
    }

#if (DBG == 1)
    _cMisses++;
#endif // (DBG == 1)

    //
    // Try to bring the record into the light record cache.  First get it
    // into the raw record cache.
    //

    HRESULT hr;
    hr = _pLogCache->Seek(_pRecList->IndexToRecNo(idxSeekTo));

    if (SUCCEEDED(hr))
    {
        ASSERT(_pLogCache->GetCurRec());
        //
        // Now copy from the raw to the light cache.
        //

        _FillRecord(_plrCur, _pLogCache->GetCurRec());
        return S_OK;
    }
    DBG_OUT_HRESULT(hr);

    //
    // Seek to record failed.  the Seek method we just called has posted
    // the ELSM_LOG_DATA_CHANGED to the sync window before returning.
    // Tell the record list that it should discard the record corresponding
    // to idxSeekTo and all records older than that.
    //

    if (_pLogCache->GetOldestRecordNo())
    {
        _pRecList->Discard(_pLogCache->GetOldestRecordNo() - 1);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLightRecCache::GetColumnString
//
//  Synopsis:   Return the string value for column [lrc] for the current
//              record.
//
//  Arguments:  [lrc] - desired column
//
//  Returns:    requested string, or L"" on failure
//
//  History:    07-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LPWSTR
CLightRecCache::GetColumnString(
    LOG_RECORD_COLS lrc)
{
    // TRACE_METHOD(CLightRecCache, GetColumnString);

    switch (lrc)
    {
    case RECORD_COL_TYPE:
        return g_awszEventType[_plrCur->bType - IDX_RDI_BMP_SUCCESS_AUDIT];

    case RECORD_COL_DATE:
        return ::GetDateStr(_plrCur->ulTimeGenerated,
                            _wszLastReturnedString,
                            MAX_LISTVIEW_STR);

    case RECORD_COL_TIME:
        return ::GetTimeStr(_plrCur->ulTimeGenerated,
                            _wszLastReturnedString,
                            MAX_LISTVIEW_STR);

    case RECORD_COL_SOURCE:
        return (LPWSTR) GetSourceStr();

    case RECORD_COL_CATEGORY:
        if (!_plrCur->usCategory)
        {
            return g_wszNone;
        }
        else
        {
            CSources *pSrc= _pli->GetSources();
            LPWSTR pwszSrc = (LPWSTR) pSrc->GetSourceStrFromHandle(_plrCur->hSource);
            CCategories *pCat = pSrc->GetCategories(pwszSrc);

            if (pCat)
            {
                return (LPWSTR) pCat->GetName(_plrCur->usCategory);
            }
            else
            {
                wsprintf(_wszLastReturnedString, L"(%u)", _plrCur->usCategory);
                return _wszLastReturnedString;
            }
        }

    case RECORD_COL_EVENT:
        return ::GetEventIDStr(_plrCur->usEventID,
                               _wszLastReturnedString,
                               MAX_LISTVIEW_STR);

    case RECORD_COL_USER:
        return GetUserStr();

    case RECORD_COL_COMPUTER:
        return GetComputerStr();

    default:
        ASSERT(FALSE);
        return L"";
    }
}




#if (DBG == 1)

#define MAX_ULONG ((ULONG) -1)

//+--------------------------------------------------------------------------
//
//  Member:     CLightRecCache::Dump
//
//  Synopsis:   Dump information about the contents of the light record cache
//              to the debugger.
//
//  History:    07-16-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CLightRecCache::Dump()
{
    Dbg(DEB_FORCE, "Dumping Light Record Cache at 0x%x:\n", this);
    ULONG cAccesses = _cHits + _cMisses;

    if (cAccesses)
    {
        Dbg(DEB_FORCE, "  hits=%u (%u%%), misses=%u\n",
            _cHits,
            MulDiv(100, _cHits, cAccesses),
            _cMisses);
    }
    else
    {
        Dbg(DEB_FORCE, "  No cache hits or misses\n");
    }
    Dbg(DEB_FORCE, "  First cached index = %uL\n", _idxStart);
    Dbg(DEB_FORCE, "  Size of cache, in recs = %uL\n", _cRecs);
    Dbg(DEB_FORCE, "  _plrBufStart = 0x%x\n", _plrBufStart);
    Dbg(DEB_FORCE, "  _plrBufEnd = 0x%x\n", _plrBufEnd);
    Dbg(DEB_FORCE, "  _plrHead = 0x%x\n", _plrHead);
    Dbg(DEB_FORCE, "  _plrTail = 0x%x\n", _plrTail);

    if (!_cRecs)
    {
        return;
    }

    Dbg(DEB_FORCE, "  Index entries marked as valid:\n");

    ULONG i;
    ULONG idxStartValid = MAX_ULONG;
    LIGHT_RECORD *plr;

    for (i = 0, plr = _plrHead;
         i < _cRecs;
         i++, plr = _BufPtrAdd(plr, 1))
    {
        if (plr->bFlags & LR_VALID)
        {
            if (idxStartValid == MAX_ULONG)
            {
                idxStartValid = i;
            }
        }
        else
        {
            if (idxStartValid != MAX_ULONG)
            {
                if (i > idxStartValid + 1)
                {
                    Dbg(DEB_FORCE,
                        "    %u-%u\n",
                        _idxStart + idxStartValid,
                        _idxStart + i - 1);
                }
                else
                {
                    Dbg(DEB_FORCE, "    %u\n", _idxStart + idxStartValid);
                }
                idxStartValid = MAX_ULONG;
            }
        }
    }

    // if last record(s) were valid they won't have been dumped yet

    if (idxStartValid != MAX_ULONG)
    {
        if (i > idxStartValid + 1)
        {
            Dbg(DEB_FORCE,
                "    %u-%u\n",
                _idxStart + idxStartValid,
                _idxStart + i - 1);
        }
        else
        {
            Dbg(DEB_FORCE, "    %u\n", _idxStart + idxStartValid);
        }
    }
}

#endif // (DBG == 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\loginfo.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999.
//
//  File:       cookie.cxx
//
//  Contents:   Implementation of node information class.
//
//  Classes:    CLogInfo
//
//  History:    12-06-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <lmwksta.h>

#if (DBG == 1)
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

WCHAR CLogInfo::_wszType[MAX_TYPE_STR] = L"";

DEBUG_DECLARE_INSTANCE_COUNTER(CLogInfo)


//
// Forward references
//



//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::CLogInfo
//
//  Synopsis:   ctor
//
//  Arguments:  [pcd]       - backpointer to parent component data object
//              [LogType]   - type of log represented by this
//              [fIsBackup] - TRUE if log must be opened with
//                              OpenBackupEventLog API.
//
//  History:    1-30-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CLogInfo::CLogInfo(
        CComponentData *pcd,
        CLogSet *pls,
        EVENTLOGTYPE LogType,
        BOOL fIsBackup,
        BOOL fUseLocalRegistry):
    _pcd(pcd),
    _pLogSet(pls),
    _cRefs(1),
    _LogType(LogType),

    // JonN 3/21/01 350614
    // Use message dlls and DS, FRS and DNS log types from specified computer
    //
    // Note that we are passing pointers to structures
    // which have not yet been initialized
    _Sources((fIsBackup && *g_wszAuxMessageSource)
                    ? g_wszAuxMessageSource
                    : (fUseLocalRegistry ? L"" : _wszLogServerUNC),
             _wszLogName),

    _hsi(NULL),
    _ulOldestGeneratedTime(0),
    _ulNewestGeneratedTime(0),
    _hwndPropSheet(NULL)
{
    TRACE_CONSTRUCTOR(CLogInfo);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CLogInfo);

    if (fIsBackup)
    {
        _SetFlag(LOGINFO_FLAG_BACKUP);
    }

    if (fUseLocalRegistry)
    {
        _SetFlag(LOGINFO_FLAG_USE_LOCAL_REGISTRY);
    }

    _wszLogServerUNC[0] = L'\0';
    _wszLogName[0]      = L'\0';
    _wszFileName[0]     = L'\0';
    _wszDisplayName[0]  = L'\0';
    _wszSize[0]         = L'\0';
    _wszDescription[0]  = L'\0';

    if (!*_wszType)  // init static var only once
    {
        LoadStr(IDS_LOG, _wszType, ARRAYLEN(_wszType));
    }

    _ulNodeId = _pcd->GetNextNodeId();
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::CLogInfo
//
//  Synopsis:   Copy ctor
//
//  History:    5-25-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CLogInfo::CLogInfo(
    const CLogInfo *pliToCopy):
        _LogType(pliToCopy->_LogType),
        _Filter(pliToCopy->_Filter),
        _cRefs(1),

        // JonN 3/21/01 Note that we are passing pointers to structures
        // which have not yet been initialized
        _Sources(_wszLogServerUNC, _wszLogName),

        _ulOldestGeneratedTime(pliToCopy->_ulOldestGeneratedTime),
        _ulNewestGeneratedTime(pliToCopy->_ulNewestGeneratedTime),
        _hwndPropSheet(NULL),
        _hsi(NULL),
        _pLogSet(pliToCopy->_pLogSet),
        _pcd(pliToCopy->_pcd)
{
    TRACE_CONSTRUCTOR(CLogInfo);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CLogInfo);

    lstrcpy(_wszLogServerUNC,pliToCopy->_wszLogServerUNC);
    lstrcpy(_wszLogName,     pliToCopy->_wszLogName);
    lstrcpy(_wszFileName,    pliToCopy->_wszFileName);
    lstrcpy(_wszDisplayName, pliToCopy->_wszDisplayName);
    lstrcpy(_wszDescription, pliToCopy->_wszDescription);
    lstrcpy(_wszSize,        pliToCopy->_wszSize);

    _flFlags = pliToCopy->_flFlags & LOGINFO_COPIED_FLAG_MASK;
    _ulNodeId = _pcd->GetNextNodeId();
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::~CLogInfo
//
//  Synopsis:   dtor
//
//  History:    2-17-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CLogInfo::~CLogInfo()
{
    TRACE_DESTRUCTOR(CLogInfo);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CLogInfo);
}




#if (DBG == 1)
//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::Dump
//
//  Synopsis:   Dump this to debugger.
//
//  History:    2-11-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CLogInfo::Dump()
{
    Dbg(DEB_FORCE, "CLogInfo(%x):\n", this);
    Dbg(DEB_FORCE, "  _ulNodeId              = %uL\n",  _ulNodeId);
    Dbg(DEB_FORCE, "  _LogType               = %uL\n",  _LogType);
    Dbg(DEB_FORCE, "  _flFlags               = 0x%x\n", _flFlags);
    Dbg(DEB_FORCE, "  _wszLogServerUNC       = '%s'\n", _wszLogServerUNC);
    Dbg(DEB_FORCE, "  _wszLogName            = '%s'\n", _wszLogName);
    Dbg(DEB_FORCE, "  _wszFileName           = '%s'\n", _wszFileName);
    Dbg(DEB_FORCE, "  _wszDisplayName        = '%s'\n", _wszDisplayName);
    Dbg(DEB_FORCE, "  _wszDescription        = '%s'\n", _wszDescription);
    Dbg(DEB_FORCE, "  _cRefs                 = %uL\n",  _cRefs);
    Dbg(DEB_FORCE, "  _wszSize               = '%s'\n", _wszSize);
    Dbg(DEB_FORCE, "  _Filter                = 0x%x\n", &_Filter);
    Dbg(DEB_FORCE, "  _Sources               = 0x%x\n", &_Sources);
    Dbg(DEB_FORCE, "  _ulOldestGeneratedTime = %uL\n",  _ulOldestGeneratedTime);
    Dbg(DEB_FORCE, "  _ulNewestGeneratedTime = %uL\n",  _ulNewestGeneratedTime);
    Dbg(DEB_FORCE, "  _hwndPropSheet         = 0x%x\n", _hwndPropSheet);
    Dbg(DEB_FORCE, "  _pcd                   = 0x%x\n", _pcd);
    _Sources.Dump();
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::IsValid
//
//  Synopsis:   Return TRUE if this log info object is valid
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CLogInfo::IsValid()
{
    return _pcd->IsValidLogInfo(this);
}

#endif // (DBG == 1)

//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::Filter
//
//  Synopsis:   Turn on or off filtering.
//
//  Arguments:  [fUseFilter] - TRUE or FALSE
//
//  History:    1-11-1997   DavidMun   Created
//
//  Notes:      Changing the filtering state invalidates the description
//              string, since it indicates filtering.
//
//              It is the caller's responsibility to invoke a view update
//
//---------------------------------------------------------------------------

VOID
CLogInfo::Filter(BOOL fUseFilter)
{
    TRACE_METHOD(CLogInfo, Filter);

    if (fUseFilter)
    {
        if (!_IsFlagSet(LOGINFO_FLAG_FILTERED))
        {
            _SetFlag(LOGINFO_FLAG_FILTERED);
            _wszDescription[0] = L'\0';
            _pcd->Dirty();
        }
    }
    else
    {
        if (_IsFlagSet(LOGINFO_FLAG_FILTERED))
        {
            _ClearFlag(LOGINFO_FLAG_FILTERED);
            _wszDescription[0] = L'\0';
            _pcd->Dirty();
        }
        _Filter.Reset();
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::GetCount
//
//  Synopsis:   Return the number of cookies in the llist, NOT counting
//              this.
//
//  History:    12-11-1996   DavidMun   Created
//
//  Notes:      This is meant to be called from the header element.
//
//---------------------------------------------------------------------------

ULONG
CLogInfo::GetCount()
{
    ULONG cCookies = 0;
    CLogInfo *pCur;

    for (pCur = Next(); pCur; pCur = pCur->Next())
    {
        cCookies++;
    }
    return cCookies;
}



//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::GetDescription
//
//  Synopsis:   Return a string describing this log.
//
//  Returns:    A string of the form:
//
//                  "System Error Records"  or
//                  "System Error Records (Filtered)"
//
//  History:    12-11-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

LPWSTR
CLogInfo::GetDescription()
{
    if (*_wszDescription)
    {
        return _wszDescription;
    }

    ASSERT(_LogType != ELT_INVALID);

    LoadStr(_LogType - ELT_SYSTEM + IDS_SYSTEM_DESCRIPTION,
            _wszDescription,
            ARRAYLEN(_wszDescription));

    if (_IsFlagSet(LOGINFO_FLAG_FILTERED))
    {
        ULONG cchDescription = lstrlen(_wszDescription);

        LoadStr(IDS_FILTERED,
                _wszDescription + cchDescription,
                ARRAYLEN(_wszDescription) - cchDescription);
    }
    return _wszDescription;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::GetDisplayName
//
//  Synopsis:   Return the display name of this log.  If it doesn't have one
//              and is not a custom log, load the default name from the
//              resource file.
//
//  History:    12-07-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

LPWSTR
CLogInfo::GetDisplayName()
{
    if (!*_wszDisplayName)
    {
        LoadStr(_LogType, _wszDisplayName, ARRAYLEN(_wszDisplayName));
    }

    return _wszDisplayName;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::GetLogSize
//
//  Synopsis:   Return a string with the file size of this log.
//
//  Arguments:  [fForceRefresh] - if TRUE, string is updated with current
//                                 log size.
//
//  History:    12-07-1996   DavidMun   Created
//
//  Notes:      Automatically refreshes on first call.
//
//---------------------------------------------------------------------------

LPWSTR
CLogInfo::GetLogSize(
    BOOL fForceRefresh)
{
    if (fForceRefresh || !*_wszSize)
    {
        _SetLogSize();
    }
    return _wszSize;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::GetLogFileAttributes
//
//  Synopsis:   Fill [pfad] with the file attributes of this log.
//
//  Arguments:  [pfad] - filled with file attributes
//
//  Returns:    Result of calling GetFileAttributesEx.
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CLogInfo::GetLogFileAttributes(
    WIN32_FILE_ATTRIBUTE_DATA *pfad) const
{
    HRESULT hr = S_OK;
    BOOL fOk;

    fOk = GetFileAttributesEx(_wszFileName,
                              GetFileExInfoStandard,
                              (LPVOID) pfad);

    if (!fOk)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBG_OUT_LASTERROR;
    }
    return hr;
}





//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::GetOldestTimestamp
//
//  Synopsis:   Fill *[pst] with the timestamp of the oldest record in the
//              log.
//
//  Arguments:  [pst] - filled with timestamp.
//
//  Returns:    HRESULT
//
//  Modifies:   *[pst]
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CLogInfo::GetOldestTimestamp(SYSTEMTIME *pst)
{
    HRESULT hr = S_OK;

    if (!_ulOldestGeneratedTime)
    {
        hr = _GetBoundaryTimestamps();
    }

    if (FAILED(hr) || !_ulOldestGeneratedTime)
    {
        GetLocalTime(pst);
    }
    else
    {
        SecondsSince1970ToSystemTime(_ulOldestGeneratedTime, pst);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::GetOldestTimestamp
//
//  Synopsis:   Fill *[pst] with the timestamp of the newest record in the
//              log.
//
//  Arguments:  [pst] - filled with timestamp.
//
//  Returns:    HRESULT
//
//  Modifies:   *[pst]
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CLogInfo::GetNewestTimestamp(SYSTEMTIME *pst)
{
    HRESULT hr = S_OK;

    if (!_ulNewestGeneratedTime)
    {
        hr = _GetBoundaryTimestamps();
    }

    if (FAILED(hr) || !_ulNewestGeneratedTime)
    {
        GetLocalTime(pst);
    }
    else
    {
        SecondsSince1970ToSystemTime(_ulNewestGeneratedTime, pst);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::_GetBoundaryTimestamps
//
//  Synopsis:   Initialize members containing the oldest and newest
//              generated time values for entries in the event log.
//
//  Returns:    HRESULT
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CLogInfo::_GetBoundaryTimestamps()
{
    HRESULT hr = S_OK;
    CEventLog logTemp;

    do
    {
        _ulOldestGeneratedTime = 0;
        _ulNewestGeneratedTime = 0;

        hr = logTemp.Open(this);
        BREAK_ON_FAIL_HRESULT(hr);

        ULONG cRecs;

        hr = logTemp.GetNumberOfRecords(&cRecs);
        BREAK_ON_FAIL_HRESULT(hr);

        if (!cRecs)
        {
            _ulOldestGeneratedTime = 0;
            _ulNewestGeneratedTime = 0;
            break;
        }

        ULONG ulOldestRecNo;

        hr = logTemp.GetOldestRecordNo(&ulOldestRecNo);
        BREAK_ON_FAIL_HRESULT(hr);

        EVENTLOGRECORD *pelr;

        pelr = logTemp.CopyRecord(ulOldestRecNo);

        if (!pelr)
        {
            hr = E_FAIL;
            break;
        }

        _ulOldestGeneratedTime = pelr->TimeGenerated;

        delete pelr;

        pelr = logTemp.CopyRecord(ulOldestRecNo + cRecs - 1);

        if (!pelr)
        {
            _ulOldestGeneratedTime = 0;
            hr = E_FAIL;
            break;
        }

        _ulNewestGeneratedTime = pelr->TimeGenerated;

        delete pelr;
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::GetTypeStr
//
//  Synopsis:   Return the localized "Log" string.
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LPWSTR
CLogInfo::GetTypeStr() const
{
    return _wszType;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::IsSameLog
//
//  Synopsis:   Return TRUE if [pli] and this refer to the same event log.
//
//  History:    2-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CLogInfo::IsSameLog(
    CLogInfo *pli) const
{

    if (_LogType != pli->_LogType                   ||
        lstrcmpi(_wszLogServerUNC, pli->_wszLogServerUNC) ||
        lstrcmpi(_wszFileName, pli->_wszFileName))
    {
        return FALSE;
    }

    return TRUE;
}


// NTRAID#NTBUG9-2002/06/05-635044-ericb: IPersistStream seek pointers don't need to be aligned on ia64
/* #if !defined(_X86_)
//+--------------------------------------------------------------------------
//
//  Function:   AlignSeekPtr
//
//  Synopsis:   Insures that the seek pointer is aligned on a natural boundary
//              for the data type. This is necessary to avoid alignment faults
//              on IA64. Use the ALIGN_PTR macro to call this function.
//
//---------------------------------------------------------------------------
VOID
AlignSeekPtr(IStream * pStm, DWORD AlignOf)
{
   const LARGE_INTEGER liZero = {0};
   ULARGE_INTEGER uliCur;

   // get current seek position
   //
   pStm->Seek(liZero, STREAM_SEEK_CUR, &uliCur);

   DWORD dwCur, dwNew;

   // ignore the high part, this clipformat stream is not that big.
   dwCur = uliCur.LowPart;

   // round up to the next boundary
   //
   dwNew = ((dwCur + AlignOf - 1) & ~(AlignOf - 1));

   if (dwNew > dwCur)
   {
      LARGE_INTEGER liNew = {0};

      liNew.LowPart = dwNew;

      pStm->Seek(liNew, STREAM_SEEK_SET, NULL);
   }
}
#endif */


//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::Load
//
//  Synopsis:   Initialize this from stream [pStm].
//
//  Arguments:  [pStm]         - stream positioned at loginfo to load
//              [usVersion]    - file version of stream
//              [pStringTable] - MMC interface for storing localizeable
//                                  strings or NULL
//
//  Returns:    HRESULT from IStream::Read
//
//  History:    12-11-1996   DavidMun   Created
//
//  Notes:      The parts of the CLogInfo that aren't persisted were
//              initialized in the ctor.
//
//---------------------------------------------------------------------------

HRESULT
CLogInfo::Load(
    IStream      *pStm,
    USHORT        usVersion,
    IStringTable *pStringTable)
{
    TRACE_METHOD(CLogInfo, Load);

    HRESULT hr = S_OK;

    do
    {
        //
        // Initialize from the stream.
        //

        ALIGN_PTR(pStm, __alignof(enum EVENTLOGTYPE));
        hr = pStm->Read(&_LogType, sizeof _LogType, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(USHORT));
        hr = pStm->Read(&_flFlags, sizeof _flFlags, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(WCHAR));
        hr = ReadString(pStm, _wszLogServerUNC, ARRAYLEN(_wszLogServerUNC));
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(WCHAR));
        hr = ReadString(pStm, _wszLogName, ARRAYLEN(_wszLogName));
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(WCHAR));
        hr = ReadString(pStm, _wszFileName, ARRAYLEN(_wszFileName));
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Current file version (and compatible future versions, hence the
        // >= instead of ==) stores log display name string in MMC's
        // String Table.  Previous version stored it in the stream
        // directly.
        //
        // Snapins creating an extension event viewer snapin and initializing
        // from a data object still write their strings directly to the
        // data stream.
        //

        if (pStringTable && usVersion >= FILE_VERSION)
        {
            MMC_STRING_ID idString;

            ALIGN_PTR(pStm, __alignof(MMC_STRING_ID));
            hr = pStm->Read(&idString, sizeof idString, NULL);
            BREAK_ON_FAIL_HRESULT(hr);

            hr = pStringTable->GetString(idString,
                                         ARRAYLEN(_wszDisplayName),
                                         _wszDisplayName,
                                         NULL);
            BREAK_ON_FAIL_HRESULT(hr);

            // JonN 1/17/01 Windows Bugs 158623 / WinSERAID 14773
            ASSERT( NULL != _pcd );
            _pcd->StringIDList().append(1,idString);

            Dbg(DEB_TRACE, "Read '%ws' from string table\n", _wszDisplayName);
        }
        else if (!pStringTable || usVersion == BETA3_FILE_VERSION)
        {
            ALIGN_PTR(pStm, __alignof(WCHAR));
            hr = ReadString(pStm, _wszDisplayName, ARRAYLEN(_wszDisplayName));
            BREAK_ON_FAIL_HRESULT(hr);
            Dbg(DEB_TRACE, "Read '%ws' from stream\n", _wszDisplayName);
        }
        else
        {
            hr = E_UNEXPECTED;
            DBG_OUT_HRESULT(hr);
            break;
        }

        hr = _Filter.Load(pStm);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::Refresh
//
//  Synopsis:   Clear category & source information for this log, and
//              reset its enable and readonly flags.
//
//  History:    4-08-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CLogInfo::Refresh()
{
    TRACE_METHOD(CLogInfo, Refresh);

    //
    // Clear the cache of source & category strings for this log
    //

    _Sources.Clear();

    //
    // If this is an archived log, just make it enabled.
    //

    if (IsBackupLog())
    {
        if (!IsEnabled())
        {
            Enable(TRUE);
            PostScopeBitmapUpdate(_pcd, this);
        }
        ASSERT(GetAllowDelete());
        ASSERT(IsReadOnly());
        return;
    }

    //
    // This loginfo is supposed to represent an active log on the
    // machine that the component data is focused on.
    //
    // If this log exists in that machine's registry, enable it,
    // otherwise disable it and allow it to be deleted.
    //

    BOOL fWasEnabled = IsEnabled();

    Enable(FALSE);
    SetReadOnly(TRUE);
    SetAllowDelete(TRUE);

    CSafeReg shkRemoteHKLM;
    CSafeReg shkEventLog;
    CSafeReg shkThisLog;

    do
    {
        HRESULT hr = S_OK;

        if (_pcd->GetCurrentFocus())
        {
            hr = shkRemoteHKLM.Connect(_pcd->GetCurrentFocus(),
                                       HKEY_LOCAL_MACHINE);
            BREAK_ON_FAIL_HRESULT(hr);


            hr = shkEventLog.Open(shkRemoteHKLM,
                                  EVENTLOG_KEY,
                                  KEY_ENUMERATE_SUB_KEYS);
        }
        else
        {
            hr = shkEventLog.Open(HKEY_LOCAL_MACHINE,
                                  EVENTLOG_KEY,
                                  KEY_ENUMERATE_SUB_KEYS);
        }
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkThisLog.Open(shkEventLog, GetLogName(), KEY_QUERY_VALUE);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Key exists & we have read acccess, mark this as enabled
        //

        Enable(TRUE);

        if (!IsUserCreated())
        {
            SetAllowDelete(FALSE);
        }

        //
        // See if we can get write access
        //

        shkThisLog.Close();

        hr = shkThisLog.Open(shkEventLog, GetLogName(), KEY_SET_VALUE);
        BREAK_ON_FAIL_HRESULT(hr);

        SetReadOnly(FALSE);
    } while (0);

    if (fWasEnabled != IsEnabled())
    {
        PostScopeBitmapUpdate(_pcd, this);
    }
}



bool
CLogInfo::ShouldSave() const
{
   return !_IsFlagSet(LOGINFO_DONT_PERSIST);
}



//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::Save
//
//  Synopsis:   Persist the data in this cookie to a stream.
//
//  Arguments:  [pStm]         - stream in which to write cookie's data.
//              [pStringTable] - MMC interface for storing localizeable
//                                  strings
//
//  Returns:    HRESULT from IStream::Write
//
//  History:    12-11-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CLogInfo::Save(
    IStream      *pStm,
    IStringTable *pStringTable)
{
    TRACE_METHOD(CLogInfo, Save);

   if (!ShouldSave())
   {
      // should not be calling this, then
      ASSERT(false);
      return S_OK;
   }

    HRESULT hr = S_OK;
    do
    {
        ALIGN_PTR(pStm, __alignof(enum EVENTLOGTYPE));
        hr = pStm->Write(&_LogType, sizeof _LogType, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        USHORT flPersistedFlags = _flFlags & LOGINFO_PERSISTED_FLAG_MASK;

        ALIGN_PTR(pStm, __alignof(USHORT));
        hr = pStm->Write(&flPersistedFlags, sizeof flPersistedFlags, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(WCHAR));
        hr = WriteString(pStm, _wszLogServerUNC);
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(WCHAR));
        hr = WriteString(pStm, _wszLogName);
        BREAK_ON_FAIL_HRESULT(hr);

        ALIGN_PTR(pStm, __alignof(WCHAR));
        hr = WriteString(pStm, _wszFileName);
        BREAK_ON_FAIL_HRESULT(hr);

        MMC_STRING_ID idString;

        hr = pStringTable->AddString(_wszDisplayName, &idString);
        BREAK_ON_FAIL_HRESULT(hr);

        // JonN 1/17/01 Windows Bugs 158623 / WinSERAID 14773
        ASSERT( NULL != _pcd );
        _pcd->StringIDList().append(1,idString);

        ALIGN_PTR(pStm, __alignof(MMC_STRING_ID));
        hr = pStm->Write(&idString, sizeof idString, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = _Filter.Save(pStm);
        BREAK_ON_FAIL_HRESULT(hr);

    } while (0);
    return hr;
}




HRESULT
WriteRecordAsText(
    HANDLE          hFile,
    CLogInfo       *pli,
    EVENTLOGRECORD *pelr,
    WCHAR           wchDelim,
    CTextBuffer    *ptb,
    LPSTR          *ppszAnsiLine,
    ULONG          *pcchAnsi);

//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::SaveLogAs
//
//  Synopsis:   Save this log to the specified file of the specified type.
//
//  Arguments:  [SaveType]        - format of file
//              [wszSaveFilename] - name for file
//              [Direction]       - direction to read log, ignored if
//                                    [SaveType] is SAVEAS_LOGFILE
//
//  Returns:    HRESULT
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CLogInfo::SaveLogAs(
    SAVE_TYPE SaveType,
    LPWSTR wszSaveFilename,
    DIRECTION Direction)
{
    HRESULT hr = S_OK;
    CWaitCursor Hourglass;

    //
    // Save as a log file (create a backup).
    //

    if (SaveType == SAVEAS_LOGFILE)
    {
        CEventLog logTemp;

        hr = logTemp.Open(this);
        CHECK_HRESULT(hr);

        if (SUCCEEDED(hr))
        {
            // EricB 1/24/02 bug 526133
            HWND hWndConsole = NULL;
            hr = _pcd->GetConsole()->GetMainWindow(&hWndConsole);
            CHECK_HRESULT(hr);

            hr = logTemp.Backup(wszSaveFilename, hWndConsole);
        }
        else if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
        {
            Enable(FALSE);
            SetReadOnly(TRUE);
            PostScopeBitmapUpdate(_pcd, this);

            wstring msg = ComposeErrorMessgeFromHRESULT(hr);

            ConsoleMsgBox(_pcd->GetConsole(),
                          IDS_CANTSAVE,
                          MB_ICONERROR | MB_OK,
                          wszSaveFilename,
                          msg.c_str());
        }
        else if (FAILED(hr))
        {
            wstring msg = ComposeErrorMessgeFromHRESULT(hr);

            ConsoleMsgBox(_pcd->GetConsole(),
                          IDS_CANTSAVE,
                          MB_ICONERROR | MB_OK,
                          wszSaveFilename,
                          msg.c_str());
        }

        return hr;
    }

    //
    // Save as a tab or comma delimited text file.
    //
    // First try to open the log.  If we don't have read access, quit
    // before creating an empty save file.
    //

    CLogCache RecordCache;

    RecordCache.SetConsole(_pcd->GetConsole());
    hr = RecordCache.Open(this, Direction);

    if (SUCCEEDED(hr))
    {
        if (!RecordCache.GetNumberOfRecords())
        {
            return S_OK;
        }
        hr = RecordCache.Next();
    }
    else if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
    {
        Enable(FALSE);
        SetReadOnly(TRUE);
        PostScopeBitmapUpdate(_pcd, this);
        return hr;
    }

    //
    // The cache was opened successfully.  Create the save file and
    // write all the records we can read.
    //

    HANDLE hFile = CreateFile(wszSaveFilename,
                              GENERIC_WRITE,
                              FILE_SHARE_READ,
                              NULL,
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        hr = HRESULT_FROM_LASTERROR;
        DBG_OUT_LASTERROR;
        return hr;
    }

    WCHAR wchSep;

    if (SaveType == SAVEAS_TABDELIM)
    {
        wchSep = L'\t';
    }
    else
    {
        wchSep = L',';
    }

    CTextBuffer tb;
    LPSTR       pszLineBuffer = NULL;
    ULONG       cchNarrow = 0;

    hr = tb.Init();

    while (hr == S_OK) // S_FALSE == end of data
    {
        EVENTLOGRECORD *pelr = RecordCache.GetCurRec();

        if (!pelr)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        hr = WriteRecordAsText(hFile,
                               this,
                               pelr,
                               wchSep,
                               &tb,
                               &pszLineBuffer,
                               &cchNarrow);

        tb.Empty();

        if (SUCCEEDED(hr))
        {
            hr = RecordCache.Next();
        }
    }

    VERIFY(CloseHandle(hFile));
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::ProcessBackupFilename
//
//  Synopsis:   Verify that, if this log is on a remote machine,
//              [wszSaveFilename] is on the same machine, and convert the
//              path [wszSaveFilename] to use the local drives of the remote
//              machine.
//
//  Arguments:  [wszSaveFilename] - filename
//
//  Modifies:   *[wszSaveFilename]
//
//  Returns:    S_OK   - same server
//              E_FAIL - different server
//
//  History:    4-03-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CLogInfo::ProcessBackupFilename(
    LPWSTR wszSaveFilename)
{
    TRACE_METHOD(CLogInfo, ProcessBackupFilename);

    HRESULT hr = S_OK;
    BYTE *pbBuf = NULL;
    WKSTA_INFO_100 *pEventLogWksta = NULL;
    WKSTA_INFO_100 *pFileDestWksta = NULL;

    do
    {
        //
        // If focus is not on remote machine, any backup filename (local
        // or remote) may be used.
        //

        if (!*_wszLogServerUNC)
        {
            break;
        }

        // JonN 12/12/00 247431
        // EV in the DNS - event viewer does not save the log file
        //
        // This was a nasty one to repro, especially since I couldn't get
        // MSVCMON working under TS on A-ARTMA1 and had to debug with NTSD.
        // It only happens if you are using ELS as an extension while
        // focused on the local machine, but the extended snapin passes
        // the full machine name rather than the empty string.
        // In this case the machine name is recorded with the CLogInfo,
        // breaking the test for local focus in
        // CLogInfo::ProcessBackupFilename().  Eventually the code
        // which parses out the sharename fails and
        // HRESULT_FROM_WIN32(ERROR_BAD_NETPATH) is returned.
        //
        // We need to compare _wszLogServerUNC to ::GetComputerName().
        // It would be possible to do this at SetLogServerName() time,
        // fixing the other calls which make an equivalent check,
        // but I'm not confident that I understand all the
        // ramifications of that.  Instead, I propose adding this check
        // to CLogInfo::ProcessBackupFilename() directly.
        wstring wstrCName = GetComputerNameAsString();
        if ( !lstrcmpi(wstrCName.c_str(), _wszLogServerUNC) )
        {
            Dbg(DEB_ITRACE,
                "ProcessBackupFilename: skip local focus '%ws'\n",
                wstrCName.c_str());
            break;
        }

        // JonN 9/4/01 463889
        // We need to use the more accurate local focus test involving
        // NetWkstaGetInfo[100].
        wstring strLocalNB = GetNetbiosComputerNameAsString(NULL);
        wstring strFocusNB = GetNetbiosComputerNameAsString(_wszLogServerUNC);
        if ( !strLocalNB.empty() &&
             !strFocusNB.empty() &&
             !lstrcmpi(strLocalNB.c_str(), strFocusNB.c_str()))
        {
            Dbg(DEB_ITRACE,
                "ProcessBackupFilename: skip NetBIOS local focus '%ws'\n",
                strFocusNB.c_str());
            break;
        }

        //
        // Focus is on remote machine.  The filename specified must be on
        // the same remote machine.  Compare the two machine names and
        // pop up an error if they're different.
        //

        WCHAR wszDestinationComputer[CCH_COMPUTER_MAX];
        WCHAR wszUncPath[MAX_PATH];

        hr = RemoteFileToServerAndUNCPath(wszSaveFilename,
                                          wszDestinationComputer,
                                          ARRAYLEN(wszDestinationComputer),
                                          wszUncPath,
                                          ARRAYLEN(wszUncPath));
        BREAK_ON_FAIL_HRESULT(hr);

        // JonN 1/31/01 300301
        // RemoteFileToServerAndUNCPath returns S_FALSE if wszSaveFilename
        // is local.  It looks like this codepath has been broken
        // for a long time.
        if (hr == S_FALSE)
        {
            ConsoleMsgBox(_pcd->GetConsole(),
                          IDS_ILLEGAL_REMOTE_BACKUP,
                          MB_ICONERROR | MB_OK,
                          _wszLogServerUNC,
                          wstrCName.c_str() );
            hr = E_FAIL;
            DBG_OUT_HRESULT(hr);
            break;
        }

        //
        // Since computer names have many different forms, the string
        // compare is only conclusive if both are in the same form.
        // If the first compare succeeds then they happen to be in the
        // same form and we can avoid additional work.  Otherwise,
        // Use NetWkstaGetInfo to get the netbios form of both machines
        // and compare again.
        //

        if (lstrcmpi(wszDestinationComputer, _wszLogServerUNC) != 0)
        {
            wstring strFileDestNB = GetNetbiosComputerNameAsString(wszDestinationComputer);

            if (!strFocusNB.empty() &&
                !strFileDestNB.empty() &&
                lstrcmpi(strFocusNB.c_str(), strFileDestNB.c_str()) != 0)
            {
                ConsoleMsgBox(_pcd->GetConsole(),
                              IDS_ILLEGAL_REMOTE_BACKUP,
                              MB_ICONERROR | MB_OK,
                              _wszLogServerUNC,
                              wszDestinationComputer);
                hr = E_FAIL;
                DBG_OUT_HRESULT(hr);
                break;
            }
        }

        //
        // wszSaveFilename is a UNC or remote drive-based path to a save
        // filename on the remote machine.  It must be converted into a path
        // using a local drive on the remote machine.
        //
        // This is because the BackupEventLog API actually asks the remote
        // event log service to do a local save, so it needs a filename
        // that is local for that machine.
        //
        // Isolate the share name from wszUncPath to give to NetShareGetInfo.
        //

        LPWSTR pwszShareName = wcschr(&wszUncPath[2], L'\\');
        LPWSTR pwszShareEnd = pwszShareName ?
                                wcschr(pwszShareName + 1, L'\\') :
                                NULL;

        if (!pwszShareName || !pwszShareEnd)
        {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_NETPATH);
            DBG_OUT_HRESULT(hr);
            break;
        }

        pwszShareName++;        // advance past backslash
        *pwszShareEnd = L'\0';  // NULL terminate

        NET_API_STATUS Result;

        Result = NetShareGetInfo(wszDestinationComputer,
                                 pwszShareName,
                                 2,
                                 &pbBuf);

        if (Result != NERR_Success)
        {
            Dbg(DEB_ERROR,
                "NetShareGetInfo('%ws', '%ws') %uL\n",
                wszDestinationComputer,
                pwszShareName,
                Result);
            hr = HRESULT_FROM_WIN32(Result);

            wstring strMessage = ComposeErrorMessgeFromHRESULT(hr);

            ConsoleMsgBox(_pcd->GetConsole(),
                          IDS_CANTSAVE,
                          MB_OK | MB_ICONERROR,
                          wszSaveFilename,
                          strMessage.c_str());
            break;
        }

        PathCombine(wszSaveFilename,
                    ((PSHARE_INFO_2)pbBuf)->shi2_path,
                    pwszShareEnd + 1);

        Dbg(DEB_ITRACE,
            "ProcessBackupFilename: Converted filename is '%ws'\n",
            wszSaveFilename);

    } while (0);

    if (pEventLogWksta)
    {
        NetApiBufferFree(pEventLogWksta);
    }

    if (pFileDestWksta)
    {
        NetApiBufferFree(pFileDestWksta);
    }

    if (pbBuf)
    {
        NetApiBufferFree(pbBuf);
    }

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Function:   WriteRecordAsText
//
//  Synopsis:   Write [pelr] as text with fields separated by [wchDelim].
//
//  Arguments:  [hFile]    - file opened at position to write
//              [pli]      - describes log from which [pelr] comes
//              [pelr]     - event record to write as text
//              [wchDelim] - delimiter char, usu. ',' or '\t'.
//
//  Returns:    HRESULT
//
//  History:    01-20-1997   DavidMun   Created from code by RaviR
//              07-24-1997   DavidMun   Rewrote
//
//---------------------------------------------------------------------------

HRESULT
WriteRecordAsText(
    HANDLE          hFile,
    CLogInfo       *pli,
    EVENTLOGRECORD *pelr,
    WCHAR           wchDelim,
    CTextBuffer    *ptb,
    LPSTR          *ppszAnsiLine,
    ULONG          *pcchAnsi)
{
    HRESULT hr = S_OK;
    WCHAR   wszField[MAX_LISTVIEW_STR];
    LPWSTR pwszDescription = NULL;

    ASSERT(pelr);
    do
    {
        //
        // Date
        //

        GetDateStr(pelr->TimeGenerated, wszField, ARRAYLEN(wszField));
        hr = ptb->AppendDelimited(wszField, wchDelim);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Time
        //

        GetTimeStr(pelr->TimeGenerated, wszField, ARRAYLEN(wszField));
        hr = ptb->AppendDelimited(wszField, wchDelim);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Source
        //

        hr = ptb->AppendDelimited(GetSourceStr(pelr), wchDelim);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Record Type
        //

        hr = ptb->AppendDelimited(GetTypeStr(GetEventType(pelr)), wchDelim);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Category
        //

        GetCategoryStr(pli, pelr, wszField, ARRAYLEN(wszField));
        hr = ptb->AppendDelimited(wszField, wchDelim);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // EventID
        //

        GetEventIDStr((USHORT) pelr->EventID, wszField, ARRAYLEN(wszField));
        hr = ptb->AppendDelimited(wszField, wchDelim);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // User
        //

        GetUserStr(pelr, wszField, ARRAYLEN(wszField), TRUE);
        hr = ptb->AppendDelimited(wszField, wchDelim);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Computer and description.  The last field shouldn't have a
        // delimiter after it, so check whether there will be a description
        // before adding the computer.
        //

        // JonN 4/17/01 370310
        // Saving event log as text shouldn't have
        // http://www.microsoft.com/contentredirect.asp reference
        pwszDescription = GetDescriptionStr(pli, pelr, NULL, FALSE);

        if (pwszDescription && *pwszDescription)
        {
            //
            // Computer
            //

            hr = ptb->AppendDelimited(GetComputerStr(pelr), wchDelim);
            BREAK_ON_FAIL_HRESULT(hr);

            //
            // Description.
            //

            hr = ptb->AppendDelimited(pwszDescription, wchDelim, FALSE);
            BREAK_ON_FAIL_HRESULT(hr);
        }
        else
        {
            //
            // Computer (with no delimiter)
            //

            hr = ptb->AppendDelimited(GetComputerStr(pelr), wchDelim, FALSE);
            BREAK_ON_FAIL_HRESULT(hr);
        }

        //
        // Terminate line with carriage-return linefeed.
        //

        hr = ptb->AppendEOL();
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Now convert from WCHAR to ANSI
        //

        ULONG cbToWrite;

        hr = ptb->GetBufferA(ppszAnsiLine, pcchAnsi, &cbToWrite);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Now append the line, less terminating null, to the file
        //

        ULONG  cbWritten;

        BOOL fOk = WriteFile(hFile,
                             *ppszAnsiLine,
                             cbToWrite - sizeof(CHAR),
                             &cbWritten,
                             NULL);

        if (!fOk)
        {
            hr = HRESULT_FROM_LASTERROR;
            DBG_OUT_LASTERROR;
            break;
        }

    } while (0);

    LocalFree(pwszDescription);
    return hr;
}





//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::SetDisplayName
//
//  Synopsis:   Set the display name of this log.
//
//  Arguments:  [wszDisplayName] - new display name
//
//  History:    1-20-1997   DavidMun   Created
//
//  Notes:      Forces UI update, if necessary, and dirties the snapin
//              containing this so that change will be persisted.
//
//---------------------------------------------------------------------------

VOID
CLogInfo::SetDisplayName(LPCWSTR wszDisplayName)
{
    lstrcpyn(_wszDisplayName, wszDisplayName, ARRAYLEN(_wszDisplayName));
    _pcd->Dirty();
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::SetLowSpeed
//
//  Synopsis:   Turn on or off low speed flag (affects log cache buffer
//              size).
//
//  Arguments:  [fLowSpeed] - zero or nonzero
//
//  History:    2-17-1997   DavidMun   Created
//
//  Notes:      Dirties the snapin containing this so that change will be
//              persisted.
//
//---------------------------------------------------------------------------

VOID
CLogInfo::SetLowSpeed(BOOL fLowSpeed)
{
    if (fLowSpeed)
    {
        _SetFlag(LOGINFO_FLAG_LOW_SPEED);
    }
    else
    {
        _ClearFlag(LOGINFO_FLAG_LOW_SPEED);
    }
    _pcd->Dirty();
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogInfo::_SetLogSize
//
//  Synopsis:   Update the size string with the log's current file size.
//
//  Modifies:   CLogInfo::_wszSize
//
//  History:    12-07-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CLogInfo::_SetLogSize()
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    ULONG  ulLastError = NO_ERROR;

    do
    {
        hFile = CreateFile(_wszFileName,
                           0,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL);

        if (hFile == INVALID_HANDLE_VALUE)
        {
            Dbg(DEB_ERROR,
                "CLogInfo::_SetLogSize: error %uL opening file '%s'\n",
                GetLastError(),
                _wszFileName);
            break;
        }

        ULONG cbFile = GetFileSize(hFile, NULL);

        if (cbFile == 0xFFFFFFFF)
        {
            ulLastError = GetLastError();

            if (ulLastError != NO_ERROR)
            {
                break;
            }
        }

        AbbreviateNumber(cbFile, _wszSize, ARRAYLEN(_wszSize));
    }
    while (0);

    if (hFile == INVALID_HANDLE_VALUE || ulLastError != NO_ERROR)
    {
        lstrcpy(_wszSize, L"--");
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        VERIFY(CloseHandle(hFile));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\logset.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       LogSet.cxx
//
//  Contents:   Implementation of CLogSet class
//
//  Classes:    CLogSet
//
//  History:    4-20-1999   LinanT   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//////////////////////////////////////////////////////////
// class CLogSet

CLogSet::CLogSet(CComponentData *pcd) :
    _pcd(pcd),
    _hsi(0),
    _hsiParent(0),
    _pLogInfos(NULL)
{
    TRACE_CONSTRUCTOR(CLogSet);
    ZeroMemory(_szExtendedNodeType, sizeof(_szExtendedNodeType));
}

CLogSet::~CLogSet()
{
    TRACE_DESTRUCTOR(CLogSet);
    CLogInfo *pli = _pLogInfos;
    CLogInfo *pliNext = NULL;

    while (pli)
    {
        pliNext = pli->Next();

        //
        // Delete log info from the scope
        //
        _pcd->DeleteLogInfo(pli);

        pli->ClearHSI();
        pli->Release();

        pli = pliNext;
    }

    _pLogInfos = NULL;
}

HRESULT
CLogSet::LoadViewsFromStream(
    IStream *pstm,
    USHORT usVersion,
    IStringTable *pStringTable)
{
    TRACE_METHOD(CLogSet, LoadViewsFromStream);
    HRESULT hr = S_OK;
    USHORT i;

    //
    // Read the count of LogInfos
    //

    USHORT cLogInfos;

    hr = pstm->Read(&cLogInfos, sizeof USHORT, NULL);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    //
    // Read the loginfos themselves
    //

    for (i = 0; i < cLogInfos; i++)
    {
        CLogInfo *pNew = new CLogInfo(_pcd, this, ELT_INVALID, FALSE, FALSE);

        if (!pNew)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        hr = pNew->Load(pstm, usVersion, pStringTable);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            delete pNew;
            break;
        }

        //
        // Add it to the llist
        //
        AddLogInfoToList(pNew);
    }
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CLogSet::GetViewsFromDataObject
//
//  Synopsis:   If [pDataObject] supports the clipboard format
//              s_cfImportViews, then initialize this object's views
//              (loginfo/filter pairs) from it.
//
//  Arguments:  [pDataObject] - data object provided by snapin we're
//                               extending
//
//  History:    06-16-1997   DavidMun   Created
//              04-16-1999   LinanT     Updated
//
//  Notes:      If [pDataObject] doesn't support requested clipboard format,
//              does nothing.
//
//---------------------------------------------------------------------------
VOID
CLogSet::GetViewsFromDataObject(
    LPDATAOBJECT pDataObject)
{
    TRACE_METHOD(CLogSet, GetViewsFromDataObject);

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL
    };

    FORMATETC formatetc =
    {
        (CLIPFORMAT)CDataObject::s_cfImportViews,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    HRESULT hr;
    BOOL    fGetDataSucceeded = FALSE;
    IStream *pstm = NULL;

    do
    {
        hr = pDataObject->GetData(&formatetc, &stgmedium);

        if (FAILED(hr))
        {
            Dbg(DEB_ITRACE, "GetData error 0x%x\n", hr);
            break;
        }

        if (stgmedium.hGlobal)
        {
            fGetDataSucceeded = TRUE;
        }
        else
        {
            ASSERT(0 && "GetData succeeded but stgmedium.hGlobal is NULL");
            break;
        }

        hr = CreateStreamOnHGlobal(stgmedium.hGlobal, FALSE, &pstm);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Check the fOnlyTheseViews flag
        //

        BOOL fOnlyTheseViews;

        hr = pstm->Read(&fOnlyTheseViews, sizeof(BOOL), NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        if (fOnlyTheseViews)
        {
            _SetFlag(COMPDATA_DONT_ADD_FROM_REG);
        }

        //
        // Load loginfo/filter pairs from the stream, adding them to
        // _pLogInfos llist.
        //

        hr = LoadViewsFromStream(pstm, FILE_VERSION, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

    } while (0);

    if (pstm)
    {
        pstm->Release();
    }

    if (fGetDataSucceeded)
    {
        ReleaseStgMedium(&stgmedium);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CLogSet::MergeLogInfos
//
//  Synopsis:   Create LogInfos for both the logs specified by registry
//              keys and those already loaded from a file (if any).
//
//  Returns:    HRESULT
//
//  History:    6-22-1999   davidmun   Created
//
//  Notes:      If a registry key corresponds to a loginfo previously loaded,
//              that loginfo will be enabled.  If the registry key has no
//              corresponding loginfo, a new one will be created.  If a
//              previously loaded loginfo doesn't have a corresponding
//              registry key, it will be shown as disabled.
//
//---------------------------------------------------------------------------

HRESULT
CLogSet::MergeLogInfos(HWND hWnd)
{
    TRACE_METHOD(CLogSet, MergeLogInfos);

    HRESULT hr = S_OK;
    IConsole *piConsole = _pcd->GetConsole();
    LPCWSTR lpszCurrentFocus = _pcd->GetCurrentFocus();
    LPCWSTR lpszCurFocusSystemRoot = _pcd->GetCurFocusSystemRoot();

    //
    // If loginfo objects have already been loaded from a stream, mark
    // as disabled and as allowing deletion all the ones which are
    // supposed to represent active logs.
    //
    // Mark all loginfos representing backup logs as allowing deletion, since
    // they are always user-created.  Also mark them read-only, since the
    // clear and settings operations aren't valid on a backup log.
    //

    if (_pLogInfos != NULL)
    {
        CLogInfo *pliCur;

        for (pliCur = _pLogInfos; pliCur; pliCur = pliCur->Next())
        {
            pliCur->SetAllowDelete(TRUE);
            pliCur->SetReadOnly(TRUE);

            if (!pliCur->IsBackupLog())
            {
                pliCur->Enable(FALSE);
            }
            else
            {
                ASSERT(pliCur->IsUserCreated());
                pliCur->SetReadOnly(TRUE); // CODEWORK didn't we just do this?
            }
        }
    }

    //
    // Open the eventlog key of the machine we're focused on.
    //

    CSafeReg shkRemoteHKLM;
    CSafeReg shkEventLog;

    if (lpszCurrentFocus)
    {
        hr = shkRemoteHKLM.Connect(lpszCurrentFocus, HKEY_LOCAL_MACHINE);

      if (SUCCEEDED(hr))
      {
         hr = shkEventLog.Open(shkRemoteHKLM,
                              EVENTLOG_KEY,
                              KEY_ENUMERATE_SUB_KEYS);
      }

     if (FAILED(hr))
     {
         DBG_OUT_HRESULT(hr);

         wstring msg = ComposeErrorMessgeFromHRESULT(hr);

         if (hWnd) // EricB 1/24/02 bug 526145
         {
            MsgBox(hWnd,
                   IDS_CANT_CONNECT,
                   MB_ICONERROR | MB_OK,
                   lpszCurrentFocus,
                   msg.c_str());
         }
         else
         {
            ConsoleMsgBox(
               piConsole,
               IDS_CANT_CONNECT,
               MB_ICONERROR | MB_OK,
               lpszCurrentFocus,
               msg.c_str());
         }

         return hr;
     }

    }
    else
    {
        hr = shkEventLog.Open(HKEY_LOCAL_MACHINE,
                              EVENTLOG_KEY,
                              KEY_ENUMERATE_SUB_KEYS);
    }

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    //
    // Enumerate the logs in the registry of the machine we're focused on.
    //
    // If loginfos for active logs have been loaded, re-enable each one
    // for which a corresponding registry key is found.
    //
    // If the loginfos haven't been loaded, create a CLogInfo object
    // for each enumerated registry key.
    //
    // In either case add an item to the scope pane for each loginfo.
    //

    WCHAR wszSubkeyName[MAX_PATH + 1]; // size per SDK on RegEnumKey
    ULONG idxSubkey;

    for (idxSubkey = 0; TRUE; idxSubkey++)
    {
        hr = shkEventLog.Enum(idxSubkey,
                              wszSubkeyName,
                              ARRAYLEN(wszSubkeyName));

        //
        // This is the only exit from this loop
        //

        if (hr != S_OK)
        {
            break;
        }

        //
        // Try to obtain the full path to the log file.  This is not
        // critical information, since it is only used to display
        // file size, modification time, etc.
        //

        CSafeReg shkLog;
        WCHAR wszPath[MAX_PATH + 1];

        hr = shkLog.Open(shkEventLog, wszSubkeyName, KEY_QUERY_VALUE);

        if (SUCCEEDED(hr))
        {
            //
            // Get the path to the log file from the registry and set it in
            // the loginfo.  Expand the systemroot to the value for the local
            // machine iff we are not focused on some other machine.
            //

            hr = shkLog.QueryPath(FILE_VALUE_NAME,
                                  wszPath,
                                  ARRAYLEN(wszPath),
                                  !lpszCurrentFocus);

            //
            // If it is a remote file, the file name must be converted to
            // a UNC.
            //

            if (SUCCEEDED(hr) && lpszCurrentFocus)
            {
                hr = ExpandSystemRootAndConvertToUnc(wszPath,
                                                     ARRAYLEN(wszPath),
                                                     lpszCurrentFocus,
                                                     lpszCurFocusSystemRoot);

                if (FAILED(hr))
                {
                    wszPath[0] = L'\0';
                }
            }
        }
        else
        {
            wszPath[0] = L'\0';
        }

        //
        // wszPath is now either an empty string, a UNC path, or a local
        // path to the log file.
        //

        //
        // See if we can get write access to the log's registry
        // key.
        //

        HRESULT hrWriteAccess;

        shkLog.Close();

        hrWriteAccess = shkLog.Open(shkEventLog,
                                    wszSubkeyName,
                                    KEY_SET_VALUE);

        shkLog.Close();

        //
        // If the loginfos have been loaded from a file, enable each
        // active log that references the subkey just enumerated. Also
        // update the log filename.
        //
        // Backup logs don't need to be updated since their log type,
        // filename, & server are all supplied by the user.
        //

        if (_pLogInfos != NULL)
        {
            CLogInfo *pliCur;
            BOOL      fFoundLogInfoForSubKey = FALSE;

            for (pliCur = _pLogInfos; pliCur; pliCur = pliCur->Next())
            {
                if (!pliCur->IsBackupLog() &&
                    !lstrcmpi(pliCur->GetLogName(), wszSubkeyName))
                {
                    //
                    // Remember that the current subkey has at least one
                    // loginfo, so we don't create one for it.
                    //

                    fFoundLogInfoForSubKey = TRUE;

                    //
                    // Without actually opening the log we can't tell whether
                    // it should be disabled, so enable it.
                    //

                    pliCur->Enable(TRUE);

                    //
                    // Since the log appears to be valid, don't let the user
                    // delete it unless the user created it.
                    //

                    pliCur->SetAllowDelete(pliCur->IsUserCreated());

                    //
                    // Make sure the log file name corresponds to what we've
                    // found in the registry.  Also force the server name to
                    // the current focus (which may have been overridden on
                    // the command line).
                    //

                    pliCur->SetFileName(wszPath);
                    pliCur->SetLogServerName(lpszCurrentFocus);

                    //
                    // Allow clear log, etc. operations if we have write access
                    // to the registry.
                    //

                    if (SUCCEEDED(hrWriteAccess))
                    {
                        pliCur->SetReadOnly(FALSE);
                    }

                    //
                    // pliCur is fully configured.
                    //

                }
            }

            //
            // If no loginfo was loaded that references the log just found,
            // fall through to the code that creates a loginfo for a subkey.
            //
            // Exception: if the event viewer is extending another snapin,
            // and that snapin specified via the s_cfImportViews format of
            // the data object it gave us when we got the MMCN_EXPAND
            // notification, AND in the data provided it set the
            // fOnlyTheseViews flag, THEN ignore any additional logs found in
            // the registry.
            //

            if (fFoundLogInfoForSubKey ||
                _IsFlagSet(COMPDATA_DONT_ADD_FROM_REG))
            {
                continue;
            }
        }

        //
        // Found a new log in the registry.  Add a loginfo for it.
        //

        EVENTLOGTYPE elt = DetermineLogType(wszSubkeyName);

        CLogInfo *pliNew = new CLogInfo(_pcd,
                                        this,
                                        elt,
                                        FALSE,
                                        // JonN 8/14/01 451415
                                        lpszCurrentFocus == NULL);

        if (!pliNew)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            continue;
        }

        if (lpszCurrentFocus)
        {
            pliNew->SetLogServerName(lpszCurrentFocus);
        }

        pliNew->SetFileName(wszPath);
        pliNew->SetLogName(wszSubkeyName);

        if (FAILED(hrWriteAccess))
        {
            pliNew->SetReadOnly(TRUE);
        }

        //
        // Get a localized name for the log; if that's not available,
        // use the default for logs we know about, and use the registry
        // key name for all others.
        //

        PWSTR pwszLogName = GetLogDisplayName(shkEventLog,
                                              lpszCurrentFocus,
                                              lpszCurFocusSystemRoot,
                                              wszSubkeyName);

        if (pwszLogName)
        {
            pliNew->SetDisplayName(pwszLogName);
            LocalFree(pwszLogName);
        }
        else
        {
            pliNew->SetDisplayName(wszSubkeyName);
        }

        AddLogInfoToList(pliNew);
    }

    return hr;
}




HRESULT
CLogSet::Save(
    IStream *pStm,
    IStringTable *pStringTable)
{
    TRACE_METHOD(CLogSet, Save);

    ASSERT(ShouldSave());

    HRESULT hr = S_OK;
    do
    {
        hr = pStm->Write(&_szExtendedNodeType, sizeof _szExtendedNodeType, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // count the number of loginfos and write the count
        //

        CLogInfo *pliCur;
        USHORT cLogInfos = 0;

        for (pliCur = _pLogInfos; pliCur; pliCur = pliCur->Next())
        {
            if (pliCur->ShouldSave())
            {
               cLogInfos++;
            }
        }

        hr = pStm->Write(&cLogInfos, sizeof USHORT, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // LogInfos
        //

        for (pliCur = _pLogInfos; pliCur; pliCur = pliCur->Next())
        {
            if (pliCur->ShouldSave())
            {
               hr = pliCur->Save(pStm, pStringTable);
               BREAK_ON_FAIL_HRESULT(hr);
            }
        }

    } while (0);
    return hr;
}

HRESULT
CLogSet::Load(
    IStream      *pStm,
    USHORT usVersion,
    IStringTable *pStringTable)
{
    TRACE_METHOD(CLogSet, Load);

    HRESULT hr = S_OK;

    do
    {
        //
        // Initialize from the stream.
        //

        hr = pStm->Read(&_szExtendedNodeType, sizeof _szExtendedNodeType, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // LogInfos
        //

        hr = LoadViewsFromStream(pStm, usVersion, pStringTable);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}

VOID
CLogSet::AddLogInfoToList(
    CLogInfo *pli)
{
    TRACE_METHOD(CLogSet, AddLogInfoToList);
    if (!_pLogInfos)
    {
        _pLogInfos = pli;
    }
    else
    {
        CLogInfo *pliLast;

        for (pliLast = _pLogInfos; pliLast->Next(); pliLast = pliLast->Next())
        {
        }
        pli->LinkAfter(pliLast);
    }
}

VOID
CLogSet::RemoveLogInfoFromList(
    CLogInfo *pli)
{
    TRACE_METHOD(CLogSet, RemoveLogInfoFromList);
    if (_pLogInfos)
    {
        if (_pLogInfos == pli)
          _pLogInfos = pli->Next();

        pli->UnLink();
    }
}

bool
CLogSet::ShouldSave() const
{
    //
    // JonN 3/26/01 300327
    // Log view changes persisted to snapin file are not restored
    //
    // The ELS code is structured to save the list log views
    // under each static node as a CLogSet objects, along with
    // full information about the log views and filters
    // at the time the console file was saved.
    // ELS successfully saves a list of CLogSet descriptions
    // in Save(), and successfully rereads this information
    // in Load(), storing this list in _pLogSets.
    // The problem comes when the user expands a new
    // extension root, and we must determine which of the saved
    // CLogSet objects corresponds to this particular CLogSet.
    // The current approach will only work for static roots;
    // the CLogSet objects loaded from the console file have no
    // HSCOPEITEM GetHSI(), since they were just loaded from
    // the console file, and the HSCOPEITEM is unlikely to
    // come up the same after MMC is closed and reopened.
    //
    // The CLogSets are accumulating in the console file.
    // The CLogSets which are restored but cannot be associated
    // with any particular extension root, will be saved into
    // any new console file along with the new CLogSets created
    // when no restored CLogSet could be associated with the
    // expanded extension roots.  In theory, you could go on
    // saving and restoring a console file and wind up with
    // an indefinite number of saved CLogSets.  The most recent
    // compmgmt.msc has 125.
    //
    return !_IsFlagSet(LOGINFO_DONT_PERSIST) && !_pcd->IsExtension();
}

ULONG
CLogSet::GetMaxSaveSize() const
{
    TRACE_METHOD(CLogSet, GetMaxSaveSize);

    ULONG ulSize = sizeof(GUID) + sizeof(ULONG);

    CLogInfo *pliCur;

    for (pliCur = _pLogInfos; pliCur; pliCur = pliCur->Next())
    {
        ulSize += pliCur->GetMaxSaveSize();
    }
    return ulSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\mscache.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       mscache.cxx
//
//  Contents:   Implementation of module "is Microsoft" flag caching class
//
//  Classes:    CIsMicrosoftDllCache
//
//  History:    9-15-2000              Created
//
//---------------------------------------------------------------------------


#include "headers.hxx"
#pragma hdrstop




//===========================================================================
//
// CIsMicrosoftDllCacheItem implementation
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CIsMicrosoftDllCacheItem::CIsMicrosoftDllCacheItem
//
//  Synopsis:   ctor
//
//  History:    9-15-2000              Created
//
//---------------------------------------------------------------------------

CIsMicrosoftDllCacheItem::CIsMicrosoftDllCacheItem(
    LPCWSTR pwszModuleName,
    BOOL fIsMicrosoftDll)
{
    TRACE_CONSTRUCTOR(CIsMicrosoftDllCacheItem);

    lstrcpyn(_wszModuleName, pwszModuleName, ARRAYLEN(_wszModuleName));
    _fIsMicrosoftDll = fIsMicrosoftDll;
}



//+--------------------------------------------------------------------------
//
//  Member:     CIsMicrosoftDllCacheItem::~CIsMicrosoftDllCacheItem
//
//  Synopsis:   dtor
//
//  History:    9-15-2000              Created
//
//---------------------------------------------------------------------------

CIsMicrosoftDllCacheItem::~CIsMicrosoftDllCacheItem()
{
    TRACE_DESTRUCTOR(CIsMicrosoftDllCacheItem);
}




//+--------------------------------------------------------------------------
//
//  Member:     CIsMicrosoftDllCacheItem::Copy
//
//  Synopsis:   Copy the cache item in [pitem].
//
//  Arguments:  [pitem] - item to copy
//
//  Returns:    HRESULT
//
//  History:    9-15-2000              Created
//
//---------------------------------------------------------------------------

HRESULT
CIsMicrosoftDllCacheItem::Copy(
    CLruCacheItem *pitem)
{
    CIsMicrosoftDllCacheItem *pIsMicrosoftDllItem = (CIsMicrosoftDllCacheItem *) pitem;

    lstrcpy(_wszModuleName, pIsMicrosoftDllItem->_wszModuleName);

    _fIsMicrosoftDll = pIsMicrosoftDllItem->_fIsMicrosoftDll;

    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CIsMicrosoftDllCacheItem::GetValue
//
//  Synopsis:   Fill [pvBuf] with cached flag.
//
//  Arguments:  [pvBuf] - buffer to fill
//              [cbBuf] - must be sizeof(BOOL)
//
//  Returns:    S_OK
//
//  Modifies:   *[pvBuf]
//
//  History:    9-15-2000              Created
//
//---------------------------------------------------------------------------

HRESULT
CIsMicrosoftDllCacheItem::GetValue(
    LPVOID pvBuf,
    ULONG cbBuf)
{
    ASSERT(cbBuf == sizeof(BOOL));
    _ulLastAccess = GetTickCount();
    *(BOOL *)pvBuf = _fIsMicrosoftDll;
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CIsMicrosoftDllCacheItem::IsEqual
//
//  Synopsis:   Return true if this item's key matches [pvKey]
//
//  History:    9-15-2000              Created
//
//---------------------------------------------------------------------------

BOOL
CIsMicrosoftDllCacheItem::IsEqual(
    LPVOID pvKey)
{
    return 0 == lstrcmpi((LPCWSTR) pvKey, _wszModuleName);
}




//===========================================================================
//
// CIsMicrosoftDllCache implementation
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CIsMicrosoftDllCache::CIsMicrosoftDllCache
//
//  Synopsis:   ctor
//
//  History:    9-15-2000              Created
//
//---------------------------------------------------------------------------

CIsMicrosoftDllCache::CIsMicrosoftDllCache():
    CLruCache(MAX_MSDLL_CACHE)
{
    TRACE_CONSTRUCTOR(CIsMicrosoftDllCache);
}




//+--------------------------------------------------------------------------
//
//  Member:     CIsMicrosoftDllCache::~CIsMicrosoftDllCache
//
//  Synopsis:   dtor
//
//  History:    9-15-2000              Created
//
//---------------------------------------------------------------------------

CIsMicrosoftDllCache::~CIsMicrosoftDllCache()
{
    TRACE_DESTRUCTOR(CIsMicrosoftDllCache);
}




//+--------------------------------------------------------------------------
//
//  Member:     CIsMicrosoftDllCache::_Add, private
//
//  Synopsis:   Add new item to cache
//
//  Arguments:  [pwszModuleName]  - identifies item
//              [fIsMicrosoftDll] - item's value
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//
//  History:    9-15-2000              Created
//
//---------------------------------------------------------------------------

HRESULT
CIsMicrosoftDllCache::_Add(
    LPCWSTR pwszModuleName,
    BOOL fIsMicrosoftDll)
{
    HRESULT hr = S_OK;
    CLruCacheItem *pNew = new CIsMicrosoftDllCacheItem(pwszModuleName, fIsMicrosoftDll);

    if (pNew)
    {
        hr = CLruCache::Add(pNew);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(hr);
    }
    return hr;
}





//+--------------------------------------------------------------------------
//
//  Member:     CIsMicrosoftDllCache::Fetch
//
//  Synopsis:   Retrieve the "is Microsoft" flag for [pwszModuleName], adding
//              it to the cache if it is not already present.
//
//  Arguments:  [pwszModuleName]   - name of module
//              [pfIsMicrosoftDll] - "is Microsoft" flag to populate
//
//  Returns:    HRESULT
//
//  History:    9-15-2000              Created
//
//---------------------------------------------------------------------------

HRESULT
CIsMicrosoftDllCache::Fetch(
    LPCWSTR pwszModuleName,
    BOOL *pfIsMicrosoftDll)
{
    //
    // Try to get the flag value from the cache.
    //

    BOOL fIsMicrosoftDll = FALSE;
    HRESULT hr;

    hr = CLruCache::Fetch((LPVOID) pwszModuleName,
                          (LPVOID) &fIsMicrosoftDll,
                          sizeof fIsMicrosoftDll);

    if (hr == S_OK)
    {
        Dbg(DEB_ITRACE,
            "CIsMicrosoftDllCache::Fetch: cache hit for module '%s'\n",
            pwszModuleName);
    }
    else
    {
        Dbg(DEB_ITRACE,
            "CIsMicrosoftDllCache::Fetch: cache miss for module '%s'\n",
            pwszModuleName);

        //
        // The flag value is not in the cache.  Examine the version resource
        // of the module to determine the flag value.  Trap exceptions because
        // the file version APIs can throw.
        //

        BYTE *pFVI = NULL;

        __try
        {
            DWORD dwJunk;
            DWORD dwFVISize;
            UINT dwFVIValueSize;

            struct LANGANDCODEPAGE
            {
                WORD wLanguage;
                WORD wCodePage;
            }
            *pFVIValue = NULL;

            if ((dwFVISize = GetFileVersionInfoSizeW((LPWSTR) pwszModuleName, &dwJunk)) > 0 &&
                (pFVI = (BYTE *) HeapAlloc(GetProcessHeap(), 0, dwFVISize)) != NULL &&
                GetFileVersionInfo((LPWSTR) pwszModuleName, 0, dwFVISize, pFVI) &&
                VerQueryValueW(pFVI, L"\\VarFileInfo\\Translation", (LPVOID *) &pFVIValue, &dwFVIValueSize))
            {
                WCHAR wszQueryString[256];
                WCHAR *pwszCompanyName;
                WCHAR wszCompanyName[256];
                UINT dwCompanyNameSize;
                DWORD dwIndex;

                for (dwIndex = 0; dwIndex < (dwFVIValueSize / sizeof(LANGANDCODEPAGE)); dwIndex++)
                {
                    wsprintf(wszQueryString, L"\\StringFileInfo\\%04x%04x\\CompanyName", pFVIValue[dwIndex].wLanguage, pFVIValue[dwIndex].wCodePage);

                    if (!VerQueryValueW(pFVI, wszQueryString, (LPVOID *) &pwszCompanyName, &dwCompanyNameSize))
                        continue;

                    wcsncpy(wszCompanyName, pwszCompanyName, (dwCompanyNameSize + 1 > 255) ? 255 : (dwCompanyNameSize + 1));

                    wszCompanyName[255] = 0;

                    _wcsupr(wszCompanyName);

                    if (wcsstr(wszCompanyName, L"MICROSOFT") != NULL)
                    {
                        fIsMicrosoftDll = TRUE;
                        break;
                    }
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
        }

        if (pFVI != NULL)
            HeapFree(GetProcessHeap(), 0, pFVI);
    }

    //
    // Pass the flag value back to the caller and cache the result.
    //

    *pfIsMicrosoftDll = fIsMicrosoftDll;

    (void) _Add(pwszModuleName, fIsMicrosoftDll);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\lrucache.cxx ===
#include "headers.hxx"
#pragma hdrstop
                
//+--------------------------------------------------------------------------
//
//  Member:     CLruCache::Add
//
//  Synopsis:   Add an entry to the cache, replacing the least
//              recently used item if necessary.
//
//  Arguments:  [pNew] - cache item to add
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//  History:    1-13-1997   DavidMun   Created
//              2-27-1997   DavidMun   Make generic
//
//---------------------------------------------------------------------------

HRESULT
CLruCache::Add(
    CLruCacheItem *pNew)
{
    TRACE_METHOD(CLruCache, Add);
    
    CAutoCritSec CritSec(&_cs);
    HRESULT hr = S_OK;

    if (_cItems < _cMaxItems)
    {
        if (_pItems)
        {
            pNew->LinkAfter((CDLink *) _pItems);
        }
        else 
        {
            _pItems = pNew;
        }
        _cItems++;
    }
    else 
    {
        CLruCacheItem *pOldest = _FindLruItem();

        hr = pOldest->Copy(pNew);
        delete pNew;
#if (DBG == 1)
        _cReplacements++;
#endif // (DBG == 1)
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLruCache::Clear
//
//  Synopsis:   Empty the cache, free all memory.
//
//  History:    1-13-1997   DavidMun   Created
//              2-27-1997   DavidMun   Make generic
//
//---------------------------------------------------------------------------

VOID 
CLruCache::Clear()
{
    TRACE_METHOD(CLruCache, Clear);
    
    CAutoCritSec CritSec(&_cs);

    for (CLruCacheItem *pCur = _pItems; pCur;)
    {
        CLruCacheItem *pNext = pCur->Next();
        pCur->UnLink();
        delete pCur;
        pCur = pNext;
    }
    _pItems = NULL;
    _cItems = 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLruCache::Fetch
//
//  Synopsis:   Search the cache 
//
//  Returns:    S_OK    - cache hit
//              S_FALSE - cache miss
//
//  History:    1-13-1997   DavidMun   Created
//              2-27-1997   DavidMun   Make generic
//
//---------------------------------------------------------------------------

HRESULT
CLruCache::Fetch(
    LPVOID pvKey,
    LPVOID pvBuf,
    ULONG  cbBuf)
{
    // TRACE_METHOD(CLruCache, Fetch);

    CLruCacheItem *pCur;
    CAutoCritSec CritSec(&_cs);

    for (pCur = _pItems; pCur; pCur = pCur->Next())
    {
        if (pCur->IsEqual(pvKey))
        {
#if (DBG == 1)
            _cHits++;
#endif // (DBG == 1)
            return pCur->GetValue(pvBuf, cbBuf);
        }
    }
#if (DBG == 1)
            _cMisses++;
#endif // (DBG == 1)
    return S_FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLruCache::_FindLruItem
//
//  Synopsis:   Return a pointer to the least recently used cache entry.
//
//  Returns:    Pointer to least recently accessed item.
//
//  History:    1-13-1997   DavidMun   Created
//              2-27-1997   DavidMun   Make generic
//
//  Notes:      Invalid to call when cache is empty.  
//              Caller must take critical section.
//
//---------------------------------------------------------------------------

CLruCacheItem *
CLruCache::_FindLruItem()
{
    TRACE_METHOD(CLruCache, _FindLruItem);

    CLruCacheItem *pCur;
    CLruCacheItem *pOldest = NULL;
    ULONG ulOldestTime = 0xFFFFFFFF;

    ASSERT(_pItems);  // we shouldn't be called on an empty list

    for (pCur = _pItems; pCur; pCur = pCur->Next())
    {
        if (pCur->GetLastAccessTime() <= ulOldestTime)
        {
            ulOldestTime = pCur->GetLastAccessTime();
            pOldest = pCur;
        }
    }

    ASSERT(pOldest);  // we should always find something

    Dbg(DEB_TRACE, "LRU is 0x%x\n", pOldest);
    return pOldest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\oleglue.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       oleglue.cxx
//
//  Contents:   Miscellaneous functions required for implementing an ole
//              in-proc server
//
//  History:    12-04-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//
// Types
//

struct NODE_GUID_INFO
{
    LPCWSTR wszGuidStr;
    LPCWSTR wszName;
};


//
// Forward references
//

HRESULT
CreateNodeKeys(
    CSafeReg *pshkNodeTypes,
    NODE_GUID_INFO aNodeGuids[]);

HRESULT
DeleteNodeKeys(
    CSafeReg *pshkNodeTypes,
    NODE_GUID_INFO aNodeGuids[]);

HRESULT
RegisterInterface(
    CSafeReg *pshkInterface,
    LPWSTR wszInterfaceGUID,
    LPWSTR wszInterfaceName,
    LPWSTR wszNumMethods,
    LPWSTR wszProxyCLSID);


//
// Private globals
//

NODE_GUID_INFO g_aNodeGuids[] =
{
    { ROOT_NODE_GUID_STR,   ROOT_NODE_NAME_STR   },
    { SCOPE_NODE_GUID_STR,  SCOPE_NODE_NAME_STR  },
    { RESULT_NODE_GUID_STR, RESULT_NODE_NAME_STR },
    { 0, 0 }
};


//+--------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Create snapin & node registry keys and values for the
//              event log viewer snapin.
//
//  Returns:    SELFREG_E_TYPELIB - couldn't register typelib
//              SELFREG_E_CLASS   - couldn't register class
//
//  History:    12-04-1996   DavidMun   Created
//              06-13-1997   DavidMun   New node types
//
//---------------------------------------------------------------------------

STDAPI
DllRegisterServer()
{
    TRACE_FUNCTION(DllRegisterServer);

    HRESULT     hr = SELFREG_E_CLASS;   // ASSUME FAILURE
    LONG        lr;
    CSafeReg    shk;    // reused several times
    CSafeReg    shkCLSID;
    CSafeReg    shkNodeTypes;

    WCHAR   wszNameString[80];
    WCHAR   wszExtensionNameString[80];
    WCHAR   wszModuleFilename[MAX_PATH];

    do
    {
        //
        // Create the snapin registry key for the event log viewer snapin
        //

        {
            lr = GetModuleFileName(g_hinst, wszModuleFilename, MAX_PATH);

            if (!lr)
            {
                DBG_OUT_LASTERROR;
                break;
            }

            CSafeReg    shkSnapins;

            hr = shkSnapins.Open(HKEY_LOCAL_MACHINE, SNAPINS_KEY, KEY_WRITE);
            BREAK_ON_FAIL_HRESULT(hr);

            CSafeReg    shkEventLogSnapin;

            hr = shkSnapins.Create(CLSID_SNAPIN_STR, &shkEventLogSnapin);
            BREAK_ON_FAIL_HRESULT(hr);

            hr = shkEventLogSnapin.SetValue(g_szNodeType,
                                            REG_SZ,
                                            (CONST BYTE *) ROOT_NODE_GUID_STR,
                                            sizeof(ROOT_NODE_GUID_STR));
            BREAK_ON_FAIL_HRESULT(hr);

            LoadStr( IDS_NAME_STR,
                     wszNameString,
                     ARRAYLEN(wszNameString),
                     NAME_STR);

            hr = shkEventLogSnapin.SetValue(g_szNameString,
                                            REG_SZ,
                                            (CONST BYTE *) wszNameString,
                                            sizeof(WCHAR) * (lstrlen(wszNameString) + 1));
            BREAK_ON_FAIL_HRESULT(hr);

            WCHAR wszNameStringIndirect[MAX_PATH * 2];

            wsprintf(wszNameStringIndirect,
                     L"@%s,-%d",
                     wszModuleFilename,
                     IDS_NAME_STR);

            hr = shkEventLogSnapin.SetValue(g_szNameStringIndirect,
                                            REG_SZ,
                                            (CONST BYTE *) wszNameStringIndirect,
                                            sizeof(WCHAR) * (lstrlen(wszNameStringIndirect) + 1));
            BREAK_ON_FAIL_HRESULT(hr);

            hr = shkEventLogSnapin.SetValue(g_szAbout,
                                            REG_SZ,
                                            (CONST BYTE *) CLSID_ABOUT_STR,
                                            sizeof(CLSID_ABOUT_STR));

            hr = shkEventLogSnapin.Create(g_szStandAlone, &shk);
            shk.Close();
            CHECK_HRESULT(hr);  // this value is optional

            hr = shkEventLogSnapin.Create(g_szNodeTypes, &shk);
            BREAK_ON_FAIL_HRESULT(hr);

            hr = CreateNodeKeys(&shk, g_aNodeGuids);
            shk.Close();
            BREAK_ON_FAIL_HRESULT(hr);

            // Event viewer system tools extension clsid

            hr = shkSnapins.Create(SYSTOOLSEXT_CLSID_STR, &shk);
            BREAK_ON_FAIL_HRESULT(hr);

            LoadStr( IDS_EXTENSION_NAME_STR,
                     wszExtensionNameString,
                     ARRAYLEN(wszExtensionNameString),
                     EXTENSION_NAME_STR);

            hr = shk.SetValue(g_szNameString,
                              REG_SZ,
                              (CONST BYTE *) wszExtensionNameString,
                              sizeof(WCHAR) * (lstrlen(wszExtensionNameString) + 1));
            CHECK_HRESULT(hr);

            wsprintf(wszNameStringIndirect,
                     L"@%s,-%d",
                     wszModuleFilename,
                     IDS_EXTENSION_NAME_STR);

            hr = shk.SetValue(g_szNameStringIndirect,
                              REG_SZ,
                              (CONST BYTE *) wszNameStringIndirect,
                              sizeof(WCHAR) * (lstrlen(wszNameStringIndirect) + 1));
            CHECK_HRESULT(hr);

            hr = shk.SetValue(g_szAbout,
                              REG_SZ,
                              (CONST BYTE *) CLSID_ABOUT_STR,
                              sizeof(CLSID_ABOUT_STR));

            shk.Close();
        }

        //
        // Create the node entries
        //

        hr = shkNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY, KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = CreateNodeKeys(&shkNodeTypes, g_aNodeGuids);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Create the CLSID entries
        //

        hr = shkCLSID.Open(HKEY_CLASSES_ROOT, L"CLSID", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // First the entry for the snapin itself
        //

        {
            CSafeReg    shkServer;

            hr = shkCLSID.Create(CLSID_SNAPIN_STR, &shk);
            BREAK_ON_FAIL_HRESULT(hr);

            hr = shk.Create(L"InprocServer32", &shkServer);
            BREAK_ON_FAIL_HRESULT(hr);

            shk.Close();

            hr = shkServer.SetValue(NULL,
                                    REG_SZ,
                                    (CONST BYTE *) wszModuleFilename,
                                    sizeof(WCHAR) * (lstrlen(wszModuleFilename) + 1));
            BREAK_ON_FAIL_HRESULT(hr);


            hr = shkServer.SetValue(L"ThreadingModel",
                                    REG_SZ,
                                    (CONST BYTE *) THREADING_STR,
                                    sizeof(THREADING_STR));
            BREAK_ON_FAIL_HRESULT(hr);
        }

        //
        // Next, the CLSID entry for the private interface proxy/stub
        // dll (which just points back to this dll).
        //

        {
            CSafeReg    shkServer;

            hr = shkCLSID.Create(GUID_INAMESPACEACTIONS_STR, &shk);
            BREAK_ON_FAIL_HRESULT(hr);

            hr = shk.SetValue(NULL,
                              REG_SZ,
                              (CONST BYTE *) PSBUFFER_STR,
                              sizeof(PSBUFFER_STR));
            BREAK_ON_FAIL_HRESULT(hr);

            hr = shk.Create(L"InprocServer32", &shkServer);
            BREAK_ON_FAIL_HRESULT(hr);

            hr = shkServer.SetValue(NULL,
                                    REG_SZ,
                                    (CONST BYTE *) wszModuleFilename,
                                    sizeof(WCHAR) * (lstrlen(wszModuleFilename) + 1));

            hr = shkServer.SetValue(L"ThreadingModel",
                                    REG_SZ,
                                    (CONST BYTE *) THREADING_STR,
                                    sizeof(THREADING_STR));
            BREAK_ON_FAIL_HRESULT(hr);

            shk.Close();
        }

        //
        // The CLSID entry for the system tools extension.  Again, it
        // points to this DLL, but since it differs from the standalone
        // CLSID, we'll know how we're being used.
        //

        {
            CSafeReg    shkServer;

            hr = shkCLSID.Create(SYSTOOLSEXT_CLSID_STR, &shk);
            BREAK_ON_FAIL_HRESULT(hr);

            hr = shk.Create(L"InprocServer32", &shkServer);
            BREAK_ON_FAIL_HRESULT(hr);

            shk.Close();

            hr = shkServer.SetValue(NULL,
                                    REG_SZ,
                                    (CONST BYTE *) wszModuleFilename,
                                    sizeof(WCHAR) * (lstrlen(wszModuleFilename) + 1));
            BREAK_ON_FAIL_HRESULT(hr);


            hr = shkServer.SetValue(L"ThreadingModel",
                                    REG_SZ,
                                    (CONST BYTE *) THREADING_STR,
                                    sizeof(THREADING_STR));
            BREAK_ON_FAIL_HRESULT(hr);

            shk.Close();
        }

        //
        // The CLSID entry for the object implementing ISnapinAbout
        //

        {
            CSafeReg    shkAbout;

            hr = shkCLSID.Create(CLSID_ABOUT_STR, &shk);
            BREAK_ON_FAIL_HRESULT(hr);

            hr = shk.Create(L"InprocServer32", &shkAbout);
            BREAK_ON_FAIL_HRESULT(hr);

            WCHAR wzClsIdFriendlyName[MAX_PATH];

            LoadStr(IDS_SNAPIN_ABOUT_CLSID_FRIENDLY_NAME,
                    wzClsIdFriendlyName,
                    ARRAYLEN(wzClsIdFriendlyName),
                    L"Event viewer snapin ISnapinAbout provider");

            hr = shk.SetValue(NULL,
                                   REG_SZ,
                                   (CONST BYTE *)wzClsIdFriendlyName,
                                   sizeof(WCHAR) * (lstrlen(wzClsIdFriendlyName) + 1));
            BREAK_ON_FAIL_HRESULT(hr);

            shk.Close();

            hr = shkAbout.SetValue(NULL,
                                    REG_SZ,
                                    (CONST BYTE *) wszModuleFilename,
                                    sizeof(WCHAR) * (lstrlen(wszModuleFilename) + 1));
            BREAK_ON_FAIL_HRESULT(hr);

            hr = shkAbout.SetValue(L"ThreadingModel",
                                    REG_SZ,
                                    (CONST BYTE *) THREADING_STR,
                                    sizeof(THREADING_STR));
            BREAK_ON_FAIL_HRESULT(hr);

            shk.Close();
        }

        //
        // Create keys under Interface to register the interface guids
        //

        hr = shk.Open(HKEY_CLASSES_ROOT, L"Interface", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = RegisterInterface(&shk,
                               GUID_INAMESPACEACTIONS_STR,
                               INAMESPACEACTIONS_STR,
                               NUM_INAMESPACEACTIONS_METHODS,
                               GUID_INAMESPACEACTIONS_STR);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = RegisterInterface(&shk,
                               GUID_IRESULTACTIONS_STR,
                               IRESULTACTIONS_STR,
                               NUM_IRESULTACTIONS_METHODS,
                               GUID_INAMESPACEACTIONS_STR);
        BREAK_ON_FAIL_HRESULT(hr);

        shk.Close();

        //
        // Register as a system tools node extension
        //

        {
            CSafeReg shkSystemTools;

            hr = shkNodeTypes.Create(TEXT(struuidNodetypeSystemTools),
                                     &shkSystemTools);
            BREAK_ON_FAIL_HRESULT(hr);

            CSafeReg shkExtensions;

            hr = shkSystemTools.Create(g_szExtensions, &shkExtensions);
            BREAK_ON_FAIL_HRESULT(hr);

            CSafeReg shkNameSpace;

            hr = shkExtensions.Create(g_szNameSpace, &shkNameSpace);
            BREAK_ON_FAIL_HRESULT(hr);

            hr = shkNameSpace.SetValue(SYSTOOLSEXT_CLSID_STR,
                                       REG_SZ,
                                       (CONST BYTE *) wszExtensionNameString,
                                       sizeof(WCHAR) * (lstrlen(wszExtensionNameString) + 1));
            BREAK_ON_FAIL_HRESULT(hr);
        }

#ifdef ELS_TASKPAD
        //
        // Register to be extended by Default View Extensions
        // JonN 5/18/00 98816
        //

        {
            CSafeReg shkLogNode;

            hr = shkLogNode.Open(shkNodeTypes,
                                 SCOPE_NODE_GUID_STR,
                                 KEY_WRITE);
            BREAK_ON_FAIL_HRESULT(hr);

            CSafeReg shkExtensions;

            hr = shkLogNode.Create(g_szExtensions, &shkExtensions);
            BREAK_ON_FAIL_HRESULT(hr);

            CSafeReg shkView;

            hr = shkExtensions.Create(L"View", &shkView);
            BREAK_ON_FAIL_HRESULT(hr);

            WCHAR wszViewExtensionString[80];
            LoadStr( IDS_VIEW_EXTENSION_STR,
                     wszViewExtensionString,
                     ARRAYLEN(wszViewExtensionString),
                     L"MMCViewExt Object");

            hr = shkView.SetValue(L"{B708457E-DB61-4C55-A92F-0D4B5E9B1224}",
                                  REG_SZ,
                                  (CONST BYTE *) wszViewExtensionString,
                                  sizeof(WCHAR) * (lstrlen(wszViewExtensionString) + 1));
            BREAK_ON_FAIL_HRESULT(hr);
        }
#endif // ELS_TASKPAD

    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   CreateNodeKeys
//
//  Synopsis:   Create a guid-named node key for every element in
//              [aNodeGuids] under [pshkNodeTypes].
//
//  Arguments:  [pshkNodeTypes] - points to safereg for key opened with
//                                 write access.
//              [aNodeGuids]    - zero terminated list of guids to write
//
//  Returns:    HRESULT
//
//  History:    06-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CreateNodeKeys(
    CSafeReg *pshkNodeTypes,
    NODE_GUID_INFO aNodeGuids[])
{
    HRESULT         hr = S_OK;
    NODE_GUID_INFO *pngi;

    for (pngi = aNodeGuids; pngi->wszGuidStr; pngi++)
    {
        CSafeReg    shk;

        hr = pshkNodeTypes->Create(pngi->wszGuidStr, &shk);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.SetValue(NULL,
                          REG_SZ,
                          (CONST BYTE *) pngi->wszName,
                          sizeof(WCHAR) * (lstrlen(pngi->wszName) + 1));
        CHECK_HRESULT(hr); // this entry is not critical
        shk.Close();
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   DeleteNodeKeys
//
//  Synopsis:   Delete all guid-named node keys listed in [aNodeGuids]
//              from [pshkNodeTypes].
//
//  Arguments:  [pshkNodeTypes] - node types key
//              [aNodeGuids]    - array of names of subkeys to delete
//
//  Returns:    HRESULT
//
//  History:    08-06-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
DeleteNodeKeys(
    CSafeReg *pshkNodeTypes,
    NODE_GUID_INFO aNodeGuids[])
{
    HRESULT         hr = S_OK;
    NODE_GUID_INFO *pngi;

    for (pngi = aNodeGuids; pngi->wszGuidStr; pngi++)
    {
        hr = pshkNodeTypes->DeleteTree(pngi->wszGuidStr);
        CHECK_HRESULT(hr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   RegisterInterface
//
//  Synopsis:   Add the registry entries required for an interface.
//
//  Arguments:  [pshkInterface]    - handle to CLSID\Interface key
//              [wszInterfaceGUID] - GUID of interface to add
//              [wszInterfaceName] - human-readable name of interface
//              [wszNumMethods]    - number of methods (including inherited)
//              [wszProxyCLSID]    - GUID of dll containing proxy/stubs
//
//  Returns:    HRESULT
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
RegisterInterface(
    CSafeReg *pshkInterface,
    LPWSTR wszInterfaceGUID,
    LPWSTR wszInterfaceName,
    LPWSTR wszNumMethods,
    LPWSTR wszProxyCLSID)
{
    HRESULT     hr = S_OK;
    CSafeReg    shkIID;
    CSafeReg    shkNumMethods;
    CSafeReg    shkProxy;

    do
    {
        hr = pshkInterface->Create(wszInterfaceGUID, &shkIID);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.SetValue(NULL,
                             REG_SZ,
                             (CONST BYTE *) wszInterfaceName,
                             sizeof(WCHAR) * (lstrlen(wszInterfaceName) + 1));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.Create(L"NumMethods", &shkNumMethods);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkNumMethods.SetValue(NULL,
                                REG_SZ,
                                (CONST BYTE *)wszNumMethods,
                                sizeof(WCHAR) * (lstrlen(wszNumMethods) + 1));
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkIID.Create(L"ProxyStubClsid32", &shkProxy);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkProxy.SetValue(NULL,
                               REG_SZ,
                               (CONST BYTE *)wszProxyCLSID,
                               sizeof(WCHAR) * (lstrlen(wszProxyCLSID) + 1));
        BREAK_ON_FAIL_HRESULT(hr);

    } while (0);

    return hr;
}





//+--------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Delete all registry entries made by DllRegisterServer.
//
//  Returns:    S_OK
//
//  History:    08-06-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDAPI
DllUnregisterServer()
{
    TRACE_FUNCTION(DllUnregisterServer);

    HRESULT     hr = S_OK;
    CSafeReg    shk;    // reused several times
    CSafeReg    shkCLSID;
    CSafeReg    shkNodeTypes;

    //
    // Delete event viewer snapin key
    //

    do
    {
        CSafeReg    shkSnapins;

        hr = shkSnapins.Open(HKEY_LOCAL_MACHINE, SNAPINS_KEY, KEY_WRITE | KEY_ENUMERATE_SUB_KEYS);
        BREAK_ON_FAIL_HRESULT(hr);

        if (SUCCEEDED(hr))
        {
            hr = shkSnapins.DeleteTree(CLSID_SNAPIN_STR);
            CHECK_HRESULT(hr);
        }

        hr = shk.Open(shkSnapins, SYSTOOLSEXT_CLSID_STR, KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.DeleteValue(g_szNameString);
        CHECK_HRESULT(hr);

        shk.Close();
    }
    while (0);

    //
    // Delete the node entries
    //

    hr = shkNodeTypes.Open(HKEY_LOCAL_MACHINE, NODE_TYPES_KEY, KEY_WRITE);

    if (SUCCEEDED(hr))
    {
        hr = DeleteNodeKeys(&shkNodeTypes, g_aNodeGuids);
        CHECK_HRESULT(hr);
    }
    else
    {
        DBG_OUT_HRESULT(hr);
    }

    //
    // Delete the CLSID entries
    //

    do
    {
        hr = shkCLSID.Open(HKEY_CLASSES_ROOT, L"CLSID", KEY_WRITE | KEY_ENUMERATE_SUB_KEYS);
        BREAK_ON_FAIL_HRESULT(hr);

        // clsid for event viewer snapin

        hr = shkCLSID.DeleteTree(CLSID_SNAPIN_STR);
        CHECK_HRESULT(hr);

        // clsid for about provider

        hr = shkCLSID.DeleteTree(CLSID_ABOUT_STR);
        CHECK_HRESULT(hr);

        // Private interface proxy/stub

        hr = shkCLSID.DeleteTree(GUID_INAMESPACEACTIONS_STR);
        CHECK_HRESULT(hr);

        // clsid for system tools extension

        hr = shkCLSID.DeleteTree(SYSTOOLSEXT_CLSID_STR);
        CHECK_HRESULT(hr);
    } while (0);

    //
    // Delete interface keys
    //

    do
    {
        hr = shk.Open(HKEY_CLASSES_ROOT, L"Interface", KEY_WRITE | KEY_ENUMERATE_SUB_KEYS);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shk.DeleteTree(GUID_INAMESPACEACTIONS_STR);
        CHECK_HRESULT(hr);

        hr = shk.DeleteTree(GUID_IRESULTACTIONS_STR);
        CHECK_HRESULT(hr);

        shk.Close();
    } while (0);

    //
    // Delete system tools node extension
    //

    do
    {
        CSafeReg shkSystemTools;

        hr = shkSystemTools.Open(shkNodeTypes,
                                 TEXT(struuidNodetypeSystemTools),
                                 KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        CSafeReg shkExtensions;

        hr = shkExtensions.Open(shkSystemTools, g_szExtensions, KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        CSafeReg shkNameSpace;

        hr = shkNameSpace.Open(shkExtensions, g_szNameSpace, KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkNameSpace.DeleteValue(SYSTOOLSEXT_CLSID_STR);
        CHECK_HRESULT(hr);
    }
    while (0);

    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Return S_OK if refcount for dll is 0.
//
//  Returns:    S_OK or S_FALSE
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDAPI
DllCanUnloadNow()
{
    TRACE_FUNCTION(DllCanUnloadNow);
    return CDll::CanUnloadNow();
}



STDAPI
elspDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);

//+--------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Return the requested class factory.
//
//  Arguments:  [rclsid] - class desired
//              [riid]   - interface on class factory desired
//              [ppv]    - filled with itf pointer to class factory
//
//  Returns:    S_OK, E_OUTOFMEMORY, CLASS_E_CLASSNOTAVAILABLE
//
//  Modifies:   *[ppv]
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    TRACE_FUNCTION(DllGetClassObject);
    IUnknown *punk = NULL;
    HRESULT hr = S_OK;

    *ppv = NULL;

    if (IsEqualCLSID(rclsid, CLSID_EventLogSnapin) ||
        IsEqualCLSID(rclsid, CLSID_SysToolsExt))
    {
        punk = new CComponentDataCF;

        if (punk)
        {
            hr = punk->QueryInterface(riid, ppv);
            punk->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
        }
    }
    else if (IsEqualCLSID(rclsid, CLSID_SnapinAbout))
    {
        punk = new CSnapinAboutCF;

        if (punk)
        {
            hr = punk->QueryInterface(riid, ppv);
            punk->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
        }
    }
    else
    {
        //
        // See if this is a request for the class factory of the proxy
        //

        hr = elspDllGetClassObject(rclsid, riid, ppv);
        CHECK_HRESULT(hr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by els.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\safereg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       safereg.cxx
//
//  Contents:   Implementation of Win32 registry API C++ wrapper
//
//  Classes:    CSafeReg
//
//  History:    1-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop



//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Close
//
//  Synopsis:   Close the key if it is open.
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSafeReg::Close()
{
    // TRACE_METHOD(CSafeReg, Close);

    if (_hKey)
    {
#if (DBG == 1)
        LONG lr =
#endif // (DBG == 1)
        RegCloseKey(_hKey);
        ASSERT(lr == ERROR_SUCCESS);
        _hKey = NULL;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Create
//
//  Synopsis:   Creates a new key with write access.
//
//  Arguments:  [wszSubKey] - name of new key
//              [pshkNew]   - given new key; must not already have a key
//
//  Returns:    HRESULT
//
//  Modifies:   *[pshkNew]
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Create(
    LPCWSTR wszSubKey,
    CSafeReg *pshkNew)
{
    Dbg(DEB_TRACE, "CSafeReg::Create(%x) '%s'\n", this, wszSubKey);
    ASSERT(_hKey);
    ASSERT(!pshkNew->_hKey);

    HRESULT hr = S_OK;
    LONG lr;
    DWORD dwDisposition;

    lr = RegCreateKeyEx(_hKey,
                        wszSubKey,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &pshkNew->_hKey,
                        &dwDisposition);

    if (lr != ERROR_SUCCESS)
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Connect
//
//  Synopsis:   Open a connection to HKLM or HKEY_USERS on
//              [ptszMachineName].
//
//  Arguments:  [ptszMachineName] - remote machine name.
//              [hkeyPredefined]  - HKEY_LOCAL_MACHINE or HKEY_USERS.
//
//  Returns:    HRESULT
//
//  History:    2-07-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Connect(
    LPCWSTR pwszMachineName,
    HKEY hkeyPredefined)
{
    TRACE_METHOD(CSafeReg, Connect);
    ASSERT(!_hKey);
    ASSERT(pwszMachineName);
    ASSERT(hkeyPredefined == HKEY_LOCAL_MACHINE ||
           hkeyPredefined == HKEY_USERS);

    HRESULT hr = S_OK;
    LONG lr;
    CWaitCursor Hourglass;

    lr = RegConnectRegistry((LPWSTR)pwszMachineName,
                            hkeyPredefined,
                            &_hKey);

    if (lr != ERROR_SUCCESS)
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::DeleteTree
//
//  Synopsis:   Delete the subkey [wszSubKey] and all keys beneath it.
//
//  Arguments:  [wszSubKey] - name of root key of tree to delete
//
//  Returns:    HRESULT
//
//  History:    08-06-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::DeleteTree(
    LPCWSTR wszSubKey)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;

    do
    {
        CSafeReg shkSubKey;

        hr = shkSubKey.Open(_hKey,
                            wszSubKey,
                            KEY_WRITE | KEY_ENUMERATE_SUB_KEYS);
        BREAK_ON_FAIL_HRESULT(hr);

        WCHAR wszEnumeratedKeyName[MAX_PATH];

        hr = shkSubKey.Enum(0,
                            wszEnumeratedKeyName,
                            ARRAYLEN(wszEnumeratedKeyName));
        CHECK_HRESULT(hr);

        if (hr != S_OK)
        {
            break;
        }

        //
        // Recursively delete keys below wszSubKey
        //

        hr = shkSubKey.DeleteTree(wszEnumeratedKeyName);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Since we've made a change to the key, the current enumeration
        // context is invalid.  We have to close the key and re-enumerate.
        //

        shkSubKey.Close();
    }
    while (TRUE);


    Dbg(DEB_TRACE, "CSafeReg::DeleteTree '%ws'\n", wszSubKey);
    LONG lr = RegDeleteKey(_hKey, wszSubKey);

    if (lr != ERROR_SUCCESS)
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::DeleteValue
//
//  Synopsis:   Delete the value [wszValueName] from the key
//
//  Arguments:  [wszValueName] - name of value to delete
//
//  Returns:    HRESULT
//
//  History:    08-06-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::DeleteValue(
    LPCWSTR wszValueName)
{
    Dbg(DEB_TRACE, "CSafeReg::DeleteValue '%ws'\n", wszValueName);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    LONG lr = RegDeleteValue(_hKey, wszValueName);

    if (lr != ERROR_SUCCESS)
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Enum
//
//  Synopsis:   Wraps the RegEnumKeyEx API.
//
//  Arguments:  [ulSubKey]       - 0-based subkey index
//              [pwszSubkeyName] - buffer to hold subkey
//              [cchSubkeyName]  - size of buffer
//
//  Returns:    S_OK    - success
//              S_FALSE - no more items
//              E_*     - enum api failed
//
//  Modifies:   *[pwszSubkeyName]
//
//  History:    2-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Enum(
    ULONG ulSubKey,
    LPWSTR pwszSubkeyName,
    ULONG cchSubkeyName) const
{
    // TRACE_METHOD(CSafeReg, Enum);
    ASSERT(_hKey);

    HRESULT     hr = S_OK;
    LONG        lr;
    FILETIME    ftLastWrite;

    lr = RegEnumKeyEx(_hKey,
                      ulSubKey,
                      pwszSubkeyName,
                      &cchSubkeyName,
                      NULL,
                      NULL,
                      NULL,
                      &ftLastWrite);

    if (lr != ERROR_SUCCESS)
    {
        if (lr == ERROR_NO_MORE_ITEMS)
        {
            hr = S_FALSE;
        }
        else
        {
            DBG_OUT_LRESULT(lr);
            hr = E_FAIL;
        }
    }

    if (FAILED(hr))
    {
        *pwszSubkeyName = L'\0';
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Open
//
//  Synopsis:   Wraps the RegOpenKeyEx function.
//
//  Arguments:  [hKeyParent]  - open parent key
//              [lpszKeyName] - name of key to open
//              [samDesired]  - desired access level
//
//  Returns:    HRESULT representing result of RegOpenKeyEx.
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Open(
    HKEY hKeyParent,
    LPCTSTR lpszKeyName,
    REGSAM samDesired)
{
    // TRACE_METHOD(CSafeReg, Open);
    ASSERT(hKeyParent);
    ASSERT(!_hKey);

    HRESULT hr = S_OK;
    HKEY    hKey = NULL;
    LONG    lr = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);

    if (lr == ERROR_SUCCESS)
    {
        _hKey = hKey;
    }
    else
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryBufSize
//
//  Synopsis:   Fill *[pcb] with the number bytes required to hold the
//              value specified by [wszValueName].
//
//  Arguments:  [wszValueName] - name of registry value on this key
//              [pcb]          - filled with required buffer size, in bytes
//
//  Returns:    HRESULT
//
//  Modifies:   *[pcb]
//
//  History:    2-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryBufSize(
    LPWSTR wszValueName,
    ULONG  *pcb)
{
    HRESULT hr = S_OK;
    LONG lr;

    lr = RegQueryValueEx(_hKey, wszValueName, NULL, NULL, NULL, pcb);

    if (lr != ERROR_SUCCESS)
    {
        Dbg(DEB_ERROR,
            "CSafeReg::QueryBufSize: error %uL for value '%s'\n",
            lr,
            wszValueName);
        hr = E_FAIL;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryDword
//
//  Synopsis:   Fill *[pdw] with the reg dword for value [wszValueName] on
//              this key.
//
//  Arguments:  [wszValueName] - name of dword value
//              [pdw]          - filled with dword
//
//  Returns:    HRESULT from Registry call.
//
//  Modifies:   *[pdw]
//
//  History:    1-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryDword(
    LPWSTR wszValueName,
    LPDWORD pdw)
{
    // TRACE_METHOD(CSafeReg, QueryDword);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    ULONG   cbData = sizeof(*pdw);
    ULONG   ulType;

    LONG lr = RegQueryValueEx(_hKey,
                              wszValueName,
                              NULL,
                              &ulType,
                              (LPBYTE) pdw,
                              &cbData);
    if (lr != ERROR_SUCCESS)
    {
        Dbg(DEB_ERROR,
            "CSafeReg::QueryDword: error %uL for value '%s'\n",
            lr,
            wszValueName);
        hr = E_FAIL;
    }
    else
    {
        ASSERT(REG_DWORD == ulType);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryPath
//
//  Synopsis:   Query this key for a value named [pwszValueName], which is
//              expected to be of type REG_SZ or REG_EXPAND_SZ, and put
//              the result in [pwszPathBuf].
//
//  Arguments:  [pwszValueName] - value to query for
//              [pwszPathBuf]   - buffer for string
//              [cchPathBuf]    - size, in wchars, of [pwszPathBuf]
//              [fExpand]       - TRUE=>expand a REG_EXPAND_SZ string,
//                                  FALSE=>just copy it
//
//  Returns:    S_OK - [pwszPathBuf] valid
//              E_*  - [pwszPathBuf] is an empty string
//
//  Modifies:   *[pwszPathBuf]
//
//  History:    2-10-1997   DavidMun   Created
//
//  Notes:      Strings are expanded using environment variables for the
//              current process, i.e., on the local machine, even if this
//              contains a key to a remote machine's registry.
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryPath(
    LPWSTR pwszValueName,
    LPWSTR pwszPathBuf,
    ULONG  cchPathBuf,
    BOOL   fExpand)
{
    // TRACE_METHOD(CSafeReg, QueryPath);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    DWORD   dwType;

    LONG lr;
    ULONG cbPath = cchPathBuf * sizeof(WCHAR);
    lr = RegQueryValueEx(_hKey,
                         pwszValueName,
                         NULL,
                         &dwType,
                         (LPBYTE) pwszPathBuf,
                         &cbPath);

    if (lr == ERROR_SUCCESS && dwType == REG_EXPAND_SZ)
    {
        if (fExpand)
        {
            LPWSTR pwszExpandedPath = new WCHAR[cchPathBuf];

            if (pwszExpandedPath)
            {
                lr = ExpandEnvironmentStrings(pwszPathBuf,
                                              pwszExpandedPath,
                                              cchPathBuf);

                if (!lr || (ULONG) lr > cchPathBuf)
                {
                    if (!lr)
                    {
                        hr = HRESULT_FROM_LASTERROR;
                        DBG_OUT_LASTERROR;
                    }
                    else
                    {
                        hr = E_FAIL;
                        Dbg(DEB_ERROR,
                            "CSafeReg::QueryPath: expanded string needs %u char buffer\n",
                            lr);
                    }
                }
                else
                {
                    lstrcpy(pwszPathBuf, pwszExpandedPath);
                }
                delete [] pwszExpandedPath;
            }
            else
            {
                hr = E_OUTOFMEMORY;
                DBG_OUT_HRESULT(hr);
            }
        }
    }
    else if (lr == ERROR_SUCCESS && dwType != REG_SZ)
    {
        hr = E_FAIL;
        Dbg(DEB_ERROR,
            "CSafeReg::QueryPath: value '%s' has unexpected type %uL\n",
            pwszValueName,
            dwType);
    }
    else
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }

    if (FAILED(hr))
    {
        *pwszPathBuf = L'\0';
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryStr
//
//  Synopsis:   Query for a value named [pwszValueName] and put its string
//              value (REG_SZ, MULTI_SZ, or EXPAND_SZ) into [pwszBuf].
//
//  Arguments:  [pwszValueName] - name to query for
//              [pwszBuf]       - destination buffer
//              [cchBuf]        - size, in chars, of [pwszBuf]
//
//  Returns:    HRESULT
//
//  Modifies:   *[pwszBuf]; on failure it is set to an empty string.
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryStr(
    LPWSTR pwszValueName,
    LPWSTR pwszBuf,
    ULONG  cchBuf)
{
    // TRACE_METHOD(CSafeReg, QueryStr);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    DWORD   dwType;

    LONG lr;
    ULONG cbBuf = cchBuf * sizeof(WCHAR);

    lr = RegQueryValueEx(_hKey,
                         pwszValueName,
                         NULL,
                         &dwType,
                         (LPBYTE) pwszBuf,
                         &cbBuf);

    if (lr == ERROR_SUCCESS    &&
        dwType != REG_SZ       &&
        dwType != REG_MULTI_SZ &&
        dwType != REG_EXPAND_SZ)
    {
        hr = E_FAIL;
        Dbg(DEB_ERROR,
            "CSafeReg::QueryStr: value '%s' has unexpected type %uL\n",
            pwszValueName,
            dwType);
    }
    else if (lr != ERROR_SUCCESS)
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }

    if (FAILED(hr))
    {
        *pwszBuf = L'\0';
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::SetDword
//
//  Synopsis:   Set a value with name [wszValueName] and type REG_DWORD on
//              the currently open key.
//
//  Arguments:  [wszValueName] - name of value to create or set
//              [dw]           - dword to set
//
//  Returns:    Result of RegSetValueEx call.
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::SetDword(
    LPWSTR wszValueName,
    DWORD dw)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;

    LONG lr = RegSetValueEx(_hKey,
                            wszValueName,
                            0,
                            REG_DWORD,
                            (PBYTE) &dw,
                            sizeof dw);

    if (lr != ERROR_SUCCESS)
    {
        Dbg(DEB_ERROR,
            "CSafeReg::WriteDword: error %uL for value '%s'\n",
            lr,
            wszValueName);
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::SetValue
//
//  Synopsis:   Set the specified value
//
//  Arguments:  [wszValueName] - name of value, can be NULL if [ulType] is
//                                  REG_SZ
//              [ulType]       - REG_* type
//              [pbValue]      - points to value data
//              [cbValue]      - size, in bytes, of value data
//
//  Returns:    HRESULT
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::SetValue(
    LPCWSTR wszValueName,
    ULONG   ulType,
    const BYTE *pbValue,
    ULONG   cbValue)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    LONG lr = RegSetValueEx(_hKey,
                            wszValueName,
                            0,
                            ulType,
                            pbValue,
                            cbValue);

    if (lr != ERROR_SUCCESS)
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\page.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       page.cxx
//
//  Contents:   Implementation of base class for property sheet pages.
//
//  Classes:    CPropSheetPage
//
//  History:    12-14-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


//+--------------------------------------------------------------------------
//
//  Member:     CPropSheetPage::_EnableApply
//
//  Synopsis:   Enable or disable the Apply button, marking this page as
//              clean or dirty.
//
//  Arguments:  [fEnable] - TRUE: enable button, mark dirty.
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CPropSheetPage::_EnableApply(BOOL fEnable)
{
    if (fEnable)
    {
        PropSheet_Changed(GetParent(_hwnd), _hwnd);
        _SetFlag(PAGE_IS_DIRTY);
    }
    else
    {
        PropSheet_UnChanged(GetParent(_hwnd), _hwnd);
        _ClearFlag(PAGE_IS_DIRTY);
    }
}





//+--------------------------------------------------------------------------
//
//  Function:   CPropSheetPage::DlgProc, static windows callback
//
//  Synopsis:   Dialog procedure for property sheet page
//
//  Arguments:  [hwnd]    - Standard Windows
//              [message] - Standard Windows
//              [wParam]  - Standard Windows
//              [lParam]  - on WM_INITDIALOG, this
//
//  Returns:    Standard Windows
//
//  History:    12-13-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

INT_PTR CALLBACK
CPropSheetPage::DlgProc(
        HWND hwnd,
        UINT message,
        WPARAM wParam,
        LPARAM lParam)
{
    CPropSheetPage *pThis = (CPropSheetPage *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (message)
    {

    case WM_INITDIALOG:
    {
        //
        // pThis isn't valid because we haven't set DWLP_USER yet.  Make
        // it valid.
        //

        PROPSHEETPAGE *pPSP = (PROPSHEETPAGE *) lParam;
        pThis = (CPropSheetPage *)pPSP->lParam;
        ASSERT(pThis);

        //
        // Save away the pointer to this so this static method can call
        // non-static members.
        //

        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR) pThis);
        pThis->_hwnd = hwnd;
        pThis->_OnInit((LPPROPSHEETPAGE) lParam);
        break;
    }

    case WM_COMMAND:
        if (pThis)
        {
            pThis->_OnCommand(wParam, lParam);
        }
        break;

    case WM_NOTIFY:
    {
        ULONG ulResult = 0;

        switch (((LPNMHDR) lParam)->code)
        {
        case PSN_SETACTIVE:
            ulResult = pThis->_OnSetActive();
            break;

        case PSN_KILLACTIVE:
            ulResult = pThis->_OnKillActive();
            break;

        case PSN_APPLY:
            if (!pThis->_IsFlagSet(PAGE_GOT_RESET))
            {
                ulResult = pThis->_OnApply();
            }
            break;

        case PSN_RESET:
            pThis->_SetFlag(PAGE_GOT_RESET);
            CloseEventViewerChildDialogs();
            break;

        default:
            ulResult = pThis->_OnNotify((LPNMHDR)lParam);
            break;
        }
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, ulResult);
        return ulResult;
    }

    case WM_SYSCOLORCHANGE:
        pThis->_OnSysColorChange();
        break;

    case WM_DESTROY:

        //
        // It's possible to get a WM_DESTROY message without having gotten
        // a WM_INITDIALOG if loading a dll that the dialog needs (e.g.
        // comctl32.dll) fails, so guard pThis access here.
        //

        if (pThis)
        {
            pThis->_OnDestroy();
        }
        break;

    case PSM_QUERYSIBLINGS:
    {
        ULONG ulResult = pThis->_OnQuerySiblings(wParam, lParam);
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, ulResult);
        break;
    }

    case WM_SETTINGCHANGE:
    {
      if (pThis)
      {
         pThis->_OnSettingChange(wParam, lParam);
         return FALSE;
      }
      break;
    }

    case WM_HELP:
    case WM_CONTEXTMENU:
        pThis->_OnHelp(message, wParam, lParam);
        return TRUE;
    }

    return FALSE;
}



void
CPropSheetPage::_OnSettingChange(WPARAM wParam, LPARAM lParam)
{
   // do nothing.
}



//+--------------------------------------------------------------------------
//
//  Function:   PropSheetCallback
//
//  Synopsis:   Handle cleanup message so our property sheet page object is
//              always destroyed.
//
//  Arguments:  [hwnd] - ignored
//              [uMsg] - PSPCB_RELEASE or ignored
//              [ppsp] - page affected
//
//  Returns:    TRUE
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

UINT CALLBACK
PropSheetCallback(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp)
{
    if (uMsg == PSPCB_RELEASE)
    {
        delete (CPropSheetPage *) ppsp->lParam;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\reclist.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       reclist.cxx
//
//  Contents:   Implementation of a class to maintain a list of the event
//              log record numbers of the events appearing in the result
//              pane.
//
//  Classes:    CRecList
//
//  History:    07-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------


#include "headers.hxx"
#pragma hdrstop

#define RECLIST_START_SIZE      256
#define MIN_RANGE_LIST_SIZE     3
#define MIN_SERIES_LIST_SIZE    2
#define MIN_EXPAND_BY           16

#if (DBG == 1)
#define ASSERT_EMPTY                ASSERT(!_cItems); \
                                    ASSERT(!_cRecNos)
#else
#define ASSERT_EMPTY
#endif // (DBG == 1)


//+--------------------------------------------------------------------------
//
//  Member:     CRecList::CRecList
//
//  Synopsis:   ctor
//
//  History:    07-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CRecList::CRecList():
    _cMaxItems(0),
    _cItems(0),
    _cRecNos(0),
    _idxLastList(0),
    _pulRecList(NULL)
{
    TRACE_CONSTRUCTOR(CRecList);
}




//+--------------------------------------------------------------------------
//
//  Member:     CRecList::Init
//
//  Synopsis:   Make initial allocation.
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  History:    07-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CRecList::Init()
{
    TRACE_METHOD(CRecList, Init);
    ASSERT(!_cMaxItems);
    ASSERT(!_pulRecList);
    ASSERT_EMPTY;

    HRESULT hr = S_OK;

    _cMaxItems = RECLIST_START_SIZE;
    _pulRecList = new ULONG [_cMaxItems];

    if (!_pulRecList)
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(hr);
        _cMaxItems = 0;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRecList::Clear
//
//  Synopsis:   Mark the list as empty.
//
//  History:    06-30-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CRecList::Clear()
{
    TRACE_METHOD(CRecList, Clear);

    _cItems = 0;
    _idxLastList = 0;
    _cRecNos = 0;

    if (_cMaxItems > 2 * RECLIST_START_SIZE)
    {
        delete [] _pulRecList;
        _cMaxItems >>= 1;
        _pulRecList = new ULONG [_cMaxItems];

        if (!_pulRecList)
        {
            DBG_OUT_HRESULT(E_OUTOFMEMORY);
            _cMaxItems = 0;
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CRecList::~CRecList
//
//  Synopsis:   dtor
//
//  History:    07-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CRecList::~CRecList()
{
    TRACE_DESTRUCTOR(CRecList);

    delete [] _pulRecList;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRecList::Append
//
//  Synopsis:   Append record number [ulRecNo] to the end of the list.
//
//  Arguments:  [ulRecNo] - number to append
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//  History:    07-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CRecList::Append(
    ULONG ulRecNo)
{
    HRESULT hr = S_OK;

    do
    {
        if (!_cMaxItems)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        if (!_cItems)
        {
            ASSERT(!_idxLastList);
            ASSERT(!_cRecNos);

            // List is empty.  Set list to series containing ulRecNo.

            hr = _ExpandBy(MIN_SERIES_LIST_SIZE);
            BREAK_ON_FAIL_HRESULT(hr);
            ASSERT(_cItems == MIN_SERIES_LIST_SIZE);

            _pulRecList[0] = 1; // series_count
            _pulRecList[1] = ulRecNo;
            break;
        }

        // List is not empty

        if (_EndsInRangeList())
        {
            // List ends in range

            ULONG idxLastRange = _GetEndingRangeIndex();
            ULONG ulNewDelta;
            BOOL  fExtendsRange;

            fExtendsRange = _RecExtendsRange(&_pulRecList[idxLastRange],
                                             ulRecNo,
                                             &ulNewDelta);

            if (fExtendsRange)
            {
                //
                // ulRecNo is contiguous with last element of range.  Extend
                // range to include ulRecNo.
                //

                _pulRecList[idxLastRange + 1] = ulNewDelta;
            }
            else
            {
                //
                // ulRecNo is not contiguous with last element of range.
                // Append new series containing ulRecNo.
                //

                hr = _ExpandBy(MIN_SERIES_LIST_SIZE);
                BREAK_ON_FAIL_HRESULT(hr);

                // _cItems has been updated

                _idxLastList = _cItems - 2;
                _pulRecList[_idxLastList] = 1;
                _pulRecList[_idxLastList + 1] = ulRecNo;
            }
            break;
        }

        // List is not empty and ends in series.

        if (_pulRecList[_idxLastList] < 2)
        {
            // series has only one element; append ulRecNo

            ASSERT(_pulRecList[_idxLastList] == 1);
            hr = _ExpandBy(1);
            BREAK_ON_FAIL_HRESULT(hr);

            _pulRecList[_idxLastList]++; // bump count in series
            _pulRecList[_cItems - 1] = ulRecNo;
            break;
        }

        //
        // The series has at least two elements.
        //
        // If it has exactly 2 elements, and they form a range with ulRecNo,
        // then convert the series into a range.  Note this doesn't require
        // expanding the array.
        //
        // If it has more than 2 elements, expand the array by 1 and split
        // the last two elements of the series off to form a range with
        // ulRecNo.
        //

        ASSERT(_cItems - 2 > _idxLastList);

        BOOL  fFormsRange;
        ULONG ulRangeDelta;
        ULONG aulSeriesToTest[] =
        {
            _pulRecList[_cItems - 2],
            _pulRecList[_cItems - 1],
            ulRecNo
        };

        fFormsRange = _RecsFormRange(aulSeriesToTest, 3, &ulRangeDelta);

        if (fFormsRange)
        {
            if (_pulRecList[_idxLastList] != 2)
            {
                //
                // currently have:  want this:
                //
                // ...              ...
                // series_count,    series_count - 2,
                // recno1,          recno1,
                // ...              recnoN - 2,
                // recnoN - 2,      range_count (== 1)
                // recnoN - 1,      starting recno
                // recnoN           range delta (ulRangeDelta)
                //

                hr = _ExpandBy(1);
                BREAK_ON_FAIL_HRESULT(hr);

                _pulRecList[_idxLastList] -= 2; // splitting off last 2 items
                                                // into a new range list
                _idxLastList = _cItems - 3;     // point at the new range_list
            }
            // else
            // {
            //     converting series in-place to range.
            //
            //     currently have:      want this:
            //     ...                  ...
            //     series_count (==2)   range_count (== 0x80000001)
            //     recno1               starting recno
            //     recno2               range delta
            // }

            _pulRecList[_idxLastList] = RANGE_COUNT_BIT | 1;  // one range
            _pulRecList[_idxLastList + 1] = aulSeriesToTest[0];
            _pulRecList[_idxLastList + 2] = ulRangeDelta;
            break;
        }

        //
        // List is not empty and ends in series, the end of which does not
        // form a range with ulRecNo.
        //
        // Append ulRecNo to series.
        //

        hr = _ExpandBy(1);
        BREAK_ON_FAIL_HRESULT(hr);

        // _cItems has been updated

        _pulRecList[_idxLastList]++;
        _pulRecList[_cItems - 1] = ulRecNo;

    } while (0);

    if (SUCCEEDED(hr))
    {
        _cRecNos++;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRecList::Discard
//
//  Synopsis:   Delete from the record list all records that are <= the
//              record number [ulBadRec].
//
//  Arguments:  [ulBadRecno] - the record which should be deleted.
//
//  History:    07-05-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CRecList::Discard(
    ULONG ulBadRecNo)
{
    TRACE_METHOD(CRecList, Discard);

    SORTKEY *pSortKeyList = NULL;
    HRESULT hr = AllocSortKeyList(&pSortKeyList);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return;
    }

    ULONG cKeys = _cRecNos;

    Clear();

    ULONG i;
    for (i = 0; i < cKeys; i++)
    {
        if (pSortKeyList[i].ulRecNo > ulBadRecNo)
        {
            hr = Append(pSortKeyList[i].ulRecNo);
            BREAK_ON_FAIL_HRESULT(hr);
        }
    }
    delete [] pSortKeyList;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRecList::CreateFromSortKeyList
//
//  Synopsis:   Create a record list from the array of sort keys.
//
//  Arguments:  [aSortKeys] - array of sort keys
//              [cKeys]     - number of keys in array
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  History:    07-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CRecList::CreateFromSortKeyList(
    SORTKEY aSortKeys[],
    ULONG cKeys)
{
    ASSERT_EMPTY;

    ULONG i;
    HRESULT hr = S_OK;

    TIMER(Creating RecList from SortKeyList);

    for (i = 0; i < cKeys; i++)
    {
        hr = Append(aSortKeys[i].ulRecNo);
        BREAK_ON_FAIL_HRESULT(hr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRecList::AllocSortKeyList
//
//  Synopsis:   Create and partially initialize an array of SORTKEY
//              structures.
//
//  Arguments:  [ppSortKeyList] - filled with pointer to new array
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  Modifies:   *[ppSortKeyList]
//
//  History:    07-02-1997   DavidMun   Created
//
//  Notes:      Initializes the SORTKEY.ulRecNo field for each of the
//              array elements.  Caller is responsible for initializing the
//              key field and for freeing the array using operator delete.
//
//---------------------------------------------------------------------------

HRESULT
CRecList::AllocSortKeyList(
    SORTKEY **ppSortKeyList)
{
    HRESULT hr = S_OK;
    *ppSortKeyList = NULL;

    do
    {
        if (!_cRecNos)
        {
            ASSERT(!_cItems);
            break;
        }
        ASSERT(_cItems);

        *ppSortKeyList = new SORTKEY [_cRecNos];

        if (!*ppSortKeyList)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        ULONG i = 0;
        SORTKEY *pCurSortKey = *ppSortKeyList;

        while (i < _cItems)
        {
            ASSERT(_pulRecList[i] & ~RANGE_COUNT_BIT); // zero length lists are
                                                       // not allowed

            if (_IsRangeListStart(_pulRecList[i]))
            {
                ULONG cRanges = _RangeListStartToRangeCount(_pulRecList[i]);
                ULONG j;

                i++; // move to first range
                for (j = 0; j < cRanges; j++)
                {
                    ULONG ulRecNo;
                    ULONG ulEndRecNo = _pulRecList[i] + _pulRecList[i + 1];

                    if ((LONG) _pulRecList[i + 1] > 0)
                    {
                        for (ulRecNo = _pulRecList[i];
                             ulRecNo <= ulEndRecNo;
                             ulRecNo++)
                        {
                            pCurSortKey->ulRecNo = ulRecNo;
                            pCurSortKey++;
                        }
                    }
                    else
                    {
                        for (ulRecNo = _pulRecList[i];
                             ulRecNo >= ulEndRecNo;
                             ulRecNo--)
                        {
                            pCurSortKey->ulRecNo = ulRecNo;
                            pCurSortKey++;
                        }
                    }

                    i += 2; // move to next range
                }
            }
            else
            {
                ULONG j;

                for (j = 0; j < _pulRecList[i]; j++)
                {
                    pCurSortKey->ulRecNo = _pulRecList[i + j + 1];
                    pCurSortKey++;
                }
                i += _pulRecList[i] + 1; // skip past end of series
            }
        }
        ASSERT(i == _cItems);
        ASSERT((ULONG)(pCurSortKey - *ppSortKeyList) == _cRecNos);
    } while (0);
    return hr;
}





#if (DBG == 1)

#define DUMP_LINE_WIDTH 80
#define WORST_CASE_SINGLE_WIDTH 12  // ", 4294967295"

//+--------------------------------------------------------------------------
//
//  Member:     CRecList::Dump
//
//  Synopsis:   Dump the range to the debugger.
//
//  History:    06-30-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CRecList::Dump()
{
    if (!_cMaxItems)
    {
        Dbg(DEB_FORCE, "CRecList::Dump: RecList has not been allocated\n");
        ASSERT(!_pulRecList);
        ASSERT(!_idxLastList);
        return;
    }

    ASSERT(_pulRecList);

    if (!_cItems)
    {
        Dbg(DEB_FORCE, "CRecList::Dump: RecList is empty\n");
        ASSERT(!_idxLastList);
        ASSERT(!_cRecNos);
        return;
    }

    Dbg(DEB_FORCE, "Dumping RecList at 0x%x:\n", _pulRecList);
    Dbg(DEB_FORCE, "  %u event log records\n", _cRecNos);
    Dbg(DEB_FORCE, "  represented using %u items\n", _cItems);
    Dbg(DEB_FORCE, "  current capacity %u items\n", _cMaxItems);
    Dbg(DEB_FORCE, "  last list is %s and starts at item %u (0x%x)\n",
        _EndsInRangeList() ? L"range" : L"series",
        _idxLastList,
        &_pulRecList[_idxLastList]);

    ULONG i = 0;

    while (i < _cItems)
    {
        if (_IsRangeListStart(_pulRecList[i]))
        {
            ULONG ulRangeCount = _RangeListStartToRangeCount(_pulRecList[i]);
            ULONG j;

            i++; // advance to first range

            for (j = 0; j < ulRangeCount; j++)
            {
                Dbg(DEB_FORCE,
                    "%u-%u\n",
                    _pulRecList[i],
                    _pulRecList[i] + _pulRecList[i + 1]);
                i += 2; // advance past range just printed
            }
        }
        else
        {
            ULONG ulSinglesCount = _pulRecList[i];
            ULONG j;
            WCHAR wszLine[DUMP_LINE_WIDTH + 1] = L"";
            BOOL  fNeedComma = FALSE;
            LONG  cchRemain = ARRAYLEN(wszLine);

            i++; // advance to first item

            for (j = 0; j < ulSinglesCount; j++)
            {
                if (cchRemain < WORST_CASE_SINGLE_WIDTH)
                {
                    Dbg(DEB_FORCE, "%ws\n", wszLine);
                    wszLine[0] = L'\0';
                    cchRemain = ARRAYLEN(wszLine);
                    fNeedComma = FALSE;
                }

                if (fNeedComma)
                {
                    wcscpy(&wszLine[ARRAYLEN(wszLine) - cchRemain], L", ");
                    cchRemain -= 2;
                }

                cchRemain -= wsprintf(&wszLine[ARRAYLEN(wszLine) - cchRemain],
                                      L"%u",
                                      _pulRecList[i]);
                fNeedComma = TRUE;
                i++;
            }

            if (*wszLine)
            {
                Dbg(DEB_FORCE, "%ws\n", wszLine);
            }
        }
    }

    ASSERT(i == _cItems);
}

#endif (DBG == 1)




//+--------------------------------------------------------------------------
//
//  Member:     CRecList::_ExpandBy
//
//  Synopsis:   Increase the count of items by [cItems].
//
//  Arguments:  [cItems] - number of items to make room for.
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  History:    07-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CRecList::_ExpandBy(
    ULONG cItems)
{
    // TRACE_METHOD(CRecList, _ExpandBy);

    HRESULT hr = S_OK;
    ULONG *pNewRecList = NULL;

    do
    {
        // if there's room, just increase the count of valid items

        if (_cItems + cItems <= _cMaxItems)
        {
            _cItems += cItems;
            break;
        }

        // need to allocate some memory

        pNewRecList = new ULONG[_cMaxItems + max(cItems, MIN_EXPAND_BY)];

        if (!pNewRecList)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        // copy any existing records

        if (_pulRecList)
        {
            CopyMemory(pNewRecList,
                       _pulRecList,
                       _cItems * sizeof(_pulRecList[0]));
            delete [] _pulRecList;
        }

        _pulRecList = pNewRecList;
        _cMaxItems += max(cItems, MIN_EXPAND_BY);
        _cItems += cItems;
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRecList::IndexToRecNo
//
//  Synopsis:   Return the [ulIndex]th record number in the list.
//
//  Arguments:  [ulIndex] - 0..n, n < number of records in list.
//
//  Returns:    Record number
//
//  History:    07-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CRecList::IndexToRecNo(
    ULONG ulTargetIndex)
{
    // TRACE_METHOD(CRecList, IndexToRecNo);

    ULONG i = 0;
    ULONG ulCurIndex = 0; // listview index

    while (i < _cItems)
    {
        if (_IsRangeListStart(_pulRecList[i]))
        {
            ULONG cRanges = _RangeListStartToRangeCount(_pulRecList[i]);
            ULONG j;

            i++; // move to first range

            for (j = 0; j < cRanges; j++)
            {
                LONG lDelta = (LONG) _pulRecList[i + 1];
                ULONG cRecsInRange;

                if (lDelta < 0)
                {
                    cRecsInRange = -lDelta + 1;

                    if (ulCurIndex + cRecsInRange > ulTargetIndex)
                    {
                        return _pulRecList[i] - (ulTargetIndex - ulCurIndex);
                    }
                }
                else if (lDelta > 0)
                {
                    cRecsInRange = lDelta + 1;

                    if (ulCurIndex + cRecsInRange > ulTargetIndex)
                    {
                        return _pulRecList[i] + (ulTargetIndex - ulCurIndex);
                    }
                }
                else
                {
                    Dbg(DEB_ERROR,
                        "*** ERROR *** CRecList::IndexToRecNo(%x) for index %u: lDelta (item %u) is 0\n",
                        this,
                        ulTargetIndex,
                        i+1);
                    return 0;
                }

                ulCurIndex += cRecsInRange;
                i += 2; // move past this range
            }
        }
        else
        {
            ULONG cRecs = _pulRecList[i];

            if (ulCurIndex + cRecs > ulTargetIndex)
            {
                return _pulRecList[i + 1 + (ulTargetIndex - ulCurIndex)];
            }

            ulCurIndex += cRecs;
            i += cRecs + 1;
        }
    }

#if (DBG == 1)

    Dbg(DEB_ERROR,
        "*** ERROR *** CRecList::IndexToRecNo: target index %uL not found\n",
        ulTargetIndex);
#endif // (DBG == 1)

    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRecList::RecNoToIndex
//
//  Synopsis:   Return the listview index which contains record [ulRecNo].
//
//  Arguments:  [ulRecNo]  - event log record number to search for
//              [pulIndex] - filled with index of listview row which is
//                             displaying the record.
//
//  Returns:    S_OK         - record found, *[pulIndex] is valid
//              E_INVALIDARG - record [ulRecNo] not found, *[pulIndex] is 0
//
//  History:    07-05-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CRecList::RecNoToIndex(
    ULONG ulRecNo,
    ULONG *pulIndex)
{
    //TRACE_METHOD(CRecList, RecNoToIndex);

    HRESULT hr = E_INVALIDARG;
    BOOL fDone = FALSE;
    ULONG i = 0;
    ULONG ulCurIndex = 0; // listview index
    *pulIndex = 0;

    while (i < _cItems && !fDone)
    {
        if (_IsRangeListStart(_pulRecList[i]))
        {
            ULONG cRanges = _RangeListStartToRangeCount(_pulRecList[i]);
            ULONG j;

            i++; // move to first range

            for (j = 0; j < cRanges; j++)
            {
                LONG lDelta = (LONG) _pulRecList[i + 1];
                ULONG cRecsInRange;

                ASSERT(lDelta);

                if (lDelta < 0)
                {
                    cRecsInRange = -lDelta + 1;
                    ULONG ulFirstRecInRange = _pulRecList[i] + (ULONG) lDelta;
                    ULONG ulLastRecInRange = _pulRecList[i];

                    if (ulRecNo >= ulFirstRecInRange &&
                        ulRecNo <= ulLastRecInRange)
                    {
                        *pulIndex = ulCurIndex + (ulLastRecInRange - ulRecNo);
                        hr = S_OK;
                        fDone = TRUE;
                        break;
                    }
                }
                else if (lDelta > 0)
                {
                    cRecsInRange = lDelta + 1;
                    ULONG ulFirstRecInRange = _pulRecList[i];
                    ULONG ulLastRecInRange = _pulRecList[i] + (ULONG) lDelta;

                    if (ulRecNo >= ulFirstRecInRange &&
                        ulRecNo <= ulLastRecInRange)
                    {
                        *pulIndex = ulCurIndex + (ulRecNo - ulFirstRecInRange);
                        hr = S_OK;
                        fDone = TRUE;
                        break;
                    }
                }
                else
                {
                    fDone = TRUE;
                    break;
                }

                ulCurIndex += cRecsInRange;
                i += 2; // move past this range
            }
        }
        else
        {
            ULONG cRecs = _pulRecList[i];
            ULONG j;

            for (j = 0; j < cRecs; j++)
            {
                if (ulRecNo == _pulRecList[(i + 1) + j])
                {
                    *pulIndex = ulCurIndex;
                    hr = S_OK;
                    fDone = TRUE;
                    break;
                }
                ulCurIndex++;
            }

            i += cRecs + 1;
        }
    }

#if 0
    if (SUCCEEDED(hr))
    {
        Dbg(DEB_TRACE,
            "Found record %u at listview index %u\n",
            ulRecNo,
            *pulIndex);
    }
    else
    {
        Dbg(DEB_TRACE, "Could not find record %u\n", ulRecNo);
    }
#endif
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRecList::_RecExtendsRange
//
//  Synopsis:   Return TRUE if [ulRecNo] lies just past the record number
//              at the end of [pulRange].
//
//  Arguments:  [pulRange]    - pointer to range
//              [ulRecNo]     - record number to test
//              [pulNewDelta] - new delta value to extend range to include
//                               [ulRecNo].
//
//  Returns:    TRUE if [ulRecNo] extends range, FALSE otherwise.
//
//  Modifies:   *[pulNewDelta]
//
//  History:    07-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CRecList::_RecExtendsRange(
    ULONG *pulRange,
    ULONG ulRecNo,
    ULONG *pulNewDelta)
{
    LONG lDelta = (LONG) pulRange[1];

    if (lDelta < 0)
    {
        if (pulRange[0] + pulRange[1] - 1 == ulRecNo)
        {
            *pulNewDelta = pulRange[1] - 1;
            return TRUE;
        }
    }
    else
    {
        if (pulRange[0] + pulRange[1] + 1 == ulRecNo)
        {
            *pulNewDelta = pulRange[1] + 1;
            return TRUE;
        }
    }
    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRecList::_RecsFormRange
//
//  Synopsis:   Return TRUE if the record numbers in [aulSeriesToTest] are
//              contiguous and monotonically increasing or decreasing.
//
//  Arguments:  [aulSeriesToTest] - array of record numbers to test
//              [cRecsInSeries]   - number of RecNos in array
//              [pulRangeDelta]   - if non-NULL, filled with delta to use
//                                   to describe range
//
//  Returns:    TRUE  - series can be represented as a range
//              FALSE - it can't
//
//  Modifies:   *[pulRangeDelta]
//
//  History:    07-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CRecList::_RecsFormRange(
    ULONG aulSeriesToTest[],
    ULONG cRecsInSeries,
    ULONG *pulRangeDelta)
{
    ASSERT(cRecsInSeries > 1);

    LONG lIncrement;
    ULONG i;

    //
    // Look at first two items to determine whether to expect an increasing
    // or decreasing series of RecNos.
    //

    if (aulSeriesToTest[0] < aulSeriesToTest[1])
    {
        lIncrement = 1;
    }
    else
    {
        lIncrement = -1;
    }

    for (i = 1; i < cRecsInSeries; i++)
    {
        if (aulSeriesToTest[i-1] + (ULONG)lIncrement != aulSeriesToTest[i])
        {
            return FALSE;
        }
    }

    if (pulRangeDelta)
    {
        *pulRangeDelta = (ULONG)((LONG)(cRecsInSeries - 1) * lIncrement);
    }
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRecList::Reverse
//
//  Synopsis:   Reverse the record list.
//
//  History:    07-03-1997   DavidMun   Created
//
//  Notes:      Since the array is being reversed in-place, no allocations
//              need be made, so this routine can't fail.
//
//---------------------------------------------------------------------------

VOID
CRecList::Reverse()
{
    TRACE_METHOD(CRecList, Reverse);

    // No-op on empty list

    if (!_cItems)
    {
        return;
    }

    //
    // There must be at least a series_list or a range_list.
    //


    ASSERT(_cItems >= min(MIN_RANGE_LIST_SIZE, MIN_SERIES_LIST_SIZE));

    //
    // First consider the list as a simple array of ULONGs without any
    // internal structure, and reverse it.
    //

    ULONG ulLeft = 0;
    ULONG ulRight = _cItems - 1;

    while (ulLeft < ulRight)
    {
        ULONG ulTemp = _pulRecList[ulRight];
        _pulRecList[ulRight] = _pulRecList[ulLeft];
        _pulRecList[ulLeft] = ulTemp;

        ulLeft++;
        ulRight--;
    }

    //
    // The range_lists and series_lists are all in the correct location
    // relative to eachother.
    //
    // The series_lists need to be fixed up because the series_count is at
    // the end of the list instead of the start.
    //
    // The range_lists need to be fixed up simimlarly because the range_count
    // is now at the end of the list, instead of the beginning.
    //
    // Also, each range has the range_delta preceding the starting_recno.
    // Finally, the starting_recno must be modified: a range from 5-10
    // must now be 10-5.
    //

    ULONG i = _cItems - 1;

    while ((LONG) i > 0)
    {
        if (_IsRangeListStart(_pulRecList[i]))
        {
            ULONG cRanges = _RangeListStartToRangeCount(_pulRecList[i]);
            ULONG j;

            i--; // move to first range
            for (j = 0; j < cRanges; j++)
            {
                ULONG ulStartRecNo = _pulRecList[i];
                ULONG ulDelta = _pulRecList[i - 1];
                ULONG ulEndRecNo = ulStartRecNo + ulDelta;

                ulDelta = (ULONG) (-1 * (LONG)ulDelta);
                _pulRecList[i - 1] = ulEndRecNo;
                _pulRecList[i] = ulDelta;

                i -= 2; // move to next range
            }

            //
            // All the ranges in this range_list have been fixed up, but the
            // range_count is at the end of the list.
            //
            // i is one less than the index of the location where the
            // range_count should be (the start of the range_list).
            //
            // Save the range_count in j, then move the list right one ulong
            // and put the range_count where it's supposed to be.
            //

            j = _pulRecList[i + 1 + 2 * cRanges];

            MoveMemory(&_pulRecList[i + 2],
                       &_pulRecList[i + 1],
                       cRanges * (2 * sizeof(_pulRecList[0])));

            _pulRecList[i + 1] = j;
        }
        else
        {
            //
            // Move the series_count from the end of the series_list to the
            // start.
            //

            ULONG ulSeriesCount = _pulRecList[i];

            i--; // move past series_count to first recno in series
            i -= ulSeriesCount; // move just past end of series

            MoveMemory(&_pulRecList[i + 2],
                       &_pulRecList[i + 1],
                       sizeof(_pulRecList[0]) * ulSeriesCount);

            _pulRecList[i + 1] = ulSeriesCount;
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CRecList::SetRange
//
//  Synopsis:   Set the list to the given range.
//
//  Arguments:  [ulFirstRecNo] - first record of range
//              [ulDelta]      - range_delta
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  History:    07-01-1997   DavidMun   Created
//
//  Notes:      This method may only be called when the record list has
//              been successfully initialized and is currently empty.
//
//              It's usually used when the event log is unfiltered.
//
//---------------------------------------------------------------------------

HRESULT
CRecList::SetRange(
    ULONG ulFirstRecNo,
    ULONG ulDelta)
{
    ASSERT_EMPTY;
    ASSERT(ulDelta);

    HRESULT hr = _ExpandBy(MIN_RANGE_LIST_SIZE);

    if (SUCCEEDED(hr))
    {
        _pulRecList[0] = RANGE_COUNT_BIT | 1;  // one range
        _pulRecList[1] = ulFirstRecNo;
        _pulRecList[2] = ulDelta;

        if ((LONG) ulDelta < 0)
        {
            _cRecNos = (ULONG)(-1 * (LONG)(ulDelta - 1));
        }
        else
        {
            _cRecNos = ulDelta + 1;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\record.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       record.cxx
//
//  Contents:   Functions to extract data from an event log record
//
//  History:    12-14-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <malloc.h>

//
// Local constants
//

#define MAX_USERNAME_SIZE               30
#define MAX_DOMAIN_SIZE                 MAX_PATH
#define TEMP_STR_BUF                    MAX_PATH



//+--------------------------------------------------------------------------
//
//  Function:   GetDateStr
//
//  Synopsis:   Fill [wszBuf] with a short-format date string describing
//              the date generated value in [pelr].
//
//  Arguments:  [ulDate] - timestamp, in seconds since 1/1/1970
//              [wszBuf] - buffer to fill with result
//              [cchBuf] - size of buffer
//
//  Returns:    [wszBuf], first character is L'\0' on error.
//
//  Modifies:   *[wszBuf]
//
//  History:    12-14-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

LPWSTR
GetDateStr(
    ULONG ulDate,
    LPWSTR wszBuf,
    ULONG cchBuf)
{
    BOOL fOk;
    SYSTEMTIME stGenerated;

    wszBuf[0] = L'\0';

    do
    {
        fOk = SecondsSince1970ToSystemTime(ulDate, &stGenerated);

        if (!fOk)
        {
            break;
        }

        ULONG cch;

        cch = GetDateFormat(LOCALE_USER_DEFAULT,
                            DATE_SHORTDATE,
                            &stGenerated,
                            NULL,
                            wszBuf,
                            cchBuf);

        if (!cch)
        {
            wszBuf[0] = L'\0';
            DBG_OUT_LASTERROR;
        }
    } while (0);

    return wszBuf;
}




//+--------------------------------------------------------------------------
//
//  Function:   GetTimeStr
//
//  Synopsis:   Fill [wszBuf] with a time string describing the time
//              value [ulTime].
//
//  Arguments:  [ulTime]         - time, in seconds since 1/1/1970
//              [wszBuf]         - buffer to fill with result
//              [cchBuf]         - size of buffer
//
//  Returns:    [wszBuf], first character is L'\0' on error.
//
//  Modifies:   *[wszBuf]
//
//  History:    12-14-1996   DavidMun   Created
//              04-12-2001   JonN       Removed pwszTimeFormat parameter
//
//---------------------------------------------------------------------------

LPWSTR
GetTimeStr(
        ULONG ulTime,
        LPWSTR wszBuf,
        ULONG cchBuf)
{
    BOOL fOk;
    SYSTEMTIME stGenerated;

    fOk = SecondsSince1970ToSystemTime(ulTime, &stGenerated);

    if (fOk)
    {
        ULONG cch;

        cch = GetTimeFormat(LOCALE_USER_DEFAULT,
                            0,
                            &stGenerated,
                            NULL,
                            wszBuf,
                            cchBuf);

        if (!cch)
        {
            wszBuf[0] = L'\0';
            DBG_OUT_LASTERROR;
        }
    }
    return wszBuf;
}




//+--------------------------------------------------------------------------
//
//  Function:   GetTypeStr
//
//  Synopsis:   Return a string describing the event type of [pelr].
//
//  History:    12-14-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

LPWSTR
GetTypeStr(
    USHORT usType)
{
    switch (usType)
    {
    case EVENTLOG_ERROR_TYPE:
        return g_awszEventType[IDS_ERROR_TYPE - IDS_SUCCESS_TYPE];

    case EVENTLOG_WARNING_TYPE:
        return g_awszEventType[IDS_WARNING_TYPE - IDS_SUCCESS_TYPE];

    case EVENTLOG_INFORMATION_TYPE:
    // EricB 9/21/01 470346 Show Sucess as Information rather than none.
    case EVENTLOG_SUCCESS:
        return g_awszEventType[IDS_INFORMATION_TYPE - IDS_SUCCESS_TYPE];

    case EVENTLOG_AUDIT_SUCCESS:
        return g_awszEventType[IDS_SUCCESS_TYPE - IDS_SUCCESS_TYPE];

    case EVENTLOG_AUDIT_FAILURE:
        return g_awszEventType[IDS_FAILURE_TYPE - IDS_SUCCESS_TYPE];

    default:
        Dbg(DEB_ERROR,
            "GetTypeStr: Invalid event type 0x%x\n",
            usType);
        return g_awszEventType[IDS_NO_TYPE - IDS_SUCCESS_TYPE];
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   GetCategoryString
//
//  Synopsis:   Fill [wszBuf] with a string describing the category value
//              in [pelr].
//
//  Arguments:  [pli]    - log info for log containing record [pelr].
//              [pelr]   - record for which to retrieve category string
//              [wszBuf] - buffer to fill with result
//              [cchBuf] - size of buffer
//
//  Returns:    [wszBuf]
//
//  Modifies:   *[wszBuf]
//
//  History:    12-14-1996   DavidMun   Created
//              01-05-1997   DavidMun   Reimplement using sources and
//                                       categories objects.
//
//  Notes:      In case of error, [wszBuf] will be filled with string
//              (n), where n is the category value.
//
//---------------------------------------------------------------------------

LPWSTR
GetCategoryStr(
    CLogInfo   *pli,
    EVENTLOGRECORD *pelr,
    LPWSTR      wszBuf,
    ULONG       cchBuf)
{
    //
    // Categories must start at 1 (per the SDK), so if the category value
    // in the event is 0, indicate it has no category.
    //

    if (!pelr->EventCategory)
    {
        lstrcpyn(wszBuf, g_wszNone, cchBuf);
    }
    else
    {
        CSources *pSources = pli->GetSources();
        LPWSTR pwszSource = ::GetSourceStr(pelr);
        CCategories *pCategories = pSources->GetCategories(pwszSource);

        if (pCategories)
        {
            LPCWSTR pwszCategoryStr;

            pwszCategoryStr = pCategories->GetName(pelr->EventCategory);
            lstrcpyn(wszBuf, pwszCategoryStr, cchBuf);
        }
        else
        {
            wsprintf(wszBuf, L"(%u)", pelr->EventCategory);
        }
    }

    return wszBuf;
}




//+--------------------------------------------------------------------------
//
//  Function:   GetUserStr
//
//  Synopsis:   Fill [wszBuf] with a human-readable string representing the
//              user identified by the SID in [pelr].
//
//  Arguments:  [pelr]        - record from which to retrieve SID
//              [wszBuf]      - filled with user name
//              [cchBuf]      - size, in characters, of [wszBuf]
//              [fWantDomain] - if true, string returned is "domain\user",
//                               else it's "user"
//
//  Returns:    [wszBuf]
//
//  Modifies:   *[wszBuf]
//
//  History:    1-13-1997   DavidMun   Created
//
//  Notes:      [wszBuf] is always filled with a string, even on error.
//
//---------------------------------------------------------------------------

LPWSTR
GetUserStr(
        EVENTLOGRECORD *pelr,
        LPWSTR wszBuf,
        ULONG cchBuf,
        BOOL fWantDomain)
{
    //
    // If the current record doesn't have a SID, load the n/a string and
    // return.
    //

    if (!pelr->UserSidLength)
    {
        LoadStr(IDS_USER_NA, wszBuf, cchBuf, L"---");
        return wszBuf;
    }

    //
    // The record has a SID.  See if we've already done the lookup
    // or conversion and cached the resulting string.
    //

    PSID psid = (PSID) (((PBYTE) pelr) + pelr->UserSidOffset);
    // NTRAID#NTBUG9-546298-2002/05/04-ericb
    if (psid >= ((PBYTE)pelr + pelr->Length))
    {
        ASSERT(false);
        LoadStr(IDS_EVENTLOG_FILE_CORRUPT, wszBuf, cchBuf, L"---");
        return wszBuf;
    }
    ULONG sidLength = RtlLengthSid(psid);
    if (((PBYTE)psid + sidLength) > ((PBYTE)pelr + pelr->Length))
    {
        ASSERT(false);
        LoadStr(IDS_EVENTLOG_FILE_CORRUPT, wszBuf, cchBuf, L"---");
        return wszBuf;
    }

    bool fNeedFree = false;

#if defined(_WIN64)

    if (((ULONG_PTR)psid & (sizeof(PVOID)-1)) != 0) {

        //
        // This sid is not properly aligned.  Make a local, aligned
        // copy so that it does not subsequently cause alignment
        // faults.
        // 

        PSID alignedSid;

        // NTRAID#NTBUG9-2002/05/17-623723-ericb: prefast
        alignedSid = malloc( sidLength );
        if (!alignedSid)
        {
            LoadStr(IDS_PROP_OUTOFMEMORY, wszBuf, cchBuf, L"out of memory");
            return wszBuf;
        }
        fNeedFree = true;

        RtlCopyMemory( alignedSid, psid, sidLength );

        psid = alignedSid;
    }

#endif

    // NTRAID#NTBUG9-546298-2002/05/04-ericb
    if (!IsValidSid(psid))
    {
        ASSERT(false);
        if (fNeedFree) free(psid);
        LoadStr(IDS_EVENTLOG_FILE_CORRUPT, wszBuf, cchBuf, L"---");
        return wszBuf;
    }

    WCHAR wszCachedSidStr[MAX_PATH + 1];

    HRESULT hr = g_SidCache.Fetch(psid,
                                  wszCachedSidStr,
                                  ARRAYLEN(wszCachedSidStr));

    if (hr == S_OK)
    {
        //
        // Yes, we've cached this.  It's either a SID as string or
        // domain\user name
        //

        if (fWantDomain)
        {
            lstrcpyn(wszBuf, wszCachedSidStr, cchBuf);
        }
        else
        {
            LPWSTR pwszSlash = wcsrchr(wszCachedSidStr, L'\\');

            if (pwszSlash)
            {
                lstrcpyn(wszBuf, pwszSlash + 1, cchBuf);
            }
            else
            {
                lstrcpyn(wszBuf, wszCachedSidStr, cchBuf);
            }
        }
        if (fNeedFree) free(psid);
        return wszBuf;
    }

    //
    // Nope, this SID isn't in our SID string cache.  Do the work to
    // turn it into a string.
    //

    BOOL         fOk;
    SID_NAME_USE snu;
    WCHAR        wszName[MAX_USERNAME_SIZE];
    ULONG        cchName = ARRAYLEN(wszName);
    WCHAR        wszDomain[MAX_DOMAIN_SIZE];
    ULONG        cchDomain = ARRAYLEN(wszDomain);
    WCHAR        wszDomainAndName[MAX_USERNAME_SIZE + MAX_DOMAIN_SIZE + 1];

    *wszBuf = 0;

    CWaitCursor Hourglass;

    fOk = LookupAccountSid(GetComputerStr(pelr),
                           psid,
                           wszName,
                           &cchName,
                           wszDomain,
                           &cchDomain,
                           &snu);

    if (!fOk)
    {
        Dbg(DEB_IWARN,
            "GetUserStr: LookupAccountSid on %ws error(%uL), retrying on local\n",
            GetComputerStr(pelr),
            GetLastError());

        fOk = LookupAccountSid(NULL,
                               psid,
                               wszName,
                               &cchName,
                               wszDomain,
                               &cchDomain,
                               &snu);

        if (fOk && snu != SidTypeWellKnownGroup)
        {
            Dbg(DEB_ITRACE, "GetUserStr: snu=%u, ignoring\n", snu);
            fOk = FALSE;
        }
    }

    if (!fOk)
    {
        Dbg(DEB_IWARN,
            "GetUserStr: LookupAccountSid error(%uL)\n",
            GetLastError());

        //
        // Couldn't get account name from SID.  Translate the SID to a
        // readable form.
        //

        SidToStr(psid, wszBuf, cchBuf);

        //
        // Enter this in the SID string cache so we don't have to do it
        // again (LookupAccountSid can take 30s on a bad day...).  Note if
        // the Add fails because of out of memory, we ignore it, because if
        // the SID can't be added this time, maybe it will be next time.
        //

        g_SidCache.Add(psid, wszBuf);
    }
    else
    {
        if (*wszDomain)
        {
            lstrcpy(wszDomainAndName, wszDomain);
            lstrcat(wszDomainAndName, L"\\");
            lstrcat(wszDomainAndName, wszName);
        }
        else
        {
            lstrcpy(wszDomainAndName, wszName);
        }

        g_SidCache.Add(psid, wszDomainAndName);

        if (fWantDomain)
        {
            lstrcpyn(wszBuf, wszDomainAndName, cchBuf);
        }
        else
        {
            lstrcpyn(wszBuf, wszName, cchBuf);
        }
    }

    if (fNeedFree) free(psid);

    return wszBuf;
}




//+--------------------------------------------------------------------------
//
//  Function:   SidToStr
//
//  Synopsis:   Convert SID pointed to by pSID to human-readable string in
//              [wszBuf].
//
//  Arguments:  [pSID]   - SID to convert
//              [wszBuf] - destination for string
//              [cchBuf] - size of destination buffer
//
//  Modifies:   *[wszBuf]
//
//  History:    12-09-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
SidToStr(
         PSID pSID,
         LPWSTR wszBuf,
         ULONG cchBuf)
{
    UCHAR   i;
    PISID   piSID = (PISID)pSID;

    //
    // The maximum size string we can produce is:
    //
    // lstrlen("S-255-65535") +
    // lstrlen("-4294967295") * SubAuthorityCount
    // + 1 for null terminator
    //

    if (cchBuf < (11UL + 11UL * piSID->SubAuthorityCount + 1UL))
    {
        DBG_OUT_LRESULT(ERROR_INSUFFICIENT_BUFFER);
        *wszBuf = L'\0';
        ASSERT(FALSE);
        return;
    }

    //
    // Buffer will hold whatever we put in it.  Build the string.
    //

    LPWSTR pwszNext = wszBuf;
    pwszNext += wsprintf(pwszNext, L"S-%u-", (USHORT)piSID->Revision);

    ULONG ulIdentifierAuthority;
    PBYTE pbIdentifierAuthority = (PBYTE)&ulIdentifierAuthority;

    pbIdentifierAuthority[3] = piSID->IdentifierAuthority.Value[2];
    pbIdentifierAuthority[2] = piSID->IdentifierAuthority.Value[3];
    pbIdentifierAuthority[1] = piSID->IdentifierAuthority.Value[4];
    pbIdentifierAuthority[0] = piSID->IdentifierAuthority.Value[5];

    pwszNext += wsprintf(pwszNext, L"%u", ulIdentifierAuthority);

    for (i=0; i < piSID->SubAuthorityCount; i++)
    {
        pwszNext += wsprintf(pwszNext,
                             L"-%u",
                             piSID->SubAuthority[i]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\rsltrecs.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       rsltrecs.cxx
//
//  Contents:   Implementation of class to manage list and caches of event
//              log records appearing in the result pane.
//
//  Classes:    CResultRecs
//
//  History:    07-08-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//
// Forward references
//

//int __cdecl CompareRecNoAscending(   const void *psk1, const void *psk2);
int __cdecl CompareRecNoKeyAscending(const void *psk1, const void *psk2);
int __cdecl CompareTypeAscending(    const void *psk1, const void *psk2);
int __cdecl CompareTimeAscending(    const void *psk1, const void *psk2);
int __cdecl CompareSourceAscending(  const void *psk1, const void *psk2);
int __cdecl CompareCategoryAscending(const void *psk1, const void *psk2);
int __cdecl CompareEventIdAscending( const void *psk1, const void *psk2);
int __cdecl CompareUserAscending(    const void *psk1, const void *psk2);
int __cdecl CompareComputerAscending(const void *psk1, const void *psk2);

int __cdecl CompareRecNoDescending(   const void *psk1, const void *psk2);
int __cdecl CompareRecNoKeyDescending(const void *psk1, const void *psk2);
int __cdecl CompareTypeDescending(    const void *psk1, const void *psk2);
int __cdecl CompareTimeDescending(    const void *psk1, const void *psk2);
int __cdecl CompareSourceDescending(  const void *psk1, const void *psk2);
int __cdecl CompareCategoryDescending(const void *psk1, const void *psk2);
int __cdecl CompareEventIdDescending( const void *psk1, const void *psk2);
int __cdecl CompareUserDescending(    const void *psk1, const void *psk2);
int __cdecl CompareComputerDescending(const void *psk1, const void *psk2);

//
// Types
//

typedef int (__cdecl * QSORTCALLBACK)(const void *, const void *);

//
// Private globals
//

QSORTCALLBACK
s_aSortAscendingCallbacks[] =
{
    CompareTypeAscending,
    CompareTimeAscending,   // for date/time
    CompareTimeAscending,   // for time only
    CompareSourceAscending,
    CompareCategoryAscending,
    CompareEventIdAscending,
    CompareUserAscending,
    CompareComputerAscending
};

QSORTCALLBACK
s_aSortDescendingCallbacks[] =
{
    CompareTypeDescending,
    CompareTimeDescending,
    CompareTimeDescending,
    CompareSourceDescending,
    CompareCategoryDescending,
    CompareEventIdDescending,
    CompareUserDescending,
    CompareComputerDescending
};

//
// Comparison callback functions used with qsort
//

int __cdecl
CompareRecNoDescending(
    const void *psk1,
    const void *psk2)
{
    return (int)((SORTKEY *)psk2)->ulRecNo -
           (int)((SORTKEY *)psk1)->ulRecNo;
}

int __cdecl
CompareRecNoKeyAscending(
    const void *psk1,
    const void *psk2)
{
    return (int)((SORTKEY *)psk1)->Key.ulRecNoKey -
           (int)((SORTKEY *)psk2)->Key.ulRecNoKey;
}

int __cdecl
CompareRecNoKeyDescending(
    const void *psk1,
    const void *psk2)
{
    return (int)((SORTKEY *)psk2)->Key.ulRecNoKey -
           (int)((SORTKEY *)psk1)->Key.ulRecNoKey;
}


int __cdecl
CompareTypeAscending(
    const void *psk1,
    const void *psk2)
{
    int r =(int)(signed char)((SORTKEY *)psk1)->Key.bType -
           (int)(signed char)((SORTKEY *)psk2)->Key.bType;
    // JonN 4/12/01 367216
    return r ? r : CompareRecNoDescending(psk1,psk2);
}




int __cdecl
CompareTypeDescending(
    const void *psk1,
    const void *psk2)
{
    int r =(int)(signed char)((SORTKEY *)psk2)->Key.bType -
           (int)(signed char)((SORTKEY *)psk1)->Key.bType;
    // JonN 4/12/01 367216
    return r ? r : CompareRecNoKeyDescending(psk2,psk1);
}




int __cdecl
CompareTimeAscending(
    const void *psk1,
    const void *psk2)
{
    int r =(int)((SORTKEY *)psk1)->Key.ulTime -
           (int)((SORTKEY *)psk2)->Key.ulTime;
    // JonN 4/12/01 367216
    return r ? r : CompareRecNoDescending(psk1,psk2);
}




int __cdecl
CompareTimeDescending(
    const void *psk1,
    const void *psk2)
{
    int r =(int)((SORTKEY *)psk2)->Key.ulTime -
           (int)((SORTKEY *)psk1)->Key.ulTime;
    // JonN 4/12/01 367216
    return r ? r : CompareRecNoKeyDescending(psk2,psk1);
}




int __cdecl
CompareSourceAscending(
    const void *psk1,
    const void *psk2)
{
    //
    // Note there's no need for case-insensitive comparison, since pwszSource
    // is a pointer into the CSources object's multi-string blob read from
    // the registry.
    //

    int r =lstrcmp(((SORTKEY *)psk1)->Key.pwszSource,
                   ((SORTKEY *)psk2)->Key.pwszSource);
    // JonN 4/12/01 367216
    return r ? r : CompareRecNoDescending(psk1,psk2);
}




int __cdecl
CompareSourceDescending(
    const void *psk1,
    const void *psk2)
{
    int r =lstrcmp(((SORTKEY *)psk2)->Key.pwszSource,
                   ((SORTKEY *)psk1)->Key.pwszSource);
    // JonN 4/12/01 367216
    return r ? r : CompareRecNoKeyDescending(psk2,psk1);
}


#define IS_STRING HIWORD

int __cdecl
CompareCategoryAscending(
    const void *psk1,
    const void *psk2)
{
    LPCWSTR pwszCat1 = ((SORTKEY *)psk1)->Key.pwszCategory;
    LPCWSTR pwszCat2 = ((SORTKEY *)psk2)->Key.pwszCategory;

    if (IS_STRING(pwszCat1))
    {
        if (IS_STRING(pwszCat2))
        {
            int r =lstrcmp(pwszCat1, pwszCat2);
            // JonN 4/12/01 367216
            return r ? r : CompareRecNoDescending(psk1,psk2);
        }
        else
        {
            return 1; // cat1 is string, cat2 is number
        }
    }
    else if (IS_STRING(pwszCat2))
    {
        return -1; // cat1 is number, cat2 is string
    }

    // cat1 and cat2 are numbers

    int r =(INT) (SHORT) ((USHORT) pwszCat1 - (USHORT) pwszCat2);
    // JonN 4/12/01 367216
    return r ? r : CompareRecNoDescending(psk1,psk2);
}




int __cdecl
CompareCategoryDescending(
    const void *psk1,
    const void *psk2)
{
    return CompareCategoryAscending(psk2, psk1);
}




int __cdecl
CompareEventIdAscending(
    const void *psk1,
    const void *psk2)
{
    int r =(int)((SORTKEY *)psk1)->Key.usEventID -
           (int)((SORTKEY *)psk2)->Key.usEventID;
    // JonN 4/12/01 367216
    return r ? r : CompareRecNoDescending(psk1,psk2);
}




int __cdecl
CompareEventIdDescending(
    const void *psk1,
    const void *psk2)
{
    int r =(int)((SORTKEY *)psk1)->Key.usEventID -
           (int)((SORTKEY *)psk2)->Key.usEventID;
    // JonN 4/12/01 367216
    return r ? r : CompareRecNoKeyDescending(psk2,psk1);
}




int __cdecl
CompareUserAscending(
    const void *psk1,
    const void *psk2)
{
    int r =lstrcmp(((SORTKEY *)psk1)->Key.pwszUser,
                   ((SORTKEY *)psk2)->Key.pwszUser);
    // JonN 4/12/01 367216
    return r ? r : CompareRecNoDescending(psk1,psk2);
}




int __cdecl
CompareUserDescending(
    const void *psk1,
    const void *psk2)
{
    int r =lstrcmp(((SORTKEY *)psk2)->Key.pwszUser,
                   ((SORTKEY *)psk1)->Key.pwszUser);
    // JonN 4/12/01 367216
    return r ? r : CompareRecNoKeyDescending(psk2,psk1);
}




int __cdecl
CompareComputerAscending(
    const void *psk1,
    const void *psk2)
{
    int r =lstrcmp(((SORTKEY *)psk1)->Key.pwszComputer,
                   ((SORTKEY *)psk2)->Key.pwszComputer);
    // JonN 4/12/01 367216
    return r ? r : CompareRecNoDescending(psk1,psk2);
}




int __cdecl
CompareComputerDescending(
    const void *psk1,
    const void *psk2)
{
    int r =lstrcmp(((SORTKEY *)psk2)->Key.pwszComputer,
                   ((SORTKEY *)psk1)->Key.pwszComputer);
    // JonN 4/12/01 367216
    return r ? r : CompareRecNoKeyDescending(psk2,psk1);
}




//+--------------------------------------------------------------------------
//
//  Member:     CResultRecs::_CompleteSortKeyListInit
//
//  Synopsis:   Initialized the key values in the sort key list.
//
//  Arguments:  [pSortKeys] - array of keys to be initialized
//              [pcKeys]    - pointer to number of keys in array
//              [SortOrder] - desired order
//
//  Returns:    HRESULT
//
//  History:    07-07-1997   DavidMun   Created
//
//  Notes:      The list was allocated using CRecList::AllocSortKeyList,
//              which initializes the record numbers.
//
//              On input *[pcKeys] is the size of the [pSortKeys] array.
//              On successful return *[pcKeys] is the number of keys that
//              were successfully initialized.
//
//---------------------------------------------------------------------------

HRESULT
CResultRecs::_CompleteSortKeyListInit(
    SORTKEY *pSortKeys,
    ULONG *pcKeys,
    SORT_ORDER SortOrder)
{
    TRACE_METHOD(CResultRecs, _CompleteSortKeyListInit);
    ULONG i;

    //
    // Because the record numbers can wrap, the oldest record number
    // might be less than the newest, so we can't just sort by record
    // number.
    //
    // Instead, we'll create a key for each record by subtracting the
    // oldest record number from the record's number.
    //

    if (SortOrder == NEWEST_FIRST || SortOrder == OLDEST_FIRST)
    {
        ULONG ulOldestRecNo = _RecordCache.GetOldestRecordNo();

        for (i = 0; i < *pcKeys; i++)
        {
            pSortKeys[i].Key.ulRecNoKey = pSortKeys[i].ulRecNo - ulOldestRecNo;
        }
        return S_OK;
    }

    //
    // Sort the sortkey list by record number.  This allows us to make a
    // sequential pass through the eventlog while initializing the keys.
    //

    {
        TIMER(qsort by record number);
        qsort(pSortKeys, *pcKeys, sizeof SORTKEY, CompareRecNoDescending);
    }

    //
    // Initialize the Key portion of the sortkeys
    //

    HRESULT hr = S_OK;

    for (i = 0; i < *pcKeys; i++)
    {
        //
        // Using the light cache instead of the raw cache is a real advantage
        // here because a huge log that is heavily filtered may all reside in
        // the light rec cache but require many seeks and reads using raw
        // cache.  Also, using light cache reduces the likelyhood of getting a
        // log-changed error.
        //
        // We read from newest to oldest record.  As soon as we get an error
        // stop reading and set *pcKeys to reflect the records we are
        // dropping.
        //

        hr = _LightCache.SeekToRecNo(pSortKeys[i].ulRecNo);
        BREAK_ON_FAIL_HRESULT(hr);

        const LIGHT_RECORD *plr = _LightCache.GetCurRec();

        switch (SortOrder)
        {
        case SO_TYPE:
            pSortKeys[i].Key.bType = plr->bType;
            break;

        case SO_DATETIME:
          pSortKeys[i].Key.ulTime = plr->ulTimeGenerated;
          break;

        case SO_TIME:
        {
            // force the date portion to be the same for all recs

            SYSTEMTIME st;

            (void) SecondsSince1970ToSystemTime(plr->ulTimeGenerated, &st);

            //
            // JonN 10/12/01 SystemTimeToSecondsSince1970 must receive
            // as input, a local time which when translated to system time
            // is after midnight on 1/1/70.  If we set the date to 1/1/70,
            // we are liable to wind up with a time which when corrected for
            // time zone is 12/31/69, in areas where the time zone is GMT+xxx
            // rather than GMT-xxx (from Berlin to the
            // International Date Line). This causes
            // SystemTimeToSecondsSince1970 to fail.
            //
            // The fix is to set st.wDay to 2.  We don't care about the actual
            // value, we only care how they compare to the other values.
            //

            st.wMonth = 1;
            st.wDay = 2;
            st.wYear = 1970;

            (void) SystemTimeToSecondsSince1970(&st, &pSortKeys[i].Key.ulTime);
            break;
        }

        case SO_EVENT:
            pSortKeys[i].Key.usEventID = (USHORT) plr->usEventID;
            break;

        case SO_SOURCE:
            pSortKeys[i].Key.pwszSource = _LightCache.GetSourceStr();
            break;

        case SO_CATEGORY:
            if (plr->usCategory)
            {
                CSources *pSrc = _pli->GetSources();
                CCategories *pCat =
                    pSrc->GetCategories(_LightCache.GetSourceStr());

                // JonN 8/21/01 459248
                // Event Viewer: Some events sorted incorrectly
                // We want integer 52 rather than string "(52)",
                // see CompareCategoryAscending
                if (pCat && (plr->usCategory <= pCat->GetCount()))
                {
                    pSortKeys[i].Key.pwszCategory =
                        pCat->GetName(plr->usCategory);
                }
                else
                {
                    pSortKeys[i].Key.pwszCategory =
                        (LPCWSTR) plr->usCategory;
                }
            }
            else
            {
                pSortKeys[i].Key.pwszCategory = g_wszNone;
            }
            break;

        case SO_USER:
            _ssUserName.AddRefHandle(plr->hUser);
            pSortKeys[i].Key.pwszUser =
                _ssUserName.GetStringFromHandle(plr->hUser);
            break;

        case SO_COMPUTER:
            _ssComputerName.AddRefHandle(plr->hComputer);
            pSortKeys[i].Key.pwszComputer =
                _ssComputerName.GetStringFromHandle(plr->hComputer);
            break;

        default:
            ASSERT(0 && "unknown sort order value");
            break;
        }
    }

    //
    // If we were able to init enough sort keys to actually do some sorting
    // but then hit a seek failure, just work with a shorter list.
    //

    if (FAILED(hr) && i > 2)
    {
        *pcKeys = i;
        hr = S_OK;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CResultRecs::Sort
//
//  Synopsis:   Sort the record list into [NewOrder] order.
//
//  Arguments:  [NewOrder]   - desired order
//              [flFlags]    - SO_* flags
//              [pSortOrder] - points to current order
//
//  Returns:    S_FALSE - sort was a no-op
//              S_OK    - sort succeeded
//
//  Modifies:   *[pSortOrder] (set to NewOrder on success)
//
//  History:    07-09-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CResultRecs::Sort(
    SORT_ORDER NewOrder,
    ULONG flFlags,
    SORT_ORDER *pSortOrder)
{
    TRACE_METHOD(CResultRecs, Sort);

    HRESULT hr = S_OK;
    HRESULT hrReturn = S_FALSE;
    SORTKEY *pSortKeys = NULL;
    CWaitCursor Hourglass;

    do
    {
        //
        // Sorting is a no-op for < 2 records, but update the *pSortOrder so
        // the View menu checkmarks correspond to what the user last picked.
        //

        if (_RecList.GetCount() < 2)
        {
            *pSortOrder = NewOrder;
            break;
        }

        //
        // if sort is for last-sorted column, then just reverse the order
        // of the records in that column
        //

        if (NewOrder == *pSortOrder  &&
                NewOrder != NEWEST_FIRST && NewOrder != OLDEST_FIRST ||
            NewOrder == OLDEST_FIRST && *pSortOrder == NEWEST_FIRST ||
            NewOrder == NEWEST_FIRST && *pSortOrder == OLDEST_FIRST)
        {
            _RecList.Reverse();
            _LightCache.Clear();
            *pSortOrder = NewOrder;
            hrReturn = S_OK;
            break;
        }

        //
        // Handle the special case "sorts" of newest-first and oldest-first.
        // If no filter is applied, then the resulting record list is simply
        // a range from the oldest to the newest (or vice versa).
        //
        // If a filter is applied, however, the record list will have to be
        // sorted with the aid of a key list.
        //

        if (!(flFlags & SO_FILTERED) &&
            (NewOrder == OLDEST_FIRST || NewOrder == NEWEST_FIRST))
        {
            ULONG cRecs = _RecordCache.GetNumberOfRecords();
            ULONG ulOldestRecNo = _RecordCache.GetOldestRecordNo();

            _RecList.Clear();
            _LightCache.Clear();
            *pSortOrder = NewOrder;

            if (NewOrder == NEWEST_FIRST)
            {
                hrReturn = _RecList.SetRange(ulOldestRecNo + cRecs - 1,
                                             (ULONG)(-(LONG)(cRecs - 1)));
            }
            else
            {
                hrReturn = _RecList.SetRange(ulOldestRecNo, cRecs - 1);
            }
            break;
        }

        // alloc sort key list via reclist

        hr = _RecList.AllocSortKeyList(&pSortKeys);
        BREAK_ON_FAIL_HRESULT(hr);

        ULONG cKeys = _RecList.GetCount();

        hr = _CompleteSortKeyListInit(pSortKeys, &cKeys, NewOrder);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Sort sortkey list by key.
        //
        // This could be optimized by using customized sorts for
        // each key, however it seems pretty quick right now.
        //

        if (NewOrder == NEWEST_FIRST)
        {
            TIMER(qsort newest first);

            qsort(pSortKeys,
                  cKeys,
                  sizeof SORTKEY,
                  CompareRecNoKeyDescending);
        }
        else if (NewOrder == OLDEST_FIRST)
        {
            TIMER(qsort oldest first);

            qsort(pSortKeys,
                  cKeys,
                  sizeof SORTKEY,
                  CompareRecNoKeyAscending);
        }
        else if (flFlags & SO_DESCENDING)
        {
            TIMER(qsort descending);

            qsort(pSortKeys,
                  cKeys,
                  sizeof SORTKEY,
                  s_aSortDescendingCallbacks[(ULONG) NewOrder]);
        }
        else
        {
            TIMER(qsort ascending);

            qsort(pSortKeys,
                  cKeys,
                  sizeof SORTKEY,
                  s_aSortAscendingCallbacks[(ULONG) NewOrder]);
        }

        // replace the reclist with one created from the keylist

        _RecList.Clear();
        _LightCache.Clear();

        hr = _RecList.CreateFromSortKeyList(pSortKeys, cKeys);
        BREAK_ON_FAIL_HRESULT(hr);

        // release references to shared strings held by sort keys

        if (NewOrder == SO_USER || NewOrder == SO_COMPUTER)
        {
            ULONG i;
            CSharedStringArray *pss;

            if (NewOrder == SO_USER)
            {
                pss = &_ssUserName;
            }
            else
            {
                pss = &_ssComputerName;
            }

            for (i = 0; i < cKeys; i++)
            {
                //
                // note Key is a union, so it doesn't matter which pointer
                // member we use.
                //

                LPCWSTR pwsz = pSortKeys[i].Key.pwszUser;

                if (*pwsz)
                {
                    ULONG hString = pss->GetHandle(pwsz);

                    // GetHandle does an addref, so release the addref it
                    // just did right here

                    pss->ReleaseHandle(hString);

                    // Now release the addref done when we were building the
                    // sortkey list.
                    pss->ReleaseHandle(hString);
                }
            }
        }

        // did the sort

        *pSortOrder = NewOrder;
        hrReturn = S_OK;
    } while (0);

    delete [] pSortKeys;

    return hrReturn;
}


//+--------------------------------------------------------------------------
//
//  Member:     CResultRecs::Init
//
//  Synopsis:   Finish initialization.
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  History:    07-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CResultRecs::Init()
{
    TRACE_METHOD(CResultRecs, Init);

    HRESULT hr = S_OK;

    do
    {
        hr = _RecList.Init();
        BREAK_ON_FAIL_HRESULT(hr);

        hr = _ssComputerName.Init();
        BREAK_ON_FAIL_HRESULT(hr);

        hr = _ssUserName.Init();
        BREAK_ON_FAIL_HRESULT(hr);

        hr = _LightCache.Init(&_RecList,
                              &_RecordCache,
                              &_ssComputerName,
                              &_ssUserName);
    } while (0);
    return hr;
}


HRESULT
CResultRecs::Open(
    CLogInfo *pli,
    DIRECTION Direction)
{
    TRACE_METHOD(CResultRecs, Open);
    ASSERT(!_pli);

    CWaitCursor Hourglass;

    _pli = pli;
    _LightCache.Open(pli);
    _RecordCache.SetConsole(pli->GetCompData()->GetConsole());
    return _RecordCache.Open(pli, Direction);
}


VOID
CResultRecs::Close()
{
    TRACE_METHOD(CResultRecs, Close);

    _RecList.Clear();
    _LightCache.Close();
    _RecordCache.Close();
    _pli = NULL;
}


//
// Functions used to support IComponent::GetDisplayInfo
//


//+--------------------------------------------------------------------------
//
//  Member:     CResultRecs::Populate
//
//  Synopsis:   Construct an internal list of the record numbers of all the
//              records that are to be
//
//  Arguments:  [SortOrder]     - current sort order
//              [pulFirstRecNo] - filled with number of record at index 0, or
//                                 0 on error.
//              [pfSeekFailed]  - Set to TRUE if a record cache seek failed
//
//  Returns:    HRESULT
//
//  Modifies:   *[pulFirstRecNo]
//
//  History:    07-09-1997   DavidMun   Created
//              06-30-2000   DavidMun   Get rid of seek failed since all
//                                       'repopulate' notification done thru
//                                       ELSM_LOG_DATA_CHANGED.
//
//---------------------------------------------------------------------------

HRESULT
CResultRecs::Populate(
    SORT_ORDER SortOrder,
    ULONG *pulFirstRecNo)
{
    TRACE_METHOD(CResultRecs, Populate);

    _RecList.Clear();

    ULONG cRecs = _RecordCache.GetNumberOfRecords();

    if (!cRecs)
    {
        return S_OK;
    }

    if (!_RecList.IsValid())
    {
        return E_FAIL;
    }

    HRESULT hr = S_OK;
    ULONG ulOldestRecNo = _RecordCache.GetOldestRecordNo();

    if (_pli->IsFiltered())
    {
        ULONG i;
        ULONG ulCurRec;
        ULONG ulInc;
        CFilter *pFilter = _pli->GetFilter();

        if (SortOrder == OLDEST_FIRST)
        {
            ulCurRec = ulOldestRecNo;
            ulInc = 1;
        }
        else
        {
            ulCurRec = ulOldestRecNo + cRecs - 1;
            ulInc = (ULONG) -1;
        }

        for (i = 0; i < cRecs; i++)
        {
            hr = _RecordCache.Seek(ulCurRec);

            if (FAILED(hr))
            {
                hr = S_OK;
                break;
            }

            if (pFilter->Passes(&_RecordCache))
            {
                hr = _RecList.Append(ulCurRec);
                BREAK_ON_FAIL_HRESULT(hr);
            }

            ulCurRec += ulInc;
        }
    }
    else if (cRecs > 1)
    {
        if (SortOrder == OLDEST_FIRST)
        {
            hr = _RecList.SetRange(ulOldestRecNo, cRecs - 1);
        }
        else
        {
            hr = _RecList.SetRange(ulOldestRecNo + cRecs - 1,
                                   (ULONG)(-1 * (LONG)(cRecs - 1)));
        }
    }
    else
    {
        hr = _RecList.Append(ulOldestRecNo);
    }

    if (SUCCEEDED(hr) && _RecList.GetCount())
    {
        *pulFirstRecNo = _RecList.IndexToRecNo(0);
    }
    else
    {
        *pulFirstRecNo = 0;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CResultRecs::CopyRecord
//
//  Synopsis:   Return a copy of record [ulRecNo].  Caller must delete.
//
//  History:    07-29-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

EVENTLOGRECORD *
CResultRecs::CopyRecord(
    ULONG ulRecNo)
{
    TRACE_METHOD(CResultRecs, CopyRecord);

    EVENTLOGRECORD *pelr = _RecordCache.CopyRecFromCache(ulRecNo);

    if (pelr)
    {
        return pelr;
    }

    HRESULT hr = _RecordCache.Seek(ulRecNo);

    if (SUCCEEDED(hr))
    {
        pelr = _RecordCache.CopyRecFromCache(ulRecNo);
    }
    else
    {
        DBG_OUT_HRESULT(hr);
    }
    return pelr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CResultRecs::GetUserStr
//
//  Synopsis:   Put the string containing the user's name into [wszUser].
//
//  Arguments:  [wszUser]     - destination buffer
//              [cchUser]     - size, in wchars, of buffer
//              [fWantDomain] - TRUE => domain\user, FALSE => user
//
//  History:    07-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LPWSTR
CResultRecs::GetUserStr(
    LPWSTR wszUser,
    ULONG cchUser,
    BOOL fWantDomain)
{
    if (!fWantDomain)
    {
        lstrcpyn(wszUser, _LightCache.GetUserStr(), cchUser);
    }
    else
    {
        if (FAILED(_RecordCache.Seek(_RecList.IndexToRecNo(_idxCur))))
        {
            LoadStr(IDS_USER_NA, wszUser, cchUser, L"---");
        }
        else
        {
            ::GetUserStr(_RecordCache.GetCurRec(),
                         wszUser,
                         cchUser,
                         fWantDomain);
        }
    }
    return wszUser;
}




//+--------------------------------------------------------------------------
//
//  Member:     CResultRecs::GetEventType
//
//  Synopsis:   Return the event type of the current record.
//
//  History:    07-29-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

USHORT
CResultRecs::GetEventType()
{
    switch (_LightCache.GetCurRec()->bType)
    {
    case IDX_RDI_BMP_SUCCESS_AUDIT:
        return EVENTLOG_AUDIT_SUCCESS;

    case IDX_RDI_BMP_FAIL_AUDIT:
        return EVENTLOG_AUDIT_FAILURE;

    default:
        Dbg(DEB_ERROR,
            "CResultRecs::GetEventType: invalid bType %uL\n",
            _LightCache.GetCurRec()->bType);
        // fall through

    case IDX_RDI_BMP_INFO:
        return EVENTLOG_INFORMATION_TYPE;

    case IDX_RDI_BMP_WARNING:
        return EVENTLOG_WARNING_TYPE;

    case IDX_RDI_BMP_ERROR:
        return EVENTLOG_ERROR_TYPE;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CResultRecs::GetDescriptionStr
//
//  Synopsis:   Return the description string of the current record.
//
//  History:    07-29-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LPWSTR
CResultRecs::GetDescriptionStr()
{
    HRESULT hr = _RecordCache.Seek(_RecList.IndexToRecNo(_idxCur));

    if (FAILED(hr))
    {
        return NULL;
    }
    return ::GetDescriptionStr(_pli, _RecordCache.GetCurRec());
}





#if (DBG == 1)

VOID
CResultRecs::DumpRecord(
    ULONG ulRecNo)
{
    HRESULT hr = S_OK;
    EVENTLOGRECORD *pelr = NULL;

    do
    {
        hr = _RecordCache.Seek(ulRecNo);
        BREAK_ON_FAIL_HRESULT(hr);

        pelr = _RecordCache.CopyRecFromCache(ulRecNo);

        if (!pelr)
        {
            Dbg(DEB_ERROR,
                "Record %u not in cache after successful seek!\n",
                ulRecNo);
            break;
        }

        Dbg(DEB_FORCE, "Dumping record %u\n", ulRecNo);
        Dbg(DEB_FORCE, "  Length:              %u\n", pelr->Length);
        Dbg(DEB_FORCE, "  Reserved:            %#x\n", pelr->Reserved);
        Dbg(DEB_FORCE, "  RecordNumber:        %u\n", pelr->RecordNumber);
        Dbg(DEB_FORCE, "  TimeGenerated:       %u\n", pelr->TimeGenerated);
        Dbg(DEB_FORCE, "  TimeWritten:         %u\n", pelr->TimeWritten);
        Dbg(DEB_FORCE, "  EventID:             %#x (%u)\n",
            pelr->EventID,
            LOWORD(pelr->EventID));
        Dbg(DEB_FORCE, "  EventType:           %u\n", pelr->EventType);
        Dbg(DEB_FORCE, "  NumStrings:          %u\n", pelr->NumStrings);
        Dbg(DEB_FORCE, "  EventCategory:       %u\n", pelr->EventCategory);
        Dbg(DEB_FORCE, "  ReservedFlags:       %#x\n", pelr->ReservedFlags);
        Dbg(DEB_FORCE, "  ClosingRecordNumber: %u\n", pelr->ClosingRecordNumber);
        Dbg(DEB_FORCE, "  StringOffset:        %u\n", pelr->StringOffset);
        Dbg(DEB_FORCE, "  UserSidLength:       %u\n", pelr->UserSidLength);
        Dbg(DEB_FORCE, "  UserSidOffset:       %u\n", pelr->UserSidOffset);
        Dbg(DEB_FORCE, "  DataLength:          %u\n", pelr->DataLength);
        Dbg(DEB_FORCE, "  DataOffset:          %u\n", pelr->DataOffset);
        Dbg(DEB_FORCE, "  Source:              %ws\n", ::GetSourceStr(pelr));
        Dbg(DEB_FORCE, "  Computer:            %ws\n", ::GetComputerStr(pelr));

        if (!pelr->UserSidLength)
        {
            Dbg(DEB_FORCE, "  UserSid:             N/A\n");
        }
        else
        {
            PSID psid = (PSID) (((PBYTE) pelr) + pelr->UserSidOffset);
            WCHAR wszSid[MAX_PATH];

            ASSERT(psid < (pelr + pelr->Length));
            ASSERT(IsValidSid(psid));

            SidToStr(psid, wszSid, ARRAYLEN(wszSid));

            Dbg(DEB_FORCE, "  UserSid:             %ws\n", wszSid);
        }

        LPWSTR pwszCurInsert = GetFirstInsertString(pelr);

        if (pwszCurInsert)
        {
            ULONG i;
            Dbg(DEB_FORCE, "  Insert Strings:\n");

            for (i = 0; i < pelr->NumStrings; i++)
            {
                ULONG cchCurInsert = static_cast<ULONG>(wcslen(pwszCurInsert));
                Dbg(DEB_FORCE, "    %ws\n", pwszCurInsert);
                pwszCurInsert += cchCurInsert + 1;
            }
        }
    } while (0);

    delete [] (BYTE*)pelr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\sharestr.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       sharestr.cxx
//
//  Contents:   Implementation of dynamic array of refcounted strings
//
//  Classes:    CSharedStringArray
//
//  History:    07-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


#define INITIAL_SHARED_STRING_COUNT     20
#define GROW_BY                         10

#define ASSERT_VALID_HANDLE(hString)    ASSERT((hString) - 1 < _cStrings);          \
                                        ASSERT(_pSharedStrings[(hString)-1].cRefs); \
                                        ASSERT(_pSharedStrings[(hString)-1].pwsz)


//+--------------------------------------------------------------------------
//
//  Member:     CSharedStringArray::CSharedStringArray
//
//  Synopsis:   ctor
//
//  History:    07-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CSharedStringArray::CSharedStringArray():
    _pSharedStrings(NULL),
    _cStrings(0)
{
    TRACE_CONSTRUCTOR(CSharedStringArray);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSharedStringArray::~CSharedStringArray
//
//  Synopsis:   dtor
//
//  History:    07-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CSharedStringArray::~CSharedStringArray()
{
    TRACE_DESTRUCTOR(CSharedStringArray);

    delete [] _pSharedStrings;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSharedStringArray::Init
//
//  Synopsis:   Allocate initial array.
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  History:    07-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSharedStringArray::Init()
{
    TRACE_METHOD(CSharedStringArray, Init);
    ASSERT(!_pSharedStrings && !_cStrings);

    _pSharedStrings = new SHARED_STRING[INITIAL_SHARED_STRING_COUNT];

    if (!_pSharedStrings)
    {
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    _cStrings = INITIAL_SHARED_STRING_COUNT;
    ZeroMemory(_pSharedStrings, _cStrings * sizeof(_pSharedStrings[0]));

    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSharedStringArray::GetHandle
//
//  Synopsis:   Return the handle to shared string [pwsz], creating a new
//              entry for it if it isn't already in the array.
//
//  Arguments:  [pwsz] - string to search for or add
//
//  Returns:    Handle or 0 on error (out of memory).
//
//  History:    07-15-1997   DavidMun   Created
//
//  Notes:      Caller must call ReleaseHandle() on returned handle.
//
//---------------------------------------------------------------------------

ULONG
CSharedStringArray::GetHandle(
    LPCWSTR pwsz)
{
    if (!_pSharedStrings)
    {
        ASSERT(!_cStrings);
        return 0;
    }

    ULONG idxFirstUnused = 0xFFFFFFFF;
    ULONG i;

    for (i = 0; i < _cStrings; i++)
    {
        if (_pSharedStrings[i].pwsz)
        {
            if (!lstrcmp(_pSharedStrings[i].pwsz, pwsz))
            {
                _pSharedStrings[i].cRefs++;
                return i + 1;
            }
        }
        else if (idxFirstUnused == 0xFFFFFFFF)
        {
            ASSERT(!_pSharedStrings[i].cRefs);
            idxFirstUnused = i;
        }
    }

    //
    // String not already in array.  If there's an empty slot in the
    // array, put a copy of the string there.
    //

    if (idxFirstUnused == 0xFFFFFFFF)
    {
        SHARED_STRING *pNewArray = new SHARED_STRING[_cStrings + GROW_BY];

        if (!pNewArray)
        {
            DBG_OUT_HRESULT(E_OUTOFMEMORY);

            return 0;
        }

        CopyMemory(pNewArray,
                   _pSharedStrings,
                   _cStrings * sizeof(SHARED_STRING));

        ZeroMemory(&pNewArray[_cStrings], GROW_BY * sizeof(SHARED_STRING));

        idxFirstUnused = _cStrings;

        _cStrings += GROW_BY;
        delete [] _pSharedStrings;
        _pSharedStrings = pNewArray;

    }

    _pSharedStrings[idxFirstUnused].pwsz = new WCHAR[lstrlen(pwsz) + 1];

    if (!_pSharedStrings[idxFirstUnused].pwsz)
    {
        DBG_OUT_HRESULT(E_OUTOFMEMORY);

        return 0;
    }

    lstrcpy(_pSharedStrings[idxFirstUnused].pwsz, pwsz);
    _pSharedStrings[idxFirstUnused].cRefs = 1;

    return idxFirstUnused + 1;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSharedStringArray::AddRefHandle
//
//  Synopsis:   Increment the refcount for shared string with handle [hString]
//
//  Arguments:  [hString] - handle to add reference to
//
//  History:    07-07-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSharedStringArray::AddRefHandle(
    ULONG hString)
{
    if (hString)
    {
        ASSERT(_pSharedStrings);
        ASSERT_VALID_HANDLE(hString);

        _pSharedStrings[hString - 1].cRefs++;
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CSharedStringArray::ReleaseHandle
//
//  Synopsis:   Decrement the refcount for shared string with handle
//              [hString].
//
//  Arguments:  [hString] - handle to release
//
//  History:    07-15-1997   DavidMun   Created
//
//  Notes:      No-op if [hString] is 0.
//
//---------------------------------------------------------------------------

VOID
CSharedStringArray::ReleaseHandle(
    ULONG hString)
{
    if (hString)
    {
        ASSERT(_pSharedStrings);
        ASSERT_VALID_HANDLE(hString);

        if (!--_pSharedStrings[hString - 1].cRefs)
        {
            delete [] _pSharedStrings[hString - 1].pwsz;
            _pSharedStrings[hString - 1].pwsz = NULL;
        }
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CSharedStringArray::GetStringFromHandle
//
//  Synopsis:   Return string associated with handle [hString].
//
//  Arguments:  [hString] - string handle or 0.
//
//  Returns:    L"" if [hString] is 0, or valid string
//              otherwise.
//
//  History:    07-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LPWSTR
CSharedStringArray::GetStringFromHandle(
    ULONG hString)
{
    if (!hString)
    {
        return L"";
    }

    ASSERT_VALID_HANDLE(hString);

    return _pSharedStrings[hString - 1].pwsz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\sidcache.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//  
//  File:       sidcache.cxx
//
//  Contents:   Implementation of class to cache SIDs and their 
//              human-readable string representations (either account 
//              names or S- strings).
//
//  Classes:    CSidCache
//
//  History:    12-09-1996   DavidMun   Created
//
//  Notes:      This class is thread-safe because it can be accessed via
//              the record details property inspector threads.
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop
    
    

        
        
//+--------------------------------------------------------------------------
//
//  Member:     CSidCache::CSidCache
//
//  Synopsis:   ctor
//
//  History:    2-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CSidCache::CSidCache():
        CLruCache(MAX_CACHED_SIDS)
{
    TRACE_CONSTRUCTOR(CSidCache);
}



//+--------------------------------------------------------------------------
//
//  Member:     CSidCache::~CSidCache
//
//  Synopsis:   dtor
//
//  History:    4-21-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CSidCache::~CSidCache()
{
    TRACE_DESTRUCTOR(CSidCache);
}





//+--------------------------------------------------------------------------
//
//  Member:     CSidCache::Add
//
//  Synopsis:   Add a new item to the sid cache, deleting the least recently
//              used if necessary.
//
//  Arguments:  [pSID]    - SID
//              [pwszSID] - human-readable string version of [pSID]
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//
//  History:    2-28-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSidCache::Add(
    PSID pSID, 
    LPCWSTR pwszSID)
{
    HRESULT hr = S_OK;
    CSidCacheItem *pNew = new CSidCacheItem(pSID, pwszSID);

    if (pNew)
    {
        if (!pNew->IsEmpty())
        {
            hr = CLruCache::Add((CLruCacheItem *) pNew);
        }
        else 
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);

            delete pNew;
        }
    }
    else 
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(hr);
    }
    return hr;
}
    



//============================================================================
//
// CSidCacheItem implementation
// 
//============================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CSidCacheItem::CSidCacheItem
//
//  Synopsis:   ctor
//
//  Arguments:  [pSID]    - sid
//              [pwszSID] - human-readable string representing sid
//
//  History:    1-13-1997   DavidMun   Created
//
//  Notes:      Insufficient memory will cause this to be a valid but empty
//              item.  Caller must check by calling CSidCacheItem::IsEmpty.
//
//---------------------------------------------------------------------------

CSidCacheItem::CSidCacheItem(
        PSID pSID, 
        LPCWSTR pwszSID)
{
    TRACE_CONSTRUCTOR(CSidCacheItem);

    _pSID = NULL;
    _pwszSID = NULL;

    _Set(pSID, pwszSID);
}



//+--------------------------------------------------------------------------
//
//  Member:     CSidCacheItem::~CSidCacheItem
//
//  Synopsis:   Destructor, requires that this item is not linked
//
//  History:    12-10-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

CSidCacheItem::~CSidCacheItem()
{
    TRACE_DESTRUCTOR(CSidCacheItem);
    ASSERT(!CDLink::Next());
    ASSERT(!CDLink::Prev());

    delete [] ((BYTE *) _pSID);
    _pSID = NULL;
}


//+--------------------------------------------------------------------------
//
//  Member:     CSidCacheItem::_Set, private
//
//  Synopsis:   Copy [pSID] and [pwszSID].
//
//  Arguments:  [pSID]    - sid to copy
//              [pwszSID] - string to copy
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSidCacheItem::_Set(
    PSID pSID, 
    LPCWSTR pwszSID)
{
    HRESULT hr      = S_OK;

    // 
    // Allocate a block of memory to hold both the SID and the string.
    // Be sure the string starts on a DWORD boundary.
    //

    ULONG cbSID = GetLengthSid(pSID);
    ULONG cbPad = DWORDALIGN(cbSID) - cbSID;
    ULONG cbRequired =  cbSID + 
                        cbPad + 
                        sizeof(WCHAR) * (lstrlen(pwszSID) + 1);

    BYTE *pbBuf = new BYTE[cbRequired];

    if (!pbBuf)
    {                     
        // 
        // Couldn't allocate the buffer.  Note the original values, if
        // any, are still intact.
        //

        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(hr);
    }
    else 
    {
        //
        // We got the buffer.  Delete the original, if any, then set the 
        // sid pointer to the start of the new buffer, and the string 
        // pointer to the start of the first dword after the sid.
        //

        delete [] ((BYTE *) _pSID);

        _pSID = pbBuf;
        _pwszSID = (LPWSTR) (pbBuf + cbSID + cbPad);

        CopyMemory(_pSID, pSID, cbSID);
        lstrcpy(_pwszSID, pwszSID);

        _ulLastAccess = GetTickCount();
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSidCacheItem::GetValue
//
//  Synopsis:   Return the value this item is holding.
//
//  Arguments:  [pvBuf] - buffer which is to receive item
//              [cbBuf] - size of buffer, in bytes
//
//  Returns:    S_OK
//
//  Modifies:   *[pvBuf]
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSidCacheItem::GetValue(
    LPVOID pvBuf,
    ULONG cbBuf)
{
    _ulLastAccess = GetTickCount();
    lstrcpyn((LPWSTR)pvBuf, _pwszSID, cbBuf / sizeof(WCHAR));
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSidCacheItem::Copy
//
//  Synopsis:   Copy the data in [pitem] into this.
//
//  Arguments:  [pitem] - points to CSidCacheItem
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSidCacheItem::Copy(
    CLruCacheItem *pitem)
{
    CSidCacheItem *psiditem = (CSidCacheItem *) pitem;

    return _Set(psiditem->_pSID, psiditem->_pwszSID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\snapin.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       dso.cxx
//
//  Contents:   Data Source Object definition
//
//  Classes:    CDataSource
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


//
// Local constants
//
// MAX_HEADER_STR - max size in chars, including terminating null, of string
//  to be inserted as header control column title.
//

#define MAX_HEADER_STR                      80

#define FOLDER_NAME_DEFAULT_WIDTH           149
#define FOLDER_TYPE_DEFAULT_WIDTH           47
#define FOLDER_DESCRIPTION_DEFAULT_WIDTH    162
#define FOLDER_SIZE_DEFAULT_WIDTH           55

#define RECORD_TYPE_DEFAULT_WIDTH           90
#define RECORD_DATE_DEFAULT_WIDTH           82
#define RECORD_TIME_DEFAULT_WIDTH           73
#define RECORD_SOURCE_DEFAULT_WIDTH         134
#define RECORD_CATEGORY_DEFAULT_WIDTH       69
#define RECORD_EVENT_DEFAULT_WIDTH          49
#define RECORD_USER_DEFAULT_WIDTH           97
#define RECORD_COMPUTER_DEFAULT_WIDTH       82

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapin)


//============================================================================
//
// IUnknown implementation
//
//============================================================================


//+---------------------------------------------------------------------------
//
//  Member:     CSnapin::QueryInterface
//
//  Synopsis:   Return the requested interface
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CSnapin::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    // TRACE_METHOD(CSnapin, QueryInterface);

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppvObj = (IUnknown*)(IPersistStream*)this;
        }
        else if (IsEqualIID(riid, IID_IComponent))
        {
            *ppvObj = (IUnknown*)(IComponent*)this;
        }
        else if (IsEqualIID(riid, IID_IExtendPropertySheet))
        {
            *ppvObj = (IUnknown*)(IExtendPropertySheet*)this;
        }
        else if (IsEqualIID(riid, IID_IExtendContextMenu))
        {
            *ppvObj = (IUnknown*)(IExtendContextMenu*)this;
        }
        else if (IsEqualIID(riid, IID_IResultDataCompare))
        {
            *ppvObj = (IUnknown*)(IResultDataCompare *)this;
        }
        else if (IsEqualIID(riid, IID_IResultOwnerData))
        {
            *ppvObj = (IUnknown*)(IResultOwnerData *)this;
        }
        else if (IsEqualIID(riid, IID_IResultPrshtActions))
        {
            *ppvObj = (IUnknown*)(IResultPrshtActions *)this;
        }
        else if (IsEqualIID(riid, IID_IPersist))
        {
            *ppvObj = (IUnknown*)(IPersist*)(IPersistStream*)this;
            Dbg(DEB_STORAGE, "CSnapin::QI(%x): giving out IPersist\n", this);
        }
        else if (IsEqualIID(riid, IID_IPersistStream))
        {
            *ppvObj = (IUnknown*)(IPersistStream*)this;

            Dbg(DEB_STORAGE,
                "CSnapin::QI(%x): giving out IPersistStream\n",
                this);
        }
#ifdef ELS_TASKPAD
        else if (IsEqualIID(riid, IID_INodeProperties))
        {
            *ppvObj = (IUnknown*)(INodeProperties*)this;

            Dbg(DEB_STORAGE,
                "CSnapin::QI(%x): giving out INodeProperties\n",
                this);
        }
#endif // ELS_TASKPAD
        else
        {
            hr = E_NOINTERFACE;
#if (DBG == 1)
            LPOLESTR pwszIID;
            StringFromIID(riid, &pwszIID);
            Dbg(DEB_ERROR, "CSnapin::QI no interface %ws\n", pwszIID);
            CoTaskMemFree(pwszIID);
#endif // (DBG == 1)
        }

        if (FAILED(hr))
        {
            *ppvObj = NULL;
            break;
        }

        //
        // If we got this far we are handing out a new interface pointer on
        // this object, so addref it.
        //

        AddRef();
    } while (0);

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Member:     CSnapin::AddRef
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CSnapin::AddRef()
{
    ULONG cRefs = InterlockedIncrement((LONG *) &_cRefs);
    //Dbg(DEB_TRACE, "AddRef'd, refs now = %d\n", cRefs);
    return cRefs;
}




//+---------------------------------------------------------------------------
//
//  Member:     CSnapin::Release
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CSnapin::Release()
{
    ULONG cRefsTemp;

    cRefsTemp = InterlockedDecrement((LONG *)&_cRefs);
    //Dbg(DEB_TRACE, "Released, refs now = %d\n", cRefsTemp);

    if (0 == cRefsTemp)
    {
        delete this;
    }

    return cRefsTemp;
}



//============================================================================
//
// IComponent implementation
//
//============================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::CompareObjects
//
//  Synopsis:   Return S_OK if both data objects refer to the same managed
//              object, S_FALSE otherwise.
//
//  Arguments:  [lpDataObjectA] - first data object to check
//              [lpDataObjectB] - second data object to check
//
//  Returns:    S_OK or S_FALSE
//
//  Derivation: IComponent
//
//  History:    1-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT CSnapin::CompareObjects(
    LPDATAOBJECT lpDataObjectA,
    LPDATAOBJECT lpDataObjectB)
{
    TRACE_METHOD(CSnapin, CompareObjects);

    CDataObject *pdoA = ExtractOwnDataObject(lpDataObjectA);
    CDataObject *pdoB = ExtractOwnDataObject(lpDataObjectB);

    //
    // At least one of these data objects is supposed to be ours, so one
    // of the extracted pointers should be non-NULL.
    //

    ASSERT(pdoA || pdoB);

    //
    // If extraction failed for one of them, then that one is foreign and
    // can't be equal to the other one.  (Or else ExtractOwnDataObject
    // returned NULL because it ran out of memory, but the most conservative
    // thing to do in that case is say they're not equal.)
    //

    if (!pdoA || !pdoB)
    {
        return S_FALSE;
    }

    //
    // If both data objects are not event records,
    // IComponentData::CompareObjects should get those.
    //

    ASSERT(pdoA->GetCookieType() == COOKIE_IS_RECNO ||
           pdoB->GetCookieType() == COOKIE_IS_RECNO);

    if (pdoA->GetCookieType() != COOKIE_IS_RECNO ||
        pdoB->GetCookieType() != COOKIE_IS_RECNO)
    {
        return S_FALSE;
    }

    /*
    //
    // Always shift focus to the existing event record sheet rather than
    // creating a new one.  JonN 11/12/98
    //

    //
    // The cookies are event log records, so they may be compared directly.
    //

    if (pdoA->GetCookie() != pdoB->GetCookie())
    {
        return S_FALSE;
    }
    */

    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::Initialize
//
//  Synopsis:   Called by MMC to allow snapin to get IConsole and other
//              interfaces.
//
//  Arguments:  [lpConsole] - IConsole instance
//
//  Returns:    HRESULT
//
//  History:    12-06-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CSnapin::Initialize(
    LPCONSOLE lpConsole)
{
    TRACE_METHOD(CSnapin, Initialize);

    HRESULT hr = S_OK;

    do
    {
        hr = _ResultRecs.Init();
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Save away all the interfaces we'll need
        //

        _pConsole = lpConsole;
        _pConsole->AddRef();

        hr = _pConsole->QueryInterface(IID_IResultData, (VOID**)&_pResult);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = _pConsole->QueryInterface(IID_IHeaderCtrl, (VOID**)&_pHeader);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = _pConsole->QueryResultImageList(&_pResultImage);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = _pConsole->QueryConsoleVerb(&_pConsoleVerb);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = _pConsole->QueryInterface(
                IID_IDisplayHelp,
                reinterpret_cast<void**>(&_pDisplayHelp));
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::Notify
//
//  Synopsis:   Called by MMC to indicate that an event has occurred.
//
//  Arguments:  [pDataObject] - object to which event happened
//              [event]       - what happened
//              [arg]         - depends on event
//              [param]       - depends on event
//
//  Returns:    HRESULT
//
//  History:    12-06-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CSnapin::Notify(
    LPDATAOBJECT pDataObject,
    MMC_NOTIFY_TYPE event,
    LPARAM arg,
    LPARAM param)
{
    TRACE_METHOD(CSnapin, Notify);

    HRESULT hr = S_OK;
    CDataObject *pdo = NULL;

    if (pDataObject)
    {
        pdo = ExtractOwnDataObject(pDataObject);
    }

    switch (event)
    {
    case MMCN_SHOW:
        Dbg(DEB_NOTIFY, "CSnapin::Notify MMCN_SHOW\n");

        if (pdo)
        {
            if (arg)
            {
                _pcd->SetActiveSnapin(this);
            }
            else
            {
                _pcd->SetActiveSnapin(NULL);
            }
            hr = _OnShow(pdo, (BOOL)arg, (HSCOPEITEM)param);
        }
        break;

    case MMCN_REFRESH:
        //
        // componentdata will notify all snapins currently displaying the
        // loginfo indicated by pDataObject that they need to refresh
        //
        hr = _pcd->Notify(pDataObject, event, arg, param);
        break;

    case MMCN_VIEW_CHANGE:
        Dbg(DEB_NOTIFY, "CSnapin::Notify MMCN_VIEW_CHANGE\n");
        break;

    case MMCN_CLICK:
        Dbg(DEB_NOTIFY, "CSnapin::Notify MMCN_CLICK\n");
        ASSERT(0 && "received MMCN_CLICK but it is no longer used per SDK");
        break;

    case MMCN_DBLCLICK:
        Dbg(DEB_NOTIFY, "CSnapin::Notify MMCN_DBLCLICK\n");

        if (pdo)
        {
            hr = _OnDoubleClick((ULONG)pdo->GetCookie(), pDataObject);
        }
        break;

    case MMCN_ACTIVATE:
        Dbg(DEB_NOTIFY, "CSnapin::Notify MMCN_ACTIVATE %u\n", arg);

        // CAUTION: pdo may be NULL if this is an extension snapin

        if (arg)
        {
            _pcd->SetActiveSnapin(this);
        }
        break;

    case MMCN_SELECT:
        Dbg(DEB_NOTIFY, "CSnapin::Notify MMCN_SELECT 0x%x 0x%x\n", arg, pdo);

        if (pdo)
        {
            if (LOWORD(arg))
            {
                if (HIWORD(arg))
                {
                    _pcd->SetActiveSnapin(this);
                }
            }
            hr = _OnSelect(LOWORD(arg), HIWORD(arg), pdo);
        }
        break;

    case MMCN_ADD_IMAGES:
        Dbg(DEB_NOTIFY, "CSnapin::Notify MMCN_ADD_IMAGES\n");
        hr = _InitializeResultBitmaps();
        break;

    case MMCN_DESELECT_ALL:
        Dbg(DEB_NOTIFY, "CSnapin::Notify MMCN_DESELECT_ALL _ulCurSelectedRecNo = 0\n");
        _ulCurSelectedRecNo = 0;
        _ulCurSelectedIndex = 0;
        break;

    case MMCN_CONTEXTHELP:
    case MMCN_SNAPINHELP:
    {
        wstring::value_type buf[MAX_PATH + 1];
        UINT result = ::GetSystemWindowsDirectory(buf, MAX_PATH);
        ASSERT(result != 0 && result <= MAX_PATH);

        if (result)
        {
            wstring topic =
                  wstring(buf)
               +  HTML_HELP_FILE_NAME
               +  TEXT("::")
               +  load_wstring(IDS_HELP_OVERVIEW_TOPIC);

            hr =
               _pDisplayHelp->ShowTopic(
                  const_cast<wstring::value_type*>(topic.c_str()));
        }
        else
        {
            hr = E_UNEXPECTED;
        }

        break;
    }

    case MMCN_COLUMNS_CHANGED:
        Dbg(DEB_NOTIFY, "CSnapin::Notify: MMCN_COLUMNS_CHANGED\n");
        break;

    case MMCN_FILTER_CHANGE:
        Dbg(DEB_NOTIFY, "CSnapin::Notify: MMCN_FILTER_CHANGED\n");
        break;

    default:
        hr = E_NOTIMPL;
        Dbg(DEB_ERROR,
            "CSnapin::Notify UNHANDLED EVENT 0x%x (%s)\n",
            event,
            GetNotifyTypeStr(event));
        break;
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::Destroy
//
//  Synopsis:   Do processing necessary when this snapin is being closed.
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CSnapin::Destroy(MMC_COOKIE cookie)
{
    TRACE_METHOD(CSnapin, Destroy);

    //
    // Close any open find windows.  The find infos themselves are freed
    // in the dtor.
    //

    CFindInfo *pCur;

    for (pCur = _pFindInfoList; pCur; pCur = pCur->Next())
    {
        pCur->Shutdown();
    }

    // EricB 9/25/01 465035 Open new-window-from-here, open properties on
    // an event in that new window, then retarget the snapin (from the original
    // window). The new window is closed leaving the inspector with no log.
    // Set the inspector to say "no record currently selected."
    //
    if (_InspectorInfo.InspectorInvoked())
    {
        _InspectorInfo.UpdateCurResultRec(NULL, FALSE);
    }

    //
    // Remove this from the linked list kept by owning CComponentData,
    // and let go of the refcount that accompanied it.
    //

    _pcd->UnlinkSnapin(this);
    Release();

    //
    // Let go of all MMC interfaces we got in Initialize
    //

    if (_pConsole)
    {
        _pConsole->Release();
        _pConsole = NULL;
    }

    if (_pResult)
    {
        _pResult->Release();
        _pResult = NULL;
    }

    if (_pHeader)
    {
        _pHeader->Release();
        _pHeader = NULL;
    }

    if (_pResultImage)
    {
        _pResultImage->Release();
        _pResultImage = NULL;
    }

    if (_pConsoleVerb)
    {
        _pConsoleVerb->Release();
        _pConsoleVerb = NULL;
    }

    if (_pDisplayHelp)
    {
        _pDisplayHelp->Release();
        _pDisplayHelp = NULL;
    }
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::OnFind
//
//  Synopsis:   Handle a request to open a find dialog on log [pli].
//
//  Arguments:  [pli] - log on which to create find dialog
//
//  Returns:    HRESULT
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSnapin::OnFind(
    CLogInfo *pli)
{
    TRACE_METHOD(CSnapin, OnFind);

    HRESULT     hr = S_OK;
    CFindInfo *pfi = NULL;

    //
    // Find or create the CFindInfo object for log pli.
    //

    hr = _GetFindInfo(pli, &pfi);

    if (SUCCEEDED(hr))
    {
        //
        // Forward the find dialog request to the find info, which knows
        // whether it has already opened a dialog.
        //

        hr = pfi->OnFind();
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::QueryDataObject
//
//  Synopsis:   Create a data object in context [type] containing [cookie].
//
//  Arguments:  [cookie]       - identifies object for which data object is
//                                  being created
//              [type]         - context of call
//              [ppDataObject] - filled with new data object
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppDataObject]
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CSnapin::QueryDataObject(
    MMC_COOKIE cookie,
    DATA_OBJECT_TYPES context,
    LPDATAOBJECT *ppDataObject)
{
    // TRACE_METHOD(CSnapin, QueryDataObject);
    ASSERT(context == CCT_SCOPE  ||
           context == CCT_RESULT ||
           context == CCT_SNAPIN_MANAGER);

    HRESULT hr = S_OK;
    CDataObject *pdoNew = NULL;

    do
    {
        pdoNew = new CDataObject;
        *ppDataObject = pdoNew;

        if (!pdoNew)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (context == CCT_RESULT)
        {
            //
            // We're creating a data object for an item in the result pane.
            //
            // If the current selection in the scope pane is one of our child
            // folders, then the result pane object must be an event log
            // record.
            //
            // In that case, the passed-in cookie is the listview index; once
            // it's been converted to a record number, we're done.
            //

            if (_pCurScopePaneSelection)
            {
                pdoNew->SetCookie(_ResultRecs.IndexToRecNo(static_cast<ULONG>(cookie)),
                                  context,
                                  COOKIE_IS_RECNO);
                break;
            }

            //
            // If the current selection in the scope pane is the event log
            // snapin static node, then the result pane contains event log
            // folders, so [cookie] is actually a pointer to a CLogInfo
            // object.
            //
            // Otherwise, cookie is 0 because it represents the snapin static
            // node.  Therefore the current selection in the scope pane is the
            // parent of the event log snapin static node.
            //

            if (cookie)
            {
                ASSERT(_pcd->IsValidLogInfo((CLogInfo*)cookie));
                pdoNew->SetCookie(cookie, context, COOKIE_IS_LOGINFO);
            }
            else
            {
                ASSERT(FALSE);
                hr = E_UNEXPECTED;
            }
        }
        else
        {
            ASSERT(FALSE);
            hr = E_UNEXPECTED;
        }

    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::GetDisplayInfo
//
//  Synopsis:   Supply the string and/or icon requested in [dispinfo].
//
//  Arguments:  [prdi] - specifies item for which to retrieve data
//
//  Returns:    HRESULT
//
//  Modifies:   *[prdi]
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CSnapin::GetDisplayInfo(
    LPRESULTDATAITEM prdi)
{
    HRESULT hr = S_OK;

    //Dbg(DEB_ITRACE,
    //    "CSnapin::GetDisplayInfo: prdi->mask = %x, IsExtension=%u\n",
    //    prdi->mask,
    //    _pcd->IsExtension());

    if (!prdi)
    {
        return S_OK;
    }

    if (_IsFlagSet(SNAPIN_RESET_PENDING))
    {
        //Dbg(DEB_ITRACE, "CSnapin::GetDisplayInfo: Reset pending, returning\n");
        prdi->nImage = -1;
        prdi->str = L"";
        return S_OK;
    }

    do
    {
        //
        // If the currently selected scope pane item is the root folder, then
        // prdi->lParam is the CLogInfo * for the item in the result pane for
        // which we have to return strings.
        //
        // The exception is when we're an extension snapin and the result pane
        // item is the root "Event Viewer" folder.
        //

        if (!_pCurScopePaneSelection)
        {
            if (!prdi->lParam)
            {
               return E_FAIL;
            }

            ASSERT(prdi->bScopeItem);

            //
            // If snapin is extension & item referred to by prdi is the
            // root folder, return its name and image.
            //

            if (_pcd->IsExtension() &&
                prdi->lParam == EXTENSION_EVENT_VIEWER_FOLDER_PARAM)
            {
                if (prdi->mask & RDI_STR)
                {
                    switch (prdi->nCol)
                    {
                    case FOLDER_COL_NAME:
                        prdi->str = g_wszEventViewer;
                        break;

                    case FOLDER_COL_TYPE:
                        prdi->str = g_wszSnapinType;
                        break;

                    case FOLDER_COL_DESCRIPTION:
                        prdi->str = g_wszSnapinDescr;
                        break;

                    default:
                        Dbg(DEB_ERROR,
                            "CSnapin::GetDisplayInfo: unexpected column %uL\n",
                            prdi->nCol);
                        prdi->str = L"";
                        break;
                    }
                }

                if (prdi->mask & RDI_IMAGE)
                {
                    prdi->nImage = IDX_RDI_BMP_FOLDER;
                }
                break;
            }
            //
            // Result item is a loginfo
            //

            CLogInfo *pli = (CLogInfo *) prdi->lParam;

            ASSERT(_pcd->IsValidLogInfo(pli));

            if(prdi->mask & RDI_IMAGE)
            {
                if (pli->IsEnabled())
                {
                    prdi->nImage = IDX_RDI_BMP_LOG;
                }
                else
                {
                    prdi->nImage = IDX_RDI_BMP_LOG_DISABLED;
                }
            }

            if (prdi->mask & RDI_STR)
            {
                switch (prdi->nCol)
                {
                case FOLDER_COL_NAME:
                    prdi->str = pli->GetDisplayName();
                    break;

                case FOLDER_COL_TYPE:
                    prdi->str = pli->GetTypeStr();
                    break;

                case FOLDER_COL_DESCRIPTION:
                    prdi->str = pli->GetDescription();
                    break;

                case FOLDER_COL_SIZE:
                    prdi->str = pli->GetLogSize(FALSE);
                    break;

                default:
                    ASSERT(FALSE);
                }
            }
            break;
        }

#ifndef ELS_TASKPAD
        ASSERT(!prdi->bScopeItem);
#else
		// JonN 4/26/00 98816
		// View Extensions will ask for the icon of a scopeitem
		if (prdi->bScopeItem)
		{
            ASSERT(!IsBadReadPtr(_pcd, sizeof(*_pcd)));
			if (IsBadReadPtr(_pcd, sizeof(*_pcd)))
			{
                Dbg(DEB_ERROR, "CSnapin::GetDisplayInfo bad _pcd\n");
                hr = E_POINTER;
				break;
			}
			SCOPEDATAITEM sdi;
			::ZeroMemory( &sdi, sizeof(sdi) );
			if (prdi->mask & RDI_STR)
				sdi.mask |= SDI_STR;
			if (prdi->mask & RDI_IMAGE)
				sdi.mask |= SDI_IMAGE;
			sdi.lParam = prdi->lParam;
			hr = _pcd->GetDisplayInfo( &sdi );
			prdi->nImage = sdi.nImage;
			prdi->str = sdi.displayname;
			break;
		}
#endif // ELS_TASKPAD

        //
        // The currently selected scope pane item is a log folder, so we are
        // working with a virtual listview and only the listview index is
        // valid.
        //

        hr = _ResultRecs.SeekToIndex(prdi->nIndex);

        //
        // If a cache miss occurred and forced a read from the log, which
        // returned an error indicating it has been cleared, set the reset
        // pending flag so that this routine (and possibly others) don't
        // attempt to do further reads from the log.
        //
        // When the current operation has finished, the console msg
        // pump will dispatch the reset message posted as a result of this
        // call to _RecordCache.Seek; the CSynchWindow::WndProc will then
        // tell all components registered with it that a refresh for the
        // log described by the loginfo currently selected for this snapin
        // is necessary.
        //

        if (FAILED(hr))
        {
            _pcd->NotifySnapinsResetPending(_pCurScopePaneSelection);

            //
            // Supply reasonable values to avoid a fault
            //

            prdi->nImage = -1;
            prdi->str = L"";
            break;
        }

        if (prdi->mask & RDI_IMAGE)
        {
            prdi->nImage = _ResultRecs.GetImageListIndex();
        }

        if (prdi->mask & RDI_STR)
        {
            prdi->str =
                _ResultRecs.GetColumnString((LOG_RECORD_COLS) prdi->nCol);
        }
    }
    while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::GetResultViewType
//
//  Synopsis:   Called by MMC to determine the type of control to use for
//              the result pane.
//
//  Returns:    S_FALSE (always use listview control)
//
//  History:    12-06-1996   DavidMun   Created
//              04-09-1997   DavidMun   add pViewOptions
//
//---------------------------------------------------------------------------

STDMETHODIMP
CSnapin::GetResultViewType(
    MMC_COOKIE cookie,
    BSTR *ppViewType,
    long* pViewOptions)
{
    TRACE_METHOD(CSnapin, GetResultViewType);

    //
    // Ask for default listview, but remove the view styles from context
    // menus, since only reportview makes sense for events.
    //

    *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS
                  | MMC_VIEW_OPTIONS_LEXICAL_SORT; // JonN 11/21/00 238144

    if (cookie && cookie != EXTENSION_EVENT_VIEWER_FOLDER_PARAM)
    {
        *pViewOptions |= MMC_VIEW_OPTIONS_OWNERDATALIST;
    }
    return S_FALSE;
}



//============================================================================
//
// IExtendPropertySheet implementation
//
//============================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::CreatePropertyPages
//
//  Synopsis:   Create property pages appropriate to the object described
//              by [pIDataObject].
//
//  Arguments:  [lpProvider]   - callback for adding pages
//              [handle]       - unused
//              [pIDataObject] - describes object on which prop sheet is
//                                  being opened.
//
//  Returns:    HRESULT
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CSnapin::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK lpProvider,
    LONG_PTR handle,
    LPDATAOBJECT pIDataObject)
{
    TRACE_METHOD(CSnapin, CreatePropertyPages);

    CDataObject *pdo = ExtractOwnDataObject(pIDataObject);

    if (!pdo)
    {
        return S_OK;
    }

    if (pdo->GetContext() == CCT_RESULT &&
        pdo->GetCookieType() == COOKIE_IS_RECNO)
    {
        //
        // We should have gotten a notification already and kept the
        // selected record number up to date.
        //

        Dbg(DEB_TRACE,
            "_ulCurSelectedRecNo = %u, cookie = %u\n",
            _ulCurSelectedRecNo,
            pdo->GetCookie());
        ASSERT(_ulCurSelectedRecNo == (ULONG)pdo->GetCookie());

        //
        // user is asking for new or updated property inspector on an event
        // log record.
        //

        if (_InspectorInfo.InspectorInvoked())
        {
            _InspectorInfo.UpdateCurResultRec(
                _ResultRecs.CopyRecord(_ulCurSelectedRecNo),
                FALSE);
            return S_OK;
        }

        return _CreatePropertyInspector(lpProvider);
    }

    //
    // Shouldn't get here because console is either asking IComponent for
    // prop pages on folder (which it should be asking IComponentData for)
    // or else the context is not the result pane.
    //

    ASSERT(FALSE);
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::QueryPagesFor
//
//  Synopsis:   Return S_OK if we have one or more property pages for the
//              item represented by [lpDataObject], or S_FALSE if we
//              have no pages to contribute.
//
//  Returns:    S_OK or S_FALSE.
//
//  History:    12-13-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CSnapin::QueryPagesFor(
    LPDATAOBJECT lpDataObject)
{
    TRACE_METHOD(CSnapin, QueryPagesFor);

    CDataObject *pdo = ExtractOwnDataObject(lpDataObject);

    if (!pdo)
    {
        return S_FALSE;
    }

    //
    // If the cookie is for an event record, then indicate a prop sheet should
    // be created.
    //

    if (pdo->GetCookieType() == COOKIE_IS_RECNO)
    {
        return S_OK;
    }

    //
    // Shouldn't get here; mmc is asking component for componentdata prop
    // pages
    //

    ASSERT(FALSE);
    return S_FALSE;
}



//============================================================================
//
// IExtendContextMenu implementation
//
//============================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::AddMenuItems
//
//  Synopsis:   Defer to IComponentData implementation.
//
//  History:    2-05-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CSnapin::AddMenuItems(
    LPDATAOBJECT piDataObject,
    LPCONTEXTMENUCALLBACK piCallback,
    long *pInsertionAllowed)
{
    TRACE_METHOD(CSnapin, AddMenuItems);

    return _pcd->AddMenuItems(piDataObject, piCallback, pInsertionAllowed);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::Command
//
//  Synopsis:   Defer to IComponentData implementation.
//
//  History:    2-05-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CSnapin::Command(
    long lCommandID,
    LPDATAOBJECT piDataObject)
{
    TRACE_METHOD(CSnapin, Command);
    return _pcd->Command(lCommandID, piDataObject);
}



//============================================================================
//
// IResultDataCompare implementation
//
//============================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::Compare
//
//  Synopsis:   Sort comparison callback.
//
//  Arguments:  [lUserParam] - 0 = compare column values,
//                             OLDEST_FIRST
//                             NEWEST_FIRST
//              [cookieA]    - left record number
//              [cookieB]    - right record number
//              [piResult]   - on entry, col number.  on exit, result as
//                               -1, 0, or 1
//
//  Returns:    HRESULT
//
//  Modifies:   *[pnResult]
//
//  Derivation: IResultDataCompare
//
//  History:    2-15-1997   DavidMun   Created
//
//  Notes:      Caller is not happy with < 0 or > 0, must be strictly -1
//              or 1.
//
//---------------------------------------------------------------------------

STDMETHODIMP
CSnapin::Compare(
    LPARAM lUserParam,
    MMC_COOKIE cookieA,
    MMC_COOKIE cookieB,
    int* piResult)
{
    HRESULT hr = S_OK;

    //
    // If the current selection is the static node then we're being
    // asked to sort scope pane items that are in the result pane.
    //
    // This function should never be called for a result pane containing
    // event log records, since if that's the case the listview is in virtual
    // mode and will call IResultOwnerData::SortItems instead.
    //

    ASSERT(!_pCurScopePaneSelection);

    CLogInfo *pliA = (CLogInfo *) cookieA;
    CLogInfo *pliB = (CLogInfo *) cookieB;

    ASSERT(_pcd->IsValidLogInfo(pliA));
    ASSERT(_pcd->IsValidLogInfo(pliB));

    switch (*piResult)
    {
    case FOLDER_COL_NAME:
        *piResult = lstrcmp(pliA->GetDisplayName(),
                            pliB->GetDisplayName());
        break;

    case FOLDER_COL_TYPE:
        *piResult = lstrcmp(pliA->GetTypeStr(),
                            pliB->GetTypeStr());
        break;

    case FOLDER_COL_DESCRIPTION:
        *piResult = lstrcmp(pliA->GetDescription(),
                            pliB->GetDescription());
        break;

    case FOLDER_COL_SIZE:
        *piResult = lstrcmp(pliA->GetLogSize(FALSE),
                            pliB->GetLogSize(FALSE));
        break;

    default:
        *piResult = 0;
        Dbg(DEB_ERROR,
            "CSnapin::Compare: illegal folder col %uL\n",
            *piResult);
        break;
    }

    return hr;
}




//============================================================================
//
// IResultOwnerData implementation
//
//============================================================================

HRESULT
CSnapin::FindItem(
    LPRESULTFINDINFO pFindInfo,
    int *pnFoundIndex)
{
    return S_FALSE;
}




HRESULT
CSnapin::CacheHint(
    int nStartIndex,
    int nEndIndex)
{
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::SortItems
//
//  Synopsis:   Sort the record list by column [nColumn].
//
//  Arguments:  [nColumn]       - 0..NUM_RECORD_COLS-1
//              [dwSortOptions] - RSI_*
//              [lUserParam]    - SNAPIN_SORT_*
//
//  Returns:    S_OK    - sorted
//              S_FALSE - no changes
//
//  History:    07-03-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSnapin::SortItems(
    int nColumn,
    DWORD dwSortOptions,
    LPARAM lUserParam)
{
    TRACE_METHOD(CSnapin, SortItems);

    HRESULT hr = S_OK;
    CWaitCursor Hourglass;

    //
    // Sorts that don't correspond to a column must be handled specially.
    //

    SORT_ORDER NewOrder;

    if (lUserParam == SNAPIN_SORT_OVERRIDE_NEWEST)
    {
        NewOrder = NEWEST_FIRST;
    }
    else if (lUserParam == SNAPIN_SORT_OVERRIDE_OLDEST)
    {
        NewOrder = OLDEST_FIRST;
    }
    else
    {
        NewOrder = (SORT_ORDER) nColumn;
    }

    ULONG flFlags = 0;

    if (dwSortOptions & RSI_DESCENDING)
    {
        flFlags |= SO_DESCENDING;
    }

    if (_pCurScopePaneSelection && _pCurScopePaneSelection->IsFiltered())
    {
        flFlags |= SO_FILTERED;
    }

    hr = _ResultRecs.Sort(NewOrder, flFlags, &_SortOrder);

    //
    // Sorting doesn't change the currently selected listview index, but
    // the record that was at that index is now probably somewhere else.
    // Find it and reselect it--UNLESS we're doing NEWEST_FIRST or
    // OLDEST_FIRST.
    //

    if (SUCCEEDED(hr) &&
        hr != S_FALSE &&
        NewOrder != NEWEST_FIRST &&
        NewOrder != OLDEST_FIRST)
    {
        ULONG ulNewSelectedIndex;

        HRESULT hr2 = _ResultRecs.RecNoToIndex(_ulCurSelectedRecNo,
                                               &ulNewSelectedIndex);

        // If this fails then sorting caused an item to disappear!
        ASSERT(SUCCEEDED(hr2));

        if (SUCCEEDED(hr2))
        {
            _ChangeRecSelection(_ulCurSelectedIndex, ulNewSelectedIndex);
        }
    }
    return hr;
}




//============================================================================
//
// IResultPrshtActions implementation
//
//============================================================================






//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::FindNext
//
//  Synopsis:   Set the current selection to the next item in the listview
//              matching the criteria specified in [pfi].
//
//  Arguments:  [ul_pfi] - specifies search criteria
//
//  Returns:    HRESULT
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSnapin::FindNext(
    ULONG_PTR ul_pfi)
{
    TRACE_METHOD(CSnapin, FindNext);

    HRESULT hr = S_OK;
    CFindInfo *pfi = (CFindInfo *) ul_pfi;

    //
    // If the count of records in the listview is 0 this is a no-op
    //

    if (!_ResultRecs.GetCountOfRecsDisplayed())
    {
        return hr;
    }

    //
    // If there is 1 item the search must fail, because this is
    // find NEXT.
    //

    HWND hdlg = pfi->GetDlgWindow();

    if (_ResultRecs.GetCountOfRecsDisplayed() == 1)
    {
        if (pfi->GetDirection() == FORWARD)
        {
            MsgBox(hdlg,
                   IDS_SEARCH_FAIL_FORWARD,
                   MB_OK | MB_ICONINFORMATION);
        }
        else
        {
            MsgBox(hdlg,
                   IDS_SEARCH_FAIL_BACKWARD,
                   MB_OK | MB_ICONINFORMATION);
        }
        return hr;
    }

#if (DBG == 1)
    pfi->Dump();
#endif // (DBG == 1)

    //
    // Get the listview index of the currently selected item.  Save it so
    // it can be deselected and so we can detect search failure.
    //

    ULONG idxStart = _GetCurSelRecIndex();
    Dbg(DEB_ITRACE, "Cur selected index is %u\n", idxStart);
    ULONG idxCur = idxStart;

    //
    // Iterate through the items in the listview, searching for a record
    // that passes the find criteria.
    //

    BOOL fFoundItem = FALSE;
    BOOL fDisplayFail = TRUE;

    while (1)
    {
        //
        // Compute the index of the next item to examine
        //

        if (pfi->GetDirection() == FORWARD)
        {
            // see if we are at end of listview

            if (idxCur == _ResultRecs.GetCountOfRecsDisplayed() - 1)
            {
                //
                // if we started at the top of the listview, there's no
                // point in wrapping, the search has failed.
                //

                if (!idxStart)
                {
                    break;
                }

                //
                // See if user wants to wrap to top of listview
                //

                ULONG ulAnswer = MsgBox(hdlg,
                                        IDS_WRAP_TO_END,
                                        MB_YESNO | MB_ICONQUESTION);

                // EricB 9/21/01 bug 468536 snapin window can be closed while
                // this message box is up. CSnapin::Destroy will zero several
                // pointers including this one. If zero, that means the
                // snapin is gone.
                if (!_pConsole)
                {
                    return S_FALSE;
                }

                if (ulAnswer == IDYES)
                {
                    idxCur = 0;
                }
                else
                {
                    fDisplayFail = FALSE;
                    break;
                }
            }
            else
            {
                // we haven't reached end of listview yet, just inc
                idxCur++;
            }
        }
        else
        {
            if (!idxCur)
            {
                if (idxStart == _ResultRecs.GetCountOfRecsDisplayed() - 1)
                {
                    break;
                }

                ULONG ulAnswer = MsgBox(hdlg,
                                        IDS_WRAP_TO_START,
                                        MB_YESNO | MB_ICONQUESTION);

                // EricB 9/21/01 bug 468536 snapin window can be closed while
                // this message box is up. CSnapin::Destroy will zero several
                // pointers including this one. If zero, that means the
                // snapin is gone.
                if (!_pConsole)
                {
                    return S_FALSE;
                }

                if (ulAnswer == IDYES)
                {
                    idxCur = _ResultRecs.GetCountOfRecsDisplayed() - 1;
                }
                else
                {
                    fDisplayFail = FALSE;
                    break;
                }
            }
            else
            {
                idxCur--;
            }
        }

        //
        // See if idxCur is now back to the item from which we started
        // searching.  If so, the search has failed.
        //

        if (idxCur == idxStart)
        {
            break;
        }

        // EricB 9/25/01 466171 Problems when use Filter and Find at same time.
        // Filter can be reset to not display anything while find is blocked
        // in one of the above MsgBox calls.
        if (!_ResultRecs.GetCountOfRecsDisplayed())
        {
            return S_OK;
        }

        //
        // Set the result record's current record pointer to the listview
        // item idxCur.
        //

        hr = _ResultRecs.SeekToIndex(idxCur);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            _pcd->NotifySnapinsResetPending(pfi->GetLogInfo());
            break;
        }

        //
        // If the record meets the find criteria, stop searching
        //

        if (pfi->Passes(&_ResultRecs))
        {
            fFoundItem = TRUE;
            break;
        }
    }

    if (fFoundItem)
    {
        //
        // deselect idxStart and select idxCur
        //

        _ChangeRecSelection(idxStart, idxCur);
    }
    else if (fDisplayFail)
    {
        if (pfi->GetDirection() == FORWARD)
        {
            MsgBox(hdlg,
                   IDS_SEARCH_FAIL_FORWARD,
                   MB_OK | MB_ICONINFORMATION);
        }
        else
        {
            MsgBox(hdlg,
                   IDS_SEARCH_FAIL_BACKWARD,
                   MB_OK | MB_ICONINFORMATION);
        }
    }
    return hr;
}





//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::InspectorAdvance
//
//  Synopsis:   Handle a request from the user via the record details
//              property inspector to view the next or previous record.
//
//  Arguments:  [idNextPrev] - detail_next_pb or detail_prev_pb
//              [fWrapOk]    - FALSE: if advancing would wrap, return TRUE
//                             TRUE:  if wrapping required, do it
//
//  Returns:    S_OK    - selection advanced or [fWrapOk] was FALSE and
//                          advancing would have wrapped.
//              S_FALSE - no wrap required
//
//  History:    12-18-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSnapin::InspectorAdvance(
    ULONG idNextPrev,
    ULONG fWrapOk)
{
    TRACE_METHOD(CSnapin, InspectorAdvance);

    //
    // Determine the number of items in the listview.  If there are
    // less than two items, next/prev is a no-op.
    //

    if (_ResultRecs.GetCountOfRecsDisplayed() < 2)
    {
        return S_FALSE;
    }

    ASSERT(_pCurScopePaneSelection); // resultview should have leaf nodes

    //
    // Determine the index of the current selection
    //

    ULONG idxCurSelection = _GetCurSelRecIndex();

    //
    // Compute the index of the next selection, wrapping from top to bottom
    // or bottom to top.
    //

    ULONG idxNewSelection;

    if (idNextPrev == detail_next_pb)
    {
        if (idxCurSelection == _ResultRecs.GetCountOfRecsDisplayed() - 1)
        {
            if (!fWrapOk)
            {
                return S_OK;
            }
            idxNewSelection = 0;
        }
        else
        {
            idxNewSelection = idxCurSelection + 1;
        }
    }
    else
    {
        if (idxCurSelection == 0)
        {
            if (!fWrapOk)
            {
                return S_OK;
            }
            idxNewSelection = _ResultRecs.GetCountOfRecsDisplayed() - 1;
        }
        else
        {
            idxNewSelection = idxCurSelection - 1;
        }
    }

    //
    // Deselect the current item, and select the new one
    //

    _ChangeRecSelection(idxCurSelection, idxNewSelection);
    return S_FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::_ChangeRecSelection
//
//  Synopsis:   Deselect [idxCurSelection] and select [idxNewSelection] in
//              the result pane.
//
//  Arguments:  [idxCurSelection] - listview index to deselect
//              [idxNewSelection] - listview index to select
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSnapin::_ChangeRecSelection(
    ULONG idxCurSelection,
    ULONG idxNewSelection)
{
    Dbg(DEB_TRACE,
        "CSnapin::_ChangeRecSelection changing from %u to %u\n",
        idxCurSelection,
        idxNewSelection);
    HRESULT hr;

    hr = _pResult->ModifyItemState(idxCurSelection,
                                   0,
                                   0,
                                   LVIS_SELECTED | LVIS_FOCUSED);

    if (SUCCEEDED(hr))
    {
        hr = _pResult->ModifyItemState(idxNewSelection,
                                       0,
                                       LVIS_SELECTED | LVIS_FOCUSED,
                                       0);
        CHECK_HRESULT(hr);
    }
    else
    {
        DBG_OUT_HRESULT(hr);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::SetInspectorWnd
//
//  Synopsis:   Set the window handle of the record details property
//              inspector.
//
//  Arguments:  [ul_hwnd] - window handle of CDetailsPage
//                            dialog, or NULL if property inspector is
//                            closing.
//
//  Returns:    S_OK
//
//  History:    12-14-1996   DavidMun   Created
//
//  Notes:      CSnapin will post a message to [ul_hwnd] via the inspector
//              object whenever the current event record selection in the
//              result pane changes.
//
//---------------------------------------------------------------------------

HRESULT
CSnapin::SetInspectorWnd(
    ULONG_PTR ul_hwnd)
{
    TRACE_METHOD(CSnapin, SetInspectorWnd);

    _InspectorInfo.SetInspectorWnd((HWND) ul_hwnd);
    return S_OK;
}


//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::GetCurSelLogInfo
//
//  Synopsis:   Return a pointer to the CLogInfo object representing the
//              currently selected scope pane item, or NULL if no log is
//              selected in the scope pane.
//
//  Arguments:  [ul_ppli] - filled with pointer to loginfo
//
//  Returns:    S_OK
//
//  History:    1-05-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSnapin::GetCurSelLogInfo(
    ULONG_PTR ul_ppli)
{
    *(CLogInfo **)ul_ppli = _pCurScopePaneSelection;
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::_GetCurSelRecIndex
//
//  Synopsis:   Return the listview index (0 based) of the currently
//              selected item in the result pane, or 0 if none is selected.
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CSnapin::_GetCurSelRecIndex()
{
    RESULTDATAITEM rdi;
    ZeroMemory(&rdi, sizeof(RESULTDATAITEM));

    rdi.mask = RDI_STATE | RDI_INDEX;
    rdi.nIndex = -1;
    rdi.nState = LVNI_ALL | LVNI_SELECTED;

#if (DBG == 1)
    HRESULT hr =
#endif // (DBG == 1)
        _pResult->GetNextItem(&rdi);
    CHECK_HRESULT(hr);

    ULONG idxCurSelection = (ULONG) rdi.nIndex;

    if (idxCurSelection == (ULONG)-1)
    {
        //
        // Nothing was selected; act as if the first item is selected
        //

        idxCurSelection = 0;
    }
    return idxCurSelection;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::GetCurSelRecCopy
//
//  Synopsis:   Access function for use by property inspector.
//
//  Arguments:  [ppelr] - points to ulong to fill with pointer to record
//
//  Returns:    S_OK
//
//  History:    12-14-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSnapin::GetCurSelRecCopy(
    ULONG_PTR ul_ppelr)
{
    return _InspectorInfo.CopyCurResultRec((EVENTLOGRECORD **)ul_ppelr);
}




//============================================================================
//
// Non-interface member function implementation
//
//============================================================================



//+---------------------------------------------------------------------------
//
//  Member:     CSnapin::CSnapin
//
//  Synopsis:   ctor
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

CSnapin::CSnapin(CComponentData *pComponent):
    _cRefs(1),
    _pConsole(NULL),
    _pResult(NULL),
    _pHeader(NULL),
    _pResultImage(NULL),
    _pConsoleVerb(NULL),
    _pCurScopePaneSelection(NULL),
    _SortOrder(NEWEST_FIRST),
    _ulCurSelectedRecNo(0),
    _ulCurSelectedIndex(0),
    _pcd(pComponent),
    _pFindInfoList(NULL),
    _pDisplayHelp(0)
{
    TRACE_CONSTRUCTOR(CSnapin);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapin);
    ASSERT(pComponent);

    _aiFolderColWidth[IDS_FOLDER_HDR_NAME - IDS_FIRST_FOLDER_HDR] =
        FOLDER_NAME_DEFAULT_WIDTH;
    _aiFolderColWidth[IDS_FOLDER_HDR_TYPE - IDS_FIRST_FOLDER_HDR] =
        FOLDER_TYPE_DEFAULT_WIDTH;
    _aiFolderColWidth[IDS_FOLDER_HDR_DESCRIPTION - IDS_FIRST_FOLDER_HDR] =
        FOLDER_DESCRIPTION_DEFAULT_WIDTH;
    _aiFolderColWidth[IDS_FOLDER_HDR_SIZE - IDS_FIRST_FOLDER_HDR] =
        FOLDER_SIZE_DEFAULT_WIDTH;

    _aiRecordColWidth[IDS_RECORD_HDR_TYPE - IDS_FIRST_RECORD_HDR] =
        RECORD_TYPE_DEFAULT_WIDTH;
    _aiRecordColWidth[IDS_RECORD_HDR_DATE - IDS_FIRST_RECORD_HDR] =
        RECORD_DATE_DEFAULT_WIDTH;
    _aiRecordColWidth[IDS_RECORD_HDR_TIME - IDS_FIRST_RECORD_HDR] =
        RECORD_TIME_DEFAULT_WIDTH;
    _aiRecordColWidth[IDS_RECORD_HDR_SOURCE - IDS_FIRST_RECORD_HDR] =
        RECORD_SOURCE_DEFAULT_WIDTH;
    _aiRecordColWidth[IDS_RECORD_HDR_CATEGORY - IDS_FIRST_RECORD_HDR] =
        RECORD_CATEGORY_DEFAULT_WIDTH;
    _aiRecordColWidth[IDS_RECORD_HDR_EVENT - IDS_FIRST_RECORD_HDR] =
        RECORD_EVENT_DEFAULT_WIDTH;
    _aiRecordColWidth[IDS_RECORD_HDR_USER - IDS_FIRST_RECORD_HDR] =
        RECORD_USER_DEFAULT_WIDTH;
    _aiRecordColWidth[IDS_RECORD_HDR_COMPUTER - IDS_FIRST_RECORD_HDR] =
        RECORD_COMPUTER_DEFAULT_WIDTH;
}




//+---------------------------------------------------------------------------
//
//  Member:     CSnapin::~CSnapin
//
//  Synopsis:   dtor
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

CSnapin::~CSnapin()
{
    TRACE_DESTRUCTOR(CSnapin);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapin);

    //
    // Free all cached data
    //

    _ResultRecs.Close();

    //
    // Free the information used to do finds on event records
    //

    CFindInfo *pfiCur;
    CFindInfo *pfiNext;

    for (pfiCur = _pFindInfoList; pfiCur; pfiCur = pfiNext)
    {
        pfiNext = pfiCur->Next();

        pfiCur->UnLink();
        delete pfiCur;
    }
    _pFindInfoList = NULL;

    //
    // Release any interface pointers we got.  These *should* have been
    // released already by a call to CSnapin::IConsole::Destroy.
    //

    if (_pConsole)
    {
        _pConsole->Release();
        _pConsole = NULL;
    }

    if (_pResult)
    {
        _pResult->Release();
        _pResult = NULL;
    }

    if (_pHeader)
    {
        _pHeader->Release();
        _pHeader = NULL;
    }

    if (_pResultImage)
    {
        _pResultImage->Release();
        _pResultImage = NULL;
    }

    if (_pConsoleVerb)
    {
        _pConsoleVerb->Release();
        _pConsoleVerb = NULL;
    }

    if (_pDisplayHelp)
    {
        _pDisplayHelp->Release();
        _pDisplayHelp = NULL;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::_CreatePropertyInspector
//
//  Synopsis:   If a property inspector window is open, notifies it to
//              update itself, otherwise opens a new inspector.
//
//  Arguments:  [lpProvider] - callback for adding property pages
//
//  Returns:    HRESULT
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSnapin::_CreatePropertyInspector(
    LPPROPERTYSHEETCALLBACK lpProvider)
{
    ASSERT(!_InspectorInfo.InspectorInvoked());

    HRESULT             hr = S_OK;
    PROPSHEETPAGE       psp;
    HPROPSHEETPAGE      hDetailsPage = NULL;
    BOOL                fAddedDetailsPage = TRUE;

    CDetailsPage       *pDetailsPage = NULL;

    IStream            *pstmDetails  = NULL;
    EVENTLOGRECORD     *pelrCopy = NULL;

    _InspectorInfo.SetOpenInProgress();

    do
    {
        hr = CoMarshalInterThreadInterfaceInStream(
                                    IID_IResultPrshtActions,
                                    (IResultPrshtActions *) this,
                                    &pstmDetails);
        BREAK_ON_FAIL_HRESULT(hr);

        pDetailsPage = new CDetailsPage(pstmDetails);

        if (!pDetailsPage)
        {
            hr = E_OUTOFMEMORY;
            break;
        }

        pstmDetails = NULL;

        ZeroMemory(&psp, sizeof psp);

        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_USECALLBACK;
        psp.hInstance   = g_hinst;
        psp.pfnDlgProc  = CPropSheetPage::DlgProc;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_DETAILS);
        psp.lParam      = (LPARAM) pDetailsPage;
        psp.pfnCallback = PropSheetCallback;

        hDetailsPage = CreatePropertySheetPage(&psp);

        if (!hDetailsPage)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }

        //
        // Try to add the page
        //

        hr = lpProvider->AddPage(hDetailsPage);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            VERIFY(DestroyPropertySheetPage(hDetailsPage));
            break;
        }

        fAddedDetailsPage = TRUE;

        //
        // Now try to give it a copy of the current record.  If we
        // can't get a copy this will just show "no record selected".
        //

        pelrCopy = _ResultRecs.CopyRecord(_ulCurSelectedRecNo);

        _InspectorInfo.UpdateCurResultRec(pelrCopy, FALSE);
    } while (0);

    //
    // If the page was added successfully, it will need to access
    // _InspectorInfo.pCurResultRecCopy.  So only delete that if the
    // page couldn't be created.
    //

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);

        if (pstmDetails)
        {
            pstmDetails->Release();
        }

        if (!fAddedDetailsPage)
        {
            _InspectorInfo.UpdateCurResultRec(NULL, FALSE);

            delete pDetailsPage;
        }
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::_GetFindInfo
//
//  Synopsis:   Return existing or create new find info for log [pli].
//
//  Arguments:  [pli]  - log to find/create findinfo for
//              [ppfi] - filled with pointer to findinfo or NULL
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//  Modifies:   *[ppfi]
//
//  History:    3-21-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSnapin::_GetFindInfo(
    CLogInfo *pli,
    CFindInfo **ppfi)
{
    HRESULT hr = S_OK;

    //
    // see if a find info has already been created for this loginfo
    //

    *ppfi = _LookupFindInfo(pli);

    if (*ppfi)
    {
        return hr;
    }

    //
    // None yet, try to create one
    //

    *ppfi = new CFindInfo(this, pli);

    if (!*ppfi)
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    //
    // Add it to our llist
    //

    if (!_pFindInfoList)
    {
        _pFindInfoList = *ppfi;
    }
    else
    {
        (*ppfi)->LinkAfter((CDLink *) _pFindInfoList);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::HandleLogChange
//
//  Synopsis:   If this is currently displaying data for the same log as
//              the one described by [pliAffectedLog], handle the change
//              described by [ldc].
//
//  Arguments:  [ldc]            - describes change in log
//              [pliAffectedLog] - describes log whose data has changed.
//              [fNotifyUser]    - TRUE if this is the first snapin of the
//                                  first componentdata to receive this
//                                  notification.
//
//  History:    2-18-1997   DavidMun   Created
//
//  Notes:      CAUTION: **DO NOT** compare [pliAffectedLog] against
//              _pCurScopePaneSelection, since it may be a CLogInfo owned
//              by a CComponentData object OTHER THAN this's parent
//              CComponentData.
//
//---------------------------------------------------------------------------

BOOL
CSnapin::HandleLogChange(
    LOGDATACHANGE ldc,
    CLogInfo *pliAffectedLog,
    BOOL      fNotifyUser)
{
    TRACE_METHOD(CSnapin, HandleLogChange);

    if (!_pCurScopePaneSelection ||
        !_pCurScopePaneSelection->IsSameLog(pliAffectedLog))
    {
        return FALSE;
    }

    BOOL fDisplayedMsgBox = FALSE;
    CWaitCursor Hourglass;

    switch (ldc)
    {
    case LDC_CORRUPT:
        fDisplayedMsgBox = _HandleLogCorrupt(fNotifyUser);
        break;

    case LDC_CLEARED:
    case LDC_FILTER_CHANGE:
        fDisplayedMsgBox = _HandleLogClearedOrFilterChange(fNotifyUser);
        break;

    case LDC_RECORDS_CHANGED:
        _HandleLogRecordsChanged();
        break;

    case LDC_DISPLAY_NAME:
        ASSERT(0 && "LDC_DISPLAY_NAME should be handled by componentdata");
        break;

    default:
        ASSERT(0 && "CSnapin::HandleLogChange: unknown ldc");
        break;
    }

    return fDisplayedMsgBox;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::_HandleLogCorrupt
//
//  Synopsis:   Let the user know the log file is corrupt, and clear the
//              listview without attempting to repopulate it.
//
//  Arguments:  [fNotifyUser] - if TRUE, tell the user that the log was
//                               corrupt
//
//  Returns:    [fNotifyUser]
//
//  History:    07-07-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CSnapin::_HandleLogCorrupt(
    BOOL fNotifyUser)
{
    TRACE_METHOD(CSnapin, _HandleLogCorrupt);

    BOOL fDisplayedMsgBox = FALSE;

    if (fNotifyUser)
    {
        ConsoleMsgBox(_pConsole,
                      IDS_EVENTLOG_FILE_CORRUPT,
                      MB_OK | MB_ICONERROR);
        fDisplayedMsgBox = TRUE;
    }

#if (DBG == 1)
    HRESULT hr =
#endif // (DBG == 1)
        _pResult->DeleteAllRsltItems();
    CHECK_HRESULT(hr);

    _ResultRecs.Clear();

    ASSERT(SUCCEEDED(hr));
    _ClearFlag(SNAPIN_RESET_PENDING);
    _SortOrder = NEWEST_FIRST;
    _pCurScopePaneSelection->Enable(FALSE);
    PostScopeBitmapUpdate(_pcd, _pCurScopePaneSelection);
    _UpdateDescriptionText(_pCurScopePaneSelection);
    return fDisplayedMsgBox;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::_HandleLogClearedOrFilterChange
//
//  Synopsis:   Clear and repopulate the result pane
//
//  Arguments:  [fNotifyUser] - if TRUE and an error occurs attempting to
//                               access the log while repopulating, notify
//                               the user.
//
//  Returns:    TRUE if a messagebox was displayed, FALSE otherwise.
//
//  History:    07-07-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CSnapin::_HandleLogClearedOrFilterChange(
    BOOL fNotifyUser)
{
    TRACE_METHOD(CSnapin, _HandleLogClearedOrFilterChange);

    BOOL fDisplayedMsgBox = FALSE;

    HRESULT hr = _pResult->DeleteAllRsltItems();
    CHECK_HRESULT(hr);

    hr = _ResultRecs.Clear();
    _ClearFlag(SNAPIN_RESET_PENDING);
    _SortOrder = NEWEST_FIRST;

    if (SUCCEEDED(hr))
    {
        hr = _PopulateResultPane(_pCurScopePaneSelection);
        CHECK_HRESULT(hr);
        _UpdateDescriptionText(_pCurScopePaneSelection);
    }
    else
    {
        if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) ||
            hr == HRESULT_FROM_WIN32(ERROR_EVENTLOG_FILE_CORRUPT))
        {
            _pCurScopePaneSelection->Enable(FALSE);
            if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
            {
                _pCurScopePaneSelection->SetReadOnly(TRUE);
            }
            PostScopeBitmapUpdate(_pcd, _pCurScopePaneSelection);
        }
        _UpdateDescriptionText(_pCurScopePaneSelection);

        if (fNotifyUser)
        {
            DisplayLogAccessError(hr,
                                  _pcd->GetConsole(),
                                  _pCurScopePaneSelection);
            fDisplayedMsgBox = TRUE;
        }
    }
    return fDisplayedMsgBox;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::_HandleLogRecordsChanged
//
//  Synopsis:   Handle the case where records that we attempted to read from
//              the event log were no longer available because they had been
//              overwritten (or cleared by some other user).
//
//  History:    07-07-2000   DavidMun   Created
//
//  Notes:      Reduces the listview count to stop attempting to display
//              records that aren't there anymore.
//
//---------------------------------------------------------------------------

VOID
CSnapin::_HandleLogRecordsChanged()
{
    TRACE_METHOD(CSnapin, _HandleLogRecordsChanged);

    //
    // We got here because a record we needed info for was not in
    // the light rec or raw caches, and upon attempting to read it
    // from the log we got an error indicating the record no longer
    // exists.  Change the listview item count so that we don't ask
    // for the nonexistant records any more.
    //

    ULONG cRecsDisplayed = _ResultRecs.GetCountOfRecsDisplayed();
    Dbg(DEB_TRACE, "Changing listview count to %u\n", cRecsDisplayed);

    HRESULT hr = _pResult->SetItemCount(cRecsDisplayed, MMCLV_UPDATE_NOSCROLL);
    CHECK_HRESULT(hr);

    if (cRecsDisplayed)
    {
        //
        // The SetItemCount call causes the listview to deselect the
        // current selection, so at this point _ulCurSelectedRecNo and
        // _ulCurSelectedIndex are inaccurate.  What's more, the
        // listview is now displaying the items at the top of the list.
        //
        // So the user may have just done a PageDown or End to get to
        // the last of the displayed records, and suddenly the listview
        // has repositioned itself at the first.
        //
        // Set the selection to be as close to the previously selected
        // index as possible.
        //

        if (_ulCurSelectedIndex >= cRecsDisplayed)
        {
            _ulCurSelectedIndex = cRecsDisplayed - 1;//index is 0 based

            //
            // Note this next assignment isn't really necessary as the
            // ModifyItemState will cause a MMCN_SELECT notification
            // which we will handle by updating _ulCurSelectedRecNo,
            // but it seems better to have a smaller window of
            // _ulCurSelectedRecNo having an incorrect value.
            //

            _ulCurSelectedRecNo =
                _ResultRecs.IndexToRecNo(_ulCurSelectedIndex);
            Dbg(DEB_TRACE,
                "_ulCurSelectedRecNo = %u\n",
                _ulCurSelectedRecNo);
        }

        Dbg(DEB_TRACE,
            "setting listview selection to %u\n",
            _ulCurSelectedIndex);

        hr = _pResult->ModifyItemState(_ulCurSelectedIndex,
                                       0,
                                       LVIS_FOCUSED | LVIS_SELECTED,
                                       0);
        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            Dbg(DEB_TRACE, "_ulCurSelectedRecNo = %u\n", _ulCurSelectedRecNo);
            _ulCurSelectedRecNo = 0;
            _ulCurSelectedIndex = 0;
        }
    }
    _ClearFlag(SNAPIN_RESET_PENDING);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::HandleLogDeletion
//
//  Synopsis:   Free any data associated with the loginfo being deleted.
//
//  Arguments:  [pliBeingDeleted] - log info that will be deleted (still a
//                                    valid object at this point).
//
//  History:    3-21-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSnapin::HandleLogDeletion(
    CLogInfo *pliBeingDeleted)
{
    TRACE_METHOD(CSnapin, HandleLogDeletion);

    CFindInfo *pfi = _LookupFindInfo(pliBeingDeleted);

    if (!pfi)
    {
        return;
    }

    //
    // If we've got a find dialog open on this log, close it.
    //

    pfi->Shutdown();

    //
    // Delete the find info
    //

    if (pfi == _pFindInfoList)
    {
        _pFindInfoList = pfi->Next();
    }

    pfi->UnLink();
    delete pfi;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::_InitializeHeader
//
//  Synopsis:   Create the columns in the result view header control
//              required for displaying object represented by [pli].
//
//  Arguments:  [fRootNode] - TRUE to init header columns for "Event Logs"
//                              folder, FALSE to init for log records.
//
//  Returns:    HRESULT
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSnapin::_InitializeHeader(
    BOOL fRootNode)
{
    TRACE_METHOD(CSnapin, _InitializeHeader);

    HRESULT hr = S_OK;
    ULONG   i;

    if (fRootNode)
    {
        // do headers for log folders

        for (i = 0; i < NUM_FOLDER_COLS && SUCCEEDED(hr); i++)
        {
            hr = _InsertHeaderColumn(i,
                                     IDS_FIRST_FOLDER_HDR + i,
                                     _aiFolderColWidth[i]);
        }
    }
    else
    {
        // do headers for log records

        for (i = 0; i < NUM_RECORD_COLS && SUCCEEDED(hr); i++)
        {
            hr = _InsertHeaderColumn(i,
                                     i + IDS_FIRST_RECORD_HDR,
                                     _aiRecordColWidth[i]);
        }
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::InsertHeaderColumn
//
//  Synopsis:   Helper function to load a string and insert it into the
//              header control.
//
//  Arguments:  [ulCol]    - 0 based index of col to insert
//              [idString] - resource id of string to insert
//              [iWidth]   - column width
//
//  Returns:    HRESULT
//
//  History:    12-06-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSnapin::_InsertHeaderColumn(
    ULONG ulCol,
    ULONG idString,
    INT iWidth)
{
    HRESULT hr;
    ULONG   cch;
    WCHAR   wszBuf[MAX_HEADER_STR];

    cch = LoadStringW(g_hinst, idString, wszBuf, ARRAYLEN(wszBuf));

    if (!cch)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBG_OUT_LASTERROR;
        return hr;
    }

    hr = _pHeader->InsertColumn(ulCol, wszBuf, LVCFMT_LEFT, iWidth);
    CHECK_HRESULT(hr);

    return hr;
}




//============================================================================
//
// IPersist implementation
//
//============================================================================


//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::GetClassID
//
//  Synopsis:   Return this object's class ID.
//
//  History:    4-09-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CSnapin::GetClassID(
    CLSID *pClassID)
{
    *pClassID = CLSID_EventLogSnapin;
    return S_OK;
}



//============================================================================
//
// IPersistStream implementation
//
//============================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::Load
//
//  Synopsis:   Initialize this from stream [pStm].
//
//  Arguments:  [pStm] - stream from which to read.
//
//  Returns:    HRESULT
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CSnapin::Load(
    IStream *pStm)
{
    Dbg(DEB_STORAGE, "CSnapin::Load (%x)\n", this);

    HRESULT hr = S_OK;

    do
    {
        // count of folder columns

        USHORT cCols;

        hr = pStm->Read(&cCols, sizeof USHORT, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(cCols == NUM_FOLDER_COLS);

        // folder column width array

        hr = pStm->Read(_aiFolderColWidth, sizeof _aiFolderColWidth, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

#if (DBG == 1)
        USHORT i;
        for (i = 0; i < cCols; i++)
        {
            Dbg(DEB_TRACE, "Snapin(%x) loaded folder col %u width = %u\n", this, i, _aiFolderColWidth[i]);
        }
#endif
        // count of record columns

        hr = pStm->Read(&cCols, sizeof USHORT, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(cCols == NUM_RECORD_COLS);

        // record column width array

        hr = pStm->Read(_aiRecordColWidth, sizeof _aiRecordColWidth, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

#if (DBG == 1)
        for (i = 0; i < cCols; i++)
        {
            Dbg(DEB_TRACE, "Snapin(%x) loaded record col %u width = %u\n", this, i, _aiRecordColWidth[i]);
        }
#endif
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::Save
//
//  Synopsis:   Persist this object to [pStm].
//
//  Arguments:  [pStm]        - stream to write to
//              [fClearDirty] - if TRUE, internal dirty flag cleared on
//                                successful write.
//
//  Returns:    HRESULT
//
//  History:    1-20-1997   DavidMun   Created
//
//  Notes:      CAUTION: if you change the amount of data written by this
//              routine, remember to update GetSizeMax.
//
//---------------------------------------------------------------------------

STDMETHODIMP
CSnapin::Save(
    IStream *pStm,
    BOOL fClearDirty)
{
    Dbg(DEB_STORAGE, "CSnapin::Save(%x)\n", this);

    HRESULT hr = S_OK;

    //
    // If some other part of the console was dirtied, the console won't
    // call CSnapin::IsDirty, so we can't be sure that the column widths
    // have been read.  Grab them now.
    //

    _UpdateColumnWidths(!_pCurScopePaneSelection);

    //
    // Stream contents:
    //
    // NUM_FOLDER_COLS (USHORT)
    // folder view column widths (NUM_FOLDER_COLS ULONGs)
    // NUM_RECORD_COLS (USHORT)
    // record view column widths (NUM_RECORD_COLS ULONGs)
    //

    do
    {
        // count of folder columns

        USHORT cCols = NUM_FOLDER_COLS;

        hr = pStm->Write(&cCols, sizeof USHORT, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        // folder column width array

        hr = pStm->Write(_aiFolderColWidth, sizeof _aiFolderColWidth, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

#if (DBG == 1)
        USHORT i;
        for (i = 0; i < cCols; i++)
        {
            Dbg(DEB_TRACE, "Snapin(%x) saved folder col %u width = %u\n", this, i, _aiFolderColWidth[i]);
        }
#endif
        // count of record columns

        cCols = NUM_RECORD_COLS;

        hr = pStm->Write(&cCols, sizeof USHORT, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        // record column width array

        hr = pStm->Write(_aiRecordColWidth, sizeof _aiRecordColWidth, NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        if (fClearDirty)
        {
            _ClearFlag(SNAPIN_DIRTY);
        }

#if (DBG == 1)
        for (i = 0; i < cCols; i++)
        {
            Dbg(DEB_TRACE, "Snapin(%x) saved record col %u width = %u\n", this, i, _aiRecordColWidth[i]);
        }
#endif
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::GetSizeMax
//
//  Synopsis:   Write the size, in bytes, needed to save this object into
//              *[pcbSize].
//
//  History:    12-11-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CSnapin::GetSizeMax(
    ULARGE_INTEGER *pcbSize)
{
    TRACE_METHOD(CSnapin, GetSizeMax);

    pcbSize->QuadPart = (ULONGLONG) sizeof(USHORT)               +
                                    sizeof(_aiFolderColWidth)    +
                                    sizeof(USHORT)               +
                                    sizeof(_aiRecordColWidth);
    return S_OK;
}


#ifdef ELS_TASKPAD
//============================================================================
//
// INodeProperties implementation
// JonN 5/15/00 98816
//
//============================================================================

STDMETHODIMP
CSnapin::GetProperty( 
    LPDATAOBJECT pDataObject,
    BSTR szPropertyName,
    BSTR* pbstrProperty)
{
    TRACE_METHOD(CSnapin, GetProperty);
    if (   IsBadReadPtr(pDataObject,sizeof(*pDataObject))
        || IsBadStringPtr(szPropertyName,0x7FFFFFFF)
        || IsBadWritePtr(pbstrProperty,sizeof(*pbstrProperty))
       )
    {
        Dbg(DEB_ERROR,
            "CSnapin::GetProperty: bad parameters from MMC\n");
        return E_POINTER;
    }

    if (_wcsicmp(L"CCF_DESCRIPTION",szPropertyName))
        return S_FALSE;

    HGLOBAL hGlobal = NULL;
    HRESULT hr = ExtractFromDataObject(
                               pDataObject,
                               CDataObject::s_cfExportResultRecNo,
                               sizeof(MMC_COOKIE),
                               &hGlobal);
    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    MMC_COOKIE ulRecNo = *((MMC_COOKIE*)hGlobal);
    VERIFY(!GlobalFree(hGlobal));

    // cribbed from old CSnapin::_CopyEventLogRecord()
    EVENTLOGRECORD *pelr = _ResultRecs.CopyRecord(ulRecNo);
    if (NULL == pelr) // not in cache
    {
        CEventLog Log;

        ASSERT(_pCurScopePaneSelection);

        // dtor will close log

        hr = Log.Open(_pCurScopePaneSelection);
        if (FAILED(hr))
        {
            Dbg(DEB_ERROR,
                "CSnapin::GetProperty: _CopyEventLogRecord() failed\n");
            return hr;
        }

        pelr = Log.CopyRecord(ulRecNo);
    }
    if (NULL == pelr)
    {
        Dbg(DEB_ERROR,
            "CSnapin::GetProperty: _CopyEventLogRecord() failed\n");
        return E_OUTOFMEMORY;
    }
    LPWSTR pwszDescription = GetDescriptionStr(_pCurScopePaneSelection,pelr,NULL);
    delete [] (BYTE *) pelr;
    if (NULL == pwszDescription)
    {
        Dbg(DEB_ERROR,
            "CSnapin::GetProperty: GetDescriptionStr() failed\n");
        return E_OUTOFMEMORY;
    }

    *pbstrProperty = ::SysAllocString(pwszDescription);

    ::LocalFree(pwszDescription);
    return hr;
}
#endif // ELS_TASKPAD


//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::_OnDoubleClick
//
//  Synopsis:   Handle a notification of a double click on a result item
//
//  Arguments:  [ulRecNo]     - currently selected event record
//              [pDataObject] - data object for same
//
//  Returns:    HRESULT
//
//  History:    4-25-1997   DavidMun   Created
//
//  Notes:      Does nothing if [pDataObject] wasn't created by event viewer
//              or if the item just double-clicked on is a log.
//
//---------------------------------------------------------------------------

HRESULT
CSnapin::_OnDoubleClick(
    ULONG ulRecNo,
    LPDATAOBJECT pDataObject)
{
    TRACE_METHOD(CSnapin, _OnDoubleClick);

    HRESULT hr = S_OK;

    do
    {
        CDataObject *pdo = ExtractOwnDataObject(pDataObject);

        // ignore foreign data objects

        if (!pdo)
        {
            break;
        }

        //
        // ignore double clicks on scope pane items displayed in the
        // result pane.
        //

        if (pdo->GetCookieType() != COOKIE_IS_RECNO)
        {
            //
            // The current scope pane selection is the static/parent
            // node, then the user is double clicking on an event log folder
            // in the result pane.  Returning S_FALSE will allow MMC to
            // expand it for us.
            //

            ASSERT(!_pCurScopePaneSelection);
            hr = S_FALSE;
            break;
        }

        //
        // The current scope pane selection is a log folder, then we should
        // have already received a click notification, so ulRecNo should
        // already be set.
        //

        if (_ulCurSelectedRecNo != ulRecNo)
        {
            Dbg(DEB_ERROR, "*** _ulCurSelectedRecNo != ulRecNo\n");
        }
        _ulCurSelectedRecNo = ulRecNo;

        //
        // If the inspector is already open it should already be looking
        // at this record, so just make it the foreground window.
        //

        if (_InspectorInfo.InspectorInvoked())
        {
            _InspectorInfo.BringToForeground();
            break;
        }

        //
        // No inspector open; create one.
        //

        hr = _InvokePropertySheet(ulRecNo, pDataObject);
    } while (0);
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::_OnSelect
//
//  Synopsis:   Handle an MMCN_SELECT notification
//
//  Arguments:  [fScopePane] - TRUE if item selected is in scope pane
//              [fSelected]  - TRUE if item selected, FALSE if deselected
//              [pdo]        - data object selected
//
//  Returns:    S_OK
//
//  History:    2-12-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSnapin::_OnSelect(
    BOOL            fScopePane,
    BOOL            fSelected,
    CDataObject    *pdo)
{
    TRACE_METHOD(CSnapin, _OnSelect);

    HRESULT hr  = S_OK;

    do
    {
        //
        // Don't care about de-select notifications
        //

        if (!fSelected)
        {
            break;
        }

        //
        // Bail if we couldn't get the console verb interface, or if the
        // selected item is the root of the event viewer.
        //

        if (!_pConsoleVerb || pdo->GetCookieType() == COOKIE_IS_ROOT)
        {
            break;
        }

        //
        // Use selections of log infos to indicate which verbs are allowed
        //

        if (fScopePane || pdo->GetCookieType() == COOKIE_IS_LOGINFO)
        {
            CLogInfo *pli = (CLogInfo *)pdo->GetCookie();

            if (pli->GetAllowDelete())
            {
                hr = _pConsoleVerb->SetVerbState(MMC_VERB_DELETE,
                                                 ENABLED,
                                                 TRUE);
                CHECK_HRESULT(hr);
            }

            //
            // JonN 4/26/01 377513
            // corrupted eventlogs do not have
            //   "clear" and "properties" in popup menu
            //
            // Enable the Properties verb for logs which are
            // disabled but not backup logs, including corrupt
            // live logs
            //
            if (pli->IsEnabled() || !pli->IsBackupLog())
            {
                hr = _pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES,
                                                 ENABLED,
                                                 TRUE);
                CHECK_HRESULT(hr);
            }

            hr = _pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
            CHECK_HRESULT(hr);

            hr = _pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);
            CHECK_HRESULT(hr);

            //
            // Set default verb to open the folder
            //

            hr = _pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
            CHECK_HRESULT(hr);
            break;
        }

        //
        // Selection is in the result pane and is of a record.  Enable the
        // properties verb, and make it the default.  MMC will execute the
        // default verb when the user hits Enter, causing the property sheet
        // to open.
        //

        hr = _pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
        CHECK_HRESULT(hr);

        hr = _pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);
        CHECK_HRESULT(hr);

        hr = _pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
        CHECK_HRESULT(hr);

        _ulCurSelectedRecNo = (ULONG)pdo->GetCookie();
        _ulCurSelectedIndex = _GetCurSelRecIndex();

        Dbg(DEB_TRACE,
            "Currently selected record is now %u, listview index is %u\n",
            _ulCurSelectedRecNo,
            _ulCurSelectedIndex);

        if (_InspectorInfo.InspectorInvoked())
        {
            _InspectorInfo.UpdateCurResultRec(
                _ResultRecs.CopyRecord(_ulCurSelectedRecNo),
                FALSE);
        }

    } while (0);

    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::_OnShow
//
//  Synopsis:   Process console notification that an item is being shown
//              or not-shown.
//
//  Arguments:  [pdo]       - item affected
//              [fShow]     - TRUE - being shown, FALSE - being hidden
//              [hsiParent] - handle to event log's static node
//
//  Returns:    HRESULT
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSnapin::_OnShow(
    CDataObject *pdo,
    BOOL fShow,
    HSCOPEITEM hsiParent)
{
    TRACE_METHOD(CSnapin, _OnShow);

    HRESULT hr = S_OK;
    BOOL    fRootNode = (pdo->GetCookieType() == COOKIE_IS_ROOT);

    do
    {
        //
        // The sort order is reset whenever the snapin is shown or hidden
        //
        _SortOrder = NEWEST_FIRST;

        if (!fShow)
        {
            Dbg(DEB_TRACE,
                "CSnapin::_OnShow(%x) Hiding %s\n",
                this,
                _pCurScopePaneSelection ?
                    _pCurScopePaneSelection->GetDisplayName() :
                    L"Root");

            //
            // Some other folder has been selected.  If we're a standalone
            // snapin, then we should quickly recieve a show TRUE, and set
            // the current scope pane selection to that folder.
            //
            // However, if we're an extension snapin, it may be that the
            // user has clicked on some folder other than one of ours, so
            // we won't have a valid scope pane selection.
            //

            _pCurScopePaneSelection = NULL;

            //
            // If there's a copy of the item that was selected in the result
            // pane which is going away, then that implies there's an
            // inspector open and displaying it.  Free the copy and notify the
            // inspector to update itself to show "no data".
            //

            _InspectorInfo.UpdateCurResultRec(NULL, FALSE);

            //
            // If there's a find dialog open on this log, tell it to disable
            // its find next pushbutton.
            //

            if (!fRootNode)
            {
                CLogInfo *pli = (CLogInfo *) pdo->GetCookie();
                ASSERT(_pcd->IsValidLogInfo(pli));
                CFindInfo *pfi = _LookupFindInfo(pli);

                if (pfi && pfi->GetDlgWindow())
                {
                    SendMessage(pfi->GetDlgWindow(),
                                WM_COMMAND,
                                ELS_ENABLE_FIND_NEXT,
                                FALSE);
                }
            }

            //
            // Free result pane data for this cookie, the view is going away
            // (user clicked on something else).
            //

            _ResultRecs.Close();

            //
            // Save the column widths so they are sticky
            //

            _UpdateColumnWidths(fRootNode);

            //
            // Clear the description bar text
            //

            _pResult->SetDescBarText(L"");
            break;
        }

        //
        // fShow is true--we must populate result pane.
        //

        CWaitCursor Hourglass;

        //
        // show items for this LogInfo.  First set up the header control.
        //

        hr = _InitializeHeader(fRootNode);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // See if we are showing the root node, there's no display work for
        // us, other than insuring the listview is in report mode, but we
        // need to note that the current selection is the static folder.
        //

        if (fRootNode)
        {
            _pCurScopePaneSelection = NULL;
            Dbg(DEB_TRACE, "CSnapin::_OnShow(%x) Showing root\n", this);
            _ForceReportMode();
            break;
        }

        //
        // Remember which folder is selected.  The listview callback method
        // needs to know this so it can interpret the lParam in the
        // RESULTDATAITEM it gets.
        //

        _pCurScopePaneSelection = (CLogInfo *) pdo->GetCookie();
        ASSERT(pdo->GetCookieType() == COOKIE_IS_LOGINFO);
        ASSERT(_pcd->IsValidLogInfo(_pCurScopePaneSelection));

        Dbg(DEB_TRACE,
            "CSnapin::_OnShow(%x) Showing %s\n",
            this,
            _pCurScopePaneSelection->GetDisplayName());

        //
        // Don't try to read the log if it is disabled, since it has already
        // been determined that it's nonexistant, corrupt, or denies access.
        //

        if (!_pCurScopePaneSelection->IsEnabled())
        {
            _UpdateDescriptionText(_pCurScopePaneSelection);
            break;
        }

        //
        // Make sure find next button is enabled
        //

        if (!fRootNode)
        {
            CFindInfo *pfi = _LookupFindInfo(_pCurScopePaneSelection);

            if (pfi && pfi->GetDlgWindow())
            {
                SendMessage(pfi->GetDlgWindow(),
                            WM_COMMAND,
                            ELS_ENABLE_FIND_NEXT,
                            TRUE);
            }
        }

        //
        // Data object represents a log folder.  Fill the result pane with
        // its records.
        //
        // Note we are assuming that we'll never get two notify show open
        // calls in a row.
        //

        // _SortOrder == NEWEST_FIRST, set at top of block

        // JonN 7/16/01 437696
        // AV when open event properties and retargeting to another computer
        // We actually need to deal with the case where we get two notify
        // show open in a row.
        _ResultRecs.Close();

        hr = _ResultRecs.Open(_pCurScopePaneSelection, BACKWARD);

        if (hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED) ||
            hr == HRESULT_FROM_WIN32(ERROR_PRIVILEGE_NOT_HELD) ||
            hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) ||
            hr == HRESULT_FROM_WIN32(ERROR_EVENTLOG_FILE_CORRUPT))
        {
            _pCurScopePaneSelection->Enable(FALSE);
            if (hr != HRESULT_FROM_WIN32(ERROR_EVENTLOG_FILE_CORRUPT))
            {
                _pCurScopePaneSelection->SetReadOnly(TRUE);
            }
            PostScopeBitmapUpdate(_pcd, _pCurScopePaneSelection);
        }

        if (FAILED(hr))
        {
            _UpdateDescriptionText(_pCurScopePaneSelection);
            DisplayLogAccessError(hr, _pConsole, _pCurScopePaneSelection);

            //
            // JonN 4/16/01 285001
            // Event Viewer: Delete not available in context menu
            // when Saved <log type> Log is first added.
            //
            // Per AudriusZ, there is no point in returning this error code
            // to MMC.
            //
            hr = S_OK;
            
            break;
        }

        CLogInfo *pli = (CLogInfo *) pdo->GetCookie();
        ASSERT(_pcd->IsValidLogInfo(pli));
        _PopulateResultPane(pli);
        _UpdateDescriptionText(_pCurScopePaneSelection);

        // make sure this is called *after* the result pane is populated,
        // or MMC will croak.
        _ForceReportMode();
    } while (0);


    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::_ForceReportMode
//
//  Synopsis:   Force the listview into report mode.
//
//  History:    06-11-1997   DavidMun   Created
//
//  Notes:      Ensure listview's in report mode.  Even though we disallow
//              the listview mode choices in the view menu when we're
//              selected, the current style may have been set by some other
//              snapin the user just left.
//
//---------------------------------------------------------------------------

VOID
CSnapin::_ForceReportMode()
{
    TRACE_METHOD(CSnapin, _ForceReportMode);
    HRESULT hr;

    hr = _pConsole->SetHeader(_pHeader);
    CHECK_HRESULT(hr);

    hr = _pResult->SetViewMode(MMCLV_VIEWSTYLE_REPORT);
    CHECK_HRESULT(hr); // will still work in other modes

    hr = _pResult->ModifyViewStyle((MMC_RESULT_VIEW_STYLE) 0, MMC_NOSORTHEADER);
    CHECK_HRESULT(hr); // will still work in other styles

    hr = _pResult->ModifyViewStyle(MMC_SHOWSELALWAYS, (MMC_RESULT_VIEW_STYLE) 0);
    CHECK_HRESULT(hr);

    hr = _pResult->ModifyViewStyle(MMC_SINGLESEL, (MMC_RESULT_VIEW_STYLE) 0);
    CHECK_HRESULT(hr);

    hr = _pResult->ModifyViewStyle(MMC_ENSUREFOCUSVISIBLE, (MMC_RESULT_VIEW_STYLE) 0);
    CHECK_HRESULT(hr);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::_InitializeResultBitmaps
//
//  Synopsis:   Load the bitmaps and init the imagelists used in displaying
//              result items.
//
//  Returns:    HRESULT
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSnapin::_InitializeResultBitmaps()
{
    TRACE_METHOD(CSnapin, _InitializeResultBitmaps);

    HRESULT hr = S_OK;

    HBITMAP hbmp16x16 = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_16x16));

    if (!hbmp16x16)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBG_OUT_LASTERROR;
        return hr;
    }

    HBITMAP hbmp32x32 = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDB_32x32));

    if (!hbmp32x32)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        DBG_OUT_LASTERROR;
        VERIFY(DeleteObject(hbmp16x16));
        return hr;
    }

    // CODEWORK This sometimes fails with 0x8000ffff as an extension
    hr = _pResultImage->ImageListSetStrip((LONG_PTR *)hbmp16x16,
                                          (LONG_PTR *)hbmp32x32,
                                          IDX_RDI_BMP_FIRST,
                                          BITMAP_MASK_COLOR);
    VERIFY(DeleteObject(hbmp16x16)); // JonN 11/29/00 243763
    VERIFY(DeleteObject(hbmp32x32)); // JonN 11/29/00 243763
    CHECK_HRESULT(hr);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::_InvokePropertySheet
//
//  Synopsis:   Open or bring to foreground an event record details
//              property sheet focused on record [ulRecNo].
//
//  Arguments:  [ulRecNo]     - number of rec to display in prop sheet
//              [pDataObject] - data object containing rec [ulRecNo]
//
//  Returns:    HRESULT
//
//  History:    4-04-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSnapin::_InvokePropertySheet(
    ULONG ulRecNo,
    LPDATAOBJECT pDataObject)
{
    TRACE_METHOD(CSnapin, _InvokePropertySheet);

    WCHAR wszDetailsCaption[MAX_PATH];

    LoadStr(IDS_DETAILS_CAPTION,
            wszDetailsCaption,
            ARRAYLEN(wszDetailsCaption));

    return InvokePropertySheet(_pcd->GetPropSheetProvider(),
                               wszDetailsCaption,
                               (LONG) ulRecNo,
                               pDataObject,
                               (IExtendPropertySheet*) this,
                               0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::_LookupFindInfo
//
//  Synopsis:   Search the llist for the find info for [pli].
//
//  Arguments:  [pli] - loginfo associated with desired findinfo.
//
//  Returns:    CFindInfo object associated with [pli] or NULL.
//
//  History:    3-21-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CFindInfo *
CSnapin::_LookupFindInfo(
    CLogInfo *pli)
{
    TRACE_METHOD(CSnapin, _LookupFindInfo);

    CFindInfo *pCur;

    for (pCur = _pFindInfoList; pCur; pCur = pCur->Next())
    {
        if (pCur->GetLogInfo() == pli)
        {
            return pCur;
        }
    }
    return NULL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::IsDirty
//
//  Synopsis:   Return S_OK if this object is dirty, S_FALSE otherwise.
//
//  History:    4-09-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CSnapin::IsDirty()
{
    TRACE_METHOD(CSnapin, IsDirty);

    _UpdateColumnWidths(!_pCurScopePaneSelection);
    return _IsFlagSet(SNAPIN_DIRTY) ? S_OK : S_FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::_PopulateResultPane
//
//  Synopsis:   Build the record list and size the result listview according
//              to the number of records to appear.
//
//  Arguments:  [pli] - log from which to populate result pane
//
//  Returns:    HRESULT
//
//  History:    07-03-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSnapin::_PopulateResultPane(
    CLogInfo *pli)
{
    HRESULT hr = S_OK;
    ASSERT(_SortOrder == NEWEST_FIRST || _SortOrder == OLDEST_FIRST);
    _ulCurSelectedRecNo = 0;
    _ulCurSelectedIndex = 0;

    if (_IsFlagSet(SNAPIN_RESET_PENDING))
    {
        Dbg(DEB_TRACE, "_PopulateResultPane: _ulCurSelectedRecNo -> 0\n");
        return S_OK;
    }

    hr = _ResultRecs.Populate(_SortOrder,
                              &_ulCurSelectedRecNo);
    Dbg(DEB_TRACE, "_PopulateResultPane: _ulCurSelectedRecNo = %u\n", _ulCurSelectedRecNo);

    if (SUCCEEDED(hr))
    {
        hr = _pResult->SetItemCount(_ResultRecs.GetCountOfRecsDisplayed(), 0);
        CHECK_HRESULT(hr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::_UpdateColumnWidths
//
//  Synopsis:   Save the width of the header columns.
//
//  Arguments:  [fRootNode] - if TRUE, assume header is showing folder
//                              columns, else assume record columns.
//
//  History:    4-23-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSnapin::_UpdateColumnWidths(BOOL fRootNode)
{
    INT  iCol;
    INT *piCol;
    INT  iLimit;

    if (fRootNode)
    {
        iLimit = NUM_FOLDER_COLS;
        piCol = _aiFolderColWidth;
    }
    else
    {
        iLimit = NUM_RECORD_COLS;
        piCol = _aiRecordColWidth;
    }

    for (iCol = 0; iCol < iLimit; iCol++, piCol++)
    {
        HRESULT hr;
        INT iNewWidth;

        hr = _pHeader->GetColumnWidth(iCol, &iNewWidth);

        if (FAILED(hr))
        {
            Dbg(DEB_ERROR,
                "GetColumnWidth(%u, 0x%x) hr=%x\n",
                iCol,
                &iNewWidth,
                hr);
        }
        else if (iNewWidth != *piCol)
        {
            Dirty();
            *piCol = iNewWidth;
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::_UpdateDescriptionText
//
//  Synopsis:   Set the text in the console description bar to indicate
//              how many records are being displayed and are in the log.
//
//  Arguments:  [pli] - log whose records are being displayed
//
//  History:    4-11-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSnapin::_UpdateDescriptionText(
    CLogInfo *pli)
{
    // TRACE_METHOD(CSnapin, _UpdateDescriptionText);

    wstring wstrDesc;
    WCHAR wszRecListCount[14]; // L"4,294,967,295"

#if (DBG == 1)
    UINT cch =
#endif // (DBG == 1)
        FormatNumber(_ResultRecs.GetCountOfRecsDisplayed(),
                         wszRecListCount,
                         ARRAYLEN(wszRecListCount));
    ASSERT(!cch);

    if (!pli->IsEnabled())
    {
        ASSERT(!_ResultRecs.GetCountOfRecsDisplayed());

        wstrDesc = FormatString(IDS_DESCBAR_DISABLED);
    }
    else if (pli->IsFiltered())
    {
        WCHAR wszLogCount[14];
#if (DBG == 1)
        cch =
#endif // (DBG == 1)
            FormatNumber(_ResultRecs.GetCountOfRecsInLog(),
                             wszLogCount,
                             ARRAYLEN(wszLogCount));
        ASSERT(!cch);

        wstrDesc = FormatString(IDS_DESCBAR_FILTERED, 
                               wszRecListCount,
                               wszLogCount);			
    }
    else
    {
        wstrDesc = FormatString(IDS_DESCBAR_NORMAL, wszRecListCount);
    }

#if (DBG == 1)
    HRESULT hr =
#endif // (DBG == 1)
        _pResult->SetDescBarText((LPOLESTR)(wstrDesc.c_str()));
    
    CHECK_HRESULT(hr);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::ResetPending
//
//  Synopsis:   Turn on the reset pending flag iff [pliAffectedLog]
//              describes the same log as _pCurScopePaneSelection.
//
//  Arguments:  [pliAffectedLog] - log that will be reset
//
//  History:    2-19-1997   DavidMun   Created
//
//  Notes:      Since this is only called with a CLogInfo * owned by
//              _pcd, it would be sufficient to compare the
//              _pCurScopePaneSelection and pliAffectedLog pointers
//              directly; however calling IsSameLog is safer in case a
//              future change causes this method to be called with a
//              CLogInfo * belonging to some CComponentData other than
//              _pcd.
//
//---------------------------------------------------------------------------

VOID
CSnapin::ResetPending(
    CLogInfo *pliAffectedLog)
{
    TRACE_METHOD(CSnapin, ResetPending);

    if (_pCurScopePaneSelection &&
        _pCurScopePaneSelection->IsSameLog(pliAffectedLog))
    {
        _SetFlag(SNAPIN_RESET_PENDING);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSnapin::SetDisplayOrder
//
//  Synopsis:   Handle a view newest/oldest command forwarded by the
//              component data.
//
//  Arguments:  [Order] - NEWEST_FIRST or OLDEST_FIRST
//
//  Returns:    Result of IResultData::Sort
//
//  History:    3-10-1997   DavidMun   Created
//
//  Notes:      This routine is necessary because the component data
//              receives the view newest/oldest command from the user, since
//              the UI spec is for that command to be on the context menu
//              of the folder (the scope item).  But it actually applies to
//              the snapin which has the input focus.  The snapins handle
//              the MMCN_ACTIVATE message to keep the console informed of
//              which of them has the focus, so it knows which to forward
//              the view order command to.
//
//---------------------------------------------------------------------------

HRESULT
CSnapin::SetDisplayOrder(
    SORT_ORDER Order)
{
    TRACE_METHOD(CSnapin, SetDisplayOrder);

    if (Order == _SortOrder) // already in requested order.
    {
        return S_FALSE;
    }

    //
    // Note Sort is a no-op if the result view has < 2 records.
    //

    if (Order == NEWEST_FIRST)
    {
        return _pResult->Sort(0,
                              RSI_DESCENDING | RSI_NOSORTICON,
                              SNAPIN_SORT_OVERRIDE_NEWEST);
    }

    ASSERT(Order == OLDEST_FIRST);

    return _pResult->Sort(0, RSI_NOSORTICON, SNAPIN_SORT_OVERRIDE_OLDEST);
}



#if (DBG == 1)
VOID
CSnapin::DumpCurRecord()
{
    _ResultRecs.DumpRecord(_ulCurSelectedRecNo);
}


#endif (DBG == 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\syncwnd.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       syncwnd.cxx
//
//  Contents:   Class to call component data objects when a message
//              posted to a hidden window is dispatched by MMC's
//              message pump.
//
//  Classes:    CSynchWindow
//
//  History:    2-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


#define SYNCHWNDCLASS        L"Event Viewer Snapin Synch"
#define CCDMAX_START         5


//+--------------------------------------------------------------------------
//
//  Member:     CSynchWindow::CSynchWindow
//
//  Synopsis:   ctor
//
//  History:    2-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CSynchWindow::CSynchWindow():
        _hwnd(NULL),
        _apcd(NULL),
        _ccd(0),
        _ccdMax(0)
{
    TRACE_CONSTRUCTOR(CSynchWindow);
}




//+--------------------------------------------------------------------------
//
//  Member:     CSynchWindow::~CSynchWindow
//
//  Synopsis:   dtor
//
//  History:    2-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CSynchWindow::~CSynchWindow()
{
    TRACE_DESTRUCTOR(CSynchWindow);

    if (_hwnd)
    {
        DestroySynchWindow();
    }
    delete [] _apcd;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSynchWindow::CreateSynchWindow
//
//  Synopsis:   Register the sync window class and create an instance.
//
//  Returns:    S_OK - class registered, window created
//              E_*  - class not registered, window not created
//
//  History:    2-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSynchWindow::CreateSynchWindow()
{
    TRACE_METHOD(CSynchWindow, CreateSynchWindow);
    ASSERT(!_hwnd);

    HRESULT hr = S_OK;
    WNDCLASS wc;

    ZeroMemory(&wc, sizeof wc);

    wc.lpfnWndProc   = _WndProc;
    wc.hInstance     = g_hinst;
    wc.lpszClassName = SYNCHWNDCLASS;

    ATOM aClass = RegisterClass(&wc);

    if (!aClass && GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
    {
        DBG_OUT_LASTERROR;
    }

    _hwnd = CreateWindowEx(0,
                           SYNCHWNDCLASS,
                           L"",
                           0,
                           0,
                           0,
                           0,
                           0,
                           HWND_MESSAGE,
                           NULL,
                           g_hinst,
                           (LPVOID) this);

    if (_hwnd)
    {
        ASSERT(IsWindow(_hwnd));
    }
    else
    {
        hr = HRESULT_FROM_LASTERROR;
        DBG_OUT_LASTERROR;
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSynchWindow::DestroySynchWindow
//
//  Synopsis:   Destroy the hidden window.
//
//  History:    2-18-1997   DavidMun   Created
//
//  Notes:      Class automatically unregistered when app terminates.
//
//---------------------------------------------------------------------------

VOID
CSynchWindow::DestroySynchWindow()
{
    TRACE_METHOD(CSynchWindow, DestroySynchWindow);
    ASSERT(_hwnd);
    ASSERT(IsWindow(_hwnd));

    BOOL fOk;

    fOk = DestroyWindow(_hwnd);
    _hwnd = NULL;

    if (!fOk)
    {
        DBG_OUT_LASTERROR;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSynchWindow::_NotifyComponentDatasLogChanged
//
//  Synopsis:   Call all registered component datas with [lParam]
//
//  Arguments:  [wParam] - caller-defined value
//              [lParam] - caller-defined value
//
//  History:    2-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSynchWindow::_NotifyComponentDatasLogChanged(
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CSynchWindow, _NotifyComponentDatasLogChanged);

    ULONG i;
    BOOL  fNotifyUser = TRUE;
    BOOL  fNotifiedUser = FALSE;

    for (i = 0; i < _ccdMax; i++)
    {
        if (_apcd[i])
        {
            fNotifiedUser = _apcd[i]->NotifySnapinsLogChanged(wParam,
                                                              lParam,
                                                              fNotifyUser);

            if (fNotifiedUser)
            {
                fNotifyUser = FALSE;
            }
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSynchWindow::Post
//
//  Synopsis:   Post specified message to hidden window.
//
//  Arguments:  [msg]    - message to post
//              [wParam] - caller-defined value
//              [lParam] - caller-defined value
//
//  Returns:    S_OK   - message posted
//              E_FAIL - window was never created
//              E_*    - PostMessage failed
//
//  History:    2-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSynchWindow::Post(
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CSynchWindow, Post);
    HRESULT hr = S_OK;

    //
    // If nothing has been registered then posting the message would be a
    // waste of time.
    //

    if (!_ccd)
    {
        return hr;
    }

    //
    // Post the message
    //

    if (_hwnd && SUCCEEDED(hr))
    {
        ASSERT(IsWindow(_hwnd));
        BOOL fOk = PostMessage(_hwnd, msg, wParam, lParam);

        if (!fOk)
        {
            hr = HRESULT_FROM_LASTERROR;
            DBG_OUT_LASTERROR;
        }
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSynchWindow::Register
//
//  Synopsis:   Add [pcd] to the list of component datas to receive
//              notification when a message is dispatched to our wndproc.
//
//  Arguments:  [pcd] - componentdata to add
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//  History:    2-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSynchWindow::Register(
    CComponentData *pcd)
{
    TRACE_METHOD(CSynchWindow, Register);
    HRESULT hr = S_OK;

    do
    {
        //
        // If no array is allocated, create one with the default
        // number of slots.
        //

        if (!_ccdMax)
        {
            ASSERT(!_apcd);
            ASSERT(!_ccd);

            _apcd = new PCOMPONENTDATA[CCDMAX_START];

            if (!_apcd)
            {
                hr = E_OUTOFMEMORY;
                DBG_OUT_HRESULT(hr);
                break;
            }

            _ccdMax = CCDMAX_START;

            //
            // Make sure unused slots are marked as such
            //

            ZeroMemory(_apcd, _ccdMax * sizeof(CComponentData *));

            //
            // Use the first slot
            //
            _apcd[0] = pcd;
            _ccd++;
            break;
        }

        //
        // An array is allocated; if there is an empty spot in it,
        // recycle it.
        //

        ASSERT(_apcd);

        if (_ccd < _ccdMax)
        {
            ULONG i;

            for (i = 0; i < _ccdMax; i++)
            {
                if (!_apcd[i])
                {
                    _apcd[i] = pcd;
                    _ccd++;
                    break;
                }
            }
            break;
        }

        //
        // No empty spots, try to realloc.
        //

        ASSERT(_ccd == _ccdMax); // if it's > we've overrun buffer!

        CComponentData **apcdNew = new PCOMPONENTDATA[_ccdMax * 2];

        if (!apcdNew)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        //
        // Copy over existing data before freeing it
        //

        CopyMemory(apcdNew, _apcd, _ccd * sizeof(CComponentData *));
        delete [] _apcd;
        _apcd = apcdNew;

        //
        // Record new size of buffer
        //

        _ccdMax *= 2;

        //
        // Append passed-in componentdata
        //

        _apcd[_ccd++] = pcd;

        //
        // Make sure unused slots are marked as such
        //

        ZeroMemory(&_apcd[_ccd], (_ccdMax - _ccd) * sizeof(CComponentData *));
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSynchWindow::_RequestScopeBitmapUpdate
//
//  Synopsis:   Ask the registered component data matching [wParam] to
//              update the scope pane bitmap for loginfo [lParam].
//
//  Arguments:  [wParam] - CComponentData *
//              [lParam] - CLogInfo *
//
//  History:    4-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSynchWindow::_RequestScopeBitmapUpdate(
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CSynchWindow, _RequestScopeBitmapUpdate);

    CComponentData *pcd = (CComponentData *) wParam;

    if (_IsRegistered(pcd))
    {
        pcd->UpdateScopeBitmap(lParam);
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CSynchWindow::_IsRegistered
//
//  Synopsis:   Return TRUE if [pcd] is found in the list of registered
//              component data objects, FALSE otherwise.
//
//  Arguments:  [pcd] - componentdata to check
//
//  Returns:    TRUE or FALSE
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CSynchWindow::_IsRegistered(
    CComponentData *pcd)
{
    ULONG           i;

    for (i = 0; i < _ccdMax; i++)
    {
        if (_apcd[i] == pcd)
        {
            return TRUE;
        }
    }

    Dbg(DEB_ERROR,
        "CSynchWindow::_RequestScopeBitmapUpdate: ComponentData 0x%x not registered\n",
        pcd);

    return FALSE;
}



//+--------------------------------------------------------------------------
//
//  Member:     CSynchWindow::Unregister
//
//  Synopsis:   Remove [pcd] from the list of component data objects that
//              will receive notifications.
//
//  Arguments:  [pcd] - componentdata to remove
//
//  Returns:    S_OK   - [pcd] found
//              E_FAIL - [pcd] not found
//
//  History:    2-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSynchWindow::Unregister(
    CComponentData *pcd)
{
    TRACE_METHOD(CSynchWindow, Unregister);

    HRESULT hr = E_FAIL; // INIT FOR FAILURE
    ULONG i;

    for (i = 0; i < _ccdMax; i++)
    {
        if (_apcd[i] == pcd)
        {
            _apcd[i] = NULL;
            ASSERT(_ccd);
            _ccd--;
            hr = S_OK;
            break;
        }
    }

    if (FAILED(hr))
    {
        Dbg(DEB_TRACE,
            "Unable to find pcd 0x%x in _apcd containing %u items\n",
            pcd,
            _ccd);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSynchWindow::_WndProc, static private
//
//  Synopsis:   WndProc for hidden window
//
//  Arguments:  [hwnd]   - window handle
//              [msg]    - WLSM_CALL_CCDS: calls HandleSynchMsg on all
//                          componentdatas that have been added.
//              [wParam] - varies by [msg]
//              [lParam] - varies by [msg]
//
//  Returns:    Standard windows
//
//  History:    2-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LRESULT CALLBACK
CSynchWindow::_WndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    CSynchWindow *pThis;
    LRESULT lResult = 0;

    pThis = (CSynchWindow *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch (msg)
    {
    case WM_CREATE:
    {
        pThis = (CSynchWindow *) ((LPCREATESTRUCT)lParam)->lpCreateParams;

        //
        // Initialize user data to this pointer, prevent window creation if
        // this fails.
        //

        SetLastError(0);
        lResult = SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR) pThis);

        if (!lResult && GetLastError())
        {
            DBG_OUT_LASTERROR;
            lResult = -1; // prevent window creation
        }
        else
        {
            lResult = 0;  // continue window creation
        }
        break;
    }

    case ELSM_LOG_DATA_CHANGED:
        pThis->_NotifyComponentDatasLogChanged(wParam, lParam);
        break;

    case ELSM_UPDATE_SCOPE_BITMAP:
        pThis->_RequestScopeBitmapUpdate(wParam, lParam);
        break;

    default:
        lResult = DefWindowProc(hwnd, msg, wParam, lParam);
        break;
    }

    return lResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\strarray.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//  
//  File:       strarray.cxx
//
//  Contents:   Simple self-extending string array class
//
//  Classes:    CStringArray
//
//  History:    07-16-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


#define GROW_BY     10


//+--------------------------------------------------------------------------
//
//  Member:     CStringArray::~CStringArray
//
//  Synopsis:   dtor
//
//  History:    07-16-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CStringArray::~CStringArray()
{
    Clear();
}




//+--------------------------------------------------------------------------
//
//  Member:     CStringArray::Clear
//
//  Synopsis:   Free resources.
//
//  History:    07-23-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CStringArray::Clear()
{
    ULONG i;

    for (i = 0; i < _cStrings; i++)
    {
        delete [] _apwsz[i];
    }

    delete [] _apwsz;

    _apwsz = NULL;
    _cStrings = _cMax = 0;
}




#if (DBG == 1)

VOID
CStringArray::Dump()
{
    for (ULONG i = 0; i < _cStrings; i++)
    {
        Dbg(DEB_FORCE, "    '%ws'\n", _apwsz[i]);
    }
}

#endif // (DBG == 1)

//+--------------------------------------------------------------------------
//
//  Member:     CStringArray::Query
//
//  Synopsis:   Return the index to string [pwsz], or 0 if it can't be found
//
//  Arguments:  [pwsz] - string to search for
//
//  Returns:    0 on error
//
//  History:    03-01-2002   JonN       Created
//
//---------------------------------------------------------------------------

ULONG
CStringArray::Query(
    LPCWSTR pwsz)
{
    ULONG i;

    for (i = 0; i < _cStrings; i++)
    {
        if (!lstrcmpi(pwsz, _apwsz[i]))
        {
            return i + 1;
        }
    }

    return 0;
}

//+--------------------------------------------------------------------------
//
//  Member:     CStringArray::Add
//
//  Synopsis:   Return the index to string [pwsz], or 0 if it can't be found
//              and can't be added.
//
//  Arguments:  [pwsz] - string to search for/add
//
//  Returns:    0 on error
//
//  History:    07-16-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CStringArray::Add(
    LPCWSTR pwsz)
{
    ULONG i = Query(pwsz);
    if (0 != i)
        return i;

    do
    {
        LPWSTR pwszCopy = new WCHAR[lstrlen(pwsz) + 1];
    
        if (!pwszCopy)
        {
            DBG_OUT_HRESULT(E_OUTOFMEMORY);
            break;
        }
        lstrcpy(pwszCopy, pwsz);
    
        //
        // expand array if necessary
        // 

        if (_cStrings == _cMax)
        {
            LPWSTR *apwszNew = new LPWSTR[_cMax + GROW_BY];

            if (!apwszNew)
            {
                DBG_OUT_HRESULT(E_OUTOFMEMORY);
                delete [] pwszCopy;
                break;
            }
            _cMax += GROW_BY;

            if (_cStrings)
            {
                CopyMemory(apwszNew, _apwsz, _cStrings * sizeof(LPWSTR));
            }

            delete [] _apwsz;
            _apwsz = apwszNew;
        }

        //
        // append copy of [pwsz] to array
        // 

        _apwsz[_cStrings++] = pwszCopy;
        i = _cStrings;
    } while (0);

    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\stddbg.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       StdDbg.h
//
//  Contents:   Common debug definitions.
//
//  History:    5/20/1996   RaviR   Created
//
//____________________________________________________________________________


#include "admindbg.h"
#include <tchar.h>

//
//  EXAMPLE: A debug file for component SAMPLE, with the debugging tag
//  name "Samp" is defined as shown below:
//
//
//      //
//      //  File:   SampDbg.h
//      //
//
//      #ifndef _SAMPDBG_H_
//      #define _SAMPDBG_H_
//
//      #include "stddbg.h"
//
//      #if DBG==1
//          DECLARE_DEBUG(Samp)
//          #define DBG_COMP    SampInfoLevel
//      #endif // DBG==1
//
//      #endif // _SAMPDBG_H_
//


//
//  A corresponding DECLARE_INFOLEVEL(Samp) should be implemented in a .cpp
//  file. This creates a global instance of an CDbg -> SampInfoLevel.
//  SampInfoLevel can be initialized by setting the "Samp" value under reg key
//
//    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AdminDebug
//
//  By defalut it is set to (DEB_ERROR | DEB_WARN)
//


//
//  ------------------------------------------------------------------------
//  Method:     CDbg::DebugOut(debug_level, lpstrfmt, ...);
//
//      Where debug_level is a combination of one or more of the DEB_XXX
//      values defined in admindbg.h. If ((SampInfoLevel & debug_level) != 0)
//      The string lpstrfmt will be printed out to the debugger.
//
//  ------------------------------------------------------------------------
//  Method:     CDbg::Trace(lpstrfmt, ...);
//
//      Same as CDbg::DebugOut, except that debug_level is internally
//      set to DEB_TRACE.
//
//  ------------------------------------------------------------------------
//  Method:     DebugMsg(file, line, message)
//
//      Force output the <file, line, message>.
//
//  ------------------------------------------------------------------------
//


#ifndef __STDDBG_HXX__
#define __STDDBG_HXX__

#undef ASSERT
#undef ASSERTMSG

//
//  C++ files redefine THIS_FILE by adding the following two lines:
//
//      #undef THIS_FILE
//      static char THIS_FILE[] = __FILE__;
//

#define THIS_FILE       __FILE__

#undef  TRACE
#undef  ASSERT
#undef  VERIFY


#if DBG==1

    #define Dbg                         DBG_COMP.DebugOut
    #define TRACE                       DBG_COMP.Trace

    // Heap checking
    extern  DWORD dwHeapChecking;
    #define DECLARE_HEAPCHECKING    DWORD dwHeapChecking = 0

    #define DEBUGCHECK \
        if ( (dwHeapChecking & 0x1) == 0x1 ) \
        { \
            HeapValidate(GetProcessHeap(),0,NULL); \
        } else 1

    #define DBG_INDENTER    \
            CIndenter Indent(&DBG_COMP)

    // Debug messages
    #define TRACE_CONSTRUCTOR(cls) \
        DEBUGCHECK; \
        Dbg(DEB_RESOURCE, _T(#cls) _T("::") _T(#cls) _T("<%x>\n"), this); \
        DBG_INDENTER;

    #define TRACE_DESTRUCTOR(cls) \
        DEBUGCHECK; \
        Dbg(DEB_RESOURCE, _T(#cls) _T("::~") _T(#cls) _T("<%x>\n"), this); \
        DBG_INDENTER;

    #define TRACE_METHOD(Class, Method) \
        DEBUGCHECK; \
        Dbg(DEB_METHOD, _T(#Class) _T("::") _T(#Method) _T("(%x)\n"), this); \
        DBG_INDENTER;

    #define TRACE_FUNCTION(Function) \
        DEBUGCHECK; \
        Dbg(DEB_FUNCTION, _T(#Function) _T("\n")); \
        DBG_INDENTER;

    #define TRACE_CONSTRUCTOR_EX(Infolevel, cls) \
        DEBUGCHECK; \
        Dbg(Infolevel, _T(#cls) _T("::") _T(#cls) _T("<%x>\n"), this); \
        DBG_INDENTER;

    #define TRACE_DESTRUCTOR_EX(Infolevel, cls) \
        DEBUGCHECK; \
        Dbg(Infolevel, _T(#cls) _T("::~") _T(#cls) _T("<%x>\n"), this); \
        DBG_INDENTER;

    #define TRACE_METHOD_EX(Infolevel, Class, Method) \
        DEBUGCHECK; \
        Dbg(Infolevel, _T(#Class) _T("::") _T(#Method) _T("(%x)\n"), this); \
        DBG_INDENTER;

    #define TRACE_FUNCTION_EX(Infolevel, Function) \
        DEBUGCHECK; \
        Dbg(Infolevel, _T(#Function) _T("\n")); \
        DBG_INDENTER;

    #define CHECK_HRESULT(hr) \
        if ( FAILED(hr) ) \
        { \
            DBG_COMP.DebugErrorX(THIS_FILE, __LINE__, hr); \
        } else 1

    #define CHECK_LASTERROR(lr) \
        if ( lr != ERROR_SUCCESS ) \
        { \
            DBG_COMP.DebugErrorL(THIS_FILE, __LINE__, lr); \
        } else 1

    #define DBG_OUT_LASTERROR \
        DBG_COMP.DebugErrorL(THIS_FILE, __LINE__, GetLastError());

    #define ASSERTMSG(x)   \
        (void)((x) || (DBG_COMP.DebugMsg(THIS_FILE, __LINE__, _T(#x)),0))

    #define VERIFYMSG(e)   ASSERTMSG(e)

    #define ASSERT(x)   Win4Assert(x)
    #define VERIFY(x)   Win4Assert(x)

#else

    inline void __cdecl __DummyDbg(ULONG, PCWSTR, ...) { }
    inline void __cdecl __DummyDbg(ULONG, LPCSTR, ...) { }
    #define Dbg             1 ? (void)0 : ::__DummyDbg

    inline void __cdecl __DummyTrace(PCWSTR, ...) { }
    inline void __cdecl __DummyTrace(LPCSTR, ...) { }
    #define TRACE           1 ? (void)0 : ::__DummyTrace

    #define TRACE_SCOPE(x)

    #define DECLARE_HEAPCHECKING
    #define DEBUGCHECK
    #define DBG_INDENTER

    #define TRACE_CONSTRUCTOR(cls)
    #define TRACE_DESTRUCTOR(cls)
    #define TRACE_METHOD(ClassName,MethodName)
    #define TRACE_FUNCTION(FunctionName)
    #define TRACE_CONSTRUCTOR_EX(Infolevel, cls)
    #define TRACE_DESTRUCTOR_EX(Infolevel, cls)
    #define TRACE_METHOD_EX(Infolevel, ClassName, MethodName)
    #define TRACE_FUNCTION_EX(Infolevel, FunctionName)

    #define CHECK_HRESULT(hr)
    #define CHECK_LASTERROR(lr)

    #define DBG_OUT_LASTERROR

    #define ASSERTMSG(e)
    #define VERIFYMSG(e)   e

    #define ASSERT(e)
    #define VERIFY(e)   e

#endif // DBG==1


#if DBG==1 && defined(_NODEMGR_DLL_)

    // Debug instance counter
inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    char buf[100];
    // JonN 2/1/01 256032 wsprintf -> wnsprintf
    wnsprintfA(buf, 100, "%s has %d instances left over.", pszClassName, cInstRem);
    ::MessageBoxA(NULL, buf, "MMC: Memory Leak!!!", MB_OK);
}

    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    extern int s_cInst_##cls; ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    extern int s_cInst_##cls; --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);

#else

    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)

#endif





#ifdef UNICODE
#define DBGSTRING %ls
#else
#define DBGSTRING %s
#endif


#define SAFEDBGBSTR(x) ((x==NULL)?L"<NULL>":x)
#define SAFEDBGTCHAR(x) ((x==NULL)?_T("<NULL>"):x)


#define ASSERT_OBJECTPTR(x) ASSERT( NULL == (x) || !::IsBadWritePtr(x,sizeof(x)) );
#define ASSERT_STRINGPTR(x) ASSERT( NULL == (x) || AfxIsValidStringPtr(x) );
#define FREE_OBJECTPTR(x) { ASSERT_OBJECTPTR(x); delete x; x = NULL; }

#endif // __STDDBG_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\util.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       util.cxx
//
//  Contents:   Miscellaneous utility functions
//
//  History:    12-09-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#include <malloc.h>
#pragma hdrstop

#include <lmwksta.h> // JonN 9/4/01 463889 NetWkstaGetInfo

//
// These are in sdk\inc\ntrtl.h
//

extern "C" {

NTSYSAPI
BOOLEAN
NTAPI
RtlTimeToSecondsSince1970 (
    PLARGE_INTEGER Time,
    PULONG ElapsedSeconds
    );

NTSYSAPI VOID NTAPI
RtlSecondsSince1970ToTime(
    ULONG ElapsedSeconds,
    PLARGE_INTEGER Time);

};

//
// Local constants
//

#define MAX_CMENU_STR           50
#define MAX_STATUSBAR_STR       200
// SYSTEMROOT_ENV_VAR must be lowercase
#define SYSTEMROOT_ENV_VAR              L"%systemroot%"
#define SYSTEMROOT_KEY                  L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
#define SYSTEMDRIVE_ENV_VAR             L"%systemdrive%"

//
// Forward references
//


LPCWSTR
FindFirstTrailingSpace(
    LPCWSTR pwsz);


//+--------------------------------------------------------------------------
//
//  Function:   AbbreviateNumber
//
//  Synopsis:   Create a string of the form "999.9 KB" (or MB or GB) in
//              [wszBuf].
//
//  Arguments:  [ulBytes] - number to transform
//              [wszBuf]  - buffer to write result
//              [cchBuf]  - size, in wchars, of [wszBuf]
//
//  Modifies:   *[wszBuf]
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
AbbreviateNumber(
    ULONG ulBytes,
    LPWSTR wszBuf,
    ULONG cchBuf)
{
    INT iResult;
    WCHAR wszDecimal[10];
    WCHAR wszFmt[20];
    PVOID rgArgs[3];
    ULONG_PTR ulMegaBytes, ulGigaBytes;

    iResult = GetLocaleInfo(LOCALE_USER_DEFAULT,
                            LOCALE_SDECIMAL,
                            wszDecimal,
                            ARRAYLEN(wszDecimal));
    if (!iResult)
    {
        // Couldn't get the decimal separator,
        // use a default.

        DBG_OUT_LASTERROR;
        lstrcpy(wszDecimal, L".");
    }

    //
    // Check the size of the destination buffer is large enough for a
    // string "999.9 KB", where "." is the string in wszDecimal.
    //

    if (cchBuf < lstrlen(wszDecimal) + 8UL)
    {
        Dbg(DEB_ERROR,
            "AbbreviateNumber: insufficient buffer size %u\n",
            cchBuf);
        wszBuf[0] = L'\0';
        return;
    }

    rgArgs[1] = wszDecimal;

    //
    // Divide the size in bytes by 2^10 to get kilobytes
    //

    ULONG_PTR ulKiloBytes = ulBytes >> 10;

    //
    // If result is three digits or less we're done
    //

    if (ulKiloBytes < 1000UL)
    {
        LoadStr(IDS_KB_FORMAT, wszFmt, ARRAYLEN(wszFmt));

        rgArgs[0] = (PVOID)ulKiloBytes;

        rgArgs[2] = (PVOID)(ULONG_PTR)(((ulBytes * 10) % KILO) / KILO);
    }
    else
    {
        //
        // Too many digits, switch to megabytes
        //

        ulMegaBytes = ulKiloBytes >> 10;

        if (ulMegaBytes < 1000UL)
        {
            LoadStr(IDS_MB_FORMAT, wszFmt, ARRAYLEN(wszFmt));

            rgArgs[0] = (PVOID)ulMegaBytes;

            rgArgs[2] = (PVOID)(ULONG_PTR)(((ulBytes * 10) % MEGA) / MEGA);
        }
        else
        {
            //
            // File size is at least 1 gig.  Handle the tenths digit computation
            // with a 64bit number to avoid overflow.
            //

            LoadStr(IDS_GB_FORMAT, wszFmt, ARRAYLEN(wszFmt));

            ulGigaBytes = ulMegaBytes >> 10;

            rgArgs[0] = (PVOID)ulGigaBytes;

            DWORDLONG dwlFraction = ((((DWORDLONG)ulBytes) * 10) % GIGA) / GIGA;
            rgArgs[2] = (PVOID)(ULONG_PTR)dwlFraction;
        }
    }

    FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                  wszFmt, 0, 0, wszBuf, cchBuf,
                  (va_list *)rgArgs);
}




//+--------------------------------------------------------------------------
//
//  Function:   AddCMenuItem
//
//  Synopsis:   Add context menu item [pItem] using [pCallback].
//
//  Arguments:  [pCallback] - supports AddItem method.
//              [pItem]     - points to item to add
//
//  Returns:    HRESULT
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
AddCMenuItem(
    LPCONTEXTMENUCALLBACK pCallback,
    CMENUITEM *pItem)
{
    HRESULT hr = S_OK;
    CONTEXTMENUITEM cmItem;
    WCHAR wszItem[MAX_CMENU_STR] = L"";
    WCHAR wszStatus[MAX_STATUSBAR_STR];

    do
    {
        if (pItem->flSpecialFlags != CCM_SPECIAL_SEPARATOR)
        {
            hr = LoadStr(pItem->idsMenu, wszItem, ARRAYLEN(wszItem));
            BREAK_ON_FAIL_HRESULT(hr);

            hr = LoadStr(pItem->idsStatusBar, wszStatus, ARRAYLEN(wszStatus));
            BREAK_ON_FAIL_HRESULT(hr);
        }

        cmItem.strName = wszItem;
        cmItem.strStatusBarText = wszStatus;
        cmItem.lCommandID = pItem->idMenuCommand;
        cmItem.lInsertionPointID = pItem->idInsertionPoint;
        cmItem.fFlags = pItem->flMenuFlags;
        cmItem.fSpecialFlags = pItem->flSpecialFlags;

        hr = pCallback->AddItem(&cmItem);

        if (FAILED(hr))
        {
            Dbg(DEB_ERROR,
                "AddCMenuItem: insert item '%s' hr=0x%x\n",
                wszItem,
                hr);
        }
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   ConvertPathToUNC
//
//  Synopsis:   Converts drive-based path in [pwszPath] to a UNC path using
//              an administrative share.
//
//  Arguments:  [pwszServerName] - name of remote machine ("foo" not "\\foo")
//              [pwszPath]       - contains drive-based path
//              [cchPathBuf]     - size, in WCHARs, of [pwszPath]
//
//  Returns:    S_OK         - conversion succeeded
//              E_FAIL       - [pwszPath] too small to hold result
//              E_INVALIDARG - second char of [pwszPath] is not a colon
//
//  Modifies:   *[pwszPath]
//
//  History:    2-24-1997   DavidMun   Created
//
//  Notes:      If the user does not have administrative access to
//              [pwszServerName], the viewer will fail to open the remote
//              files when attempting to get message id strings; it will
//              treat that error as any other and attempt to get the string
//              from modules on the local machine.
//
//---------------------------------------------------------------------------

HRESULT
ConvertPathToUNC(
    LPCWSTR pwszServerName,
    LPWSTR  pwszPath,
    ULONG   cchPathBuf)
{
    TRACE_FUNCTION(ConvertPathToUNC);

    //
    // Verify there's enough room for the expanded string.  We need to have
    // room for two backslashes, the server name, another backslash, the
    // filename, and a null terminator.
    //

    ULONG cchServerName = lstrlen(pwszServerName);
    ULONG cchPath       = lstrlen(pwszPath);
    ULONG cchRequired   = 2 + cchServerName + 1 + cchPath + 1;

    if (cchRequired > cchPathBuf)
    {
        Dbg(DEB_ERROR,
            "ConvertPathToUNC: buffer size %u too small for '\\\\%s\\%s'\n",
            cchPathBuf,
            pwszServerName,
            pwszPath);
        return E_FAIL;
    }

    //
    // Verify precondition is met pwszPath contains a full path on entry.
    //

    if (pwszPath[1] != L':')
    {
        Dbg(DEB_ERROR,
            "ConvertPathToUNC: filename '%s' is not a drive-based path\n",
            pwszPath);
        return E_INVALIDARG;
    }

    //
    // Convert to administrative share
    //

    ASSERT(IsDriveLetter(pwszPath[0]));
    pwszPath[1] = L'$';

    //
    // Move the filename to the right to make room for the server name
    // and backslashes.  Remember to move the null terminator.
    //

    MoveMemory(&pwszPath[cchServerName + 3],
               &pwszPath[0],
               sizeof(WCHAR) * (cchPath + 1));

    //
    // Insert server name and backslashes.
    //

    lstrcpy(pwszPath, L"\\\\");
    lstrcpy(&pwszPath[2], pwszServerName);
    pwszPath[2 + cchServerName] = L'\\';
    return S_OK;
}




//+---------------------------------------------------------------------------
//
//  Function:   ConvertToFixedPitchFont
//
//  Synopsis:   Converts a windows font to a fixed pitch font.
//
//  Arguments:  [hwnd] -- IN window handle
//
//  Returns:    BOOL
//
//  History:    7/15/1995   RaviR   Created
//
//----------------------------------------------------------------------------

BOOL
ConvertToFixedPitchFont(
    HWND hwnd)
{
    LOGFONT     lf;

    if (!GetObject(GetWindowFont(hwnd), sizeof(LOGFONT), &lf))
    {
        DBG_OUT_LASTERROR;
        return FALSE;
    }

    lf.lfQuality        = PROOF_QUALITY;
    lf.lfPitchAndFamily &= ~VARIABLE_PITCH;
    lf.lfPitchAndFamily |= FIXED_PITCH;
    lf.lfFaceName[0]    = L'\0';

    HFONT hf = CreateFontIndirect(&lf);

    if (hf == NULL)
    {
        DBG_OUT_LASTERROR;
        return FALSE;
    }

    SetWindowFont(hwnd, hf, TRUE); // macro in windowsx.h

    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Function:   DeleteQuotes
//
//  Synopsis:   Delete all instances of the double quote character from
//              [pwsz].
//
//  Arguments:  [pwsz] - nul terminated string
//
//  Modifies:   *[pwsz]
//
//  History:    11-21-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
DeleteQuotes(
    LPWSTR pwsz)
{
    TCHAR *pwszLead;
    TCHAR *pwszTrail;

    //
    // Move a lead and trail pointer through the buffer, copying from the lead
    // to the trail whenever the character isn't one we're deleting (a double
    // quote).
    //
    // Note: the "Lead" and "Trail" in pwszLead and pwszTrail do not refer
    // to DBCS lead/trail bytes, rather that the pwszLead pointer can move
    // ahead of pwszTrail when it is advanced past a double quote.
    //

    for (pwszTrail = pwszLead = pwsz; *pwszLead; pwszLead++)
    {
        //
        // If the current char is a double quote, we want it deleted, so don't
        // copy it and go on to the next char.
        //

        if (*pwszLead == L'"')
        {
            continue;
        }

        //
        // pwszLead is pointing to a 'normal' character, i.e.  not a double
        // quote.
        //

        *pwszTrail++ = *pwszLead;
    }
    *pwszTrail = L'\0';
}




//+--------------------------------------------------------------------------
//
//  Function:   DetermineLogType
//
//  Synopsis:   Compare [wszSubkeyName] against known log names and return
//              a type describing it.
//
//  Arguments:  [wszSubkeyName] - log name to compare
//
//  Returns:    ELT_*
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

EVENTLOGTYPE
DetermineLogType(
    LPCWSTR wszSubkeyName)
{
    // NTRAID#NTBUG9-2002/05/17-623723-ericb: prefast, don't use lstrcmpi
    if (!_wcsicmp(wszSubkeyName, APPLICATION_LOG_NAME))
    {
        return ELT_APPLICATION;
    }

    if (!_wcsicmp(wszSubkeyName, SYSTEM_LOG_NAME))
    {
        return ELT_SYSTEM;
    }

    if (!_wcsicmp(wszSubkeyName, SECURITY_LOG_NAME))
    {
        return ELT_SECURITY;
    }

    return ELT_CUSTOM;
}




//+--------------------------------------------------------------------------
//
//  Function:   DisplayLogAccessError
//
//  Synopsis:   Display a console-modal message box informing user of error
//              hr.
//
//  Arguments:  [hr]       - error
//              [pConsole] - console interface
//              [pli]      - log which caused error
//
//  History:    4-08-1997   DavidMun   Created
//
//  Notes:      No-op if SUCCEEDED(hr)
//
//---------------------------------------------------------------------------

VOID
DisplayLogAccessError(
    HRESULT hr,
    IConsole *pConsole,
    CLogInfo *pli)
{
    LPWSTR pwszMsgBuf = NULL;

    ULONG cchWritten = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_FROM_SYSTEM,
                                     NULL,
                                     hr,
                                     0,
                                     (LPWSTR) &pwszMsgBuf,
                                     0,
                                     NULL);

    if (!cchWritten)
    {
        ConsoleMsgBox(pConsole,
                      IDS_LOG_GENERIC_ERROR,
                      MB_ICONERROR | MB_OK,
                      pli->GetDisplayName(),
                      hr);
    }
    else
    {
        LPWSTR pwszNewLine = wcschr(pwszMsgBuf, L'\r');

        if (pwszNewLine)
        {
            *pwszNewLine = L'\0';
        }

        ConsoleMsgBox(pConsole,
                      IDS_LOG_SYSMSG_ERROR,
                      MB_ICONERROR | MB_OK,
                      pli->GetDisplayName(),
                      pwszMsgBuf);
    }

    LocalFree(pwszMsgBuf);
}








//+--------------------------------------------------------------------------
//
//  Function:   ExpandRemoteSystemRoot
//
//  Synopsis:   Copy [pwszUnexpanded] into [pwszExpanded], substituting
//              [wszRemoteSystemRoot] for all occurrences of %systemroot% in
//              [pwszUnexpanded].
//
//  Arguments:  [pwszUnexpanded]      - string to expand
//              [wszRemoteSystemRoot] - value to substitute for %systemroot%
//              [pwszExpanded]        - destination buffer
//              [cchExpandedOutBuf]   - size, in wchars, of [pwszExpanded]
//
//  Returns:    S_OK - expansion done
//              E_FAIL - destination buffer too small
//
//  Modifies:   [pwszUnexpanded] (lowercases), [pwszExpanded]
//
//  History:    2-24-1997   DavidMun   Created
//              9-05-2001   JonN       463015: Added %SystemDrive% support
//
//  Notes:      Lowercases unexpanded string.  [pwszUnexpanded] MUST NOT ==
//              [pwszExpanded].
//
//---------------------------------------------------------------------------

HRESULT
ExpandRemoteSystemRoot(
    LPWSTR  pwszUnexpanded,
    LPCWSTR wszRemoteSystemRoot,
    LPWSTR  pwszExpanded,
    ULONG   cchExpandedOutBuf)
{
    TRACE_FUNCTION(ExpandRemoteSystemRoot);

    HRESULT hr = S_OK;
    LPCWSTR pwszCurSrcPos = pwszUnexpanded;
    LPWSTR  pwszCurDestPos = pwszExpanded;
    ULONG   cchRemain = cchExpandedOutBuf;
    ULONG   cchExpandedSR = lstrlen(wszRemoteSystemRoot);

    ASSERT(cchExpandedSR);

    _wcslwr(pwszUnexpanded); // no wcsistr :-(

    do
    {
        LPWSTR pwszNextSR = wcsstr(pwszCurSrcPos, SYSTEMROOT_ENV_VAR);
        LPWSTR pwszNextSD = wcsstr(pwszCurSrcPos, SYSTEMDRIVE_ENV_VAR);
        LPWSTR pwszNext = NULL;
        if (!pwszNextSD)
            pwszNext = pwszNextSR;
        else if (!pwszNextSR)
            pwszNext = pwszNextSD;
        else
            pwszNext = (pwszNextSR < pwszNextSD) ? pwszNextSR : pwszNextSD;

        if (!pwszNext)
            break;

        bool bSystemDrive = (pwszNext == pwszNextSD);
        ULONG cchExpanded = (bSystemDrive) ? 2 : cchExpandedSR;
        ULONG cchReplace = (bSystemDrive) ? (ARRAYLEN(SYSTEMDRIVE_ENV_VAR) - 1)
                                          : (ARRAYLEN(SYSTEMROOT_ENV_VAR) - 1);

        //
        // If the systemroot was found after the current source
        // position, copy all characters from the current source up to
        // the start of the systemroot into the destination.
        //

        if (pwszNext > pwszCurSrcPos)
        {
            ULONG cchToCopy = static_cast<ULONG>(pwszNext - pwszCurSrcPos);

            if (cchRemain <= cchToCopy)
            {
                hr = E_FAIL;
                break;
            }

            CopyMemory(pwszCurDestPos,
                       pwszCurSrcPos,
                       sizeof(WCHAR) * cchToCopy);

            pwszCurDestPos += cchToCopy;
            cchRemain -= cchToCopy;

            //
            // Advance source pointer past the characters just copied,
            // i.e., up to the start of the systemroot string.
            //

            pwszCurSrcPos = pwszNext;
        }

        //
        // Now pwszNext == pwszCurSrcPos.  Check that enough room
        // remains in the destination, then write the expanded env
        // var into the destination and advance its pointer.
        //

        if (cchRemain <= cchExpanded)
        {
            hr = E_FAIL;
            break;
        }

        CopyMemory(pwszCurDestPos,
                   wszRemoteSystemRoot,
                   sizeof(WCHAR) * cchExpanded);

        pwszCurDestPos += cchExpanded;
        cchRemain -= cchExpanded;

        //
        // Advance the source pointers past the %systemroot% string
        //

        pwszNext += cchReplace;
        pwszCurSrcPos += cchReplace;
    } while (true);

    if (FAILED(hr))
    {
        //
        // Make out buffer an empty string
        //

        *pwszExpanded = L'\0';
    }
    else
    {
        //
        // Copy remaining characters from source to dest
        //

        lstrcpyn(pwszCurDestPos, pwszCurSrcPos, cchRemain);

        //
        // We don't support any environment variables other than
        // SystemRoot and SystemDrive.  However, it is possible that
        // someone registered the event source incorrectly, so skip
        // this assertion.  JonN 9/05/01
        //
        // ASSERT(!wcschr(pwszExpanded, L'%'));
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   ExpandSystemRootAndConvertToUnc
//
//  Synopsis:   Replace occurences of %SystemRoot% in [pwszPath] with
//              [wszRemoteSystemRoot], then convert the result to a UNC
//              name.
//
//  Arguments:  [pwszPath]            - path to convert
//              [cchPath]             - size, in wchars, of [pwszPath]
//              [wszServerName]       - used as machine in UNC
//              [wszRemoteSystemRoot] - used to replace environment var
//
//  Returns:    HRESULT
//
//  Modifies:   *[pwszPath]
//
//  History:    4-04-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
ExpandSystemRootAndConvertToUnc(
    LPWSTR pwszPath,
    ULONG  cchPath,
    LPCWSTR wszServerName,
    LPCWSTR wszRemoteSystemRoot)
{
    HRESULT hr;
    WCHAR   wszTemp[MAX_PATH + 1];

    hr = ExpandRemoteSystemRoot(pwszPath,
                                wszRemoteSystemRoot,
                                wszTemp,
                                ARRAYLEN(wszTemp));

    if (FAILED(hr))
    {
        return hr;
    }

    hr = ConvertPathToUNC(wszServerName, wszTemp, ARRAYLEN(wszTemp));

    if (FAILED(hr))
    {
        return hr;
    }

    lstrcpyn(pwszPath, wszTemp, cchPath);

    return S_OK;
}



#define DISPLAY_PATH_STR    L"DisplayNameFile"
#define DISPLAY_MSGID_STR   L"DisplayNameID"

//+--------------------------------------------------------------------------
//
//  Function:   GetLogDisplayName
//
//  Synopsis:   Get the display (node) name for a log
//
//  Arguments:  [hkTargetEventLog]    - handle to reg key of event log we're
//                                       viewing
//              [wszServer]           - NULL or remote machine name
//              [wszRemoteSystemRoot] - NULL or value of SystemRoot env var on
//                                       wszServer.  Must be non-NULL if
//                                       wszServer is non-NULL.
//              [wszSubkeyName]       - name of log subkey for which to seek
//                                       localized name.
//
//  Returns:    NULL or localized display name of log
//
//  History:    6-22-1999   davidmun   Created
//
//  Notes:      Caller must use LocalFree on returned string.
//
//---------------------------------------------------------------------------

LPWSTR
GetLogDisplayName(
    HKEY    hkTargetEventLog,
    LPCWSTR wszServer,
    LPCWSTR wszRemoteSystemRoot,
    LPCWSTR wszSubkeyName)
{
    HRESULT hr = S_OK;
    //
    // Try to get a localized string for the log's display name.
    // Note we always look on the local machine first, since the
    // remote machine's locale may differ from the local machine's.
    //

    LPWSTR pwszLogDisplayName = NULL;
    WCHAR wszDisplayModule[MAX_PATH];

    do
    {
        //
        // JonN 7/2/01 426119
        // Security string is hardcoded and visible
        // only when user with no admin right logs on
        //
        // If this is the Security log, ignore the registry contents and
        // load the log name locally.  We do this because the Security
        // subkey has highly restrictive permissions.
        //
        if (!_wcsicmp(wszSubkeyName,L"Security"))
        {
            (void) LoadStr(IDS_NAME_OF_SECURITY_LOG,
                           wszDisplayModule,
                           ARRAYLEN(wszDisplayModule),
                           L"");
            if (wszDisplayModule[0])
            {
                pwszLogDisplayName = (LPWSTR)LocalAlloc(LPTR,
                    sizeof(WCHAR)*(wcslen(wszDisplayModule)+1));
                if (pwszLogDisplayName)
                {
                    wcscpy( pwszLogDisplayName, wszDisplayModule );
                    break;
                }
            }
        }

        wstring wstrLocalKey; // JonN 2/1/01 256032

        wstrLocalKey = EVENTLOG_KEY;
        wstrLocalKey += L"\\";
        wstrLocalKey += wszSubkeyName;

        CSafeReg shkLocalLogKey;

        hr = shkLocalLogKey.Open(HKEY_LOCAL_MACHINE,
                                 (LPCTSTR)(wstrLocalKey.c_str()),
                                 KEY_READ);
        BREAK_ON_FAIL_HRESULT(hr);

        WCHAR wzUnexpandedDisplayModule[MAX_PATH];

        hr = shkLocalLogKey.QueryPath(DISPLAY_PATH_STR,
                                      wzUnexpandedDisplayModule,
                                      ARRAYLEN(wzUnexpandedDisplayModule),
                                      TRUE);
        BREAK_ON_FAIL_HRESULT(hr);

        ULONG ulLogMsgId;

        hr = shkLocalLogKey.QueryDword(DISPLAY_MSGID_STR,
                                      &ulLogMsgId);
        BREAK_ON_FAIL_HRESULT(hr);

        ExpandEnvironmentStrings(wzUnexpandedDisplayModule,
                                 wszDisplayModule,
                                 ARRAYLEN(wszDisplayModule));
        //
        // Try to read message with id ulLogMsgId from file
        // wszDisplayModule.
        //

        AttemptFormatMessage(ulLogMsgId,
                             wszDisplayModule,
                             &pwszLogDisplayName);
    } while (0);

    hr = S_OK;

    //
    // If the local machine doesn't have the display name for the
    // log and the log is on a remote machine, check the remote
    // machine's registry.
    //

    do
    {
        if (pwszLogDisplayName || !wszServer || !*wszServer)
        {
            break;
        }

        CSafeReg shkRemoteLogKey;

        hr = shkRemoteLogKey.Open(hkTargetEventLog,
                                  wszSubkeyName,
                                  KEY_READ);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = shkRemoteLogKey.QueryPath(DISPLAY_PATH_STR,
                                      wszDisplayModule,
                                      ARRAYLEN(wszDisplayModule),
                                      TRUE);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // convert REG_EXPAND_SZ path in wszDisplayModule to
        // a UNC path.
        //

        hr = ExpandSystemRootAndConvertToUnc(wszDisplayModule,
                                             ARRAYLEN(wszDisplayModule),
                                             wszServer,
                                             wszRemoteSystemRoot);
        BREAK_ON_FAIL_HRESULT(hr);

        ULONG ulLogMsgId;

        hr = shkRemoteLogKey.QueryDword(DISPLAY_MSGID_STR,
                                      &ulLogMsgId);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Try to read message with id ulLogMsgId from file
        // wszDisplayModule.
        //

        AttemptFormatMessage(ulLogMsgId,
                             wszDisplayModule,
                             &pwszLogDisplayName);

    } while (0);

    return pwszLogDisplayName;
}




//+--------------------------------------------------------------------------
//
//  Function:   ExtractFromDataObject
//
//  Synopsis:   Ask [lpDataObject] to put its data in the format [cf] into]
//              a stream on global memory.
//
//  Arguments:  [lpDataObject] - data object from which to get data
//              [cf]           - requested format of data
//              [cb]           - size, in bytes, of requested data
//              [phGlobal]     - filled with handle to data
//
//  Returns:    HRESULT
//
//  Modifies:   *[phGlobal]
//
//  History:    4-19-1997   DavidMun   Created
//
//  Notes:      It is the caller's responsibility to free *[phGlobal].
//
//---------------------------------------------------------------------------

HRESULT
ExtractFromDataObject(
    LPDATAOBJECT lpDataObject,
    UINT cf,
    ULONG cb,
    HGLOBAL *phGlobal)
{
    ASSERT(lpDataObject != NULL);

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL
    };

    FORMATETC formatetc =
    {
        (CLIPFORMAT)cf,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    HRESULT hr = S_OK;

    *phGlobal = NULL;

    do
        {
        // Allocate memory for the stream

        stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, cb);

        if (!stgmedium.hGlobal)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        // Attempt to get data from the object

        hr = lpDataObject->GetDataHere(&formatetc, &stgmedium);

        if (FAILED(hr))
        {
            Dbg(DEB_IWARN,
                "Warning (possibly benign): ExtractFromDataObject failed to get own data object from lpDataObject\n");
            break;
        }

        *phGlobal = stgmedium.hGlobal;
        stgmedium.hGlobal = NULL;
        } while (0);

    if (FAILED(hr) && stgmedium.hGlobal)
    {
#if (DBG == 1)
        HGLOBAL hRet =
#endif // (DBG == 1)
            GlobalFree(stgmedium.hGlobal);
        ASSERT(!hRet);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   ExtractOwnDataObject
//
//  Synopsis:   Return a pointer to the CDataObject associated with
//              [lpDataObject], or NULL if [lpDataObject] was not created
//              by our QueryDataObject implementation.
//
//  Arguments:  [lpDataObject] - data object to "cast"
//
//  Returns:    Pointer to CDataObject implementing [lpDataObject], or
//              NULL if an error occurs or [lpDataObject] is not implemented
//              by our CDataObject class.
//
//  History:    1-23-1997   davidmun   Created
//
//  Notes:      We can't simply cast from LPDATAOBJECT to CDataObject,
//              because the console may give us a data object created by
//              some other component (esp. when we are an extension).
//
//---------------------------------------------------------------------------

CDataObject *
ExtractOwnDataObject(
    LPDATAOBJECT lpDataObject)
{
    ASSERT(lpDataObject);

    if (!lpDataObject)
    {
        return NULL;
    }

    HRESULT hr = S_OK;
    HGLOBAL hGlobal;
    CDataObject *pdo = NULL;

    hr = ExtractFromDataObject(lpDataObject,
                               CDataObject::s_cfInternal,
                               sizeof(CDataObject **),
                               &hGlobal);

    if (SUCCEEDED(hr))
    {
        pdo = *(CDataObject **)(hGlobal);
        ASSERT(pdo);
#if (DBG == 1)
        HGLOBAL hRet =
#endif // (DBG == 1)
            GlobalFree(hGlobal);
        ASSERT(!hRet);
    }

    return pdo;
}




//+--------------------------------------------------------------------------
//
//  Function:   GetExtension
//
//  Synopsis:   Return a pointer to the file extension in [pwszFilename],
//              or NULL if it has none.
//
//  Arguments:  [pwszFilename] - filename to scan
//
//  Returns:    Pointer into [pwszFilename] or NULL.
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

LPWSTR
GetExtension(
    LPCWSTR pwszFilename)
{
    LPCWSTR pwsz;
    LPCWSTR pwszLastDot = NULL;

    for (pwsz = pwszFilename; *pwsz; pwsz++)
    {
        if (*pwsz == L'\\')
        {
            pwszLastDot = NULL;
        }
        else if (*pwsz == L'.')
        {
            pwszLastDot = pwsz;
        }
    }
    return (LPWSTR) pwszLastDot;
}




//+--------------------------------------------------------------------------
//
//  Function:   GetLocaleStr
//
//  Synopsis:   Fill [wszBuf] with the locale string corresponding to
//              [LCType].
//
//  Arguments:  [LCType]      - identifies string to fetch
//              [wszBuf]      - buffer for string
//              [cchBuf]      - size, in WCHARs, of [wszBuf]
//              [pwszDefault] - NULL or default string if GetLocaleInfo fails
//
//  Returns:    HRESULT
//
//  Modifies:   *[wszBuf]
//
//  History:    07-27-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
GetLocaleStr(
    LCTYPE LCType,
    LPWSTR wszBuf,
    ULONG cchBuf,
    LPCWSTR pwszDefault)
{
    HRESULT hr = S_OK;
    BOOL fOk = GetLocaleInfo(LOCALE_USER_DEFAULT, LCType, wszBuf, cchBuf);

    if (!fOk)
    {
        hr = HRESULT_FROM_LASTERROR;
        DBG_OUT_LASTERROR;

        if (pwszDefault)
        {
            lstrcpyn(wszBuf, pwszDefault, cchBuf);
        }
        else
        {
            *wszBuf = L'\0';
        }
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   GetRemoteSystemRoot
//
//  Synopsis:   Fill [wszRemoteSystemRoot] with the value of the SystemRoot
//              environment variable on remote machine connected to by
//              [hkRemoteHKLM].
//
//  Arguments:  [hkRemoteHKLM]        - connection to HKEY_LOCAL_MACHINE of
//                                        remote machine
//              [wszRemoteSystemRoot] - destination buffer
//              [cch]                 - size, in WCHARs, of
//                                        [wszRemoteSystemRoot]
//
//  Returns:    S_OK  - [wszRemoteSystemRoot] valid
//              E_*   - registry operation failed
//
//  Modifies:   [wszRemoteSystemRoot]
//
//  History:    2-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
GetRemoteSystemRoot(
    HKEY    hkRemoteHKLM,
    LPWSTR  wszRemoteSystemRoot,
    ULONG   cch)
{
    TRACE_FUNCTION(GetRemoteSystemRoot);

    HRESULT  hr = S_OK;
    CSafeReg shkRemoteSRkey;

    hr = shkRemoteSRkey.Open(hkRemoteHKLM, SYSTEMROOT_KEY, KEY_QUERY_VALUE);

    if (SUCCEEDED(hr))
    {
        hr = shkRemoteSRkey.QueryStr(L"SystemRoot", wszRemoteSystemRoot, cch);
    }

    if (FAILED(hr))
    {
        *wszRemoteSystemRoot = L'\0';
    }

    return hr;
}




#define MAX_FILTER              200

//+--------------------------------------------------------------------------
//
//  Function:   GetSaveFileAndType
//
//  Synopsis:   Prompt the user for the file name and file type for saving
//              the log represented by [pli].
//
//  Arguments:  [hwndParent]      - NULL or parent window for save dlg.
//              [pli]         - log in question
//              [pSaveType]       - filled with resulting type
//              [wszSaveFilename] - filled with resulting name
//              [cchSaveFilename] - size of [wszSaveFilename], in chars
//
//  Returns:    S_OK    - type and filename specified
//              S_FALSE - user hit cancel
//              E_*     - dialog reported error
//
//  Modifies:   [pSaveType], [wszSaveFilename]
//
//  History:    1-17-1997   DavidMun   Scavenged from code by RaviR
//
//  Notes:      Any existing file of the same name is deleted.
//
//---------------------------------------------------------------------------

HRESULT
GetSaveFileAndType(
    HWND hwndParent,
    CLogInfo *pli,
    SAVE_TYPE *pSaveType,
    LPWSTR wszSaveFilename,
    ULONG cchSaveFilename)
{
    HRESULT         hr = S_OK;
    OPENFILENAME    ofn;
    WCHAR           wszFilter[MAX_FILTER];
    wstring         wszSaveAs;

    do
    {
        ZeroMemory(wszFilter, sizeof wszFilter);
        hr = LoadStr(IDS_SAVEFILTER, wszFilter, ARRAYLEN(wszFilter));
        BREAK_ON_FAIL_HRESULT(hr);

        // do without a caption if necessary
        wszSaveAs = FormatString(IDS_SAVEAS, pli->GetDisplayName());

        wszSaveFilename[0] = L'\0';
        ZeroMemory(&ofn, sizeof(ofn));

        ofn.lStructSize       = sizeof(OPENFILENAME);
        ofn.hwndOwner         = hwndParent;
        ofn.hInstance         = g_hinst;
        ofn.lpstrFilter       = wszFilter;
        ofn.nFilterIndex      = 1L;
        ofn.lpstrFile         = wszSaveFilename;
        ofn.nMaxFile          = cchSaveFilename;
        ofn.lpstrDefExt       = EVENT_FILE_EXTENSION;
        ofn.lpstrTitle        = wszSaveAs.c_str();
        ofn.Flags             = OFN_PATHMUSTEXIST |
                                OFN_EXPLORER |
                                OFN_NOCHANGEDIR |
                                OFN_HIDEREADONLY  |
                                OFN_OVERWRITEPROMPT;

        //
        // Bail on error or if user selected Cancel or closed dialog
        //

        if (!GetSaveFileName(&ofn))
        {
#if (DBG == 1)
            LONG lr = CommDlgExtendedError();
            if (lr)
            {
                DBG_OUT_LRESULT(lr);
            }
#endif // (DBG == 1)

            hr = S_FALSE;
            break;
        }

        //
        // Remember the type of file selected in the types combo
        //

        *pSaveType = (SAVE_TYPE) ofn.nFilterIndex;
        ASSERT(*pSaveType);
        ASSERT(*pSaveType < 4);

        //
        // If the user didn't specify an extension, and there's room for one,
        // add the extension used by the type selected in the types combobox.
        //

        LPWSTR pwszExtension = GetExtension(wszSaveFilename);


        if ((!pwszExtension || !*pwszExtension) &&
            (cchSaveFilename - lstrlen(wszSaveFilename) > 4))
        {
            UINT nFilterIndex = ofn.nFilterIndex;
            LPWSTR pwszExt = wszFilter;

            while (--nFilterIndex)
            {
                pwszExt += (wcslen(pwszExt) + 1);
                pwszExt += (wcslen(pwszExt) + 1);
            }

            // 1 for previous string's NULL terminator & 1 for '*' as in *.evt
            pwszExt += (wcslen(pwszExt) + 2);

            lstrcat(wszSaveFilename, pwszExt);
        }

        //
        // Backup event log on a remote log only works if the destination
        // for the backup file is the same remote machine.  Ask the loginfo
        // to check that.
        //

        if (*pSaveType == SAVEAS_LOGFILE)
        {
            wstring strOriginalSaveFileName = wszSaveFilename;

            //
            // JonN 8/21/01 459062
            // Cannot save saved logs if snapin targeted to another computer
            //
            // If this is a backup log, the savefile path will be interpreted
            // local to the MMC machine rather than to the target machine.
            // Only do this processing is this is a live log.
            //
            if (!pli->IsBackupLog())
            {
                hr = pli->ProcessBackupFilename(wszSaveFilename);
            }

            // EricB 1/28/02 bug 526578, don't delete the
            // existing file if the remote log cannot be saved locally.
            //
            if (SUCCEEDED(hr))
            {
                DeleteFile(strOriginalSaveFileName.c_str());
            }
        }
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   GetUncServer
//
//  Synopsis:   Given a properly formatted UNC name, copy the server name
//              to wszServer, which is assumed to be at least MAX_PATH+1
//              characters.
//
//  Arguments:  [pwszUNC]   - valid UNC name
//              [wszServer] - destination buffer
//
//  Modifies:   *[wszServer]
//
//  History:    2-11-1997   DavidMun   Created
//  Modifies:   1/25/2001 Add wcchServer for #256032.
//---------------------------------------------------------------------------

VOID
GetUncServer(
    LPCWSTR pwszUNC,
    LPWSTR wszServer,
    USHORT wcchServer)
{
    LPWSTR pwszEnd = wcschr(&pwszUNC[2], L'\\');
    
    if (pwszEnd)
    {
        *pwszEnd = L'\0';
        lstrcpyn(wszServer, &pwszUNC[2], wcchServer-1);
        *pwszEnd = L'\\';
    }
    else if (pwszUNC[0] == L'\\' && pwszUNC[1] == L'\\')
    {
        lstrcpyn(wszServer, &pwszUNC[2], wcchServer-1);
    }
    else
    {
        lstrcpyn(wszServer, pwszUNC, wcchServer-1);
    }
    *(wszServer+wcchServer-1) = L'\0'; 
}




//+--------------------------------------------------------------------------
//
//  Function:   InitFindOrFilterDlg
//
//  Synopsis:   Initialize the controls common to both the find dialog and
//              the filter property sheet page.
//
//  Arguments:  [hwnd]     - handle to find dlg or filter prsht page
//              [pSources] - sources object to get cat/source strings from
//              [pffb]     - contains info describing settings
//
//  History:    3-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
InitFindOrFilterDlg(
    HWND hwnd,
    CSources *pSources,
    CFindFilterBase *pffb)
{
    //
    // Init the source and category comboboxes.  Start by adding (All)
    // since that always appears.
    //

    HWND hwndSourceCombo = GetDlgItem(hwnd, filter_source_combo);

    ComboBox_AddString(hwndSourceCombo, g_wszAll);

    //
    // Ask the log info for the sources container, and add all the
    // source names it contains to the sources combobox.
    //

    USHORT i;
    USHORT cSources = pSources->GetCount();

    for (i = 0; i < cSources; i++)
    {
        ComboBox_AddString(hwndSourceCombo,
                           pSources->GetSourceStrFromHandle(i + 1));
    }

    //
    // Set the selection in the sources combobox according to the
    // existing filter.  If we're not filtering by source, set it to
    // the first entry, which is (All).
    //

    if (pffb->SourceSpecified())
    {
        ComboBox_SelectString(hwndSourceCombo, -1, pffb->GetSourceName());
    }
    else
    {
        ComboBox_SelectString(hwndSourceCombo, -1, g_wszAll);
    }

    //
    // Fill the category combobox and set its current selection based on
    // the selected source.
    //

    SetCategoryCombobox(hwnd,
                     pSources,
                     pffb->GetSourceName(),
                     pffb->GetCategory());

    //
    // Set types checkboxes according to current source selection
    //

    SetTypesCheckboxes(hwnd, pSources, pffb->GetType());

    //
    // Initialize the User name edit control
    //

    if (pffb->GetUser())
    {
        Edit_SetText(GetDlgItem(hwnd, filter_user_edit), pffb->GetUser());
    }
    Edit_LimitText(GetDlgItem(hwnd, filter_user_edit), CCH_USER_MAX - 1);

    //
    // Initialize the computer name edit control
    //

    if (pffb->GetComputer())
    {
        Edit_SetText(GetDlgItem(hwnd, filter_computer_edit), pffb->GetComputer());
    }
    Edit_LimitText(GetDlgItem(hwnd, filter_computer_edit), CCH_COMPUTER_MAX - 1);

    //
    // Initialize the event ID edit control
    //

    if (pffb->EventIDSpecified())
    {
        VERIFY(SetDlgItemInt(hwnd,
                             filter_eventid_edit,
                             pffb->GetEventID(),
                             FALSE)); // unsigned
    }
    Edit_LimitText(GetDlgItem(hwnd, filter_eventid_edit), 5); // max is 65535
}




//+--------------------------------------------------------------------------
//
//  Function:   InvokePropertySheet
//
//  Synopsis:   Bring to top an existing or create a new property sheet
//              using the parameters provided.
//
//  Arguments:  [pPrshtProvider] - used to search for or create sheet
//              [wszTitle]       - sheet caption
//              [lCookie]        - a loginfo* or an event record number
//              [pDataObject]    - DO on object sheet's being opened on
//                                  (cookie in DO should == cookie)
//              [pPrimary]       - IExtendPropertySheet interface on
//                                  calling CSnapin or CComponentData
//              [usStartingPage] - which page number should be active when
//                                  sheet opens
//
//  Returns:    HRESULT
//
//  History:    4-25-1997   DavidMun   Created
//
//  Notes:      Call this routine when you want a property sheet to appear
//              as if the user had just selected "Properties" on it.
//
//---------------------------------------------------------------------------

HRESULT
InvokePropertySheet(
    IPropertySheetProvider *pPrshtProvider,
    LPCWSTR wszTitle,
    LONG lCookie,
    LPDATAOBJECT pDataObject,
    IExtendPropertySheet *pPrimary,
    USHORT usStartingPage)
{
    TRACE_FUNCTION(InvokePropertySheet);
    HRESULT hr = S_OK;

    do
    {
        //
        // Because we pass NULL for the second arg, the first is not allowed
        // to be null.
        //
        ASSERT(lCookie);

        hr = pPrshtProvider->FindPropertySheet(lCookie, NULL, pDataObject);
        Dbg(DEB_TRACE, "FindPropertySheet returned %x\n", hr);

        if (hr == S_OK)
        {
            break;
        }
        CHECK_HRESULT(hr);

        hr = pPrshtProvider->CreatePropertySheet(wszTitle,
                                                  TRUE,
                                                  lCookie,
                                                  pDataObject,
                                                  0);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pPrshtProvider->AddPrimaryPages(pPrimary, TRUE, NULL, TRUE);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pPrshtProvider->Show(NULL, usStartingPage);
        CHECK_HRESULT(hr);

    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   InvokeWinHelp
//
//  Synopsis:   Helper (ahem) function to invoke winhelp.
//
//  Arguments:  [message]                 - WM_CONTEXTMENU or WM_HELP
//              [wParam]                  - depends on [message]
//              [wszHelpFileName]         - filename with or without path
//              [aulControlIdToHelpIdMap] - see WinHelp API
//
//  History:    06-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
InvokeWinHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    LPCWSTR wszHelpFileName,
    ULONG aulControlIdToHelpIdMap[])
{
    TRACE_FUNCTION(InvokeWinHelp);

    ASSERT(wszHelpFileName);
    ASSERT(aulControlIdToHelpIdMap);

    switch (message)
    {
    case WM_CONTEXTMENU:                // Right mouse click - "What's This" context menu
                WinHelp((HWND) wParam,
                wszHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR) aulControlIdToHelpIdMap);
        break;

        case WM_HELP:                           // Help from the "?" dialog
    {
        const LPHELPINFO pHelpInfo = (LPHELPINFO) lParam;

        if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
        {
            WinHelp((HWND) pHelpInfo->hItemHandle,
                    wszHelpFileName,
                    HELP_WM_HELP,
                    (DWORD_PTR) aulControlIdToHelpIdMap);
        }
        break;
    }

    default:
        Dbg(DEB_ERROR, "Unexpected message %uL\n", message);
        break;
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   LoadStr
//
//  Synopsis:   Load string with resource id [ids] into buffer [wszBuf],
//              which is of size [cchBuf] characters.
//
//  Arguments:  [ids]        - string to load
//              [wszBuf]     - buffer for string
//              [cchBuf]     - size of buffer
//              [wszDefault] - NULL or string to use if load fails
//
//  Returns:    S_OK or error from LoadString
//
//  Modifies:   *[wszBuf]
//
//  History:    12-11-1996   DavidMun   Created
//
//  Notes:      If the load fails and no default is supplied, [wszBuf] is
//              set to an empty string.
//
//---------------------------------------------------------------------------

HRESULT
LoadStr(
    ULONG ids,
    LPWSTR wszBuf,
    ULONG cchBuf,
    LPCWSTR wszDefault)
{
    HRESULT hr = S_OK;
    ULONG cchLoaded;

    cchLoaded = LoadString(g_hinst, ids, wszBuf, cchBuf);

    if (!cchLoaded)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        Dbg(DEB_ERROR,
            "Error %uL loading string id %uL, hinst %#x\n",
            GetLastError(),
            ids,
            g_hinst);

        if (wszDefault)
        {
            lstrcpyn(wszBuf, wszDefault, cchBuf);
        }
        else
        {
            *wszBuf = L'\0';
        }
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   CoTaskDupStr
//
//  Synopsis:   Allocate a copy of [wzSrc] using CoTaskMemAlloc.
//
//  Arguments:  [ppwzDup] - filled with pointer to copy of [wszSrc].
//              [wszSrc]  - string to copy
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  Modifies:   *[ppwzDup]
//
//  History:    06-03-1998   DavidMun   Created
//
//  Notes:      Caller must CoTaskMemFree string
//
//---------------------------------------------------------------------------

HRESULT
CoTaskDupStr(
    PWSTR *ppwzDup,
    PCWSTR wzSrc)
{
    HRESULT hr = S_OK;

    *ppwzDup = (PWSTR) CoTaskMemAlloc(sizeof(WCHAR) *
                                            (lstrlen(wzSrc) + 1));

    if (*ppwzDup)
    {
        lstrcpy(*ppwzDup, wzSrc);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(hr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   ReadFindOrFilterValues
//
//  Synopsis:   Read the values that appear in both the find dialog and
//              filter propsheet page, putting them into [pffb].
//
//  Arguments:  [hwnd]     - find dialog or filter page
//              [pSources] - sources object for log to which dialog refers
//              [pffb]     - pointer to object that receives settings
//
//  Returns:    TRUE  - data is valid
//              FALSE - data is not valid (eventid is not a number)
//
//  History:    3-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
ReadFindOrFilterValues(
    HWND hwnd,
    CSources *pSources,
    CFindFilterBase *pffb)
{
    BOOL fOk = TRUE;

    //
    // Read the source value from the combobox and put that in the filter.
    // If it's (All), then there's no filtering on either source or
    // category.  Otherwise there's filtering on the source, and possibly
    // also the category.
    //

    WCHAR wszSource[CCH_SOURCE_NAME_MAX];

    GetDlgItemText(hwnd,
                   filter_source_combo,
                   wszSource,
                   CCH_SOURCE_NAME_MAX);

    if (!lstrcmp(wszSource, g_wszAll))
    {
        pffb->SetSource(NULL);
        pffb->SetCategory(0);
    }
    else
    {
        pffb->SetSource(wszSource);

        //
        // Read the category value from the category combo and put that in
        // the filter.  If it's (All), then there's no filtering on
        // category.
        //

        WCHAR wszCategory[CCH_CATEGORY_MAX];

        GetDlgItemText(hwnd,
                       filter_category_combo,
                       wszCategory,
                       CCH_CATEGORY_MAX);

        if (!lstrcmp(wszCategory, g_wszAll))
        {
            pffb->SetCategory(0);
        }
        else
        {
            CCategories *pCategories = pSources->GetCategories(wszSource);

            if (pCategories)
            {
                pffb->SetCategory(pCategories->GetValue(wszCategory));
            }
            else
            {
                //
                // On failure, degrade to matching all categories
                //

                pffb->SetCategory(0);
            }
        }
    }

    //
    // Convert the checked type checkboxes to event type bits and set the
    // filter type.
    //

    ULONG flType = 0;

    if (IsWindowEnabled(GetDlgItem(hwnd, filter_error_ckbox)) &&
        IsDlgButtonChecked(hwnd, filter_error_ckbox))
    {
        flType |= EVENTLOG_ERROR_TYPE;
    }

    if (IsWindowEnabled(GetDlgItem(hwnd, filter_warning_ckbox)) &&
        IsDlgButtonChecked(hwnd, filter_warning_ckbox))
    {
        flType |= EVENTLOG_WARNING_TYPE;
    }

    if (IsWindowEnabled(GetDlgItem(hwnd, filter_information_ckbox)) &&
        IsDlgButtonChecked(hwnd, filter_information_ckbox))
    {
        // EricB 9/25/01 470346 EVENTLOG_SUCCESS is ignored. So add it such that it is
        // treated as a synonym for information.
        flType |= EVENTLOG_INFORMATION_TYPE | EVENTLOG_SUCCESS;
    }

    if (IsWindowEnabled(GetDlgItem(hwnd, filter_success_ckbox)) &&
        IsDlgButtonChecked(hwnd, filter_success_ckbox))
    {
        flType |= EVENTLOG_AUDIT_SUCCESS;
    }

    if (IsWindowEnabled(GetDlgItem(hwnd, filter_failure_ckbox)) &&
        IsDlgButtonChecked(hwnd, filter_failure_ckbox))
    {
        flType |= EVENTLOG_AUDIT_FAILURE;
    }

    pffb->SetType(flType);

    //
    // Set the filter's user name
    //

    {
        WCHAR wszUser[CCH_USER_MAX];

        GetDlgItemText(hwnd,
                       filter_user_edit,
                       wszUser,
                       CCH_USER_MAX);
        pffb->SetUser(wszUser);
    }

    //
    // Set the computer name
    //

    {
        WCHAR wszComputer[CCH_COMPUTER_MAX];

        GetDlgItemText(hwnd,
                       filter_computer_edit,
                       wszComputer,
                       CCH_COMPUTER_MAX);
        pffb->SetComputer(wszComputer);
    }

    //
    // Set the event ID
    //


    if (!GetWindowTextLength(GetDlgItem(hwnd, filter_eventid_edit)))
    {
        pffb->SetEventID(FALSE, 0);
    }
    else
    {
        ULONG ulEventID;
        BOOL fValidNumber;

        ulEventID = GetDlgItemInt(hwnd,
                                  filter_eventid_edit,
                                  &fValidNumber,
                                  FALSE);

        if (fValidNumber)
        {
            pffb->SetEventID(TRUE, ulEventID);
        }
        else
        {
            // JonN 4/12/01 367216
            HWND hwndEdit = GetDlgItem(hwnd,filter_eventid_edit);
            Edit_SetSel(hwndEdit, 0, -1);
            SetFocus(hwndEdit);
            MsgBox(hwnd, IDS_INVALID_EVENTID, MB_ICONERROR | MB_OK);
            fOk = FALSE;
        }
    }

    return fOk;
}




//+--------------------------------------------------------------------------
//
//  Function:   ReadString
//
//  Synopsis:   Read a counted null terminated WCHAR string from [pStm]
//              into [pwsz].
//
//  Arguments:  [pStm] - stream positioned at counted null-terminated str.
//              [pwsz] - string buffer to fill
//
//  Returns:    HRESULT from pStm->Read
//
//  Modifies:   *[pwsz]
//
//  History:    12-11-1996   DavidMun   Created
//
//  Notes:      It is assumed that [pwsz] is large enough to hold the
//              string read.
//  Modifies:   Add cwch for #256032. 1/25/2001.
//---------------------------------------------------------------------------

HRESULT
ReadString(
    IStream *pStm,
    LPWSTR pwsz,
    USHORT cwch)
{
    USHORT cch = 0;
    HRESULT hr = pStm->Read(&cch, sizeof cch, NULL);
    CHECK_HRESULT(hr);

    if(cch >= cwch)
    {
        // NTRAID#NTBUG9-2002/05/17-623723-ericb: prefast
        LPWSTR pwszTemp = (LPWSTR)malloc(cch * sizeof(WCHAR));
        if (!pwszTemp)
        {
            hr = E_OUTOFMEMORY;
            CHECK_HRESULT(hr);
        }

        if (pwszTemp && SUCCEEDED(hr))
        {
            hr = pStm->Read(pwszTemp, cch * sizeof(WCHAR), NULL);
            CHECK_HRESULT(hr);
            ASSERT( L'\0' == pwszTemp[cch-1] );
            pwszTemp[cch-1] = L'\0';
            wcsncpy(pwsz, pwszTemp, cwch-1);
            *(pwsz+cwch-1) = L'\0';
        }

        if (pwszTemp) // 653900-2002/07/08-JonN PREFIX
        {
            free(pwszTemp);
        }
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            hr = pStm->Read(pwsz, cch * sizeof(WCHAR), NULL);
            CHECK_HRESULT(hr);
        }
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   RemoteFileToServerAndUNCPath
//
//  Synopsis:   If [wszPath] specifies a redirected drive path or UNC path,
//              put the server name in [wszServer] and the UNC path in
//              [wszUNCPath].
//
//  Arguments:  [wszPath]     - path to convert
//              [wszServer]   - filled with server name
//              [wszUNCPath]  - filled with unc path, NULL if not needed
//
//  Returns:    S_OK    - conversion succeeded
//              E_FAIL  - WNetGetUniversalName failed
//              S_FALSE - [wszPath] is a local path
//
//  Modifies:   *[wszServer], *[wszUNCPath]
//
//  History:    4-01-1997   DavidMun   Created
//
//  Modifies:   For bug 256032. Add USHORT wcchServer, USHORT wcchUNCPath.
//              1-24-2001. 
//---------------------------------------------------------------------------

HRESULT
RemoteFileToServerAndUNCPath(
    LPCWSTR wszPath,
    LPWSTR wszServer,
    USHORT wcchServer,
    LPWSTR wszUNCPath,
    USHORT wcchUNCPath)
{
    HRESULT hr = S_OK;

    WCHAR wszDrive[] = L"c:\\"; // reserve space
    wszDrive[0] = wszPath[0];   // use correct drive letter

    if (wszPath[0] == L'\\' && wszPath[1] == L'\\')
    {
        GetUncServer(wszPath, wszServer, wcchServer);
        if (wszUNCPath)
        {
            wcsncpy(wszUNCPath, wszPath, wcchUNCPath-1);
            *(wszUNCPath+wcchUNCPath-1) = L'\0';
        }
    }
    else if (IsDriveLetter(wszPath[0]) &&
             wszPath[1] == L':'        &&
             GetDriveType(wszDrive) == DRIVE_REMOTE)
    {
        BYTE  abBuf[sizeof(WCHAR) * (MAX_PATH + 1) + sizeof(UNIVERSAL_NAME_INFO) + 1];
        ULONG cbBuf = sizeof(abBuf);
        DWORD dw;

        dw = WNetGetUniversalName(wszPath,
                                  UNIVERSAL_NAME_INFO_LEVEL,
                                  (LPVOID) abBuf,
                                  &cbBuf);

        if (dw == NO_ERROR)
        {
            LPWSTR pwszUNC = ((UNIVERSAL_NAME_INFO *)abBuf)->lpUniversalName;
            ASSERT((PBYTE)pwszUNC > abBuf && (PBYTE)pwszUNC < (abBuf + cbBuf));
            GetUncServer(pwszUNC, wszServer, wcchServer);
            if (wszUNCPath)
            {
                wcsncpy(wszUNCPath, pwszUNC, wcchUNCPath-1);
                *(wszUNCPath+wcchUNCPath-1) = L'\0';
            }
        }
        else
        {
            hr = E_FAIL;
            Dbg(DEB_ERROR,
                "RemoteFileToServerAndUNCPath: WNetGetUniversalName <%uL>\n",
                dw);
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Function:   SecondsSince1970ToSystemTime
//
//  Synopsis:   Converts time value
//
//  Arguments:  [dwSecondsSince1970] - time to convert
//              [pSystemTime]        - filled with local time version of
//                                      [dwSecondsSince1970].
//
//  Returns:    TRUE  - *[pSystemTime] valid
//              FALSE - conversion failed
//
//  Modifies:   *[pSystemTime]
//
//  History:    12-09-1996   DavidMun   Copied from RaviR's alert log code
//
//---------------------------------------------------------------------------

BOOL
SecondsSince1970ToSystemTime(
    IN  DWORD       dwSecondsSince1970,
    OUT SYSTEMTIME *pSystemTime)
{
    //  Seconds since the start of 1970 -> 64 bit Time value

    LARGE_INTEGER liTime;

    RtlSecondsSince1970ToTime(dwSecondsSince1970, &liTime);

    //
    //  The time is in UTC. Convert it to local file time.
    //

    FILETIME ftUTC;

    ftUTC.dwLowDateTime  = liTime.LowPart;
    ftUTC.dwHighDateTime = liTime.HighPart;

    FILETIME ftLocal;

    if (FileTimeToLocalFileTime(&ftUTC, &ftLocal) == FALSE)
    {
        DBG_OUT_LASTERROR;
        return FALSE;
    }

    //
    //  Convert local file time to system time.
    //

    if (FileTimeToSystemTime(&ftLocal, pSystemTime) == FALSE)
    {
        DBG_OUT_LASTERROR;
        return FALSE;
    }

    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Function:   SystemTimeToSecondsSince1970
//
//  Synopsis:   Converts time value
//
//  Arguments:  [pSystemTime]         - system time to convert
//              [pulSecondsSince1970] - filled with converted value
//
//  Returns:    TRUE on success, FALSE on failure
//
//  Modifies:   *[pulSecondsSince1970]
//
//  History:    1-13-1997   DavidMun   Copied from RaviR's alert log code
//
//---------------------------------------------------------------------------

BOOL
SystemTimeToSecondsSince1970(
    IN  SYSTEMTIME * pSystemTime,
    OUT ULONG      * pulSecondsSince1970)
{
    FILETIME ftLocal;

    if (SystemTimeToFileTime(pSystemTime, &ftLocal) == FALSE)
    {
        DBG_OUT_LASTERROR;
        return FALSE;
    }

    FILETIME ftUTC;

    if (LocalFileTimeToFileTime(&ftLocal, &ftUTC) == FALSE)
    {
        DBG_OUT_LASTERROR;
        return FALSE;
    }

    LARGE_INTEGER liTime;

    liTime.LowPart  = ftUTC.dwLowDateTime;
    liTime.HighPart = ftUTC.dwHighDateTime;

    if (RtlTimeToSecondsSince1970(&liTime, pulSecondsSince1970) == FALSE)
    {
        DBG_OUT_LASTERROR;
        return FALSE;
    }

    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Function:   WriteString
//
//  Synopsis:   Write length (including null terminator), in WCHARS, of
//              [pwsz], followed by the string and its terminator to
//              stream [pStm].
//
//  Arguments:  [pStm] - open IStream to write to
//              [pwsz] - string to write
//
//  Returns:    HRESULT from pStm->Write
//
//  History:    12-11-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
WriteString(
    IStream *pStm,
    LPCWSTR pwsz)
{
    USHORT cch = static_cast<USHORT>(lstrlen(pwsz) + 1);
    HRESULT hr = pStm->Write(&cch, sizeof cch, NULL);
    CHECK_HRESULT(hr);

    if (SUCCEEDED(hr))
    {
        hr = pStm->Write(pwsz, cch * sizeof(WCHAR), NULL);
        CHECK_HRESULT(hr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   CopyStrippingLeadTrailSpace
//
//  Synopsis:   Make a copy of [wszSrc] in [wszDest], less any leading and
//              trailing spaces.
//
//  Arguments:  [wszDest] - destination buffer
//              [wszSrc]  - string to copy
//              [cchDest] - size, in characters of destination buffer
//
//  Modifies:   *[wszDest]
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CopyStrippingLeadTrailSpace(
    LPWSTR wszDest,
    LPCWSTR wszSrc,
    ULONG cchDest)
{
    LPCWSTR pwszFirstNonSpace = wszSrc + wcsspn(wszSrc, L" ");
    lstrcpyn(wszDest, pwszFirstNonSpace, cchDest);

    LPWSTR pwszFirstTrailingSpace = NULL;

    for (LPWSTR pwsz = wszDest; *pwsz; pwsz++)
    {
        if (*pwsz == ' ')
        {
            if (!pwszFirstTrailingSpace)
            {
                pwszFirstTrailingSpace = pwsz;
            }
        }
        else
        {
            pwszFirstTrailingSpace = NULL;
        }
    }

    if (pwszFirstTrailingSpace)
    {
        *pwszFirstTrailingSpace = L'\0';
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   ClearFindOrFilterDlg
//
//  Synopsis:   Reset the dialog controls which are common to both the find
//              dialog and the filter property sheet.
//
//  Arguments:  [hwnd]     - handle to find dlg or filter prsht
//              [pSources] - sources object for current log
//
//  History:    3-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
ClearFindOrFilterDlg(
    HWND hwnd,
    CSources *pSources)
{
    //
    // Set the source combo to (All).  Once that's done, the types and
    // categories can be set based on that.
    //

    ComboBox_SelectString(GetDlgItem(hwnd, filter_source_combo),
                          -1,
                          g_wszAll);
    SetCategoryCombobox(hwnd, pSources, NULL, 0);
    SetTypesCheckboxes(hwnd, pSources, ALL_LOG_TYPE_BITS);

    //
    // Clear the user, computer, and event ID edit controls
    //

    SetDlgItemText(hwnd, filter_user_edit,     L"");
    SetDlgItemText(hwnd, filter_computer_edit, L"");
    SetDlgItemText(hwnd, filter_eventid_edit,  L"");
}





#define MAX_MESSAGEBOX_STR  512

//+--------------------------------------------------------------------------
//
//  Function:   ConsoleMsgBox
//
//  Synopsis:   Pop up a console-modal message box using IConsole::MessageBox
//
//  Arguments:  [pConsole] - IConsole pointer
//              [idsMsg]   - id of message to display
//              [flags]    - MB_*
//              [...]      - args for printf-style message str
//
//  Returns:    Out value from IConsole::MessageBox.
//
//  History:    02-18-1997   DavidMun   Created
//              06-03-1997   DavidMun   match iconsole::messagebox parameter
//                                       order change
//
//---------------------------------------------------------------------------

INT __cdecl
ConsoleMsgBox(
    IConsole *pConsole,
    ULONG idsMsg,
    ULONG flags,
    ...)
{
    WCHAR wszFmt[MAX_MESSAGEBOX_STR];
    WCHAR wszMessage[MAX_MESSAGEBOX_STR];
    WCHAR wszTitle[MAX_MESSAGEBOX_STR];

    LoadStr(idsMsg, wszFmt, ARRAYLEN(wszFmt));
    LoadStr(IDS_VIEWER, wszTitle, ARRAYLEN(wszTitle));

    va_list varArgs;
    va_start(varArgs, flags);
    _vsnwprintf(wszMessage, ARRAYLEN(wszMessage), wszFmt, varArgs);
    wszMessage[ARRAYLEN(wszMessage) - 1] = '\0';
    va_end(varArgs);

    HRESULT hr;
    INT iResult;
    hr = pConsole->MessageBox(wszMessage, wszTitle, flags, &iResult);
    CHECK_HRESULT(hr);

    return iResult;
}




//+--------------------------------------------------------------------------
//
//  Function:   FileExists
//
//  Synopsis:   Return TRUE if the specified file exists, FALSE otherwise.
//
//  History:    4-03-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
FileExists(
    LPCWSTR wszFileName)
{
    HANDLE hFile;

    hFile = CreateFile(wszFileName,
                       0,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }
    VERIFY(CloseHandle(hFile));
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Function:   FindFirstTrailingSpace
//
//  Synopsis:   Return a pointer to the first trailing space in [pwsz].
//
//  History:    11-22-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

LPCWSTR
FindFirstTrailingSpace(
    LPCWSTR pwsz)
{
    LPCWSTR pwszFirstTrailingSpace = NULL;
    LPCWSTR pwszCur;

    for (pwszCur = pwsz; *pwszCur; pwszCur++)
    {
        if (*pwszCur == ' ' || *pwszCur == '\t')
        {
            if (!pwszFirstTrailingSpace)
            {
                pwszFirstTrailingSpace = pwszCur;
            }
        }
        else if (pwszFirstTrailingSpace)
        {
            pwszFirstTrailingSpace = NULL;
        }
    }
    return pwszFirstTrailingSpace;
}





//+---------------------------------------------------------------------------
//
//  Function:   FormatNumber
//
//  Synopsis:   Format a number. Insert separators ( ',' or '.', probably )
//              every three digits in a number (thousands, millions, etc).
//
//  Arguments:  [ulNumber]  -- number to format
//              [pBuffer]   -- buffer to fill with the formatted number
//              [cchBuffer] -- size of the buffer in characters
//
//  Returns:    0 on success. If the target buffer is too small, returns
//              the size (in characters) needed for the target buffer.
//
//  History:    1-Jun-94   BruceFo   Created
//
//----------------------------------------------------------------------------

UINT
FormatNumber(
    ULONG ulNumber,
    PWSTR pBuffer,
    ULONG cchBuffer)
{
    WCHAR szSeparator[10];

    if (0 == GetLocaleInfo(
                    GetUserDefaultLCID(),
                    LOCALE_STHOUSAND,
                    szSeparator,
                    ARRAYLEN(szSeparator)))
    {
        // Couldn't get the thousands separator, so make the number unseparated

        szSeparator[0] = L'\0';
    }

    ULONG cchSeparator = static_cast<ULONG>(wcslen(szSeparator));
    WCHAR pszNumber[99];           // a ULONG can never need this many digits!
    PWSTR pszCurrent = pszNumber;
    ULONG cDigits;
    ULONG cStrays;

    wsprintf(pszNumber, L"%lu", ulNumber);
    cDigits = static_cast<ULONG>(wcslen(pszNumber));
    cStrays = cDigits % 3;

    ULONG cchSizeNeeded = cDigits + ((cDigits - 1) / 3) * cchSeparator + 1;
    if (cchSizeNeeded > cchBuffer)
    {
        // buffer passed in isn't big enough...

        return cchSizeNeeded;
    }

    if (szSeparator[0] == L'\0')
    {
        // if there isn't a separator, but the buffer is big enough,
        // just copy the string. This is a special case that would be
        // handled well enough by the code below...

        wcscpy(pBuffer, pszNumber);
    }

    if (0 != cStrays)
    {
        // do the "strays" first...

        wcsncpy(pBuffer, pszCurrent, cStrays);
        pBuffer     += cStrays;
        pszCurrent += cStrays;
        cDigits     -= cStrays;

        if (cDigits > 0)
        {
            wcscpy(pBuffer, szSeparator);
            pBuffer += cchSeparator;
        }
    }

    while (cDigits > 0)
    {
        wcsncpy(pBuffer, pszCurrent, 3);
        pBuffer     += 3;
        pszCurrent += 3;
        cDigits     -= 3;

        if (cDigits > 0)
        {
            wcscpy(pBuffer, szSeparator);
            pBuffer += cchSeparator;
        }
    }

    *pBuffer = L'\0';
    return 0;           // success
}




//+--------------------------------------------------------------------------
//
//  Function:   MakeTimestamp
//
//  Synopsis:   Make a string from [pft] with the long date format followed
//              by the short date format
//
//  Arguments:  [pftUTC] - UTC time to express as string
//              [wszBuf] - buffer in which to write string
//              [cchBuf] - size, in wchars, of [wszBuf]
//
//  Modifies:   *[wszBuf]
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
MakeTimestamp(
    const FILETIME *pftUTC,
    LPWSTR wszBuf,
    ULONG   cchBuf)
{
    BOOL fOk;
    FILETIME   ftLocal;
    SYSTEMTIME st;

    wszBuf[0] = L'\0';

    do
    {
        fOk = FileTimeToLocalFileTime(pftUTC, &ftLocal);

        if (!fOk)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        fOk = FileTimeToSystemTime(&ftLocal, &st);

        if (!fOk)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        ULONG cch;

        cch = GetDateFormat(LOCALE_USER_DEFAULT,
                            DATE_LONGDATE,
                            &st,
                            NULL,
                            wszBuf,
                            cchBuf);
        if (!cch)
        {
            fOk = FALSE;
            DBG_OUT_LASTERROR;
            break;
        }

        if (cchBuf - cch < 5)
        {
            // won't be enough for time, just give up.
            break;
        }

        wszBuf[cch - 1] = L' ';

        cch = GetTimeFormat(LOCALE_USER_DEFAULT,
                            0,
                            &st,
                            NULL,
                            &wszBuf[cch],
                            cchBuf - cch);

        if (!cch)
        {
            fOk = FALSE;
            DBG_OUT_LASTERROR;
            break;
        }

    } while (0);

    if (!fOk)
    {
        *wszBuf = L'\0';
    }
}



//+--------------------------------------------------------------------------
//
//  Function:   MsgBox
//
//  Synopsis:   Pop up a messagebox with parent window [hwnd], title
//              IDS_VIEWER, and message [idsMsg].
//
//  Arguments:  [hwnd]   - parent window, may be NULL
//              [idsMsg] - resource id of printf-style message line
//              [flags]  - MB_* flags for MessageBox
//              [...]    - args for wsprintf
//
//  Returns:    Return value of MessageBox.
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

INT __cdecl
MsgBox(
    HWND hwnd,
    ULONG idsMsg,
    ULONG flags,
    ...)
{
    WCHAR wszFmt[MAX_MESSAGEBOX_STR];
    WCHAR wszMessage[MAX_MESSAGEBOX_STR];
    WCHAR wszTitle[MAX_MESSAGEBOX_STR];

    LoadStr(idsMsg, wszFmt, ARRAYLEN(wszFmt));
    LoadStr(IDS_VIEWER, wszTitle, ARRAYLEN(wszTitle));

    va_list varArgs;
    va_start(varArgs, flags);
    _vsnwprintf(wszMessage, ARRAYLEN(wszMessage), wszFmt, varArgs);
    wszMessage[ARRAYLEN(wszMessage) - 1] = '\0';
    va_end(varArgs);

    return MessageBox(hwnd, wszMessage, wszTitle, flags);
}




//+--------------------------------------------------------------------------
//
//  Function:   SetCategoryCombobox
//
//  Synopsis:   Initialize the combobox that holds categories
//
//  Arguments:  [hwnd]       - window containing category combo
//              [pSources]   - contains source/category info for cur log
//              [pwszSource] - source selected in combo
//              [usCategory] - 0 or category to select in combo
//
//  History:    3-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
SetCategoryCombobox(
    HWND    hwnd,
    CSources *pSources,
    LPCWSTR pwszSource,
    USHORT usCategory)
{
    HWND  hwndCategoryCombo = GetDlgItem(hwnd, filter_category_combo);

    //
    // Set the contents of the categories combobox according to the
    // selection in the sources combobox.
    //
    // If the selection in the sources combo is (All), the contents
    // of the categories combo remains (All).
    //
    // Otherwise if the source selected in the sources box has its
    // own category list, the contents of the category box become
    // that list.
    //
    // Otherwise if there is a default subkey and that subkey has
    // a category list, the contents of the category box become
    // that list.
    //
    // (A default subkey is a subkey with the same name as the log
    // key.  For example, the Security log has a subkey named Security.)
    //

    ComboBox_ResetContent(hwndCategoryCombo);
    ComboBox_AddString(hwndCategoryCombo, g_wszAll);

    if (pwszSource)
    {
        CCategories *pCategories;

        pCategories = pSources->GetCategories(pwszSource);

        if (pCategories && pCategories->GetCount())
        {
            for (ULONG i = 1; i <= pCategories->GetCount(); i++)
            {
                ComboBox_AddString(hwndCategoryCombo,
                                   pCategories->GetName(i));
            }

            if (usCategory)
            {
                ComboBox_SelectString(hwndCategoryCombo,
                                      -1,
                                      pCategories->GetName(usCategory));
            }
            else
            {
                ComboBox_SelectString(hwndCategoryCombo, -1, g_wszAll);
            }
        }
        else
        {
            ComboBox_SelectString(hwndCategoryCombo, -1, g_wszAll);
        }
    }
    else
    {
        ComboBox_SelectString(hwndCategoryCombo, -1, g_wszAll);
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   SetTypesCheckboxes
//
//  Synopsis:   Enable/disable and check/uncheck the event log type
//              checkboxes to match those supported by the current source
//              and selected in [flTypes].
//
//  Arguments:  [hwnd]     - handle to find dialog or filter propsheet
//              [pSources] - contains cat/src info for cur log
//              [flTypes]  - bitwise OR of EVENTLOG_* type bits.
//
//  History:    3-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
SetTypesCheckboxes(
    HWND      hwnd,
    CSources *pSources,
    ULONG     flTypes)
{
    HWND hwndSourceCombo = GetDlgItem(hwnd, filter_source_combo);
    ULONG flSupported;
    WCHAR wszSource[CCH_SOURCE_NAME_MAX];

    ComboBox_GetText(hwndSourceCombo, wszSource, CCH_SOURCE_NAME_MAX);

    //
    // If the source selected is (All), then all types are supported, even
    // if the default subkey specifies something different.
    //

    if (!lstrcmp(wszSource, g_wszAll))
    {
        flSupported = ALL_LOG_TYPE_BITS;
    }
    else
    {
        flSupported = pSources->GetTypesSupported(wszSource);
    }

    EnableWindow(GetDlgItem(hwnd, filter_error_ckbox),
                 (flSupported & EVENTLOG_ERROR_TYPE));

    EnableWindow(GetDlgItem(hwnd, filter_warning_ckbox),
                 (flSupported & EVENTLOG_WARNING_TYPE));

    EnableWindow(GetDlgItem(hwnd, filter_information_ckbox),
                 (flSupported & EVENTLOG_INFORMATION_TYPE));

    EnableWindow(GetDlgItem(hwnd, filter_success_ckbox),
                 (flSupported & EVENTLOG_AUDIT_SUCCESS));

    EnableWindow(GetDlgItem(hwnd, filter_failure_ckbox),
                 (flSupported & EVENTLOG_AUDIT_FAILURE));

    //
    // Set the Type checkboxes, forcing those that are not supported to
    // unchecked.
    //

    ULONG flSupportedCheckedType = flTypes & flSupported;

    if (flSupportedCheckedType & EVENTLOG_ERROR_TYPE)
    {
        CheckDlgButton(hwnd, filter_error_ckbox, BST_CHECKED);
    }
    else
    {
        CheckDlgButton(hwnd, filter_error_ckbox, BST_UNCHECKED);
    }

    if (flSupportedCheckedType & EVENTLOG_WARNING_TYPE)
    {
        CheckDlgButton(hwnd, filter_warning_ckbox, BST_CHECKED);
    }
    else
    {
        CheckDlgButton(hwnd, filter_warning_ckbox, BST_UNCHECKED);
    }

    if (flSupportedCheckedType & EVENTLOG_INFORMATION_TYPE)
    {
        CheckDlgButton(hwnd, filter_information_ckbox, BST_CHECKED);
    }
    else
    {
        CheckDlgButton(hwnd, filter_information_ckbox, BST_UNCHECKED);
    }

    if (flSupportedCheckedType & EVENTLOG_AUDIT_SUCCESS)
    {
        CheckDlgButton(hwnd, filter_success_ckbox, BST_CHECKED);
    }
    else
    {
        CheckDlgButton(hwnd, filter_success_ckbox, BST_UNCHECKED);
    }

    if (flSupportedCheckedType & EVENTLOG_AUDIT_FAILURE)
    {
        CheckDlgButton(hwnd, filter_failure_ckbox, BST_CHECKED);
    }
    else
    {
        CheckDlgButton(hwnd, filter_failure_ckbox, BST_UNCHECKED);
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   StripLeadTrailSpace
//
//  Synopsis:   Delete leading and trailing spaces from [pwsz].
//
//  History:    11-22-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
StripLeadTrailSpace(
    LPWSTR pwsz)
{
    ULONG cchLeadingSpace = static_cast<ULONG>(wcsspn(pwsz, L" \t"));
    ULONG cch = lstrlen(pwsz);

    //
    // If there are any leading spaces or tabs, move the string
    // (including its null terminator) left to delete them.
    //

    if (cchLeadingSpace)
    {
        MoveMemory(pwsz,
                   pwsz + cchLeadingSpace,
                   (cch - cchLeadingSpace + 1) * sizeof(TCHAR));
        cch -= cchLeadingSpace;
    }

    //
    // Terminate at the first trailing space
    //

    LPWSTR pwszTrailingSpace = (LPWSTR) FindFirstTrailingSpace(pwsz);

    if (pwszTrailingSpace)
    {
        *pwszTrailingSpace = L'\0';
    }
}



//+--------------------------------------------------------------------------
//
//  Function:   CanonicalizeComputername
//
//  Synopsis:   Remove blanks, optionally add leading backslashes, and
//              verify [pwszMachineName].
//
//  Arguments:  [pwszMachineName] - computer name
//              [fAddWhackWhack]  - TRUE=>prefix result with backslashes
//
//  Returns:    S_OK
//              E_INVALIDARG
//              HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)
//
//  Modifies:   *[pwszMachineName]
//
//  History:    07-30-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CanonicalizeComputername(
    LPWSTR pwszMachineName,
    BOOL fAddWhackWhack)
{
    HRESULT hr = S_OK;
    WCHAR   wszTemp[MAX_PATH] = L"";

    do
    {
        //
        // Remove leading and trailing blanks.  If that leaves us with an
        // empty string, we're done.
        //

        PathRemoveBlanks(pwszMachineName);

        if (!*pwszMachineName)
        {
            break;
        }

        //
        // Remove the \\ at the beginning of name
        //

        ULONG cchMachineName = lstrlen(pwszMachineName);

        if (cchMachineName >= 2         &&
            L'\\' == pwszMachineName[0] &&
            L'\\' == pwszMachineName[1])
        {
            //
            // Move everything after the \\, including the terminating null, left
            // by two wchars.
            //

            MoveMemory(pwszMachineName,
                       pwszMachineName + 2,
                       (cchMachineName - 1) * sizeof(WCHAR));
        }

        //
        // Validate and canonicalize the name.
        //

        NET_API_STATUS err = I_NetNameValidate(NULL,
                                               pwszMachineName,
                                               NAMETYPE_COMPUTER,
                                               0L);

        if (NERR_Success != err)
        {
            hr = E_INVALIDARG;
            break;
        }

        ASSERT(cchMachineName < MAX_PATH);

        err = I_NetNameCanonicalize(NULL,
                                    pwszMachineName,
                                    wszTemp,
                                    MAX_PATH * sizeof(WCHAR),
                                    NAMETYPE_COMPUTER,
                                    0L);

        if (NERR_Success != err)
        {
            hr = E_INVALIDARG;
            break;
        }

        //
        // If caller wants \\ at front of machine name, add it as long as the
        // machine name isn't an empty string.
        //

        if (fAddWhackWhack && wszTemp[0])
        {
            if (lstrlen(wszTemp) > MAX_PATH - 2)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
            else
            {
                lstrcpy(pwszMachineName, L"\\\\");
                lstrcpy(pwszMachineName + 2, wszTemp);
            }
        }
        else
        {
            lstrcpy(pwszMachineName, wszTemp);
        }
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   ChildDialogEnumCallback
//
//  Synopsis:   Destroy [hwndChild] if it's a dialog window with caption
//              "Event Viewer".
//
//  Arguments:  [hwndChild] - child window
//              [lParam]    - unused
//
//  Returns:    TRUE (continue enumeration)
//
//  History:    06-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL CALLBACK
ChildDialogEnumCallback(
    HWND hwndChild,
    LPARAM lParam)
{
    WCHAR wszClassName[MAX_PATH];
    WCHAR wszCaption[MAX_PATH];

    GetClassName(hwndChild,
                 wszClassName,
                 ARRAYLEN(wszClassName));

    GetWindowText(hwndChild,
                  wszCaption,
                  ARRAYLEN(wszCaption));

    if (!lstrcmp(wszClassName, L"#32770") &&
        !lstrcmp(wszCaption, g_wszEventViewer))
    {
        Dbg(DEB_TRACE,
            "ChildDialogEnumCallback: destroying hwnd 0x%x\n",
            hwndChild);

        if (!DestroyWindow(hwndChild))
        {
            DBG_OUT_LASTERROR;
        }
    }

    //
    // continue until all child windows have been enumerated
    //

    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Function:   CloseEventViewerChildDialogs
//
//  Synopsis:   Destroy all child windows of this thread having dialog
//              class and caption "Event Viewer".
//
//  History:    06-20-1997   DavidMun   Created
//
//  Notes:      This routine is called to close any message boxes that may
//              have been opened by a dialog that needs to close.
//
//---------------------------------------------------------------------------

VOID
CloseEventViewerChildDialogs()
{
    TRACE_FUNCTION(CloseEventViewerChildDialogs);

    EnumThreadWindows(GetCurrentThreadId(), ChildDialogEnumCallback, NULL);
}



wstring
load_wstring(int resID)
{
   static const int TEMP_LEN = 512;
   wstring::value_type temp[TEMP_LEN];

#if (DBG == 1)
   HRESULT hr =
#endif // (DBG == 1)
       LoadStr(resID, temp, TEMP_LEN, 0);
   ASSERT(SUCCEEDED(hr));

   return temp;
}



wstring
GetSystemErrorMessage(int iErrorCode)
{
    wstring strMessage;
    ULONG   ulFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER
                    |  FORMAT_MESSAGE_IGNORE_INSERTS
                    |  FORMAT_MESSAGE_FROM_SYSTEM;
    PWSTR   pwszMessage = NULL;

    FormatMessage(ulFlags,
                  NULL,
                  iErrorCode,
                  0,
                  (LPTSTR) &pwszMessage,
                  0,
                  0);

    if (pwszMessage)
    {
        strMessage = pwszMessage;
        LocalFree(pwszMessage);
    }
    else
    {
        DBG_OUT_LASTERROR;
    }

    if (strMessage.empty())
    {
        strMessage = load_wstring(IDS_UNKNOWN_ERROR_CODE);
    }

    return strMessage;
}



wstring __cdecl
FormatString(unsigned formatResID, ...)
{
   wstring format = load_wstring(formatResID);

   va_list arg_list;
   va_start(arg_list, formatResID);
   LPTSTR temp = 0;
   if (
      ::FormatMessage(
         FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
         format.c_str(),
         0,
         0,
         (LPTSTR) &temp,
         0,
         &arg_list))
   {
      wstring retval(temp);
      ::LocalFree(temp);
      va_end(arg_list);
      return retval;
   }

   va_end(arg_list);
   return wstring();
}



wstring
ComposeErrorMessgeFromHRESULT(HRESULT hr)
{
   ASSERT(FAILED(hr));

   wstring result;
   if (FAILED(hr))
   {
      if (HRESULT_FACILITY(hr) == FACILITY_WIN32)
      {
         result = GetSystemErrorMessage(HRESULT_CODE(hr));
      }
      else
      {
         result = FormatString(IDS_HRESULT_SANS_MESSAGE, hr);
      }
   }

   return result;
}



//+--------------------------------------------------------------------------
//
//  Function:   wcsistr
//
//  Synopsis:   Wide character case insensitive substring search.
//
//  Arguments:  [pwzSearchIn]  - string to look in
//              [pwzSearchFor] - substring to look for
//
//  Returns:    Pointer to first occurence of [pwzSearchFor] within
//              [pwzSearchIn], or NULL if none found.
//
//  History:    3-12-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

PWSTR
wcsistr(
    PCWSTR pwzSearchIn,
    PCWSTR pwzSearchFor)
{
    PCWSTR pwzSearchInCur;
    PCWSTR pwzSearchForCur = pwzSearchFor;

    //
    // Handle special case of search for string empty by returning
    // pointer to end of search in string.
    //

    if (!*pwzSearchFor)
    {
        return (PWSTR) (pwzSearchIn + lstrlen(pwzSearchIn));
    }

    //
    // pwzSearchFor is at least one character long.
    //

    for (pwzSearchInCur = pwzSearchIn; *pwzSearchInCur; pwzSearchInCur++)
    {
        //
        // If current char of both strings matches, advance in search
        // for string.
        //

        if (towlower(*pwzSearchInCur) == towlower(*pwzSearchForCur))
        {
            pwzSearchForCur++;

            //
            // If we just hit the end of the substring we're searching
            // for, then we've found a match.  The start of the match
            // is at the current location of the search in pointer less
            // the length of the substring we just matched, plus 1 since
            // we haven't advanced pwzSearchInCur past the last matching
            // character yet.
            //

            if (!*pwzSearchForCur)
            {
                return (PWSTR)(pwzSearchInCur - lstrlen(pwzSearchFor) + 1);
            }
        }
        else
        {
            //
            // Mismatch, start searching from the beginning of
            // the search for string again.
            //

            pwzSearchForCur = pwzSearchFor;
        }
    }

    return NULL;
}

// JonN 3/21/01 moved from eventmsg.cxx
wstring
GetComputerNameAsString()
{
   TCHAR buf[MAX_COMPUTERNAME_LENGTH + 1];
   ::ZeroMemory( buf, sizeof(buf) );
   DWORD capacity = ARRAYLEN(buf);

   VERIFY( ::GetComputerNameW(buf, &capacity) );

   return buf;
}

// JonN 9/4/01 463889
wstring
GetNetbiosComputerNameAsString(LPCWSTR pwzComputerName)
{
   WKSTA_INFO_100 *pWksta100 = NULL;
   PWSTR pwszNetbios = L""; // JonN 9/26/01 472654

   ULONG ulResult = NetWkstaGetInfo(const_cast<LPWSTR>(pwzComputerName),
                  100,
                  (PBYTE*)&pWksta100);

   if (ulResult == NERR_Success)
   {
       pwszNetbios = pWksta100->wki100_computername;
   }
   else
   {
       DBG_OUT_LRESULT(ulResult);
   }

   wstring retval = pwszNetbios;

   if (pWksta100)
   {
      NetApiBufferFree(pWksta100);
   }

   return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\types\proxy\elsp_dlldata.c ===
#include <dlldata.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\wizard.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       wizard.cxx
//
//  Contents:   Implementation of event viewer snapin manager wizard
//              property sheet page.
//
//  Classes:    CWizardPage
//
//  History:    3-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


DEBUG_DECLARE_INSTANCE_COUNTER(CWizardPage)

UINT g_cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

static ULONG
s_aulHelpIds[] =
{
    IDC_CHOOSER_STATIC,                      HCHOOSER_STATIC,
    IDC_CHOOSER_GROUP_TARGET_MACHINE,        HCHOOSER_GROUP_TARGET_MACHINE,
    IDC_CHOOSER_RADIO_LOCAL_MACHINE,         HCHOOSER_RADIO_LOCAL_MACHINE,
    IDC_CHOOSER_RADIO_SPECIFIC_MACHINE,      HCHOOSER_RADIO_SPECIFIC_MACHINE,
    IDC_CHOOSER_EDIT_MACHINE_NAME,           HCHOOSER_EDIT_MACHINE_NAME,
    IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES,  HCHOOSER_BUTTON_BROWSE_MACHINENAMES,
    IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME, HCHOOSER_CHECK_OVERRIDE_MACHINE_NAME,
    0,0
};



//+--------------------------------------------------------------------------
//
//  Member:     CWizardPage::CWizardPage
//
//  Synopsis:   ctor
//
//  Arguments:  [pcd] - parent componentdata
//
//  History:    4-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CWizardPage::CWizardPage(
    CComponentData *pcd):
        _pcd(pcd)
{
    TRACE_CONSTRUCTOR(CWizardPage);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CWizardPage);
}



//+--------------------------------------------------------------------------
//
//  Member:     CWizardPage::~CWizardPage
//
//  Synopsis:   dtor
//
//  History:    4-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CWizardPage::~CWizardPage()
{
    TRACE_DESTRUCTOR(CWizardPage);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CWizardPage);
}




VOID
CWizardPage::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    InvokeWinHelp(message, wParam, lParam, HELP_FILENAME, s_aulHelpIds);
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizardPage::_OnInit
//
//  Synopsis:   Handle property page dialog initialization.
//
//  Arguments:  [pPSP] - unused
//
//  History:    4-03-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CWizardPage::_OnInit(
    LPPROPSHEETPAGE pPSP)
{
    TRACE_METHOD(CWizardPage, _OnInit);

    //
    // Disable back, display Finish button
    //

    ::PropSheet_SetWizButtons(::GetParent(_hwnd), PSWIZB_FINISH);

    //
    // Default to local machine
    //

    Button_SetCheck(_hCtrl(IDC_CHOOSER_RADIO_LOCAL_MACHINE), BST_CHECKED);
    EnableWindow(_hCtrl(IDC_CHOOSER_EDIT_MACHINE_NAME), FALSE);
    EnableWindow(_hCtrl(IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES), FALSE);

    //
    // Prevent user from entering more than machine name chars, allowing
    // +2 chars for leading backslashes
    //

    Edit_LimitText(_hCtrl(IDC_CHOOSER_EDIT_MACHINE_NAME), CCH_COMPUTER_MAX + 2);
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizardPage::_OnSetActive
//
//  Synopsis:   Handle notification that this page is being activated.
//
//  History:    4-03-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CWizardPage::_OnSetActive()
{
    TRACE_METHOD(CWizardPage, _OnSetActive);
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizardPage::_OnCommand
//
//  Synopsis:   Respond to notifications from controls in dialog
//
//  Arguments:  [wParam] - specifies control
//              [lParam] - unused
//
//  Returns:    0
//
//  History:    4-03-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CWizardPage::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CWizardPage, _OnCommand);

    switch (LOWORD(wParam))
    {
    case IDC_CHOOSER_RADIO_LOCAL_MACHINE:
        EnableWindow(_hCtrl(IDC_CHOOSER_EDIT_MACHINE_NAME), FALSE);
        EnableWindow(_hCtrl(IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES), FALSE);
        break;

    case IDC_CHOOSER_RADIO_SPECIFIC_MACHINE:
        EnableWindow(_hCtrl(IDC_CHOOSER_EDIT_MACHINE_NAME), TRUE);
        EnableWindow(_hCtrl(IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES), TRUE);
        break;

    case IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES:
        _OnBrowseForMachine();
        break;
    }
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizardPage::_OnBrowseForMachine
//
//  Synopsis:   Fill the machine name edit control with the machine chosen
//              from the computer object selector dialog by the user.
//
//  History:    11-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CWizardPage::_OnBrowseForMachine()
{
    HRESULT hr;
    static const int     SCOPE_INIT_COUNT = 1;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Since we just want computer objects from every scope, combine them
    // all in a single scope initializer.
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                           | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                           | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_WORKGROUP
                           | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                           | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    IDsObjectPicker *pDsObjectPicker = NULL;
    IDataObject *pdo = NULL;
    bool fGotStgMedium = false;
    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    do
    {
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pDsObjectPicker->Initialize(&InitInfo);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pDsObjectPicker->InvokeDialog(_hwnd, &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

        // Quit if user hit Cancel

        if (hr == S_FALSE)
        {
            break;
        }

        FORMATETC formatetc =
        {
            (CLIPFORMAT)g_cfDsObjectPicker,
            NULL,
            DVASPECT_CONTENT,
            -1,
            TYMED_HGLOBAL
        };

        hr = pdo->GetData(&formatetc, &stgmedium);
        BREAK_ON_FAIL_HRESULT(hr);

        fGotStgMedium = true;

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        if (!pDsSelList)
        {
            DBG_OUT_LRESULT(GetLastError());
            break;
        }

        ASSERT(pDsSelList->cItems == 1);

        //
        // Put the machine name in the edit control
        //

        Edit_SetText(_hCtrl(IDC_CHOOSER_EDIT_MACHINE_NAME),
                     pDsSelList->aDsSelection[0].pwzName);

        GlobalUnlock(stgmedium.hGlobal);

    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }

    if (pdo)
    {
        pdo->Release();
    }

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizardPage::_OnApply
//
//  Synopsis:   This method is not called for a wizard property sheet page.
//
//  History:    4-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CWizardPage::_OnApply()
{
    TRACE_METHOD(CWizardPage, _OnApply);
    ASSERT(FALSE);
    return PSNRET_NOERROR;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizardPage::_OnNotify
//
//  Synopsis:   Handle wizard button click (the Finish button).
//
//  Arguments:  [pnmh] - describes notification
//
//  Returns:    0 or PSNRET_INVALID_NOCHANGEPAGE
//
//  History:    4-01-1997   DavidMun   Created
//
//  Notes:      Notifications other than PSN_WIZFINISH are ignored.
//
//---------------------------------------------------------------------------

ULONG
CWizardPage::_OnNotify(
    LPNMHDR pnmh)
{
    TRACE_METHOD(CWizardPage, _OnNotify);
    ULONG ulRet = 0;

    if (pnmh->code != PSN_WIZFINISH)
    {
        return ulRet;
    }

    if (IsDlgButtonChecked(_hwnd, IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME))
    {
        Dbg(DEB_ITRACE,
            "CWizardPage::_OnNotify: setting allow machine override on pcd 0x%x\n",
            _pcd);
        _pcd->AllowMachineOverride();
    }

    if (IsDlgButtonChecked(_hwnd, IDC_CHOOSER_RADIO_LOCAL_MACHINE))
    {
        _pcd->SetServerFocus(L""); // NULL==local machine
    }
    else
    {
        WCHAR wszServer[CCH_COMPUTER_MAX + 3];
        ::ZeroMemory( wszServer, sizeof(wszServer) ); // PREFIX 56321

        Edit_GetText(_hCtrl(IDC_CHOOSER_EDIT_MACHINE_NAME),
                     wszServer,
                     ARRAYLEN(wszServer));

        StripLeadTrailSpace(wszServer);

        if (*wszServer)
        {
            LPWSTR pwszNameStart;

            for (pwszNameStart = wszServer;
                 *pwszNameStart == L'\\';
                 pwszNameStart++)
            {
            }
            _pcd->SetServerFocus(pwszNameStart);
        }
        else
        {
            MsgBox(_hwnd, IDS_NO_SERVERNAME, MB_ICONERROR | MB_OK);
            ulRet = PSNRET_INVALID_NOCHANGEPAGE;
        }
    }
    return ulRet;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizardPage::_OnKillActive
//
//  Synopsis:   Indicate whether page may lose focus.
//
//  History:    4-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CWizardPage::_OnKillActive()
{
    TRACE_METHOD(CWizardPage, _OnKillActive);

    //
    // FALSE allows page to lose focus, TRUE prevents it.
    //

    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizardPage::_OnQuerySiblings
//
//  Synopsis:   Handle notification from other pages.
//
//  History:    4-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CWizardPage::_OnQuerySiblings(
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CWizardPage, _OnQuerySiblings);
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWizardPage::_OnDestroy
//
//  Synopsis:   Do cleanup as page closes
//
//  History:    4-01-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CWizardPage::_OnDestroy()
{
    TRACE_METHOD(CWizardPage, _OnDestroy);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\src\textbuf.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       textbuf.cxx
//
//  Contents:   Helper class for constructing text version of event log
//              record (for save as text file operation).
//
//  Classes:    CTextBuffer
//
//  History:    07-26-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop




//+--------------------------------------------------------------------------
//
//  Member:     CTextBuffer::CTextBuffer
//
//  Synopsis:   ctor
//
//  History:    07-26-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CTextBuffer::CTextBuffer():
        _pwszBuf(NULL),
        _cchBuf(0),
        _cchReserved(0),
        _pwszCur(NULL)
{
}




//+--------------------------------------------------------------------------
//
//  Member:     CTextBuffer::~CTextBuffer
//
//  Synopsis:   dtor
//
//  History:    07-26-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CTextBuffer::~CTextBuffer()
{
    delete [] _pwszBuf;
}





//+--------------------------------------------------------------------------
//
//  Member:     CTextBuffer::Init
//
//  Synopsis:   Do initial memory allocation for internal buffer
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  History:    07-26-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CTextBuffer::Init()
{
    ASSERT(!_cchBuf && !_pwszBuf && !_pwszCur);

    _cchBuf = 80;
    _pwszBuf = new WCHAR[_cchBuf];

    HRESULT hr = S_OK;

    if (_pwszBuf)
    {
        Empty();
    }
    else
    {
        _cchBuf = 0;
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(hr);
    }
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CTextBuffer::Empty
//
//  Synopsis:   Reset the text to an empty string.
//
//  History:    07-26-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CTextBuffer::Empty()
{
    if (_pwszBuf)
    {
        _pwszCur = _pwszBuf;
        *_pwszCur = L'\0';
        _cchReserved = 1;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CTextBuffer::_ExpandBy
//
//  Synopsis:   Ensure that there is room for at least [cch] characters to
//              be appended to the buffer.
//
//  Arguments:  [cch] - number of characters to reserve space for
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  History:    07-26-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CTextBuffer::_ExpandBy(
    ULONG cch)
{
    _cchReserved += cch;

    if (_cchReserved > _cchBuf)
    {
        ULONG cchNew = (_cchReserved * 3) / 2;
        LPWSTR pwszNew = new WCHAR[cchNew];

        if (!pwszNew)
        {
            _cchReserved -= cch;
            DBG_OUT_HRESULT(E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }

        _pwszCur = pwszNew + (_pwszCur - _pwszBuf);
        _cchBuf = cchNew;
        lstrcpy(pwszNew, _pwszBuf);

        delete [] _pwszBuf;
        _pwszBuf = pwszNew;
    }

    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CTextBuffer::AppendDelimited
//
//  Synopsis:   Concatenate [pwszToAppend] to the internal buffer,
//              surrounding it with double quotes if necessary, and following
//              it with the delimiter [wchDelim] if [fAddDelim] is nonzero.
//
//  Arguments:  [pwszToAppend] - string to concatenate
//              [wchDelim]     - delimiter character
//              [fAddDelim]    - if true, append [wchDelim]
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  History:    07-26-1997   DavidMun   Created
//              04-17-2002   JonN       543598 fix quoting
//
//  Notes:      If [pwszToAppend] contains double quote characters or any
//              instances of [wchDelim], it will be surrounded by double
//              quotes.  Additionally, any internal double quotes will be
//              doubled (i.e., each " becomes "").
//
//---------------------------------------------------------------------------

HRESULT
CTextBuffer::AppendDelimited(
    LPCWSTR pwszToAppend,
    WCHAR   wchDelim,
    BOOL    fAddDelim)
{
    UINT    len = lstrlen(pwszToAppend);
    UINT    cDoubleQuotes = 0;
    const   WCHAR wchDoubleQuote = L'"';

    BOOL fSurroundedByDoubleQuotes = FALSE;

    //
    // Count the number of double quote characters in the source
    // string.  Set the flag fSurroundedByDoubleQuotes if the string
    // contains either a double quote or a separator character.
    //

    for (UINT i=0; i < len; i++)
    {
        // 543598-2002/04/17-JonN double-quote return char
        if (pwszToAppend[i] == wchDelim || pwszToAppend[i] == L'\n')
        {
            fSurroundedByDoubleQuotes = TRUE;
        }
        else if (pwszToAppend[i] == wchDoubleQuote)
        {
            fSurroundedByDoubleQuotes = TRUE;
            ++cDoubleQuotes;
        }
    }

    //
    // If double quotes are required, put them around the source
    // string while copying it to the destination string.  Otherwise
    // just copy from source to dest.
    //

    HRESULT hr;

    do
    {
        if (fSurroundedByDoubleQuotes)
        {
            UINT Offset = 1 + cDoubleQuotes;

            hr = _ExpandBy(len + Offset + 1);
            BREAK_ON_FAIL_HRESULT(hr);

            _pwszCur[len + Offset + 1] = L'\0';
            _pwszCur[len + Offset] = wchDoubleQuote;

            for (int k = len - 1; k >= 0; k--)
            {
                _pwszCur[k + Offset] = pwszToAppend[k];

                if (_pwszCur[k + Offset] == wchDoubleQuote)
                {
                    --Offset;

                    _pwszCur[k + Offset] = wchDoubleQuote;
                }
            }

            _pwszCur[0] = wchDoubleQuote;
            _pwszCur += len + cDoubleQuotes + 2;
        }
        else
        {
            hr = _ExpandBy(len);
            BREAK_ON_FAIL_HRESULT(hr);

            CopyMemory(_pwszCur, pwszToAppend, (len + 1) * sizeof(WCHAR));
            _pwszCur += len;
        }

        if (!fAddDelim)
        {
            break;
        }

        hr = _ExpandBy(1);
        BREAK_ON_FAIL_HRESULT(hr);

        *_pwszCur++ = wchDelim;
        *_pwszCur = L'\0';
    } while (0);

    return hr;
}





//+--------------------------------------------------------------------------
//
//  Member:     CTextBuffer::AppendEOL
//
//  Synopsis:   Add a CRLF to the end of the buffer.
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  History:    07-26-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CTextBuffer::AppendEOL()
{
    HRESULT hr;

    hr = _ExpandBy(2);

    if (SUCCEEDED(hr))
    {
        lstrcpy(_pwszCur, L"\r\n");
        _pwszCur += 2;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CTextBuffer::GetBufferA
//
//  Synopsis:   Return an ansi version of the internal buffer in [ppsz]
//
//  Arguments:  [ppsz]       - points to buffer to write to
//              [pcch]       - size of buffer pointed to by [ppsz]
//              [pcbToWrite] - number of bytes written to **[ppsz].
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  Modifies:   *[pcch] and *[pcbToWrite]
//
//  History:    07-26-1997   DavidMun   Created
//
//  Notes:      *[ppsz] may be NULL.  If it is, *[pcch] must be 0.
//
//              If the buffer pointed to by [ppsz] is too small to contain
//              the ANSI string, a new one will be allocated and returned
//              in *[ppsz].
//
//---------------------------------------------------------------------------

HRESULT
CTextBuffer::GetBufferA(
    LPSTR *ppsz,
    ULONG *pcch,
    ULONG *pcbToWrite)
{
    if (*pcch < 2UL * (_pwszCur - _pwszBuf))
    {
        delete [] *ppsz;
        *pcch = static_cast<ULONG>(2 * (_pwszCur - _pwszBuf));
        *ppsz = new CHAR[*pcch];

        if (!*ppsz)
        {
            *pcch = 0;
            DBG_OUT_HRESULT(E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }
    }

    *pcbToWrite = WideCharToMultiByte(CP_ACP,
                                      0,
                                      _pwszBuf,
                                      -1,
                                      *ppsz,
                                      *pcch,
                                      NULL,
                                      NULL);

    if (!*pcbToWrite)
    {
        HRESULT hr = HRESULT_FROM_LASTERROR;
        DBG_OUT_LASTERROR;
        return hr;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\types\uuid\elsp_uuid.c ===
#include <elsp_i.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\eventlog\types\proxy\elsp_proxy.c ===
#include <elsp_p.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\about.h ===
//	About.h

#ifndef __ABOUT_H_INCLUDED__
#define __ABOUT_H_INCLUDED__

#include "stdabout.h"

//	About for "File Services"
class CFileSvcMgmtAbout :
	public CSnapinAbout,
	public CComCoClass<CFileSvcMgmtAbout, &CLSID_FileServiceManagementAbout>

{
public:
DECLARE_REGISTRY(CFileSvcMgmtAbout, _T("FILEMGMT.FileSvcMgmtAboutObject.1"), _T("FILEMGMT.FileSvcMgmtAboutObject.1"), IDS_FILEMGMT_DESC, THREADFLAGS_BOTH)
	CFileSvcMgmtAbout();
};

//	About for "System Services"
class CServiceMgmtAbout :
	public CSnapinAbout,
	public CComCoClass<CServiceMgmtAbout, &CLSID_SystemServiceManagementAbout>
{
public:
DECLARE_REGISTRY(CServiceMgmtAbout, _T("SVCMGMT.ServiceMgmtAboutObject.1"), _T("SVCMGMT.ServiceMgmtAboutObject.1"), IDS_SVCVWR_DESC, THREADFLAGS_BOTH)
	CServiceMgmtAbout();
};

// version and provider strings

#include <ntverp.h>
#define IDS_SNAPINABOUT_VERSION VER_PRODUCTVERSION_STR
#define IDS_SNAPINABOUT_PROVIDER VER_COMPANYNAME_STR

#endif // ~__ABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\about.cpp ===
/////////////////////////////////////////////////////////////////////
//	About.cpp
//
//	Provide constructors for the CSnapinAbout implementation.
//
//	HISTORY
//	31-Jul-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "about.h"

#include "stdabout.cpp" 


/////////////////////////////////////////////////////////////////////
CServiceMgmtAbout::CServiceMgmtAbout()
	{
	m_szProvider = IDS_SNAPINABOUT_PROVIDER;
	m_szVersion = IDS_SNAPINABOUT_VERSION;
	m_uIdStrDestription = IDS_SNAPINABOUT_DESCR_SERVICES;
	m_uIdIconImage = IDI_ICON_SVCMGMT;
	// HACK (t-danm): Currently there is only one bitmap
	// per IDB_SVCMGMT_ICONS_* so we can use the same bitmap
	// strip for individual bitmaps.
	m_uIdBitmapSmallImage = IDB_SVCMGMT_ICONS_16;
	m_uIdBitmapSmallImageOpen = IDB_SVCMGMT_ICONS_16;
	m_uIdBitmapLargeImage = IDB_SVCMGMT_ICONS_32;
	m_crImageMask = RGB(255, 0, 255);
	}

/////////////////////////////////////////////////////////////////////
CFileSvcMgmtAbout::CFileSvcMgmtAbout()
	{
	m_szProvider = IDS_SNAPINABOUT_PROVIDER;
	m_szVersion = IDS_SNAPINABOUT_VERSION;
	m_uIdStrDestription = IDS_SNAPINABOUT_DESCR_FILESVC;
	m_uIdIconImage = IDI_ICON_FILEMGMT;
	m_uIdBitmapSmallImage = IDB_FILEMGMT_FOLDER_SMALL;
	m_uIdBitmapSmallImageOpen = IDB_FILEMGMT_FOLDER_SMALLOPEN;
	m_uIdBitmapLargeImage = IDB_FILEMGMT_FOLDER_LARGE;
	m_crImageMask = RGB(255, 0, 255);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\cacheset.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       CacheSet.h
//
//  Contents:   CCacheSettingsDlg header.  Allows the setting of file sharing 
//                    caching options.
//
//----------------------------------------------------------------------------
#if !defined(AFX_CACHESET_H__953E618B_D542_11D1_A6E0_00C04FB94F17__INCLUDED_)
#define AFX_CACHESET_H__953E618B_D542_11D1_A6E0_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// CacheSet.h : header file
//
#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CCacheSettingsDlg dialog

class CCacheSettingsDlg : public CDialog
{
// Construction
public:
    CCacheSettingsDlg(CWnd*            pParent, 
            DWORD&                    dwFlags);

// Dialog Data
    //{{AFX_DATA(CCacheSettingsDlg)
    enum { IDD = IDD_SMB_CACHE_SETTINGS };
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCacheSettingsDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CCacheSettingsDlg)
    afx_msg void OnCSCNoAuto();
    afx_msg void OnCSCAuto();
    afx_msg void OnCSCAutoCheck();
    afx_msg void OnHelpLink(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
    afx_msg BOOL OnContextHelp(WPARAM wParam, LPARAM lParam);
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:
    BOOL GetCachedFlag (DWORD dwFlags, DWORD dwFlagToCheck);
    VOID SetCachedFlag (DWORD* pdwFlags, DWORD dwNewFlag);
    DWORD&                    m_dwFlags;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CACHESET_H__953E618B_D542_11D1_A6E0_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\cmponent.h ===
// cmponent.h : Declaration of CFileMgmtComponent

#ifndef __CMPONENT_H_INCLUDED__
#define __CMPONENT_H_INCLUDED__

#include "cookie.h"  // CFileMgmtCookie
#include "stdcmpnt.h" // CComponent

extern CString g_strResultColumnText;
extern CString g_strTransportSMB;
extern CString g_strTransportSFM;

// forward declarations
class FileServiceProvider;
class CFileMgmtComponentData;


class CFileMgmtComponent :
    public CComponent,
    public IExtendContextMenu,
    public IExtendPropertySheet,
    public IExtendControlbar,
    public INodeProperties,
    public IResultDataCompare
{
public:
    CFileMgmtComponent();
    ~CFileMgmtComponent();
BEGIN_COM_MAP(CFileMgmtComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IExtendControlbar)
     COM_INTERFACE_ENTRY(IExtendPropertySheet)
     COM_INTERFACE_ENTRY(IResultDataCompare)
     COM_INTERFACE_ENTRY(INodeProperties)
    COM_INTERFACE_ENTRY_CHAIN(CComponent)
END_COM_MAP()

#if DBG==1
    ULONG InternalAddRef()
    {
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        return CComObjectRoot::InternalRelease();
    }
    int dbg_InstID;
#endif // DBG==1

// IComponent implemented in CComponent

    // support methods for IComponent
    virtual HRESULT ReleaseAll();
    virtual HRESULT OnPropertyChange( LPARAM param );
    virtual HRESULT OnViewChange( LPDATAOBJECT lpDataObject, LPARAM data, LPARAM hint );
    virtual HRESULT OnNotifyRefresh( LPDATAOBJECT lpDataObject );
    virtual HRESULT OnNotifySelect( LPDATAOBJECT lpDataObject, BOOL fSelected );
    virtual HRESULT Show(CCookie* pcookie, LPARAM arg, HSCOPEITEM hScopeItem);
    virtual HRESULT OnNotifyAddImages( LPDATAOBJECT lpDataObject,
                                       LPIMAGELIST lpImageList,
                                       HSCOPEITEM hSelectedItem );
    virtual HRESULT OnNotifySnapinHelp (LPDATAOBJECT pDataObject);
    virtual HRESULT OnNotifyColumnClick( LPDATAOBJECT lpDataObject, LPARAM iColumn, LPARAM uFlags );

    HRESULT PopulateListbox(CFileMgmtScopeCookie* pcookie);
    HRESULT RefreshAllViewsOnSelectedObject( LPDATAOBJECT piDataObject );
    virtual HRESULT RefreshAllViews( LPDATAOBJECT lpDataObject );
    HRESULT RefreshNewResultCookies( CCookie& refparentcookie );
    void UpdateDefaultVerbs();

    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie, LPOLESTR* ppViewType, long* pViewOptions);

    #ifdef SNAPIN_PROTOTYPER
    CString m_strDemoName;        // Name of the SnapIn prototyper demo
    CString m_strKeyPrototyper;    // "HKLM\Software\Microsoft\MMC\DemoSnapInKey" + m_strDemoName
    int m_cColumns;                // Number of columns in the result pane
    int m_iImageListLast;        // Index of the last image in the imagelist

    BOOL Prototyper_FInsertColumns(CFileMgmtCookie * pCookie);
    HRESULT Prototyper_HrPopulateResultPane(CFileMgmtCookie * pCookie);
    BOOL Prototyper_FAddResultPaneItem(CFileMgmtCookie * pParentCookie, LPCTSTR pszItemName, AMC::CRegKey& regkeySnapinItem);
    BOOL Prototyper_FAddMenuItems(IContextMenuCallback * pContextMenuCallback, IDataObject * pDataObject);
    BOOL Prototyper_ContextMenuCommand(LONG lCommandID, IDataObject* piDataObject);
    int Prototyper_AddIconToImageList(LPCTSTR pszIconPath);
    #endif // SNAPIN_PROTOTYPER
    
    HRESULT LoadIcons();
    static HRESULT LoadStrings();
    HRESULT LoadColumns( CFileMgmtCookie* pcookie );
    HRESULT GetSnapinMultiSelectDataObject(
        LPDATAOBJECT i_pMMCMultiSelectDataObject,
        LPDATAOBJECT *o_ppSnapinMultiSelectDataObject
    );
    BOOL OpenShare(LPDATAOBJECT piDataObject);
    BOOL DeleteShare(LPDATAOBJECT piDataObject);
    BOOL DeleteThisOneShare(LPDATAOBJECT piDataObject, BOOL bQuietMode);
    BOOL CloseSession( LPDATAOBJECT piDataObject );
    BOOL CloseThisOneSession(LPDATAOBJECT piDataObject, BOOL bQuietMode);
    BOOL CloseResource( LPDATAOBJECT piDataObject );
    BOOL CloseThisOneResource(LPDATAOBJECT piDataObject, BOOL bQuietMode);

// IExtendContextMenu
    STDMETHOD(AddMenuItems)(
                    IDataObject*          piDataObject,
                    IContextMenuCallback* piCallback,
                    long*                 pInsertionAllowed);
    STDMETHOD(Command)(
                    LONG            lCommandID,
                    IDataObject*    piDataObject );

// IExtendPropertySheet
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK pCall, LONG_PTR handle, LPDATAOBJECT pDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);

// IExtendControlbar
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event,LPARAM arg,LPARAM param);

    HRESULT AddToolbar(LPDATAOBJECT pdoScopeIsSelected, BOOL fSelected);
    HRESULT UpdateToolbar(LPDATAOBJECT pdoResultIsSelected, BOOL fSelected);
    HRESULT OnToolbarButton(LPDATAOBJECT pDataObject, UINT idButton);
    HRESULT ServiceToolbarButtonState( LPDATAOBJECT pServiceDataObject, BOOL fSelected );

// IResultDataCompare
    STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);

// FILEMGMT_NodeProperties
    STDMETHOD(GetProperty)( 
            /* [in] */ LPDATAOBJECT pDataObject,
            /* [in] */ BSTR szPropertyName,
            /* [out] */ BSTR* pbstrProperty);

    CFileMgmtComponentData& QueryComponentDataRef()
    {
        return (CFileMgmtComponentData&)QueryBaseComponentDataRef();
    }

public:
    LPCONTROLBAR    m_pControlbar; // CODEWORK should use smartpointer
    LPTOOLBAR        m_pSvcMgmtToolbar; // CODEWORK should use smartpointer
    LPTOOLBAR        m_pFileMgmtToolbar; // CODEWORK should use smartpointer
    int         m_iSortColumn;
    DWORD       m_dwSortFlags;

    CFileMgmtScopeCookie* m_pViewedCookie;
    CFileMgmtCookie*      m_pSelectedCookie;
    static const GUID m_ObjectTypeGUIDs[FILEMGMT_NUMTYPES];
    static const BSTR m_ObjectTypeStrings[FILEMGMT_NUMTYPES];

    BOOL IsServiceSnapin();

    FileServiceProvider* GetFileServiceProvider( FILEMGMT_TRANSPORT transport );
    inline FileServiceProvider* GetFileServiceProvider(
        INT iTransport )
    {
        return GetFileServiceProvider((FILEMGMT_TRANSPORT)iTransport);
    }

}; // class CFileMgmtComponent


/*
//
// A pointer to this structure is passed from the property sheets
// to the views via MMCPropertyChangeNotify.  Two notifications will be passed to all of
// the views; first one where fClear==TRUE will instruct all relevant views to dump all
// of their cookies, then a second with fClear==FALSE instructs them to reload.
//
typedef struct _FILEMGMTPROPERTYCHANGE
{
    BOOL fServiceChange;            // TRUE -> SvcMgmt change, FALSE -> FileMgmt change
    LPCTSTR lpcszMachineName;        // machine whose properties must be refreshed
    BOOL fClear;                    // TRUE -> clear view, FALSE -> reload view
} FILEMGMTPROPERTYCHANGE;
*/

// Enumeration for the icons used
enum
{
    iIconSharesFolder = 0,
    iIconSharesFolderOpen,
    iIconSMBShare,
    iIconSFMShareFolder,
    iIconSFMShare,
    iIconSMBResource,
    iIconSFMResource,
    iIconSMBSession,
    iIconSFMSession,
    iIconService,
    #ifdef SNAPIN_PROTOTYPER
    iIconPrototyperContainerClosed,
    iIconPrototyperContainerOpen,
    iIconPrototyperHTML,
    iIconPrototyperLeaf,
    #endif
    iIconLast        // Must be last
};


typedef enum _COLNUM_ROOT {
    COLNUM_ROOT_NAME = 0
} COLNUM_ROOT;

typedef enum _COLNUM_SHARES {
    COLNUM_SHARES_SHARED_FOLDER = 0,
    COLNUM_SHARES_SHARED_PATH,
    COLNUM_SHARES_TRANSPORT,
    COLNUM_SHARES_NUM_SESSIONS,
    COLNUM_SHARES_COMMENT
} COLNUM_SHARES;

typedef enum _COLNUM_SESSIONS {
    COLNUM_SESSIONS_USERNAME = 0,
    COLNUM_SESSIONS_COMPUTERNAME,
    COLNUM_SESSIONS_TRANSPORT,
    COLNUM_SESSIONS_NUM_FILES,
    COLNUM_SESSIONS_CONNECTED_TIME,
    COLNUM_SESSIONS_IDLE_TIME,
    COLNUM_SESSIONS_IS_GUEST
} COLNUM_SESSIONS;

typedef enum _COLNUM_RESOURCES {
    COLNUM_RESOURCES_FILENAME = 0,
    COLNUM_RESOURCES_USERNAME,
    COLNUM_RESOURCES_TRANSPORT,
    COLNUM_RESOURCES_NUM_LOCKS,
    COLNUM_RESOURCES_OPEN_MODE
} COLNUM_RESOURCES;

//typedef enum _COLNUM_SERVICES {
//    COLNUM_SERVICES_SERVICENAME = 0,
//    COLNUM_SERVICES_DESCRIPTION,
//    COLNUM_SERVICES_STATUS,
//    COLNUM_SERVICES_STARTUPTYPE,
//    COLNUM_SERVICES_SECURITYCONTEXT,
//} COLNUM_SERVICES;

//
// For context menu
//
enum
    {
    cmServiceStart = 100,
    cmServiceStop,
    cmServicePause,
    cmServiceResume,
    cmServiceRestart,    // Stop + Start
    cmServiceStartTask,
    cmServiceStopTask,
    cmServicePauseTask,
    cmServiceResumeTask,
    cmServiceRestartTask,    // Stop + Start
    };


#ifdef SNAPIN_PROTOTYPER
BOOL Prototyper_AddMenuItems(IContextMenuCallback* pContextMenuCallback, IDataObject* piDataObject);
#endif

#endif // ~__CMPONENT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\cacheset.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       CacheSet.h
//
//  Contents:   CCacheSettingsDlg implementation.  Allows the setting of file sharing 
//                    caching options.
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "CacheSet.h"
#include "filesvc.h"
#include <htmlhelp.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCacheSettingsDlg dialog

CCacheSettingsDlg::CCacheSettingsDlg(
        CWnd*                    pParent, 
        DWORD&                    dwFlags)
    : CDialog(CCacheSettingsDlg::IDD, pParent),
    m_dwFlags (dwFlags)
{
    //{{AFX_DATA_INIT(CCacheSettingsDlg)
    //}}AFX_DATA_INIT
}


void CCacheSettingsDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CCacheSettingsDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CCacheSettingsDlg, CDialog)
    //{{AFX_MSG_MAP(CCacheSettingsDlg)
    ON_BN_CLICKED(IDC_CACHE_OPTIONS_MANUAL, OnCSCNoAuto)
    ON_BN_CLICKED(IDC_CACHE_OPTIONS_AUTO, OnCSCAuto)
    ON_BN_CLICKED(IDC_CACHE_OPTIONS_NOCACHE, OnCSCNoAuto)
    ON_BN_CLICKED(IDC_CACHE_OPTIONS_AUTO_CHECK, OnCSCAutoCheck)
    ON_NOTIFY(NM_CLICK, IDC_CACHE_HELPLINK, OnHelpLink)
    ON_NOTIFY(NM_RETURN, IDC_CACHE_HELPLINK, OnHelpLink)
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCacheSettingsDlg message handlers

BOOL CCacheSettingsDlg::OnInitDialog() 
{
    CDialog::OnInitDialog();
    
    if (GetCachedFlag(m_dwFlags, CSC_CACHE_MANUAL_REINT))
    {
        CheckRadioButton(IDC_CACHE_OPTIONS_MANUAL,
                        IDC_CACHE_OPTIONS_NOCACHE,
                        IDC_CACHE_OPTIONS_MANUAL);
    } else if (GetCachedFlag(m_dwFlags, CSC_CACHE_AUTO_REINT))
    {
        CheckRadioButton(IDC_CACHE_OPTIONS_MANUAL,
                        IDC_CACHE_OPTIONS_NOCACHE,
                        IDC_CACHE_OPTIONS_AUTO);
        CheckDlgButton(IDC_CACHE_OPTIONS_AUTO_CHECK, BST_UNCHECKED);
    } else if (GetCachedFlag(m_dwFlags, CSC_CACHE_VDO))
    {
        CheckRadioButton(IDC_CACHE_OPTIONS_MANUAL,
                        IDC_CACHE_OPTIONS_NOCACHE,
                        IDC_CACHE_OPTIONS_AUTO);
        CheckDlgButton(IDC_CACHE_OPTIONS_AUTO_CHECK, BST_CHECKED);
    } else if (GetCachedFlag(m_dwFlags, CSC_CACHE_NONE))
    {
        CheckRadioButton(IDC_CACHE_OPTIONS_MANUAL,
                        IDC_CACHE_OPTIONS_NOCACHE,
                        IDC_CACHE_OPTIONS_NOCACHE);
    }

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CCacheSettingsDlg::OnCSCNoAuto()
{
    CheckDlgButton(IDC_CACHE_OPTIONS_AUTO_CHECK, BST_UNCHECKED);

    HWND hwnd = GetDlgItem(IDC_CACHE_OPTIONS_AUTO_CHECK)->GetSafeHwnd();
    LONG_PTR lStyle = GetWindowLongPtr(hwnd, GWL_STYLE);
    if (0 != lStyle)
        SetWindowLongPtr(hwnd, GWL_STYLE, lStyle & ~WS_TABSTOP);
}

void CCacheSettingsDlg::OnCSCAuto()
{
    CheckDlgButton(IDC_CACHE_OPTIONS_AUTO_CHECK, BST_CHECKED);

    HWND hwnd = GetDlgItem(IDC_CACHE_OPTIONS_AUTO_CHECK)->GetSafeHwnd();
    LONG_PTR lStyle = GetWindowLongPtr(hwnd, GWL_STYLE);
    if (0 != lStyle)
        SetWindowLongPtr(hwnd, GWL_STYLE, lStyle | WS_TABSTOP);
}

void CCacheSettingsDlg::OnCSCAutoCheck()
{
    CheckRadioButton(IDC_CACHE_OPTIONS_MANUAL,
                    IDC_CACHE_OPTIONS_NOCACHE,
                    IDC_CACHE_OPTIONS_AUTO);

    HWND hwnd = GetDlgItem(IDC_CACHE_OPTIONS_AUTO_CHECK)->GetSafeHwnd();
    LONG_PTR lStyle = GetWindowLongPtr(hwnd, GWL_STYLE);
    if (0 != lStyle)
        SetWindowLongPtr(hwnd, GWL_STYLE, lStyle | WS_TABSTOP);
}

void CCacheSettingsDlg::OnHelpLink(NMHDR* pNMHDR, LRESULT* pResult)
{
    CWaitCursor wait;

    ::HtmlHelp(0, _T("file_srv.chm"), HH_DISPLAY_TOPIC, (DWORD_PTR)(_T("file_srv_cache_options.htm")));

    *pResult = 0;
}

void CCacheSettingsDlg::OnOK() 
{
    DWORD    dwNewFlag = 0;

    switch (GetCheckedRadioButton(IDC_CACHE_OPTIONS_MANUAL, IDC_CACHE_OPTIONS_NOCACHE))
    {
    case IDC_CACHE_OPTIONS_MANUAL:
        dwNewFlag = CSC_CACHE_MANUAL_REINT;
        break;
    case IDC_CACHE_OPTIONS_AUTO:
        if (BST_CHECKED != IsDlgButtonChecked(IDC_CACHE_OPTIONS_AUTO_CHECK))
            dwNewFlag = CSC_CACHE_AUTO_REINT;
        else
            dwNewFlag = CSC_CACHE_VDO;
        break;
    case IDC_CACHE_OPTIONS_NOCACHE:
        dwNewFlag = CSC_CACHE_NONE;
        break;
    default:
        break;
    }

    SetCachedFlag (&m_dwFlags, dwNewFlag);
    
    CDialog::OnOK();
}

BOOL CCacheSettingsDlg::GetCachedFlag( DWORD dwFlags, DWORD dwFlagToCheck )
{
    return (dwFlags & CSC_MASK) == dwFlagToCheck;
}

VOID CCacheSettingsDlg::SetCachedFlag( DWORD* pdwFlags, DWORD dwNewFlag )
{
    *pdwFlags &= ~CSC_MASK;

    *pdwFlags |= dwNewFlag;
}

/////////////////////////////////////////////////////////////////////
//    Help
BOOL CCacheSettingsDlg::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
    return DoHelp(lParam, HELP_DIALOG_TOPIC(IDD_SMB_CACHE_SETTINGS));
}

BOOL CCacheSettingsDlg::OnContextHelp(WPARAM wParam, LPARAM /*lParam*/)
{
    return DoContextHelp(wParam, HELP_DIALOG_TOPIC(IDD_SMB_CACHE_SETTINGS));
}

///////////////////////////////////////////////////////////////////////////////
//    CacheSettingsDlg ()
//
//    Invoke a dialog to set/modify cache settings for a share
//
//    RETURNS
//    Return S_OK if the user clicked on the OK button.
//    Return S_FALSE if the user clicked on the Cancel button.
//    Return E_OUTOFMEMORY if there is not enough memory.
//    Return E_UNEXPECTED if an expected error occured (eg: bad parameter)
//
///////////////////////////////////////////////////////////////////////////////

HRESULT
CacheSettingsDlg(
    HWND hwndParent,    // IN: Parent's window handle
    DWORD& dwFlags)        // IN & OUT: share flags
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(::IsWindow(hwndParent));

    HRESULT                    hResult = S_OK;
    CWnd                    parentWnd;

    parentWnd.Attach (hwndParent);
    CCacheSettingsDlg dlg (&parentWnd, dwFlags);
    CThemeContextActivator activator;
    if (IDOK != dlg.DoModal())
        hResult = S_FALSE;

    parentWnd.Detach ();

    return hResult;
} // CacheSettingsDlg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\cmponent.cpp ===
// cmponent.cpp : Implementation of CFileMgmtComponent

#include "stdafx.h"
#include "cookie.h"
#include "safetemp.h"

#include "macros.h"
USE_HANDLE_MACROS("FILEMGMT(cmponent.cpp)")

#include "ShrProp.h"    // Share Properties Pages

#include "FileSvc.h" // FileServiceProvider
#include "smb.h"
#include "sfm.h"

#include "dataobj.h"
#include "cmponent.h" // CFileMgmtComponent
#include "compdata.h" // CFileMgmtComponentData
#include "stdutils.h" // SynchronousCreateProcess

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#include "stdcmpnt.cpp" // CComponent

UINT g_aColumns0[2] =
  {IDS_ROOT_NAME, 0};
UINT g_aColumns1[6] =
  {IDS_SHARES_SHARED_FOLDER, IDS_SHARES_SHARED_PATH, IDS_SHARES_TRANSPORT,
    IDS_SHARES_NUM_SESSIONS, IDS_SHARES_COMMENT, 0};
UINT g_aColumns2[8] =
  {IDS_CONN_USERNAME, IDS_CONN_COMPUTERNAME, IDS_CONN_TRANSPORT, IDS_CONN_NUM_FILES,
    IDS_CONN_CONNECTED_TIME, IDS_CONN_IDLE_TIME, IDS_CONN_IS_GUEST, 0};
UINT g_aColumns3[6] =
  {IDS_FILE_FILENAME, IDS_FILE_USERNAME, IDS_FILE_TRANSPORT, IDS_FILE_NUM_LOCKS,
    IDS_FILE_OPEN_MODE, 0};
UINT g_aColumns4[6] =
  { IDS_SERVICE_SERVICENAME, IDS_SERVICE_DESCRIPTION, IDS_SERVICE_STATUS,
    IDS_SERVICE_STARTUPTYPE, IDS_SERVICE_SECURITYCONTEXT, 0};

UINT* g_Columns[FILEMGMT_NUMTYPES] =
  {  g_aColumns0, // FILEMGMT_ROOT
    g_aColumns1, // FILEMGMT_SHARES
    g_aColumns2, // FILEMGMT_SESSIONS
    g_aColumns3, // FILEMGMT_RESOURCES
    g_aColumns4, // FILEMGMT_SERVICES
    NULL,        // FILEMGMT_SHARE
    NULL,        // FILEMGMT_SESSION
    NULL,        // FILEMGMT_RESOURCE
    NULL         // FILEMGMT_SERVICE
  };

UINT** g_aColumns = g_Columns;
/*
const UINT aColumns[STD_NODETYPE_NUMTYPES][STD_MAX_COLUMNS] =
  {  {IDS_ROOT_NAME, 0,0,0,0,0,0},
    {IDS_SHARES_SHARED_FOLDER, IDS_SHARES_SHARED_PATH, IDS_SHARES_TRANSPORT,
      IDS_SHARES_NUM_SESSIONS, IDS_SHARES_COMMENT, 0,0},
    {IDS_CONN_USERNAME, IDS_CONN_COMPUTERNAME, IDS_CONN_TRANSPORT, IDS_CONN_NUM_FILES,
      IDS_CONN_CONNECTED_TIME, IDS_CONN_IDLE_TIME, IDS_CONN_IS_GUEST},
    {IDS_FILE_FILENAME, IDS_FILE_USERNAME, IDS_FILE_TRANSPORT, IDS_FILE_NUM_LOCKS,
      IDS_FILE_OPEN_MODE, 0,0},
    { IDS_SERVICE_SERVICENAME, IDS_SERVICE_DESCRIPTION, IDS_SERVICE_STATUS,
      IDS_SERVICE_STARTUPTYPE, IDS_SERVICE_SECURITYCONTEXT, 0,0 },
    {0,0,0,0,0,0},
    {0,0,0,0,0,0},
    {0,0,0,0,0,0},
    {0,0,0,0,0,0}
};
*/

//
// CODEWORK this should be in a resource, for example code on loading data resources see
//   D:\nt\private\net\ui\common\src\applib\applib\lbcolw.cxx ReloadColumnWidths()
//   JonN 10/11/96
//

int g_aColumnWidths0[1] = {150};
int g_aColumnWidths1[5] = {AUTO_WIDTH,120       ,90        ,AUTO_WIDTH,150};
int g_aColumnWidths2[7] = {100       ,AUTO_WIDTH,90        ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH};
int g_aColumnWidths3[5] = {120       ,AUTO_WIDTH,90        ,AUTO_WIDTH,AUTO_WIDTH};
int g_aColumnWidths4[5] = {130       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH};
int* g_ColumnWidths[FILEMGMT_NUMTYPES] =
  {  g_aColumnWidths0, // FILEMGMT_ROOT
    g_aColumnWidths1, // FILEMGMT_SHARES
    g_aColumnWidths2, // FILEMGMT_SESSIONS
    g_aColumnWidths3, // FILEMGMT_RESOURCES
    g_aColumnWidths4, // FILEMGMT_SERVICES
    NULL,             // FILEMGMT_SHARE
    NULL,             // FILEMGMT_SESSION
    NULL,             // FILEMGMT_RESOURCE
    NULL              // FILEMGMT_SERVICE
  };
int** g_aColumnWidths = g_ColumnWidths;
/*
const int aColumnWidths[STD_NODETYPE_NUMTYPES][STD_MAX_COLUMNS] =
  {  {AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // FILEMGMT_ROOT
    {AUTO_WIDTH,120       ,90        ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // FILEMGMT_SHARES
    {100       ,AUTO_WIDTH,90        ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // FILEMGMT_SESSIONS
    {120       ,AUTO_WIDTH,90        ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // FILEMGMT_RESOURCES
    {130       ,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // FILEMGMT_SERVICES
    {AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // FILEMGMT_SHARE
    {AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // FILEMGMT_SESSION
    {AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}, // FILEMGMT_RESOURCE
    {AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH,AUTO_WIDTH}  // FILEMGMT_SERVICE
};
*/

CString g_cstrClientName;
CString g_cstrGuest;
CString g_cstrYes;
CString g_cstrNo;

// Note that m_pFileMgmtData is still NULL during construction
CFileMgmtComponent::CFileMgmtComponent()
:  m_pControlbar( NULL )
,  m_pSvcMgmtToolbar( NULL )
,  m_pFileMgmtToolbar( NULL )
,  m_pViewedCookie( NULL )
,  m_pSelectedCookie( NULL )
,  m_iSortColumn(0)
,  m_dwSortFlags(0)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
}

CFileMgmtComponent::~CFileMgmtComponent()
{
  TRACE_METHOD(CFileMgmtComponent,ReleaseAll);
/* now in CFileMgmtComponentData
  if (m_hScManager != NULL)
    {
      AFX_MANAGE_STATE(AfxGetStaticModuleState( )); // required for CWaitCursor
    CWaitCursor wait;
    // Close the service control manager
    (void)::CloseServiceHandle(m_hScManager);
    } // if
*/
  VERIFY( SUCCEEDED(ReleaseAll()) );
}

HRESULT CFileMgmtComponent::ReleaseAll()
{
  MFC_TRY;

  TRACE_METHOD(CFileMgmtComponent,ReleaseAll);

  if ( NULL != m_pViewedCookie )
  {
    // We did not get an equal number of MMCN_SHOW(1) and
    // MMCN_SHOW(0) notifications
    // CODEWORK should assert here but MMC is currently broken
    // ASSERT(FALSE);
    m_pViewedCookie->ReleaseResultChildren();
    m_pViewedCookie->Release(); // JonN 10/1/01 465507
    m_pViewedCookie = NULL;
  }

  // We should get an equal number of MMCN_SELECT(1) and MMCN_SELECT(0) notifications
  // CODEWORK should assert this but MMC is broken ASSERT( NULL == m_pSelectedCookie ); 

  SAFE_RELEASE(m_pSvcMgmtToolbar);
  SAFE_RELEASE(m_pFileMgmtToolbar);
  SAFE_RELEASE(m_pControlbar);

  return CComponent::ReleaseAll();

  MFC_CATCH;
}

FileServiceProvider* CFileMgmtComponent::GetFileServiceProvider(
  FILEMGMT_TRANSPORT transport )
{
  return QueryComponentDataRef().GetFileServiceProvider(transport);
}

BOOL CFileMgmtComponent::IsServiceSnapin()
{
  return QueryComponentDataRef().IsServiceSnapin();
}


/////////////////////////////////////////////////////////////////////////////
// IComponent Implementation


HRESULT CFileMgmtComponent::LoadStrings()
{
  Service_LoadResourceStrings();
  return S_OK;
}

HRESULT CFileMgmtComponent::LoadColumns( CFileMgmtCookie* pcookie )
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState( )); // 2002/03/22-JonN 572859

  TEST_NONNULL_PTR_PARAM(pcookie);
  ASSERT(m_pHeader != NULL);

  #ifdef SNAPIN_PROTOTYPER
  (void)Prototyper_FInsertColumns(pcookie);
  return S_OK;
  #endif

  if (g_cstrGuest.IsEmpty())
    VERIFY(g_cstrGuest.LoadString(IDS_GUEST));
  if (g_cstrYes.IsEmpty())
    VERIFY(g_cstrYes.LoadString(IDS_YES));
  if (g_cstrNo.IsEmpty())
    VERIFY(g_cstrNo.LoadString(IDS_NO));

  return LoadColumnsFromArrays( pcookie->QueryObjectType() );
}

// OnPropertyChange() is generated by MMCPropertyChangeNotify( param )
HRESULT CFileMgmtComponent::OnPropertyChange( LPARAM param )
{
  LPDATAOBJECT pdataobject = reinterpret_cast<LPDATAOBJECT> (param);
  (void) RefreshAllViews(pdataobject);

  // The recipient of this notification is required to release the data object
  (void) pdataobject->Release();

  return S_OK;
} // CFileMgmtComponent::OnPropertyChange()

//
// In case of multiselect, piDataObject may point to a composite data object (MMC_MS_DO).
// RefreshAllViewsOnSelectedObject will crack down MMC_MS_DO to retrieve SI_MS_DO, then call
// RefreshAllViews on one of the selected objects in the internal list.
//
HRESULT CFileMgmtComponent::RefreshAllViewsOnSelectedObject(LPDATAOBJECT piDataObject)
{
    BOOL bMultiSelectObject = IsMultiSelectObject(piDataObject);
    if (!bMultiSelectObject)
        return RefreshAllViews(piDataObject);

    //
    // piDataObject is the composite data object (MMC_MS_DO) created by MMC.
    // We need to crack it to retrieve the multiselect data object (SI_MS_DO)
    // we provided to MMC in QueryDataObject().
    //
    IDataObject *piSIMSDO = NULL;
    HRESULT hr = GetSnapinMultiSelectDataObject(piDataObject, &piSIMSDO);
    if (SUCCEEDED(hr))
    {
        CFileMgmtDataObject *pDataObj = NULL;
        hr = ExtractData(piSIMSDO, CFileMgmtDataObject::m_CFInternal, &pDataObj, sizeof(pDataObj));
        if (SUCCEEDED(hr))
        {
            //
            // get the internal list of data objects of selected items, operate on one of them.
            //
            CDataObjectList* pMultiSelectObjList = pDataObj->GetMultiSelectObjList();
            ASSERT(!pMultiSelectObjList->empty());
            hr = RefreshAllViews(*(pMultiSelectObjList->begin()));
        }

        piSIMSDO->Release();
    }

    return hr;
}

// Forces all views of the specified data object to refresh
HRESULT CFileMgmtComponent::RefreshAllViews( LPDATAOBJECT pDataObject )
{
  if ( NULL == pDataObject || NULL == m_pConsole )
  {
    // JonN 465022 9/26/01
    // This can happen if the view for this property page
    // has already been released
    // ASSERT(FALSE);
    return ERROR_INVALID_PARAMETER;
  }

// This is new code for updating the Service list using a mark-and-sweep algorithm.
// Eventually this should be applied to all result cookies.
  CCookie* pbasecookie = NULL;
  HRESULT hr = ExtractData(
    pDataObject,
    CDataObject::m_CFRawCookie,
    &pbasecookie,
    sizeof(pbasecookie) );
  RETURN_HR_IF_FAIL; // MMC shouldn't have given me someone else's cookie
  pbasecookie = QueryBaseComponentDataRef().ActiveBaseCookie( pbasecookie );
  CFileMgmtCookie* pUpdatedCookie = dynamic_cast<CFileMgmtCookie*>(pbasecookie);
  RETURN_E_FAIL_IF_NULL(pUpdatedCookie);
  FileMgmtObjectType objTypeForUpdatedCookie = pUpdatedCookie->QueryObjectType();
  if ( FILEMGMT_SERVICE == objTypeForUpdatedCookie )
  {
    if (   NULL == m_pViewedCookie
        || FILEMGMT_SERVICES != m_pViewedCookie->QueryObjectType()
       )
    {
      return S_OK; // not a service cookie update
    }
    pUpdatedCookie = dynamic_cast<CFileMgmtCookie*>(m_pViewedCookie);
    RETURN_E_FAIL_IF_NULL(pUpdatedCookie);
    objTypeForUpdatedCookie = FILEMGMT_SERVICES;
  }
  if ( FILEMGMT_SERVICES == objTypeForUpdatedCookie )
  {
    CFileMgmtScopeCookie* pScopeCookie = dynamic_cast<CFileMgmtScopeCookie*>(pUpdatedCookie);
    RETURN_E_FAIL_IF_NULL(pScopeCookie);

    // "Mark" -- Mark all existing list elements as "delete"
    pScopeCookie->MarkResultChildren( NEWRESULTCOOKIE_DELETE );

    // "Sweep" -- Read the new list.  When a new element is the same object
    // as an existing element not yet seen, mark the old element as "old"
    // and update its fields. Otherwise, add it as a "new" element.
    hr = QueryComponentDataRef().Service_PopulateServices(m_pResultData, pScopeCookie);
    RETURN_HR_IF_FAIL;

    // Refresh all views to conform with the new list.
    hr = m_pConsole->UpdateAllViews( pDataObject, 2L, 0L );
    RETURN_HR_IF_FAIL;

    // UpdateToolbar if selected
    hr = m_pConsole->UpdateAllViews( pDataObject, 3L, 0L );
    RETURN_HR_IF_FAIL;

    // Remove items which are still marked "delete".
    pScopeCookie->RemoveMarkedChildren();

    pScopeCookie->MarkResultChildren( NEWRESULTCOOKIE_OLD );

    return S_OK;
  }

  //
  // JonN 1/27/00: WinSE 5875: The refresh action is liable to delete pDataObject
  // unless we keep an extra refcount.  In practice, this only appears to happen
  // when we delete a share in taskpad view.
  //
  CComPtr<IDataObject> spDataObject = pDataObject;

  // clear all views of this data
  hr = m_pConsole->UpdateAllViews( pDataObject, 0L, 0L );
  RETURN_HR_IF_FAIL;

  // reread all views of this data
  hr = m_pConsole->UpdateAllViews( pDataObject, 1L, 0L );
  RETURN_HR_IF_FAIL;

  // UpdateToolbar if selected
  hr = m_pConsole->UpdateAllViews( pDataObject, 3L, 0L );
  
  return hr;
} // CFileMgmtComponent::RefreshAllViews()

// OnViewChange is generated by UpdateAllViews( lpDataObject, data, hint )
HRESULT CFileMgmtComponent::OnViewChange( LPDATAOBJECT lpDataObject, LPARAM data, LPARAM /*hint*/ )
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
  CWaitCursor wait;

  ASSERT( NULL != lpDataObject );

  if (NULL == m_pViewedCookie) // skip this component if not being viewed
    return S_OK;

  CCookie* pbasecookie = NULL;
  HRESULT hr = ExtractData( lpDataObject,
    CDataObject::m_CFRawCookie,
    &pbasecookie,
    sizeof(pbasecookie) );

  RETURN_HR_IF_FAIL; // MMC shouldn't have given me someone else's cookie
  pbasecookie = QueryBaseComponentDataRef().ActiveBaseCookie( pbasecookie );
  CFileMgmtCookie* pUpdatedCookie = dynamic_cast<CFileMgmtCookie*>(pbasecookie);
  RETURN_E_FAIL_IF_NULL(pUpdatedCookie);
  FileMgmtObjectType objTypeForUpdatedCookie = pUpdatedCookie->QueryObjectType();

  switch (m_pViewedCookie->QueryObjectType())
  {
  case FILEMGMT_ROOT:
    return S_OK; // there is never any need to refresh this
  case FILEMGMT_RESOURCES:
    if ( FILEMGMT_RESOURCE == objTypeForUpdatedCookie ||
         FILEMGMT_RESOURCES == objTypeForUpdatedCookie)
      break;
    // fall through
  case FILEMGMT_SESSIONS:
    if ( FILEMGMT_SESSION == objTypeForUpdatedCookie ||
         FILEMGMT_SESSIONS == objTypeForUpdatedCookie)
      break;
    // fall through
  case FILEMGMT_SHARES:
    if ( FILEMGMT_SHARE == objTypeForUpdatedCookie ||
         FILEMGMT_SHARES == objTypeForUpdatedCookie)
      break;
    return S_OK;
  case FILEMGMT_SERVICES:
    if ( FILEMGMT_SERVICE == objTypeForUpdatedCookie ||
         FILEMGMT_SERVICES == objTypeForUpdatedCookie)
      break;
    return S_OK;
  case FILEMGMT_SHARE:
  case FILEMGMT_SESSION:
  case FILEMGMT_RESOURCE:
  case FILEMGMT_SERVICE:
  default:
    ASSERT(FALSE); // this shouldn't be possible
    return S_OK;
  }

  // There should be no need to compare machine name, since these are both from the
  // same instance.

  if ( 0L == data )
  {
    ASSERT( NULL != m_pResultData );
    VERIFY( SUCCEEDED(m_pResultData->DeleteAllRsltItems()) );
    m_pViewedCookie->ReleaseResultChildren();
    //
    // At this point, m_pViewedCookie is still the viewed cookie for this IComponent
    // but (once this has happened to all of the views) its list of result children
    // is empty and its m_nResultCookiesRefcount is zero.  This must be followed
    // promptly with PopulateListbox calls for these views since this is not a good
    // state for the cookie.
    //
  }
  else if ( 1L == data )
  {
    // 2002/02/26-JonN overactive assertion
    (void) PopulateListbox( m_pViewedCookie );
  }
  else if ( 2L == data )
  {
    VERIFY( SUCCEEDED(RefreshNewResultCookies( *m_pViewedCookie )) );
  }
  else if ( 3L == data )
  {
    if (m_pSelectedCookie == pbasecookie)
      UpdateToolbar(lpDataObject, TRUE);
  }
  else
  {
    ASSERT(FALSE);
  }

  return S_OK;
} // CFileMgmtComponent::OnViewChange()


/////////////////////////////////////////////////////////////////////
// CFileMgmtComponent::CComponent::OnNotifyRefresh()
// 
// Virtual function called by CComponent::IComponent::Notify(MMCN_REFRESH)
// OnNotifyRefresh is generated by enabling the verb MMC_VERB_REFRESH.
HRESULT CFileMgmtComponent::OnNotifyRefresh( LPDATAOBJECT lpDataObject )
{
  TRACE0("CFileMgmtComponent::OnNotifyRefresh()\n");
  ASSERT(m_pResultData != NULL);
  if ( !m_pResultData )
    return E_POINTER;
  if ( !m_pViewedCookie )
  {
    ASSERT(FALSE);
    return S_OK;
  }

  // We used to use the cookie here from lpDataObject.  However, if one node
  // is selected and the user right clicks on a different one we an
  // lpDataObject for a node that is not enumerated in the result pane.
  // It results in bizarre behavior.  So use the m_pViewedCookie, instead.
  HRESULT    hr = S_OK;
  switch (m_pViewedCookie->QueryObjectType())
  {
  case FILEMGMT_SHARES:
  case FILEMGMT_SESSIONS:
  case FILEMGMT_RESOURCES:
  case FILEMGMT_SERVICES:
    (void) RefreshAllViews( lpDataObject );
    break;

  case FILEMGMT_ROOT:
  case FILEMGMT_SERVICE:   // Service was selected
  case FILEMGMT_SHARE:     // Share was selected
  case FILEMGMT_SESSION:   // Session was selected
  case FILEMGMT_RESOURCE:  // Open file was selected
  default:
    // This can happen if you select Shares, then select Shared Folders,
    // then right-click Shares and choose Refresh.  JonN 12/7/98
    break; // no need to refresh
  }

  return S_OK;
}

/////////////////////////////////////////////////////////////////////
// CFileMgmtComponent::RefreshNewResultCookies()
// 12/03/98 JonN     Created
// In the mark-and-sweep refresh algorithm, we have already marked all cookies
// as "old", "new" or "delete".  The view must now be made to conform with the list.
HRESULT CFileMgmtComponent::RefreshNewResultCookies( CCookie& refparentcookie )
{
  ASSERT( NULL != m_pResultData );

  RESULTDATAITEM tRDItem;
  ::ZeroMemory( &tRDItem, sizeof(tRDItem) );
  tRDItem.nCol = 0;
  tRDItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
  tRDItem.str = MMC_CALLBACK;
  // CODEWORK should use MMC_ICON_CALLBACK here

  HRESULT hr = S_OK;
  POSITION pos = refparentcookie.m_listResultCookieBlocks.GetHeadPosition();
  while (NULL != pos)
  {
    CBaseCookieBlock* pblock = refparentcookie.m_listResultCookieBlocks.GetNext( pos );
    ASSERT( NULL != pblock && 1 == pblock->QueryNumCookies() );
    CCookie* pbasecookie = pblock->QueryBaseCookie(0);
    CNewResultCookie* pcookie = dynamic_cast<CNewResultCookie*>(pbasecookie);
    RETURN_E_FAIL_IF_NULL(pcookie);
    if ( pcookie->IsMarkedOld() )
    {
      continue; // Leave this one alone
    }
    else if ( pcookie->IsMarkedNew() )
    { // This one was just added to the list, add it to the view
      tRDItem.nImage = QueryBaseComponentDataRef().QueryImage( *pbasecookie, FALSE );
      // WARNING cookie cast
      tRDItem.lParam = reinterpret_cast<LPARAM>(pbasecookie);
      hr = m_pResultData->InsertItem(&tRDItem);
      if ( FAILED(hr) )
      {
        ASSERT(FALSE);
        break;
      }
    }
    else if ( pcookie->IsMarkedChanged() )
    { // This one was already in the list but its fields were altered, update
      HRESULTITEM hItem = 0;
      hr = m_pResultData->FindItemByLParam( reinterpret_cast<LPARAM>(pbasecookie), &hItem );
      if ( FAILED(hr) || 0 == hItem )
      {
        ASSERT(FALSE);
        continue;
      }
      VERIFY( SUCCEEDED(m_pResultData->UpdateItem( hItem )) );
    }
    else
    { // This one was just marked for deletion, remove it from the view
      // CODEWORK This may be a performance problem when the list is long
      // CODEWORK BryanWal doesn't trust FindItemByLParam!  Test carefully!
      ASSERT( pcookie->IsMarkedForDeletion() );
      HRESULTITEM hItem = 0;
      hr = m_pResultData->FindItemByLParam( reinterpret_cast<LPARAM>(pbasecookie), &hItem );
      if ( FAILED(hr) || 0 == hItem )
      {
        ASSERT(FALSE);
        continue;
      }
      VERIFY( SUCCEEDED(m_pResultData->DeleteItem( hItem, 0 )) );
    }
  }
  VERIFY( SUCCEEDED(m_pResultData->Sort( m_iSortColumn , m_dwSortFlags, 0 )) );
  return hr;
}

HRESULT CFileMgmtComponent::OnNotifySelect( LPDATAOBJECT lpDataObject, BOOL fSelected )
{
    HRESULT hr = S_OK;
    BOOL    bMultiSelectObject = FALSE;

    //
    // MMC passes in SI_MS_DO in MMCN_SELECT in case of multiselection.
    //
    CFileMgmtDataObject *pDataObj = NULL;
    hr = ExtractData(lpDataObject, CFileMgmtDataObject::m_CFInternal, &pDataObj, sizeof(pDataObj));
    if (SUCCEEDED(hr))
    {
        CDataObjectList* pMultiSelectObjList = pDataObj->GetMultiSelectObjList();
        bMultiSelectObject = !(pMultiSelectObjList->empty());
    }

    //
    // no verbs to add for multi-selected SharedFolders items
    //
    if (!bMultiSelectObject)
    {
        CCookie* pbasecookie = NULL;
        hr = ExtractData( lpDataObject,
                        CDataObject::m_CFRawCookie,
                        &pbasecookie,
                        sizeof(pbasecookie) );
        RETURN_HR_IF_FAIL; // MMC shouldn't have given me someone else's cookie
        pbasecookie = QueryBaseComponentDataRef().ActiveBaseCookie( pbasecookie );
        CFileMgmtCookie* pUpdatedCookie = dynamic_cast<CFileMgmtCookie*>(pbasecookie);
        RETURN_E_FAIL_IF_NULL(pUpdatedCookie);

        m_pSelectedCookie = (fSelected) ? pUpdatedCookie : NULL;

        UpdateDefaultVerbs();
    }

    return S_OK;
}

void CFileMgmtComponent::UpdateDefaultVerbs()
{
  if (NULL == m_pSelectedCookie)
    return;

  FileMgmtObjectType objtypeSelected = m_pSelectedCookie->QueryObjectType();

  if (NULL != m_pViewedCookie)
  {
    BOOL fEnableRefresh = FALSE;
    FileMgmtObjectType objtypeViewed = m_pViewedCookie->QueryObjectType();

    switch (objtypeViewed)
    {
    case FILEMGMT_SHARES:
      if (FILEMGMT_SHARES == objtypeSelected || FILEMGMT_SHARE == objtypeSelected)
        fEnableRefresh = TRUE;
      break;
    case FILEMGMT_SESSIONS:
      if (FILEMGMT_SESSIONS == objtypeSelected || FILEMGMT_SESSION == objtypeSelected)
        fEnableRefresh = TRUE;
      break;
    case FILEMGMT_RESOURCES:
      if (FILEMGMT_RESOURCES == objtypeSelected || FILEMGMT_RESOURCE == objtypeSelected)
        fEnableRefresh = TRUE;
      break;
    case FILEMGMT_SERVICES:
      if (FILEMGMT_SERVICES == objtypeSelected || FILEMGMT_SERVICE == objtypeSelected)
        fEnableRefresh = TRUE;
      break;
    }
    if (fEnableRefresh)
    {
      // Enable the refresh menuitem
      VERIFY( SUCCEEDED(m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE)) );
    }
  }

  switch (objtypeSelected)
  {
  case FILEMGMT_SHARE:  // Share was selected
    //
    // don't enable Properties on the menu whenever SimpleSharingUI appears in NT Explorer
    //
    if (QueryComponentDataRef().GetIsSimpleUI())
    {
        VERIFY( SUCCEEDED(m_pConsoleVerb->SetDefaultVerb(MMC_VERB_NONE)) );
        break;
    }
    // fall through
  case FILEMGMT_SERVICE:  // Service was selected
    // Set the default verb to display the properties of the selected object
    VERIFY( SUCCEEDED(m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE)) );
    VERIFY( SUCCEEDED(m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES)) );
    break;

  case FILEMGMT_SESSION:  // Session was selected
  case FILEMGMT_RESOURCE:  // Open file was selected
    VERIFY( SUCCEEDED(m_pConsoleVerb->SetDefaultVerb(MMC_VERB_NONE)) );
    break;

  case FILEMGMT_SHARES:
  case FILEMGMT_SESSIONS:
  case FILEMGMT_RESOURCES:
  case FILEMGMT_SERVICES:
  case FILEMGMT_ROOT:  // Root node was selected
    // set the default verb to open/expand the folder
    VERIFY( SUCCEEDED(m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN)) );
    break;

  default: // shouldn't happen
    ASSERT(FALSE);
    break;

  } // switch

} // CFileMgmtComponent::OnNotifySelect()

STDMETHODIMP CFileMgmtComponent::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    HRESULT hr = S_OK;

    MFC_TRY;

    //
    // MMC queries us for a multiselect data object (SI_MS_DO) by 
    // passing the special cookie in this QueryDataObject call.
    //
    if (IS_SPECIAL_COOKIE(cookie) && MMC_MULTI_SELECT_COOKIE == cookie) 
    {
        CComObject<CFileMgmtDataObject>* pDataObject = NULL;
        hr = CComObject<CFileMgmtDataObject>::CreateInstance(&pDataObject);

        if (SUCCEEDED(hr))
            hr = pDataObject->InitMultiSelectDataObjects(QueryComponentDataRef());

        if (SUCCEEDED(hr))
        {
            //
            // We create a multiselect data object (SI_MS_DO), which contains
            // an internal list of data objects of selected items.
            //
            RESULTDATAITEM rdi = {0};
            int nIndex = -1;
            do
            {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM));
                rdi.mask    = RDI_STATE;
                rdi.nCol    = 0;
                rdi.nIndex  = nIndex;            // nIndex == -1 to start at first item
                rdi.nState  = LVIS_SELECTED;    // only interested in selected items

                hr = m_pResultData->GetNextItem(&rdi);
                if (FAILED(hr))
                    break;

                if (rdi.nIndex != -1)
                {
                    //
                    // rdi is the RESULTDATAITEM of a selected item. its lParam contains the cookie.
                    // Add it to the internal data object list.
                    //
                    CCookie* pbasecookie = reinterpret_cast<CCookie*>(rdi.lParam);
                    CFileMgmtCookie* pUseThisCookie = QueryComponentDataRef().ActiveCookie((CFileMgmtCookie*)pbasecookie);
                    pDataObject->AddMultiSelectDataObjects(pUseThisCookie, type);
                }

                nIndex = rdi.nIndex;

            } while (-1 != nIndex);
        }

        //
        // return this SI_MS_DO to MMC
        //
        if (SUCCEEDED(hr)) 
            hr = pDataObject->QueryInterface(IID_IDataObject, (void **)ppDataObject);
        
        if (FAILED(hr))
            delete pDataObject;
    }
    else
    {
        // Delegate it to the IComponentData
        hr = QueryBaseComponentDataRef().QueryDataObject(cookie, type, ppDataObject);
    }

    MFC_CATCH;

    return hr;
}

STDMETHODIMP CFileMgmtComponent::GetResultViewType(MMC_COOKIE cookie,
                                           BSTR* ppViewType,
                                           long* pViewOptions)
{
    *ppViewType = NULL;

    //
    // we support multiselection in SharedFolders snapin
    //
    CCookie* pbasecookie = reinterpret_cast<CCookie*>(cookie);
    CFileMgmtCookie* pUseThisCookie = QueryComponentDataRef().ActiveCookie((CFileMgmtCookie*)pbasecookie);
    FileMgmtObjectType objecttype = pUseThisCookie->QueryObjectType();
    if ( FILEMGMT_SHARES == objecttype ||
        FILEMGMT_SESSIONS == objecttype ||
        FILEMGMT_RESOURCES == objecttype )
    {
        *pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;
    } else
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
    }

    return S_FALSE;
}

HRESULT CFileMgmtComponent::Show( CCookie* pcookie, LPARAM arg, HSCOPEITEM /*hScopeItem*/ )
{
  TEST_NONNULL_PTR_PARAM(pcookie);

  #ifndef SNAPIN_PROTOTYPER
  if ( 0 == arg )
  {
    //
    // This is a Hide notification
    //
    if ( NULL == m_pResultData )
    {
      ASSERT( FALSE );
      return E_UNEXPECTED;
    }

    // We should not get a Hide notification if we are not currently showing
    // CODEWORK see 287399: MMC: two MMCN_SHOW(0) notifications
    // ASSERT( (CFileMgmtCookie*)pcookie == m_pViewedCookie );
    if ( (CFileMgmtScopeCookie*)pcookie == m_pViewedCookie )
    {
      //
      // Only delete the cookies if no other views are using them
      //
      pcookie->ReleaseResultChildren();

      m_pViewedCookie->Release(); // JonN 10/1/01 465507
      m_pViewedCookie = NULL;

      UpdateDefaultVerbs();
    }
    
    return S_OK;
  } // if
  #else
    CPrototyperScopeCookie* pScopeCookie = (CPrototyperScopeCookie*) pcookie;
    if (pScopeCookie->m_ScopeType == HTML)
        return S_OK;
  #endif // SNAPIN_PROTOTYPER

  // We should not get a Show notification if we are already showing
  if ( NULL != m_pViewedCookie )
  {
    ASSERT(FALSE);
    return S_OK;
  }

  //
  // This is a Show notification
  // Build new cookies and insert them into the cookie and the view
  //

  ASSERT( IsAutonomousObjectType( ((CFileMgmtCookie*)pcookie)->QueryObjectType() ) );

  m_pViewedCookie = (CFileMgmtScopeCookie*)pcookie;
  m_pViewedCookie->AddRef(); // JonN 10/1/01 465507

  LoadColumns( m_pViewedCookie );

  UpdateDefaultVerbs();

  return PopulateListbox( m_pViewedCookie );
} // CFileMgmtComponent::Show()


HRESULT CFileMgmtComponent::OnNotifyAddImages( LPDATAOBJECT /*lpDataObject*/,
                                               LPIMAGELIST lpImageList,
                                               HSCOPEITEM /*hSelectedItem*/ )
{
  return QueryComponentDataRef().LoadIcons(lpImageList,TRUE);
}


HRESULT CFileMgmtComponent::PopulateListbox(CFileMgmtScopeCookie* pcookie)
{
  TEST_NONNULL_PTR_PARAM(pcookie);

  CWaitCursor cwait;

  HRESULT hr = S_OK;
  //
  // If this is the second view on the same data, just insert the same cookies
  // which are in the other views
  //
  if ( 1 < pcookie->AddRefResultChildren() )
  {
    hr = InsertResultCookies( *pcookie );
    if ( SUCCEEDED(hr) )
      hr = m_pResultData->Sort( m_iSortColumn , m_dwSortFlags, 0 );
    return hr;
  }

  INT iTransport;
  switch ( pcookie->QueryObjectType() )
  {
  case FILEMGMT_SHARES:
    for (iTransport = FILEMGMT_FIRST_TRANSPORT;
         iTransport < FILEMGMT_NUM_TRANSPORTS;
       iTransport++)
    {
      hr = GetFileServiceProvider(iTransport)->PopulateShares(m_pResultData,pcookie);
      if( FAILED(hr) )
        return hr;
    }
    break;

  case FILEMGMT_SESSIONS:
    for (iTransport = FILEMGMT_FIRST_TRANSPORT;
         iTransport < FILEMGMT_NUM_TRANSPORTS;
       iTransport++)
    {
      ASSERT( NULL != m_pResultData ); // otherwise we close all sessions
      hr = GetFileServiceProvider(iTransport)->EnumerateSessions (
          m_pResultData, pcookie, true);
      if( FAILED(hr) )
        return hr;
    }
    break;
    
  case FILEMGMT_RESOURCES:
    for (iTransport = FILEMGMT_FIRST_TRANSPORT;
         iTransport < FILEMGMT_NUM_TRANSPORTS;
       iTransport++)
    {
      ASSERT( NULL != m_pResultData ); // otherwise we close all sessions
      hr = GetFileServiceProvider(iTransport)->EnumerateResources(m_pResultData,pcookie);
      if( FAILED(hr) )
        return hr;
    }
    break;

  case FILEMGMT_SERVICES:
    //
    // JonN 12/03/98 Service_PopulateServices no longer inserts items into the list
    //
    hr = QueryComponentDataRef().Service_PopulateServices(m_pResultData, pcookie);
    if ( SUCCEEDED(hr) )
      hr = InsertResultCookies( *pcookie );
    if( FAILED(hr) )
      return hr;

  #ifdef SNAPIN_PROTOTYPER
  case FILEMGMT_PROTOTYPER:
    return Prototyper_HrPopulateResultPane(pcookie);
  #endif

  case FILEMGMT_ROOT:
    // We no longer need to explicitly insert these
    break;

  default:
    ASSERT( FALSE );
    // fall through
  }

  return m_pResultData->Sort( m_iSortColumn , m_dwSortFlags, 0 );
} // CFileMgmtComponent::PopulateListbox()

HRESULT CFileMgmtComponent::GetSnapinMultiSelectDataObject(
    LPDATAOBJECT i_pMMCMultiSelectDataObject,
    LPDATAOBJECT *o_ppSnapinMultiSelectDataObject
    )
{
    if (!i_pMMCMultiSelectDataObject || !o_ppSnapinMultiSelectDataObject)
        return E_INVALIDARG;

    *o_ppSnapinMultiSelectDataObject = NULL;

    //
    // i_pMMCMultiSelectDataObject is the composite data object (MMC_MS_DO) created by MMC.
    // We need to crack it to retrieve the multiselect data object (SI_MS_DO)
    // we provided to MMC in QueryDataObject().
    //
    STGMEDIUM   stgmedium = {TYMED_HGLOBAL, NULL, NULL};
    FORMATETC   formatetc = {CFileMgmtDataObject::m_CFMultiSelectSnapins, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    HRESULT     hr = i_pMMCMultiSelectDataObject->GetData(&formatetc, &stgmedium);

    if (SUCCEEDED(hr))
    {
        if (!stgmedium.hGlobal)
            return E_FAIL;

        //
        // Locate the SI_MS_DO we have provided to MMC in QueryDataObject().
        //
        SMMCDataObjects *pMMCDO = (SMMCDataObjects*)::GlobalLock(stgmedium.hGlobal);

        GUID guidSnapin = GUID_NULL;
        VERIFY( SUCCEEDED(QueryComponentDataRef().GetClassID(&guidSnapin)) );

        for (int i = 0; i < pMMCDO->count; i++)
        {
            GUID guid = GUID_NULL;
            hr = ExtractData(pMMCDO->lpDataObject[i], CFileMgmtDataObject::m_CFSnapInCLSID, &guid, sizeof(GUID));
            if (SUCCEEDED(hr) && guid == guidSnapin)
            {
                //
                // pMMCDO->lpDataObject[i] is the SI_MS_DO we have provided to MMC in QueryDataObject().
                //
                *o_ppSnapinMultiSelectDataObject = pMMCDO->lpDataObject[i];
                (*o_ppSnapinMultiSelectDataObject)->AddRef();

                break;
            }
        }

        ::GlobalUnlock(stgmedium.hGlobal);
        ::GlobalFree(stgmedium.hGlobal);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu Implementation

STDMETHODIMP CFileMgmtComponent::AddMenuItems(
                    IDataObject*          piDataObject,
                    IContextMenuCallback* piCallback,
                    long*                 pInsertionAllowed)
{
  MFC_TRY;

  TRACE_METHOD(CFileMgmtComponent,AddMenuItems);
  TEST_NONNULL_PTR_PARAM(piDataObject);
  TEST_NONNULL_PTR_PARAM(piCallback);
  TEST_NONNULL_PTR_PARAM(pInsertionAllowed);
  TRACE( "FileMgmt snapin: extending menu\n" );

    HRESULT hr = S_OK;

    FileMgmtObjectType objecttype = FILEMGMT_NUMTYPES;

    //
    // need to find out the object type in case of multiselection
    //
    BOOL bMultiSelectObject = IsMultiSelectObject(piDataObject);
    if (!bMultiSelectObject)
    {
        objecttype = FileMgmtObjectTypeFromIDataObject(piDataObject);
    } else
    {
        //
        // piDataObject is the composite data object (MMC_MS_DO) created by MMC.
        // We need to crack it to retrieve the multiselect data object (SI_MS_DO)
        // we provided to MMC in QueryDataObject().
        //
        IDataObject *piSIMSDO = NULL;
        hr = GetSnapinMultiSelectDataObject(piDataObject, &piSIMSDO);
        if (SUCCEEDED(hr))
        {
            //
            // Note: we assume all multiselected items are of the same type.
            // 
            // Now retrieve data type of the currently selected items
            //
            STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL, NULL};
            FORMATETC formatetc = {CFileMgmtDataObject::m_CFObjectTypesInMultiSelect,
                                    NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
            hr = piSIMSDO->GetData(&formatetc, &stgmedium);
            if (SUCCEEDED(hr) && stgmedium.hGlobal)
            {
                BYTE* pb = (BYTE*)::GlobalLock(stgmedium.hGlobal);

                GUID* pguid = (GUID*)(pb + sizeof(DWORD)); // skip the 1st DWORD - count
                objecttype = (FileMgmtObjectType)CheckObjectTypeGUID(pguid);

                ::GlobalUnlock(stgmedium.hGlobal);
                ::GlobalFree(stgmedium.hGlobal);
            }

            piSIMSDO->Release();
        }
    }

  switch (objecttype)
  {
  case FILEMGMT_SHARE:
      if (FALSE == IsMultiSelectObject(piDataObject))
      {
            FILEMGMT_TRANSPORT transport = FILEMGMT_SFM;
            ExtractData( piDataObject,
                        CFileMgmtDataObject::m_CFTransport,
                        &transport,
                        sizeof(DWORD) );

            if (FILEMGMT_SMB == transport)
            {
                CString strShareName;
                ExtractString( piDataObject, CFileMgmtDataObject::m_CFShareName, &strShareName, MAX_PATH );

                if (0 != strShareName.CompareNoCase(_T("IPC$")))
                {
                    if ( CCM_INSERTIONALLOWED_TOP & (*pInsertionAllowed) )
                    {
                        hr = LoadAndAddMenuItem( piCallback, IDS_OPEN_SHARE_TOP, IDS_OPEN_SHARE_TOP,
                                    CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, AfxGetInstanceHandle(), _T("OpenShareTop") );
                        ASSERT( SUCCEEDED(hr) );
                    }
                    if ( CCM_INSERTIONALLOWED_TASK & (*pInsertionAllowed) )
                    {
                        hr = LoadAndAddMenuItem( piCallback, IDS_OPEN_SHARE_TASK, IDS_OPEN_SHARE_TASK,
                                    CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, AfxGetInstanceHandle(), _T("OpenShareTask") );
                        ASSERT( SUCCEEDED(hr) );
                    }
                }
            }
      }

    //
    // don't add acl-related menu items whenever SimpleSharingUI appears in NT Explorer
    //
    if (QueryComponentDataRef().GetIsSimpleUI())
        break;

    if ( CCM_INSERTIONALLOWED_TOP & (*pInsertionAllowed) )
    {
      hr = LoadAndAddMenuItem( piCallback, IDS_DELETE_SHARE_TOP, IDS_DELETE_SHARE_TOP,
        CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, AfxGetInstanceHandle(), _T("DeleteShareTop") );
      ASSERT( SUCCEEDED(hr) );
    }
    if ( CCM_INSERTIONALLOWED_TASK & (*pInsertionAllowed) )
    {
      hr = LoadAndAddMenuItem( piCallback, IDS_DELETE_SHARE_TASK, IDS_DELETE_SHARE_TASK,
        CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, AfxGetInstanceHandle(), _T("DeleteShareTask") );
      ASSERT( SUCCEEDED(hr) );
    }
    if ( CCM_INSERTIONALLOWED_NEW & (*pInsertionAllowed) )
    {
      hr = LoadAndAddMenuItem( piCallback, IDS_NEW_SHARE_NEW, IDS_NEW_SHARE_NEW,
        CCM_INSERTIONPOINTID_PRIMARY_NEW, 0, AfxGetInstanceHandle(), _T("NewShareNew") );
      ASSERT( SUCCEEDED(hr) );
    }
    break;

  case FILEMGMT_SESSION:
    if ( CCM_INSERTIONALLOWED_TOP & (*pInsertionAllowed) )
    {
      hr = LoadAndAddMenuItem( piCallback, IDS_CLOSE_SESSION_TOP, IDS_CLOSE_SESSION_TOP,
        CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, AfxGetInstanceHandle(), _T("CloseSessionTop") );
      ASSERT( SUCCEEDED(hr) );
    }
    if ( CCM_INSERTIONALLOWED_TASK & (*pInsertionAllowed) )
    {
      hr = LoadAndAddMenuItem( piCallback, IDS_CLOSE_SESSION_TASK, IDS_CLOSE_SESSION_TASK,
        CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, AfxGetInstanceHandle(), _T("CloseSessionTask") );
      ASSERT( SUCCEEDED(hr) );
    }
    break;

  case FILEMGMT_RESOURCE:
    if ( CCM_INSERTIONALLOWED_TOP & (*pInsertionAllowed) )
    {
      hr = LoadAndAddMenuItem( piCallback, IDS_CLOSE_RESOURCE_TOP, IDS_CLOSE_RESOURCE_TOP,
        CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, AfxGetInstanceHandle(), _T("CloseResourceTop") );
      ASSERT( SUCCEEDED(hr) );
    }
    if ( CCM_INSERTIONALLOWED_TASK & (*pInsertionAllowed) )
    {
      hr = LoadAndAddMenuItem( piCallback, IDS_CLOSE_RESOURCE_TASK, IDS_CLOSE_RESOURCE_TASK,
        CCM_INSERTIONPOINTID_PRIMARY_TASK, 0, AfxGetInstanceHandle(), _T("CloseResourceTask") );
      ASSERT( SUCCEEDED(hr) );
    }
    break;

  case FILEMGMT_SERVICE:
    QueryComponentDataRef().Service_FAddMenuItems(piCallback, piDataObject);
    break;

  #ifdef SNAPIN_PROTOTYPER
    case FILEMGMT_PROTOTYPER_LEAF:
        Prototyper_AddMenuItems(piCallback, piDataObject);
        break;
    #endif // SNAPIN_PROTOTYPER

  default:
      {
        DATA_OBJECT_TYPES dataobjecttype = CCT_SCOPE;
        hr = ExtractData( piDataObject,
                            CFileMgmtDataObject::m_CFDataObjectType,
                            &dataobjecttype,
                            sizeof(dataobjecttype) );
        ASSERT( SUCCEEDED(hr) );

        // perhaps this is a scope node in the result pane
        hr = QueryComponentDataRef().DoAddMenuItems( piCallback,
                                                    objecttype,
                                                    dataobjecttype,
                                                    pInsertionAllowed,
                                                    piDataObject );
      }
    break;
  } // switch

    return hr;

    MFC_CATCH;

} // CFileMgmtComponent::AddMenuItems()

STDMETHODIMP CFileMgmtComponent::Command(
                    LONG            lCommandID,
                    IDataObject*    piDataObject )
{
  MFC_TRY;

  TRACE_METHOD(CFileMgmtComponent,Command);
  TEST_NONNULL_PTR_PARAM(piDataObject);
  TRACE( "CFileMgmtComponent::Command: command %ld selected\n", lCommandID );

  #ifdef SNAPIN_PROTOTYPER
  Prototyper_ContextMenuCommand(lCommandID, piDataObject);
  return S_OK;
  #endif

  BOOL fFSMRefresh = FALSE;
  BOOL fSVCRefresh = FALSE;
  switch (lCommandID)
  {
  case IDS_OPEN_SHARE_TASK:
  case IDS_OPEN_SHARE_TOP:
    OpenShare( piDataObject );
    break;
  case IDS_DELETE_SHARE_TASK:
  case IDS_DELETE_SHARE_TOP:
    fFSMRefresh = DeleteShare( piDataObject );
    break;
  case IDS_CLOSE_SESSION_TASK:
  case IDS_CLOSE_SESSION_TOP:
    fFSMRefresh = CloseSession( piDataObject );
    break;
  case IDS_CLOSE_RESOURCE_TASK:
  case IDS_CLOSE_RESOURCE_TOP:
    fFSMRefresh = CloseResource( piDataObject );
    break;

  case cmServiceStart:
  case cmServiceStop:
  case cmServicePause:
  case cmServiceResume:
  case cmServiceRestart:
  case cmServiceStartTask:
  case cmServiceStopTask:
  case cmServicePauseTask:
  case cmServiceResumeTask:
  case cmServiceRestartTask:
    fSVCRefresh = QueryComponentDataRef().Service_FDispatchMenuCommand(lCommandID, piDataObject);
    break;

  default:
    return QueryComponentDataRef().Command(lCommandID, piDataObject);
  } // switch

  if (fFSMRefresh)
  {
    //
    // In case of multiselect, piDataObject may point to a composite data object (MMC_MS_DO).
    // RefreshAllViewsOnSelectedObject will crack down MMC_MS_DO to retrieve SI_MS_DO, then call
    // RefreshAllViews on one of the selected objects in the internal list.
    //
    (void) RefreshAllViewsOnSelectedObject(piDataObject);
  }

  if (fSVCRefresh)
  {
    (void) RefreshAllViews( piDataObject );
  }

    return S_OK;
    MFC_CATCH;
} // CFileMgmtComponent::Command()

BOOL CFileMgmtComponent::OpenShare(LPDATAOBJECT piDataObject)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
  ASSERT( piDataObject != NULL );
#ifdef DEBUG
  {
    FileMgmtObjectType objecttype = FileMgmtObjectTypeFromIDataObject(piDataObject);
    ASSERT(FILEMGMT_SHARE == objecttype);
  }
#endif

  CString strServerName;
  HRESULT hr = ExtractString( piDataObject, CFileMgmtDataObject::m_CFMachineName, &strServerName, MAX_PATH );
  if (FAILED(hr))
      return TRUE; // something is wrong, refresh

  CString strShareName;
  hr = ExtractString( piDataObject, CFileMgmtDataObject::m_CFShareName, &strShareName, MAX_PATH );
  if (FAILED(hr))
      return TRUE; // something is wrong, refresh

  FILEMGMT_TRANSPORT transport;
  hr = ExtractData( piDataObject,
                    CFileMgmtDataObject::m_CFTransport,
                    &transport,
                    sizeof(DWORD) );
  if (FAILED(hr))
      return TRUE; // something is wrong, refresh

  DWORD retval = 0L;
  switch (transport)
  {
  case FILEMGMT_SMB:
    {
        CWaitCursor wait;
        retval = GetFileServiceProvider(transport)->OpenShare(strServerName, strShareName);
    }
    break;
  case FILEMGMT_SFM:
  default:
    ASSERT(FALSE);
    break;
  }

  if (NERR_Success == retval)
  {
      return FALSE; // no need to refresh
  }

  return TRUE;
}

BOOL CFileMgmtComponent::DeleteShare(LPDATAOBJECT piDataObject)
{
    ASSERT( piDataObject != NULL );

    BOOL bMultiSelectObject = IsMultiSelectObject(piDataObject);
    if (!bMultiSelectObject)
        return DeleteThisOneShare(piDataObject, FALSE);

    BOOL bRefresh = FALSE;
    if (IDYES == DoErrMsgBox(GetActiveWindow(), MB_YESNO, 0, IDS_s_CONFIRM_DELETEMULTISHARES))
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        CWaitCursor wait;

        //
        // piDataObject is the composite data object (MMC_MS_DO) created by MMC.
        // We need to crack it to retrieve the multiselect data object (SI_MS_DO)
        // we provided to MMC in QueryDataObject().
        //
        IDataObject *piSIMSDO = NULL;
        HRESULT hr = GetSnapinMultiSelectDataObject(piDataObject, &piSIMSDO);
        if (SUCCEEDED(hr))
        {
            CFileMgmtDataObject *pDataObj = NULL;
            hr = ExtractData(piSIMSDO, CFileMgmtDataObject::m_CFInternal, &pDataObj, sizeof(pDataObj));
            if (SUCCEEDED(hr))
            {
                //
                // get the internal list of data objects of selected items, operate on each one of them.
                //
                CDataObjectList* pMultiSelectObjList = pDataObj->GetMultiSelectObjList();
                for (CDataObjectList::iterator i = pMultiSelectObjList->begin(); i != pMultiSelectObjList->end(); i++)
                {
                     BOOL bDeleted = DeleteThisOneShare(*i, TRUE);
                     if (bDeleted)
                         bRefresh = TRUE;
                }
            }

            piSIMSDO->Release();
        }
    }

    return bRefresh;
}

BOOL CFileMgmtComponent::DeleteThisOneShare(LPDATAOBJECT piDataObject, BOOL bQuietMode)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
  ASSERT( piDataObject != NULL );
#ifdef DEBUG
  {
    FileMgmtObjectType objecttype = FileMgmtObjectTypeFromIDataObject(piDataObject);
    ASSERT(FILEMGMT_SHARE == objecttype);
  }
#endif

  CString strServerName;
  HRESULT hr = ExtractString( piDataObject, CFileMgmtDataObject::m_CFMachineName, &strServerName, MAX_PATH );
  RETURN_FALSE_IF_FAIL;

  CString strShareName;
  hr = ExtractString( piDataObject, CFileMgmtDataObject::m_CFShareName, &strShareName, MAX_PATH );
  RETURN_FALSE_IF_FAIL;

  FILEMGMT_TRANSPORT transport;
  hr = ExtractData( piDataObject,
                  CFileMgmtDataObject::m_CFTransport,
            &transport,
            sizeof(DWORD) );
  RETURN_FALSE_IF_FAIL;

  BOOL fNetLogonShare = (!lstrcmpi(strShareName, _T("SYSVOL")) || !lstrcmpi(strShareName, _T("NETLOGON")));
  BOOL fIPC = FALSE;
  BOOL fAdminShare = FALSE;

  if (!fNetLogonShare && transport == FILEMGMT_SMB)
  {
    DWORD dwShareType = 0;
    GetFileServiceProvider(transport)->ReadShareType(strServerName, strShareName, &dwShareType);
    fAdminShare = (dwShareType & STYPE_SPECIAL);
    fIPC = (STYPE_IPC == (dwShareType & STYPE_IPC));
  }

  if (fIPC)
  {
      DoErrMsgBox(
                  GetActiveWindow(),
                  MB_OK | MB_ICONEXCLAMATION,
                  0,
                  IDS_s_DELETE_IPCSHARE
                  );
      return FALSE;
  }

  if ((fNetLogonShare || fAdminShare) &&
      IDYES != DoErrMsgBox(
                  GetActiveWindow(),
                  MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2,
                  0,
                  (fAdminShare ? IDS_s_CONFIRM_DELETE_ADMINSHARE : IDS_s_CONFIRM_DELETE_NETLOGONSHARE),
                  strShareName) )
  {
      return FALSE;
  }

  DWORD retval = 0L;
  switch (transport)
  {
  case FILEMGMT_SMB:
  case FILEMGMT_SFM:
    {
        if (!bQuietMode)
        {
            hr = GetFileServiceProvider(transport)->ConfirmDeleteShare(strServerName, strShareName);
            if (S_FALSE == hr)
                return FALSE; // user cancels the operation and keep the share
            else if (S_OK != hr)
                return TRUE; // share may not exist, refresh
        }

        CWaitCursor wait;
        retval = GetFileServiceProvider(transport)->DeleteShare(strServerName, strShareName);
    }
    break;
  default:
    ASSERT(FALSE);
    break;
  }
  if (0L != retval)
  {
    (void) DoErrMsgBox(GetActiveWindow(), MB_OK | MB_ICONSTOP, retval, IDS_POPUP_DELETE_SHARE, strShareName);
    return FALSE;
  }
  return TRUE;
}

BOOL CFileMgmtComponent::CloseSession(LPDATAOBJECT piDataObject)
{
    ASSERT( piDataObject != NULL );

    BOOL bMultiSelectObject = IsMultiSelectObject(piDataObject);
    if (!bMultiSelectObject)
        return CloseThisOneSession(piDataObject, FALSE);

    BOOL bRefresh = FALSE;
    if (IDYES == DoErrMsgBox(GetActiveWindow(), MB_YESNO, 0, IDS_CONFIRM_CLOSEMULTISESSIONS))
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        CWaitCursor wait;

        //
        // piDataObject is the composite data object (MMC_MS_DO) created by MMC.
        // We need to crack it to retrieve the multiselect data object (SI_MS_DO)
        // we provided to MMC in QueryDataObject().
        //
        IDataObject *piSIMSDO = NULL;
        HRESULT hr = GetSnapinMultiSelectDataObject(piDataObject, &piSIMSDO);
        if (SUCCEEDED(hr))
        {
            CFileMgmtDataObject *pDataObj = NULL;
            hr = ExtractData(piSIMSDO, CFileMgmtDataObject::m_CFInternal, &pDataObj, sizeof(pDataObj));
            if (SUCCEEDED(hr))
            {
                //
                // get the internal list of data objects of selected items, operate on each one of them.
                //
                CDataObjectList* pMultiSelectObjList = pDataObj->GetMultiSelectObjList();
                for (CDataObjectList::iterator i = pMultiSelectObjList->begin(); i != pMultiSelectObjList->end(); i++)
                {
                     BOOL bDeleted = CloseThisOneSession(*i, TRUE);
                     if (bDeleted)
                         bRefresh = TRUE;
                }
            }

            piSIMSDO->Release();
        }
    }

    return bRefresh;
}

BOOL CFileMgmtComponent::CloseThisOneSession(LPDATAOBJECT piDataObject, BOOL bQuietMode)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

  ASSERT( piDataObject != NULL );

  CCookie* pbasecookie = NULL;
  FileMgmtObjectType objecttype = FILEMGMT_ROOT;
  HRESULT hr = ExtractBaseCookie( piDataObject, &pbasecookie, &objecttype );
  ASSERT( SUCCEEDED(hr) && NULL != pbasecookie && FILEMGMT_SESSION == objecttype );
  CFileMgmtResultCookie* pcookie = (CFileMgmtResultCookie*)pbasecookie;

  if ( !bQuietMode && IDYES != DoErrMsgBox(GetActiveWindow(), MB_YESNO, 0, IDS_CONFIRM_CLOSESESSION) )
  {
    return FALSE;
  }

  FILEMGMT_TRANSPORT transport = FILEMGMT_SMB;
  VERIFY( SUCCEEDED( pcookie->GetTransport( &transport ) ) );
  DWORD retval = 0;

  if (bQuietMode)
  {
    retval = GetFileServiceProvider(transport)->CloseSession( pcookie );
  } else
  {
    CWaitCursor wait;
    retval = GetFileServiceProvider(transport)->CloseSession( pcookie );
  }

  if (0L != retval)
  {
    (void) DoErrMsgBox(GetActiveWindow(), MB_OK | MB_ICONSTOP, retval, IDS_POPUP_CLOSE_SESSION);
    return FALSE;
  }
  return TRUE;
}

BOOL CFileMgmtComponent::CloseResource(LPDATAOBJECT piDataObject)
{
    ASSERT( piDataObject != NULL );

    BOOL bMultiSelectObject = IsMultiSelectObject(piDataObject);
    if (!bMultiSelectObject)
        return CloseThisOneResource(piDataObject, FALSE);

    BOOL bRefresh = FALSE;
    if (IDYES == DoErrMsgBox(GetActiveWindow(), MB_YESNO, 0, IDS_CONFIRM_CLOSEMULTIRESOURCES))
    {
        AFX_MANAGE_STATE(AfxGetStaticModuleState( ));
        CWaitCursor wait;

        //
        // piDataObject is the composite data object (MMC_MS_DO) created by MMC.
        // We need to crack it to retrieve the multiselect data object (SI_MS_DO)
        // we provided to MMC in QueryDataObject().
        //
        IDataObject *piSIMSDO = NULL;
        HRESULT hr = GetSnapinMultiSelectDataObject(piDataObject, &piSIMSDO);
        if (SUCCEEDED(hr))
        {
            CFileMgmtDataObject *pDataObj = NULL;
            hr = ExtractData(piSIMSDO, CFileMgmtDataObject::m_CFInternal, &pDataObj, sizeof(pDataObj));
            if (SUCCEEDED(hr))
            {
                //
                // get the internal list of data objects of selected items, operate on each one of them.
                //
                CDataObjectList* pMultiSelectObjList = pDataObj->GetMultiSelectObjList();
                for (CDataObjectList::iterator i = pMultiSelectObjList->begin(); i != pMultiSelectObjList->end(); i++)
                {
                     BOOL bDeleted = CloseThisOneResource(*i, TRUE);
                     if (bDeleted)
                         bRefresh = TRUE;
                }
            }

            piSIMSDO->Release();
        }
    }

    return bRefresh;
}

BOOL CFileMgmtComponent::CloseThisOneResource(LPDATAOBJECT piDataObject, BOOL bQuietMode)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

  ASSERT( piDataObject != NULL );

  CCookie* pbasecookie = NULL;
  FileMgmtObjectType objecttype;
  HRESULT hr = ExtractBaseCookie( piDataObject, &pbasecookie, &objecttype );
  ASSERT( SUCCEEDED(hr) && NULL != pbasecookie && FILEMGMT_RESOURCE == objecttype );
  CFileMgmtResultCookie* pcookie = (CFileMgmtResultCookie*)pbasecookie;

  if ( !bQuietMode && IDYES != DoErrMsgBox(GetActiveWindow(), MB_YESNO, 0, IDS_CONFIRM_CLOSERESOURCE) )
  {
    return FALSE;
  }

  FILEMGMT_TRANSPORT transport = FILEMGMT_SMB;
  VERIFY( SUCCEEDED( pcookie->GetTransport( &transport ) ) );
  DWORD retval = 0;

  if (bQuietMode)
  {
    retval = GetFileServiceProvider(transport)->CloseResource( pcookie );
  } else
  {
    CWaitCursor wait;
    retval = GetFileServiceProvider(transport)->CloseResource( pcookie );
  }

  if (0L != retval)
  {
    (void) DoErrMsgBox(GetActiveWindow(), MB_OK | MB_ICONSTOP, retval, IDS_POPUP_CLOSE_RESOURCE);
    return FALSE;
  }
  return TRUE;

}

///////////////////////////////////////////////////////////////////////////////
/// IExtendPropertySheet

STDMETHODIMP CFileMgmtComponent::QueryPagesFor(LPDATAOBJECT pDataObject)
{
  MFC_TRY;

  if (NULL == pDataObject)
  {
    ASSERT(FALSE);
    return E_POINTER;
  }

  HRESULT hr = S_OK;
  DATA_OBJECT_TYPES dataobjecttype = CCT_SCOPE;
  // extract data from data object
  FileMgmtObjectType objecttype = FileMgmtObjectTypeFromIDataObject(pDataObject);
  hr = ExtractData( pDataObject, CFileMgmtDataObject::m_CFDataObjectType, &dataobjecttype, sizeof(dataobjecttype) );
  ASSERT( SUCCEEDED(hr) );
  ASSERT( CCT_SCOPE == dataobjecttype ||
        CCT_RESULT == dataobjecttype ||
        CCT_SNAPIN_MANAGER == dataobjecttype );

    // determine if it needs property pages
  switch (objecttype)
  {
  case FILEMGMT_SESSION:
  case FILEMGMT_RESOURCE:
    ASSERT(CCT_SNAPIN_MANAGER != dataobjecttype);
    return S_FALSE;
  case FILEMGMT_SHARE: // now has a property page
      {
          CString strServerName;
          CString strShareName;
          FILEMGMT_TRANSPORT transport;
          hr = ExtractString(pDataObject, CFileMgmtDataObject::m_CFMachineName, &strServerName, MAX_PATH);

          if (SUCCEEDED(hr))
              hr = ExtractString(pDataObject, CFileMgmtDataObject::m_CFShareName, &strShareName, MAX_PATH);

          if (SUCCEEDED(hr))
              hr = ExtractData(pDataObject, CFileMgmtDataObject::m_CFTransport, &transport, sizeof(DWORD));

          if (SUCCEEDED(hr))
          {
              CString strDescription;
              CString strPath;
              DWORD dwRet = GetFileServiceProvider(transport)->ReadShareProperties(
                                                                      strServerName,
                                                                      strShareName,
                                                                      NULL, // ppvPropertyBlock
                                                                      strDescription,
                                                                      strPath,
                                                                      NULL, // pfEditDescription
                                                                      NULL, // pfEditPath
                                                                      NULL // pdwShareType
                                                                      );
              if (NERR_Success == dwRet)
              {
                  return S_OK; // yes, we have a property page to display
              } else
              {
                  DoErrMsgBox(GetActiveWindow(), MB_OK | MB_ICONSTOP, dwRet, IDS_POPUP_QUERY_SHARE, strShareName);
                  if ((FILEMGMT_SMB == transport) && (NERR_NetNameNotFound == dwRet) ||
                      (FILEMGMT_SFM == transport) && (AFPERR_VolumeNonExist == dwRet))
                  {
                      RefreshAllViews(pDataObject);
                  }
              }
          }

          return S_FALSE;
      }
  case FILEMGMT_SERVICE:
    ASSERT(CCT_SNAPIN_MANAGER != dataobjecttype);
    return S_OK;
    #ifdef SNAPIN_PROTOTYPER
    case FILEMGMT_PROTOTYPER_LEAF:
        return S_OK;
    #endif
  default:
    break;
  }
  ASSERT(FALSE);
  return S_FALSE;

  MFC_CATCH;
}

STDMETHODIMP CFileMgmtComponent::CreatePropertyPages(
  LPPROPERTYSHEETCALLBACK pCallBack,
  LONG_PTR handle,    // This handle must be saved in the property page object to notify the parent when modified
  LPDATAOBJECT pDataObject)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

  if (NULL == pCallBack || NULL == pDataObject)
  {
    ASSERT(FALSE);
    return E_POINTER;
  }
  HRESULT hr;
  // extract data from data object
  FileMgmtObjectType objecttype = FileMgmtObjectTypeFromIDataObject(pDataObject);
  DATA_OBJECT_TYPES dataobjecttype = CCT_SCOPE;
  hr = ExtractData( pDataObject, CFileMgmtDataObject::m_CFDataObjectType, &dataobjecttype, sizeof(dataobjecttype) );
  ASSERT( SUCCEEDED(hr) );
  ASSERT( CCT_SCOPE == dataobjecttype ||
          CCT_RESULT == dataobjecttype ||
          CCT_SNAPIN_MANAGER == dataobjecttype );

    // determine if it needs property pages
  switch (objecttype)
  {
  case FILEMGMT_SHARE:
  {
    CWaitCursor cwait;

    if (CCT_SNAPIN_MANAGER == dataobjecttype)
    {
      ASSERT(FALSE);
      return E_UNEXPECTED;
    }

    FILEMGMT_TRANSPORT transport;
    hr = ExtractData( pDataObject,
                    CFileMgmtDataObject::m_CFTransport,
                    &transport,
                    sizeof(DWORD) );
    if ( FAILED(hr) )
    {
      ASSERT( FALSE );
      return E_UNEXPECTED;
    }

    // CODEWORK probably not necessary to split off transport at this point
    GetFileServiceProvider(transport)->DisplayShareProperties(pCallBack, pDataObject, handle);
    return S_OK;
  }
  case FILEMGMT_SESSION:
  case FILEMGMT_RESOURCE:
    ASSERT(FALSE);
    return E_UNEXPECTED;
  case FILEMGMT_SERVICE:
    if (CCT_RESULT != dataobjecttype)
    {
      ASSERT(FALSE);
      return E_UNEXPECTED;
    }

    if (!QueryComponentDataRef().Service_FInsertPropertyPages(OUT pCallBack, IN pDataObject, handle))
    {
      // Unable to open the service and query service info
      return S_FALSE;
    }
    return S_OK;
  default:
    break;
  }
  ASSERT(FALSE);
  return S_FALSE;
}

STDMETHODIMP CFileMgmtComponent::Compare(
  LPARAM /*lUserParam*/, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult)
{
  ASSERT(NULL != pnResult);
  // WARNING cookie cast
  CCookie* pBaseCookieA = reinterpret_cast<CCookie*>(cookieA);
  CCookie* pBaseCookieB = reinterpret_cast<CCookie*>(cookieB);
  ASSERT( NULL != pBaseCookieA && NULL != pBaseCookieB );
  CFileMgmtCookie* pCookieA = QueryComponentDataRef().ActiveCookie(
    (CFileMgmtCookie*)pBaseCookieA);
  CFileMgmtCookie* pCookieB = QueryComponentDataRef().ActiveCookie(
    (CFileMgmtCookie*)pBaseCookieB);
  ASSERT( NULL != pCookieA && NULL != pCookieB );
  FileMgmtObjectType objecttypeA = pCookieA->QueryObjectType();
  FileMgmtObjectType objecttypeB = pCookieB->QueryObjectType();
  ASSERT( IsValidObjectType(objecttypeA) && IsValidObjectType(objecttypeB) );
  if (objecttypeA != objecttypeB)
  {
    // assign an arbitrary ordering to cookies with different nodetypes
    *pnResult = ((int)objecttypeA) - ((int)objecttypeB);
    return S_OK;
  }

  return pCookieA->CompareSimilarCookies( pBaseCookieB, pnResult);
}


STDMETHODIMP CFileMgmtComponent::GetProperty( 
            /* [in] */ LPDATAOBJECT pDataObject,
            /* [in] */ BSTR szPropertyName,
            /* [out] */ BSTR* pbstrProperty)
{
  if (   IsBadReadPtr(pDataObject,sizeof(*pDataObject))
      || IsBadStringPtr(szPropertyName,0x7FFFFFFF)
      || IsBadWritePtr(pbstrProperty,sizeof(*pbstrProperty))
     )
  {
      ASSERT(FALSE);
      return E_POINTER;
  }

  CCookie* pbasecookie = NULL;
  HRESULT hr = ExtractBaseCookie( pDataObject, &pbasecookie );
  RETURN_HR_IF_FAIL;
  ASSERT(NULL != pbasecookie);
  CFileMgmtCookie* pcookie = (CFileMgmtCookie*)pbasecookie;

  CString strProperty;
  if (!_wcsicmp(L"CCF_HTML_DETAILS",szPropertyName))
  {
    if (FILEMGMT_SERVICE != pcookie->QueryObjectType())
      return S_FALSE;

    if (NULL == QueryComponentDataRef().m_hScManager)
    {
      ASSERT(FALSE);
      return S_FALSE;
    }

    CString strServiceName;
    if (!QueryComponentDataRef().Service_FGetServiceInfoFromIDataObject(
      pDataObject,
      NULL,
      OUT &strServiceName,
      NULL))
    {
      ASSERT(FALSE);
      return S_FALSE;
    }

    BOOL rgfMenuFlags[iServiceActionMax];
    ::ZeroMemory(rgfMenuFlags,sizeof(rgfMenuFlags));

    AFX_MANAGE_STATE(AfxGetStaticModuleState()); // required for CWaitCursor
    CWaitCursor wait;
    if (!Service_FGetServiceButtonStatus( // this will report errors itself
          QueryComponentDataRef().m_hScManager,
          strServiceName,
          OUT rgfMenuFlags,
          NULL,  // pdwCurrentState
          TRUE)) // fSilentError
    {
      return S_FALSE;
    }

    for (INT i = 0; i < iServiceActionMax; i++)
    {
      if (rgfMenuFlags[i])
      {
        CString strTemp;
        VERIFY(strTemp.LoadString(IDS_HTML_DETAILS_START+i));
        strProperty += strTemp;
      }
    }
  }
  else if (!_wcsicmp(L"CCF_DESCRIPTION",szPropertyName))
  {
    hr = pcookie->GetExplorerViewDescription( strProperty );
  }
  else
  {
    return S_FALSE; // unknown strPropertyName
  }

  *pbstrProperty = ::SysAllocString(strProperty);

  return S_OK;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_COLUMN_CLICK)
HRESULT CFileMgmtComponent::OnNotifyColumnClick( LPDATAOBJECT /*lpDataObject*/, LPARAM iColumn, LPARAM uFlags )
{
  m_iSortColumn = (int)iColumn;
  m_dwSortFlags = (DWORD) uFlags;
  return m_pResultData->Sort ((int)iColumn, (DWORD)uFlags, 0);
}

HRESULT CFileMgmtComponent::OnNotifySnapinHelp (LPDATAOBJECT /*pDataObject*/)
{
  return ShowHelpTopic( IsServiceSnapin()
                          ? L"sys_srv_overview.htm"
                          : L"file_srv_overview.htm" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\cookie.cpp ===
// Cookie.cpp : Implementation of CFileMgmtCookie and related classes

#include "stdafx.h"
#include "cookie.h"
#include "stdutils.h" // g_aNodetypeGuids
#include "cmponent.h"

#include "atlimpl.cpp"

DECLARE_INFOLEVEL(FileMgmtSnapin)

#include "macros.h"
USE_HANDLE_MACROS("FILEMGMT(cookie.cpp)")

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "stdcooki.cpp"

//
// This is used by the nodetype utility routines in stdutils.cpp
//

const struct NODETYPE_GUID_ARRAYSTRUCT g_NodetypeGuids[FILEMGMT_NUMTYPES] =
{
  { // FILEMGMT_ROOT
    structuuidNodetypeRoot,
    lstruuidNodetypeRoot },
  {  // FILEMGMT_SHARES
    structuuidNodetypeShares,
    lstruuidNodetypeShares },
  { // FILEMGMT_SESSIONS
    structuuidNodetypeSessions,
    lstruuidNodetypeSessions },
  { // FILEMGMT_RESOURCES
    structuuidNodetypeResources,
    lstruuidNodetypeResources },
  { // FILEMGMT_SERVICES
    structuuidNodetypeServices,
    lstruuidNodetypeServices },
  { // FILEMGMT_SHARE
    structuuidNodetypeShare,
    lstruuidNodetypeShare },
  { // FILEMGMT_SESSION
    structuuidNodetypeSession,
    lstruuidNodetypeSession },
  { // FILEMGMT_RESOURCE
    structuuidNodetypeResource,
    lstruuidNodetypeResource },
  { // FILEMGMT_SERVICE
    structuuidNodetypeService,
    lstruuidNodetypeService }
};

const struct NODETYPE_GUID_ARRAYSTRUCT* g_aNodetypeGuids = g_NodetypeGuids;

const int g_cNumNodetypeGuids = FILEMGMT_NUMTYPES;

//
// CFileMgmtCookie
//

HRESULT CFileMgmtCookie::GetTransport( FILEMGMT_TRANSPORT* /*ptransport*/ )
{
  return DV_E_FORMATETC;
}

HRESULT CFileMgmtCookie::GetShareName( OUT CString& /*strShareName*/ )
{
  return DV_E_FORMATETC;
}

HRESULT CFileMgmtCookie::GetSharePIDList( OUT LPITEMIDLIST * /*ppidl*/ )
{
  return DV_E_FORMATETC;
}

HRESULT CFileMgmtCookie::GetSessionClientName( OUT CString& /*strShareName*/ )
{
  return DV_E_FORMATETC;
}

HRESULT CFileMgmtCookie::GetSessionUserName( OUT CString& /*strShareName*/ )
{
  return DV_E_FORMATETC;
}

HRESULT CFileMgmtCookie::GetSessionID( DWORD* /*pdwFileID*/ )
{
  return DV_E_FORMATETC;
}

HRESULT CFileMgmtCookie::GetFileID( DWORD* /*pdwFileID*/ )
{
  return DV_E_FORMATETC;
}

HRESULT CFileMgmtCookie::GetServiceName( OUT CString& /*strServiceName*/ )
{
  return DV_E_FORMATETC;
}

HRESULT CFileMgmtCookie::GetServiceDisplayName( OUT CString& /*strServiceDisplayName*/ )
{
  return DV_E_FORMATETC;
}

HRESULT CFileMgmtCookie::GetExplorerViewDescription( OUT CString& /*strExplorerViewDescription*/ )
{
  return DV_E_FORMATETC;
}

HRESULT CFileMgmtCookie::CompareSimilarCookies (
    CCookie* pOtherCookie, 
    int* pnResult)
{
  CFileMgmtCookie* pcookie = (CFileMgmtCookie*)pOtherCookie;
  int iColumn = *pnResult;

  HRESULT hr = CHasMachineName::CompareMachineNames( *pcookie, pnResult );
  if (S_OK != hr || 0 != *pnResult)
    return hr;

  switch (QueryObjectType())
  {
  case FILEMGMT_SHARE:
    {
      switch (iColumn)
      {
      case COMPARESIMILARCOOKIE_FULL:
        {
          CComBSTR bstr1 = GetColumnText(COLNUM_SHARES_SHARED_FOLDER);
          CComBSTR bstr2 = pcookie->GetColumnText(COLNUM_SHARES_SHARED_FOLDER);
          *pnResult = ((!bstr1 || !bstr2) ? 0 : lstrcmpi(bstr1, bstr2));

          if (!*pnResult)
          {
            bstr1 = GetColumnText(COLNUM_SHARES_TRANSPORT);
            bstr2 = pcookie->GetColumnText(COLNUM_SHARES_TRANSPORT);
            *pnResult = ((!bstr1 || !bstr2) ? 0 : lstrcmpi(bstr1, bstr2));
          }
        }
        break;
      case COLNUM_SHARES_SHARED_FOLDER:
      case COLNUM_SHARES_SHARED_PATH:
      case COLNUM_SHARES_TRANSPORT:
      case COLNUM_SHARES_COMMENT:
        {
          CComBSTR bstr1 = GetColumnText(iColumn);
          CComBSTR bstr2 = pcookie->GetColumnText(iColumn);
          *pnResult = ((!bstr1 || !bstr2) ? 0 : lstrcmpi(bstr1, bstr2));
        }
        break;
      case COLNUM_SHARES_NUM_SESSIONS:
        {
          DWORD dw1 = GetNumOfCurrentUses();
          DWORD dw2 = pcookie->GetNumOfCurrentUses();
          *pnResult = (dw1 < dw2) ? -1 : ((dw1 == dw2) ? 0 : 1); 
        }
        break;
      default:
        ASSERT(FALSE);
        *pnResult = 0;
        break;
      }
    }
    break;

  case FILEMGMT_SERVICE:
    ASSERT (0);  // comparison provided by CServiceCookie
    break;

  case FILEMGMT_SESSION:
    {
      switch (iColumn)
      {
      case COMPARESIMILARCOOKIE_FULL:
           iColumn = COLNUM_SESSIONS_USERNAME; // fall through
      case COLNUM_SESSIONS_USERNAME:
      case COLNUM_SESSIONS_COMPUTERNAME:
      case COLNUM_SESSIONS_TRANSPORT:
      case COLNUM_SESSIONS_IS_GUEST:
        {
          CComBSTR bstr1 = GetColumnText(iColumn);
          CComBSTR bstr2 = pcookie->GetColumnText(iColumn);
          *pnResult = ((!bstr1 || !bstr2) ? 0 : lstrcmpi(bstr1, bstr2));
        }
        break;
      case COLNUM_SESSIONS_NUM_FILES:
        {
          DWORD dw1 = GetNumOfOpenFiles();
          DWORD dw2 = pcookie->GetNumOfOpenFiles();
          *pnResult = (dw1 < dw2) ? -1 : ((dw1 == dw2) ? 0 : 1); 
        }
        break;
      case COLNUM_SESSIONS_CONNECTED_TIME:
        {
          DWORD dw1 = GetConnectedTime();
          DWORD dw2 = pcookie->GetConnectedTime();
          *pnResult = (dw1 < dw2) ? -1 : ((dw1 == dw2) ? 0 : 1); 
        }
        break;
      case COLNUM_SESSIONS_IDLE_TIME:
        {
          DWORD dw1 = GetIdleTime();
          DWORD dw2 = pcookie->GetIdleTime();
          *pnResult = (dw1 < dw2) ? -1 : ((dw1 == dw2) ? 0 : 1); 
        }
        break;
      default:
        ASSERT(FALSE);
        *pnResult = 0;
        break;
      }
    }
    break;
  case FILEMGMT_RESOURCE:
    {
      switch (iColumn)
      {
      case COMPARESIMILARCOOKIE_FULL:
           iColumn = COLNUM_RESOURCES_FILENAME; // fall through
      case COLNUM_RESOURCES_FILENAME:
      case COLNUM_RESOURCES_USERNAME:
      case COLNUM_RESOURCES_TRANSPORT:
      case COLNUM_RESOURCES_OPEN_MODE:
        {
          CComBSTR bstr1 = GetColumnText(iColumn);
          CComBSTR bstr2 = pcookie->GetColumnText(iColumn);
          *pnResult = ((!bstr1 || !bstr2) ? 0 : lstrcmpi(bstr1, bstr2));
        }
        break;
      case COLNUM_RESOURCES_NUM_LOCKS:
        {
          DWORD dw1 = GetNumOfLocks();
          DWORD dw2 = pcookie->GetNumOfLocks();
          *pnResult = (dw1 < dw2) ? -1 : ((dw1 == dw2) ? 0 : 1); 
        }
        break;
      default:
        ASSERT(FALSE);
        *pnResult = 0;
        break;
      }
    }
    break;
  case FILEMGMT_ROOT:
  case FILEMGMT_SHARES:
  case FILEMGMT_SESSIONS:
  case FILEMGMT_RESOURCES:
  #ifdef SNAPIN_PROTOTYPER
  case FILEMGMT_PROTOTYPER:
    *pnResult = 0;
    break;
  #endif
  case FILEMGMT_SERVICES:
    *pnResult = 0;
    break;

  default:
    ASSERT(FALSE);
    break;
  }

  return S_OK;
}


//
// CFileMgmtCookieBlock
//
DEFINE_COOKIE_BLOCK(CFileMgmtCookie)


//
// CFileMgmtScopeCookie
//

CFileMgmtScopeCookie::CFileMgmtScopeCookie(
      LPCTSTR lpcszMachineName,
      FileMgmtObjectType objecttype)
  : CFileMgmtCookie( objecttype )
  , m_hScManager( NULL )
  , m_fQueryServiceConfig2( FALSE )
  , m_hScopeItemParent( NULL )
  , m_strMachineName( lpcszMachineName )
{
  ASSERT( IsAutonomousObjectType( objecttype ) );
  m_hScManager = NULL;
  m_fQueryServiceConfig2 = TRUE;  // Pretend the target machine does support QueryServiceConfig2() API
}

CFileMgmtScopeCookie::~CFileMgmtScopeCookie()
{
}

CCookie* CFileMgmtScopeCookie::QueryBaseCookie(int i)
{
    UNREFERENCED_PARAMETER (i);
    ASSERT(0 == i);
    return (CCookie*)this;
}
int CFileMgmtScopeCookie::QueryNumCookies()
{
  return 1;
}

void CFileMgmtCookie::GetDisplayName( CString& /*strref*/, BOOL /*fStaticNode*/ )
{
    ASSERT(FALSE);
}

void CFileMgmtScopeCookie::GetDisplayName( CString& strref, BOOL fStaticNode )
{
  if ( !IsAutonomousObjectType(QueryObjectType()) )
  {
    ASSERT(FALSE);
    return;
  }

  int nStringId = IDS_DISPLAYNAME_ROOT;
  if (fStaticNode)
  {
    if (NULL != QueryTargetServer())
      nStringId = IDS_DISPLAYNAME_s_ROOT;
    else
      nStringId = IDS_DISPLAYNAME_ROOT_LOCAL;
  }
  nStringId += (QueryObjectType() - FILEMGMT_ROOT);

  LoadStringPrintf(nStringId, OUT &strref, (LPCTSTR)QueryNonNULLMachineName());
}

void CFileMgmtScopeCookie::MarkResultChildren( CBITFLAG_FLAGWORD state )
{
  ASSERT( FILEMGMT_SERVICES == QueryObjectType() ); // CODEWORK remove
  POSITION pos = m_listResultCookieBlocks.GetHeadPosition();
  while (NULL != pos)
  {
    CBaseCookieBlock* pblock = m_listResultCookieBlocks.GetNext( pos );
    ASSERT( NULL != pblock && 1 == pblock->QueryNumCookies() );
    CCookie* pbasecookie = pblock->QueryBaseCookie(0);
    CNewResultCookie* pcookie = (CNewResultCookie*)pbasecookie;
    pcookie->MarkState( state );
  }
}

void CFileMgmtScopeCookie::RemoveMarkedChildren()
{
  ASSERT( FILEMGMT_SERVICES == QueryObjectType() ); // CODEWORK remove
  POSITION pos = m_listResultCookieBlocks.GetHeadPosition();
  while (NULL != pos)
  {
    POSITION posCurr = pos;
    CBaseCookieBlock* pblock = m_listResultCookieBlocks.GetNext( pos );
    ASSERT( NULL != pblock && 1 == pblock->QueryNumCookies() );
    CCookie* pbasecookie = pblock->QueryBaseCookie(0);
    CNewResultCookie* pcookie = (CNewResultCookie*)pbasecookie;
    if ( pcookie->IsMarkedForDeletion() )
    {
      m_listResultCookieBlocks.RemoveAt( posCurr );
      pcookie->Release();
    }
  }
}

// CODEWORK This may be a O(N^^2) performance problem when the list is long
void CFileMgmtScopeCookie::ScanAndAddResultCookie( CNewResultCookie* pnewcookie )
{
  ASSERT( FILEMGMT_SERVICES == QueryObjectType() ); // CODEWORK remove
  POSITION pos = m_listResultCookieBlocks.GetHeadPosition();
  while (NULL != pos)
  {
    CBaseCookieBlock* pblock = m_listResultCookieBlocks.GetNext( pos );
    ASSERT( NULL != pblock && 1 == pblock->QueryNumCookies() );
    CCookie* pbasecookie = pblock->QueryBaseCookie(0);
    CNewResultCookie* pcookie = (CNewResultCookie*)pbasecookie;
    if (!pcookie->IsMarkedForDeletion())
      continue; // this is not an old-and-still-unmatched object
    BOOL bSame = FALSE;
    HRESULT hr = pcookie->SimilarCookieIsSameObject( pnewcookie, &bSame );
    if ( !FAILED(hr) && bSame )
    {
      // this existing object is the same as our new object
      if (pcookie->CopySimilarCookie( pnewcookie ) )
        pcookie->MarkAsChanged();
      else
        pcookie->MarkAsOld();
      delete pnewcookie;
      return;
    }
  }
  AddResultCookie( pnewcookie );
}

#ifdef SNAPIN_PROTOTYPER
//
// CPrototyperScopeCookie
//
DEFINE_COOKIE_BLOCK(CPrototyperScopeCookie)

//
// CPrototyperResultCookie
//
DEFINE_COOKIE_BLOCK(CPrototyperResultCookie)
#endif


//
// CNewResultCookie
//

CNewResultCookie::CNewResultCookie( PVOID pvCookieTypeMarker, FileMgmtObjectType objecttype )
    : CFileMgmtCookie( objecttype )
    , m_pvCookieTypeMarker( pvCookieTypeMarker )
{
}

CNewResultCookie::~CNewResultCookie()
{
}

// return TRUE iif object has changed
BOOL CNewResultCookie::CopySimilarCookie( CNewResultCookie* /*pcookie*/ )
{
  return FALSE;
}

/*
class CNewShareCookie
  : public CNewResultCookie
{
public:
  CNewShareCookie( FILEMGMT_TRANSPORT transport )
    : CNewResultCookie( FILEMGMT_SHARE )
    , m_transport( transport )
  {}
  virtual ~CNewShareCookie();

  virtual BSTR QueryResultColumnText( int nCol, CFileMgmtComponentData& refcdata );

public:
  FILEMGMT_TRANSPORT m_transport;
  CString m_strName;
  CString m_strPath;
  CString m_strComment;
  DWORD m_dwSessions;
  DWORD m_dwID;

}; // CNewShareCookie

CNewShareCookie::~CNewShareCookie() {}

BSTR CNewShareCookie::QueryResultColumnText(
  int nCol,
  CFileMgmtComponentData& refcdata )
{
  switch (nCol)
  {
  case COLNUM_SHARES_SHARED_FOLDER:
    return const_cast<BSTR>((LPCTSTR)m_strName);
  case COLNUM_SHARES_SHARED_PATH:
    return const_cast<BSTR>((LPCTSTR)m_strPath);
  case COLNUM_SHARES_TRANSPORT:
    return refcdata.MakeTransportResult(m_transport);
  case COLNUM_SHARES_NUM_SESSIONS:
    return refcdata.MakeDwordResult( m_dwSessions );
  case COLNUM_SHARES_COMMENT:
    return const_cast<BSTR>((LPCTSTR)m_strComment);
  default:
    ASSERT(FALSE);
    break;
  }
  return L"";
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\cookie.h ===
// cookie.h : Declaration of CFileMgmtCookie and related classes

#ifndef __COOKIE_H_INCLUDED__
#define __COOKIE_H_INCLUDED__

#include "bitflag.hxx"

extern HINSTANCE g_hInstanceSave;  // Instance handle of the DLL (initialized during CFileMgmtComponent::Initialize)

#include "stdcooki.h"
#include "nodetype.h"
#include "shlobj.h"  // LPITEMIDLIST

typedef enum _COLNUM_SERVICES {
	COLNUM_SERVICES_SERVICENAME = 0,
	COLNUM_SERVICES_DESCRIPTION,
	COLNUM_SERVICES_STATUS,
	COLNUM_SERVICES_STARTUPTYPE,
	COLNUM_SERVICES_SECURITYCONTEXT,
} COLNUM_SERVICES;


#ifdef SNAPIN_PROTOTYPER
typedef enum ScopeType {
	HTML,
	CONTAINER
} ScopeType;
#endif

// forward declarations
class CFileMgmtComponentData;
class CFileMgmtResultCookie;

/////////////////////////////////////////////////////////////////////////////
// cookie

//REVIEW -- using pointers to ID's is necessary because some compilers don't like
//references as template arguments.


/////////////////////////////////////////////////////////////////////
class CFileMgmtCookie : public CCookie, public CHasMachineName
{
public:
	CFileMgmtCookie( FileMgmtObjectType objecttype )
			: m_objecttype( objecttype )
		{}

	FileMgmtObjectType QueryObjectType()
		{ return m_objecttype; }

	// CFileMgmtDataObject uses these methods to obtain return values
	// for various clipboard formats
	virtual HRESULT GetTransport( OUT FILEMGMT_TRANSPORT* pTransport );
	virtual HRESULT GetShareName( OUT CString& strShareName );
	virtual HRESULT GetSharePIDList( OUT LPITEMIDLIST *ppidl );
	virtual HRESULT GetSessionClientName( OUT CString& strSessionClientName );
	virtual HRESULT GetSessionUserName( OUT CString& strSessionUserName );
	virtual HRESULT GetSessionID( DWORD* pdwSessionID );
	virtual HRESULT GetFileID( DWORD* pdwFileID );
	virtual HRESULT GetServiceName( OUT CString& strServiceName );
	virtual HRESULT GetServiceDisplayName( OUT CString& strServiceDisplayName );
	virtual HRESULT GetExplorerViewDescription( OUT CString& strExplorerViewDescription );

	// these functions are used when sorting columns
	inline virtual DWORD GetNumOfCurrentUses()    { return 0; }
	inline virtual DWORD GetNumOfOpenFiles()      { return 0; }
	inline virtual DWORD GetConnectedTime()       { return 0; }
	inline virtual DWORD GetIdleTime()            { return 0; }
	inline virtual DWORD GetNumOfLocks()          { return 0; }
	inline virtual BSTR  GetColumnText(int nCol)  
    { 
        UNREFERENCED_PARAMETER (nCol); 
        return L""; 
    }

	// The cookie should return the appropriate string to display.
	virtual BSTR QueryResultColumnText( int nCol, CFileMgmtComponentData& refcdata ) = 0;

	// return <0, 0 or >0
	virtual HRESULT CompareSimilarCookies( CCookie* pOtherCookie, int* pnResult);

	virtual void AddRefCookie() = 0;
	virtual void ReleaseCookie() = 0;

	virtual void GetDisplayName( OUT CString& strref, BOOL fStaticNode );

protected:
	FileMgmtObjectType m_objecttype;
}; // CFileMgmtCookie

/*
/////////////////////////////////////////////////////////////////////
class CFileMgmtCookieBlock
: public CCookieBlock<CFileMgmtCookie>,
  public CStoresMachineName
{
public:
	CFileMgmtCookieBlock(
			CFileMgmtCookie* aCookies,
			int cCookies,
			LPCTSTR lpcszMachineName = NULL )
		: CCookieBlock<CFileMgmtCookie>( aCookies, cCookies ),
		  CStoresMachineName( lpcszMachineName )
	{
		for (int i = 0; i < cCookies; i++)
		{
			aCookies[i].ReadMachineNameFrom( (CHasMachineName*)this );
		 	aCookies[i].m_pContainedInCookieBlock = this;
		}
	}

}; // CFileMgmtCookieBlock
*/

class CNewResultCookie
	: public CFileMgmtCookie // CODEWORK should eventually move into framework
	, public CBaseCookieBlock
	, private CBitFlag
{
public:
	CNewResultCookie( PVOID pvCookieTypeMarker, FileMgmtObjectType objecttype );
	virtual ~CNewResultCookie();

	// required for CBaseCookieBlock
	virtual void AddRefCookie() { CRefcountedObject::AddRef(); }
	virtual void ReleaseCookie() { CRefcountedObject::Release(); }
	virtual CCookie* QueryBaseCookie(int i) 
    { 
        UNREFERENCED_PARAMETER (i);
        return (CCookie*)this; 
    }
	virtual int QueryNumCookies() { return 1; }

	// Mark-and-sweep support in CBitFlag
	// ctor marks cookies as New
#define NEWRESULTCOOKIE_NEW    0x0
#define NEWRESULTCOOKIE_DELETE 0x1
#define NEWRESULTCOOKIE_OLD    0x2
#define NEWRESULTCOOKIE_CHANGE 0x3
#define NEWRESULTCOOKIE_MASK   0x3
	void MarkState( ULONG state ) { _SetMask(state, NEWRESULTCOOKIE_MASK); }
	BOOL QueryState( ULONG state ) { return (state == _QueryMask(NEWRESULTCOOKIE_MASK)); }
	void MarkForDeletion() { MarkState(NEWRESULTCOOKIE_DELETE); }
	BOOL IsMarkedForDeletion() { return QueryState(NEWRESULTCOOKIE_DELETE); }
	void MarkAsOld() { MarkState(NEWRESULTCOOKIE_OLD); }
	BOOL IsMarkedOld() { return QueryState(NEWRESULTCOOKIE_OLD); }
	void MarkAsNew() { MarkState(NEWRESULTCOOKIE_NEW); }
	BOOL IsMarkedNew() { return QueryState(NEWRESULTCOOKIE_NEW); }
	void MarkAsChanged() { MarkState(NEWRESULTCOOKIE_CHANGE); }
	BOOL IsMarkedChanged() { return QueryState(NEWRESULTCOOKIE_CHANGE); }

	virtual HRESULT SimilarCookieIsSameObject( CNewResultCookie* pOtherCookie, BOOL* pbSame ) = 0;
	virtual BOOL CopySimilarCookie( CNewResultCookie* pcookie );

	BOOL IsSameType( CNewResultCookie* pcookie )
		{ return (m_pvCookieTypeMarker == pcookie->m_pvCookieTypeMarker); }

// CHasMachineName Interface
	STORES_MACHINE_NAME;

private:
	PVOID m_pvCookieTypeMarker;

}; // CNewResultCookie


/////////////////////////////////////////////////////////////////////
class CFileMgmtScopeCookie : public CFileMgmtCookie, public CBaseCookieBlock
{
public:
	CFileMgmtScopeCookie( LPCTSTR lpcszMachineName = NULL,
	                      FileMgmtObjectType objecttype = FILEMGMT_ROOT );
	virtual ~CFileMgmtScopeCookie();

	virtual CCookie* QueryBaseCookie(int i);
	virtual int QueryNumCookies();

	// This is only possible for scope cookies which are not further differentiated
	void SetObjectType( FileMgmtObjectType objecttype )
	{
		ASSERT( IsAutonomousObjectType( objecttype ) );
		m_objecttype = objecttype;
	}

	virtual BSTR QueryResultColumnText( int nCol, CFileMgmtComponentData& refcdata );

	// CODEWORK there are only used for FILEMGMT_SERVICES
	SC_HANDLE m_hScManager;				// Handle to service control manager database
	BOOL m_fQueryServiceConfig2;		// TRUE => Machine support QueryServiceConfig2() API

	HSCOPEITEM m_hScopeItemParent;		// used only for extension nodes

	virtual void AddRefCookie() { CRefcountedObject::AddRef(); }
	virtual void ReleaseCookie() { CRefcountedObject::Release(); }

// CHasMachineName Interface
	STORES_MACHINE_NAME;

	virtual void GetDisplayName( OUT CString& strref, BOOL fStaticNode );

	void MarkResultChildren( CBITFLAG_FLAGWORD state );
	void AddResultCookie( CNewResultCookie* pcookie )
		{ m_listResultCookieBlocks.AddHead( pcookie ); }
	void ScanAndAddResultCookie( CNewResultCookie* pcookie );
	void RemoveMarkedChildren();

	}; // CFileMgmtScopeCookie 


/////////////////////////////////////////////////////////////////////
class CFileMgmtResultCookie : public CFileMgmtCookie
{
// can only create via subclass
protected:
	CFileMgmtResultCookie( FileMgmtObjectType objecttype )
			: CFileMgmtCookie( objecttype )
			, m_pobject( NULL )
	{
		ASSERT(  IsValidObjectType( objecttype ) &&
			    !IsAutonomousObjectType( objecttype ) );
	}

	// still pure virtual
	virtual void AddRefCookie() = 0;
	virtual void ReleaseCookie() = 0;

public:
	PVOID m_pobject;
}; // CFileMgmtResultCookie

#ifdef SNAPIN_PROTOTYPER
/////////////////////////////////////////////////////////////////////
class CPrototyperScopeCookie : public CFileMgmtScopeCookie
{
public:
	CPrototyperScopeCookie( FileMgmtObjectType objecttype = FILEMGMT_ROOT )
			: CFileMgmtScopeCookie(NULL, objecttype )
	{
		ASSERT( IsAutonomousObjectType( objecttype ) );
		m_NumChildren = 0;
		m_NumLeafNodes = 0;
	}

	virtual BSTR QueryResultColumnText( int nCol, CFileMgmtComponentData& refcdata );

	CString m_DisplayName;
	CString m_Header;
	CString m_RecordData;
	CString m_HTMLURL;
	CString m_DefaultMenu;
	CString m_TaskMenu;
	CString m_NewMenu;
	CString m_DefaultMenuCommand;
	CString m_TaskMenuCommand;
	CString m_NewMenuCommand;
	int m_NumChildren;
	int m_NumLeafNodes;
	ScopeType m_ScopeType;

}; // CPrototyperScopeCookie

/////////////////////////////////////////////////////////////////////
class CPrototyperScopeCookieBlock :
	public CCookieBlock<CPrototyperScopeCookie>,
	public CStoresMachineName
{
public:
	CPrototyperScopeCookieBlock( CPrototyperScopeCookie* aCookies,
		int cCookies, LPCTSTR lpcszMachineName = NULL)
		: CCookieBlock<CPrototyperScopeCookie>( aCookies, cCookies ),
		  CStoresMachineName( lpcszMachineName )
	{                                                       
		ASSERT(NULL != aCookies && 0 < cCookies);          
		for (int i = 0; i < cCookies; i++)
		{
			//aCookies[i].m_pContainedInCookieBlock = this;   
			//aCookies[i].ReadMachineNameFrom( (CHasMachineName*)this );
		} // for
	} 
}; // CPrototyperScopeCookieBlock

/////////////////////////////////////////////////////////////////////
class CPrototyperResultCookie : public CFileMgmtResultCookie
{
public:
	CPrototyperResultCookie( FileMgmtObjectType objecttype = FILEMGMT_PROTOTYPER_LEAF )
			: CFileMgmtResultCookie( objecttype ) {}

	virtual BSTR QueryResultColumnText( int nCol, CFileMgmtComponentData& refcdata );

	CString m_DisplayName;
	CString m_RecordData;
	CString m_DefaultMenu;
	CString m_TaskMenu;
	CString m_NewMenu;
	CString m_DefaultMenuCommand;
	CString m_TaskMenuCommand;
	CString m_NewMenuCommand;

	virtual void AddRefCookie() {}
	virtual void ReleaseCookie() {}

// CHasMachineName
	class CPrototyperResultCookieBlock * m_pCookieBlock;
	DECLARE_FORWARDS_MACHINE_NAME(m_pCookieBlock)

}; // CPrototyperResultCookie

/////////////////////////////////////////////////////////////////////
class CPrototyperResultCookieBlock :
	public CCookieBlock<CPrototyperResultCookie>,
	public CStoresMachineName
{
public:
	CPrototyperResultCookieBlock( CPrototyperResultCookie* aCookies, int cCookies,
				LPCTSTR lpcszMachineName = NULL)
		: CCookieBlock<CPrototyperResultCookie>( aCookies, cCookies ),
		  CStoresMachineName( lpcszMachineName )
	{                                                       
		ASSERT(NULL != aCookies && 0 < cCookies);          
		for (int i = 0; i < cCookies; i++)
		{
			//aCookies[i].m_pContainedInCookieBlock = this;   
		} // for
	} 
}; // CPrototyperResultCookieBlock

#endif // SNAPIN_PROTOTYPER

#endif // ~__COOKIE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\compdata.cpp ===
// compdata.cpp : Implementation of CFileMgmtComponentData
/*
History:
  8/20/97 EricDav
  Added Configure File Server for Macintosh menu item to the 
  root node.  Only shows up if SFM is installed and the user
  has admin access to that machine.

*/

#include "stdafx.h"
#include "cookie.h"
#include "safetemp.h"

#include "macros.h"
USE_HANDLE_MACROS("FILEMGMT(compdata.cpp)")

#include "dataobj.h"
#include "compdata.h"
#include "cmponent.h"
#include "DynamLnk.h" // DynamicDLL

#include "FileSvc.h" // FileServiceProvider
#include "smb.h"
#include "sfm.h"

#include "SnapMgr.h" // CFileMgtGeneral: Snapin Manager property page
#include "chooser2.h" // CHOOSER2_PickTargetComputer

#include <compuuid.h> // UUIDs for Computer Management

#include <safeboot.h>   // for SAFEBOOT_MINIMAL
#include <shlwapi.h>    // for IsOS
#include <shlwapip.h>    // for IsOS

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "stdcdata.cpp" // CComponentData implementation
#include "chooser2.cpp" // CHOOSER2_PickTargetComputer implementation

//
// CFileMgmtComponentData
//

CString g_strTransportSMB;
CString g_strTransportSFM;

BOOL g_fTransportStringsLoaded = FALSE;

CFileMgmtComponentData::CFileMgmtComponentData()
:   m_fLoadedFileMgmtToolbarBitmap(FALSE),
    m_fLoadedSvcMgmtToolbarBitmap(FALSE),
    m_pRootCookie( NULL ),
    m_hScManager( NULL ),
    m_SchemaSupportSharePublishing(SHAREPUBLISH_SCHEMA_UNASSIGNED),
    m_bIsSimpleUI(FALSE),
    m_fQueryServiceConfig2( TRUE ) // Pretend the target machine does support QueryServiceConfig2() API
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // We must refcount the root cookie, since a dataobject for it
    // might outlive the IComponentData.  JonN 9/2/97
    //
    m_pRootCookie = new CFileMgmtScopeCookie();
    ASSERT(NULL != m_pRootCookie);
// JonN 10/27/98 All CRefcountedObject's start with refcount==1
//    m_pRootCookie->AddRef();

    m_apFileServiceProviders[FILEMGMT_SMB]  = new SmbFileServiceProvider(this);
    m_apFileServiceProviders[FILEMGMT_SFM]  = new SfmFileServiceProvider(this);
    m_dwFlagsPersist = 0;
    m_fAllowOverrideMachineName = TRUE;
    ASSERT( 2 == FILEMGMT_NUM_TRANSPORTS );
    #ifdef SNAPIN_PROTOTYPER
    m_RegistryParsedYet = FALSE;
    #endif

  if (!g_fTransportStringsLoaded)
  {
    g_fTransportStringsLoaded = TRUE;
    VERIFY( g_strTransportSMB.LoadString(IDS_TRANSPORT_SMB) );
    VERIFY( g_strTransportSFM.LoadString(IDS_TRANSPORT_SFM) );
  }
}


CFileMgmtComponentData::~CFileMgmtComponentData()
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());    // required for CWaitCursor
    for (INT i = 0; i < FILEMGMT_NUM_TRANSPORTS; i++)
    {
        delete m_apFileServiceProviders[i];
        m_apFileServiceProviders[i] = NULL;
    }
    // Close the service control manager
    Service_CloseScManager();
    m_pRootCookie->Release();
    m_pRootCookie = NULL;
}

DEFINE_FORWARDS_MACHINE_NAME( CFileMgmtComponentData, m_pRootCookie )


CFileSvcMgmtSnapin::CFileSvcMgmtSnapin()
{
    // The identity of the default root node is the only difference
    // between the File Management snapin and the Service Management snapins
    QueryRootCookie().SetObjectType( FILEMGMT_ROOT );
    SetHtmlHelpFileName (L"file_srv.chm");
}

CFileSvcMgmtSnapin::~CFileSvcMgmtSnapin()
{
}

CServiceMgmtSnapin::CServiceMgmtSnapin()
{
    // The identity of the default root node is the only difference
    // between the File Management snapin and the Service Management snapins
    #ifdef SNAPIN_PROTOTYPER
    QueryRootCookie().SetObjectType( FILEMGMT_PROTOTYPER );
    #else
    QueryRootCookie().SetObjectType( FILEMGMT_SERVICES );
    #endif
    SetHtmlHelpFileName (L"sys_srv.chm");
}

CServiceMgmtSnapin::~CServiceMgmtSnapin()
{
}

CFileSvcMgmtExtension::CFileSvcMgmtExtension()
{
    // The root cookie is not used
    SetHtmlHelpFileName (L"file_srv.chm");
}

CFileSvcMgmtExtension::~CFileSvcMgmtExtension()
{
}

CServiceMgmtExtension::CServiceMgmtExtension()
{
    // The root cookie is not used
    SetHtmlHelpFileName (L"sys_srv.chm");
}

CServiceMgmtExtension::~CServiceMgmtExtension()
{
}

CCookie& CFileMgmtComponentData::QueryBaseRootCookie()
{
    ASSERT(NULL != m_pRootCookie);
    return (CCookie&)(*m_pRootCookie);
}


STDMETHODIMP CFileMgmtComponentData::CreateComponent(LPCOMPONENT* ppComponent)
{
    MFC_TRY;

    ASSERT(ppComponent != NULL);

    CComObject<CFileMgmtComponent>* pObject;
    HRESULT hr = CComObject<CFileMgmtComponent>::CreateInstance(&pObject);
    if (FAILED(hr))
        return hr;

    pObject->SetComponentDataPtr( (CFileMgmtComponentData*)this );

    return pObject->QueryInterface(IID_IComponent,
                    reinterpret_cast<void**>(ppComponent));

    MFC_CATCH;
}


HRESULT CFileMgmtComponentData::LoadIcons(LPIMAGELIST pImageList, BOOL fLoadLargeIcons)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( )); // 2002/03/22-JonN 572859

    HBITMAP hBMSm = NULL;
    HBITMAP hBMLg = NULL;
    HRESULT hr = S_OK;

    hBMSm = ::LoadBitmap(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDB_FILEMGMT_ICONS_16));
    if (!hBMSm)
        return HRESULT_FROM_WIN32(GetLastError());

    if (fLoadLargeIcons)
    {
        hBMLg = ::LoadBitmap(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDB_FILEMGMT_ICONS_32));
        if (!hBMLg)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DeleteObject(hBMSm);
            return hr;
        }
    }
    hr = pImageList->ImageListSetStrip((LONG_PTR *)hBMSm, (LONG_PTR *)hBMLg, iIconSharesFolder, RGB(255,0,255));
    DeleteObject(hBMSm);
    if (fLoadLargeIcons)
        DeleteObject(hBMLg);
    if (FAILED(hr))
        return hr;

    hBMSm = ::LoadBitmap(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDB_SVCMGMT_ICONS_16));
    if (!hBMSm)
        return HRESULT_FROM_WIN32(GetLastError());
    if (fLoadLargeIcons)
    {
        hBMLg = ::LoadBitmap(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDB_SVCMGMT_ICONS_32));
        if (!hBMLg)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            DeleteObject(hBMSm);
            return hr;
        }
    }
    hr = pImageList->ImageListSetStrip((LONG_PTR *)hBMSm, (LONG_PTR *)hBMLg, iIconService, RGB(255,0,255));
    DeleteObject(hBMSm);
    if (fLoadLargeIcons)
        DeleteObject(hBMLg);

    return hr;
}

GUID g_guidSystemTools = structuuidNodetypeSystemTools;
GUID g_guidServerApps = structuuidNodetypeServerApps;

BOOL CFileMgmtComponentData::IsExtendedNodetype( GUID& refguid )
{
    return (refguid == g_guidSystemTools || refguid == g_guidServerApps);
}

HRESULT CFileMgmtComponentData::AddScopeCookie( HSCOPEITEM hParent,
                                                LPCTSTR lpcszTargetServer,
                                                FileMgmtObjectType objecttype,
                                                CFileMgmtCookie* pParentCookie )
{
    SCOPEDATAITEM tSDItem;
    ::ZeroMemory(&tSDItem,sizeof(tSDItem));
    tSDItem.mask = SDI_STR | SDI_IMAGE | SDI_OPENIMAGE | SDI_STATE | SDI_PARAM | SDI_PARENT;
    tSDItem.displayname = MMC_CALLBACK;
    // CODEWORK should use MMC_ICON_CALLBACK here
    tSDItem.relativeID = hParent;
    tSDItem.nState = 0;

    if (FILEMGMT_ROOT != objecttype)
    {
      // no children
      tSDItem.mask |= SDI_CHILDREN; // note that cChildren is still 0
    }

    CFileMgmtScopeCookie* pCookie = new CFileMgmtScopeCookie(
        lpcszTargetServer,
        objecttype);
    if (NULL != pParentCookie)
        pParentCookie->m_listScopeCookieBlocks.AddHead( pCookie );
    // WARNING cookie cast
    tSDItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pCookie);
    tSDItem.nImage = QueryImage( *pCookie, FALSE );
    tSDItem.nOpenImage = QueryImage( *pCookie, TRUE );
    return m_pConsoleNameSpace->InsertItem(&tSDItem);
}

BOOL IsSimpleUI(PCTSTR pszMachineName);

HRESULT CFileMgmtComponentData::OnNotifyExpand(
    LPDATAOBJECT lpDataObject,
    BOOL bExpanding,
    HSCOPEITEM hParent)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CWaitCursor wait;

    if (!bExpanding)
        return S_OK;

    GUID guidObjectType;
    HRESULT hr = ExtractObjectTypeGUID( lpDataObject, &guidObjectType );
    ASSERT( SUCCEEDED(hr) );
    if ( IsExtendedNodetype(guidObjectType) )
    {
        CString strServerName;
        hr = ExtractString( lpDataObject, CFileMgmtDataObject::m_CFMachineName, &strServerName, MAX_PATH );
        if ( FAILED(hr) )
        {
            ASSERT( FALSE );
            return hr;
        }
        // JonN 10/27/98:  We add these nodes under the root cookie
        return AddScopeNodes( strServerName, hParent, &QueryRootCookie() );
    }
    
    CCookie* pbasecookie = NULL;
    FileMgmtObjectType objecttype =
        (FileMgmtObjectType)CheckObjectTypeGUID( &guidObjectType );
    hr = ExtractBaseCookie( lpDataObject, &pbasecookie );
    ASSERT( SUCCEEDED(hr) );
    CFileMgmtCookie* pParentCookie = (CFileMgmtCookie*)pbasecookie;

    if (NULL == pParentCookie) // JonN 05/30/00 PREFIX 110945
		{
			ASSERT(FALSE);
			return S_OK;
		}

    #ifdef SNAPIN_PROTOTYPER
    //(void)Prototyper_HrEnumerateScopeChildren(pParentCookie, hParent);
    return S_OK;
    #endif

    switch ( objecttype )
    {
        // This node type has a child
        case FILEMGMT_ROOT:
            if ( !IsExtensionSnapin() )
            {
                // Ensure that node is formatted correctly
                CString    machineName    = pParentCookie->QueryNonNULLMachineName ();
                if ( !pParentCookie->m_hScopeItem )
                    pParentCookie->m_hScopeItem = hParent;

                m_strMachineNamePersist = machineName; // init m_strMachineNamePersist
                hr = ChangeRootNodeName (machineName);
                ASSERT( SUCCEEDED(hr) );
            }
            break;

        // These node types have no children
        case FILEMGMT_SHARES:
        case FILEMGMT_SESSIONS:
        case FILEMGMT_RESOURCES:
        case FILEMGMT_SERVICES:
            return S_OK;

        case FILEMGMT_SHARE:
        case FILEMGMT_SESSION:
        case FILEMGMT_RESOURCE:
        case FILEMGMT_SERVICE:
            TRACE( "CFileMgmtComponentData::EnumerateScopeChildren node type should not be in scope pane\n" );
            // fall through
        default:
            TRACE( "CFileMgmtComponentData::EnumerateScopeChildren bad parent type\n" );
            ASSERT( FALSE );
            return S_OK;
    }

    if ( NULL == hParent || !(pParentCookie->m_listScopeCookieBlocks).IsEmpty() )
    {
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }

    return AddScopeNodes( pParentCookie->QueryTargetServer(), hParent, pParentCookie );
}

//
// 7/11/2001 LinanT
// Determine if the schema supports share publishing or not. This information is used
// to decide whether to show the Publish tab on a share's property sheet.
// We only need to do this once on current-retargeted computer. The ReInit() process
// will reset this member variable if computer has been retargeted.
//
BOOL CFileMgmtComponentData::GetSchemaSupportSharePublishing()
{
    if (SHAREPUBLISH_SCHEMA_UNASSIGNED == m_SchemaSupportSharePublishing)
    {
        if (S_OK == CheckSchemaVersion(QueryRootCookie().QueryNonNULLMachineName()))
            m_SchemaSupportSharePublishing = SHAREPUBLISH_SCHEMA_SUPPORTED;
        else
            m_SchemaSupportSharePublishing = SHAREPUBLISH_SCHEMA_UNSUPPORTED;
    }

    return (SHAREPUBLISH_SCHEMA_SUPPORTED == m_SchemaSupportSharePublishing);
}

//
// 7/11/2001 LinanT
// Cache the interface pointer to the computer object in AD. This information is
// used to speed up the multiple-shares-deletion process.
// We only need to do this once on current-retargeted computer. The ReInit() process
// will reset this member variable if computer has been retargeted.
//
IADsContainer *CFileMgmtComponentData::GetIADsContainer()
{
    if (!m_spiADsContainer)
    {
        if (GetSchemaSupportSharePublishing())
        {
            CString strADsPath, strDCName;
            HRESULT hr = GetADsPathOfComputerObject(QueryRootCookie().QueryNonNULLMachineName(), strADsPath, strDCName);
            if (SUCCEEDED(hr))
                ADsGetObject(strADsPath, IID_IADsContainer, (void**)&m_spiADsContainer);
        }
    }

    return (IADsContainer *)m_spiADsContainer;
}

//
// 7/11/2001 LinanT
// Re-initialize several "global" member variables based on the current-targeted computer.
// These variables are all related to share operations.
//
HRESULT CFileMgmtComponentData::ReInit(LPCTSTR lpcszTargetServer)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    CWaitCursor wait;

    //
    // re-initialize several global variables based on the targeted server
    //

    SetIsSimpleUI(IsSimpleUI(lpcszTargetServer));

    //
    // reset schema version of the domain the targeted machine belongs to
    //
    m_SchemaSupportSharePublishing = SHAREPUBLISH_SCHEMA_UNASSIGNED;

    //
    // reset the interface pointer to the AD container
    //
    if ((IADsContainer *)m_spiADsContainer)
        m_spiADsContainer.Release();

    return S_OK;
}

HRESULT CFileMgmtComponentData::AddScopeNodes( LPCTSTR lpcszTargetServer,
                                               HSCOPEITEM hParent,
                                               CFileMgmtCookie* pParentCookie )
{
    ASSERT( NULL != pParentCookie );

    //
    // Create new cookies
    //

    LoadGlobalStrings();

    if (IsExtensionSnapin())
    {
        ASSERT( pParentCookie->m_listScopeCookieBlocks.IsEmpty() );
    }

    HRESULT hr = S_OK;
    if (IsServiceSnapin())
    {
        if ( IsExtensionSnapin() )
        {
            hr = AddScopeCookie( hParent, lpcszTargetServer, FILEMGMT_SERVICES, pParentCookie );
            ASSERT( SUCCEEDED(hr) );
        }
        return hr;
    }

    if (IsExtensionSnapin() && (pParentCookie == m_pRootCookie)) // called as extension
    {
        QueryRootCookie().SetMachineName(lpcszTargetServer);
        hr = AddScopeCookie( hParent, lpcszTargetServer, FILEMGMT_ROOT, pParentCookie );
        ASSERT( SUCCEEDED(hr) );
        return hr;
    }

    //
    // 7/11/2001 LinanT bug#433102
    // Before we insert the "Shares" scope node, we need to
    // re-initialize related global variables on currently targeted computer.
    //
    ReInit(lpcszTargetServer);

    hr = AddScopeCookie( hParent, lpcszTargetServer, FILEMGMT_SHARES, pParentCookie );
    ASSERT( SUCCEEDED(hr) );
    hr = AddScopeCookie( hParent, lpcszTargetServer, FILEMGMT_SESSIONS, pParentCookie );
    ASSERT( SUCCEEDED(hr) );
    hr = AddScopeCookie( hParent, lpcszTargetServer, FILEMGMT_RESOURCES, pParentCookie );
    ASSERT( SUCCEEDED(hr) );

    return S_OK;
}


HRESULT CFileMgmtComponentData::OnNotifyDelete(LPDATAOBJECT /*lpDataObject*/)
{
    // CODEWORK The user hit the Delete key, I should deal with this
    return S_OK;
}


// JonN 10/27/98:  We must release the children of the root cookie
// JonN 10/27/98:  We must release the cached Service Controller handle
HRESULT CFileMgmtComponentData::OnNotifyRelease(LPDATAOBJECT lpDataObject, HSCOPEITEM /*hItem*/)
{
    GUID guidObjectType;
    HRESULT hr = ExtractObjectTypeGUID( lpDataObject, &guidObjectType );
    ASSERT( SUCCEEDED(hr) );
    if ( IsExtendedNodetype(guidObjectType) )
    {
        // EricDav 3/19/99:  We need to close the SCManager for both the service
        // snapin and the file mgmt snapin as the SFM config part uses this as well.
        Service_CloseScManager();

        QueryRootCookie().ReleaseScopeChildren();
    }
    // CODEWORK This will release all top-level extension scopenodes, not just those
    // under this particular external scopenode.  I depend on the fact that COMPMGMT
    // will only create one instance of System Tools.  JonN 10/27/98

    return S_OK;
}



STDMETHODIMP CFileMgmtComponentData::AddMenuItems(
                    IDataObject*          piDataObject,
                    IContextMenuCallback* piCallback,
                    long*                 pInsertionAllowed)
{
    MFC_TRY;

    TRACE_METHOD(CFileMgmtComponentData,AddMenuItems);
    TEST_NONNULL_PTR_PARAM(piDataObject);
    TEST_NONNULL_PTR_PARAM(piCallback);
    TEST_NONNULL_PTR_PARAM(pInsertionAllowed);
    TRACE( "FileMgmt snapin: extending menu\n" );

    DATA_OBJECT_TYPES dataobjecttype = CCT_SCOPE;
    HRESULT hr = ExtractData( piDataObject,
                              CFileMgmtDataObject::m_CFDataObjectType,
                              &dataobjecttype,
                              sizeof(dataobjecttype) );
    ASSERT( SUCCEEDED(hr) );

    GUID guidObjectType = GUID_NULL; // JonN 11/21/00 PREFIX 226044
    hr = ExtractObjectTypeGUID( piDataObject, &guidObjectType );
    ASSERT( SUCCEEDED(hr) );
    int objecttype = FilemgmtCheckObjectTypeGUID(IN &guidObjectType);
    if (objecttype == -1)
    {
        // We don't recognize the GUID, therefore we assume
        // the node wants to be extended by the service snapin.
        (void)Service_FAddMenuItems(piCallback, piDataObject, TRUE);
        return S_OK;
    }
    return DoAddMenuItems( piCallback, (FileMgmtObjectType)objecttype, dataobjecttype, pInsertionAllowed, piDataObject );

    MFC_CATCH;
} // CFileMgmtComponentData::AddMenuItems()

HRESULT CFileMgmtComponentData::DoAddMenuItems( IContextMenuCallback* piCallback,
                                                FileMgmtObjectType objecttype,
                                                DATA_OBJECT_TYPES  /*dataobjecttype*/,
                                                long* pInsertionAllowed,
                                                IDataObject* piDataObject)
{
    HRESULT hr = S_OK;

    if (   !IsExtensionSnapin()
        && (objecttype == m_pRootCookie->QueryObjectType()) )
    {
        if (CCM_INSERTIONALLOWED_TOP & (*pInsertionAllowed) )
        {
            hr = LoadAndAddMenuItem(
                piCallback,
                IDS_CHANGE_COMPUTER_TOP,
                IDS_CHANGE_COMPUTER_TOP,
                CCM_INSERTIONPOINTID_PRIMARY_TOP,
                0,
                AfxGetInstanceHandle(),
                _T("ChangeComputerTop") );
            ASSERT( SUCCEEDED(hr) );
        }
        if ( CCM_INSERTIONALLOWED_TASK & (*pInsertionAllowed) )
        {
            hr = LoadAndAddMenuItem(
                piCallback,
                IDS_CHANGE_COMPUTER_TASK,
                IDS_CHANGE_COMPUTER_TASK,
                CCM_INSERTIONPOINTID_PRIMARY_TASK,
                0,
                AfxGetInstanceHandle(),
                _T("ChangeComputerTask") );
            ASSERT( SUCCEEDED(hr) );
        }
    }

    switch (objecttype)
    {
    case FILEMGMT_ROOT:
        {
            // check to see if this machine has SFM installed
            // if so, display the menu item.
            SfmFileServiceProvider* pProvider =    
                (SfmFileServiceProvider*) GetFileServiceProvider(FILEMGMT_SFM);

            CString strServerName;
            HRESULT hr = ExtractString( piDataObject, CFileMgmtDataObject::m_CFMachineName, &strServerName, MAX_PATH );
            if ( FAILED(hr) )
            {
                break;
            }

            if (m_hScManager == NULL)
            {
                Service_EOpenScManager(strServerName);
            }

            if ( pProvider->FSFMInstalled(strServerName) )
            {
                if ( CCM_INSERTIONALLOWED_TASK & (*pInsertionAllowed) )
                {
                    hr = LoadAndAddMenuItem(
                        piCallback,
                        IDS_CONFIG_SFM_TASK,
                        IDS_CONFIG_SFM_TASK,
                        CCM_INSERTIONPOINTID_PRIMARY_TASK,
                        0,
                        AfxGetInstanceHandle(),
                        _T("ConfigSFMTask") );
                    ASSERT( SUCCEEDED(hr) );
                }

                if ( CCM_INSERTIONALLOWED_TOP & (*pInsertionAllowed) )
                {
                    hr = LoadAndAddMenuItem(
                        piCallback,
                        IDS_CONFIG_SFM_TOP,
                        IDS_CONFIG_SFM_TOP,
                        CCM_INSERTIONPOINTID_PRIMARY_TOP,
                        0,
                        AfxGetInstanceHandle(),
                        _T("ConfigSFMTop") );
                    ASSERT( SUCCEEDED(hr) );
                }
            }
        }
        break;
    
    case FILEMGMT_SHARES:
        //
        // don't add New Share Wizard to the menu whenever SimpleSharingUI appears in NT Explorer
        //
        if (GetIsSimpleUI())
            break;

        if ( CCM_INSERTIONALLOWED_TOP & (*pInsertionAllowed) )
        {
            hr = LoadAndAddMenuItem(
                piCallback,
                IDS_NEW_SHARE_TOP,
                IDS_NEW_SHARE_TOP,
                CCM_INSERTIONPOINTID_PRIMARY_TOP,
                0,
                AfxGetInstanceHandle(),
                _T("NewShareTop") );
            ASSERT( SUCCEEDED(hr) );
        }
        if ( CCM_INSERTIONALLOWED_NEW & (*pInsertionAllowed) )
        {
            hr = LoadAndAddMenuItem(
                piCallback,
                IDS_NEW_SHARE_NEW,
                IDS_NEW_SHARE_NEW,
                CCM_INSERTIONPOINTID_PRIMARY_NEW,
                0,
                AfxGetInstanceHandle(),
                _T("NewShareNew") );
            ASSERT( SUCCEEDED(hr) );
        }
        break;
    case FILEMGMT_SESSIONS:
        if ( CCM_INSERTIONALLOWED_TOP & (*pInsertionAllowed) )
        {
            hr = LoadAndAddMenuItem(
                piCallback,
                IDS_DISCONNECT_ALL_SESSIONS_TOP,
                IDS_DISCONNECT_ALL_SESSIONS_TOP,
                CCM_INSERTIONPOINTID_PRIMARY_TOP,
                0,
                AfxGetInstanceHandle(),
                _T("DisconnectAllSessionsTop") );
            ASSERT( SUCCEEDED(hr) );
        }
        if ( CCM_INSERTIONALLOWED_TASK & (*pInsertionAllowed) )
        {
            hr = LoadAndAddMenuItem(
                piCallback,
                IDS_DISCONNECT_ALL_SESSIONS_TASK,
                IDS_DISCONNECT_ALL_SESSIONS_TASK,
                CCM_INSERTIONPOINTID_PRIMARY_TASK,
                0,
                AfxGetInstanceHandle(),
                _T("DisconnectAllSessionsTask") );
            ASSERT( SUCCEEDED(hr) );
        }
        break;
    case FILEMGMT_RESOURCES:
        if ( CCM_INSERTIONALLOWED_TOP & (*pInsertionAllowed) )
        {
            hr = LoadAndAddMenuItem(
                piCallback,
                IDS_DISCONNECT_ALL_RESOURCES_TOP,
                IDS_DISCONNECT_ALL_RESOURCES_TOP,
                CCM_INSERTIONPOINTID_PRIMARY_TOP,
                0,
                AfxGetInstanceHandle(),
                _T("DisconnectAllResourcesTop") );
            ASSERT( SUCCEEDED(hr) );
        }
        if ( CCM_INSERTIONALLOWED_TASK & (*pInsertionAllowed) )
        {
            hr = LoadAndAddMenuItem(
                piCallback,
                IDS_DISCONNECT_ALL_RESOURCES_TASK,
                IDS_DISCONNECT_ALL_RESOURCES_TASK,
                CCM_INSERTIONPOINTID_PRIMARY_TASK,
                0,
                AfxGetInstanceHandle(),
                _T("DisconnectAllResourcesTask") );
            ASSERT( SUCCEEDED(hr) );
        }
        break;
    case FILEMGMT_SERVICES:
        #ifdef SNAPIN_PROTOTYPER
        // (void)Prototyper_FAddMenuItemsFromHKey(piCallback, m_regkeySnapinDemoRoot);
        #endif
        break;
    default:
        ASSERT( FALSE );
        break;
    } // switch

    return hr;

} // CFileMgmtComponentData::DoAddMenuItems()


STDMETHODIMP CFileMgmtComponentData::Command(
                    LONG            lCommandID,
                    IDataObject*    piDataObject )
{
    MFC_TRY;

    TRACE_METHOD(CFileMgmtComponentData,Command);
    TEST_NONNULL_PTR_PARAM(piDataObject);
    TRACE( "CFileMgmtComponentData::Command: command %ld selected\n", lCommandID );

    #ifdef SNAPIN_PROTOTYPER
    Prototyper_ContextMenuCommand(lCommandID, piDataObject);
    return S_OK;
    #endif

    BOOL fRefresh = FALSE;
    switch (lCommandID)
    {
    case IDS_CHANGE_COMPUTER_TASK:
    case IDS_CHANGE_COMPUTER_TOP:
        {
            HRESULT hr = OnChangeComputer(piDataObject);
            fRefresh = ( SUCCEEDED(hr) && S_FALSE != hr );
        }
        break;

    case IDS_NEW_SHARE_NEW:
    case IDS_NEW_SHARE_TOP:
        fRefresh = NewShare( piDataObject );
        break;

    case IDS_DISCONNECT_ALL_SESSIONS_TASK:
    case IDS_DISCONNECT_ALL_SESSIONS_TOP:
        fRefresh = DisconnectAllSessions( piDataObject );
        break;
    case IDS_DISCONNECT_ALL_RESOURCES_TASK:
    case IDS_DISCONNECT_ALL_RESOURCES_TOP:
        fRefresh = DisconnectAllResources( piDataObject );
        break;
    
    case IDS_CONFIG_SFM_TASK:
    case IDS_CONFIG_SFM_TOP:
        fRefresh = ConfigSfm( piDataObject );
        break;

    case cmServiceStart:
    case cmServiceStop:
    case cmServicePause:
    case cmServiceResume:
    case cmServiceRestart:
    case cmServiceStartTask:
    case cmServiceStopTask:
    case cmServicePauseTask:
    case cmServiceResumeTask:
    case cmServiceRestartTask:
        // Context menu extension
        (void)Service_FDispatchMenuCommand(lCommandID, piDataObject);
        Assert(FALSE == fRefresh && "Context menu extension not allowed to refresh result pane");
        break;

    case -1:    // Received when back arrow pushed in console.
        break;

    default:
        ASSERT(FALSE && "CFileMgmtComponentData::Command() - Invalid command ID");
        break;
    } // switch

    if (fRefresh)
    {
        // clear all views of this data
        m_pConsole->UpdateAllViews(piDataObject, 0L, 0L);
        // reread all views of this data
        m_pConsole->UpdateAllViews(piDataObject, 1L, 0L);
    }

    return S_OK;

    MFC_CATCH;

} // CFileMgmtComponentData::Command()


///////////////////////////////////////////////////////////////////////////////
//
//  OnChangeComputer ()
//
//  Purpose:    Change the machine managed by the snapin
//
//  Input:      piDataObject - the selected node.  This should be the root node
//                             of the snapin.
//  Output:     Returns S_OK on success
//
//  JonN 12/10/99 Copied from MYCOMPUT
//
///////////////////////////////////////////////////////////////////////////////

//      1. Launch object picker and get new computer name
//      2. Change root node text
//      3. Save new computer name to persistent name
//      4. Delete subordinate nodes
//      5. Re-add subordinate nodes
HRESULT CFileMgmtComponentData::OnChangeComputer( IDataObject * /*piDataObject*/ )
{
    if ( IsExtensionSnapin() )
    {
        ASSERT(FALSE);
        return S_FALSE;
    }

    HRESULT    hr = S_OK;

    do { // false loop

        HWND hWndParent = NULL;
        hr = m_pConsole->GetMainWindow (&hWndParent);
        ASSERT(SUCCEEDED(hr));
        CComBSTR sbstrTargetComputer;
        if ( !CHOOSER2_PickTargetComputer( AfxGetInstanceHandle(),
                                           hWndParent,
                                           &sbstrTargetComputer ) )
        {
            hr = S_FALSE;
            break;
        }

        CString strTargetComputer = sbstrTargetComputer;
        strTargetComputer.MakeUpper ();

        // If the user chooses the local computer, treat that as if they had chosen
        // "Local Computer" in Snapin Manager.  This means that there is no way to
        // reset the snapin to target explicitly at this computer without either
        // reloading the snapin from Snapin Manager, or going to a different computer.
        // When the Choose Target Computer UI is revised, we can make this more
        // consistent with Snapin Manager.
        if ( IsLocalComputername( strTargetComputer ) )
            strTargetComputer = L"";

        // If this is the same machine then don't do anything
        if (m_strMachineNamePersist == strTargetComputer)
            break;

        if (strTargetComputer.Left(2) == _T("\\\\"))
            QueryRootCookie().SetMachineName ((LPCTSTR)strTargetComputer + 2);
        else
            QueryRootCookie().SetMachineName (strTargetComputer);

        // Set the persistent name.  If we are managing the local computer
        // this name should be empty.
        m_strMachineNamePersist = strTargetComputer;

        // This requires the MMCN_PRELOAD change so that we have the
        // HSCOPEITEM for the root node
        hr = ChangeRootNodeName (strTargetComputer);
        if ( !SUCCEEDED(hr) )
            break;

        Service_CloseScManager();

        // If the node hasn't already been expanded, or if it was previously
        // expanded and there weren't any children, then there is no need
        // to remove and replace and child nodes.
        if ( QueryRootCookie().m_listScopeCookieBlocks.IsEmpty() )
        {
            //
            // 7/11/2001 LinanT bug#433102
            // When "Shares" is added to scope pane by itself as the root node, we need to
            // re-initialize related global variables after computer retargeted.
            //
            FileMgmtObjectType objecttype = QueryRootCookie().QueryObjectType();
            if (FILEMGMT_SHARES == objecttype)
                ReInit(strTargetComputer); // these global variables are only needed by the share-related operations
            break;
        }

        // Delete subordinates
        HSCOPEITEM    hRootScopeItem = QueryRootCookie().m_hScopeItem;
        MMC_COOKIE    lCookie = 0;
        HSCOPEITEM    hChild = 0;
                            
        do {
            hr = m_pConsoleNameSpace->GetChildItem (hRootScopeItem,
                                                    &hChild, &lCookie);
            if ( S_OK != hr )
                break;

            hr = m_pConsoleNameSpace->DeleteItem (hChild, TRUE);
            ASSERT (SUCCEEDED (hr));
            if ( !SUCCEEDED(hr) )
                break;
        } while (S_OK == hr);

        QueryRootCookie().ReleaseScopeChildren();

        hr = AddScopeNodes( strTargetComputer, hRootScopeItem, &QueryRootCookie() );

    } while (false); // false loop

    return hr;

} // CFileMgmtComponentData::OnChangeComputer



typedef enum _Shell32ApiIndex
{
    SHELL_EXECUTE_ENUM = 0
};

// not subject to localization
static LPCSTR g_COMPDATA_apchShell32FunctionNames[] = {
    "ShellExecuteW",
    NULL
};

// not subject to localization
DynamicDLL g_COMPDATA_Shell32DLL( _T("SHELL32.DLL"), g_COMPDATA_apchShell32FunctionNames );

typedef HINSTANCE (*SHELLEXECUTEPROC)(HWND, LPCWSTR, LPCWSTR, LPCWSTR, LPCWSTR, INT);

BOOL CFileMgmtComponentData::NewShare( LPDATAOBJECT piDataObject )
{
  TCHAR szWinDir[MAX_PATH];
  if (GetSystemWindowsDirectory(szWinDir, MAX_PATH) == 0)
  {
    ASSERT(FALSE);
    return FALSE;
  }

  CString strServerName;
    HRESULT hr = ExtractString( piDataObject, CFileMgmtDataObject::m_CFMachineName, &strServerName, MAX_PATH );
    if ( FAILED(hr) )
    {
        ASSERT( FALSE );
        return FALSE;
    }

  CString csAppName = szWinDir;
  if (csAppName.Right(1) != _T('\\'))
    csAppName += _T("\\");
  csAppName += _T("System32\\shrpubw.exe");

    CString strParameters;
    if (strServerName.IsEmpty())
        strParameters = _T(" /s");
    else
        strParameters.Format( _T(" /s %s"), strServerName );

  HWND hWnd;
  m_pConsole->GetMainWindow(&hWnd);

  DWORD dwExitCode =0;
  hr = SynchronousCreateProcess(hWnd, csAppName, strParameters, &dwExitCode);
  if ( FAILED(hr) )
  {
    (void) DoErrMsgBox(GetActiveWindow(), MB_OK | MB_ICONSTOP, hr, IDS_POPUP_NEWSHARE);
    return FALSE;
  }

    return TRUE;
}

BOOL CFileMgmtComponentData::DisconnectAllSessions( LPDATAOBJECT pDataObject )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CCookie* pbasecookie = NULL;
    FileMgmtObjectType objecttype;
    HRESULT hr = ExtractBaseCookie( pDataObject, &pbasecookie, &objecttype );
    ASSERT( SUCCEEDED(hr) && NULL != pbasecookie && FILEMGMT_SESSIONS == objecttype );
    CFileMgmtCookie* pcookie = (CFileMgmtCookie*)pbasecookie;

    if ( IDYES != DoErrMsgBox(GetActiveWindow(), MB_YESNO, 0, IDS_POPUP_CLOSE_ALL_SESSIONS) )
    {
        return FALSE;
    }

    CWaitCursor wait;
    INT iTransport;
    for ( iTransport = FILEMGMT_NUM_TRANSPORTS - 1; // bug#163500: follow this order: SFM/SMB
          iTransport >= FILEMGMT_FIRST_TRANSPORT;
          iTransport-- )
    {
        // NULL == pResultData means disconnect all sessions
        // bug#210110: ignore error to attempt on all sessions
        (void) GetFileServiceProvider(iTransport)->EnumerateSessions(
            NULL, pcookie, true);
    }
    return TRUE; // always assume that something might have changed
}

BOOL CFileMgmtComponentData::DisconnectAllResources( LPDATAOBJECT pDataObject )
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CCookie* pbasecookie = NULL;
    FileMgmtObjectType objecttype;
    HRESULT hr = ExtractBaseCookie( pDataObject, &pbasecookie, &objecttype );
    ASSERT( SUCCEEDED(hr) && NULL != pbasecookie && FILEMGMT_RESOURCES == objecttype );
    CFileMgmtCookie* pcookie = (CFileMgmtCookie*)pbasecookie;

    if ( IDYES != DoErrMsgBox(GetActiveWindow(), MB_YESNO, 0, IDS_POPUP_CLOSE_ALL_RESOURCES) )
    {
        return FALSE;
    }

    CWaitCursor wait;
    INT iTransport;
    for ( iTransport = FILEMGMT_NUM_TRANSPORTS - 1; // bug#163494: follow this order: SFM/SMB
          iTransport >= FILEMGMT_FIRST_TRANSPORT;
          iTransport-- )
    {
        // NULL == pResultData means disconnect all resources
        // bug#210110: ignore error to attempt on all open files
        (void) GetFileServiceProvider(iTransport)->EnumerateResources(
            NULL,pcookie);
    }
    return TRUE; // always assume that something might have changed
}

BOOL CFileMgmtComponentData::ConfigSfm( LPDATAOBJECT pDataObject )
{
    CString strServerName;
    HRESULT hr = ExtractString( pDataObject, CFileMgmtDataObject::m_CFMachineName, &strServerName, MAX_PATH );
    if ( FAILED(hr) )
    {
        ASSERT( FALSE );
        return FALSE;
    }

    SfmFileServiceProvider* pProvider =    
        (SfmFileServiceProvider*) GetFileServiceProvider(FILEMGMT_SFM);

    // make sure the service is running
    if ( pProvider->StartSFM(::GetActiveWindow(), m_hScManager, strServerName) )
    {
        // does the user have access?
        DWORD dwErr = pProvider->UserHasAccess(strServerName);
        if ( dwErr == NO_ERROR )
        {
            pProvider->DisplaySfmProperties(pDataObject, (CFileMgmtCookie*) &QueryRootCookie());
        }
        else
        {
            // need to tell the user something here
            DoErrMsgBox(::GetActiveWindow(), MB_OK | MB_ICONEXCLAMATION, dwErr);
        }
    }

    return FALSE; // nothing to update in the UI
}

///////////////////////////////////////////////////////////////////////////////
/// IExtendPropertySheet

STDMETHODIMP CFileMgmtComponentData::QueryPagesFor(LPDATAOBJECT pDataObject)
{
    MFC_TRY;

    if (NULL == pDataObject)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    HRESULT hr;
    DATA_OBJECT_TYPES dataobjecttype = CCT_SCOPE;
    FileMgmtObjectType objecttype = FileMgmtObjectTypeFromIDataObject(pDataObject);
    hr = ExtractData( pDataObject, CFileMgmtDataObject::m_CFDataObjectType, &dataobjecttype, sizeof(dataobjecttype) );
    ASSERT( SUCCEEDED(hr) );
    ASSERT( CCT_SCOPE == dataobjecttype ||
            CCT_RESULT == dataobjecttype ||
            CCT_SNAPIN_MANAGER == dataobjecttype );

    // determine if it needs property pages
    switch (objecttype)
    {
    #ifdef SNAPIN_PROTOTYPER
    case FILEMGMT_PROTOTYPER:
        // return S_OK;
    #endif
    case FILEMGMT_ROOT:
    case FILEMGMT_SHARES:
    case FILEMGMT_SESSIONS:
    case FILEMGMT_RESOURCES:
    case FILEMGMT_SERVICES:
        return (CCT_SNAPIN_MANAGER == dataobjecttype) ? S_OK : S_FALSE;
    default:
        break;
    }
    ASSERT(FALSE);
    return S_FALSE;

    MFC_CATCH;
} // CFileMgmtComponentData::QueryPagesFor()

STDMETHODIMP CFileMgmtComponentData::CreatePropertyPages(
    LPPROPERTYSHEETCALLBACK pCallBack,
    LONG_PTR /*handle*/,        // This handle must be saved in the property page object to notify the parent when modified
    LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState( ));

    if (NULL == pCallBack || NULL == pDataObject)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }
    HRESULT hr;

    // extract data from data object
    FileMgmtObjectType objecttype = FileMgmtObjectTypeFromIDataObject(pDataObject);
    DATA_OBJECT_TYPES dataobjecttype = CCT_SCOPE;
    hr = ExtractData( pDataObject, CFileMgmtDataObject::m_CFDataObjectType, &dataobjecttype, sizeof(dataobjecttype) );
    ASSERT( SUCCEEDED(hr) );
    ASSERT( CCT_SCOPE == dataobjecttype ||
            CCT_RESULT == dataobjecttype ||
            CCT_SNAPIN_MANAGER == dataobjecttype );

    // determine if it needs property pages
    switch (objecttype)
    {
    case FILEMGMT_ROOT:
    case FILEMGMT_SHARES:
    case FILEMGMT_SESSIONS:
    case FILEMGMT_RESOURCES:
    #ifdef SNAPIN_PROTOTYPER
    case FILEMGMT_PROTOTYPER:
    #endif
    case FILEMGMT_SERVICES:
    {
        if (CCT_SNAPIN_MANAGER != dataobjecttype)
        {
            ASSERT(FALSE);
            return E_UNEXPECTED;
        }

        //
        // Note that once we have established that this is a CCT_SNAPIN_MANAGER cookie,
        // we don't care about its other properties.  A CCT_SNAPIN_MANAGER cookie is
        // equivalent to a BOOL flag asking for the Node Properties page instead of a
        // managed object property page.  JonN 10/9/96
        //
        CChooseMachinePropPage * pPage;
        if (IsServiceSnapin())
            {
            pPage = new CChooseMachinePropPage();
            pPage->SetCaption(IDS_CAPTION_SERVICES);
            pPage->SetHelp(g_szHelpFileFilemgmt, g_a970HelpIDs);
            }
        else
            {
            CFileMgmtGeneral * pPageT = new CFileMgmtGeneral;
            pPageT->SetFileMgmtComponentData(this);
            pPage = pPageT;
            pPage->SetHelp(g_szHelpFileFilemgmt, HELP_DIALOG_TOPIC(IDD_FILE_FILEMANAGEMENT_GENERAL));
            }
        // Initialize state of object
        ASSERT(NULL != m_pRootCookie);
        pPage->InitMachineName( QueryRootCookie().QueryTargetServer() );
        pPage->SetOutputBuffers(
            OUT &m_strMachineNamePersist,
            OUT &m_fAllowOverrideMachineName,
            OUT &m_pRootCookie->m_strMachineName);    // Effective machine name

        HPROPSHEETPAGE hPage=MyCreatePropertySheetPage(&pPage->m_psp);
        pCallBack->AddPage(hPage);
        return S_OK;
    }
    default:
        break;
    }
    ASSERT(FALSE);
    return S_FALSE;
} // CFileMgmtComponentData::CreatePropertyPages()


CString g_strShares;
CString g_strSessions;
CString g_strResources;
CString g_strServices;
BOOL g_fScopeStringsLoaded = FALSE;
void CFileMgmtComponentData::LoadGlobalStrings()
{
    if (!g_fScopeStringsLoaded )
    {
        g_fScopeStringsLoaded = TRUE;
        VERIFY( g_strShares.LoadString(    IDS_SCOPE_SHARES    ) );
        VERIFY( g_strSessions.LoadString(  IDS_SCOPE_SESSIONS  ) );
        VERIFY( g_strResources.LoadString( IDS_SCOPE_RESOURCES ) );
        VERIFY( g_strServices.LoadString(  IDS_SCOPE_SERVICES  ) );
    }
}

// global space to store the string haded back to GetDisplayInfo()
// CODEWORK should use "bstr" for ANSI-ization
CString g_strResultColumnText;

BSTR CFileMgmtScopeCookie::QueryResultColumnText( int nCol, CFileMgmtComponentData& refcdata )
{
    FileMgmtObjectType objtype = QueryObjectType();
    BOOL fStaticNode = (   !refcdata.IsExtensionSnapin()
                        && refcdata.QueryRootCookie().QueryObjectType() == objtype);
    switch (objtype)
    {
    //
    // These are scope items which can appear in the result pane.
    // We only need to deal with column 0, others are blank
    //
    case FILEMGMT_ROOT:
        switch (nCol)
        {
        case 0:
            GetDisplayName( g_strResultColumnText, fStaticNode );
            return const_cast<BSTR>(((LPCTSTR)g_strResultColumnText));
        case 1: // Type - blank
            break;
        case 2: // Description
            g_strResultColumnText.LoadString(IDS_SNAPINABOUT_DESCR_FILESVC);
            return const_cast<BSTR>(((LPCTSTR)g_strResultColumnText));
        default:
            break;
        }
        break;
    case FILEMGMT_SHARES:
    case FILEMGMT_SESSIONS:
    case FILEMGMT_RESOURCES:
        if (0 == nCol)
        {
            GetDisplayName( g_strResultColumnText, fStaticNode );
            return const_cast<BSTR>(((LPCTSTR)g_strResultColumnText));
        }
        break;
    case FILEMGMT_SERVICES:
        switch (nCol)
        {
        case 0:
            GetDisplayName( g_strResultColumnText, fStaticNode );
            return const_cast<BSTR>(((LPCTSTR)g_strResultColumnText));
        case 1: // Type - blank
            break;
        case 2: // Description
            g_strResultColumnText.LoadString(IDS_SNAPINABOUT_DESCR_SERVICES);
            return const_cast<BSTR>(((LPCTSTR)g_strResultColumnText));
        default:
            break;
        }
        break;
    default:
        ASSERT(FALSE);
        break;
    }
    return L"";
}



BSTR MakeDwordResult(DWORD dw)
{
    g_strResultColumnText.Format( _T("%d"), dw );
    return const_cast<BSTR>((LPCTSTR)g_strResultColumnText);
}

BSTR MakeElapsedTimeResult(DWORD dwTime)
{
    if ( -1L == dwTime )
        return L""; // not known
    DWORD dwSeconds = dwTime % 60;
    dwTime /= 60;
    DWORD dwMinutes = dwTime % 60;
    dwTime /= 60;
    DWORD dwHours = dwTime % 24;
    dwTime /= 24;
    DWORD dwDays = dwTime;
    LoadStringPrintf(
          (dwDays == 0) ? IDS_TIME_HOURPLUS :
            ((dwDays > 1) ? IDS_TIME_DAYPLUS : IDS_TIME_ONEDAY),
          &g_strResultColumnText,
          dwDays, dwHours, dwMinutes, dwSeconds );
    return const_cast<BSTR>((LPCTSTR)g_strResultColumnText);
}

BSTR CFileMgmtComponentData::MakeTransportResult(FILEMGMT_TRANSPORT transport)
{
    return const_cast<BSTR>(GetFileServiceProvider(transport)->QueryTransportString());
}

CString g_strPermissionNone;
CString g_strPermissionCreate;
CString g_strPermissionReadWrite;
CString g_strPermissionRead;
CString g_strPermissionWrite;
BOOL    g_fPermissionStringsLoaded = FALSE;

BSTR MakePermissionsResult( DWORD dwPermissions )
{
  if (!g_fPermissionStringsLoaded)
  {
    g_fPermissionStringsLoaded = TRUE;
    VERIFY( g_strPermissionNone.LoadString(IDS_FILEPERM_NONE) );
    VERIFY( g_strPermissionCreate.LoadString(IDS_FILEPERM_CREATE) );
    VERIFY( g_strPermissionReadWrite.LoadString(IDS_FILEPERM_READWRITE) );
    VERIFY( g_strPermissionRead.LoadString(IDS_FILEPERM_READ) );
    VERIFY( g_strPermissionWrite.LoadString(IDS_FILEPERM_WRITE) );
  }

    if      (PERM_FILE_CREATE & dwPermissions)
        return const_cast<BSTR>((LPCTSTR)g_strPermissionCreate);
    else if (PERM_FILE_WRITE  & dwPermissions)
        return ( (PERM_FILE_READ & dwPermissions)
            ? const_cast<BSTR>((LPCTSTR)g_strPermissionReadWrite)
            : const_cast<BSTR>((LPCTSTR)g_strPermissionWrite) );
    else if (PERM_FILE_READ   & dwPermissions)
        return const_cast<BSTR>((LPCTSTR)g_strPermissionRead);

    return const_cast<BSTR>((LPCTSTR)g_strPermissionNone);
}

CString& CFileMgmtComponentData::ResultStorageString()
{
    return g_strResultColumnText;
}

BSTR CFileMgmtComponentData::QueryResultColumnText(
    CCookie& basecookieref,
    int nCol )
{
    CFileMgmtCookie& cookieref = (CFileMgmtCookie&)basecookieref;
    return cookieref.QueryResultColumnText( nCol, *this );
/*
#ifndef UNICODE
#error not ANSI-enabled
#endif
    HRESULT hr = S_OK;
    switch (cookieref.QueryObjectType())
    {
    //
    // These are scope items which can appear in the result pane.
    // We only need to deal with column 0, others are blank
    //
    case FILEMGMT_SHARES:
        if (0 == nCol)
            return const_cast<BSTR>(((LPCTSTR)g_strShares));
        break;
    case FILEMGMT_SESSIONS:
        if (0 == nCol)
            return const_cast<BSTR>(((LPCTSTR)g_strSessions));
        break;
    case FILEMGMT_RESOURCES:
        if (0 == nCol)
            return const_cast<BSTR>(((LPCTSTR)g_strResources));
        break;

    //
    // These are result items.  We need to deal with all columns.
    // It is no longer permitted to set this text at insert time.
    //
    case FILEMGMT_SHARE:
    case FILEMGMT_SESSION:
    case FILEMGMT_RESOURCE:
    case FILEMGMT_SERVICE:
        return cookieref.QueryResultColumnText( nCol, *this );

    // CODEWORK do we need to deal with these?  They never appear
    //   in the result pane.
    case FILEMGMT_ROOT:
    case FILEMGMT_SERVICES:
        // fall through

    default:
        ASSERT(FALSE);
        break;
    }

    return L"";
*/
}

int CFileMgmtComponentData::QueryImage(CCookie& basecookieref, BOOL fOpenImage)
{
    CFileMgmtCookie& cookieref = (CFileMgmtCookie&)basecookieref;
    // CODEWORK we need new icons for Resource, Open File and possibly also
    // differentiating by transport
    int iIconReturn = iIconSharesFolder;
    switch (cookieref.QueryObjectType())
    {
    case FILEMGMT_ROOT:
    case FILEMGMT_SHARES:
    case FILEMGMT_SESSIONS:
    case FILEMGMT_RESOURCES:
        if (fOpenImage)
            return iIconSharesFolderOpen;
        return iIconSharesFolder;
    case FILEMGMT_SERVICE:
    case FILEMGMT_SERVICES:
        return iIconService;
    case FILEMGMT_SHARE:
        iIconReturn = iIconSMBShare;
        break;
    case FILEMGMT_SESSION:
        iIconReturn = iIconSMBSession;
        break;
    case FILEMGMT_RESOURCE:
        iIconReturn = iIconSMBResource;
        break;
    default:
        ASSERT(FALSE);
        return iIconSharesFolder;
    }

    FILEMGMT_TRANSPORT transport = FILEMGMT_SMB;
    VERIFY( SUCCEEDED(cookieref.GetTransport( &transport ) ) );

    switch (transport)
    {
    case FILEMGMT_SMB:
        break;
    case FILEMGMT_SFM:
        return iIconReturn+1;
    #ifdef SNAPIN_PROTOTYPER
    case FILEMGMT_PROTOTYPER:
        if (((CPrototyperScopeCookie &)cookieref).m_ScopeType == HTML)
            return iIconPrototyperHTML;
        else return iIconPrototyperContainerClosed;
    case FILEMGMT_PROTOTYPER_LEAF:
        return iIconPrototyperLeaf;
    #endif // FILEMGMT_PROTOTYPER
    default:
        ASSERT(FALSE);
        break;
    }

    return iIconReturn;
}

///////////////////////////////////////////////////////////////////////////////
//
//    ChangeRootNodeName ()
//
//  Purpose:    Change the text of the root node
//
//    Input:        newName - the new machine name that the snapin manages
//  Output:        Returns S_OK on success
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CFileMgmtComponentData::ChangeRootNodeName(const CString & newName)
{
    MFC_TRY;
    ASSERT (m_pRootCookie);
    if ( !m_pRootCookie )
        return E_FAIL;
    // This should only happen per bug 453635/453636, when the snapin
    // was just added to the console and we still don't have the
    // root node's HSCOPEITEM.  Ignore this for now.
    if ( !QueryBaseRootCookie().m_hScopeItem )
        return S_OK;

    CString        machineName (newName);
    CString        formattedName;

    // If machineName is empty, then this manages the local machine.  Get
    // the local machine name.  Then format the computer name with the snapin
    // name

    FileMgmtObjectType objecttype = QueryRootCookie().QueryObjectType();

    // JonN 11/14/00 164998 set to SERVICES where appropriate
    if (machineName.IsEmpty())
    {
        if (IsServiceSnapin())
	    formattedName.LoadString(IDS_DISPLAYNAME_SERVICES_LOCAL);
        else
        {
            switch (objecttype)
            {
            case FILEMGMT_SHARES:
        	formattedName.LoadString(IDS_DISPLAYNAME_SHARES_LOCAL);
                break;   
            case FILEMGMT_SESSIONS:
        	formattedName.LoadString(IDS_DISPLAYNAME_SESSIONS_LOCAL);
                break;   
            case FILEMGMT_RESOURCES:
        	formattedName.LoadString(IDS_DISPLAYNAME_FILES_LOCAL);
                break;   
            default:
        	formattedName.LoadString(IDS_DISPLAYNAME_ROOT_LOCAL);
                break;   
            }
        }
    }
    else
    {
        machineName.MakeUpper ();
        if (IsServiceSnapin())
	    formattedName.FormatMessage(IDS_DISPLAYNAME_s_SERVICES, machineName);
        else
        {
            switch (objecttype)
            {
            case FILEMGMT_SHARES:
        	formattedName.FormatMessage(IDS_DISPLAYNAME_s_SHARES, machineName);
                break;   
            case FILEMGMT_SESSIONS:
        	formattedName.FormatMessage(IDS_DISPLAYNAME_s_SESSIONS, machineName);
                break;   
            case FILEMGMT_RESOURCES:
        	formattedName.FormatMessage(IDS_DISPLAYNAME_s_FILES, machineName);
                break;   
            default:
        	formattedName.FormatMessage(IDS_DISPLAYNAME_s_ROOT, machineName);
                break;   
            }
        }
    }

    SCOPEDATAITEM    item;
    ::ZeroMemory (&item, sizeof (SCOPEDATAITEM));
    item.mask = SDI_STR;
    item.displayname = (LPTSTR) (LPCTSTR) formattedName;
    item.ID = QueryBaseRootCookie ().m_hScopeItem;

    return m_pConsoleNameSpace->SetItem (&item);
    MFC_CATCH;
}

///////////////////////////////////////////////////////////////////////////////
//
//  OnNotifyPreload ()
//
//  Purpose:    Remember the HSCOPEITEM of the root node
//
//  Note:       Requires that CCF_SNAPIN_PRELOADS be set
//
///////////////////////////////////////////////////////////////////////////////
HRESULT CFileMgmtComponentData::OnNotifyPreload(
    LPDATAOBJECT /*lpDataObject*/,
    HSCOPEITEM hRootScopeItem)
{
    QueryRootCookie().m_hScopeItem = hRootScopeItem;

    //
    // 7/11/2001 LinanT bug#433102
    // Before "Shares" is added to scope pane by itself as the root node, we need to
    // initialize related global variables.
    //
    PCWSTR lpwcszMachineName = QueryRootCookie().QueryNonNULLMachineName();
    FileMgmtObjectType objecttype = QueryRootCookie().QueryObjectType();
    if (FILEMGMT_SHARES == objecttype)
    {
        ReInit(lpwcszMachineName);
    }

    // JonN 3/13/01 342366
    // Services: No credential defaults to local from command line
    VERIFY( SUCCEEDED( ChangeRootNodeName(
                QueryRootCookie().QueryNonNULLMachineName())));

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// The following 3 functions are cut & pasted from shell\osshell\lmui\ntshrui\util.cxx
//////////////////////////////////////////////////////////////////////////////

//+---------------------------------------------------------------------------
//
//  Function:   IsSafeMode
//
//  Synopsis:   Checks the registry to see if the system is in safe mode.
//
//  History:    06-Oct-00 JeffreyS  Created
//
//----------------------------------------------------------------------------

BOOL
IsSafeMode(
    VOID
    )
{
    BOOL fIsSafeMode = FALSE;

    HKEY hkey = NULL;
    LONG ec = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("SYSTEM\\CurrentControlSet\\Control\\SafeBoot\\Option"),
                0,
                KEY_QUERY_VALUE,
                &hkey
                );

    if (ec == NO_ERROR)
    {
        DWORD dwValue = 0;
        DWORD dwValueSize = sizeof(dwValue);

        ec = RegQueryValueEx(hkey,
                             TEXT("OptionValue"),
                             NULL,
                             NULL,
                             (LPBYTE)&dwValue,
                             &dwValueSize);

        if (ec == NO_ERROR)
        {
            fIsSafeMode = (dwValue == SAFEBOOT_MINIMAL || dwValue == SAFEBOOT_NETWORK);
        }

        RegCloseKey(hkey);
    }

    return fIsSafeMode;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsForcedGuestModeOn
//
//  Synopsis:   Checks the registry to see if the system is using the
//              Guest-only network access mode.
//
//  History:    06-Oct-00 JeffreyS  Created
//              19-Apr-00 GPease    Modified and changed name
//
//----------------------------------------------------------------------------

BOOL
IsForcedGuestModeOn(
    VOID
    )
{
    BOOL fIsForcedGuestModeOn = FALSE;

    if (IsOS(OS_PERSONAL))
    {
        // Guest mode is always on for Personal
        fIsForcedGuestModeOn = TRUE;
    }
    else if (IsOS(OS_PROFESSIONAL) && !IsOS(OS_DOMAINMEMBER))
    {
        // Professional, not in a domain. Check the ForceGuest value.
        HKEY hkey = NULL;
        LONG ec = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT("SYSTEM\\CurrentControlSet\\Control\\LSA"),
                    0,
                    KEY_QUERY_VALUE,
                    &hkey
                    );

        if (ec == NO_ERROR)
        {
            DWORD dwValue = 0;
            DWORD dwValueSize = sizeof(dwValue);

            ec = RegQueryValueEx(hkey,
                                 TEXT("ForceGuest"),
                                 NULL,
                                 NULL,
                                 (LPBYTE)&dwValue,
                                 &dwValueSize);

            if (ec == NO_ERROR && 0 != dwValue)
            {
                fIsForcedGuestModeOn = TRUE;
            }

            RegCloseKey(hkey);
        }
    }

    return fIsForcedGuestModeOn;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsSimpleUI
//
//  Synopsis:   Checks whether to show the simple version of the UI.
//
//  History:    06-Oct-00 JeffreyS  Created
//              19-Apr-00 GPease    Removed CTRL key check
//
//----------------------------------------------------------------------------

BOOL IsSimpleUI(PCTSTR pszMachineName)
{
    //
    // no need to disable acl-related context menu items if targeted at a remote machine
    //
    if (!IsLocalComputername(pszMachineName))
        return FALSE;

    // Show old UI in safe mode and anytime network access involves
    // true user identity (server, pro with GuestMode off).
    
    // Show simple UI anytime network access is done using the Guest
    // account (personal, pro with GuestMode on) except in safe mode.

    return (!IsSafeMode() && IsForcedGuestModeOn());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\compdata.h ===
/////////////////////////////////////////////////////////////////////
// compdata.h : Declaration of CFileMgmtComponentData
//
// HISTORY
// 01-Jan-1996		???			Creation
// 29-May-1997		t-danm		Added Command Line override.
//
/////////////////////////////////////////////////////////////////////

#ifndef __COMPDATA_H_INCLUDED__
#define __COMPDATA_H_INCLUDED__

#include "stdcdata.h" // CComponentData
#include "persist.h" // PersistStorage, PersistStream
#include "cookie.h"  // CFileMgmtCookie
#include <activeds.h> // IADsContainer

typedef enum _SHAREPUBLISH_SCHEMA
{
    SHAREPUBLISH_SCHEMA_UNASSIGNED = 0,
    SHAREPUBLISH_SCHEMA_SUPPORTED,
    SHAREPUBLISH_SCHEMA_UNSUPPORTED
} SHAREPUBLISH_SCHEMA;

// forward declarations
class FileServiceProvider;

class CFileMgmtComponentData :
   	public CComponentData,
    public CHasMachineName,
   	public IExtendContextMenu,
    public IExtendPropertySheet,
	#ifdef PERSIST_TO_STORAGE
	public PersistStorage
	#else
	public PersistStream
	#endif
{
friend class CFileMgmtDataObject;
public:
	CFileMgmtComponentData();
	~CFileMgmtComponentData();
BEGIN_COM_MAP(CFileMgmtComponentData)
	COM_INTERFACE_ENTRY(IExtendContextMenu)
	COM_INTERFACE_ENTRY(IExtendPropertySheet)
	#ifdef PERSIST_TO_STORAGE
	COM_INTERFACE_ENTRY(IPersistStorage)
	#else
	COM_INTERFACE_ENTRY(IPersistStream)
	#endif
	COM_INTERFACE_ENTRY_CHAIN(CComponentData)
END_COM_MAP()

#if DBG==1
	ULONG InternalAddRef()
	{
        return CComObjectRoot::InternalAddRef();
	}
	ULONG InternalRelease()
	{
        return CComObjectRoot::InternalRelease();
	}
    int dbg_InstID;
#endif // DBG==1

// IComponentData
	STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
	STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);

	// needed for Initialize()
	virtual HRESULT LoadIcons(LPIMAGELIST pImageList, BOOL fLoadLargeIcons);

	// needed for Notify()
	virtual HRESULT OnNotifyExpand(LPDATAOBJECT lpDataObject, BOOL bExpanding, HSCOPEITEM hParent);
	virtual HRESULT OnNotifyDelete(LPDATAOBJECT lpDataObject);
	virtual HRESULT OnNotifyRelease(LPDATAOBJECT lpDataObject, HSCOPEITEM hItem);
	virtual HRESULT AddScopeNodes( LPCTSTR lpcszTargetServer,
								   HSCOPEITEM hParent,
								   CFileMgmtCookie* pParentCookie );

	// added 01/19/00 JonN
	virtual HRESULT OnNotifyPreload(LPDATAOBJECT lpDataObject,
	                                HSCOPEITEM hRootScopeItem);

	// needed for GetDisplayInfo(), must be defined by subclass
	virtual BSTR QueryResultColumnText(CCookie& basecookieref, int nCol );
	virtual int QueryImage(CCookie& basecookieref, BOOL fOpenImage);

    // needed for OnNotifyExpand
    HRESULT ReInit(LPCTSTR lpcszTargetServer);
    HRESULT AddScopeCookie( HSCOPEITEM hParnet,
                            LPCTSTR lpcszTargetServer,
                            FileMgmtObjectType objecttype,
                            CFileMgmtCookie* pParentCookie );

	// utility routines for QueryResultColumnText
	BSTR MakeTransportResult(FILEMGMT_TRANSPORT transport);
	CString& ResultStorageString();

	BOOL IsExtendedNodetype( GUID& refguid );

	#ifdef SNAPIN_PROTOTYPER
	#define RegStringLen  1000
	#define DefMenuStart  100
	#define TaskMenuStart 200
	#define NewMenuStart  300
	HRESULT	Prototyper_HrEnumerateScopeChildren(CFileMgmtCookie * pParentCookie, HSCOPEITEM hParent);
	BOOL TraverseRegistry(CPrototyperScopeCookie *pParentCookie, HKEY parentRegkey);
	BOOL ReadLeafData(CPrototyperResultCookie *pParentCookie, HKEY parentRegkey);
	BOOL Prototyper_FOpenRegistry(CFileMgmtCookie * pCookie, AMC::CRegKey *m_regkeySnapinDemoRoot);
	BOOL Prototyper_ContextMenuCommand(LONG lCommandID, IDataObject* piDataObject);
	#endif // SNAPIN_PROTOTYPER

	// IExtendContextMenu
	STDMETHOD(AddMenuItems)(
                    IDataObject*          piDataObject,
					IContextMenuCallback* piCallback,
					long*                 pInsertionAllowed);
	STDMETHOD(Command)(
					LONG	        lCommandID,
                    IDataObject*    piDataObject );
	HRESULT DoAddMenuItems( IContextMenuCallback* piCallback,
	                        FileMgmtObjectType objecttype,
	                        DATA_OBJECT_TYPES  dataobjecttype,
							long* pInsertionAllowed,
                            IDataObject * piDataObject);
	HRESULT OnChangeComputer( IDataObject * piDataObject );
	BOOL NewShare( LPDATAOBJECT piDataObject );
	BOOL DisconnectAllSessions( LPDATAOBJECT pDataObject );
	BOOL DisconnectAllResources( LPDATAOBJECT pDataObject );
    BOOL ConfigSfm( LPDATAOBJECT pDataObject );

// IExtendPropertySheet
	STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK pCall, LONG_PTR handle, LPDATAOBJECT pDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT pDataObject);

// IPersistStream or IPersistStorage
	STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID) = 0;
	#ifdef PERSIST_TO_STORAGE
    STDMETHOD(Load)(IStorage __RPC_FAR *pStg);
    STDMETHOD(Save)(IStorage __RPC_FAR *pStgSave, BOOL fSameAsLoad);
	#else
    STDMETHOD(Load)(IStream __RPC_FAR *pStg);
    STDMETHOD(Save)(IStream __RPC_FAR *pStgSave, BOOL fSameAsLoad);
    #endif

	virtual CCookie& QueryBaseRootCookie();

	inline CFileMgmtScopeCookie& QueryRootCookie()
	{
		return (CFileMgmtScopeCookie&)QueryBaseRootCookie();
	}

	inline FileServiceProvider* GetFileServiceProvider(
		FILEMGMT_TRANSPORT transport )
	{
		ASSERT( IsValidTransport(transport) && 
		        NULL != m_apFileServiceProviders[transport] );
		return m_apFileServiceProviders[transport];
	}
	inline FileServiceProvider* GetFileServiceProvider(
		INT iTransport )
	{
		return GetFileServiceProvider((FILEMGMT_TRANSPORT)iTransport);
	}

	virtual BOOL IsServiceSnapin() = 0;
	virtual BOOL IsExtensionSnapin() { return FALSE; }

	static void LoadGlobalStrings();

	inline CFileMgmtCookie* ActiveCookie( CFileMgmtCookie* pCookie )
	{
		return (CFileMgmtCookie*)ActiveBaseCookie( (CCookie*)pCookie );
	}

	BOOL GetSchemaSupportSharePublishing();

	IADsContainer *GetIADsContainer();

	inline BOOL GetIsSimpleUI() { return m_bIsSimpleUI; }
	inline void SetIsSimpleUI(BOOL bSimpleUI) { m_bIsSimpleUI = bSimpleUI; }

	HRESULT ChangeRootNodeName (const CString& newName);

	DECLARE_FORWARDS_MACHINE_NAME( m_pRootCookie )

	// It would be great if these could be global. but MFC's global-destructor
	// apparently doesn't like deleting handles in DLL_PROCESS_DETACH with
	// DEBUG_CRTS set.  Win32 ::LoadBitmap should use copy-on-write semantics
	// for multiple copies of a bitmap.
	// CODEWORK could break these out into the subclasses
	BOOL m_fLoadedFileMgmtToolbarBitmap;
	CBitmap m_bmpFileMgmtToolbar;
	BOOL m_fLoadedSvcMgmtToolbarBitmap;
	CBitmap m_bmpSvcMgmtToolbar;

protected:
	friend class CFileMgmtComponent;

	// Variables for System Services
	SC_HANDLE m_hScManager;				// Handle to service control manager database
	BOOL m_fQueryServiceConfig2;		// TRUE => Machine support QueryServiceConfig2() API

	SHAREPUBLISH_SCHEMA m_SchemaSupportSharePublishing;

	CComPtr<IADsContainer> m_spiADsContainer; // improv PERF when deleting multi-selected shares

	// m_bIsSimpleUI is used to disable acl-related context menu items on shares
	// whenever SimpleSharingUI is on (i.e., when ForceGuest bit really functions)
        // when snapin targeted at local machine.
	BOOL m_bIsSimpleUI;

public:
	APIERR Service_EOpenScManager(LPCTSTR pszMachineName);
	void Service_CloseScManager();
	BOOL Service_FGetServiceInfoFromIDataObject(IDataObject * pDataObject, CString * pstrMachineName, CString * pstrServiceName, CString * pstrServiceDisplayName);
	BOOL Service_FAddMenuItems(IContextMenuCallback * pContextMenuCallback, IDataObject * pDataObject, BOOL fIs3rdPartyContextMenuExtension = FALSE);
	BOOL Service_FDispatchMenuCommand(INT nCommandId, IDataObject * pDataObject);
	BOOL Service_FInsertPropertyPages(LPPROPERTYSHEETCALLBACK pCallBack, IDataObject * pDataObject, LONG_PTR lNotifyHandle);
	HRESULT Service_PopulateServices(LPRESULTDATA pResultData, CFileMgmtScopeCookie* pcookie);
	HRESULT Service_AddServiceItems(LPRESULTDATA pResultData, CFileMgmtScopeCookie* pParentCookie, ENUM_SERVICE_STATUS * rgESS, DWORD nDataItems);
	
private:
	// for extensions, the list of child scope cookies is in
	// m_pRootCookie->m_listScopeCookieBlocks
	CFileMgmtScopeCookie* m_pRootCookie;


protected:
	// The following members are used to support Command Line override.
	enum	// Bit fields for m_dwFlagsPersist
		{
		mskfAllowOverrideMachineName = 0x0001
		};
	DWORD m_dwFlagsPersist;				// General-purpose flags to be persisted into .msc file
	CString m_strMachineNamePersist;	// Machine name to persist into .msc file

public:
	BOOL m_fAllowOverrideMachineName;	// TRUE => Allow the machine name to be overriden by the command line
	
	void SetPersistentFlags(DWORD dwFlags)
		{
		m_dwFlagsPersist = dwFlags;
		m_fAllowOverrideMachineName = !!(m_dwFlagsPersist & mskfAllowOverrideMachineName);
		}

	DWORD GetPersistentFlags()
		{
		if (m_fAllowOverrideMachineName)
			m_dwFlagsPersist |= mskfAllowOverrideMachineName;
		else
			m_dwFlagsPersist &= ~mskfAllowOverrideMachineName;
		return m_dwFlagsPersist;
		}

private:
	#ifdef SNAPIN_PROTOTYPER
	bool m_RegistryParsedYet;
	//CPrototyperScopeCookieBlock m_RootCookieBlock;	
	#else
	//CFileMgmtScopeCookieBlock m_RootCookieBlock;
	#endif
	FileServiceProvider* m_apFileServiceProviders[FILEMGMT_NUM_TRANSPORTS];
}; // CFileMgmtComponentData

BSTR MakeDwordResult(DWORD dw);
BSTR MakeElapsedTimeResult(DWORD dwTime);
BSTR MakePermissionsResult( DWORD dwPermissions );
void TranslateIPToComputerName(LPCTSTR ptszIP, CString& strComputerName);

/////////////////////////////////////////////////////////////////////
class CFileSvcMgmtSnapin: public CFileMgmtComponentData,
	public CComCoClass<CFileSvcMgmtSnapin, &CLSID_FileServiceManagement>
{
public:
	CFileSvcMgmtSnapin();
	~CFileSvcMgmtSnapin();
// Use DECLARE_NOT_AGGREGATABLE(CFileSvcMgmtSnapin) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CFileSvcMgmtSnapin)
DECLARE_REGISTRY(CFileSvcMgmtSnapin, _T("FILEMGMT.FileSvcMgmtObject.1"), _T("FILEMGMT.FileSvcMgmtObject.1"), IDS_FILEMGMT_DESC, THREADFLAGS_BOTH)
	virtual BOOL IsServiceSnapin() { return FALSE; }

// IPersistStream or IPersistStorage
	STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
	{
		*pClassID=CLSID_FileServiceManagement;
		return S_OK;
	}
};


class CServiceMgmtSnapin:
	public CFileMgmtComponentData,
	public CComCoClass<CServiceMgmtSnapin, 
		#ifdef SNAPIN_PROTOTYPER
			&CLSID_SnapinPrototyper>
		#else
			&CLSID_SystemServiceManagement>
		#endif
{
public:
	CServiceMgmtSnapin();
	~CServiceMgmtSnapin();
// Use DECLARE_NOT_AGGREGATABLE(CServiceMgmtSnapin) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CServiceMgmtSnapin)
DECLARE_REGISTRY(CServiceMgmtSnapin, _T("SVCVWR.SvcVwrObject.1"), _T("SVCVWR.SvcVwrObject.1"), IDS_SVCVWR_DESC, THREADFLAGS_BOTH)
	virtual BOOL IsServiceSnapin() { return TRUE; }

// IPersistStream or IPersistStorage
	STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
	{
		*pClassID=CLSID_SystemServiceManagement;
		return S_OK;
	}
};


class CFileSvcMgmtExtension: public CFileMgmtComponentData,
	public CComCoClass<CFileSvcMgmtSnapin, &CLSID_FileServiceManagementExt>
{
public:
	CFileSvcMgmtExtension();
	~CFileSvcMgmtExtension();
// Use DECLARE_NOT_AGGREGATABLE(CFileSvcMgmtExtension) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CFileSvcMgmtExtension)
DECLARE_REGISTRY(CFileSvcMgmtExtension, _T("FILEMGMT.FileSvcMgmtExtObject.1"), _T("FILEMGMT.FileSvcMgmtExtObject.1"), IDS_FILEMGMT_DESC, THREADFLAGS_BOTH)
	virtual BOOL IsServiceSnapin() { return FALSE; }
	virtual BOOL IsExtensionSnapin() { return TRUE; }

// IPersistStream or IPersistStorage
	STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
	{
		*pClassID=CLSID_FileServiceManagementExt;
		return S_OK;
	}
};


class CServiceMgmtExtension: public CFileMgmtComponentData,
	public CComCoClass<CServiceMgmtExtension, &CLSID_SystemServiceManagementExt>
{
public:
	CServiceMgmtExtension();
	~CServiceMgmtExtension();
// Use DECLARE_NOT_AGGREGATABLE(CServiceMgmtExtension) if you don't want your object
// to support aggregation
DECLARE_AGGREGATABLE(CServiceMgmtExtension)
DECLARE_REGISTRY(CServiceMgmtExtension, _T("SVCVWR.SvcVwrExtObject.1"), _T("SVCVWR.SvcVwrExtObject.1"), IDS_SVCVWR_DESC, THREADFLAGS_BOTH)
	virtual BOOL IsServiceSnapin() { return TRUE; }
	virtual BOOL IsExtensionSnapin() { return TRUE; }

// IPersistStream or IPersistStorage
	STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
	{
		*pClassID=CLSID_SystemServiceManagementExt;
		return S_OK;
	}
};

#endif // ~__COMPDATA_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\dbg.h ===
#include "StdDbg.h"

#if DBG==1
    DECLARE_DEBUG(FileMgmtSnapin)
    #define DBG_COMP    FileMgmtSnapinInfoLevel
#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\dataobj.cpp ===
// DataObj.cpp : Implementation of data object classes

#include "stdafx.h"
#include "compdata.h"
#include "safetemp.h"

#include "macros.h"
USE_HANDLE_MACROS("FILEMGMT(dataobj.cpp)")

#include "FileSvc.h" // FileServiceProvider
#include "dataobj.h"

#include "smb.h"
#include "sfm.h"
#include "cmponent.h"    // for COLNUM_SESSIONS_COMPUTERNAME

#define DONT_WANT_SHELLDEBUG
#include "shlobjp.h"    // ILFree, ILGetSize, ILClone, etc.

#include <comstrm.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#include "stddtobj.cpp"


// IDataObject interface implementation
HRESULT CFileMgmtDataObject::GetDataHere(
    FORMATETC __RPC_FAR *pFormatEtcIn,
    STGMEDIUM __RPC_FAR *pMedium)
{
    MFC_TRY;

    const CLIPFORMAT cf=pFormatEtcIn->cfFormat;

    if (cf == m_CFInternal)
    {
        CFileMgmtDataObject *pThis = this;
        stream_ptr s(pMedium);
        return s.Write(&pThis, sizeof(CFileMgmtDataObject*));
    }
    else if (cf == m_CFSnapInCLSID)
    {
        stream_ptr s(pMedium);
        return s.Write(&m_SnapInCLSID, sizeof(GUID));
    }
    
    if (!m_MultiSelectObjList.empty())
    {
        //
        // this is the multiselect data object, we don't support other clipformats in GetDataHere().
        //
        return DV_E_FORMATETC;
    }

    if (cf == m_CFNodeType)
    {
        const GUID* pguid = GetObjectTypeGUID( m_objecttype );
        stream_ptr s(pMedium);
        return s.Write(pguid, sizeof(GUID));
    }
    else if (cf == m_CFNodeTypeString)
    {
        const BSTR strGUID = GetObjectTypeString( m_objecttype );
        stream_ptr s(pMedium);
        return s.Write(strGUID);
    }
    else if (cf == m_CFDisplayName)
    {
        return PutDisplayName(pMedium);
    }
    else if (cf == m_CFDataObjectType)
    {
        stream_ptr s(pMedium);
        return s.Write(&m_dataobjecttype, sizeof(m_dataobjecttype));
    }
    else if (cf == m_CFMachineName)
    {
        stream_ptr s(pMedium);
        return s.Write(m_strMachineName);
    }
    else if (cf == m_CFTransport)
    {
        FILEMGMT_TRANSPORT transport = FILEMGMT_OTHER;
        HRESULT hr = m_pcookie->GetTransport( &transport );
        if ( FAILED(hr) )
            return hr;
        stream_ptr s(pMedium);
        return s.Write(&transport, sizeof(DWORD));
    }
    else if (cf == m_CFShareName)
    {
        ASSERT( NULL != m_pcookie );
        CString strShareName;
        HRESULT hr = m_pcookie->GetShareName( strShareName );
        if ( FAILED(hr) )
            return hr;
        stream_ptr s(pMedium);
        return s.Write(strShareName);
    }
    else if (cf == m_CFSessionClientName)
    {
        ASSERT( NULL != m_pcookie );
        CString strSessionClientName;
        HRESULT hr = m_pcookie->GetSessionClientName( strSessionClientName );
        if ( FAILED(hr) )
            return hr;
        stream_ptr s(pMedium);
        return s.Write(strSessionClientName);
    }
    else if (cf == m_CFSessionUserName)
    {
        ASSERT( NULL != m_pcookie );
        CString strSessionUserName;
        HRESULT hr = m_pcookie->GetSessionUserName( strSessionUserName );
        if ( FAILED(hr) )
            return hr;
        stream_ptr s(pMedium);
        return s.Write(strSessionUserName);
    }
    else if (cf == m_CFSessionID)
    {
        DWORD dwSessionID = 0;
        HRESULT hr = m_pcookie->GetSessionID( &dwSessionID );
        if ( FAILED(hr) )
            return hr;
        stream_ptr s(pMedium);
        return s.Write(&dwSessionID, sizeof(DWORD));
    }
    else if (cf == m_CFFileID)
    {
        DWORD dwFileID = 0;
        HRESULT hr = m_pcookie->GetFileID( &dwFileID );
        if ( FAILED(hr) )
            return hr;
        stream_ptr s(pMedium);
        return s.Write(&dwFileID, sizeof(DWORD));
    }
    else if (cf == m_CFServiceName)
    {
        ASSERT( NULL != m_pcookie );
        CString strServiceName;
        HRESULT hr = m_pcookie->GetServiceName( strServiceName );
        if ( FAILED(hr) )
            return hr;
        stream_ptr s(pMedium);
        return s.Write(strServiceName);
    }
    else if (cf == m_CFServiceDisplayName)
    {
        ASSERT( NULL != m_pcookie );
        CString strServiceDisplayName;
        HRESULT hr = m_pcookie->GetServiceDisplayName( strServiceDisplayName );
        if ( FAILED(hr) )
            return hr;
        stream_ptr s(pMedium);
        return s.Write(strServiceDisplayName);
    }
    else if (cf == m_CFRawCookie)
    {
        stream_ptr s(pMedium);
        return s.Write((PBYTE)&m_pcookie, sizeof(m_pcookie));
    }
    else if (cf == m_CFSnapinPreloads) // added JonN 01/19/00
    {
        stream_ptr s(pMedium);
        BOOL bPreload = TRUE;
        return s.Write((PBYTE)&bPreload, sizeof(BOOL));
    }

    return DV_E_FORMATETC;

    MFC_CATCH;
}

HRESULT CFileMgmtDataObject::Initialize( CFileMgmtCookie* pcookie,
                                         CFileMgmtComponentData& refComponentData,
                                         DATA_OBJECT_TYPES type )
{
    if (NULL == pcookie)
    {
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }

    m_pComponentData = &refComponentData;
    ((IComponentData*) m_pComponentData)->AddRef ();

    m_objecttype = pcookie->QueryObjectType();
    m_fAllowOverrideMachineName = refComponentData.m_fAllowOverrideMachineName;
#ifdef SNAPIN_PROTOTYPER
    if (m_objecttype != FILEMGMT_PROTOTYPER_LEAF) 
        m_strMachineName = pcookie->QueryTargetServer();
#else
        m_strMachineName = pcookie->QueryTargetServer();
#endif
    m_dataobjecttype = type;
    m_pcookie = pcookie;
    m_pcookie->AddRefCookie();
    VERIFY( SUCCEEDED(refComponentData.GetClassID(&m_SnapInCLSID)) );
    return S_OK;
}


CFileMgmtDataObject::~CFileMgmtDataObject()
{
    FreeMultiSelectObjList();

    if (NULL != m_pcookie)
    {
        m_pcookie->ReleaseCookie();
    }
    if ( m_pComponentData )
        ((IComponentData*) m_pComponentData)->Release ();
}

/////////////////////////////////////////////////////////////////////
//    CFileMgmtDataObject::IDataObject::GetData()
//
//    Write data into the storage medium.
//    The data will be retrieved by the Send Console Message snapin.
//
//
HRESULT CFileMgmtDataObject::GetData(
        FORMATETC __RPC_FAR * pFormatEtcIn,
        STGMEDIUM __RPC_FAR * pMedium)
{
    ASSERT(pFormatEtcIn != NULL);
    ASSERT(pMedium != NULL);

    HRESULT                hResult = S_OK;
    const CLIPFORMAT    cf = pFormatEtcIn->cfFormat;

    if (!m_MultiSelectObjList.empty())
    {
        //
        // This is the multiselect dataobject.
        //
        if (cf == m_CFObjectTypesInMultiSelect)
        {
            //
            // We will provide the list of object types of all the currently selected items here.
            // MMC will use this format to determine extensions snapins
            //
            UINT nMultiSelectedObjects = m_MultiSelectObjList.size();

            // Calculate the size of SMMCObjectTypes.
            int cb = sizeof(DWORD) + sizeof(SMMCObjectTypes) * nMultiSelectedObjects;

            //Fill out parameters
            pMedium->tymed = TYMED_HGLOBAL; 
            pMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, cb);
            if (pMedium->hGlobal == NULL)
                return STG_E_MEDIUMFULL;

            SMMCObjectTypes* pMMCDO = reinterpret_cast<SMMCObjectTypes*>(::GlobalLock(pMedium->hGlobal));
            pMMCDO->count = 0;
            GUID *pMMCDOGuid = pMMCDO->guid;

            for (CDataObjectList::iterator i = m_MultiSelectObjList.begin(); i != m_MultiSelectObjList.end(); i++)
            {
                CCookie* pbasecookie = NULL;
                hResult = ExtractData(*i, CFileMgmtDataObject::m_CFRawCookie, &pbasecookie, sizeof(pbasecookie));
                if (FAILED(hResult))
                    break;

                pbasecookie = m_pComponentData->ActiveBaseCookie( pbasecookie );
                CFileMgmtCookie* pUseThisCookie = dynamic_cast<CFileMgmtCookie*>(pbasecookie);
                FileMgmtObjectType objecttype = pUseThisCookie->QueryObjectType();
                const GUID* pguid = GetObjectTypeGUID(objecttype);
                memcpy(pMMCDOGuid++, pguid, sizeof(GUID));
                pMMCDO->count++;
            }
            ::GlobalUnlock(pMedium->hGlobal);

            if (FAILED(hResult))
            {
                ::GlobalFree(pMedium->hGlobal);
                pMedium->hGlobal = NULL;
            }
        } else
            hResult = DV_E_FORMATETC;
        
        return hResult;
    }

    if (cf == m_cfSendConsoleMessageRecipients)
    {
        ASSERT (m_pComponentData);
        if ( m_pComponentData )
        {

            // I suppose it doesn't matter what type this cookie is because we
            // are just using to hang enumerated session cookies off of, as long
            // as it's not an abstract class.
            BOOL                fContinue = TRUE;
            HRESULT                hr = S_OK;
            CSmbSessionCookie*    pCookie = new CSmbSessionCookie[1];
            if ( pCookie )
            {
                CSmbCookieBlock        cookieBlock (pCookie, 1, (LPCTSTR) m_strMachineName, 0);

                CBaseCookieBlock*    pCookieBlock = 0;

                //
                // JonN 6/28/01 426224
                // Shared Folder: Send Message access denied error title needs to be changed for localization
                //
                AFX_MANAGE_STATE(AfxGetStaticModuleState());    // required for CWaitCursor

                // Enumerate all the session cookies
                for (INT iTransport = FILEMGMT_FIRST_TRANSPORT;
                      fContinue && iTransport < FILEMGMT_NUM_TRANSPORTS;
                      iTransport++ )
                {
                    hr = m_pComponentData->GetFileServiceProvider(iTransport)->EnumerateSessions(
                        NULL, &pCookie[0], false);
                    fContinue = SUCCEEDED(hr);
                }

                // Enumerate all the computer names from the session cookies and store them in
                // the computerList
                CStringList            computerList;
                size_t                len = 0;    // number of WCHARS
                while ( !pCookie[0].m_listResultCookieBlocks.IsEmpty () )
                {
                    pCookieBlock = pCookie[0].m_listResultCookieBlocks.RemoveHead ();
                    ASSERT (pCookieBlock);
                    if ( !pCookieBlock )
                        break;
                    int nCookies = pCookieBlock->QueryNumCookies ();
                    while (nCookies--)
                    {
                        CCookie* pBaseCookie = pCookieBlock->QueryBaseCookie (nCookies);
                        ASSERT (pBaseCookie);
                        if ( pBaseCookie )
                        {
                            CFileMgmtCookie* pFMCookie = dynamic_cast <CFileMgmtCookie*> (pBaseCookie);
                            ASSERT (pFMCookie);
                            if ( pFMCookie )
                            {
                                computerList.AddHead (pFMCookie->QueryResultColumnText (
                                        COLNUM_SESSIONS_COMPUTERNAME, *m_pComponentData));
                                len += computerList.GetHead ().GetLength () + 1; // to account for NULL
                            }
                        }
                    }
                    pCookieBlock->Release ();
                }


                if ( !m_strMachineName.IsEmpty () )
                {
                    computerList.AddHead (m_strMachineName);
                    len += computerList.GetHead ().GetLength () + 1; // to account for NULL
                }

                // Run through all the computer names in computerList and add them to the output buffer
                //
                // Write the list of recipients to the storage medium.
                // - The list of recipients is a group of UNICODE strings
                //     terminated by TWO null characters.c
                // - Allocated memory must include BOTH null characters.
                //
                len += 1;    // to account for extra NULL at end.
                WCHAR*        pgrszRecipients = new WCHAR[len];
                WCHAR*        ptr = pgrszRecipients;
                CString        computerName;

                if ( pgrszRecipients )
                {
                    ::ZeroMemory (pgrszRecipients, len * sizeof (WCHAR));
                    while ( !computerList.IsEmpty () )
                    {
                        computerName = computerList.RemoveHead ();

                        // append computer name
                        wcscpy (ptr, (LPCTSTR) computerName);    

                        // skip past computer name and terminating NULL
                        ptr += computerName.GetLength () + 1;    
                    }

                    // Add the name of this computer

                    HGLOBAL hGlobal = ::GlobalAlloc (GMEM_FIXED, len * sizeof (WCHAR));
                    if ( hGlobal )
                    {
                        memcpy (OUT hGlobal, pgrszRecipients, len * sizeof (WCHAR));
                        pMedium->hGlobal = hGlobal;
                    }
                    else
                        hResult = E_OUTOFMEMORY;

                    delete [] pgrszRecipients;
                }
                else
                    hResult = E_OUTOFMEMORY;

                // pCookie deleted in destructor of cookieBlock
            }
            else
                hResult = E_OUTOFMEMORY;
        }
        else
            hResult = E_UNEXPECTED;
    }
    else if (cf == m_CFIDList)
  {
    LPITEMIDLIST pidl = NULL, pidlR = NULL;

    hResult = m_pcookie->GetSharePIDList( &pidl );

    if (SUCCEEDED(hResult))
    {
      pidlR = ILClone(ILFindLastID(pidl));  // relative IDList
      ILRemoveLastID(pidl);                 // folder IDList

      int  cidl = 1;
      UINT offset = sizeof(CIDA) + sizeof(UINT)*cidl;
      UINT cbFolder = ILGetSize(pidl);
      UINT cbRelative = ILGetSize(pidlR);
      UINT cbTotal = offset + cbFolder + cbRelative;
      
      HGLOBAL hGlobal = ::GlobalAlloc (GPTR, cbTotal);
      if ( hGlobal )
      {
        LPIDA pida = (LPIDA)hGlobal;

        pida->cidl = cidl;
        pida->aoffset[0] = offset;
          MoveMemory(((LPBYTE)hGlobal+offset), pidl, cbFolder);

        offset += cbFolder;
        pida->aoffset[1] = offset;
          MoveMemory(((LPBYTE)hGlobal+offset), pidlR, cbRelative);

        pMedium->hGlobal = hGlobal;
      }
      else
          hResult = E_OUTOFMEMORY;

      // free pidl & pidlR
      if (pidl)
        ILFree(pidl);
      if (pidlR)
        ILFree(pidlR);
    } else
      hResult = DV_E_FORMATETC;
  } else if (cf == m_CFNodeID2)
  {
    if (m_objecttype != FILEMGMT_ROOT &&
        m_objecttype != FILEMGMT_SHARES &&
        m_objecttype != FILEMGMT_SESSIONS &&
        m_objecttype != FILEMGMT_RESOURCES &&
        m_objecttype != FILEMGMT_SERVICES)
    {
        hResult = DV_E_FORMATETC;
    } else
    {
        const BSTR strGUID = GetObjectTypeString( m_objecttype );

        // JonN 12/11/01 502856
        int cbString = (lstrlen(strGUID) + 1) * sizeof(TCHAR);

        pMedium->tymed = TYMED_HGLOBAL; 
        pMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE,
                                         sizeof(SNodeID2) + cbString);
        if (!(pMedium->hGlobal))
        {
            hResult = E_OUTOFMEMORY;
        } else
        {
            SNodeID2 *pNodeID = (SNodeID2 *)GlobalLock(pMedium->hGlobal);
            if (!pNodeID)
            {
                hResult = HRESULT_FROM_WIN32(GetLastError());
                GlobalFree(pMedium->hGlobal);
                pMedium->hGlobal = NULL;
            } else
            {
                pNodeID->dwFlags = 0;
                pNodeID->cBytes = cbString;
                CopyMemory(pNodeID->id, strGUID, cbString);
                GlobalUnlock(pMedium->hGlobal);
            }
        }
    }
  } else
        hResult = DV_E_FORMATETC;    // Invalid/unknown clipboard format

    return hResult;
} // CMyComputerDataObject::GetData()


HRESULT CFileMgmtDataObject::PutDisplayName(STGMEDIUM* pMedium)
    // Writes the "friendly name" to the provided storage medium
    // Returns the result of the write operation
{
    if ( !IsAutonomousObjectType(m_objecttype) )
    {
        ASSERT(FALSE);
        return DV_E_FORMATETC;
    }

    CString strDisplayName;
    BOOL fStaticNode = (   NULL != m_pComponentData
                        && !m_pComponentData->IsExtensionSnapin()
                        && m_pComponentData->QueryRootCookie().QueryObjectType()
                                  == m_objecttype);
    // will only succeed for scope cookies
    m_pcookie->GetDisplayName( strDisplayName, fStaticNode );
    // LoadStringPrintf(nStringId, OUT &strDisplayName, (LPCTSTR)m_strMachineName);
    stream_ptr s(pMedium);
    return s.Write(strDisplayName);
}

void CFileMgmtDataObject::FreeMultiSelectObjList()
{
    if (!m_MultiSelectObjList.empty())
    {
        for (CDataObjectList::iterator i = m_MultiSelectObjList.begin(); i != m_MultiSelectObjList.end(); i++)
        {
            CComObject<CFileMgmtDataObject>* pDataObject = reinterpret_cast<CComObject<CFileMgmtDataObject>*>(*i);
            delete pDataObject;
        }

        m_MultiSelectObjList.clear();
    }
}

HRESULT CFileMgmtDataObject::InitMultiSelectDataObjects(CFileMgmtComponentData& refComponentData)
{
    FreeMultiSelectObjList();

    ASSERT(!m_pComponentData);
    m_pComponentData = &refComponentData;
    ((IComponentData*) m_pComponentData)->AddRef ();

    VERIFY( SUCCEEDED(refComponentData.GetClassID(&m_SnapInCLSID)) );

    return S_OK;
}

HRESULT CFileMgmtDataObject::AddMultiSelectDataObjects(CFileMgmtCookie* pCookie, DATA_OBJECT_TYPES type)
{
    HRESULT hr = S_OK;

    CComObject<CFileMgmtDataObject>* pDataObject = NULL;
    hr = CComObject<CFileMgmtDataObject>::CreateInstance(&pDataObject);

    if (SUCCEEDED(hr))
        hr = pDataObject->Initialize(pCookie, *m_pComponentData, type );

    IDataObject *piDataObject = NULL;
    if (SUCCEEDED(hr))
        hr = pDataObject->QueryInterface(IID_IDataObject, reinterpret_cast<void**>(&piDataObject));

    if (SUCCEEDED(hr))
    {
        m_MultiSelectObjList.push_back(piDataObject);
    } else
    {
        delete pDataObject;
    }

    return hr;
}

// Register the clipboard formats
CLIPFORMAT CFileMgmtDataObject::m_CFSnapinPreloads =
    (CLIPFORMAT)RegisterClipboardFormat(CCF_SNAPIN_PRELOADS);
CLIPFORMAT CFileMgmtDataObject::m_CFDisplayName =
    (CLIPFORMAT)RegisterClipboardFormat(CCF_DISPLAY_NAME);
CLIPFORMAT CFileMgmtDataObject::m_CFNodeID2 =
    (CLIPFORMAT)RegisterClipboardFormat(CCF_NODEID2);
CLIPFORMAT CFileMgmtDataObject::m_CFTransport =
    (CLIPFORMAT)RegisterClipboardFormat(L"FILEMGMT_TRANSPORT");
CLIPFORMAT CFileMgmtDataObject::m_CFMachineName =
    (CLIPFORMAT)RegisterClipboardFormat(L"MMC_SNAPIN_MACHINE_NAME");
CLIPFORMAT CFileMgmtDataObject::m_CFShareName =
    (CLIPFORMAT)RegisterClipboardFormat(L"FILEMGMT_SNAPIN_SHARE_NAME");
CLIPFORMAT CFileMgmtDataObject::m_CFSessionClientName =
    (CLIPFORMAT)RegisterClipboardFormat(L"FILEMGMT_SNAPIN_SESSION_CLIENT_NAME");
CLIPFORMAT CFileMgmtDataObject::m_CFSessionUserName =
    (CLIPFORMAT)RegisterClipboardFormat(L"FILEMGMT_SNAPIN_SESSION_USER_NAME");
CLIPFORMAT CFileMgmtDataObject::m_CFSessionID =
    (CLIPFORMAT)RegisterClipboardFormat(L"FILEMGMT_SNAPIN_SESSION_ID");
CLIPFORMAT CFileMgmtDataObject::m_CFFileID =
    (CLIPFORMAT)RegisterClipboardFormat(L"FILEMGMT_SNAPIN_FILE_ID");
CLIPFORMAT CFileMgmtDataObject::m_CFServiceName =
    (CLIPFORMAT)RegisterClipboardFormat(L"FILEMGMT_SNAPIN_SERVICE_NAME");
CLIPFORMAT CFileMgmtDataObject::m_CFServiceDisplayName =
    (CLIPFORMAT)RegisterClipboardFormat(L"FILEMGMT_SNAPIN_SERVICE_DISPLAYNAME");
CLIPFORMAT CDataObject::m_CFRawCookie =
    (CLIPFORMAT)RegisterClipboardFormat(L"FILEMGMT_SNAPIN_RAW_COOKIE");

//    Additional clipboard formats for the Send Console Message snapin
CLIPFORMAT CFileMgmtDataObject::m_cfSendConsoleMessageRecipients = 
    (CLIPFORMAT)RegisterClipboardFormat(_T("mmc.sendcmsg.MessageRecipients"));

//    Additional clipboard formats for the Security Page
CLIPFORMAT CFileMgmtDataObject::m_CFIDList = 
    (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);

CLIPFORMAT CFileMgmtDataObject::m_CFObjectTypesInMultiSelect = 
    (CLIPFORMAT)RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);
CLIPFORMAT CFileMgmtDataObject::m_CFMultiSelectDataObject = 
    (CLIPFORMAT)RegisterClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT);
CLIPFORMAT CFileMgmtDataObject::m_CFMultiSelectSnapins = 
    (CLIPFORMAT)RegisterClipboardFormat(CCF_MULTI_SELECT_SNAPINS);

CLIPFORMAT CFileMgmtDataObject::m_CFInternal = 
    (CLIPFORMAT)RegisterClipboardFormat(L"FILEMGMT_SNAPIN_INTERNAL");

STDMETHODIMP CFileMgmtComponentData::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    MFC_TRY;

    // WARNING cookie cast
    CCookie* pbasecookie = reinterpret_cast<CCookie*>(cookie);
    CFileMgmtCookie* pUseThisCookie = ActiveCookie((CFileMgmtCookie*)pbasecookie);
    ASSERT( IsValidObjectType(pUseThisCookie->QueryObjectType()) );

    CComObject<CFileMgmtDataObject>* pDataObject = NULL;
    HRESULT hRes = CComObject<CFileMgmtDataObject>::CreateInstance(&pDataObject);
    if ( FAILED(hRes) )
        return hRes;

    HRESULT hr = pDataObject->Initialize( pUseThisCookie, *this, type );
    if ( SUCCEEDED(hr) )
    {
        hr = pDataObject->QueryInterface(IID_IDataObject,
                                         reinterpret_cast<void**>(ppDataObject));
    }
    if ( FAILED(hr) )
    {
        delete pDataObject;
        return hr;
    }

    return hr;

    MFC_CATCH;
}


/////////////////////////////////////////////////////////////////////
//    FileMgmtObjectTypeFromIDataObject()
//
//    Find the objecttype of a IDataObject pointer.  The purpose
//    of this routine is to combine ExtractObjectTypeGUID() and
//    CheckObjectTypeGUID() into a single function.
//
//    Return the FILEMGMT_* node type (enum FileMgmtObjectType).
//
//    HISTORY
//    30-Jul-97    t-danm        Creation.
//
FileMgmtObjectType
FileMgmtObjectTypeFromIDataObject(IN LPDATAOBJECT lpDataObject)
{
    ASSERT(lpDataObject != NULL);
    GUID guidObjectType = GUID_NULL; // JonN 11/21/00 PREFIX 226042
    HRESULT hr = ExtractObjectTypeGUID( IN lpDataObject, OUT &guidObjectType );
    ASSERT( SUCCEEDED(hr) );
    return (FileMgmtObjectType)CheckObjectTypeGUID(IN &guidObjectType );
} // FileMgmtObjectTypeFromIDataObject()


HRESULT ExtractBaseCookie(
    IN LPDATAOBJECT piDataObject,
    OUT CCookie** ppcookie,
    OUT FileMgmtObjectType* pobjecttype )
{
    HRESULT hr = ExtractData( piDataObject,
                              CFileMgmtDataObject::m_CFRawCookie,
                              (PBYTE)ppcookie,
                              sizeof(CCookie*) );
    if ( SUCCEEDED(hr) && NULL != pobjecttype )
    {
        *pobjecttype = FileMgmtObjectTypeFromIDataObject(piDataObject);
    }
    return hr;
}

BOOL IsMultiSelectObject(LPDATAOBJECT piDataObject)
{
    BOOL bMultiSelectObject = FALSE;

    if (piDataObject)
    {
        //
        // return TRUE if piDataObject is the composite data object (MMC_MS_DO) created by MMC.
        //
        STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL, NULL};
        FORMATETC formatetc = {CFileMgmtDataObject::m_CFMultiSelectDataObject,
                                NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        HRESULT hr = piDataObject->GetData(&formatetc, &stgmedium);
        if (S_OK == hr && stgmedium.hGlobal)
        {
            DWORD* pdwData = reinterpret_cast<DWORD*>(::GlobalLock(stgmedium.hGlobal));
            bMultiSelectObject = (1 == *pdwData);
            ::GlobalUnlock(stgmedium.hGlobal);
            ::GlobalFree(stgmedium.hGlobal);
        }
    }

    return bMultiSelectObject;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\dataobj.h ===
// DataObj.h : Declaration of the data object classes

#ifndef __DATAOBJ_H_INCLUDED__
#define __DATAOBJ_H_INCLUDED__

#include "cookie.h" // FILEMGMT_TRANSPORT
#include "stddtobj.h" // class DataObject

#include <list>
using namespace std;

typedef list<LPDATAOBJECT> CDataObjectList;

class CFileMgmtDataObject : public CDataObject
{
    DECLARE_NOT_AGGREGATABLE(CFileMgmtDataObject)

public:

// debug refcount
#if DBG==1
    ULONG InternalAddRef()
    {
        TRACE2( "DataObj 0x%xd AddRef (%d)\n", (DWORD)this, m_dwRef ); return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        TRACE2( "DataObj 0x%xd Release (%d)\n", (DWORD)this, m_dwRef );return CComObjectRoot::InternalRelease();
    }
    int dbg_InstID;
#endif // DBG==1

    CFileMgmtDataObject()
        : m_pComponentData(0), m_pcookie(NULL)
    {
    }

    ~CFileMgmtDataObject();

    virtual HRESULT Initialize( CFileMgmtCookie* pcookie,
                                CFileMgmtComponentData& refComponentData,
                                DATA_OBJECT_TYPES type );

    // IDataObject interface implementation
    HRESULT STDMETHODCALLTYPE GetDataHere(
        FORMATETC __RPC_FAR *pFormatEtcIn,
        STGMEDIUM __RPC_FAR *pMedium);

    HRESULT PutDisplayName(STGMEDIUM* pMedium);
    HRESULT PutServiceName(STGMEDIUM* pMedium);

    HRESULT STDMETHODCALLTYPE GetData(
        FORMATETC __RPC_FAR *pFormatEtcIn,
        STGMEDIUM __RPC_FAR *pMedium);

    void FreeMultiSelectObjList();
    HRESULT InitMultiSelectDataObjects(CFileMgmtComponentData& refComponentData);
    HRESULT AddMultiSelectDataObjects(CFileMgmtCookie* pCookie, DATA_OBJECT_TYPES type);
    CDataObjectList* GetMultiSelectObjList() { return &m_MultiSelectObjList; }

protected:
    CDataObjectList m_MultiSelectObjList;
    CFileMgmtCookie* m_pcookie; // the CCookieBlock is AddRef'ed for the life of the DataObject
    CString m_strMachineName; // CODEWORK should not be necessary
    FileMgmtObjectType m_objecttype; // CODEWORK should not be necessary
    DATA_OBJECT_TYPES m_dataobjecttype;
    GUID m_SnapInCLSID;
    BOOL m_fAllowOverrideMachineName;    // From CFileMgmtComponentData

public:
    // Clipboard formats
    static CLIPFORMAT m_CFSnapinPreloads;    // added JonN 01/19/00
    static CLIPFORMAT m_CFDisplayName;
    static CLIPFORMAT m_CFNodeID2;
    static CLIPFORMAT m_CFTransport;
    static CLIPFORMAT m_CFMachineName;
    static CLIPFORMAT m_CFShareName;
    static CLIPFORMAT m_CFSessionClientName; // only for SMB
    static CLIPFORMAT m_CFSessionUserName;   // only for SMB
    static CLIPFORMAT m_CFSessionID;         // only for SFM
    static CLIPFORMAT m_CFFileID;
    static CLIPFORMAT m_CFServiceName;
    static CLIPFORMAT m_CFServiceDisplayName;
    static CLIPFORMAT m_cfSendConsoleMessageRecipients;
    static CLIPFORMAT m_CFIDList;            // only for SMB
    static CLIPFORMAT m_CFObjectTypesInMultiSelect;
    static CLIPFORMAT m_CFMultiSelectDataObject;
    static CLIPFORMAT m_CFMultiSelectSnapins;
    static CLIPFORMAT m_CFInternal;
private:
    CFileMgmtComponentData* m_pComponentData;
};


FileMgmtObjectType FileMgmtObjectTypeFromIDataObject(IN LPDATAOBJECT lpDataObject);

//
// I recommend passing a non-NULL pobjecttype, to make sure that the
// type of the cookie is valid
//
HRESULT ExtractBaseCookie(
    LPDATAOBJECT piDataObject,
    CCookie** ppcookie,
    FileMgmtObjectType* pobjecttype = NULL );

BOOL IsMultiSelectObject(LPDATAOBJECT piDataObject);

#endif // ~__DATAOBJ_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\filemgmt.cpp ===
// filemgmt.cpp : Implementation of DLL Exports.

// To fully complete this project follow these steps

// You will need the new MIDL compiler to build this project.  Additionally,
// if you are building the proxy stub DLL, you will need new headers and libs.

// 1) Add a custom build step to filemgmt.idl
//		You can select all of the .IDL files by holding Ctrl and clicking on
//		each of them.
//
//		Description
//			Running MIDL
//		Build Command(s)
//			midl filemgmt.idl
//		Outputs
//			filemgmt.tlb
//			filemgmt.h
//			mmcfmgm_i.c
//
// NOTE: You must use the MIDL compiler from NT 4.0,
// preferably 3.00.15 or greater

// 2) Add a custom build step to the project to register the DLL
//		For this, you can select all projects at once
//		Description
//			Registering OLE Server...
//		Build Command(s)
//			regsvr32 /s /c "$(TargetPath)"
//			echo regsvr32 exec. time > "$(OutDir)\regsvr32.trg"
//		Outputs
//			$(OutDir)\regsvr32.trg

// 3) To add UNICODE support, follow these steps
//		Select Build|Configurations...
//		Press Add...
//		Change the configuration name to Unicode Release
//		Change the "Copy Settings From" combo to filemgmt - Win32 Release
//		Press OK
//		Press Add...
//		Change the configuration name to Unicode Debug
//		Change the "Copy Settings From" combo to filemgmt - Win32 Debug
//		Press OK
//		Press "Close"
//		Select Build|Settings...
//		Select the two UNICODE projects and press the C++ tab.
//		Select the "General" category
//		Add _UNICODE to the Preprocessor definitions
//		Select the Unicode Debug project
//		Press the "General" tab
//		Specify DebugU for the intermediate and output directories
//		Select the Unicode Release project
//		Press the "General" tab
//		Specify ReleaseU for the intermediate and output directories

// 4) Proxy stub DLL
//		To build a separate proxy/stub DLL,
//		run nmake -f ps.mak in the project directory.

#include "stdafx.h"
#include "initguid.h"
#include "filemgmt.h"
#include "cmponent.h"
#include "compdata.h"
#include "macros.h"   // MFC_TRY/MFC_CATCH
#include "regkey.h"   // AMC::CRegKey
#include "strings.h"  // SNAPINS_KEY etc.
#include "guidhelp.h" // GuidToCString

#include <compuuid.h> // UUIDs for Computer Management
#include "about.h"
#include "snapreg.h" // RegisterSnapin

USE_HANDLE_MACROS("FILEMGMT(filemgmt.cpp)")                                        \

const CLSID CLSID_FileServiceManagement =       {0x58221C65,0xEA27,0x11CF,{0xAD,0xCF,0x00,0xAA,0x00,0xA8,0x00,0x33}};
const CLSID CLSID_SystemServiceManagement =     {0x58221C66,0xEA27,0x11CF,{0xAD,0xCF,0x00,0xAA,0x00,0xA8,0x00,0x33}};
const CLSID CLSID_FileServiceManagementExt =    {0x58221C69,0xEA27,0x11CF,{0xAD,0xCF,0x00,0xAA,0x00,0xA8,0x00,0x33}};
const CLSID CLSID_SystemServiceManagementExt =  {0x58221C6a,0xEA27,0x11CF,{0xAD,0xCF,0x00,0xAA,0x00,0xA8,0x00,0x33}};
const CLSID CLSID_FileServiceManagementAbout =  {0xDB5D1FF4,0x09D7,0x11D1,{0xBB,0x10,0x00,0xC0,0x4F,0xC9,0xA3,0xA3}};
const CLSID CLSID_SystemServiceManagementAbout ={0xDB5D1FF5,0x09D7,0x11D1,{0xBB,0x10,0x00,0xC0,0x4F,0xC9,0xA3,0xA3}};
#ifdef SNAPIN_PROTOTYPER
const CLSID CLSID_SnapinPrototyper = {0xab17ce10,0x9b30,0x11d0,{0xb6, 0xa6, 0x00, 0xaa, 0x00, 0x6e, 0xb9, 0x5b}};
#endif

CComModule _Module;
HINSTANCE g_hInstanceSave;  // Instance handle of the DLL

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_FileServiceManagement, CFileSvcMgmtSnapin)
	OBJECT_ENTRY(CLSID_SystemServiceManagement, CServiceMgmtSnapin)
	OBJECT_ENTRY(CLSID_FileServiceManagementExt, CFileSvcMgmtExtension)
	OBJECT_ENTRY(CLSID_SystemServiceManagementExt, CServiceMgmtExtension)
	OBJECT_ENTRY(CLSID_FileServiceManagementAbout, CFileSvcMgmtAbout)
	OBJECT_ENTRY(CLSID_SystemServiceManagementAbout, CServiceMgmtAbout)
	OBJECT_ENTRY(CLSID_SvcMgmt, CStartStopHelper)
#ifdef SNAPIN_PROTOTYPER
	OBJECT_ENTRY(CLSID_SnapinPrototyper, CServiceMgmtSnapin)
#endif
END_OBJECT_MAP()

class CFileServiceMgmtApp : public CWinApp
{
public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
};

CFileServiceMgmtApp theApp;

BOOL CFileServiceMgmtApp::InitInstance()
{
	_Module.Init(ObjectMap, m_hInstance);
	SHFusionInitializeFromModuleID (m_hInstance, 2);
	VERIFY( SUCCEEDED(CFileMgmtComponent::LoadStrings()) );
	g_hInstanceSave = AfxGetInstanceHandle();
	return CWinApp::InitInstance();
}

int CFileServiceMgmtApp::ExitInstance()
{
	SHFusionUninitialize();

	_Module.Term();
	return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (AfxDllCanUnloadNow() && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	MFC_TRY;

	HRESULT hr = S_OK;
	// registers object, there is no typelib
	hr = _Module.RegisterServer(FALSE);
	if ( FAILED(hr) )
	{
		ASSERT(FALSE && "_Module.RegisterServer(TRUE) failure.");
		return SELFREG_E_CLASS;
	}

	CString strFileMgmtCLSID, strSvcMgmtCLSID;
	CString strFileMgmtExtCLSID, strSvcMgmtExtCLSID;
	CString strFileMgmtAboutCLSID, strSvcMgmtAboutCLSID;
	if (   FAILED(hr = GuidToCString( &strFileMgmtCLSID, CLSID_FileServiceManagement ))
	    || FAILED(hr = GuidToCString( &strSvcMgmtCLSID, CLSID_SystemServiceManagement ))
	    || FAILED(hr = GuidToCString( &strFileMgmtExtCLSID, CLSID_FileServiceManagementExt ))
	    || FAILED(hr = GuidToCString( &strSvcMgmtExtCLSID, CLSID_SystemServiceManagementExt ))
	    || FAILED(hr = GuidToCString( &strFileMgmtAboutCLSID, CLSID_FileServiceManagementAbout ))
	    || FAILED(hr = GuidToCString( &strSvcMgmtAboutCLSID, CLSID_SystemServiceManagementAbout ))
	   )
	{
		ASSERT(FALSE && "GuidToCString() failure");
		return SELFREG_E_CLASS;
	}


	try
	{
		AMC::CRegKey regkeySnapins;
		BOOL fFound = regkeySnapins.OpenKeyEx( HKEY_LOCAL_MACHINE, SNAPINS_KEY );
		if ( !fFound )
		{
			ASSERT(FALSE && "DllRegisterServer() - Unable to open key from registry.");
			return SELFREG_E_CLASS;
		}

		static int filemgmt_types[7] = 
			{ FILEMGMT_ROOT,
			  FILEMGMT_SHARES,
			  FILEMGMT_SESSIONS,
			  FILEMGMT_RESOURCES,
			  FILEMGMT_SHARE,
			  FILEMGMT_SESSION,
			  FILEMGMT_RESOURCE };
		hr = RegisterSnapin( regkeySnapins,
		                     strFileMgmtCLSID,
		                     g_aNodetypeGuids[FILEMGMT_ROOT].bstr,
		                     IDS_REGISTER_FILEMGMT,
		                     IDS_SNAPINABOUT_PROVIDER,
		                     IDS_SNAPINABOUT_VERSION,
		                     true,
		                     strFileMgmtAboutCLSID,
		                     filemgmt_types,
		                     7 );
		if ( FAILED(hr) )
		{
			ASSERT(FALSE);
			return SELFREG_E_CLASS;
		}
		static int svcmgmt_types[2] = 
			{ FILEMGMT_SERVICES,
			  FILEMGMT_SERVICE };
		hr = RegisterSnapin( regkeySnapins,
		                     strSvcMgmtCLSID,
		                     g_aNodetypeGuids[FILEMGMT_SERVICES].bstr,
		                     IDS_REGISTER_SVCMGMT,
		                     IDS_SNAPINABOUT_PROVIDER,
		                     IDS_SNAPINABOUT_VERSION,
		                     true,
		                     strSvcMgmtAboutCLSID,
		                     svcmgmt_types,
		                     2 );
		if ( FAILED(hr) )
		{
			ASSERT(FALSE);
			return SELFREG_E_CLASS;
		}
		static int filemgmtext_types[7] = 
			{ FILEMGMT_ROOT,
                          FILEMGMT_SHARES,
			  FILEMGMT_SESSIONS,
			  FILEMGMT_RESOURCES,
			  FILEMGMT_SHARE,
			  FILEMGMT_SESSION,
			  FILEMGMT_RESOURCE };
		hr = RegisterSnapin( regkeySnapins,
		                     strFileMgmtExtCLSID,
		                     NULL, // no primary nodetype
		                     IDS_REGISTER_FILEMGMT_EXT,
		                     IDS_SNAPINABOUT_PROVIDER,
		                     IDS_SNAPINABOUT_VERSION,
		                     false,
		                     // JonN 11/11/98 changed to use same About handler
		                     strFileMgmtAboutCLSID,
		                     filemgmtext_types,
		                     7 );
		if ( FAILED(hr) )
		{
			ASSERT(FALSE);
			return SELFREG_E_CLASS;
		}
		static int svcmgmtext_types[2] = 
			{ FILEMGMT_SERVICES,
			  FILEMGMT_SERVICE };
		hr = RegisterSnapin( regkeySnapins,
		                     strSvcMgmtExtCLSID,
		                     NULL, // no primary nodetype
		                     IDS_REGISTER_SVCMGMT_EXT,
		                     IDS_SNAPINABOUT_PROVIDER,
		                     IDS_SNAPINABOUT_VERSION,
		                     false,
		                     // JonN 11/11/98 changed to use same About handler
		                     strSvcMgmtAboutCLSID,
		                     svcmgmtext_types,
		                     2 );
		if ( FAILED(hr) )
		{
			ASSERT(FALSE);
			return SELFREG_E_CLASS;
		}

		CString strFileExt, strSystemExt, strDefaultViewExt;
		if (   !strFileExt.LoadString(IDS_REGISTER_FILEMGMT_EXT)
		    || !strSystemExt.LoadString(IDS_REGISTER_SVCMGMT_EXT)
		    || !strDefaultViewExt.LoadString(IDS_REGISTER_DEFAULT_VIEW_EXT)
		   )
		{
			ASSERT(FALSE);
			return SELFREG_E_CLASS;
		}
		AMC::CRegKey regkeyNodeTypes;
		fFound = regkeyNodeTypes.OpenKeyEx( HKEY_LOCAL_MACHINE, NODE_TYPES_KEY );
		if ( !fFound )
		{
			ASSERT(FALSE);
			return SELFREG_E_CLASS;
		}
		AMC::CRegKey regkeyNodeType;
		for (int i = FILEMGMT_ROOT; i < FILEMGMT_NUMTYPES; i++)
		{
			regkeyNodeType.CreateKeyEx( regkeyNodeTypes, g_aNodetypeGuids[i].bstr );
			regkeyNodeType.CloseKey();
		}

		regkeyNodeType.CreateKeyEx( regkeyNodeTypes, TEXT(struuidNodetypeSystemTools) );
		{
			AMC::CRegKey regkeyExtensions;
			regkeyExtensions.CreateKeyEx( regkeyNodeType, g_szExtensions );
			AMC::CRegKey regkeyNameSpace;
			regkeyNameSpace.CreateKeyEx( regkeyExtensions, g_szNameSpace );
			regkeyNameSpace.SetString( strFileMgmtExtCLSID, strFileExt );
			// JonN 5/27/99 deregister as extension of System Tools
			// ignore errors
			(void)::RegDeleteValue(regkeyNameSpace, strSvcMgmtExtCLSID);
		}
		regkeyNodeType.CloseKey();

		// JonN 5/27/99 register as extension of Server Apps
		regkeyNodeType.CreateKeyEx( regkeyNodeTypes, TEXT(struuidNodetypeServerApps) );
		{
			AMC::CRegKey regkeyExtensions;
			regkeyExtensions.CreateKeyEx( regkeyNodeType, g_szExtensions );
			AMC::CRegKey regkeyNameSpace;
			regkeyNameSpace.CreateKeyEx( regkeyExtensions, g_szNameSpace );
			(void)::RegDeleteValue(regkeyNameSpace, strFileMgmtExtCLSID);
			regkeyNameSpace.SetString( strSvcMgmtExtCLSID, strSystemExt );
		}
		regkeyNodeType.CloseKey();

		// JonN 5/16/00 register Default View Extension under Services node
		regkeyNodeType.CreateKeyEx( regkeyNodeTypes, TEXT(struuidNodetypeServices) );
		{
			AMC::CRegKey regkeyExtensions;
			regkeyExtensions.CreateKeyEx( regkeyNodeType, g_szExtensions );
			AMC::CRegKey regkeyView;
			regkeyView.CreateKeyEx( regkeyExtensions, L"View" );
			regkeyView.SetString( L"{B708457E-DB61-4C55-A92F-0D4B5E9B1224}",
			                      strDefaultViewExt );
		}
		regkeyNodeType.CloseKey();

	}
	catch (COleException* e)
	{
		ASSERT(FALSE);
		e->Delete();
		return SELFREG_E_CLASS;
	}

	return hr;

	MFC_CATCH;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Adds entries to the system registry

STDAPI DllUnregisterServer(void)
{
	HRESULT hRes = S_OK;
	_Module.UnregisterServer();

	// CODEWORK need to unregister properly

	return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\filesvc.cpp ===
// FileSvc.cpp : File Service provider base class

#include "stdafx.h"
#include "safetemp.h"
#include "FileSvc.h"
#include "compdata.h" // CFileMgmtComponentData::DoPopup

#include "macros.h"
USE_HANDLE_MACROS("FILEMGMT(FileSvc.cpp)")

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

FileServiceProvider::FileServiceProvider(CFileMgmtComponentData* pFileMgmtData)
: m_pFileMgmtData( pFileMgmtData )
{
  ASSERT( m_pFileMgmtData != NULL );
}

FileServiceProvider::~FileServiceProvider()
{
}

//+-------------------------------------------------------------------------
//
//  Function:   AddPageProc
//
//  Synopsis:   The IShellPropSheetExt->AddPages callback.
//
//--------------------------------------------------------------------------
BOOL CALLBACK
AddPageProc(HPROPSHEETPAGE hPage, LPARAM pCallBack)
{
  HRESULT hr = ((LPPROPERTYSHEETCALLBACK)pCallBack)->AddPage(hPage);

  return (hr == S_OK);
}

// Security Shell extension CLSID - {1F2E5C40-9550-11CE-99D2-00AA006E086C}
const CLSID CLSID_ShellExtSecurity =
 {0x1F2E5C40, 0x9550, 0x11CE, {0x99, 0xD2, 0x0, 0xAA, 0x0, 0x6E, 0x08, 0x6C}};

HRESULT
FileServiceProvider::CreateFolderSecurityPropPage(
    LPPROPERTYSHEETCALLBACK pCallBack,
    LPDATAOBJECT pDataObject
)
{
  //
  // add the file system security page
  //
  CComPtr<IShellExtInit> spShlInit;
  HRESULT hr = CoCreateInstance(CLSID_ShellExtSecurity, 
                        NULL, 
                        CLSCTX_INPROC_SERVER,
                        IID_IShellExtInit, 
                        (void **)&spShlInit);
  if (SUCCEEDED(hr))
  {
    hr = spShlInit->Initialize(NULL, pDataObject, 0);
    if (SUCCEEDED(hr))
    {
      CComPtr<IShellPropSheetExt>  spSPSE;
      hr = spShlInit->QueryInterface(IID_IShellPropSheetExt, (void **)&spSPSE);
      if (SUCCEEDED(hr))
        hr = spSPSE->AddPages(AddPageProc, (LPARAM)pCallBack);
    }
  }

  return hr;
}

INT FileServiceProvider::DoPopup(
          INT nResourceID,
          DWORD dwErrorNumber,
          LPCTSTR pszInsertionString,
          UINT fuStyle )
{
  return m_pFileMgmtData->DoPopup( nResourceID, dwErrorNumber, pszInsertionString, fuStyle );
}

//
// These methods cover the seperate API to determine whether share type is admin specific
// By default, SFM have no admin specific shares.
//
DWORD FileServiceProvider::ReadShareType(
    LPCTSTR /*ptchServerName*/,
    LPCTSTR /*ptchShareName*/,
    DWORD* pdwShareType )
{
  ASSERT(pdwShareType);
  *pdwShareType = 0;
  return NERR_Success;
}

//
// These methods cover the seperate API to determine whether IntelliMirror
// caching is enabled.  By default, SFM they are disabled.
//
DWORD FileServiceProvider::ReadShareFlags(
    LPCTSTR /*ptchServerName*/,
    LPCTSTR /*ptchShareName*/,
    DWORD* /*pdwFlags*/ )
{
  return NERR_InvalidAPI; // caught by CSharePageGeneralSMB::Load()
}

DWORD FileServiceProvider::WriteShareFlags(
    LPCTSTR /*ptchServerName*/,
    LPCTSTR /*ptchShareName*/,
    DWORD /*dwFlags*/ )
{
  ASSERT( FALSE ); // why was this called?
  return NERR_Success;
}

BOOL FileServiceProvider::GetCachedFlag( DWORD /*dwFlags*/, DWORD /*dwFlagToCheck*/ )
{
  ASSERT(FALSE);
  return FALSE;
}

VOID FileServiceProvider::SetCachedFlag( DWORD* /*pdwFlags*/, DWORD /*dwNewFlag*/ )
{
  ASSERT(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\mvedit.cpp ===
//
// mvEdit.cpp : implementation file for multi-valued string edit dialog
//

#include "stdafx.h"
#include "mvedit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMultiValuedStringEdit dialog

/*CMultiValuedStringEdit::CMultiValuedStringEdit(CWnd* pParent)
    : CDialog(CMultiValuedStringEdit::IDD, pParent)
{
    m_nDlgTitle = 0;
    m_nText = 0;
}
*/
CMultiValuedStringEdit::CMultiValuedStringEdit(CWnd* pParent, int nDlgTitle, int nText, UINT uiStringLengthLimit)
    : CDialog(CMultiValuedStringEdit::IDD, pParent)
{
    m_nDlgTitle = nDlgTitle;
    m_nText = nText;
    m_uiStringLengthLimit = ((0 == uiStringLengthLimit || MAX_PATH <= uiStringLengthLimit) ? (MAX_PATH - 1) : uiStringLengthLimit);
}

BEGIN_MESSAGE_MAP(CMultiValuedStringEdit, CDialog)
    //{{AFX_MSG_MAP(CMultiValuedStringEdit)
    ON_BN_CLICKED(IDC_MVSTRINGEDIT_ADD, OnAdd)
    ON_BN_CLICKED(IDC_MVSTRINGEDIT_REMOVE, OnRemove)
    ON_EN_CHANGE(IDC_MVSTRINGEDIT_STRING, OnString)
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_MVSTRINGEDIT_LIST, OnList)
    ON_MESSAGE(WM_HELP, OnHelp)
    ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CMultiValuedStringEdit::OnInitDialog() 
{
    CDialog::OnInitDialog();

    if (m_nDlgTitle)
    {
        CString strDlgTitle;
        strDlgTitle.LoadString(m_nDlgTitle);
        SetWindowText(strDlgTitle);
    }

    if (m_nText)
    {
        CString strText;
        strText.LoadString(m_nText);
        SetDlgItemText(IDC_MVSTRINGEDIT_TEXT, strText);
    }

    SendDlgItemMessage(IDC_MVSTRINGEDIT_STRING, EM_LIMITTEXT, m_uiStringLengthLimit, 0);

    HWND    hwnd = GetDlgItem(IDC_MVSTRINGEDIT_LIST)->GetSafeHwnd();
    RECT    rect = {0};
    ::GetWindowRect(hwnd, &rect);
    int nControlWidth = rect.right - rect.left;
    int nVScrollbarWidth = GetSystemMetrics(SM_CXVSCROLL);
    int nBorderWidth = GetSystemMetrics(SM_CXBORDER);
    int nControlNetWidth = nControlWidth - 4 * nBorderWidth;

    LVCOLUMN  lvColumn = {0};
    lvColumn.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    lvColumn.iSubItem = 0;
    lvColumn.cx = nControlNetWidth;
    ListView_InsertColumn(hwnd, 0, &lvColumn);

    GetDlgItem(IDC_MVSTRINGEDIT_ADD)->EnableWindow(FALSE);
    GetDlgItem(IDC_MVSTRINGEDIT_REMOVE)->EnableWindow(FALSE);

    if (m_strValues.IsEmpty())
        return TRUE;

    CString strToken;
    int     nIndex = 0;
    mystrtok(m_strValues, &nIndex, m_strSeparators, strToken);
    while (!strToken.IsEmpty())
    {
        strToken.TrimLeft();
        strToken.TrimRight();
        strToken.MakeLower();

        LVITEM  lvItem = {0};
        lvItem.mask = LVIF_TEXT;
        lvItem.pszText = (LPTSTR)(LPCTSTR)strToken;
        ListView_InsertItem(hwnd, &lvItem);

        mystrtok(m_strValues, &nIndex, m_strSeparators, strToken);
    }

    return TRUE;
}

void CMultiValuedStringEdit::OnAdd() 
{
    CString str;
    GetDlgItemText(IDC_MVSTRINGEDIT_STRING, str);
    str.TrimLeft();
    str.TrimRight();

    if (!str.IsEmpty())
    {
        str.MakeLower();

        if (!_tcschr(str, *m_strSeparators))
        {
            LVFINDINFO lvInfo = {0};
            lvInfo.flags = LVFI_STRING;
            lvInfo.psz = str;

            HWND hwnd = GetDlgItem(IDC_MVSTRINGEDIT_LIST)->GetSafeHwnd();
            if (-1 == ListView_FindItem(hwnd, -1, &lvInfo))
            {
                LVITEM  lvItem = {0};
                lvItem.mask = LVIF_TEXT;
                lvItem.pszText = (LPTSTR)(LPCTSTR)str;
                ListView_InsertItem(hwnd, &lvItem);
            }
            SetDlgItemText(IDC_MVSTRINGEDIT_STRING, _T(""));
        } else
        {
            DoErrMsgBox(m_hWnd, MB_OK, 0, IDS_MVSTRINGEDIT_STRING_INVALID, m_strSeparators);
        }
    }

    GetDlgItem(IDC_MVSTRINGEDIT_STRING)->SetFocus();

}

void CMultiValuedStringEdit::OnRemove() 
{
    HWND hwnd = GetDlgItem(IDC_MVSTRINGEDIT_LIST)->GetSafeHwnd();
    int nIndex = -1;
    while (-1 != (nIndex = ListView_GetNextItem(hwnd, -1, LVNI_SELECTED)))
        ListView_DeleteItem(hwnd, nIndex);
}

void CMultiValuedStringEdit::OnString() 
{
    int nLen = GetDlgItem(IDC_MVSTRINGEDIT_STRING)->GetWindowTextLength();
    GetDlgItem(IDC_MVSTRINGEDIT_ADD)->EnableWindow(0 < nLen);
}

void CMultiValuedStringEdit::OnList(NMHDR* /*pNMHDR*/, LRESULT* pResult)
{
    HWND hwnd = GetDlgItem(IDC_MVSTRINGEDIT_LIST)->GetSafeHwnd();
    int nCount = ListView_GetSelectedCount(hwnd);
    GetDlgItem(IDC_MVSTRINGEDIT_REMOVE)->EnableWindow(nCount >= 1);

    *pResult = 0;
}

BOOL CMultiValuedStringEdit::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
    return DoHelp(lParam, HELP_DIALOG_TOPIC(IDD_MVSTRINGEDIT));
}

BOOL CMultiValuedStringEdit::OnContextHelp(WPARAM wParam, LPARAM /*lParam*/)
{
    return DoContextHelp(wParam, HELP_DIALOG_TOPIC(IDD_MVSTRINGEDIT));
}

void CMultiValuedStringEdit::OnOK() 
{
    m_strValues.Empty();

    HRESULT   hr = S_OK;

    HWND hwnd = GetDlgItem(IDC_MVSTRINGEDIT_LIST)->GetSafeHwnd();
    if (0 < ListView_GetItemCount(hwnd))
    {
        PTSTR pszText = (PTSTR)calloc(m_uiStringLengthLimit+1, sizeof(TCHAR));
        if (pszText)
        {
            int nIndex = -1;
            while (-1 != (nIndex = ListView_GetNextItem(hwnd, nIndex, LVNI_ALL)))
            {
                ListView_GetItemText(hwnd, nIndex, 0, pszText, m_uiStringLengthLimit+1);

                if (m_strValues.IsEmpty())
                {
                    m_strValues = pszText;
                    if (!m_strValues) { hr = E_OUTOFMEMORY; break; }
                } else
                {
                    m_strValues += m_strSeparators;
                    if (!m_strValues) { hr = E_OUTOFMEMORY; break; }
                    m_strValues += pszText;
                    if (!m_strValues) { hr = E_OUTOFMEMORY; break; }
                }
            }
            free(pszText);
        } else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (FAILED(hr))
        DoErrMsgBox(m_hWnd, MB_OK, hr);
    else
        EndDialog(IDOK);
}

HRESULT CMultiValuedStringEdit::put_Strings(
    IN LPCTSTR      i_pszValues, 
    IN LPCTSTR      i_pszSeparators
    )
{
    if (!i_pszSeparators || 1 != lstrlen(i_pszSeparators))
        return E_INVALIDARG;

    m_strValues = i_pszValues;
    m_strSeparators = i_pszSeparators;

    m_strValues.MakeLower();
    m_strSeparators.MakeLower();

    return S_OK;
}


HRESULT CMultiValuedStringEdit::get_Strings
(
  CString& o_strValues
)
{
    o_strValues = m_strValues;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Helper routine to invoke the dialog.
//
// S_OK: io_str contains the new string
// S_FALSE: dlg cancelled, or string unchanged
// others: error occurred and reported
//
HRESULT InvokeMultiValuedStringEditDlg(
    IN CWnd*    i_pParent,
    IN CString& io_str,
    IN LPCTSTR  i_pszSeparators,
    IN int      i_nDlgTitle,
    IN int      i_nText,
    IN UINT    i_uiStringLengthLimit
    )
{

    CMultiValuedStringEdit editDlg(i_pParent, i_nDlgTitle, i_nText, i_uiStringLengthLimit);
    
    HRESULT hr = editDlg.put_Strings(io_str, i_pszSeparators);

    CThemeContextActivator activator;
    if (SUCCEEDED(hr) && IDOK == editDlg.DoModal())
    {
        CString str;
        hr = editDlg.get_Strings(str);
        if (SUCCEEDED(hr))
        {
            if (0 != io_str.CompareNoCase(str))
            {
                io_str = str;
                hr = S_OK;
            } else
            {
                hr = S_FALSE; // string unchanged
            }
        }
    }

    if (FAILED(hr))
        DoErrMsgBox(i_pParent->GetSafeHwnd(), MB_OK | MB_ICONSTOP, hr, IDS_MVSTRINGEDIT_ERROR);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\lsastuff.cpp ===
//	LsaStuff.cpp
//
//	LSA-dependent code
//
//	HISTORY
//	09-Jul-97	jonn		Creation.
//

#include "stdafx.h"
#include "DynamLnk.h"		// DynamicDLL

extern "C"
{
	#define NTSTATUS LONG
	#define PNTSTATUS NTSTATUS*
	#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
	#define SE_SHUTDOWN_PRIVILEGE             (19L)

// stuff taken from ntdef.h
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;

#include <ntlsa.h>
#define _NTDEF_

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;
#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }
#define _NTDEF

// from ntstatus.h
#define STATUS_OBJECT_NAME_NOT_FOUND     ((NTSTATUS)0xC0000034L)

#include <lmaccess.h>
}


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


typedef enum _Netapi32ApiIndex
{
	BUFFERFREE_ENUM = 0,
	USERMODALSGET_ENUM
};

// not subject to localization
static LPCSTR g_apchNetapi32FunctionNames[] = {
	"NetApiBufferFree",
	"NetUserModalsGet",
	NULL
};

typedef NET_API_STATUS (*BUFFERFREEPROC)(LPVOID);
typedef NET_API_STATUS (*USERMODALSGETPROC)(LPCWSTR, DWORD, LPBYTE*);

// not subject to localization
DynamicDLL g_LSASTUFF_Netapi32DLL( _T("NETAPI32.DLL"), g_apchNetapi32FunctionNames );



/*******************************************************************

    NAME: ::FillUnicodeString

    SYNOPSIS: Standalone method for filling in a UNICODE_STRING

    ENTRY:	punistr - Unicode string to be filled in.
			nls - Source for filling the unistr

    EXIT:

    NOTES:	punistr->Buffer is allocated here and must be deallocated
			by the caller using FreeUnicodeString.

    HISTORY:
	jonn		07/09/97	copied from net\ui\common\src\lmobj\lmobj\uintmem.cxx

********************************************************************/
VOID FillUnicodeString( LSA_UNICODE_STRING * punistr, LPCWSTR psz )
{
	if ( NULL == punistr || NULL == psz )
	{
		ASSERT(FALSE);
		return;
	}
	size_t cTchar = ::wcslen(psz);
	punistr->Buffer = new WCHAR[cTchar + 1];
	ASSERT( NULL != punistr->Buffer );
	if ( NULL != punistr->Buffer )
	{
		::wcscpy( punistr->Buffer, psz );
		// Length and MaximumLength are counts of bytes.
		punistr->Length = (USHORT)(cTchar * sizeof(WCHAR));
		punistr->MaximumLength = punistr->Length + sizeof(WCHAR);
	}
	else
		::ZeroMemory( punistr, sizeof(*punistr) );
}

/*******************************************************************

    NAME: ::FreeUnicodeString

    SYNOPSIS: Standalone method for freeing in a UNICODE_STRING

    ENTRY:	unistr - Unicode string whose Buffer is to be freed.

    EXIT:

    HISTORY:
	jonn		07/09/97	copied from net\ui\common\src\lmobj\lmobj\uintmem.cxx

********************************************************************/
VOID FreeUnicodeString( LSA_UNICODE_STRING * punistr )
{
	if ( punistr && punistr->Buffer )
	{
		delete punistr->Buffer;
		::ZeroMemory( punistr, sizeof(*punistr) );
	}
}



/*******************************************************************

    NAME: InitObjectAttributes

    SYNOPSIS:

    This function initializes the given Object Attributes structure, including
    Security Quality Of Service.  Memory must be allcated for both
    ObjectAttributes and Security QOS by the caller.

    ENTRY:

    poa - Pointer to Object Attributes to be initialized.

    psqos - Pointer to Security QOS to be initialized.

    EXIT:

    NOTES:

    HISTORY:
	jonn		07/09/97	copied from net\ui\common\src\lmobj\lmobj\uintlsa.cxx

********************************************************************/
VOID InitObjectAttributes( PLSA_OBJECT_ATTRIBUTES poa,
                           PSECURITY_QUALITY_OF_SERVICE psqos )

{
    ASSERT( poa != NULL );
    ASSERT( psqos != NULL );

    psqos->Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    psqos->ImpersonationLevel = SecurityImpersonation;
    psqos->ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    psqos->EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes(
				poa,
				NULL,
				0L,
				NULL,
				NULL );

    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the psqos field, so we must manually copy that
    // structure for now.
    //

    poa->SecurityQualityOfService = psqos;
}


BOOL
I_CheckLSAAccount( LSA_UNICODE_STRING* punistrServerName,
                   LPCTSTR pszLogOnAccountName,
                   DWORD* pdwMsgID ) // *pdsMsgID is always set if this fails
{
	ASSERT( NULL != pdwMsgID );

	BOOL fSuccess = FALSE;
	LSA_HANDLE hlsa = NULL;
	LSA_HANDLE hlsaAccount = NULL;
	PSID psidAccount = NULL;

	do { // false loop

		//
		// Determine whether the target machine is a BDC, and if so, get the PDC
		//

		// if an error occurs now, it is a read error
		*pdwMsgID = IDS_LSAERR_READ_FAILED;

		//
		// Get LSA_POLICY handle
		//
		LSA_OBJECT_ATTRIBUTES oa;
		SECURITY_QUALITY_OF_SERVICE sqos;
		InitObjectAttributes( &oa, &sqos );

		// 563140-2002/03/04 JonN POLICY_ALL_ACCESS was too much authority.
		// LsaLookupNames only requires POLICY_LOOKUP_NAMES.
		// LsaOpenAccount requres no rights (MarkPu).
		// LsaCreateAccount requires POLICY_CREATE_ACCOUNT (MarkPu).
		NTSTATUS ntstatus = ::LsaOpenPolicy(
		               punistrServerName,
		               &oa,
		               POLICY_LOOKUP_NAMES | POLICY_CREATE_ACCOUNT,
		               &hlsa );
		if ( !NT_SUCCESS(ntstatus) )
			break;

		//
		// Remove ".\" or "thismachine\" from the head of the account name if it is present
		//
		CString strAccountName = pszLogOnAccountName;
		int iBackslash = strAccountName.Find( _T('\\') );
		if ( -1 < iBackslash )
		{
			CString strPrefix = strAccountName.Left(iBackslash);
			if ( !lstrcmp(strPrefix, _T(".")) || IsLocalComputername(strPrefix) )
			{
				strAccountName = strAccountName.Mid(iBackslash+1);
			}
		}

		//
		// determine the SID of the account
		//
		PLSA_REFERENCED_DOMAIN_LIST plsardl = NULL;
		PLSA_TRANSLATED_SID plsasid = NULL;
		LSA_UNICODE_STRING unistrAccountName;
		::FillUnicodeString( &unistrAccountName, strAccountName );
		ntstatus = ::LsaLookupNames(
						 hlsa,
						 1,
						 &unistrAccountName,
						 &plsardl,
						 &plsasid );
		::FreeUnicodeString( &unistrAccountName );
		if ( !NT_SUCCESS(ntstatus) )
			break;
		if ( !plsardl || !plsasid || !plsardl->Domains[0].Sid )
		{
			ASSERT(FALSE);
			ntstatus = E_FAIL;
			break;
		}

		// ISSUE-2002-03-04-JonN There is a potential issue here
		// if LsaLookupNames returns an invalid SID.  This is a fairly
		// remote risk however.

		//
		// Build the SID of the account by taking the SID of the domain
		// and adding at the end the RID of the account
		//
		PSID psidDomain = plsardl->Domains[0].Sid;
		DWORD ridAccount = plsasid[0].RelativeId;
		DWORD cbNewSid = ::GetLengthSid(psidDomain)+sizeof(ridAccount);
		psidAccount = (PSID) new BYTE[cbNewSid];
		ASSERT( NULL != psidAccount );
		(void) ::CopySid( cbNewSid, psidAccount, psidDomain );
		UCHAR* pcSubAuthorities = ::GetSidSubAuthorityCount( psidAccount ) ;
		(*pcSubAuthorities)++;
		DWORD* pdwSubAuthority = ::GetSidSubAuthority(
			psidAccount, (*pcSubAuthorities)-1 );
		*pdwSubAuthority = ridAccount;

		(void) ::LsaFreeMemory( plsardl );
		(void) ::LsaFreeMemory( plsasid );

		// 563140-2002/04/08 JonN POLICY_ALL_ACCESS | DELETE was too much authority.
		// CliffV says:
		// LsaGetSystemAccessAccount only requires ACCOUNT_VIEW.
		// LsaSetSystemAccessAccount only requires ACCOUNT_ADJUST_SYSTEM_ACCESS.

		//
		// Determine whether this LSA account exists, create it if not
		//
		ntstatus = ::LsaOpenAccount( hlsa,
		                             psidAccount,
		                             ACCOUNT_VIEW | ACCOUNT_ADJUST_SYSTEM_ACCESS,
		                             &hlsaAccount );
		ULONG ulSystemAccessCurrent = 0;
		if (STATUS_OBJECT_NAME_NOT_FOUND == ntstatus)
		{
			// handle account-not-found case

			// if an error occurs now, it is a write error
			*pdwMsgID = IDS_LSAERR_WRITE_FAILED;
			ntstatus = ::LsaCreateAccount( hlsa,
			                               psidAccount,
			                               ACCOUNT_ADJUST_SYSTEM_ACCESS,
			                               &hlsaAccount );
			// 4/8/02 JonN: CliffV confirms that the account is created without any privileges
		}
		else
		{
			ntstatus = ::LsaGetSystemAccessAccount( hlsaAccount, &ulSystemAccessCurrent );
		}
		if ( !NT_SUCCESS(ntstatus) )
			break;

		//
		// Determine whether this LSA account has POLICY_MODE_SERVICE privilege,
		// grant it if not
		//
		if ( POLICY_MODE_SERVICE != (ulSystemAccessCurrent & POLICY_MODE_SERVICE ) )
		{
			// if an error occurs now, it is a write error
			*pdwMsgID = IDS_LSAERR_WRITE_FAILED;

			ntstatus = ::LsaSetSystemAccessAccount(
				hlsaAccount,
				ulSystemAccessCurrent | POLICY_MODE_SERVICE );
			if ( !NT_SUCCESS(ntstatus) )
				break; // CODEWORK could check for STATUS_BACKUP_CONTROLLER

			// display the write-succeeded message
			*pdwMsgID = IDS_LSAERR_WRITE_SUCCEEDED;
		}
		else
		{
			*pdwMsgID = 0;
		}

		fSuccess = TRUE;

	} while (FALSE); // false loop

	// CODEWORK should check for special error code for NT5 non-DC
	// using local policy object

	if (NULL != hlsa)
	{
		::LsaClose( hlsa );
	}
	if (NULL != hlsaAccount)
	{
		::LsaClose( hlsaAccount );
	}
	if (NULL != psidAccount)
	{
		delete[] psidAccount;
	}

	return fSuccess;

} // I_CheckLSAAccount()

/////////////////////////////////////////////////////////////////////
//	FCheckLSAAccount()
//
VOID
CServicePropertyData::FCheckLSAAccount()
{
	LSA_UNICODE_STRING unistrServerName;
	PLSA_UNICODE_STRING punistrServerName = NULL ;
	USER_MODALS_INFO_1* pum1 = NULL;
	DWORD dwMsgID = 0;

	TRACE1("INFO: Checking LSA permissions for account %s...\n",
		(LPCTSTR)m_strLogOnAccountName);

	if ( !m_strMachineName.IsEmpty() )
	{
		::FillUnicodeString( &unistrServerName, m_strMachineName );
		punistrServerName = &unistrServerName;
	}

	do // false loop
	{
		// check on the local machine
		// this will always set dwMsgID if it fails
		if (I_CheckLSAAccount(punistrServerName, m_strLogOnAccountName, &dwMsgID))
			break; // this succeeded, we can stop now

		// check whether this is a Backup Domain Controller
		if ( !g_LSASTUFF_Netapi32DLL.LoadFunctionPointers() )
		{
			ASSERT(FALSE);
			return;
		}
		DWORD err = ((USERMODALSGETPROC)g_LSASTUFF_Netapi32DLL[USERMODALSGET_ENUM])(
			(m_strMachineName.IsEmpty()) ? NULL : const_cast<LPTSTR>((LPCTSTR)m_strMachineName),
			1,
			reinterpret_cast<LPBYTE*>(&pum1) );
		if (NERR_Success != err)
			break;
		ASSERT( NULL != pum1 );
		if (UAS_ROLE_BACKUP != pum1->usrmod1_role)
			break; // not a backup controller
		if (NULL == pum1->usrmod1_primary )
		{
			ASSERT(FALSE);
			break;
		}

		// Try it on the PDC
		(void) I_CheckLSAAccount(punistrServerName, pum1->usrmod1_primary, &dwMsgID);

	} while (FALSE); // false loop

    if ( NULL != punistrServerName )
    {
		::FreeUnicodeString( punistrServerName );
    }

	if ( NULL != pum1 )
	{
		if ( !g_LSASTUFF_Netapi32DLL.LoadFunctionPointers() )
		{
			ASSERT(FALSE);
			return;
		}

		((BUFFERFREEPROC)g_LSASTUFF_Netapi32DLL[BUFFERFREE_ENUM])( pum1 );
	}

	if (0 != dwMsgID)
	{
		DoServicesErrMsgBox( GetActiveWindow(), MB_OK | MB_ICONEXCLAMATION, 0, dwMsgID, (LPCTSTR)m_strLogOnAccountName );
	}

} // FCheckLSAAccount()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\nodetype.h ===
// nodetype.h : Declaration of FileMgmtObjectType

#ifndef __NODETYPE_H_INCLUDED__
#define __NODETYPE_H_INCLUDED__

//
// The order of these object types must be as follows:
//  First, FILEMGMT_ROOT
//  Next, the autonomous node types, where FILEMGMT_LAST_AUTONOMOUS is the last one
//  Next, all non-autonomous types
//  Finally, FILEMGMT_NUMTYPES
// Also note that the IDS_DISPLAYNAME_* and IDS_DISPLAYNAME_*_LOCAL string resources
// must be kept in sync with these values, and in the appropriate order.
// Also global variable cookie.cpp aColumns[][] must be kept in sync.
//
typedef enum _FileMgmtObjectType {
	FILEMGMT_ROOT = 0,
	FILEMGMT_SHARES,
	FILEMGMT_SESSIONS,
	FILEMGMT_RESOURCES,
	FILEMGMT_SERVICES,
	#ifdef SNAPIN_PROTOTYPER
	FILEMGMT_PROTOTYPER,
	FILEMGMT_PROTOTYPER_LEAF,
	#endif
	FILEMGMT_SHARE,
	FILEMGMT_SESSION,
	FILEMGMT_RESOURCE,
	FILEMGMT_SERVICE,

	FILEMGMT_NUMTYPES // must be last
} FileMgmtObjectType, *PFileMgmtObjectType;

#ifdef SNAPIN_PROTOTYPER
	#define FILEMGMT_LAST_AUTONOMOUS FILEMGMT_PROTOTYPER
#else
	#define FILEMGMT_LAST_AUTONOMOUS FILEMGMT_SERVICES
#endif

inline BOOL IsAutonomousObjectType( FileMgmtObjectType objecttype )
	{ return (objecttype >= FILEMGMT_ROOT && objecttype <= FILEMGMT_LAST_AUTONOMOUS); }
inline BOOL IsValidObjectType( FileMgmtObjectType objecttype )
	{ return (objecttype >= FILEMGMT_ROOT && objecttype < FILEMGMT_NUMTYPES); }

// enumeration for the transports supported
// keep cookie.cpp:g_FileServiceProviders in sync
typedef enum _FILEMGMT_TRANSPORT
{
	FILEMGMT_FIRST = 0,
	FILEMGMT_FIRST_TRANSPORT = 0,
	FILEMGMT_SMB = 0,
	FILEMGMT_SFM,
	FILEMGMT_NUM_TRANSPORTS,
	FILEMGMT_OTHER = FILEMGMT_NUM_TRANSPORTS,
	FILEMGMT_LAST = FILEMGMT_OTHER
} FILEMGMT_TRANSPORT;
inline BOOL IsValidTransport( FILEMGMT_TRANSPORT transport )
	{ return (transport >= FILEMGMT_FIRST_TRANSPORT &&
			  transport < FILEMGMT_NUM_TRANSPORTS); }

#endif // ~__NODETYPE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\mvedit.h ===
//
// mvEdit.h : header file for multi-valued string edit dialog
//

#ifndef __MVEDIT_H_INCLUDED__
#define __MVEDIT_H_INCLUDED__

/////////////////////////////////////////////////////////////////////////////
// CMultiValuedStringEdit dialog

class CMultiValuedStringEdit : public CDialog
{
public:
//	CMultiValuedStringEdit(CWnd* pParent = NULL);
    CMultiValuedStringEdit(CWnd* pParent = NULL, int nDlgTitle = 0, int nText = 0, UINT uiStringLengthLimit = 0);

	enum { IDD = IDD_MVSTRINGEDIT };

protected:

	// Generated message map functions
	//{{AFX_MSG(CMultiValuedStringEdit)
	virtual BOOL OnInitDialog();
	afx_msg void OnString();
	afx_msg void OnAdd();
	afx_msg void OnRemove();
	afx_msg void OnList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	afx_msg BOOL OnContextHelp(WPARAM wParam, LPARAM lParam);
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
    HRESULT put_Strings(IN LPCTSTR i_pszValues, IN LPCTSTR i_pszSeparators);
    HRESULT get_Strings(OUT CString& o_strValues);

protected:
    CString m_strSeparators;
    CString m_strValues;
    int     m_nDlgTitle;
    int     m_nText;
    UINT    m_uiStringLengthLimit;
};

HRESULT InvokeMultiValuedStringEditDlg(
    IN CWnd*    i_pParent,
    IN CString& io_str,
    IN LPCTSTR  i_pszSeparators,
    IN int      i_nDlgTitle,
    IN int      i_nText,
    IN UINT     i_uiStringLengthLimit
    );

#endif // __MVEDIT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\filesvc.h ===
// FileSvc.h : Base class for File Service Provider

#ifndef __FILESVC_H_INCLUDED__
#define __FILESVC_H_INCLUDED__

// forward declarations
class CFileMgmtCookie;
class CFileMgmtResultCookie;
class CFileMgmtComponentData;
class CSecurityInformation;

class FileServiceProvider
{
public:
  FileServiceProvider(CFileMgmtComponentData* pFileMgmtData);
  virtual ~FileServiceProvider();

  virtual HRESULT PopulateShares(
    IResultData* pResultData,
    CFileMgmtCookie* pcookie) = 0;
  // for EnumerateSessions and EnumerateResources:
  //   if pResultData is not NULL, add sessions/resources to the listbox
  //   if pResultData is NULL, delete all sessions/resources
  //   if pResultData is NULL, return SUCCEEDED(hr) to continue or
  //     FAILED(hr) to abort
  virtual HRESULT EnumerateSessions(
    IResultData* pResultData,
    CFileMgmtCookie* pcookie,
    bool bAddToResultPane) = 0;
  virtual HRESULT EnumerateResources(
    IResultData* pResultData,
    CFileMgmtCookie* pcookie) = 0;

  virtual DWORD OpenShare(LPCTSTR ptchServerName, LPCTSTR ptchShareName) = 0;
  virtual HRESULT ConfirmDeleteShare(LPCTSTR ptchServerName, LPCTSTR ptchShareName) = 0;
  virtual DWORD DeleteShare(LPCTSTR ptchServerName, LPCTSTR ptchShareName) = 0;
  virtual DWORD CloseSession(CFileMgmtResultCookie* pcookie) = 0;
  virtual DWORD CloseResource(CFileMgmtResultCookie* pcookie) = 0;

  virtual VOID DisplayShareProperties( // CODEWORK can this be removed?
    LPPROPERTYSHEETCALLBACK pCallBack,
    LPDATAOBJECT pDataObject,
    LONG_PTR handle) = 0;
  virtual DWORD ReadShareProperties(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    OUT PVOID* ppvPropertyBlock,
    OUT CString& strDescription,
    OUT CString& strPath,
    OUT BOOL* pfEditDescription,
    OUT BOOL* pfEditPath,      // CODEWORK always disable for now
    OUT DWORD* pdwShareType) = 0;
  virtual DWORD WriteShareProperties(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    PVOID pvPropertyBlock,
    LPCTSTR ptchDescription,
    LPCTSTR ptchPath) = 0;
  virtual HRESULT ReadSharePublishInfo(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    OUT BOOL* pbPublish,
    OUT CString& strUNCPath,
    OUT CString& strDescription,
    OUT CString& strKeywords,
    OUT CString& strManagedBy) 
  {
      UNREFERENCED_PARAMETER (ptchServerName);
      UNREFERENCED_PARAMETER (ptchShareName);
      UNREFERENCED_PARAMETER (pbPublish);
      UNREFERENCED_PARAMETER (strUNCPath);
      UNREFERENCED_PARAMETER (strDescription);
      UNREFERENCED_PARAMETER (strKeywords);
      UNREFERENCED_PARAMETER (strManagedBy);
      return S_OK; 
  }
  virtual HRESULT WriteSharePublishInfo(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    IN BOOL bPublish,
    LPCTSTR ptchDescription,
    LPCTSTR ptchKeywords,
    LPCTSTR ptchManagedBy) 
  {
      UNREFERENCED_PARAMETER (ptchServerName);
      UNREFERENCED_PARAMETER (ptchShareName);
      UNREFERENCED_PARAMETER (bPublish);
      UNREFERENCED_PARAMETER (ptchDescription);
      UNREFERENCED_PARAMETER (ptchKeywords);
      UNREFERENCED_PARAMETER (ptchManagedBy);
      return S_OK; 
  }
  virtual DWORD ReadShareType(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    DWORD* pdwShareType );
  virtual DWORD ReadShareFlags(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    DWORD* pdwFlags );
  virtual DWORD WriteShareFlags(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    DWORD dwFlags );
  virtual BOOL GetCachedFlag( DWORD dwFlags, DWORD dwFlagToCheck );
  virtual VOID SetCachedFlag( DWORD* pdwFlags, DWORD dwNewFlag );
  virtual VOID FreeShareProperties(PVOID pvPropertyBlock) = 0;

  virtual VOID FreeData(PVOID pv) = 0;

  virtual DWORD QueryMaxUsers(PVOID pvPropertyBlock) = 0;
  virtual VOID  SetMaxUsers(  PVOID pvPropertyBlock, DWORD dwMaxUsers) = 0;

  virtual LPCTSTR QueryTransportString() = 0;

protected:
  CFileMgmtComponentData* m_pFileMgmtData;
  INT DoPopup(  INT nResourceID,
          DWORD dwErrorNumber = 0,
          LPCTSTR pszInsertionString = NULL,
          UINT fuStyle = MB_OK | MB_ICONSTOP );
  HRESULT CreateFolderSecurityPropPage(
      LPPROPERTYSHEETCALLBACK pCallBack,
      LPDATAOBJECT pDataObject
  );
};

#endif // ~__FILESVC_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\permpage.cpp ===
// PermPage.cpp : Implementation of data object classes

#include "stdafx.h"
#include "cookie.h"

#include "macros.h"
USE_HANDLE_MACROS("FILEMGMT(PermPage.cpp)")

#include "DynamLnk.h"		// DynamicDLL

#include "PermPage.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/*
 * Share General Permissions -- from shareacl.hxx 
#define FILE_PERM_GEN_NO_ACCESS          (0)
#define FILE_PERM_GEN_READ               (GENERIC_READ    |\
                                          GENERIC_EXECUTE)
#define FILE_PERM_GEN_MODIFY             (GENERIC_READ    |\
                                          GENERIC_EXECUTE |\
                                          GENERIC_WRITE   |\
                                          DELETE )
#define FILE_PERM_GEN_ALL                (GENERIC_ALL)
*/ 

SI_ACCESS siShareAccesses[] =
{
  { &GUID_NULL, 
    FILE_ALL_ACCESS, 
    MAKEINTRESOURCE(IDS_SHAREPERM_ALL), 
    SI_ACCESS_GENERAL },
  { &GUID_NULL, 
    FILE_GENERIC_READ | FILE_EXECUTE | FILE_GENERIC_WRITE | DELETE, 
    MAKEINTRESOURCE(IDS_SHAREPERM_MODIFY), 
    SI_ACCESS_GENERAL },
  { &GUID_NULL, 
    FILE_GENERIC_READ | FILE_EXECUTE, 
    MAKEINTRESOURCE(IDS_SHAREPERM_READ), 
    SI_ACCESS_GENERAL }
};

#define iShareDefAccess       2   // index of value in array siShareAccesses
#ifndef ARRAYSIZE
#define ARRAYSIZE(x)          (sizeof(x)/sizeof(x[0]))
#endif

STDMETHODIMP
CSecurityInformation::GetAccessRights(
    const GUID  * /*pguidObjectType*/,
    DWORD       /*dwFlags*/,
    PSI_ACCESS  *ppAccess,
    ULONG       *pcAccesses,
    ULONG       *piDefaultAccess
)
{
  ASSERT(ppAccess);
  ASSERT(pcAccesses);
  ASSERT(piDefaultAccess);

  *ppAccess = siShareAccesses;
  *pcAccesses = ARRAYSIZE(siShareAccesses);
  *piDefaultAccess = iShareDefAccess;

  return S_OK;
}

// This is consistent with the NETUI code
GENERIC_MAPPING ShareMap =
{
  FILE_GENERIC_READ,
  FILE_GENERIC_WRITE,
  FILE_GENERIC_EXECUTE,
  FILE_ALL_ACCESS
};

STDMETHODIMP
CSecurityInformation::MapGeneric(
    const GUID  * /*pguidObjectType*/,
    UCHAR       * /*pAceFlags*/,
    ACCESS_MASK *pMask
)
{
  ASSERT(pMask);

  MapGenericMask(pMask, &ShareMap);

  return S_OK;
}

STDMETHODIMP 
CSecurityInformation::GetInheritTypes (
    PSI_INHERIT_TYPE  * /*ppInheritTypes*/,
    ULONG             * /*pcInheritTypes*/
)
{
  return E_NOTIMPL;
}

STDMETHODIMP 
CSecurityInformation::PropertySheetPageCallback(
    HWND          /*hwnd*/, 
    UINT          /*uMsg*/, 
    SI_PAGE_TYPE  /*uPage*/
)
{
  return S_OK;
}

/*
JeffreyS 1/24/97:
If you don't set the SI_RESET flag in
ISecurityInformation::GetObjectInformation, then fDefault should never be TRUE
so you can ignore it.  Returning E_NOTIMPL in this case is OK too.

If you want the user to be able to reset the ACL to some default state
(defined by you) then turn on SI_RESET and return your default ACL
when fDefault is TRUE.  This happens if/when the user pushes a button
that is only visible when SI_RESET is on.
*/
STDMETHODIMP CShareSecurityInformation::GetObjectInformation (
    PSI_OBJECT_INFO pObjectInfo )
{
    ASSERT(pObjectInfo != NULL &&
           !IsBadWritePtr(pObjectInfo, sizeof(*pObjectInfo)));

    pObjectInfo->dwFlags = SI_EDIT_ALL | SI_NO_ACL_PROTECT | SI_PAGE_TITLE;
    pObjectInfo->hInstance = g_hInstanceSave;
    pObjectInfo->pszServerName = QueryMachineName();
    pObjectInfo->pszObjectName = QueryShareName();
    pObjectInfo->pszPageTitle = QueryPageTitle();

    return S_OK;
}

typedef enum _AcluiApiIndex
{
	ACLUI_CREATE_PAGE = 0
};

// not subject to localization
static LPCSTR g_apchFunctionNames[] = {
	"CreateSecurityPage",
	NULL
};

// not subject to localization
DynamicDLL g_AcluiDLL( _T("ACLUI.DLL"), g_apchFunctionNames );

/*
HPROPSHEETPAGE ACLUIAPI CreateSecurityPage( LPSECURITYINFO psi );
*/
typedef HPROPSHEETPAGE (*CREATEPAGE_PROC) (LPSECURITYINFO);

HRESULT
MyCreateShareSecurityPage(
    IN LPPROPERTYSHEETCALLBACK   pCallBack,
    IN CShareSecurityInformation *pSecInfo,
    IN LPCTSTR                   pszMachineName,
    IN LPCTSTR                   pszShareName
)
{
  ASSERT( pCallBack );
  ASSERT( pSecInfo );

  HRESULT hr = S_OK;

  if ( !g_AcluiDLL.LoadFunctionPointers() )
    return hr; // ignore the load failure

  pSecInfo->SetMachineName( pszMachineName );
  pSecInfo->SetShareName( pszShareName );
  CString csPageTitle;
  csPageTitle.LoadString(IDS_SHARE_SECURITY);
  pSecInfo->SetPageTitle( csPageTitle );

  pSecInfo->AddRef();

  HPROPSHEETPAGE hPage = ((CREATEPAGE_PROC)g_AcluiDLL[ACLUI_CREATE_PAGE])(pSecInfo);
  if (hPage)
    pCallBack->AddPage(hPage);
  else
    hr = HRESULT_FROM_WIN32(GetLastError());
  
  pSecInfo->Release();

  return hr;
}

HRESULT 
CSecurityInformation::NewDefaultDescriptor(
    OUT PSECURITY_DESCRIPTOR  *ppsd,
    IN  SECURITY_INFORMATION  /*RequestedInformation*/
)
{
  ASSERT(ppsd);

  *ppsd = NULL;

  PSID psidWorld = NULL, psidAdmins = NULL;
  PACL pAcl = NULL;
  SECURITY_DESCRIPTOR sd;
  DWORD dwErr = 0;

  do { // false loop

    // get World SID for "everyone"
    SID_IDENTIFIER_AUTHORITY IDAuthorityWorld = SECURITY_WORLD_SID_AUTHORITY;
    if ( !::AllocateAndInitializeSid(
              &IDAuthorityWorld,
              1,
              SECURITY_WORLD_RID,
              0,0,0,0,0,0,0,
              &psidWorld ) )
    {
      dwErr = GetLastError();
      break;
    }

    // get Admins SID
    SID_IDENTIFIER_AUTHORITY IDAuthorityNT = SECURITY_NT_AUTHORITY;
    if ( !::AllocateAndInitializeSid(
              &IDAuthorityNT,
              2,
              SECURITY_BUILTIN_DOMAIN_RID,
              DOMAIN_ALIAS_RID_ADMINS,
              0,0,0,0,0,0,
              &psidAdmins ) )
    {
      dwErr = GetLastError();
      break;
    }

    // build ACL, and add AccessAllowedAce to it
    DWORD cbAcl = sizeof (ACL) + sizeof (ACCESS_ALLOWED_ACE) +
                  ::GetLengthSid(psidWorld) - sizeof (DWORD);
    pAcl = reinterpret_cast<ACL *>(LocalAlloc(LPTR, cbAcl));
    if ( !pAcl ||
         !::InitializeAcl(pAcl, cbAcl, ACL_REVISION2) ||
         !::AddAccessAllowedAce(pAcl, ACL_REVISION2, GENERIC_ALL, psidWorld) )
    {
      dwErr = GetLastError();
      break;
    }

    // add ACL to the security descriptor, and set Owner and Group appropriately
    if ( !::InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION) ||
         !::SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE) ||
         !::SetSecurityDescriptorOwner(&sd, psidAdmins, FALSE) ||
         !::SetSecurityDescriptorGroup(&sd, psidAdmins, FALSE) )
    {
      dwErr = GetLastError();
      break;
    }

    // convert security descriptor to self-relative format
    DWORD cbSD = 0;
    ::MakeSelfRelativeSD(&sd, NULL, &cbSD); // this call should fail and set cbSD to the correct size
    *ppsd = (PSECURITY_DESCRIPTOR)(LocalAlloc(LPTR, cbSD));
    if ( !(*ppsd) || !::MakeSelfRelativeSD(&sd, *ppsd, &cbSD) )
    {
      dwErr = GetLastError();
      break;
    }

  } while (FALSE); // false loop

  // clean up
  if (psidWorld)
    (void)::FreeSid(psidWorld);
  if (psidAdmins)
    (void)::FreeSid(psidAdmins);

  if (pAcl)
    LocalFree(pAcl);

  if (dwErr && *ppsd)
  {
    LocalFree(*ppsd);
    *ppsd = NULL;
  }

  return (dwErr ? HRESULT_FROM_WIN32(dwErr) : S_OK);
}

HRESULT 
CSecurityInformation::MakeSelfRelativeCopy(
    IN  PSECURITY_DESCRIPTOR  psdOriginal,
    OUT PSECURITY_DESCRIPTOR  *ppsdNew
)
{
  ASSERT(psdOriginal);
  ASSERT(ppsdNew);

  *ppsdNew = NULL;

  DWORD dwErr = 0;
  PSECURITY_DESCRIPTOR psdSelfRelative = NULL;

  do { // false loop

    DWORD cbSD = ::GetSecurityDescriptorLength(psdOriginal);
    psdSelfRelative = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR, cbSD);
    if ( !psdSelfRelative )
    {
      dwErr = ::GetLastError();
      break;
    }

    // we have to find out whether the original is already self-relative
    SECURITY_DESCRIPTOR_CONTROL sdc = 0;
    DWORD dwRevision = 0;
    if ( !::GetSecurityDescriptorControl(psdOriginal, &sdc, &dwRevision) )
    {
      dwErr = ::GetLastError();
      break;
    }

    if (sdc & SE_SELF_RELATIVE)
    {
      ::memcpy(psdSelfRelative, psdOriginal, cbSD);
    } else if ( !::MakeSelfRelativeSD(psdOriginal, psdSelfRelative, &cbSD) )
    {
      dwErr = ::GetLastError();
      break;
    }

    *ppsdNew = psdSelfRelative;

  } while (FALSE);

  if (dwErr && psdSelfRelative)
    LocalFree(psdSelfRelative);
 
  return (dwErr ? HRESULT_FROM_WIN32(dwErr) : S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\permpage.h ===
// PermPage.h : Declaration of the standard permissions page class

#ifndef __PERMPAGE_H_INCLUDED__
#define __PERMPAGE_H_INCLUDED__

#include "aclui.h"

class CSecurityInformation : public ISecurityInformation, public CComObjectRoot
{
    DECLARE_NOT_AGGREGATABLE(CSecurityInformation)
    BEGIN_COM_MAP(CSecurityInformation)
        COM_INTERFACE_ENTRY(ISecurityInformation)
    END_COM_MAP()

  // *** ISecurityInformation methods ***
  STDMETHOD(GetObjectInformation)(
      IN PSI_OBJECT_INFO pObjectInfo
  ) = 0;
  STDMETHOD(GetSecurity)(
      IN  SECURITY_INFORMATION  RequestedInformation,
      OUT PSECURITY_DESCRIPTOR  *ppSecurityDescriptor,
      IN  BOOL                  fDefault
  ) = 0;
  STDMETHOD(SetSecurity)(
      IN SECURITY_INFORMATION SecurityInformation,
      IN PSECURITY_DESCRIPTOR pSecurityDescriptor
  ) = 0;
  STDMETHOD(GetAccessRights)(
      const GUID  *pguidObjectType,
      DWORD       dwFlags,
      PSI_ACCESS  *ppAccess,
      ULONG       *pcAccesses,
      ULONG       *piDefaultAccess
  );
  STDMETHOD(MapGeneric)(
      const GUID  *pguidObjectType,
      UCHAR       *pAceFlags,
      ACCESS_MASK *pMask
  );
  STDMETHOD(GetInheritTypes)(
      PSI_INHERIT_TYPE  *ppInheritTypes,
      ULONG             *pcInheritTypes
  );
  STDMETHOD(PropertySheetPageCallback)(
      HWND          hwnd, 
      UINT          uMsg, 
      SI_PAGE_TYPE  uPage
  );
protected:
  HRESULT 
  NewDefaultDescriptor(
      OUT PSECURITY_DESCRIPTOR  *ppsd,
      IN  SECURITY_INFORMATION  RequestedInformation
  );

  HRESULT 
  MakeSelfRelativeCopy(
      IN  PSECURITY_DESCRIPTOR  psdOriginal,
      OUT PSECURITY_DESCRIPTOR  *ppsdNew
  );
};

class CShareSecurityInformation : public CSecurityInformation
{
private:
	CString m_strMachineName;
	CString m_strShareName;
  CString m_strPageTitle;
public:
	void SetMachineName( LPCTSTR pszMachineName )
	{
		m_strMachineName = pszMachineName;
	}
	void SetShareName( LPCTSTR pszShareName )
	{
		m_strShareName = pszShareName;
	}
	void SetPageTitle( LPCTSTR pszPageTitle )
	{
		m_strPageTitle = pszPageTitle;
	}
	// note: these should be LPCTSTR but are left this way for convenience
	LPTSTR QueryMachineName()
	{
		return (m_strMachineName.IsEmpty())
			? NULL
			: const_cast<LPTSTR>((LPCTSTR)m_strMachineName);
	}
	LPTSTR QueryShareName()
	{
		return const_cast<LPTSTR>((LPCTSTR)m_strShareName);
	}
	LPTSTR QueryPageTitle()
	{
		return const_cast<LPTSTR>((LPCTSTR)m_strPageTitle);
	}

    // *** ISecurityInformation methods ***
    STDMETHOD(GetObjectInformation) (PSI_OBJECT_INFO pObjectInfo );
};

HRESULT
MyCreateShareSecurityPage(
    IN LPPROPERTYSHEETCALLBACK   pCallBack,
    IN CShareSecurityInformation *pSecInfo,
    IN LPCTSTR                   pszMachineName,
    IN LPCTSTR                   pszShareName
);

#endif // ~__PERMPAGE_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\persist.cpp ===
// Persist.cpp : Implementation of persistence for CFileMgmtComponentData
//
// HISTORY
// 01-Jan-1996	???			Creation
// 28-May-1997	t-danm		Added a version number to storage and
//							Command Line override.
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "compdata.h"
#include "safetemp.h"

#include "macros.h"
USE_HANDLE_MACROS("FILEMGMT(persist.cpp)")

#include <comstrm.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


LPCTSTR PchGetMachineNameOverride();	// Defined in chooser.cpp

/////////////////////////////////////////////////
//	The _dwMagicword is the internal version number.
//	Increment this number if you makea file format change.
#define _dwMagicword	10000


///////////////////////////////////////////////////////////////////////////////
/// IPersistStorage 
#ifdef PERSIST_TO_STORAGE
/*
STDMETHODIMP CFileMgmtComponentData::Load(IStorage __RPC_FAR *pStg)
{
	MFC_TRY;

	ASSERT( NULL != pStg );
#ifndef DONT_PERSIST
	// open stream
	IStream* pIStream = NULL;
	HRESULT hr = pStg->OpenStream(
		L"ServerName",
		NULL,
		STGM_READ | STGM_SHARE_EXCLUSIVE,
		0L,
		&pIStream );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	ASSERT( NULL != pIStream );
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	// read object type from stream
	hr = pIStream->Read( &(QueryRootCookie().QueryObjectType()), 4, NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}

	// read server name from stream
	DWORD dwLen = 0;
	hr = pIStream->Read( &dwLen, 4, NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	ASSERT( dwLen <= MAX_PATH*sizeof(WCHAR) );
	// allocated from stack, we don't need to free
	LPCWSTR lpwcszMachineName = (LPCWSTR)alloca( dwLen );
	if (NULL == lpwcszMachineName)
	{
		AfxThrowMemoryException();
		return E_OUTOFMEMORY;
	}
	hr = pIStream->Read( (PVOID)lpwcszMachineName, dwLen, NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	m_RootCookieBlock.SetMachineName( lpwcszMachineName );

#endif
	return S_OK;

	MFC_CATCH;
}
*/

/*
STDMETHODIMP CFileMgmtComponentData::Save(IStorage __RPC_FAR *pStgSave, BOOL fSameAsLoad)
{
	MFC_TRY;

	ASSERT( NULL != pStgSave );
#ifndef DONT_PERSIST
	IStream* pIStream = NULL;
	HRESULT hr = pStgSave->CreateStream(
		L"ServerName",
		STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
		0L,
		0L,
		&pIStream );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	ASSERT( NULL != pIStream );
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	ASSERT( 4 == sizeof(QueryRootCookie().QueryObjectType()) );
	hr = pIStream->Write( &(QueryRootCookie().QueryObjectType()), 4, NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}

	LPCWSTR lpwcszMachineName = QueryRootCookie().QueryNonNULLMachineName();

	DWORD dwLen = (::wcslen(lpwcszMachineName)+1)*sizeof(WCHAR);
	ASSERT( 4 == sizeof(DWORD) );
	hr = pIStream->Write( &dwLen, 4, NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	hr = pIStream->Write( lpwcszMachineName, dwLen, NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
#endif
	return S_OK;

	MFC_CATCH;
}
*/
#else // PERSIST_TO_STORAGE

STDMETHODIMP CFileMgmtComponentData::Load(IStream __RPC_FAR *pIStream)
{
	MFC_TRY;
	HRESULT hr;

#ifndef DONT_PERSIST
	ASSERT( NULL != pIStream );
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	// Read the magic word from the stream
	DWORD dwMagicword;
	hr = pIStream->Read( OUT &dwMagicword, sizeof(dwMagicword), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	if (dwMagicword != _dwMagicword)
	{
		// We have a version mismatch
		TRACE0("INFO: CFileMgmtComponentData::Load() - Wrong Magicword.  You need to re-save your .msc file.\n");
		return E_FAIL;
	}

	// read object type from stream
	FileMgmtObjectType objecttype;
	ASSERT( 4 == sizeof(objecttype) );
	hr = pIStream->Read( &objecttype, 4, NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	QueryRootCookie().SetObjectType( objecttype );

	// read flags from stream
	DWORD dwFlags;
	hr = pIStream->Read( OUT &dwFlags, sizeof(dwFlags), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	SetPersistentFlags(dwFlags);

	// read server name from stream
	DWORD dwLen = 0;
	hr = pIStream->Read( &dwLen, 4, NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	ASSERT( dwLen <= MAX_PATH*sizeof(WCHAR) );
	LPCWSTR lpwcszMachineName = (LPCWSTR)alloca( dwLen );
	// allocated from stack, we don't need to free
	if (NULL == lpwcszMachineName)
	{
		AfxThrowMemoryException();
		return E_OUTOFMEMORY;
	}
	hr = pIStream->Read( (PVOID)lpwcszMachineName, dwLen, NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	m_strMachineNamePersist = lpwcszMachineName;
	LPCTSTR pszMachineNameT = PchGetMachineNameOverride();
	if (m_fAllowOverrideMachineName && pszMachineNameT != NULL)
		{
		// Allow machine name override
		}
	else
		{
		pszMachineNameT = lpwcszMachineName;
		}

	// JonN 1/27/99: If the persisted name is the local computername,
	// leave the persisted name alone but make the effective name (Local).
	if ( IsLocalComputername(pszMachineNameT) )
		pszMachineNameT = L"";

	if (pszMachineNameT && !_tcsncmp(pszMachineNameT, _T("\\\\"), 2))
		QueryRootCookie().SetMachineName(pszMachineNameT + 2);
	else
		QueryRootCookie().SetMachineName(pszMachineNameT);

#endif

	return S_OK;

	MFC_CATCH;
} // CFileMgmtComponentData::Load()


STDMETHODIMP CFileMgmtComponentData::Save(IStream __RPC_FAR *pIStream, BOOL /*fSameAsLoad*/)
{
	MFC_TRY;
	HRESULT hr;

#ifndef DONT_PERSIST
	ASSERT( NULL != pIStream );
	XSafeInterfacePtr<IStream> pIStreamSafePtr( pIStream );

	// Store the magic word to the stream
	DWORD dwMagicword = _dwMagicword;
	hr = pIStream->Write( IN &dwMagicword, sizeof(dwMagicword), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}

	FileMgmtObjectType objecttype = QueryRootCookie().QueryObjectType();
	ASSERT( 4 == sizeof(objecttype) );
	hr = pIStream->Write( &objecttype, 4, NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}

	DWORD dwFlags = GetPersistentFlags();
	hr = pIStream->Write( IN &dwFlags, sizeof(dwFlags), NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}

	LPCWSTR lpwcszMachineName = m_strMachineNamePersist;
	ULONG cbLen = (ULONG)((::wcslen(lpwcszMachineName)+1)*sizeof(WCHAR));
	ASSERT( 4 == sizeof(DWORD) );
	hr = pIStream->Write( &cbLen, 4, NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
	hr = pIStream->Write( lpwcszMachineName, cbLen, NULL );
	if ( FAILED(hr) )
	{
		ASSERT( FALSE );
		return hr;
	}
#endif
	return S_OK;

	MFC_CATCH;
} // CFileMgmtComponentData::Save()

#endif // PERSIST_TO_STORAGE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\progress.h ===
/////////////////////////////////////////////////////////////////////
//
//	Progress.h
//
//  Progress dialog to Start, Stop, Pause and Resume a service.
//
//	HISTORY
//	03-Oct-95	t-danmo		Creation of (sysmgmt\dsui\services\progress.cxx) 
//	01-Oct-96	t-danmo		Renaming of progress.cxx and adaptation to slate.
//


#define SERVICE_CONTROL_RESTART		10		// Stop and then Start the service

/////////////////////////////////////////////////////////////////////////////
class CServiceControlProgress
{
  protected:
	enum { IDD = IDD_SERVICE_CONTROL_PROGRESS }; // Id of the dialog used
	enum { ID_TIMER = 1 };					// Id of the timer
	enum { dwTimerTickIncrement = 400 };	// Length of a timer tick (in milliseconds)
	enum { dwTimerTimeout = 125000 };		// Timeout in milliseconds before aborting
	enum { dwTimerProgressDone = 5000 };	// Estimate of time to complete the operation

  protected:
	// Run-time UI variables
	HWND m_hWndParent;			// Parent window of the dialog box
	HWND m_hctlActionMsg;		// Handle of action static control
	HWND m_hctlServiceNameMsg;	// Handle of service name static control
	HWND m_hctlProgress;		// Handle of progress bar
	UINT m_iServiceAction;		// Index of action to take (start, stop, pause or resume)
	
	UINT_PTR m_uTimerId;			// Dynamic timer Id
	UINT m_dwTimerTicks;		// Number of milliseconds the timer has been ticking

	// Variables needed for the threadproc
	HANDLE m_hThread;
	HANDLE m_hEvent;
	BOOL m_fCanQueryStatus;
	DWORD m_dwQueryState;				// Service state to query when pooling
	
	SC_HANDLE m_hScManager;				// Handle to service control manager database
	SC_HANDLE m_hService;				// Handle of the opened service
	TCHAR m_szUiMachineName[256];		// Name of the computer in a friendly way
	TCHAR m_szServiceName[256];			// Service name
	TCHAR m_szServiceDisplayName[256];	// Display name of service
	DWORD m_dwDesiredAccess;
	
	// Variables used by ::StartService()
	DWORD m_dwNumServiceArgs;			// Number of arguments 
    LPCTSTR * m_lpServiceArgVectors;	// Address of array of argument string pointers  
	
	// Variables used by ::ControlService()
	DWORD m_dwControlCode;				// Control code

	// Variables used by ::ControlService(SERVICE_CONTROL_STOP)
	BOOL m_fPulseEvent;				// TRUE => Call PulseEvent() instead of closing the dialog
	BOOL m_fRestartService;			// TRUE => Stop the service first, then start it again.
	INT m_iDependentServiceIter;	// Index of the current dependent service
	INT m_cDependentServices;		// Number of dependent services
	ENUM_SERVICE_STATUS * m_pargDependentServicesT;	// Allocated array of dependent services
	ENUM_SERVICE_STATUS * m_pargServiceStop;	// Allocated array of services to stop

	APIERR m_dwLastError;			// Error code from GetLastError()

  public:
	CServiceControlProgress();	// Constructor
	~CServiceControlProgress();	// Destructor
	BOOL M_FInit(
		HWND hwndParent,
		SC_HANDLE hScManager,
		LPCTSTR pszMachineName,
		LPCTSTR pszServiceName,
		LPCTSTR pszServiceDisplayName);
  
  protected:
	BOOL M_FDlgStopDependentServices();
	void M_UpdateDialogUI(LPCTSTR pszDisplayName);
	BOOL M_FGetNextService(OUT LPCTSTR * ppszServiceName, OUT LPCTSTR * ppszDisplayName);
	DWORD M_QueryCurrentServiceState();

	APIERR M_EControlService(DWORD dwControlCode);
	APIERR M_EDoExecuteServiceThread(void * pThreadProc);
	void M_ProcessErrorCode();
	void M_DoThreadCleanup();

  protected:
	static DWORD S_ThreadProcStartService(CServiceControlProgress * pThis);
	static DWORD S_ThreadProcStopService(CServiceControlProgress * pThis);
	static DWORD S_ThreadProcPauseResumeService(CServiceControlProgress * pThis);

	static INT_PTR CALLBACK S_DlgProcControlService(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
	static INT_PTR CALLBACK S_DlgProcDependentServices(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

	void M_OnInitDialog(HWND hdlg);
	void M_OnTimer(HWND hdlg);


  public:
	enum	// Error codes for variable m_dwLastError (arbitrary chosen)
		{
		errCannotInitialize = 123456,			// Failed to initialize object
		errUserCancelStopDependentServices,		// User changed its mind (only used when stop service)
		errUserAbort,							// User aborted operation
		};

	static APIERR S_EStartService(
		HWND hwndParent,
		SC_HANDLE hScManager,
		LPCTSTR pszMachineName,
		LPCTSTR pszServiceName,
		LPCTSTR pszServiceDisplayName,
		DWORD dwNumServiceArgs,
		LPCTSTR * lpServiceArgVectors);

	static APIERR S_EControlService(
		HWND hwndParent,
		SC_HANDLE hScManager,
		LPCTSTR pszMachineName,
		LPCTSTR pszServiceName,
		LPCTSTR pszServiceDisplayName,
		DWORD dwControlCode);

}; // CServiceControlProgress
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by filemgmt.rc
//
#define IDS_FILEMGMT_DESC               1
#define IDS_SVCVWR_DESC                 2
#define IDS_LOCAL_MACHINE               3
#define IDS_CAPTION_FILEMGMT            4
#define IDS_CAPTION_SERVICES            5
#define IDS_ss_PROPERTIES_ON            11
#define IDS_sus_ERROR                   12
#define IDS_sus_ERROR_HR                13
#define IDS_SVC_STARTUP_BOOT            100
#define IDD_FILEMANAGEMENT_GENERAL      100
#define IDS_SVC_STARTUP_SYSTEM          101
#define IDD_FILE_FILEMANAGEMENT_GENERAL 101
#define IDS_SVC_STARTUP_AUTOMATIC       102
#define IDS_SVC_STARTUP_MANUAL          103
#define IDS_SVC_STARTUP_DISABLED        104
#define IDS_SVC_STATUS_STARTED          105
#define IDS_SVC_STATUS_STOPPED          106
#define IDS_SVC_STATUS_PAUSED           107
#define IDS_SVC_STATUS_STARTING         108
#define IDS_SVC_STATUS_STOPPING         109
#define IDS_SVC_STATUS_PAUSING          110
#define IDS_SVC_STATUS_RESUMING         111
#define IDS_SVC_UNKNOWN                 112
#define IDS_SVC_REBOOT_MESSAGE_DEFAULT  113
#define IDS_SVC_ss_SERVICE_STARTING     116
#define IDS_SVC_ss_SERVICE_STOPPING     117
#define IDS_SVC_ss_SERVICE_PAUSING      118
#define IDS_SVC_ss_SERVICE_RESUMING     119
#define IDS_SVC_RECOVERY_NOACTION       120
#define IDS_SVC_RECOVERY_RESTARTSERVICE 121
#define IDS_SVC_RECOVERY_RUNFILE        122
#define IDS_SVC_RECOVERY_REBOOTCOMPUTER 123
#define IDS_SVC_HARDWARE_PROFILE        125
#define IDS_SVC_INSTANCE                126
#define IDS_SVC_STATUS                  127
#define IDS_SVC_ENABLED                 129
#define IDS_SVC_DISABLED                130
#define IDS_SVC_RESTART_DEPENDENT_QUERY 131
#define IDS_SVC_RESTART_DEPENDENT_CAPTION 132
#define IDS_SVC_s_STOP_DEPENDENT_SERVICES 133
#define IDS_SVC_s_RESTART_DEPENDENT_SERVICES 134
#define IDS_SVC_MENU_SERVICE_START      140
#define IDS_SVC_MENU_SERVICE_STOP       141
#define IDS_SVC_MENU_SERVICE_PAUSE      142
#define IDS_SVC_MENU_SERVICE_RESUME     143
#define IDS_SVC_MENU_SERVICE_RESTART    144
#define IDS_SVC_STATUSBAR_ss_SERVICE_START 145
#define IDS_SVC_STATUSBAR_ss_SERVICE_STOP 146
#define IDS_SVC_STATUSBAR_ss_SERVICE_PAUSE 147
#define IDS_SVC_STATUSBAR_ss_SERVICE_RESUME 148
#define IDS_SVC_STATUSBAR_ss_SERVICE_RESTART 149
#define IDS_SVC_STARTUP_LOCALSYSTEM     160
#define IDS_SVC_STARTUP_LOCALSERVICE    161
#define IDS_SVC_STARTUP_NETWORKSERVICE  162
#define IDS_CFGMGR32_BASE               200
#define IDC_GEN_DATE                    201
#define IDC_GEN_TIME                    203
#define IDC_GEN_USER                    204
#define IDC_GEN_COMPUTER                205
#define IDC_GEN_EVENTID                 206
#define IDC_GEN_SRC                     207
#define IDC_BUTTON_SEND                 207
#define IDC_GEN_TYPE                    208
#define IDB_ICONSTRIPLG                 208
#define IDC_STATIC_SESSIONS             208
#define IDC_GEN_CATEGORY                209
#define IDB_ICONSTRIPSM                 209
#define IDC_STATIC_FORKS                209
#define IDC_STATIC_FILE_LOCKS           210
#define IDD_PROPPAGE_SERVICE_GENERAL    211
#define IDC_FIELD_LIST                  212
#define IDD_PROPPAGE_SERVICE_HWPROFILE  212
#define IDC_EDIT_SERVER_NAME            212
#define IDC_EDIT_DISPLAY_NAME           213
#define IDD_PROPPAGE_SERVICE_RECOVERY   213
#define IDC_EDIT_SESSION_LIMIT          213
#define IDC_STATIC_SERVICE_NAME         214
#define IDD_SERVICE_REBOOT_COMPUTER     214
#define IDC_STATIC_PATH_TO_EXECUTABLE   215
#define IDD_SERVICE_STOP_DEPENDENCIES   215
#define IDC_COMBO_CREATOR               215
#define IDC_STATIC_CURRENT_STATUS       216
#define IDC_BUTTON_START                217
#define IDC_COMBO_FILE_TYPE             217
#define IDC_BUTTON_STOP                 218
#define IDC_BUTTON_PAUSE                219
#define IDD_SERVICE_CONTROL_PROGRESS    219
#define IDC_BUTTON_RESUME               220
#define IDD_PROPPAGE_SERVICE_RECOVERY2  220
#define IDC_EDIT_DESCRIPTION            221
#define IDC_SHRPROP_EDIT_USERS          222
#define IDD_SHAREPROP_GENERAL           223
#define IDC_SFM_EDIT_PASSWORD           223
#define IDD_SHAREPROP_GENERAL_SMB       224
#define IDC_COMBO_STARTUP_TYPE          224
#define IDD_SHAREPROP_GENERAL_SFM       225
#define IDC_EDIT_STARTUP_PARAMETERS     225
#define IDB_SVCMGMT_TOOLBAR             225
#define IDB_FILEMGMT_TOOLBAR            226
#define IDC_RADIO_LOGONAS_SYSTEMACCOUNT 226
#define IDB_FILEMGMT_ICONS_16           227
#define IDC_RADIO_LOGONAS_THIS_ACCOUNT  227
#define IDC_CHECK_SERVICE_INTERACT_WITH_DESKTOP 228
#define IDC_COMBO_LOGONAS_THIS_ACCOUNT  229
#define IDC_EDIT_PASSWORD               230
#define IDC_EDIT_PASSWORD_CONFIRM       231
#define IDB_FILEMGMT_ICONS_32           231
#define IDC_BUTTON_ENABLE               232
#define IDB_BITMAP1                     232
#define IDC_BUTTON_DISABLE              233
#define IDB_SVCMGMT_ICONS_16            233
#define IDC_EDIT_ACCOUNTNAME            234
#define IDB_SVCMGMT_ICONS_32            234
#define IDC_EDIT_RUNFILE_FILENAME       235
#define IDC_COMBO_SECOND_ATTEMPT        236
#define IDI_ICON_SVCMGMT                236
#define IDC_COMBO_SUBSEQUENT_ATTEMPTS   237
#define IDI_ICON_FILEMGMT               237
#define IDI_ICON_WARNING                238
#define IDC_EDIT_SERVICE_RESET_ABEND_COUNT 238
#define IDB_FILEMGMT_FOLDER_SMALL       238
#define IDC_BUTTON_BROWSE               239
#define IDB_FILEMGMT_FOLDER_SMALLOPEN   239
#define IDD_SMB_CACHE_SETTINGS          239
#define IDC_EDIT_RUNFILE_PARAMETERS     240
#define IDB_FILEMGMT_FOLDER_LARGE       240
#define IDC_SFM_CHECK_READONLY          241
// #define IDC_SFM_CHECK_GUESTS         242
#define IDC_DESCRIBE_HARDWARE_PROFILES  243
#define IDC_EDIT1                       244
#define IDC_BUTTON_CHOOSE_USER          245
#define IDC_BUTTON_REBOOT_COMPUTER      246
#define IDC_COMBO_FIRST_ATTEMPT         247
#define IDC_STATIC_RESTARTSERVICE       249
#define IDC_STATIC_RESTARTSERVICE_3     250
#define IDC_STATIC_RUNFILE_1            251
#define IDC_STATIC_RUNFILE_2            252
#define IDC_STATIC_RUNFILE_3            253
#define IDC_LIST_HARDWARE_PROFILES      254
#define IDC_RADIO_ALL                   255
#define IDC_RADIO_SHARES                256
#define IDC_RADIO_SESSIONS              257
#define IDC_RADIO_RESOURCES             258
#define IDC_RADIO_SERVICES              259
#define IDC_STATIC_ACTION_MSG           260
#define IDC_LIST_SERVICES               261
#define IDC_STATIC_SERVICE_NAME_STATIC  262
#define IDC_STATIC_STARTUP_PARAMETERS   263
#define IDC_STATIC_DISPLAY_NAME         264
#define IDC_EDIT_PATH_NAME              265
#define IDC_EDIT_SHARE_NAME             266
#define IDC_STATIC_PATH_NAME            267
#define IDC_PROGRESS                    269
#define IDC_STATIC_SERVICENAME_MSG      270
#define IDC_SHRPROP_MAX_ALLOWED         271
#define IDC_SHRPROP_ALLOW_SPECIFIC      272
#define IDC_SHRPROP_SPIN_USERS          273
#define IDC_SFM_GROUPBOX                277
#define IDC_SFM_STATIC1                 278
#define IDC_STATIC_PATH_TO_EXECUTABLE_STATIC 283
#define IDC_STATIC_CURRENT_STATUS_STATIC 284
#define IDC_STATIC_STARTUP_TYPE         285
#define IDC_GROUP_STARTUP_TYPE          286
#define IDC_GROUP_LOGON_AS              288
#define IDC_STATIC_FAILURE_ACTIONS      289
#define IDC_STATIC_FIRST_ATTEMPT        290
#define IDC_STATIC_SECOND_ATTEMPT       291
#define IDC_STATIC_SUBSEQUENT_ATTEMPTS  292
#define IDC_STATIC_RESET_FAIL_COUNT     293
#define IDC_STATIC_SHARE_NAME_STATIC    294
#define IDC_STATIC_PATH_NAME_STATIC     295
#define IDC_STATIC_COMMENT_STATIC       296
#define IDC_GROUP_USER_LIMIT            297
#define IDC_GROUP_VIEW                  299
#define IDC_STATIC_STOP_SERVICES_QUERY  300
#define IDC_STATIC_STOP_SERVICES        301
#define IDC_STATIC_MINUTES              302
#define IDC_STATIC_PASSWORD             303
#define IDC_STATIC_PASSWORD_CONFIRM     304
#define IDC_STATIC_DESCRIPTION          305
#define IDC_STATIC_REBOOT_MESSAGE       306
#define IDC_STATIC_REBOOT_COMPUTER_DELAY 307
#define IDC_EDIT_REBOOT_MESSAGE         308
#define IDC_EDIT_SERVICE_RESTART_DELAY  309
#define IDC_CHECK_APPEND_ABENDNO        310
#define IDC_EDIT_REBOOT_COMPUTER_DELAY  311
#define IDC_STATIC_EVERYONE             316
#define IDC_STATIC_PRIMARY_GROUP        317
#define IDC_STATIC_OWNER                318
#define IDC_GROUP_PERMISSIONS           319
#define IDC_STATIC_PATH                 320
#define IDC_REBOOT_MESSAGE_CHECKBOX     321
#define IDC_COMBO_AUTHENTICATION        323
#define IDC_CACHE_OPTIONS_MANUAL        329
#define IDC_CACHE_OPTIONS_AUTO          330
#define IDC_CACHE_OPTIONS_NOCACHE       331
#define IDC_CACHE_OPTIONS_AUTO_CHECK    332
#define IDC_CACHE_HELPLINK              333
#define IDD_SHAREPROP_PUBLISH           340
#define IDC_CHECK_SHRPUB_PUBLISH        341
#define IDC_LABEL_SHRPUB_UNCPATH        342
#define IDC_EDIT_SHRPUB_UNCPATH         343
#define IDC_LABEL_SHRPUB_DESCRIPTION    344
#define IDC_EDIT_SHRPUB_DESCRIPTION     345
#define IDC_LABEL_SHRPUB_MANAGEDBY      346
#define IDC_EDIT_SHRPUB_MANAGEDBY       347
#define IDC_LABEL_SHRPUB_KEYWORDS       348
#define IDC_EDIT_SHRPUB_KEYWORDS        349
#define IDC_BUTTON_SHRPUB_CHANGE        350
#define IDC_STATIC_SHRPUB_ERRORMSG      351
#define IDD_MVSTRINGEDIT                360
#define IDC_MVSTRINGEDIT_TEXT           361
#define IDC_MVSTRINGEDIT_STRING         362
#define IDC_MVSTRINGEDIT_LIST           363
#define IDC_MVSTRINGEDIT_ADD            364
#define IDC_MVSTRINGEDIT_REMOVE         365
#define IDS_MVSTRINGEDIT_TITLE_KEYWORDS 366
#define IDS_MVSTRINGEDIT_TEXT_KEYWORDS  367
#define IDS_MVSTRINGEDIT_ERROR          368
#define IDS_MVSTRINGEDIT_STRING_INVALID 369
#define IDC_STATIC_HELPLESS             400
#define IDC_STATIC_HELPLESS2            402
#define IDS_SNAPINABOUT_DESCR_SERVICES  602
#define IDS_SNAPINABOUT_DESCR_FILESVC   603
#define IDD_CHOOSER_CHOOSE_MACHINE      970
#ifdef EDIT_DISPLAY_NAME_373025
#define IDS_MSG_PLEASE_ENTER_DISPLAY_NAME 1000
#endif // EDIT_DISPLAY_NAME_373025
#define IDS_MSG_INVALID_STARTUP_PARAMETERS 1002
#define IDS_MSG_PASSWORD_MISMATCH       1003
#define IDS_MSG_PASSWORD_EMPTY          1004
#define IDS_MSG_sss_UNABLE_TO_START_SERVICE 1006
#define IDS_MSG_sss_UNABLE_TO_STOP_SERVICE 1007
#define IDS_MSG_sss_UNABLE_TO_PAUSE_SERVICE 1008
#define IDS_MSG_sss_UNABLE_TO_RESUME_SERVICE 1009
#define IDS_MSG_sss_SERVICE_STOPPED_AUTOMATICALLY 1010
#define IDS_MSG_ss_UNABLE_TO_OPEN_READ_SERVICE 1014
#define IDS_MSG_ss_UNABLE_TO_OPEN_WRITE_SERVICE 1015
#define IDS_MSG_SPECIFIC_ERROR          1016
#define IDS_MSG_INTERNAL_ERROR          1017
#define IDS_MSG_s_UNABLE_TO_OPEN_SERVICE_DATABASE 1018
#define IDC_CACHING                     1019
#define IDS_MSG_s_UNABLE_TO_READ_SERVICES 1019
#define IDS_MSG_ss_UNABLE_TO_QUERY_SERVICE_STATUS 1020
#define IDS_MSG_s_UNABLE_TO_OPEN_WRITE_ACCT_INFO_DOWNLEVEL 1021
#define IDS_MSG_ssd_SERVSPECIFIC_START_SERVICE 1030
#define IDS_MSG_ssd_SERVSPECIFIC_STOP_SERVICE 1031
#define IDS_MSG_ssd_SERVSPECIFIC_PAUSE_SERVICE 1032
#define IDS_MSG_ssd_SERVSPECIFIC_RESUME_SERVICE 1033
#define IDS_DISPLAYNAME_s_ROOT          2000
#define IDS_DISPLAYNAME_s_SHARES        2001
#define IDS_DISPLAYNAME_s_SESSIONS      2002
#define IDS_DISPLAYNAME_s_FILES         2003
#define IDS_DISPLAYNAME_s_SERVICES      2004
#define IDS_DISPLAYNAME_ROOT_LOCAL      2100
#define IDS_DISPLAYNAME_SHARES_LOCAL    2101
#define IDS_DISPLAYNAME_SESSIONS_LOCAL  2102
#define IDS_DISPLAYNAME_FILES_LOCAL     2103
#define IDS_DISPLAYNAME_SERVICES_LOCAL  2104
#define IDS_DISPLAYNAME_ROOT            2200
#define IDS_DISPLAYNAME_SHARES          2201
#define IDS_DISPLAYNAME_SESSIONS        2202
#define IDS_DISPLAYNAME_FILES           2203
#define IDS_DISPLAYNAME_SERVICES        2204
#define IDS_BLT_ELLIPSIS_TEXT           3000
#define IDS_PROP_SHEET_TITLE            3001
#define IDS_NEED_SERVER_NAME            3002
#define IDS_SERVERNAME_CHANGE           3003
#define IDS_MESSAGE_TOO_LONG            3004
#define IDS_DELETE_TC_CONFIRM           3005
#define IDS_NEED_TEXT_TO_SEND           3006
#define IDS_SESSION_DELETED             3007
#define IDS_MESSAGE_SENT                3008
#define IDS_NOT_RECEIVED                3009
#define IDS_NEED_TYPE_CREATOR           3010
#define IDS_CONFIG_SFM_TASK             3012
#define IDS_CONFIG_SFM_TOP              3013
#define IDS_AUTH_MS_ONLY                3014
#define IDS_AUTH_APPLE_CLEARTEXT        3015
#define IDS_AUTH_APPLE_ENCRYPTED        3016
#define IDS_AUTH_CLEARTEXT_OR_MS        3017
#define IDS_AUTH_ENCRYPTED_OR_MS        3018
#define IDS_START_SERVICE               3019
#define IDS_AUTH_WARNING                3020
#define IDS_CREATOR                     3021
#define IDS_TYPE                        3022
#define IDS_DESCRIPTION                 3023
#define IDS_INVALID_SESSIONLIMIT        3024
#define IDS_REGISTER_FILEMGMT           3500
#define IDS_REGISTER_FILEMGMT_EXT       3501
#define IDS_REGISTER_SVCMGMT            3502
#define IDS_REGISTER_SVCMGMT_EXT        3503
#define IDS_REGISTER_DEFAULT_VIEW_EXT   3504
#define IDP_SFM_CONFIGURATION           11475
#define IDC_EDIT_LOGON_MESSAGE          11478
#define IDC_CHECK_MS_AUTH               11479
#define IDC_CHECK_SAVE_PASSWORD         11480
#define IDC_RADIO_SESSION_UNLIMITED     11482
#define IDC_RADIO_SESSSION_LIMIT        11483
#define IDDP_CHK_OWNER_FILE             11526
#define IDDP_CHK_OWNER_FOLDER           11527
#define IDDP_CHK_OWNER_CHANGES          11528
#define IDDP_CHK_GROUP_FILE             11529
#define IDDP_CHK_GROUP_FOLDER           11530
#define IDDP_CHK_GROUP_CHANGES          11531
#define IDDP_CHK_WORLD_FILE             11532
#define IDDP_CHK_WORLD_FOLDER           11533
#define IDDP_CHK_WORLD_CHANGES          11534
#define IDDP_SLE_OWNER                  11535
#define IDDP_SLE_PRIMARYGROUP           11536
#define IDDP_CHK_READONLY               11537
#define IDDP_CHK_RECURSE                11538
#define IDDP_SLT_PATH                   11539
#define IDDP_PB_OWNER                   11540
#define IDDP_PB_GROUP                   11541
#define IDP_SFM_SESSIONS                11625
#define IDC_EDIT_MESSAGE                11627
#define IDD_SFM_TYPE_CREATOR_ADD        11650
#define IDD_SFM_TYPE_CREATOR_EDIT       11675
#define IDC_STATIC_CREATOR              11677
#define IDC_STATIC_FILE_TYPE            11678
#define IDP_SFM_FILE_ASSOCIATION        11700
#define IDC_COMBO_EXTENSION             11701
#define IDC_BUTTON_ADD                  11702
#define IDC_BUTTON_EDIT                 11703
#define IDC_BUTTON_DELETE               11704
#define IDC_BUTTON_ASSOCIATE            11705
#define IDC_LIST_TYPE_CREATORS          11706
#define IDFA_ST_CREATOR                 11707
#define IDFA_ST_TYPE                    11708
#define IDFA_ST_COMMENT                 11709
#define IDS_AFPMGR_BASE                 22000
#define IDS_AFPERR_InvalidServerName    22105
#define IDS_ERROR_BASE                  25000
#define IDS_ERROR_PATH_NOT_FOUND        25003
#define IDS_ERROR_ACCESS_DENIED         25005
#define IDS_ERROR_INVALID_HANDLE        25006
#define IDS_ERROR_NOT_ENOUGH_MEMORY     25008
#define IDS_ERROR_SHARING_VIOLATION     25032
#define IDS_ERROR_INVALID_PARAMETER     25087
#define IDS_ERROR_INVALID_NAME          25123
#define IDS_ERROR_INVALID_LEVEL         25124
#define IDS_ERROR_SERVICE_REQUEST_TIMEOUT 26053
#define IDS_ERROR_SERVICE_NO_THREAD     26054
#define IDS_ERROR_SERVICE_DATABASE_LOCKED 26055
#define IDS_ERROR_SERVICE_ALREADY_RUNNING 26056
#define IDS_ERROR_SERVICE_DISABLED      26058
#define IDS_ERROR_SERVICE_DOES_NOT_EXIST 26060
#define IDS_ERROR_DATABASE_DOES_NOT_EXIST 26065
#define IDS_ERROR_SERVICE_DEPENDENCY_FAIL 26068
#define IDS_ERROR_SERVICE_LOGON_FAILED  26069
#define IDS_ERROR_SERVICE_MARKED_FOR_DELETE 26072
#define IDS_ERROR_SERVICE_DEPENDENCY_DELETED 26075
#define IDS_POPUP_SMB_SHARES_NOACCESS   32000
#define IDS_POPUP_SFM_SHARES_NOACCESS   32001
#define IDS_POPUP_SMB_SESSIONS_NOACCESS 32002
#define IDS_POPUP_SFM_SESSIONS_NOACCESS 32003
#define IDS_POPUP_SMB_RESOURCES_NOACCESS 32004
#define IDS_POPUP_SFM_RESOURCES_NOACCESS 32005
#define IDS_CATEGORY                    32774
#define IDS_SHARES_SHARED_FOLDER        32776
#define IDS_SHARES_SHARED_PATH          32777
#define IDS_SHARES_NUM_SESSIONS         32778
#define IDS_SHARES_COMMENT              32779
#define IDS_CONN_USERNAME               32780
#define IDS_CONN_COMPUTERNAME           32781
#define IDS_CONN_NUM_SESSIONS           32782
#define IDS_CONN_NUM_FILES              32783
#define IDS_CONN_CONNECTED_TIME         32784
#define IDS_CONN_IDLE_TIME              32785
#define IDS_CONN_IS_GUEST               32786
#define IDS_FILE_FILENAME               32787
#define IDS_FILE_SHARENAME              32788
#define IDS_FILE_USERNAME               32789
#define IDS_FILE_NUM_LOCKS              32790
#define IDS_FILE_OPEN_MODE              32791
#define IDS_SERVICE_SERVICENAME         32792
#define IDS_SERVICE_DESCRIPTION         32793
#define IDS_SERVICE_STATUS              32794
#define IDS_SERVICE_STARTUPTYPE         32795
#define IDS_SERVICE_SECURITYCONTEXT     32796
#define IDS_TIME_HOURPLUS               32800
#define IDS_TIME_ONEDAY                 32801
#define IDS_TIME_DAYPLUS                32802
#define IDS_FILEPERM_NONE               32805
#define IDS_FILEPERM_READ               32806
#define IDS_FILEPERM_WRITE              32807
#define IDS_FILEPERM_CREATE             32808
#define IDS_OPEN_SHARE_TASK             32809
#define IDS_OPEN_SHARE_TOP              32810
#define IDS_CANNOT_OPENSHARE            32811
#define IDS_MSG_EXPLORE_FAILURE         32812
#define IDS_POPUP_SMB_DISCONNECTALLSESSION_ERROR 32813
#define IDS_POPUP_SFM_DISCONNECTALLSESSION_ERROR 32815
#define IDS_POPUP_SMB_DISCONNECTALLRESOURCE_ERROR 32816
#define IDS_POPUP_SFM_DISCONNECTALLRESOURCE_ERROR 32818
#define IDS_POPUP_SMB_SHARES            32819
#define IDS_POPUP_SFM_SHARES            32821
#define IDS_POPUP_SMB_SESSIONS          32822
#define IDS_POPUP_SFM_SESSIONS          32824
#define IDS_POPUP_SMB_RESOURCES         32825
#define IDS_POPUP_SFM_RESOURCES         32827
#define IDS_POPUP_SERVICES              32828
#define IDS_DELETE_SHARE_TASK           32829
#define IDS_DELETE_SHARE_TOP            32830
#define IDS_POPUP_REMOTEADMINSESSION    32831
#define IDS_POPUP_REMOTEADMINFILE       32832
#define IDS_POPUP_DELETE_SHARE          32833
#define IDS_POPUP_CLOSE_SESSION         32834
#define IDS_POPUP_CLOSE_RESOURCE        32835
#define IDS_ROOT_NAME                   32836
#define IDS_s_CONFIRM_DELETESHARE       32837
#define IDS_s_CONFIRM_DELETESHARE_FILE  32838
#define IDS_s_CONFIRM_DELETESHARE_CONN  32839
#define IDS_CONFIRM_CLOSESESSION        32840
#define IDS_CONFIRM_CLOSERESOURCE       32841
#define IDS_SHARES_TRANSPORT            32842
#define IDS_TRANSPORT_SMB               32843
#define IDS_TRANSPORT_SFM               32845
#define IDS_CONN_TRANSPORT              32846
#define IDS_FILE_TRANSPORT              32847
#define IDS_SCOPE_SHARES                32848
#define IDS_SCOPE_SESSIONS              32849
#define IDS_SCOPE_RESOURCES             32850
#define IDS_POPUP_QUERY_SHARE           32852
#define IDS_POPUP_WRITE_SHARE           32853
#define IDS_SHAREPERM_READ              32855
#define IDS_SHAREPERM_MODIFY            32856
#define IDS_SHAREPERM_ALL               32857
#define IDS_POPUP_SFM_CONNECT           32858
#define IDS_POPUP_QUERY_SFM_DIRECTORY   32859
#define IDS_POPUP_SET_SFM_DIRECTORY     32860
#define IDS_SFM_PERM_GROUP_HEADER       32861
#define IDS_SFM_PERM_OWNER_HEADER       32862
#define IDS_POPUP_SFM_USERLIST          32863
#define IDS_POPUP_NEWSHARE              32864
#define IDS_POPUP_NEWSHARE_MEMORY       32865
#define IDS_POPUP_CLOSE_ALL_SESSIONS    32868
#define IDS_POPUP_CLOSE_ALL_RESOURCES   32869
#define IDS_FILEPERM_READWRITE          32872
#define IDS_BUTTON_NEWSHARE             32873
#define IDS_TOOLTIP_NEWSHARE            32874
#define IDS_BUTTON_SERVICE_START        32875
#define IDS_TOOLTIP_SERVICE_START       32876
#define IDS_BUTTON_SERVICE_STOP         32877
#define IDS_TOOLTIP_SERVICE_STOP        32878
#define IDS_BUTTON_SERVICE_PAUSE        32879
#define IDS_TOOLTIP_SERVICE_PAUSE       32880
#define IDS_BUTTON_SERVICE_RESUME       32881
#define IDS_TOOLTIP_SERVICE_RESUME      32882
#define IDS_BUTTON_SERVICE_RESTART      32883
#define IDS_TOOLTIP_SERVICE_RESTART     32884
#define IDS_SCOPE_SERVICES              32886
#define IDS_LSAERR_READ_FAILED          32887
#define IDS_LSAERR_WRITE_FAILED         32888
#define IDS_LSAERR_WRITE_SUCCEEDED      32889
#define IDS_s_POPUP_ADMIN_SHARE         32890
#define IDS_s_CONFIRM_DELETE_ADMINSHARE 32891
#define IDS_NEW_SHARE_NEW               32892
#define IDS_NEW_SHARE_TOP               32893
#define IDS_CLOSE_SESSION_TASK          32894
#define IDS_CLOSE_SESSION_TOP           32895
#define IDS_CLOSE_RESOURCE_TASK         32896
#define IDS_CLOSE_RESOURCE_TOP          32897
#define IDS_DISCONNECT_ALL_SESSIONS_TASK 32898
#define IDS_DISCONNECT_ALL_SESSIONS_TOP 32899
#define IDS_DISCONNECT_ALL_RESOURCES_TASK 32900
#define IDS_DISCONNECT_ALL_RESOURCES_TOP 32901
#define IDS_s_POPUP_IPC_SHARE           32908
#define IDS_CHANGE_COMPUTER_TOP         32909
#define IDS_CHANGE_COMPUTER_TASK        32910
#define IDS_MSG_READ_SHRPUB             32911
#define IDS_POPUP_WRITE_SHRPUB          32912
#define IDS_MSG_SHRPUB_ERRMSG_64        32913
#define IDS_s_DELETE_IPCSHARE           32914
#define IDS_s_CONFIRM_DELETE_NETLOGONSHARE 32915
#define IDS_s_CONFIRM_DELETEMULTISHARES 32920
#define IDS_CONFIRM_CLOSEMULTISESSIONS  32921
#define IDS_CONFIRM_CLOSEMULTIRESOURCES 32922
#define IDS_CANT_SAVE_CHANGES           57345
#define IDS_SHARE_SECURITY              57346
#define IDS_GUEST                       57347
#define IDS_YES                         57348
#define IDS_NO                          57349
#define IDS_CHANGED_LOGON_NAME          57400
#define IDS_OPENFILE_FILTER             57401

// leave these in order
#define IDS_HTML_DETAILS_START          57500
#define IDS_HTML_DETAILS_STOP           57501
#define IDS_HTML_DETAILS_PAUSE          57502
#define IDS_HTML_DETAILS_RESUME         57503
#define IDS_HTML_DETAILS_RESTART        57504

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        241
#define _APS_NEXT_COMMAND_VALUE         32777
#define _APS_NEXT_CONTROL_VALUE         380
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\progress.cpp ===
/////////////////////////////////////////////////////////////////////
//
//	Progress.cpp
//
//  Progress dialog to Start, Stop, Pause, Resume and Restart a service.
//
//	IMPLEMENTATION
//	Since an operation (ie, Start, Stop, Pause, Resume or Restart) may take
//	a while, a thread is created to do the actual work while a dialog
//	is displayed to the user.
//	0.	Allocate CServiceControlProgress object on the heap
//	1.	Create a thread in suspended mode.
//	2.	Create the dialog.
//	3.	Dialog creates a timer to update the progress bar.
//	4.	Dialog resumes the thread.
//	5.	Thread opens the service and perform the requested operation(s).
//	6.	Dialog updates UI using its timer.
//	7.	Thread updates dialog UI as well.
//	8.	Thread waits until the dialog is dismissed.  Dialog can be
//		dismissed for any of the following event:
//		a) Operation completed successfully.
//		b) User hit cancel button.
//		c) An unexpected error occured.
//		d) Operation times out.
//	9	Thread deletes CServiceControlProgress object.
//
//	HISTORY
//	03-Oct-95	t-danmo		Creation of (sysmgmt\dsui\services\progress.cxx) 
//	30-Sep-96	t-danmo		Renamed and adapted to MMC.
//	14-May-97	t-danm		Fully implemented the "Restart" feature.
//

#include "stdafx.h"
#include "progress.h"


/////////////////////////////////////////////////////////////////////////////
// This array represent the expected state of the service
// after carrying action, start, stop, pause or resume.
//
// To be compared SERVICE_STATUS.dwCurrentState.
//
const DWORD rgdwExpectedServiceStatus[4] =
	{
	SERVICE_RUNNING,		// Service should be running after a 'start'
	SERVICE_STOPPED,		// Service should be stopped after a 'stop'
	SERVICE_PAUSED,			// Service should be paused after a 'pause'
	SERVICE_RUNNING,		// Service should be running after a 'resume'
	};


/////////////////////////////////////////////////////////////////////////////
CServiceControlProgress::CServiceControlProgress()
	{
	// Using ZeroMemory() is safe as long as CServiceControlProgress
	// is not derived from any other object and does not contains
	// any objects with constructors.
	::ZeroMemory(this, sizeof(*this));
	}


/////////////////////////////////////////////////////////////////////////////
CServiceControlProgress::~CServiceControlProgress()
	{
	delete m_pargDependentServicesT;
	delete m_pargServiceStop;
	}


/////////////////////////////////////////////////////////////////////////////
//	M_FInit()
//
//	Initialize the object.
//		- Copy all input parameters
//		- Load the clock bitmap(s)
//	Return TRUE if successful, otherwise FALSE
//
BOOL
CServiceControlProgress::M_FInit(
	HWND hwndParent,				// IN: Parent of the dialog
	SC_HANDLE hScManager,			// IN: Handle to service control manager database 
	LPCTSTR pszMachineName,			// IN: Machine name to display to the user
	LPCTSTR pszServiceName,			// IN: Name of the service
	LPCTSTR pszServiceDisplayName)	// IN: Display name of the service
	{
	Assert(IsWindow(hwndParent));
	Assert(hScManager != NULL);
	Assert(pszServiceName != NULL);
	Assert(pszServiceDisplayName != NULL);

	m_hWndParent = hwndParent;
	m_hScManager = hScManager;
	lstrcpy(OUT m_szUiMachineName, (pszMachineName && pszMachineName[0])
	                                  ? pszMachineName : (LPCTSTR)g_strLocalMachine);
	lstrcpy(OUT m_szServiceName, pszServiceName);
	lstrcpy(OUT m_szServiceDisplayName, pszServiceDisplayName);

	return TRUE;
	} // M_FInit()


/////////////////////////////////////////////////////////////////////
//	M_FDlgStopDependentServices()
//
//	Check if the services has dependent services that must be stopped
//	before stopping the current service.
//
//	If there are any dependent services, the function will display
//	a dialog asking the user to confirm he/she wants also to stop
//	all the dependent services.
//
//	This function return FALSE ONLY IF the user click on the cancel button
//	otherwise TRUE.  If there are no dependent services, or an error occurs
//	while reading dependent services, the function will return TRUE.
//
BOOL
CServiceControlProgress::M_FDlgStopDependentServices()
	{
	Assert(m_hScManager != NULL);

	SC_HANDLE hService = NULL;
	BOOL fSuccess = TRUE;
	DWORD cbBytesNeeded = 0;
	DWORD dwServicesReturned = 0;

	m_cDependentServices = 0;	// So far we have no dependent services
	delete m_pargServiceStop;
	m_pargServiceStop = NULL;

	{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( )); // required for CWaitCursor
	CWaitCursor wait;
	hService = ::OpenService(m_hScManager, m_szServiceName, SERVICE_ENUMERATE_DEPENDENTS);
	}
	if (hService == NULL)
		{
		TRACE1("M_FDlgStopDependentServices() - Unable to enumerate service dependencies for service %s.\n",
			m_szServiceName);
		goto End;
		}

	// Find out how many bytes are needed to enumerate the dependent services
	fSuccess = ::EnumDependentServices(
		hService,
		SERVICE_ACTIVE,		// Enumerate only the active services
		NULL,
		0,
		OUT &cbBytesNeeded,
		OUT &dwServicesReturned);
	
	if (cbBytesNeeded == 0)
		{
		// Service does not have any dependencies
		goto End;
		}
	Assert(fSuccess == FALSE);
	Report(GetLastError() == ERROR_MORE_DATA);	// Error should be 'more data'
	Assert(dwServicesReturned == 0);
	cbBytesNeeded += 1000;		// Add extra bytes (just in case)
	delete m_pargDependentServicesT;		// Free previously allocated memory (if any)
	m_pargDependentServicesT	= (LPENUM_SERVICE_STATUS) new BYTE[cbBytesNeeded];

	// Query the database for the dependent services
	fSuccess = ::EnumDependentServices(
		hService,
		SERVICE_ACTIVE,		// Enumerate only the active services
		OUT m_pargDependentServicesT,
		cbBytesNeeded,
		OUT IGNORED &cbBytesNeeded,
		OUT &dwServicesReturned);
	Report(fSuccess != FALSE);
	Report(dwServicesReturned > 0);
	m_cDependentServices = dwServicesReturned;
	if (m_cDependentServices > 0)
		{
		// Allocate an array to hold all the dependent services
		m_pargServiceStop = new ENUM_SERVICE_STATUS[m_cDependentServices + 1];
		memcpy(OUT m_pargServiceStop, m_pargDependentServicesT,
			m_cDependentServices * sizeof(ENUM_SERVICE_STATUS));
		m_pargServiceStop[m_cDependentServices].lpServiceName = m_szServiceName;
		m_pargServiceStop[m_cDependentServices].lpDisplayName = m_szServiceDisplayName;

		INT_PTR nReturn = ::DialogBoxParam(
			g_hInstanceSave,
			MAKEINTRESOURCE(IDD_SERVICE_STOP_DEPENDENCIES),
			m_hWndParent,
			&S_DlgProcDependentServices,
			reinterpret_cast<LPARAM>(this));
		Report(nReturn != -1);
		if (0 == nReturn) // user chose Cancel
			fSuccess = FALSE;
		} // if
End:
	if (NULL != hService)
	{
		VERIFY(::CloseServiceHandle(hService));
	}
	return fSuccess;
	} // M_FDlgStopDependentServices()


/////////////////////////////////////////////////////////////////////
//	M_DoExecuteServiceThread()
//
//	Run a background thread while a foreground dialog is
//	displayed to the user.
//	This routine synchronizes the background thread with the main thread.
//
//	If an error occurs, the routine will display a message box of the
//	error encountered.
//
//	Return the error code from GetLastError() if an error occured.
//
APIERR
CServiceControlProgress::M_EDoExecuteServiceThread(void * pThreadProc)
	{
	Assert(pThreadProc != NULL);
	Assert(m_hService == NULL);
	Assert(m_hThread == NULL);

	m_hEvent = ::CreateEvent(
		NULL,
		FALSE, 
		FALSE,
		NULL);
	Report(m_hEvent != NULL);

	// Create a thread in suspended mode
	m_hThread = ::CreateThread(
		NULL,
		0,
		(LPTHREAD_START_ROUTINE)pThreadProc,
		this,
		CREATE_SUSPENDED,
		NULL);
	Report(m_hThread != NULL);

	// Display the dialog box, the dialog will resume the suspended thread
	(void)::DialogBoxParam(
		g_hInstanceSave,
		MAKEINTRESOURCE(IDD),
		m_hWndParent,
		&S_DlgProcControlService,
		reinterpret_cast<LPARAM>(this));	

	// Display an error message to the user (if an error occured);
	M_ProcessErrorCode();
	// Make a copy of the last error code
	APIERR dwLastError = m_dwLastError;
	// Indicate the thread is allowed to terminate and delete the 'this' pointer
	VERIFY(SetEvent(m_hEvent));
	// 'this' pointer cannot longer be assumed to be valid
	return dwLastError;
	} // M_EDoExecuteServiceThread()


/////////////////////////////////////////////////////////////////////
//	M_ProcessErrorCode()
//
//	Query the service status one last time to get its exit code,
//	examine the content of member m_dwLastError and display an
//	error message if an error occured.
//
void
CServiceControlProgress::M_ProcessErrorCode()
	{
	SERVICE_STATUS ss;
	::ZeroMemory( &ss, sizeof(ss) );

	if (m_hService != NULL)
		{
		// Query the service status again to get its Win32ExitCode
		if (!::QueryServiceStatus(m_hService, OUT &ss))
			{
			TRACE3("QueryServiceStatus(%s [hService=%p]) failed. err=%u.\n",
				m_szServiceName, m_hService, GetLastError());
			m_dwLastError = GetLastError();
			}
		else
			{
			if (ss.dwWin32ExitCode != ERROR_SUCCESS)
				m_dwLastError = ss.dwWin32ExitCode;
			}
		} // if

	APIERR dwLastError = m_dwLastError;
	UINT uIdString = IDS_MSG_sss_UNABLE_TO_START_SERVICE;
	TCHAR szMessageExtra[512];
	szMessageExtra[0] = _T('\0');
	
	switch (dwLastError)
		{
	case ERROR_SUCCESS:
		if (ss.dwCurrentState == rgdwExpectedServiceStatus[m_iServiceAction])
			{
			// The service status is consistent with the expected service status
			uIdString = 0;
			}
		else
			{
			// We got a problem here, the service did not return an error
			// but did not behave as expected
			//
			// JonN 12/3/99 418111 If the service stopped automatically,
			//              don't make such a fuss
			//
			if (SERVICE_RUNNING == rgdwExpectedServiceStatus[m_iServiceAction]
				&& (   ss.dwCurrentState == SERVICE_STOPPED
				    || ss.dwCurrentState == SERVICE_STOP_PENDING))
			{
				uIdString = IDS_MSG_sss_SERVICE_STOPPED_AUTOMATICALLY;
				break;
			}
			::LoadString(g_hInstanceSave, IDS_MSG_INTERNAL_ERROR,
				OUT szMessageExtra, LENGTH(szMessageExtra));
			Assert(lstrlen(szMessageExtra) > 0);
			}
		break;

	case errUserCancelStopDependentServices:
	case errUserAbort:
		// Do not report this 'error' to the user
		uIdString = 0;
		break;

	case ERROR_SERVICE_SPECIFIC_ERROR:
		dwLastError = ss.dwServiceSpecificExitCode;
		uIdString = IDS_MSG_ssd_SERVSPECIFIC_START_SERVICE;
		// 341363 JonN 6/1/99: no point in loading this string as if it were
		// a Win32 error
		//::LoadString(g_hInstanceSave, IDS_MSG_SPECIFIC_ERROR,
		//	OUT szMessageExtra, LENGTH(szMessageExtra));
		// Assert(lstrlen(szMessageExtra) > 0);
		break;
		} // switch

	if (uIdString != 0)
		{
		if (uIdString == IDS_MSG_ssd_SERVSPECIFIC_START_SERVICE)
			{
			DoServicesErrMsgBox(
				m_hWndParent, // 562331-2002/04/08-JonN not ::GetActiveWindow()
				MB_OK | MB_ICONEXCLAMATION,
				0,
				uIdString + m_iServiceAction,
				m_szServiceDisplayName,
				m_szUiMachineName,
				dwLastError);
			}
		else
			{
			DoServicesErrMsgBox(
				m_hWndParent, // 562331-2002/04/08-JonN not ::GetActiveWindow()
				MB_OK | MB_ICONEXCLAMATION,
				dwLastError,
				uIdString + m_iServiceAction,
				m_szServiceDisplayName,
				m_szUiMachineName,
				szMessageExtra);
			}
		}
	} // M_ProcessErrorCode()


/////////////////////////////////////////////////////////////////////
//	M_DoThreadCleanup()
//
//	Routine that synchronize the background thread with the dialog and
//	perform cleanup tasks.
//	This routine delete the 'this' pointer when done.
//
void
CServiceControlProgress::M_DoThreadCleanup()
	{
	TRACE1("CServiceControlProgress::M_DoThreadCleanup() - Waiting for event 0x%p...\n", m_hEvent);
	
	Assert(m_hEvent != NULL);
	// Wait for the the dialog box to be gone
	::WaitForSingleObject(m_hEvent, INFINITE);
	VERIFY(::CloseHandle(m_hEvent));

	// Close the service handle opened by the thread
	if (m_hService != NULL)
		{
		if (!::CloseServiceHandle(m_hService))
			{
			TRACE3("CloseServiceHandle(%s [hService=%p]) failed. err=%u.\n",
				m_szServiceName, m_hService, GetLastError());
			}
		} // if
	VERIFY(::CloseHandle(m_hThread));
	delete this;	// We are done with the object
	} // M_DoThreadCleanup()


/////////////////////////////////////////////////////////////////////
//	M_EControlService()
//
//	This function is just there to initialize variables to
//	perform a stop, pause, resume or restart operation.
//
APIERR
CServiceControlProgress::M_EControlService(DWORD dwControlCode)
	{
	Assert(m_fRestartService == FALSE);

	APIERR err = 0;
	m_dwControlCode = dwControlCode;
	switch (dwControlCode)
		{
	default:
		Assert(FALSE && "CServiceControlProgress::M_EControlService() - Unknown control code.");
		break;

	case SERVICE_CONTROL_RESTART:
		m_dwControlCode = SERVICE_CONTROL_STOP;
		m_fRestartService = TRUE;
		// Fall Through //

	case SERVICE_CONTROL_STOP:
		m_dwDesiredAccess = SERVICE_STOP | SERVICE_QUERY_STATUS;
		m_dwQueryState = SERVICE_STOP_PENDING;
		m_iServiceAction = iServiceActionStop;
		if (!M_FDlgStopDependentServices())
			{
			// User changed its mind by pressing the 'Cancel' button
			err = errUserCancelStopDependentServices;
			}
		else
			{
			// Stop the services (including dependent services)
			err = M_EDoExecuteServiceThread(S_ThreadProcStopService);
			}
		break;

	case SERVICE_CONTROL_PAUSE:
		m_dwDesiredAccess = SERVICE_PAUSE_CONTINUE | SERVICE_QUERY_STATUS;
		m_dwQueryState = SERVICE_PAUSE_PENDING;
		m_iServiceAction = iServiceActionPause;
		err = M_EDoExecuteServiceThread(S_ThreadProcPauseResumeService);
		break;

	case SERVICE_CONTROL_CONTINUE:
		m_dwDesiredAccess = SERVICE_PAUSE_CONTINUE | SERVICE_QUERY_STATUS;
		m_dwQueryState = SERVICE_CONTINUE_PENDING;
		m_iServiceAction = iServiceActionResume;
		err = M_EDoExecuteServiceThread(S_ThreadProcPauseResumeService);
		break;
		} // switch

	return err;
	} // M_EControlService()


/////////////////////////////////////////////////////////////////////
//	M_QueryCurrentServiceState()
//
//	Simply call the API ::QueryServiceStatus() and return dwCurrentState
//	of the SERVICE_STATUS structure.
//
//	RETURNS
//	Function return the current state of a service:
//		SERVICE_STOPPED				The service is not running.
//		SERVICE_START_PENDING		The service is starting.
//		SERVICE_STOP_PENDING		The service is stopping.
//		SERVICE_RUNNING				The service is running.
//		SERVICE_CONTINUE_PENDING	The service continue is pending.
//		SERVICE_PAUSE_PENDING		The service pause is pending.
//		SERVICE_PAUSED				The service is paused.
//
//	If an error occurs, the function will return SERVICE_STOPPED.
//
DWORD
CServiceControlProgress::M_QueryCurrentServiceState()
	{
	BOOL fRet;
	SERVICE_STATUS ss;

	Assert(m_hService != NULL);
	if (m_hService == NULL)	// Just in case
		{
		return SERVICE_STOPPED;
		}
	// Query the service status
	fRet = ::QueryServiceStatus(m_hService, OUT &ss);
	if (!fRet)
		{
		TRACE2("CServiceControlProgress::M_QueryCurrentServiceState() - ::QueryServiceStatus(%s) failed. err=%u\n",
			m_szServiceName, GetLastError());
		Assert(GetLastError() != ERROR_SUCCESS);
		m_dwLastError = GetLastError();
		return SERVICE_STOPPED;
		}
	return ss.dwCurrentState;
	} // M_QueryCurrentServiceState()


/////////////////////////////////////////////////////////////////////
//	Query the service database to get the friendly name and
//	display it into the dialog.
//
void CServiceControlProgress::M_UpdateDialogUI(LPCTSTR pszDisplayName)
	{
	Assert(pszDisplayName != NULL);
	if (m_hctlActionMsg == NULL || m_hctlServiceNameMsg == NULL)
		return;
	Assert(IsWindow(m_hctlActionMsg) && IsWindow(m_hctlServiceNameMsg));
	SetWindowTextPrintf(
		m_hctlActionMsg, 
		IDS_SVC_ss_SERVICE_STARTING + m_iServiceAction,
		pszDisplayName,
		m_szUiMachineName);
	SetWindowText( m_hctlServiceNameMsg, pszDisplayName );
	} // M_UpdateDialogUI()


/////////////////////////////////////////////////////////////////////
//	Routine to iterate through the dependent services to stop.
//
//	Return the the service name to stop, increment the 'pointer' to the
//	next service.  The routine returns FALSE if there are no remaining
//	services to stop.
//
//	REMARKS
//	This routine is also used to restart dependent services.
//
BOOL
CServiceControlProgress::M_FGetNextService(
	OUT LPCTSTR * ppszServiceName,
	OUT LPCTSTR * ppszDisplayName)
	{
	Assert(ppszServiceName != NULL);
	Assert(ppszDisplayName != NULL);
	Assert(m_iServiceAction == iServiceActionStop || m_iServiceAction == iServiceActionStart);

	int iDependentService = m_iDependentServiceIter;
	if (m_iServiceAction == iServiceActionStop)
		m_iDependentServiceIter++;
	else
		m_iDependentServiceIter--;
	if (m_pargServiceStop != NULL
		&& iDependentService >= 0 
		&& iDependentService <= m_cDependentServices)
		{
		*ppszServiceName = m_pargServiceStop[iDependentService].lpServiceName;
		*ppszDisplayName = m_pargServiceStop[iDependentService].lpDisplayName;
		}
	else
		{
		*ppszServiceName = m_szServiceName;
		*ppszDisplayName = m_szServiceDisplayName;
		}
	return (m_iDependentServiceIter >= 0 && m_iDependentServiceIter <= m_cDependentServices);
	} // M_FGetNextService()


/////////////////////////////////////////////////////////////////////
//	Thread to start one (or more) services.
DWORD
CServiceControlProgress::S_ThreadProcStartService(CServiceControlProgress * pThis)
	{
	BOOL fSuccess = FALSE;
	SC_HANDLE hService;

	Assert(pThis != NULL);
	Assert(pThis->m_hScManager != NULL);
	Assert(pThis->m_hService == NULL);
	Endorse(pThis->m_fPulseEvent == TRUE);	// We are starting multiple services
	Endorse(pThis->m_fPulseEvent == FALSE);	// Wa are starting only one service

	if (pThis->m_dwLastError != ERROR_SUCCESS)
		{
		// If there is already an error, it is because we attempted to previously stop a service
		Assert(pThis->m_fRestartService == TRUE);
		goto Done;
		}

	while (TRUE)
		{
		LPCTSTR pszServiceName;
		LPCTSTR pszServiceDisplayName;
		UINT cServicesRemaining = pThis->M_FGetNextService(
			OUT &pszServiceName,
			OUT &pszServiceDisplayName);

		pThis->M_UpdateDialogUI(pszServiceDisplayName);
		// Sleep(5000);	// Debug

		// Open service to allow a 'start' operation
		hService = ::OpenService(
			pThis->m_hScManager,
			pszServiceName,
			SERVICE_START | SERVICE_QUERY_STATUS);
		if (hService == NULL)
			{
			pThis->m_dwLastError = GetLastError();
			TRACE2("ERR: S_ThreadProcStartService(): Unable to open service %s to start. err=%u.\n",
				pszServiceName, pThis->m_dwLastError);
			break;
			}
		fSuccess = ::StartService(
			hService,
			pThis->m_dwNumServiceArgs,
			pThis->m_lpServiceArgVectors);
		if (!fSuccess)
			{
			APIERR err = GetLastError();
			if (ERROR_SERVICE_ALREADY_RUNNING != err)
				{
				pThis->m_dwLastError = err;
				TRACE2("ERR: S_ThreadProcStartService(): StartService(%s) returned err=%u.\n",
					pszServiceName, pThis->m_dwLastError);
				break;
				}
			}
		Assert(pThis->m_hService == NULL);
		if (cServicesRemaining == 0)
			{
			// This was our last service to start
			pThis->m_fPulseEvent = FALSE;
			pThis->m_hService = hService;
			break;
			}
		Assert(pThis->m_fPulseEvent == TRUE);
		pThis->m_hService = hService;
		// Wait until the service was actually 'started'
		WaitForSingleObject(pThis->m_hEvent, INFINITE);
		pThis->m_hService = NULL;
		Assert(hService != NULL);
		VERIFY(::CloseServiceHandle(hService));
		} // while
Done:
	pThis->M_DoThreadCleanup();
	return 0;
	} // S_ThreadProcStartService()


/////////////////////////////////////////////////////////////////////
//	Thread to stop one (or more) services.
DWORD
CServiceControlProgress::S_ThreadProcStopService(CServiceControlProgress * pThis)
	{
	BOOL fSuccess;
	SC_HANDLE hService;

	Assert(pThis != NULL);
	Assert(pThis->m_hScManager != NULL);
	Assert(pThis->m_dwDesiredAccess & SERVICE_STOP);
	Assert(pThis->m_hService == NULL);
	Assert(pThis->m_fPulseEvent == FALSE);

	//
	//	Stop the dependent services
	//
	while (TRUE)
		{
		LPCTSTR pszServiceName;
		LPCTSTR pszServiceDisplayName;
		UINT cServicesRemaining = pThis->M_FGetNextService(
			OUT &pszServiceName,
			OUT &pszServiceDisplayName);

		pThis->M_UpdateDialogUI(pszServiceDisplayName);
		// Sleep(5000);	// Debug

		hService = ::OpenService(
			pThis->m_hScManager,
			pszServiceName,
			pThis->m_dwDesiredAccess);
		if (hService == NULL)
			{
			pThis->m_dwLastError = GetLastError();
			TRACE2("ERR: S_ThreadProcStopService(): Unable to open dependent service %s to stop. err=%u.\n",
				pszServiceName, pThis->m_dwLastError);
			break;
			}
		SERVICE_STATUS ss;	// Ignored
		fSuccess = ::ControlService(
			hService,
			pThis->m_dwControlCode,
			OUT IGNORED &ss);
		if (!fSuccess)
			{
			APIERR err = GetLastError();
			if (ERROR_SERVICE_NOT_ACTIVE != err)
				{
				TRACE2("ERR: S_ThreadProcStopService(): ControlService(%s) returned err=%u.\n",
					pszServiceName, pThis->m_dwLastError);
				break;
				}
			}

		Assert(pThis->m_hService == NULL);
		if (cServicesRemaining == 0 && !pThis->m_fRestartService)
			{
			// This was our last service to stop
			pThis->m_fPulseEvent = FALSE;
			pThis->m_hService = hService;
			break; // We are done
			}
		else
			{
			pThis->m_fPulseEvent = TRUE;
			pThis->m_hService = hService;
			}

		// Wait until the service was actually 'stopped'
		WaitForSingleObject(pThis->m_hEvent, INFINITE);
		pThis->m_hService = NULL;
		Assert(hService != NULL);
		VERIFY(::CloseServiceHandle(hService));

		if (cServicesRemaining == 0)
			{
			Assert(pThis->m_fRestartService == TRUE);
			Assert(pThis->m_fPulseEvent == TRUE);
			
			// Start the service
			Assert(pThis->m_dwNumServiceArgs == 0);
			Assert(pThis->m_lpServiceArgVectors == NULL);
			pThis->m_iDependentServiceIter = pThis->m_cDependentServices;	// Rewind the service iterator
			pThis->m_dwQueryState = SERVICE_START_PENDING;
			pThis->m_iServiceAction = iServiceActionStart;
			(void)S_ThreadProcStartService(pThis);
			return 0;
			}
		} // while

	pThis->M_DoThreadCleanup();
	return 0;
	} // S_ThreadProcStopService()


/////////////////////////////////////////////////////////////////////
//	Thread to pause or resume the service
DWORD CServiceControlProgress::S_ThreadProcPauseResumeService(CServiceControlProgress * pThis)
	{
	BOOL fSuccess;
	SC_HANDLE hService;
	SERVICE_STATUS ss;

	Assert(pThis != NULL);
	Assert(pThis->m_hScManager != NULL);
	Assert(pThis->m_dwDesiredAccess & SERVICE_PAUSE_CONTINUE);
	Assert(pThis->m_hService == NULL);
	Assert(pThis->m_fPulseEvent == FALSE);

	pThis->M_UpdateDialogUI(pThis->m_szServiceDisplayName);

	// Open service to allow a 'pause' or 'resume' operation
	hService = ::OpenService(
		pThis->m_hScManager,
		pThis->m_szServiceName,
		pThis->m_dwDesiredAccess);
	if (hService == NULL)
		{
		pThis->m_dwLastError = GetLastError();
		TRACE2("ERR: S_ThreadProcPauseResumeService(): Unable to open service %s. err=%u.\n",
			pThis->m_szServiceName, pThis->m_dwLastError);
		goto Done;
		}
	fSuccess = ::ControlService(
		hService,
		pThis->m_dwControlCode,
		OUT IGNORED &ss);
	if (!fSuccess)
		{
		pThis->m_dwLastError = GetLastError();
		TRACE2("ERR: S_ThreadProcPauseResumeService(): ControlService(%s) returned err=%u.\n",
			pThis->m_szServiceName, pThis->m_dwLastError);
		}
	Assert(pThis->m_hService == NULL);
	pThis->m_hService = hService;
Done:
	pThis->M_DoThreadCleanup();
	return 0;
	} // S_ThreadProcPauseResumeService()


/////////////////////////////////////////////////////////////////////
//	S_DlgProcControlService()
//
//	Dialog proc for the clock dialog
//		- Respond to a WM_TIMER message to update the clock bitmap while
//		  waiting for the operation to complete.
//
INT_PTR CALLBACK
CServiceControlProgress::S_DlgProcControlService(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
	CServiceControlProgress * pThis;
	
	pThis = (CServiceControlProgress*)GetWindowLongPtr(hdlg, DWLP_USER);
	switch (uMsg)
		{
	case WM_INITDIALOG:
		pThis = reinterpret_cast<CServiceControlProgress *>(lParam);
		Assert(pThis != NULL);
		pThis->M_OnInitDialog(hdlg);
		break;

	case WM_TIMER:
		Assert(pThis != NULL);
		Assert(wParam == pThis->m_uTimerId);
		pThis->M_OnTimer(hdlg);
		break;

	case WM_COMMAND:
		Assert(wParam == IDOK || wParam == IDCANCEL);
		if (wParam == IDCANCEL)
			{
			if ((HWND)lParam != NULL)
				{
				TRACE1("INFO: User cancelled dialog. dwLastError=%u.\n",
					pThis->m_dwLastError);
				pThis->m_dwLastError = errUserAbort;
				}
			EndDialog(hdlg, FALSE);
			}
		else
			{
			Assert(IsWindow(pThis->m_hctlProgress));
			SendMessage(pThis->m_hctlProgress, PBM_SETPOS, dwTimerProgressDone * 2, 0); 
			Sleep(150);
			EndDialog (hdlg, TRUE);
			}
		break;

	case WM_DESTROY:
		Assert(IsWindow(pThis->m_hctlActionMsg) && IsWindow(pThis->m_hctlServiceNameMsg));
		pThis->m_hctlActionMsg = NULL;
		pThis->m_hctlServiceNameMsg = NULL;
		if (pThis->m_uTimerId != 0)
			{
			VERIFY(KillTimer(hdlg, pThis->m_uTimerId));
			}
		break;

	default:
		return FALSE;
		} // switch (uMsg)

	return (TRUE);
	} // S_DlgProcControlService()


/////////////////////////////////////////////////////////////////////
void
CServiceControlProgress::M_OnInitDialog(HWND hdlg)
	{
	Assert(IsWindow(hdlg));
	SetWindowLongPtr(hdlg, DWLP_USER, reinterpret_cast<LONG_PTR>(this));
	m_hctlActionMsg = HGetDlgItem(hdlg, IDC_STATIC_ACTION_MSG);
	m_hctlServiceNameMsg = HGetDlgItem(hdlg, IDC_STATIC_SERVICENAME_MSG);
	m_hctlProgress = HGetDlgItem(hdlg, IDC_PROGRESS);
	SendMessage(m_hctlProgress, PBM_SETRANGE, 0, MAKELPARAM(0, dwTimerProgressDone * 2)); 

	Assert(m_uTimerId == 0);
	Assert(m_dwTimerTicks == 0);
	m_uTimerId = SetTimer(hdlg, ID_TIMER, dwTimerTickIncrement, NULL);
	Assert(m_hThread != NULL);
	::ResumeThread(m_hThread);
	if (m_uTimerId == 0)
		{
		Report(FALSE && "Unable to create timer. Dialog will be destroyed.");
		PostMessage(hdlg, WM_COMMAND, IDCANCEL, 0);
		}
	} // M_OnInitDialog()


/////////////////////////////////////////////////////////////////////
void
CServiceControlProgress::M_OnTimer(HWND hdlg)
	{
	Assert(IsWindow(m_hctlActionMsg) && IsWindow(m_hctlServiceNameMsg));
	m_dwTimerTicks += dwTimerTickIncrement;
	if (m_dwLastError != ERROR_SUCCESS)
		{
		TRACE1("CServiceControlProgress::M_OnTimer() - dwLastError=%u.\n", m_dwLastError);
		PostMessage(hdlg, WM_COMMAND, IDCANCEL, 0);
		return;
		}
	if (m_dwTimerTicks > dwTimerTimeout)
		{
		VERIFY(KillTimer(hdlg, m_uTimerId));
		m_uTimerId = 0;
		m_dwLastError = ERROR_SERVICE_REQUEST_TIMEOUT;
		TRACE0("CServiceControlProgress::M_OnTimer() - Time out.\n");
		PostMessage(hdlg, WM_COMMAND, IDCANCEL, 0);
		return;
		}
	if ((m_hService != NULL) && (m_dwTimerTicks >= 900))
		{
		// If the current state of the service changed (ie, operation completed)
		// we can dismiss the dialog
		if (m_dwQueryState != M_QueryCurrentServiceState())
			{
			if (m_fPulseEvent)
				{
				m_dwTimerTicks = 0;		// Reset the time-out counter
				Assert(m_hEvent != NULL);
				PulseEvent(m_hEvent);
				SendMessage(m_hctlProgress, PBM_SETPOS, dwTimerProgressDone * 2, 0);
				Sleep(100);
				}
			else
				{
				PostMessage(hdlg, WM_COMMAND, IDOK, 0);
				}
			}
		} // if

	// Advance the current position of the progress bar by the increment. 
	Assert(IsWindow(m_hctlProgress));
	DWORD dwPos = m_dwTimerTicks;
	if(dwPos > dwTimerProgressDone)
		{
		dwPos -= dwTimerProgressDone;
		dwPos = (dwPos * dwTimerProgressDone) / dwTimerTimeout;
		dwPos += dwTimerProgressDone;
		}
	SendMessage(m_hctlProgress, PBM_SETPOS, dwPos, 0); 
	} // M_OnTimer()


/////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK
CServiceControlProgress::S_DlgProcDependentServices(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
	CServiceControlProgress * pThis;
	HWND hwndListbox;
	INT i;

	switch (uMsg)
		{
	case WM_INITDIALOG:
		pThis = reinterpret_cast<CServiceControlProgress *>(lParam);
		Assert(pThis != NULL);
		SetWindowTextPrintf( ::GetDlgItem(hdlg, IDC_STATIC_STOP_SERVICES),
		                     (pThis->m_fRestartService)
		                        ? IDS_SVC_s_RESTART_DEPENDENT_SERVICES
		                        : IDS_SVC_s_STOP_DEPENDENT_SERVICES,
		                     pThis->m_szServiceDisplayName);
		if (pThis->m_fRestartService)
		{
			// Set the window caption
			SetWindowTextPrintf(hdlg, IDS_SVC_RESTART_DEPENDENT_CAPTION);
			SetWindowTextPrintf(::GetDlgItem(hdlg, IDC_STATIC_STOP_SERVICES_QUERY),
			                    IDS_SVC_RESTART_DEPENDENT_QUERY);
		}
		// Fill in the listbox with dependent services
		hwndListbox = HGetDlgItem(hdlg, IDC_LIST_SERVICES);
		Assert(pThis->m_pargDependentServicesT != NULL);
		for (i = 0; i < pThis->m_cDependentServices; i++)
			{
			SendMessage(hwndListbox, LB_ADDSTRING, 0,
				(LPARAM)pThis->m_pargDependentServicesT[i].lpDisplayName);
			}
		break;

	case WM_COMMAND:
		switch (wParam)
			{
		case IDOK:
			EndDialog(hdlg, TRUE);
			break;
		case IDCANCEL:
			EndDialog(hdlg, FALSE);
			break;
			}
		break;

    case WM_CONTEXTMENU:      // right mouse click
		DoContextHelp(wParam, HELP_DIALOG_TOPIC(IDD_SERVICE_STOP_DEPENDENCIES));
		break;

	case WM_HELP:
		DoHelp(lParam, HELP_DIALOG_TOPIC(IDD_SERVICE_STOP_DEPENDENCIES));
		break;

	default:
		return FALSE;
		} // switch (uMsg)
	return TRUE;

	} // S_DlgProcDependentServices()


/////////////////////////////////////////////////////////////////////
//	S_EStartService()
//
//	Starts the execution of a service synchronously. The function will wait
//	until the service is fully started and/or failed to start.
//
//	A clock dialog will appear indicating the progress of the operation.
//
//	Return ERROR_SUCCESS if syccessful, otherwise return the error code
//	from GetLastError().
//
APIERR
CServiceControlProgress::S_EStartService(
	HWND hwndParent,				// IN: Parent of the dialog
	SC_HANDLE hScManager,			// IN: Handle to service control manager database 
	LPCTSTR pszMachineName,			// IN: Machine name to display to the user
	LPCTSTR pszServiceName,			// IN: Name of the service to start
	LPCTSTR pszServiceDisplayName,	// IN: Display name of the service to start
	DWORD dwNumServiceArgs,			// IN: Number of arguments 
	LPCTSTR * lpServiceArgVectors)	// IN: Address of array of argument string pointers  
	{
	CServiceControlProgress * pThis;

	pThis = new CServiceControlProgress;
	Assert(pThis->m_dwLastError == ERROR_SUCCESS);	// No error yet

	if (!pThis->M_FInit(
		hwndParent,
		hScManager,
		pszMachineName,
		pszServiceName,
		pszServiceDisplayName))
		{
		delete pThis;
		return errCannotInitialize;
		}
	
	pThis->m_dwNumServiceArgs = dwNumServiceArgs;
	pThis->m_lpServiceArgVectors = lpServiceArgVectors;
	pThis->m_dwQueryState = SERVICE_START_PENDING;
	pThis->m_iServiceAction = iServiceActionStart;
	
	return pThis->M_EDoExecuteServiceThread(S_ThreadProcStartService);
	} // S_EStartService()


/////////////////////////////////////////////////////////////////////
//	S_EControlService()
//
//	Control the execution of a service synchronously. The function is similar
//	to EStartService() but use for Stop, Pause or Resume a service.
//
//	A clock dialog will appear indicating the progress of the operation.
//
//	Return ERROR_SUCCESS if syccessful, otherwise return the error code
//	from GetLastError().
//
APIERR
CServiceControlProgress::S_EControlService(
	HWND hwndParent,				// IN: Parent of the dialog
	SC_HANDLE hScManager,			// IN: Handle to service control manager database 
	LPCTSTR pszMachineName,			// IN: Machine name to display to the user
	LPCTSTR pszServiceName,			// IN: Name of the service to start
	LPCTSTR pszServiceDisplayName,	// IN: Display name of the service to start
	DWORD dwControlCode)			// IN: Control code.  (SERVICE_CONTROL_STOP, SERVICE_CONTROL_PAUSE or SERVICE_CONTROL_CONTINUE)
	{
	CServiceControlProgress * pThis;

	pThis = new CServiceControlProgress;
	Assert(pThis->m_dwLastError == ERROR_SUCCESS);	// No error yet

	if (!pThis->M_FInit(
		hwndParent,
		hScManager,
		pszMachineName,
		pszServiceName,
		pszServiceDisplayName))
		{
		delete pThis;
		return errCannotInitialize;
		}

	return pThis->M_EControlService(dwControlCode);
	} // S_EControlService()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\sfm.cpp ===
// sfm.cpp : SFM shares, sessions and open resources

/* 
History:

  1/24/97 JonN
I have looked over the enumeration API usage in SFMMGR.CPL:
The Users dialog uses AfpAdminSessionEnum for the upper LB and
  AfpAdminConnectionEnum for the lower LB.
The Volumesdialog uses AfpAdminVolumeEnum for the upper LB and
  AfpAdminConnectionEnum for the lower LB.
The Files dialog uses AfpAdminFileEnum for single LB.
    
  8/20/97 EricDav
Added code to support the SFM property sheet. The following 
functions were added:
    DisplaySfmProperties()
    CleanupSfmProperties();
    UserHasAccess();
    SetSfmPropSheet();

The SFM prop sheet is a modeless prop sheet and is global for 
a machine running SFM.

  4/16/98 EricDav
Added code to properly check if SFM is installed and running.
Able to start the service as necessary.

*/

#include "stdafx.h"
#include "cmponent.h"
#include "safetemp.h"
#include "FileSvc.h"
#include "DynamLnk.h"    // DynamicDLL
#include "ShrPgSFM.h"    // Share Properties Page
#include "compdata.h"
#include "progress.h"       // service control progress dialog
#include "dataobj.h"

#include "sfm.h"
#include "sfmutil.h"        // Support for the SFM config prop sheet

#define DONT_WANT_SHELLDEBUG
#include "shlobjp.h"     // LPITEMIDLIST
#include "wraps.h"       // Wrap_ILCreateFromPath   

#include "macros.h"
USE_HANDLE_MACROS("FILEMGMT(sfm.cpp)")

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DynamicDLL g_SfmDLL( _T("SFMAPI.DLL"), g_apchFunctionNames );

SfmFileServiceProvider::SfmFileServiceProvider( CFileMgmtComponentData* pFileMgmtData )
  : m_ulSFMServerConnection( NULL ),
      m_pSfmPropSheet(NULL),
    // not subject to localization
    FileServiceProvider( pFileMgmtData )
{
    VERIFY( m_strTransportSFM.LoadString( IDS_TRANSPORT_SFM ) );
}

SfmFileServiceProvider::~SfmFileServiceProvider()
{
    CleanupSfmProperties();
  SFMDisconnect();
}

typedef DWORD (*CONNECTPROC) (LPWSTR,PAFP_SERVER_HANDLE);
typedef DWORD (*DISCONNECTPROC) (AFP_SERVER_HANDLE);

BOOL SfmFileServiceProvider::SFMConnect(LPCWSTR pwchServerName, BOOL fDisplayError)
{
  if (NULL != m_ulSFMServerConnection)
  {
    if (NULL == pwchServerName)
    {
      if (0 == m_ulSFMServerConnectionMachine.GetLength() )
        return TRUE; // already connected to local machine
    }
    else
    {
      if (0 == lstrcmpi(m_ulSFMServerConnectionMachine, pwchServerName))
        return TRUE; // already connected to this machine
    }
    SFMDisconnect();
    ASSERT (NULL == m_ulSFMServerConnection);
  }
  if ( !g_SfmDLL.LoadFunctionPointers() )
    return S_OK;
    DWORD retval = ((CONNECTPROC)g_SfmDLL[AFP_CONNECT])(
    const_cast<LPWSTR>(pwchServerName),
    &m_ulSFMServerConnection );
  if ( 0 != retval )
  {
    ASSERT( NULL == m_ulSFMServerConnection );
    m_ulSFMServerConnection = NULL;
    m_ulSFMServerConnectionMachine = _T("");
    if (fDisplayError)
    {
      (void) DoErrMsgBox(GetActiveWindow(), MB_OK | MB_ICONSTOP, retval, IDS_POPUP_SFM_CONNECT, pwchServerName );
    }
    return FALSE;
  } else
  {
    m_ulSFMServerConnectionMachine = 
      (pwchServerName ? pwchServerName : _T(""));
  }

  return TRUE;
}

void SfmFileServiceProvider::SFMDisconnect()
{
  if (NULL == m_ulSFMServerConnection)
    return;
  if ( !g_SfmDLL.LoadFunctionPointers() )
    return;
    ((DISCONNECTPROC)g_SfmDLL[AFP_DISCONNECT])(
    m_ulSFMServerConnection );
  m_ulSFMServerConnection = NULL;
}

/*
DWORD
AfpAdminVolumeEnum(
    IN  AFP_SERVER_HANDLE  hAfpServer,
    OUT  LPBYTE *      lpbBuffer,
    IN  DWORD        dwPrefMaxLen,
    OUT  LPDWORD        lpdwEntriesRead,
    OUT  LPDWORD        lpdwTotalEntries,
    IN  LPDWORD        lpdwResumeHandle
);
*/
typedef DWORD (*VOLUMEENUMPROC) (AFP_SERVER_HANDLE,LPBYTE*,DWORD,LPDWORD,LPDWORD,LPDWORD);

HRESULT SfmFileServiceProvider::PopulateShares(
  IResultData* pResultData,
  CFileMgmtCookie* pcookie)
{
  TEST_NONNULL_PTR_PARAM(pcookie);

  if ( !g_SfmDLL.LoadFunctionPointers() )
    return S_OK;

  if ( !SFMConnect(pcookie->QueryTargetServer()) )
    return S_OK;

    AFP_VOLUME_INFO* pvolumeinfo = NULL;
    DWORD dwEntriesRead = 0;
    DWORD dwTotalEntries = 0;
    DWORD hEnumHandle = 0;
    HRESULT hr = S_OK;
    NET_API_STATUS retval = NERR_Success;
    do {
        retval = ((VOLUMEENUMPROC)g_SfmDLL[AFP_VOLUME_ENUM])(
            m_ulSFMServerConnection,
      (PBYTE*)&pvolumeinfo,
      (DWORD)-1L,
      &dwEntriesRead,
      &dwTotalEntries,
      &hEnumHandle );
        if (NERR_Success == retval)
        {
            hr = AddSFMShareItems( pResultData, pcookie, pvolumeinfo, dwEntriesRead );
            pvolumeinfo = NULL;
            break;
        } else if (ERROR_MORE_DATA == retval) {
            ASSERT( NULL != hEnumHandle );
            hr = AddSFMShareItems( pResultData, pcookie, pvolumeinfo, dwEntriesRead );
            pvolumeinfo = NULL;
            continue;
        } else if (RPC_S_SERVER_UNAVAILABLE == retval && 0 == hEnumHandle) {
      // SFM just isn't installed, don't worry about it
            retval = NERR_Success;  
            break;
        } else {
            if (ERROR_ACCESS_DENIED == retval)
            {
                (void) DoErrMsgBox(
                            GetActiveWindow(), 
                            MB_OK | MB_ICONSTOP, 
                            0,
                            IDS_POPUP_SFM_SHARES_NOACCESS
                            );
            } else
            {
                (void) DoErrMsgBox(
                            GetActiveWindow(), 
                            MB_OK | MB_ICONSTOP, 
                            retval, 
                            IDS_POPUP_SFM_SHARES
                            );
            }
            break;
        }
    } while (S_OK == hr);

    return HRESULT_FROM_WIN32(retval);
}

/*
typedef enum _COLNUM_SHARES {
  COLNUM_SHARES_SHARED_FOLDER = 0,
  COLNUM_SHARES_SHARED_PATH,
  COLNUM_SHARES_TRANSPORT,
  COLNUM_SHARES_NUM_SESSIONS,
  COLNUM_SHARES_COMMENT
} COLNUM_SHARES;

typedef struct _AFP_VOLUME_INFO
{
  LPWSTR  afpvol_name;        // Name of the volume max.
  DWORD  afpvol_id;          // id of this volume. generated by sever
  LPWSTR  afpvol_password;      // Volume password, max. AFP_VOLPASS_LEN
  DWORD  afpvol_max_uses;      // Max opens allowed
  DWORD  afpvol_props_mask;      // Mask of volume properties
  DWORD  afpvol_curr_uses;      // Number of curr open connections.
  LPWSTR  afpvol_path;        // The actual path
                    // Ignored for VolumeSetInfo
} AFP_VOLUME_INFO, *PAFP_VOLUME_INFO;
*/

HRESULT SfmFileServiceProvider::AddSFMShareItems(
    IResultData* pResultData,
    CFileMgmtCookie* pParentCookie,
    PVOID pinfo,
    DWORD nItems)
{
  TEST_NONNULL_PTR_PARAM(pParentCookie);
  TEST_NONNULL_PTR_PARAM(pinfo);

  if (0 >= nItems)
    return S_OK;

    RESULTDATAITEM tRDItem;
  ::ZeroMemory( &tRDItem, sizeof(tRDItem) );
  // CODEWORK should use MMC_ICON_CALLBACK
  tRDItem.nCol = COLNUM_SHARES_SHARED_FOLDER;
  tRDItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
  tRDItem.str = MMC_CALLBACK;

    AFP_VOLUME_INFO* pvolumeinfo = (AFP_VOLUME_INFO*)pinfo;

  DWORD nItemsToAdd = 0;
  for (DWORD i = 0; i < nItems; i++ )
  {
      if (!IsInvalidSharename(pvolumeinfo[i].afpvol_name))
          nItemsToAdd++;
  }

  CSfmShareCookie* pcookiearray = new CSfmShareCookie[nItemsToAdd];
  CSfmCookieBlock* pCookieBlock = new CSfmCookieBlock(
    pcookiearray,nItemsToAdd,pParentCookie->QueryTargetServer(),pinfo );
  pParentCookie->m_listResultCookieBlocks.AddHead( pCookieBlock );

  CString str;

    for ( ; nItems > 0; nItems--, pvolumeinfo++, pcookiearray++ )
    {
        if (IsInvalidSharename(pvolumeinfo->afpvol_name))
            continue;

        pcookiearray->m_pobject = pvolumeinfo;
        // WARNING cookie cast
        tRDItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pcookiearray);

        if (pvolumeinfo->afpvol_path &&
            lstrlen(pvolumeinfo->afpvol_path) == 3 &&
            *(pvolumeinfo->afpvol_path + 1) == _T(':') &&
            *(pvolumeinfo->afpvol_path + 2) == _T('\\') &&
            (*pvolumeinfo->afpvol_path >= _T('a') && *pvolumeinfo->afpvol_path <= _T('z') ||
            *pvolumeinfo->afpvol_path >= _T('A') && *pvolumeinfo->afpvol_path <= _T('Z')))
        {
            tRDItem.nImage = iIconSFMShare;
        } else
        {
            tRDItem.nImage = iIconSFMShareFolder;
        }

        HRESULT hr = pResultData->InsertItem(&tRDItem);
        ASSERT(SUCCEEDED(hr));
    }

    return S_OK;
}

/*
DWORD
AfpAdminSessionEnum(
    IN  AFP_SERVER_HANDLE  hAfpServer,
    OUT  LPBYTE *      lpbBuffer,
    IN  DWORD        dwPrefMaxLen,
    OUT  LPDWORD        lpdwEntriesRead,
    OUT  LPDWORD        lpdwTotalEntries,
    IN  LPDWORD        lpdwResumeHandle
);
*/

typedef DWORD (*SESSIONENUMPROC) (AFP_SERVER_HANDLE,LPBYTE*,DWORD,LPDWORD,LPDWORD,LPDWORD);

//   if pResultData is not NULL, add sessions/resources to the listbox
//   if pResultData is NULL, delete all sessions/resources
//   if pResultData is NULL, return SUCCEEDED(hr) to continue or
//     FAILED(hr) to abort
HRESULT SfmFileServiceProvider::EnumerateSessions(
  IResultData* pResultData,
  CFileMgmtCookie* pcookie,
  bool bAddToResultPane)
{
  TEST_NONNULL_PTR_PARAM(pcookie);

  if ( !g_SfmDLL.LoadFunctionPointers() )
    return S_OK;

  if ( !SFMConnect(pcookie->QueryTargetServer()) )
    return S_OK;

    AFP_SESSION_INFO* psessioninfo = NULL;
    DWORD dwEntriesRead = 0;
    DWORD dwTotalEntries = 0;
    DWORD hEnumHandle = 0;
    HRESULT hr = S_OK;
    NET_API_STATUS retval = NERR_Success;
    do {
        retval = ((SESSIONENUMPROC)g_SfmDLL[AFP_SESSION_ENUM])(
            m_ulSFMServerConnection,
      (PBYTE*)&psessioninfo,
      (DWORD)-1L,
      &dwEntriesRead,
      &dwTotalEntries,
      &hEnumHandle );
        if (NERR_Success == retval)
        {
            hr = HandleSFMSessionItems( pResultData, pcookie, psessioninfo, dwEntriesRead,
          bAddToResultPane);
            psessioninfo = NULL;
            break;
        } else if (ERROR_MORE_DATA == retval) {
            ASSERT( NULL != hEnumHandle );
            hr = HandleSFMSessionItems( pResultData, pcookie, psessioninfo, dwEntriesRead,
          bAddToResultPane);
            psessioninfo = NULL;
            continue;
        } else if (RPC_S_SERVER_UNAVAILABLE == retval && 0 == hEnumHandle) {
      // SFM just isn't installed, don't worry about it
            retval = NERR_Success;  
            break;
        } else {
            if (ERROR_ACCESS_DENIED == retval)
            {
                (void) DoErrMsgBox(
                            GetActiveWindow(), 
                            MB_OK | MB_ICONSTOP, 
                            0,
                            IDS_POPUP_SFM_SESSIONS_NOACCESS
                            );
            } else
            {
                (void) DoErrMsgBox(
                            GetActiveWindow(), 
                            MB_OK | MB_ICONSTOP, 
                            retval, 
                            IDS_POPUP_SFM_SESSIONS
                            );
            }
            break;
        }
    } while (S_OK == hr);

    return HRESULT_FROM_WIN32(retval);
}


/*
typedef enum _COLNUM_SESSIONS {
  COLNUM_SESSIONS_USERNAME = 0,
  COLNUM_SESSIONS_COMPUTERNAME,
  COLNUM_SESSIONS_NUM_FILES,
  COLNUM_SESSIONS_CONNECTED_TIME,
  COLNUM_SESSIONS_IDLE_TIME,
  COLNUM_SESSIONS_IS_GUEST
} COLNUM_SESSIONS;

typedef struct _AFP_SESSION_INFO
{
  DWORD  afpsess_id;          // Id of the session
  LPWSTR  afpsess_ws_name;      // Workstation Name,
  LPWSTR  afpsess_username;      // User Name, max. UNLEN
  DWORD  afpsess_num_cons;      // Number of open volumes
  DWORD  afpsess_num_opens;      // Number of open files
  LONG  afpsess_time;        // Time session established
  DWORD  afpsess_logon_type;      // How the user logged on

} AFP_SESSION_INFO, *PAFP_SESSION_INFO;

  ShirishK 1/24/97:
  afpsess_logon_type: tells you how the user is logged on:
     0 -> Guest, 2 -> the standard MS way, 3 -> Admin
*/



HRESULT SfmFileServiceProvider::HandleSFMSessionItems(
    IResultData* pResultData,
    CFileMgmtCookie* pParentCookie,
    PVOID pinfo,
    DWORD nItems,
    BOOL bAddToResultPane)
{
  TEST_NONNULL_PTR_PARAM(pParentCookie);
  TEST_NONNULL_PTR_PARAM(pinfo);

  if (0 >= nItems)
    return S_OK;

  BOOL fDeleteAllItems = (NULL == pResultData);

    RESULTDATAITEM tRDItem;
  ::ZeroMemory( &tRDItem, sizeof(tRDItem) );
  // CODEWORK should use MMC_ICON_CALLBACK
  tRDItem.nImage = iIconSFMSession;
  tRDItem.nCol = COLNUM_SESSIONS_USERNAME;
  tRDItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
  tRDItem.str = MMC_CALLBACK;

  AFP_SESSION_INFO* psessioninfo = (AFP_SESSION_INFO*)pinfo;

  CSfmSessionCookie* pcookiearray = new CSfmSessionCookie[nItems];
  CSfmCookieBlock* pCookieBlock = new CSfmCookieBlock(
    pcookiearray,nItems,pParentCookie->QueryTargetServer(),pinfo );
  bool  bAdded = false;
  if ( !fDeleteAllItems || !bAddToResultPane )
  {
    pParentCookie->m_listResultCookieBlocks.AddHead( pCookieBlock );
    bAdded = true;
  }

  for ( ; nItems > 0; nItems--, psessioninfo++, pcookiearray++ )
  {
    pcookiearray->m_pobject = psessioninfo;

    if ( bAddToResultPane )
    {
      if (fDeleteAllItems)
      {
        DWORD dwApiResult = CloseSession( pcookiearray );
        if (0L != dwApiResult)
        {
            CString strName;
            TranslateIPToComputerName(psessioninfo->afpsess_ws_name, strName);
          (void) DoErrMsgBox(GetActiveWindow(), MB_OK | MB_ICONSTOP, dwApiResult,
            IDS_POPUP_SFM_DISCONNECTALLSESSION_ERROR,
            strName );
          //return S_FALSE;
        }
        continue;
      }

      // WARNING cookie cast
      tRDItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pcookiearray);
      HRESULT hr = pResultData->InsertItem(&tRDItem);
      ASSERT(SUCCEEDED(hr));
    }
  }

  if ( !bAdded ) // they were not added to the parent cookie's list
    delete pCookieBlock;

    return S_OK;
}


/*
DWORD
AfpAdminFileEnum(
    IN  AFP_SERVER_HANDLE  hAfpServer,
    OUT  LPBYTE *      lpbBuffer,
    IN  DWORD        dwPrefMaxLen,
    OUT  LPDWORD        lpdwEntriesRead,
    OUT  LPDWORD        lpdwTotalEntries,
    IN  LPDWORD        lpdwResumeHandle
);
*/

typedef DWORD (*FILEENUMPROC) (AFP_SERVER_HANDLE,LPBYTE*,DWORD,LPDWORD,LPDWORD,LPDWORD);

//   if pResultData is not NULL, add sessions/resources to the listbox
//   if pResultData is NULL, delete all sessions/resources
//   if pResultData is NULL, return SUCCEEDED(hr) to continue or
//     FAILED(hr) to abort
HRESULT SfmFileServiceProvider::EnumerateResources(
  IResultData* pResultData,
  CFileMgmtCookie* pcookie)
{
  TEST_NONNULL_PTR_PARAM(pcookie);

  if ( !g_SfmDLL.LoadFunctionPointers() )
    return S_OK;

  if ( !SFMConnect(pcookie->QueryTargetServer()) )
    return S_OK;

    AFP_FILE_INFO* pfileinfo = NULL;
    DWORD dwEntriesRead = 0;
    DWORD dwTotalEntries = 0;
    DWORD hEnumHandle = 0;
    HRESULT hr = S_OK;
    NET_API_STATUS retval = NERR_Success;
    do {
        retval = ((FILEENUMPROC)g_SfmDLL[AFP_FILE_ENUM])(
            m_ulSFMServerConnection,
      (PBYTE*)&pfileinfo,
      (DWORD)-1L,
      &dwEntriesRead,
      &dwTotalEntries,
      &hEnumHandle );
        if (NERR_Success == retval)
        {
            hr = HandleSFMResourceItems( pResultData, pcookie, pfileinfo, dwEntriesRead );
            pfileinfo = NULL;
            break;
        } else if (ERROR_MORE_DATA == retval) {
            ASSERT( NULL != hEnumHandle );
            hr = HandleSFMResourceItems( pResultData, pcookie, pfileinfo, dwEntriesRead );
            pfileinfo = NULL;
            continue;
        } else if (RPC_S_SERVER_UNAVAILABLE == retval && 0 == hEnumHandle) {
      // SFM just isn't installed, don't worry about it
            retval = NERR_Success;  
            break;
        } else {
            if (ERROR_ACCESS_DENIED == retval)
            {
                (void) DoErrMsgBox(
                            GetActiveWindow(), 
                            MB_OK | MB_ICONSTOP, 
                            0,
                            IDS_POPUP_SFM_RESOURCES_NOACCESS
                            );
            } else
            {
                (void) DoErrMsgBox(
                            GetActiveWindow(), 
                            MB_OK | MB_ICONSTOP, 
                            retval, 
                            IDS_POPUP_SFM_RESOURCES
                            );
            }
            break;
        }
    } while (S_OK == hr);

    return HRESULT_FROM_WIN32(retval);
}


#if 0
typedef enum _COLNUM_RESOURCES {
  COLNUM_RESOURCES_FILENAME = 0,
  COLNUM_RESOURCES_USERNAME,
  COLNUM_RESOURCES_NUM_LOCKS,  // we don't try to display sharename for now, since
                // only SFM has this information
  COLNUM_RESOURCES_OPEN_MODE
} COLNUM_RESOURCES;

typedef struct _AFP_FILE_INFO
{
  DWORD  afpfile_id;          // Id of the open file fork
  DWORD  afpfile_open_mode;      // Mode in which file is opened
  DWORD  afpfile_num_locks;      // Number of locks on the file
  DWORD  afpfile_fork_type;      // Fork type
  LPWSTR  afpfile_username;      // File opened by this user. max UNLEN
  LPWSTR  afpfile_path;        // Absolute canonical path to the file

} AFP_FILE_INFO, *PAFP_FILE_INFO;
#endif

HRESULT SfmFileServiceProvider::HandleSFMResourceItems(
    IResultData* pResultData,
    CFileMgmtCookie* pParentCookie,
    PVOID pinfo,
    DWORD nItems)
{
  TEST_NONNULL_PTR_PARAM(pParentCookie);
  TEST_NONNULL_PTR_PARAM(pinfo);

  if (0 >= nItems)
    return S_OK;

  BOOL fDeleteAllItems = (NULL == pResultData);

    RESULTDATAITEM tRDItem;
  ::ZeroMemory( &tRDItem, sizeof(tRDItem) );
  // CODEWORK should use MMC_ICON_CALLBACK
  tRDItem.nImage = iIconSFMResource;
  tRDItem.nCol = COLNUM_RESOURCES_FILENAME;
  tRDItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
  tRDItem.str = MMC_CALLBACK;

  AFP_FILE_INFO* pfileinfo = (AFP_FILE_INFO*)pinfo;

  CSfmResourceCookie* pcookiearray = new CSfmResourceCookie[nItems];
  CSfmCookieBlock* pCookieBlock = new CSfmCookieBlock(
    pcookiearray,nItems,pParentCookie->QueryTargetServer(),pinfo );
  if (!fDeleteAllItems)
  {
    pParentCookie->m_listResultCookieBlocks.AddHead( pCookieBlock );
  }

  CString str;
    for ( ; nItems > 0; nItems--, pfileinfo++, pcookiearray++ )
    {
    pcookiearray->m_pobject = pfileinfo;

    if (fDeleteAllItems)
    {
      DWORD dwApiResult = CloseResource( pcookiearray );
      if (0L != dwApiResult)
      {
        (void) DoErrMsgBox(GetActiveWindow(), MB_OK | MB_ICONSTOP, dwApiResult,
          IDS_POPUP_SFM_DISCONNECTALLRESOURCE_ERROR,
                    pfileinfo->afpfile_path );
        return S_FALSE;
      }
      continue;
    }

    // WARNING cookie cast
    tRDItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pcookiearray);
    HRESULT hr = pResultData->InsertItem(&tRDItem);
    ASSERT(SUCCEEDED(hr));
    }

  if (fDeleteAllItems) // they were not added to the parent cookie's list
    delete pCookieBlock;

  return S_OK;
}


/*
DWORD
AfpAdminFileClose(
    IN AFP_SERVER_HANDLE   hAfpServer,
    IN DWORD         dwConnectionId
);
DWORD
AfpAdminConnectionEnum(
        IN  AFP_SERVER_HANDLE   hAfpServer,
        OUT LPBYTE              *ppbBuffer,
        IN  DWORD               dwFilter,
        IN  DWORD               dwId,
        IN  DWORD               dwPrefMaxLen,
        OUT LPDWORD             lpdwEntriesRead,
        OUT LPDWORD             lpdwTotalEntries,
        IN  LPDWORD             lpdwResumeHandle
);
DWORD
AfpAdminConnectionClose(
        IN  AFP_SERVER_HANDLE   hAfpServer,
        IN  DWORD               dwConnectionId
);
DWORD
AfpAdminVolumeGetInfo (
    IN  AFP_SERVER_HANDLE   hAfpServer,
    IN  LPWSTR        lpwsVolumeName,
    OUT  LPBYTE *      lpbBuffer
);

typedef struct _AFP_VOLUME_INFO
{
  LPWSTR  afpvol_name;        // Name of the volume max.
  DWORD  afpvol_id;          // id of this volume. generated by sever
  LPWSTR  afpvol_password;      // Volume password, max. AFP_VOLPASS_LEN
  DWORD  afpvol_max_uses;      // Max opens allowed
  DWORD  afpvol_props_mask;      // Mask of volume properties
  DWORD  afpvol_curr_uses;      // Number of curr open connections.
  LPWSTR  afpvol_path;        // The actual path
                    // Ignored for VolumeSetInfo
} AFP_VOLUME_INFO, *PAFP_VOLUME_INFO;

DWORD
AfpAdminVolumeDelete(
    IN AFP_SERVER_HANDLE   hAfpServer,
    IN LPWSTR         lpwsVolumeName
);
*/

typedef DWORD (*VOLUMEGETINFOPROC) (AFP_SERVER_HANDLE,LPWSTR,LPBYTE*);
typedef DWORD (*FILECLOSEPROC) (AFP_SERVER_HANDLE,DWORD);
typedef DWORD (*AFPCONNECTIONENUMPROC) (AFP_SERVER_HANDLE,LPBYTE*,DWORD,
                                        DWORD,DWORD,LPDWORD,LPDWORD,LPDWORD);
typedef DWORD (*AFPCONNECTIONCLOSEPROC) (AFP_SERVER_HANDLE,DWORD);
typedef DWORD (*VOLUMEDELPROC) (AFP_SERVER_HANDLE,LPWSTR);
typedef DWORD (*BUFFERFREEPROC) (LPVOID);

// S_OK:    user wants to continue
// S_FALSE: user wants to cancel the operation and keep the share
// E_FAIL:  share doesn't exist, needs to refresh
HRESULT SfmFileServiceProvider::ConfirmDeleteShare( LPCTSTR lpcszServerName, LPCTSTR lpcszShareName )
{
    if ( !g_SfmDLL.LoadFunctionPointers() )
        return E_FAIL;

    if ( !SFMConnect(lpcszServerName, TRUE) )
        return E_FAIL;

    PAFP_VOLUME_INFO pAfpVolumeInfo = NULL;
    DWORD dwRetCode = ((VOLUMEGETINFOPROC)g_SfmDLL[AFP_VOLUME_GET_INFO])(
                                                            m_ulSFMServerConnection,
                                                            const_cast<LPTSTR>(lpcszShareName),
                                                            (LPBYTE*)&pAfpVolumeInfo);

    if (AFPERR_VolumeNonExist == dwRetCode)
        return E_FAIL;

    if (NO_ERROR != dwRetCode)
        return E_FAIL;

    ASSERT( NULL != pAfpVolumeInfo);

    UINT cOpens = 0;
    UINT cConns = 0;

    //
    // Check if there are any open resources on the volume
    //
    PAFP_FILE_INFO pAfpFileInfos = NULL;
    DWORD dwEntriesRead = 0;
    DWORD dwTotalEntries = 0;
    dwRetCode = ((FILEENUMPROC)g_SfmDLL[AFP_FILE_ENUM])(
                    m_ulSFMServerConnection,
                    (PBYTE*)&pAfpFileInfos,
                    (DWORD)-1L,
                    &dwEntriesRead,
                    &dwTotalEntries,
                    NULL );

    if (NO_ERROR == dwRetCode)
    {
      PAFP_FILE_INFO pAfpFileInfoIter = pAfpFileInfos;
      for ( DWORD dwIndex = 0;
            dwIndex < dwEntriesRead;
            dwIndex++, pAfpFileInfoIter++ )
      {
        if (_tcsnicmp(pAfpVolumeInfo->afpvol_path, 
                      pAfpFileInfoIter->afpfile_path,
                      _tcslen(pAfpVolumeInfo->afpvol_path)) == 0)
        {
            cOpens++;
        }
      }

      ((BUFFERFREEPROC) g_SfmDLL[AFP_BUFFER_FREE])(pAfpFileInfos);
    }

    //
    // Check if there are any users connected to the volume
    // by enumerating the connections to this volume.
    //
    PAFP_CONNECTION_INFO pAfpConnections = NULL;
    dwRetCode = ((AFPCONNECTIONENUMPROC)g_SfmDLL[AFP_CONNECTION_ENUM])(
                      m_ulSFMServerConnection,
                      (LPBYTE*)&pAfpConnections,
                      AFP_FILTER_ON_VOLUME_ID,
                      pAfpVolumeInfo->afpvol_id,
                      (DWORD)-1,    // Get all conenctions
                      &dwEntriesRead,
                      &dwTotalEntries,
                      NULL );
    ((BUFFERFREEPROC) g_SfmDLL[AFP_BUFFER_FREE])(pAfpVolumeInfo);

    if (NO_ERROR == dwRetCode)
    {
        cConns = dwTotalEntries;

      ((BUFFERFREEPROC) g_SfmDLL[AFP_BUFFER_FREE])(pAfpConnections);
    }


    // pop up the proper confirmation message
    if (cConns > 0)
    {
        if (cOpens > 0)
        {
            if (IDYES != DoErrMsgBox(
                            GetActiveWindow(),
                            MB_YESNO,
                            0,
                            IDS_s_CONFIRM_DELETESHARE_FILE,
                            cOpens,
                            cConns,
                            lpcszShareName))
            {
                return S_FALSE;
            }
        } else              // (cConns > 0)
        {
            if (IDYES != DoErrMsgBox(
                            GetActiveWindow(),
                            MB_YESNO,
                            0,
                            IDS_s_CONFIRM_DELETESHARE_CONN,
                            cConns,
                            lpcszShareName))
            {
                return S_FALSE;
            }
        }
    } else
    {
        if (IDYES != DoErrMsgBox(
                        GetActiveWindow(),
                        MB_YESNO,
                        0,
                        IDS_s_CONFIRM_DELETESHARE,
                        lpcszShareName))
        {
            return S_FALSE;
        }
    }

    return S_OK;
}

DWORD SfmFileServiceProvider::DeleteShare( LPCWSTR pwchServerName, LPCWSTR pwchShareName )
{
  if ( !g_SfmDLL.LoadFunctionPointers() )
    return S_OK;

  if ( !SFMConnect(pwchServerName, TRUE) )
    return S_OK;

  PAFP_VOLUME_INFO pAfpVolumeInfo = NULL;
  DWORD dwRetCode = ((VOLUMEGETINFOPROC)g_SfmDLL[AFP_VOLUME_GET_INFO])(
                        m_ulSFMServerConnection,
                        const_cast<LPTSTR>(pwchShareName),
                        (LPBYTE*)&pAfpVolumeInfo);

  if (AFPERR_VolumeNonExist == dwRetCode)
      return NERR_Success;

  if (NO_ERROR == dwRetCode)
  {
    ASSERT( NULL != pAfpVolumeInfo);
    //
    // Check if there are any open resources on the volume
    //
    PAFP_FILE_INFO pAfpFileInfos = NULL;
    DWORD dwEntriesRead = 0;
    DWORD dwTotalEntries = 0;
    dwRetCode = ((FILEENUMPROC)g_SfmDLL[AFP_FILE_ENUM])(
                    m_ulSFMServerConnection,
                    (PBYTE*)&pAfpFileInfos,
                    (DWORD)-1L,
                    &dwEntriesRead,
                    &dwTotalEntries,
                    NULL );

    if (NO_ERROR == dwRetCode)
    {
      PAFP_FILE_INFO pAfpFileInfoIter = pAfpFileInfos;
      for ( DWORD dwIndex = 0;
            dwIndex < dwEntriesRead;
            dwIndex++, pAfpFileInfoIter++ )
      {
        if (_tcsnicmp(pAfpVolumeInfo->afpvol_path, 
                      pAfpFileInfoIter->afpfile_path,
                      _tcslen(pAfpVolumeInfo->afpvol_path)) == 0)
        {
          ((FILECLOSEPROC)g_SfmDLL[AFP_FILE_CLOSE])(
                m_ulSFMServerConnection,
                pAfpFileInfoIter->afpfile_id );
        }
      }

      ((BUFFERFREEPROC) g_SfmDLL[AFP_BUFFER_FREE])(pAfpFileInfos);
    }

    //
    // Check if there are any users connected to the volume
    // by enumerating the connections to this volume.
    //
    PAFP_CONNECTION_INFO pAfpConnections = NULL;
    dwRetCode = ((AFPCONNECTIONENUMPROC)g_SfmDLL[AFP_CONNECTION_ENUM])(
                      m_ulSFMServerConnection,
                      (LPBYTE*)&pAfpConnections,
                      AFP_FILTER_ON_VOLUME_ID,
                      pAfpVolumeInfo->afpvol_id,
                      (DWORD)-1,    // Get all conenctions
                      &dwEntriesRead,
                      &dwTotalEntries,
                      NULL );
    ((BUFFERFREEPROC) g_SfmDLL[AFP_BUFFER_FREE])(pAfpVolumeInfo);

    if (NO_ERROR == dwRetCode)
    {
      PAFP_CONNECTION_INFO pAfpConnInfoIter = pAfpConnections;
      for ( DWORD dwIndex = 0;
            dwIndex < dwEntriesRead;
            dwIndex++, pAfpConnInfoIter++ )
      {
        ((AFPCONNECTIONCLOSEPROC)g_SfmDLL[AFP_CONNECTION_CLOSE])(
              m_ulSFMServerConnection,
              pAfpConnInfoIter->afpconn_id );
      }

      ((BUFFERFREEPROC) g_SfmDLL[AFP_BUFFER_FREE])(pAfpConnections);
    }

    dwRetCode = ((VOLUMEDELPROC)g_SfmDLL[AFP_VOLUME_DEL])(
                      m_ulSFMServerConnection,
                      const_cast<LPTSTR>(pwchShareName) );

    if (AFPERR_VolumeNonExist == dwRetCode)
        dwRetCode = NERR_Success;
  }

  return dwRetCode;
}

/*
DWORD
AfpAdminSessionClose(
    IN AFP_SERVER_HANDLE   hAfpServer,
    IN DWORD         dwSessionId
);
*/

typedef DWORD (*SESSIONCLOSEPROC) (AFP_SERVER_HANDLE,DWORD);

DWORD SfmFileServiceProvider::CloseSession(CFileMgmtResultCookie* pcookie)
{
  if ( !g_SfmDLL.LoadFunctionPointers() )
    return S_OK;
  USES_CONVERSION;
  if ( !SFMConnect(T2OLE(const_cast<LPTSTR>(pcookie->QueryTargetServer()))) )
    return S_OK;

  ASSERT( FILEMGMT_SESSION == pcookie->QueryObjectType() );
  AFP_SESSION_INFO* psessioninfo = (AFP_SESSION_INFO*)pcookie->m_pobject;
  ASSERT( NULL != psessioninfo );

  DWORD dwRet = ((SESSIONCLOSEPROC)g_SfmDLL[AFP_SESSION_CLOSE])(
        m_ulSFMServerConnection,
    psessioninfo->afpsess_id );

  return (AFPERR_InvalidId == dwRet ? NERR_Success : dwRet);
}

DWORD SfmFileServiceProvider::CloseResource(CFileMgmtResultCookie* pcookie)
{
  if ( !g_SfmDLL.LoadFunctionPointers() )
    return S_OK;

  if ( !SFMConnect(T2OLE(const_cast<LPTSTR>(pcookie->QueryTargetServer()))) )
    return S_OK;

  ASSERT( FILEMGMT_RESOURCE == pcookie->QueryObjectType() );
  AFP_FILE_INFO* pfileinfo = (AFP_FILE_INFO*)pcookie->m_pobject;
  ASSERT( NULL != pfileinfo );

  DWORD dwRet = ((FILECLOSEPROC)g_SfmDLL[AFP_FILE_CLOSE])(
        m_ulSFMServerConnection,
    pfileinfo->afpfile_id );

  return (AFPERR_InvalidId == dwRet ? NERR_Success : dwRet);
}

/*
DWORD
AfpAdminDirectoryGetInfo(
    IN  AFP_SERVER_HANDLE  hAfpServer,
    IN  LPWSTR        lpwsPath,
    OUT LPBYTE        *ppAfpDirectoryInfo
);

DWORD
AfpAdminDirectorySetInfo(
    IN  AFP_SERVER_HANDLE  hAfpServer,
    IN  LPBYTE        pAfpDirectoryInfo,
    IN  DWORD        dwParmNum
);
*/

typedef DWORD (*DIRECTORYGETINFOPROC) (AFP_SERVER_HANDLE,LPWSTR,LPBYTE*);
typedef DWORD (*DIRECTORYSETINFOPROC) (AFP_SERVER_HANDLE,LPBYTE,DWORD);

DWORD SfmFileServiceProvider::GetDirectoryInfo(
    LPCTSTR  ptchServerName,
    LPCWSTR  pszPath,
    DWORD*   pdwPerms,
    CString& strOwner,
    CString& strGroup )
{
  if ( !g_SfmDLL.LoadFunctionPointers() )
    return S_OK;

  if ( !SFMConnect(ptchServerName, TRUE) )
    return S_OK;

  AFP_DIRECTORY_INFO* pdirinfo = NULL;
    DWORD retval = ((DIRECTORYGETINFOPROC)g_SfmDLL[AFP_DIRECTORY_GET_INFO])(
    m_ulSFMServerConnection,
    const_cast<LPWSTR>(pszPath),
    (LPBYTE*)&pdirinfo );
  if (0L != retval)
  {
    return retval;
  }
  ASSERT( NULL != pdirinfo );
  *pdwPerms = pdirinfo->afpdir_perms;
  strOwner  = pdirinfo->afpdir_owner;
  strGroup  = pdirinfo->afpdir_group;
  FreeData( pdirinfo );
  return 0L;
}

DWORD SfmFileServiceProvider::SetDirectoryInfo(
    LPCTSTR  ptchServerName,
    LPCWSTR  pszPath,
    DWORD    dwPerms,
    LPCWSTR  pszOwner,
    LPCWSTR  pszGroup )
{
  if ( !g_SfmDLL.LoadFunctionPointers() )
    return S_OK;

  if ( !SFMConnect(ptchServerName, TRUE) )
    return S_OK;

  AFP_DIRECTORY_INFO dirinfo;
  ::memset( &dirinfo, 0, sizeof(dirinfo) );
  dirinfo.afpdir_path = const_cast<LPWSTR>(pszPath);
  dirinfo.afpdir_perms = dwPerms;
  dirinfo.afpdir_owner = const_cast<LPWSTR>(pszOwner);
  dirinfo.afpdir_group = const_cast<LPWSTR>(pszGroup);
  dirinfo.afpdir_in_volume = FALSE;
    return ((DIRECTORYSETINFOPROC)g_SfmDLL[AFP_DIRECTORY_SET_INFO])(
    m_ulSFMServerConnection,
    (LPBYTE)&dirinfo,
    AFP_DIR_PARMNUM_ALL );
}



/*
DWORD
AfpAdminVolumeSetInfo (
    IN  AFP_SERVER_HANDLE   hAfpServer,
    IN  LPBYTE        pBuffer,
    IN  DWORD        dwParmNum
);
*/

typedef DWORD (*VOLUMESETINFOPROC) (AFP_SERVER_HANDLE,LPBYTE,DWORD);

VOID SfmFileServiceProvider::DisplayShareProperties(
    LPPROPERTYSHEETCALLBACK pCallBack,
    LPDATAOBJECT pDataObject, 
    LONG_PTR handle)
{
  /*
  add General page
  */
  CSharePageGeneralSFM * pPage = new CSharePageGeneralSFM();
    if ( !pPage->Load( m_pFileMgmtData, pDataObject ) )
    return;

  // This mechanism deletes the CSharePageGeneral when the property sheet is finished
  pPage->m_pfnOriginalPropSheetPageProc = pPage->m_psp.pfnCallback;
  pPage->m_psp.lParam = reinterpret_cast<LPARAM>(pPage);
  pPage->m_psp.pfnCallback = &CSharePageGeneralSFM::PropSheetPageProc;
  pPage->m_handle = handle;

  HPROPSHEETPAGE hPage=MyCreatePropertySheetPage(&pPage->m_psp);
  pCallBack->AddPage(hPage);

  CreateFolderSecurityPropPage(pCallBack, pDataObject);
}

DWORD SfmFileServiceProvider::ReadShareProperties(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    OUT PVOID* ppvPropertyBlock,
    OUT CString& /*strDescription*/,
    OUT CString& strPath,
    OUT BOOL* pfEditDescription,
    OUT BOOL* pfEditPath,
    OUT DWORD* pdwShareType)
{
  if ( !g_SfmDLL.LoadFunctionPointers() )
  {
    ASSERT(FALSE);
    return S_OK;
  }

  if (ppvPropertyBlock)     *ppvPropertyBlock = NULL;
  if (pdwShareType)         *pdwShareType = 0;
  if (pfEditDescription)    *pfEditDescription = FALSE;
  if (pfEditPath)           *pfEditPath = FALSE;

  USES_CONVERSION;
  if ( !SFMConnect(T2OLE(const_cast<LPTSTR>(ptchServerName))) )
    return S_OK;

  AFP_VOLUME_INFO* pvolumeinfo = NULL;
  NET_API_STATUS retval = ((VOLUMEGETINFOPROC)g_SfmDLL[AFP_VOLUME_GET_INFO])(
                                                        m_ulSFMServerConnection,
                                                        T2OLE(const_cast<LPTSTR>(ptchShareName)),
                                                        (LPBYTE*)&pvolumeinfo);
  if (NERR_Success == retval)
  {
    strPath = pvolumeinfo->afpvol_path;
    if (ppvPropertyBlock)
    {
        *ppvPropertyBlock = pvolumeinfo; // will be freed by the caller
    } else
    {
        FreeData(pvolumeinfo);
    }
  }
  return retval;
}

// the changed values have already been loaded into pvPropertyBlock
DWORD SfmFileServiceProvider::WriteShareProperties(LPCTSTR ptchServerName, LPCTSTR /*ptchShareName*/,
    PVOID pvPropertyBlock, LPCTSTR /*ptchDescription*/, LPCTSTR /*ptchPath*/)
{
  if ( !g_SfmDLL.LoadFunctionPointers() )
    return S_OK;

  USES_CONVERSION;
  if ( !SFMConnect(T2OLE(const_cast<LPTSTR>(ptchServerName))) )
    return S_OK;

  ASSERT( NULL != pvPropertyBlock );

  AFP_VOLUME_INFO* pvolumeinfo = (AFP_VOLUME_INFO*)pvPropertyBlock;
  DWORD retval = ((VOLUMESETINFOPROC)g_SfmDLL[AFP_VOLUME_SET_INFO])(
        m_ulSFMServerConnection,
    (LPBYTE)pvolumeinfo,
    AFP_VOL_PARMNUM_ALL);
  pvolumeinfo->afpvol_path = NULL;
  return retval;
}

VOID SfmFileServiceProvider::FreeShareProperties(PVOID pvPropertyBlock)
{
  FreeData( pvPropertyBlock );
}

DWORD SfmFileServiceProvider::QueryMaxUsers(PVOID pvPropertyBlock)
{
  AFP_VOLUME_INFO* pvolumeinfo = (AFP_VOLUME_INFO*)pvPropertyBlock;
  ASSERT( NULL != pvolumeinfo );
  return pvolumeinfo->afpvol_max_uses;
}

VOID SfmFileServiceProvider::SetMaxUsers(PVOID pvPropertyBlock, DWORD dwMaxUsers)
{
  AFP_VOLUME_INFO* pvolumeinfo = (AFP_VOLUME_INFO*)pvPropertyBlock;
  ASSERT( NULL != pvolumeinfo );
  pvolumeinfo->afpvol_max_uses = dwMaxUsers;
}

VOID SfmFileServiceProvider::FreeData(PVOID pv)
{
  if (pv != NULL)
  {
    ASSERT( NULL != g_SfmDLL[AFP_BUFFER_FREE] );
    (void) ((BUFFERFREEPROC)g_SfmDLL[AFP_BUFFER_FREE])( pv );
  }
}

LPCTSTR SfmFileServiceProvider::QueryTransportString()
{
  return m_strTransportSFM;
}

BOOL SfmFileServiceProvider::DisplaySfmProperties(LPDATAOBJECT pDataObject, CFileMgmtCookie* pcookie)
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if ( !g_SfmDLL.LoadFunctionPointers() )
    return S_OK;

    CString strServerName;
    HRESULT hr = ExtractString( pDataObject, CFileMgmtDataObject::m_CFMachineName, &strServerName, MAX_PATH );

    if ( !SFMConnect(strServerName) )
        return S_OK;

    CString strTitle;
    
    // check to see if we have a sheet up, if so make it active.
    if (m_pSfmPropSheet)
    {
        m_pSfmPropSheet->SetActiveWindow();
        
        return TRUE;
    }

    // nothing up, create a new sheet
    strTitle.LoadString(IDS_PROP_SHEET_TITLE);
    SetSfmPropSheet(new CSFMPropertySheet);

    if (!m_pSfmPropSheet->FInit(NULL, m_ulSFMServerConnection, strTitle, this, pcookie->QueryTargetServer()))
    {
        delete m_pSfmPropSheet;
        SetSfmPropSheet(NULL);
        return FALSE;
    }

    return m_pSfmPropSheet->DoModelessSheet(pDataObject);
}

void SfmFileServiceProvider::CleanupSfmProperties()
{
    if (m_pSfmPropSheet)
    {
        // we're going away, so set the pointer to NULL
        // so the property sheet won't try to call back into us.
        m_pSfmPropSheet->SetProvider(NULL);
        m_pSfmPropSheet->CancelSheet();
        m_pSfmPropSheet->Release();
        SetSfmPropSheet(NULL);
    }
}

void SfmFileServiceProvider::SetSfmPropSheet(CSFMPropertySheet * pSfmPropSheet)
{
  if (m_pSfmPropSheet)
    m_pSfmPropSheet->Release();

    m_pSfmPropSheet = pSfmPropSheet;
}

DWORD SfmFileServiceProvider::UserHasAccess(LPCWSTR pwchServerName)
{
    PAFP_SERVER_INFO    pAfpServerInfo;
    DWORD               err; 
    
    if ( !g_SfmDLL.LoadFunctionPointers() )
    return FALSE;

    if ( !SFMConnect(pwchServerName) )
    return FALSE;

    err = ((SERVERGETINFOPROC) g_SfmDLL[AFP_SERVER_GET_INFO])(m_ulSFMServerConnection,
                                                              (LPBYTE*) &pAfpServerInfo);
  if (err == NO_ERROR)
  {
        ((BUFFERFREEPROC) g_SfmDLL[AFP_BUFFER_FREE])(pAfpServerInfo);
  }

    return err;
}

BOOL SfmFileServiceProvider::FSFMInstalled(LPCWSTR pwchServerName)
{
    BOOL                bInstalled = FALSE;
    
    if ( !g_SfmDLL.LoadFunctionPointers() )
    return FALSE;

    if ( !SFMConnect(pwchServerName) )
    return FALSE;

    // check to make sure the service is there
    SC_HANDLE hScManager = ::OpenSCManager(pwchServerName, NULL, SC_MANAGER_CONNECT);
    if (hScManager)
    {
        SC_HANDLE hService = ::OpenService(hScManager, AFP_SERVICE_NAME, GENERIC_READ);
        if (hService != NULL)
        {
            // the service is there.  May or may not be started.  
            bInstalled = TRUE;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hScManager);
    }

    return bInstalled;
}

// ensures that SFM is started
BOOL SfmFileServiceProvider::StartSFM(HWND hwndParent, SC_HANDLE hScManager, LPCWSTR pwchServerName)
{
    BOOL                bStarted = FALSE;
    
    if ( !g_SfmDLL.LoadFunctionPointers() )
    return FALSE;

    if ( !SFMConnect(pwchServerName) )
    return FALSE;

    // open the service
    SC_HANDLE hService = ::OpenService(hScManager, AFP_SERVICE_NAME, GENERIC_READ);
    if (hService != NULL)
    {
        SERVICE_STATUS ss;

        // get the service status
        if (::QueryServiceStatus(hService, &ss))
        {
            APIERR err = NO_ERROR;

            if (ss.dwCurrentState != SERVICE_RUNNING)
            {
                // try to start the service
                CString strSvcDisplayName, strMessageBox;

                strSvcDisplayName.LoadString(IDS_PROP_SHEET_TITLE);
                AfxFormatString1(strMessageBox, IDS_START_SERVICE, strSvcDisplayName);

                if (AfxMessageBox(strMessageBox, MB_YESNO) == IDYES)
                {
                    TCHAR szName[MAX_COMPUTERNAME_LENGTH + 1] = {0};
                    DWORD dwSize = sizeof(szName);

                    if (pwchServerName == NULL)
                    {
                        GetComputerName(szName, &dwSize);
                        pwchServerName = szName;
                    }

                    // the service control progress handles displaying the error
                    err = CServiceControlProgress::S_EStartService(hwndParent,
                                                                   hScManager,
                                                                   pwchServerName,
                                                                   AFP_SERVICE_NAME,
                                                                   strSvcDisplayName,
                                                                   0,
                                                                   NULL);
                }
                else
                {
                    // user chose not to start the service.
                    err = 1;
                }
            }

            if (err == NO_ERROR)
            {
                bStarted = TRUE;
            }
        }
        
        
        ::CloseServiceHandle(hService);
    }
   
    return bStarted;
}

CSfmCookieBlock::~CSfmCookieBlock()
{
  if (NULL != m_pvCookieData)
  {
    (void) ((BUFFERFREEPROC)g_SfmDLL[AFP_BUFFER_FREE])( m_pvCookieData );
    m_pvCookieData = NULL;
  }
}

DEFINE_COOKIE_BLOCK(CSfmCookie)
DEFINE_FORWARDS_MACHINE_NAME( CSfmCookie, m_pCookieBlock )

void CSfmCookie::AddRefCookie() { m_pCookieBlock->AddRef(); }
void CSfmCookie::ReleaseCookie() { m_pCookieBlock->Release(); }

HRESULT CSfmCookie::GetTransport( FILEMGMT_TRANSPORT* pTransport )
{
  *pTransport = FILEMGMT_SFM;
  return S_OK;
}

HRESULT CSfmShareCookie::GetShareName( CString& strShareName )
{
  AFP_VOLUME_INFO* pvolumeinfo = (AFP_VOLUME_INFO*)m_pobject;
  ASSERT( NULL != pvolumeinfo );
  USES_CONVERSION;
  strShareName = OLE2T(pvolumeinfo->afpvol_name);
  return S_OK;
}

HRESULT CSfmShareCookie::GetSharePIDList( OUT LPITEMIDLIST *ppidl )
{
  ASSERT(ppidl);
  ASSERT(NULL == *ppidl);  // prevent memory leak
  *ppidl = NULL;

  AFP_VOLUME_INFO* pvolumeinfo = (AFP_VOLUME_INFO*)m_pobject;
  ASSERT( NULL != pvolumeinfo );
  ASSERT( _tcslen(pvolumeinfo->afpvol_path) >= 3 && 
          _T(':') == *(pvolumeinfo->afpvol_path + 1) );
  USES_CONVERSION;

  PCTSTR pszTargetServer = m_pCookieBlock->QueryTargetServer();
  CString csPath;

  if (pszTargetServer)
  {
    //
    // since MS Windows user cannot see shares created for MAC users,
    // we have to use $ share to retrieve the pidl here.
    //
    CString csTemp = OLE2T(pvolumeinfo->afpvol_path);
    csTemp.SetAt(1, _T('$'));
    if ( _tcslen(pszTargetServer) >= 2 &&
         _T('\\') == *pszTargetServer &&
         _T('\\') == *(pszTargetServer + 1) )
    {
      csPath = pszTargetServer;
    } else
    {
      csPath = _T("\\\\");
      csPath += pszTargetServer;
    }
    csPath += _T("\\");
    csPath += csTemp;
  } else
  {
    csPath = OLE2T(pvolumeinfo->afpvol_path);
  }

  if (FALSE == csPath.IsEmpty())
    *ppidl = ILCreateFromPath(csPath);

  return ((*ppidl) ? S_OK : E_FAIL);
}

HRESULT CSfmSessionCookie::GetSessionID( DWORD* pdwSessionID )
{
  AFP_SESSION_INFO* psessioninfo = (AFP_SESSION_INFO*)m_pobject;
  ASSERT( NULL != pdwSessionID && NULL != psessioninfo );
  *pdwSessionID = psessioninfo->afpsess_id;
  return S_OK;
}

HRESULT CSfmResourceCookie::GetFileID( DWORD* pdwFileID )
{
  AFP_FILE_INFO* pfileinfo = (AFP_FILE_INFO*)m_pobject;
  ASSERT( NULL != pdwFileID && NULL != pfileinfo );
  *pdwFileID = pfileinfo->afpfile_id;
  return S_OK;
}

BSTR CSfmShareCookie::GetColumnText( int nCol )
{
  switch (nCol)
  {
  case COLNUM_SHARES_SHARED_FOLDER:
    return GetShareInfo()->afpvol_name;
  case COLNUM_SHARES_SHARED_PATH:
    return GetShareInfo()->afpvol_path;
  case COLNUM_SHARES_TRANSPORT:
    return const_cast<BSTR>((LPCTSTR)g_strTransportSFM);
  case COLNUM_SHARES_COMMENT:
    break; // not known for SFM
  default:
    ASSERT(FALSE);
    break;
  }
  return L"";
}

BSTR CSfmShareCookie::QueryResultColumnText( int nCol, CFileMgmtComponentData& /*refcdata*/ )
{
  if (COLNUM_SHARES_NUM_SESSIONS == nCol)
    return MakeDwordResult( GetNumOfCurrentUses() );

  return GetColumnText(nCol);
}

extern CString g_cstrClientName;
extern CString g_cstrGuest;
extern CString g_cstrYes;
extern CString g_cstrNo;

BSTR CSfmSessionCookie::GetColumnText( int nCol )
{
  switch (nCol)
  {
  case COLNUM_SESSIONS_USERNAME:
    if (0 == GetSessionInfo()->afpsess_logon_type &&
        ( !(GetSessionInfo()->afpsess_username) ||
          _T('\0') == *(GetSessionInfo()->afpsess_username) ) )
    {
      return const_cast<BSTR>(((LPCTSTR)g_cstrGuest));
    } else
    {
      return GetSessionInfo()->afpsess_username;
    }
  case COLNUM_SESSIONS_COMPUTERNAME:
      {
        TranslateIPToComputerName(GetSessionInfo()->afpsess_ws_name, g_cstrClientName);
        return const_cast<BSTR>(((LPCTSTR)g_cstrClientName));
      }
  case COLNUM_SESSIONS_TRANSPORT:
    return const_cast<BSTR>((LPCTSTR)g_strTransportSFM);
  case COLNUM_SESSIONS_IS_GUEST:
    if (0 == GetSessionInfo()->afpsess_logon_type)
      return const_cast<BSTR>(((LPCTSTR)g_cstrYes));
    else
      return const_cast<BSTR>(((LPCTSTR)g_cstrNo));
  default:
    ASSERT(FALSE);
    break;
  }
  return L"";
}

BSTR CSfmSessionCookie::QueryResultColumnText( int nCol, CFileMgmtComponentData& /*refcdata*/ )
{
  switch (nCol)
  {
  case COLNUM_SESSIONS_NUM_FILES:
    return MakeDwordResult( GetNumOfOpenFiles() );
  case COLNUM_SESSIONS_CONNECTED_TIME:
    return MakeElapsedTimeResult( GetConnectedTime() );
  case COLNUM_SESSIONS_IDLE_TIME:
    return L""; // not known for SFM sessions
  default:
    break;
  }

  return GetColumnText(nCol);
}

BSTR CSfmResourceCookie::GetColumnText( int nCol )
{
  switch (nCol)
  {
  case COLNUM_RESOURCES_FILENAME:
    return GetFileInfo()->afpfile_path;
  case COLNUM_RESOURCES_USERNAME:
    return GetFileInfo()->afpfile_username;
  case COLNUM_RESOURCES_TRANSPORT:
    return const_cast<BSTR>((LPCTSTR)g_strTransportSFM);
  case COLNUM_RESOURCES_OPEN_MODE:
  {
    return ( MakePermissionsResult(
        ((AFP_OPEN_MODE_WRITE & GetFileInfo()->afpfile_open_mode)
          ? PERM_FILE_WRITE : 0) |
        ((AFP_OPEN_MODE_READ  & GetFileInfo()->afpfile_open_mode)
          ? PERM_FILE_READ  : 0) ) );
  }
  default:
    ASSERT(FALSE);
    break;
  }
  return L"";
}

BSTR CSfmResourceCookie::QueryResultColumnText( int nCol, CFileMgmtComponentData& /*refcdata*/ )
{
  if (COLNUM_RESOURCES_NUM_LOCKS == nCol)
    return MakeDwordResult( GetNumOfLocks() );

  return GetColumnText(nCol);
}

void CSharePageGeneralSFM::ReadSfmSettings()
{
  AFP_VOLUME_INFO* pvolumeinfo = (AFP_VOLUME_INFO*)m_pvPropertyBlock;
  ASSERT( NULL != pvolumeinfo );
  // CODEWORK I may want to use a string of eight spaces rather than
  //   putting the actual password on screen.  I may also want to
  //   use a confirmation password field.
  //   See \\kernel\razzle2\src\sfm\afp\ui\afpmgr\volprop.cxx
  m_strSfmPassword = pvolumeinfo->afpvol_password;
  m_bSfmReadonly = !!(pvolumeinfo->afpvol_props_mask & AFP_VOLUME_READONLY);
}

void CSharePageGeneralSFM::WriteSfmSettings()
{
  AFP_VOLUME_INFO* pvolumeinfo = (AFP_VOLUME_INFO*)m_pvPropertyBlock;
  ASSERT( NULL != pvolumeinfo );
  pvolumeinfo->afpvol_password = const_cast<LPWSTR>((LPCWSTR)m_strSfmPassword);
  pvolumeinfo->afpvol_props_mask &=
    ~(AFP_VOLUME_READONLY);
  if (m_bSfmReadonly)
    pvolumeinfo->afpvol_props_mask |= AFP_VOLUME_READONLY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\sfm.h ===
// sfm.h: SFM shares, sessions and open resources

#ifndef __SFM_H_INCLUDED__
#define __SFM_H_INCLUDED__

#include "FileSvc.h" // FileServiceProvider

class DynamicDLL;
class CSFMPropertySheet;

typedef enum _SfmApiIndex
{
  AFP_VOLUME_ENUM = 0,
  AFP_SESSION_ENUM,
  AFP_FILE_ENUM,
  AFP_BUFFER_FREE,
  AFP_VOLUME_DEL,
  AFP_CONNECTION_ENUM,
  AFP_CONNECTION_CLOSE,
  AFP_SESSION_CLOSE,
  AFP_FILE_CLOSE,
  AFP_CONNECT,
  AFP_DISCONNECT,
  AFP_VOLUME_GET_INFO,
  AFP_VOLUME_SET_INFO,
  AFP_DIRECTORY_GET_INFO,
  AFP_DIRECTORY_SET_INFO,
  AFP_SERVER_GET_INFO,
  AFP_SERVER_SET_INFO,
  AFP_ETC_MAP_ASSOCIATE,
  AFP_ETC_MAP_ADD,
  AFP_ETC_MAP_DELETE,
  AFP_ETC_MAP_GET_INFO,
  AFP_ETC_MAP_SET_INFO,
  AFP_MESSAGE_SEND,
  AFP_STATISTICS_GET
};

// not subject to localization
static LPCSTR g_apchFunctionNames[] = {
  "AfpAdminVolumeEnum",
  "AfpAdminSessionEnum",
  "AfpAdminFileEnum",
  "AfpAdminBufferFree",
  "AfpAdminVolumeDelete",
  "AfpAdminConnectionEnum",
  "AfpAdminConnectionClose",
  "AfpAdminSessionClose",
  "AfpAdminFileClose",
  "AfpAdminConnect",
  "AfpAdminDisconnect",
  "AfpAdminVolumeGetInfo",
  "AfpAdminVolumeSetInfo",
  "AfpAdminDirectoryGetInfo",
  "AfpAdminDirectorySetInfo",
    "AfpAdminServerGetInfo",
    "AfpAdminServerSetInfo",
    "AfpAdminETCMapAssociate",
    "AfpAdminETCMapAdd",
    "AfpAdminETCMapDelete",
    "AfpAdminETCMapGetInfo",
    "AfpAdminETCMapSetInfo",
    "AfpAdminMessageSend",
    "AfpAdminStatisticsGet",
  NULL
};

// not subject to localization
extern DynamicDLL g_SfmDLL;

// forward declarations
class CSfmCookieBlock;


class SfmFileServiceProvider : public FileServiceProvider
{
public:
  SfmFileServiceProvider( CFileMgmtComponentData* pFileMgmtData );
  ~SfmFileServiceProvider();

  virtual DWORD OpenShare(LPCTSTR ptchServerName, LPCTSTR ptchShareName) { return NERR_Success; }
  virtual HRESULT ConfirmDeleteShare(LPCTSTR ptchServerName, LPCTSTR ptchShareName);
  virtual DWORD DeleteShare(LPCTSTR ptchServerName, LPCTSTR ptchShareName);
  virtual DWORD CloseSession(CFileMgmtResultCookie* pcookie);
  virtual DWORD CloseResource(CFileMgmtResultCookie* pcookie);

  virtual VOID DisplayShareProperties(
    LPPROPERTYSHEETCALLBACK pCallBack,
    LPDATAOBJECT pDataObject,
    LONG_PTR handle);
  virtual DWORD ReadShareProperties(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    OUT PVOID* ppvPropertyBlock,
    OUT CString& strDescription,
    OUT CString& strPath,
    OUT BOOL* pfEditDescription,
    OUT BOOL* pfEditPath,
    OUT DWORD* pdwShareType);
  virtual DWORD WriteShareProperties(LPCTSTR ptchServerName, LPCTSTR ptchShareName,
    PVOID pvPropertyBlock, LPCTSTR ptchDescription, LPCTSTR ptchPath);
  virtual VOID FreeShareProperties(PVOID pvPropertyBlock);

  virtual DWORD QueryMaxUsers(PVOID pvPropertyBlock);
  virtual VOID  SetMaxUsers(  PVOID pvPropertyBlock, DWORD dwMaxUsers);

  virtual VOID FreeData(PVOID pv);

  virtual HRESULT PopulateShares(
    IResultData* pResultData,
    CFileMgmtCookie* pcookie);
  //   if pResultData is not NULL, add sessions/resources to the listbox
  //   if pResultData is NULL, delete all sessions/resources
  //   if pResultData is NULL, return SUCCEEDED(hr) to continue or
  //     FAILED(hr) to abort
  virtual HRESULT EnumerateSessions(
    IResultData* pResultData,
    CFileMgmtCookie* pcookie,
    bool bAddToResultPane);
  virtual HRESULT EnumerateResources(
    IResultData* pResultData,
    CFileMgmtCookie* pcookie);

  virtual LPCTSTR QueryTransportString();

  HRESULT AddSFMShareItems(
    IResultData* pResultData,
    CFileMgmtCookie* pParentCookie,
    PVOID pinfo,
    DWORD nItems);
  HRESULT HandleSFMSessionItems(
    IResultData* pResultData,
    CFileMgmtCookie* pParentCookie,
    PVOID pinfo,
    DWORD nItems,
    BOOL bAddToResultPane);
  HRESULT HandleSFMResourceItems(
    IResultData* pResultData,
    CFileMgmtCookie* pParentCookie,
    PVOID pinfo,
    DWORD nItems);

  DWORD GetDirectoryInfo(
    LPCTSTR  ptchServerName,
    LPCWSTR  pszPath,
    DWORD*   pdwPerms,
    CString& strOwner,
    CString& strGroup );
  DWORD SetDirectoryInfo(
    LPCTSTR  ptchServerName,
    LPCWSTR  pszPath,
    DWORD    dwPerms,
    LPCWSTR  pszOwner,
    LPCWSTR  pszGroup );

    // functions added for SFM configuration - EricDav
    BOOL DisplaySfmProperties(
        LPDATAOBJECT pDataObject,
        CFileMgmtCookie* pCookie);
    void  CleanupSfmProperties();
    void  SetSfmPropSheet(CSFMPropertySheet * pSfmPropSheet);
    DWORD UserHasAccess(LPCWSTR pwchServerName);
    BOOL  FSFMInstalled(LPCWSTR pwchServerName);
    BOOL  StartSFM(HWND hwndParent, SC_HANDLE hScManager, LPCWSTR pwchServerName);

  // This is public, but be careful to use it promptly after SFMConnect().
  AFP_SERVER_HANDLE   m_ulSFMServerConnection;
  BOOL    SFMConnect(LPCWSTR pwchServer, BOOL fDisplayError = FALSE);
  void    SFMDisconnect();
private:
  CString             m_ulSFMServerConnectionMachine;
    CString             m_strTransportSFM;
    CSFMPropertySheet * m_pSfmPropSheet;
};


class CSfmCookie : public CFileMgmtResultCookie
{
public:
  CSfmCookie( FileMgmtObjectType objecttype )
    : CFileMgmtResultCookie( objecttype )
  {}
  virtual HRESULT GetTransport( OUT FILEMGMT_TRANSPORT* pTransport );

  virtual void AddRefCookie();
  virtual void ReleaseCookie();

// CHasMachineName
  CSfmCookieBlock* m_pCookieBlock;
  DECLARE_FORWARDS_MACHINE_NAME(m_pCookieBlock)
};


class CSfmCookieBlock : public CCookieBlock<CSfmCookie>, public CStoresMachineName
{
public:
  inline CSfmCookieBlock(
    CSfmCookie* aCookies, // use vector ctor, we use vector dtor
    INT cCookies,
    LPCTSTR lpcszMachineName,
    PVOID pvCookieData)
    :  CCookieBlock<CSfmCookie>( aCookies, cCookies ),
      CStoresMachineName( lpcszMachineName ),
      m_pvCookieData( pvCookieData )
  {
    for (int i = 0; i < cCookies; i++)
//    {
//      aCookies[i].ReadMachineNameFrom( (CHasMachineName*)this );
       aCookies[i].m_pCookieBlock = this;
//    }
  }
  virtual ~CSfmCookieBlock();
private:
  PVOID m_pvCookieData;
};


class CSfmShareCookie : public CSfmCookie
{
public:
  CSfmShareCookie() : CSfmCookie( FILEMGMT_SHARE ) {}
  virtual HRESULT GetShareName( OUT CString& strShareName );

  inline virtual DWORD GetNumOfCurrentUses() { return GetShareInfo()->afpvol_curr_uses; }
  virtual BSTR GetColumnText(int nCol);

  virtual BSTR QueryResultColumnText( int nCol, CFileMgmtComponentData& refcdata );

  inline AFP_VOLUME_INFO* GetShareInfo()
  {
    ASSERT( NULL != m_pobject );
    return (AFP_VOLUME_INFO*)m_pobject;
  }
  virtual HRESULT GetSharePIDList( OUT LPITEMIDLIST *ppidl );
};

class CSfmSessionCookie : public CSfmCookie
{
public:
  inline CSfmSessionCookie() : CSfmCookie( FILEMGMT_SESSION )
    {
    }
    
  virtual HRESULT GetSessionID( DWORD* pdwSessionID );

  inline virtual DWORD GetNumOfOpenFiles() { return GetSessionInfo()->afpsess_num_opens; }
  inline virtual DWORD GetConnectedTime() { return GetSessionInfo()->afpsess_time; }
  inline virtual DWORD GetIdleTime() { return 0; }
  virtual BSTR GetColumnText(int nCol);

  virtual BSTR QueryResultColumnText( int nCol, CFileMgmtComponentData& refcdata );
  inline AFP_SESSION_INFO* GetSessionInfo()
  {
    ASSERT( NULL != m_pobject );
    return (AFP_SESSION_INFO*)m_pobject;
  }
};

class CSfmResourceCookie : public CSfmCookie
{
public:
  CSfmResourceCookie() : CSfmCookie( FILEMGMT_RESOURCE ) {}
  virtual HRESULT GetFileID( DWORD* pdwFileID );

  inline virtual DWORD GetNumOfLocks() { return GetFileInfo()->afpfile_num_locks; }
  virtual BSTR GetColumnText(int nCol);

  virtual BSTR QueryResultColumnText( int nCol, CFileMgmtComponentData& refcdata );
  inline AFP_FILE_INFO* GetFileInfo()
  {
    ASSERT( NULL != m_pobject );
    return (AFP_FILE_INFO*)m_pobject;
  }
};

#endif // ~__SFM_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\sfmcfg.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    sfmcfg.h
        Prototypes for the configuration property page.

    FILE HISTORY:
    8/20/97 ericdav     Code moved into file managemnet snapin
        
*/

#ifndef _SFMCFG_H
#define _SFMCFG_H

#ifndef _SFMSESS_H
#include "sfmsess.h"
#endif

#ifndef _SFMFASOC_H
#include "sfmfasoc.h"
#endif

#ifndef _SFMUTIL_H
#include "sfmutil.h"
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


/////////////////////////////////////////////////////////////////////////////
//
// CMacFilesConfiguration dialog
//
/////////////////////////////////////////////////////////////////////////////
class CMacFilesConfiguration : public CPropertyPage
{
	DECLARE_DYNCREATE(CMacFilesConfiguration)

// Construction
public:
	CMacFilesConfiguration();
	~CMacFilesConfiguration();

// Dialog Data
	//{{AFX_DATA(CMacFilesConfiguration)
	enum { IDD = IDP_SFM_CONFIGURATION };
	CComboBox	m_comboAuthentication;
	CButton	m_radioSessionLimit;
	CEdit	m_editLogonMessage;
	CButton	m_radioSessionUnlimited;
	CButton	m_checkSavePassword;
	CEdit	m_editSessionLimit;
	CEdit	m_editServerName;
	CSpinButtonCtrl	m_spinSessionLimit;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMacFilesConfiguration)
	public:
	virtual BOOL OnKillActive();
	virtual void OnOK();
	virtual BOOL OnSetActive();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMacFilesConfiguration)
	virtual BOOL OnInitDialog();
	afx_msg void OnRadioSessionUnlimited();
	afx_msg void OnRadioSesssionLimit();
	afx_msg void OnCheckMsAuth();
	afx_msg void OnCheckSavePassword();
	afx_msg void OnChangeEditLogonMessage();
	afx_msg void OnChangeEditServerName();
	afx_msg void OnChangeEditSessionLimit();
	afx_msg void OnDeltaposSpinSessionLimit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnSelchangeComboAuthentication();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void	SetSessionLimit(DWORD dwSessionLimit);
	DWORD	QuerySessionLimit();
	void	UpdateRadioButtons(BOOL bUnlimitedClicked);

	DWORD	m_dwAfpOriginalOptions;
    BOOL    m_bIsNT5;

public:
    CSFMPropertySheet *     m_pSheet;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif _SFMCFG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\sfmfasoc.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    sfmfasoc.cpp
        Implementation for the file association property page.
        
    FILE HISTORY:
    8/20/97 ericdav     Code moved into file managemnet snapin
        
*/

#include "stdafx.h"
#include "sfmcfg.h"
#include "sfmfasoc.h"
#include "sfmtypes.h"
#include "sfmutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

int CompareCreators(CAfpTypeCreator * pAfpTC1, CAfpTypeCreator * pAfpTC2)
{
    CString str1, str2;

    str1 = pAfpTC1->QueryCreator();
    str2 = pAfpTC2->QueryCreator();

    return lstrcmpi(str1,str2);
}

int CompareTypes(CAfpTypeCreator * pAfpTC1, CAfpTypeCreator * pAfpTC2)
{
    CString str1, str2;

    str1 = pAfpTC1->QueryType();
    str2 = pAfpTC2->QueryType();

    return lstrcmpi(str1,str2);
}

int CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    CAfpTypeCreator * pAfpTC1 = (CAfpTypeCreator *) lParam1;
    CAfpTypeCreator * pAfpTC2 = (CAfpTypeCreator *) lParam2;

    CString str1, str2;

    int nCompare = 0;

    // special case, we want the default to show up at the top always
    if (pAfpTC1->QueryId() == AFP_DEF_TCID)
        return -1;
    else if (pAfpTC2->QueryId() == AFP_DEF_TCID)
        return 1;

    switch (lParamSort)
    {
        // creator
        case 0:
            nCompare = CompareCreators(pAfpTC1, pAfpTC2);
            if (nCompare == 0)
                nCompare = CompareTypes(pAfpTC1, pAfpTC2);
            break;

        // type
        case 1:
            nCompare = CompareTypes(pAfpTC1, pAfpTC2);
            if (nCompare == 0)
                nCompare = CompareCreators(pAfpTC1, pAfpTC2);
            break;

        // description
        case 2:
            str1 = pAfpTC1->QueryComment();
            str2 = pAfpTC2->QueryComment();

            nCompare = lstrcmpi(str1,str2);
            break;
    }

    return nCompare;
}

/////////////////////////////////////////////////////////////////////////////
// CMacFilesFileAssociation property page

IMPLEMENT_DYNCREATE(CMacFilesFileAssociation, CPropertyPage)

CMacFilesFileAssociation::CMacFilesFileAssociation() : CPropertyPage(CMacFilesFileAssociation::IDD)
{
    //{{AFX_DATA_INIT(CMacFilesFileAssociation)
    //}}AFX_DATA_INIT
    m_nSortColumn = 0;
}

CMacFilesFileAssociation::~CMacFilesFileAssociation()
{
}

void CMacFilesFileAssociation::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMacFilesFileAssociation)
    DDX_Control(pDX, IDC_LIST_TYPE_CREATORS, m_listctrlCreators);
    DDX_Control(pDX, IDC_COMBO_EXTENSION, m_comboExtension);
    DDX_Control(pDX, IDC_BUTTON_EDIT, m_buttonEdit);
    DDX_Control(pDX, IDC_BUTTON_DELETE, m_buttonDelete);
    DDX_Control(pDX, IDC_BUTTON_ASSOCIATE, m_buttonAssociate);
    DDX_Control(pDX, IDC_BUTTON_ADD, m_buttonAdd);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMacFilesFileAssociation, CPropertyPage)
    //{{AFX_MSG_MAP(CMacFilesFileAssociation)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_ASSOCIATE, OnButtonAssociate)
    ON_BN_CLICKED(IDC_BUTTON_DELETE, OnButtonDelete)
    ON_BN_CLICKED(IDC_BUTTON_EDIT, OnButtonEdit)
    ON_CBN_SELCHANGE(IDC_COMBO_EXTENSION, OnSelchangeComboExtension)
    ON_CBN_EDITCHANGE(IDC_COMBO_EXTENSION, OnEditchangeComboExtension)
    ON_NOTIFY(NM_DBLCLK, IDC_LIST_TYPE_CREATORS, OnDblclkListTypeCreators)
    ON_WM_CLOSE()
    ON_WM_CONTEXTMENU()
    ON_WM_HELPINFO()
    ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_TYPE_CREATORS, OnItemchangedListTypeCreators)
    ON_NOTIFY(LVN_COLUMNCLICK, IDC_LIST_TYPE_CREATORS, OnColumnclickListTypeCreators)
    ON_WM_DESTROY()
    ON_WM_COMPAREITEM()
    ON_WM_DRAWITEM()
    ON_WM_DELETEITEM()
    ON_NOTIFY(LVN_DELETEITEM, IDC_LIST_TYPE_CREATORS, OnDeleteitemListTypeCreators)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMacFilesFileAssociation message handlers

BOOL CMacFilesFileAssociation::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();

    m_comboExtension.LimitText(AFP_EXTENSION_LEN);

    InitListCtrl();

    // 
    // Fill in the data from the server for extensions and type creators
    //
    Update();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CMacFilesFileAssociation::OnButtonAdd() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CTypeCreatorAddDlg    dlgAdd(&m_listctrlCreators, m_pSheet->m_hAfpServer, m_pSheet->m_strHelpFilePath);
        
    CThemeContextActivator activator;
    if (dlgAdd.DoModal() == IDOK)
    {
        //
        // Refresh the dialog
        //
        DWORD err = Refresh();
        if ( err != NO_ERROR )
        {
            ::SFMMessageBox(err);

            return;
        }

        SelectTypeCreator(dlgAdd.m_strCreator, dlgAdd.m_strType);
    }
}

void CMacFilesFileAssociation::OnButtonEdit() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CAfpTypeCreator *       pAfpTC = GetTCObject(-1);  // Get current TC Object
    if (!pAfpTC)
        return;

    CTypeCreatorEditDlg        dlgEdit(pAfpTC, m_pSheet->m_hAfpServer, m_pSheet->m_strHelpFilePath);
    
    CThemeContextActivator activator;
    if (dlgEdit.DoModal() == IDOK)
    {
        //
        // Refresh the dialog.
        //
        DWORD err = Refresh();
        if ( err != NO_ERROR )
        {
            ::SFMMessageBox(err);
            
            return;
        }
    }

    if (m_buttonEdit.GetButtonStyle() == BS_DEFPUSHBUTTON)
        m_buttonEdit.SetFocus();
}

void CMacFilesFileAssociation::OnButtonAssociate() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    
    //
    //  The user pressed the Associate button. So associate the currently
    //  selected Extension with the currently selected type/creator.
    //
    AFP_TYPE_CREATOR AfpTypeCreator;
    AFP_EXTENSION      AfpExtension;
    DWORD              err;
    CString             strExtension;

    if ( !g_SfmDLL.LoadFunctionPointers() )
        return;

    m_comboExtension.GetWindowText(strExtension);
    strExtension.MakeUpper();

    ::ZeroMemory(&AfpTypeCreator, sizeof(AfpTypeCreator));
    ::ZeroMemory(&AfpExtension, sizeof(AfpExtension));

    ::CopyMemory(AfpExtension.afpe_extension, (LPCTSTR) strExtension, strExtension.GetLength() * sizeof(TCHAR));

    CAfpTypeCreator * pAfpTC = GetTCObject(-1);  // Get Current TC Object
    if (!pAfpTC)
        return;

    ::CopyMemory(AfpTypeCreator.afptc_creator, pAfpTC->QueryCreator(), pAfpTC->QueryCreatorLength() * sizeof(TCHAR));
    ::CopyMemory(AfpTypeCreator.afptc_type, pAfpTC->QueryType(), pAfpTC->QueryTypeLength() * sizeof(TCHAR));
    ::CopyMemory(AfpTypeCreator.afptc_comment, pAfpTC->QueryComment(), pAfpTC->QueryCommentLength() * sizeof(TCHAR));
    
    AfpTypeCreator.afptc_id = pAfpTC->QueryId();

    err = ((ETCMAPASSOCIATEPROC) g_SfmDLL[AFP_ETC_MAP_ASSOCIATE])(m_pSheet->m_hAfpServer,
                                                                  &AfpTypeCreator,    
                                                                  &AfpExtension );
    if ( err != NO_ERROR )
    {
        ::SFMMessageBox(err);
    }

    //
    // Refresh the dialog
    //
    err = Refresh();
    if ( err != NO_ERROR )
    {
        ::SFMMessageBox(err);
    }
}

void CMacFilesFileAssociation::OnButtonDelete() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    //  The user pressed the Delete button.  Delete the currently
    //  selected type/creator pair
    //
    AFP_TYPE_CREATOR    AfpTypeCreator;
    CAfpTypeCreator *    pAfpTC = GetTCObject(-1);  // Get Current TC Object
    if (!pAfpTC)
        return;

    DWORD               err;

    if ( !g_SfmDLL.LoadFunctionPointers() )
        return;

    //
    // First warn the user.
    //
    if (::AfxMessageBox(IDS_DELETE_TC_CONFIRM,
                        MB_ICONEXCLAMATION | MB_YESNO) == IDNO )
    {
        return;
    }


    ::ZeroMemory( &AfpTypeCreator, sizeof(AfpTypeCreator) );
    
    CopyMemory(AfpTypeCreator.afptc_creator, 
               pAfpTC->QueryCreator(), 
               pAfpTC->QueryCreatorLength() * sizeof(TCHAR));
    
    CopyMemory(AfpTypeCreator.afptc_type, 
               pAfpTC->QueryType(), 
               pAfpTC->QueryTypeLength() * sizeof(TCHAR));

    err = ((ETCMAPDELETEPROC) g_SfmDLL[AFP_ETC_MAP_DELETE])(m_pSheet->m_hAfpServer, &AfpTypeCreator);
    if ( err != NO_ERROR )
    {
        ::SFMMessageBox(err);
    }

    //
    // Refresh the dialog.
    //
    err = Refresh();
    if ( err != NO_ERROR )
    {
        ::SFMMessageBox(err);

        return;
    }

    if ((m_buttonDelete.GetButtonStyle() == BS_DEFPUSHBUTTON) ||
        (m_buttonEdit.GetButtonStyle() == BS_DEFPUSHBUTTON))
    {
        //
        // The delete button has focus so we need to move 
        // the focus elsewhere because this button will be
        // disabled.  Let's set it to the add button.
        //
        m_buttonAdd.SetFocus();
        m_buttonAdd.SetButtonStyle(BS_DEFPUSHBUTTON);
        m_buttonDelete.SetButtonStyle(BS_PUSHBUTTON);
        m_buttonEdit.SetButtonStyle(BS_PUSHBUTTON);
    }
}

void CMacFilesFileAssociation::OnSelchangeComboExtension() 
{
    int        nCurIndex = m_comboExtension.GetCurSel();

    if (nCurIndex != -1)
    {
        //
        // Select the matching type creator (if exists) and enable associate button
        //
        SelectTypeCreator((DWORD)m_comboExtension.GetItemData(nCurIndex));
        m_buttonAssociate.EnableWindow(TRUE);
    }
    else
    {
        m_buttonAssociate.EnableWindow(FALSE);
    }
}
    

void CMacFilesFileAssociation::OnEditchangeComboExtension() 
{
    CString strCurText;
    
    m_comboExtension.GetWindowText(strCurText);
    strCurText.MakeUpper();

    if (strCurText.IsEmpty())
    {
        //
        // User cleared out the edit box, go to the default type creator
        //
        m_buttonAssociate.EnableWindow(FALSE);
        SelectTypeCreator(AFP_DEF_TCID);
    }
    else
    {
        int nIndexFound = m_comboExtension.FindStringExact(-1, strCurText);
        if (nIndexFound != CB_ERR)
        {
            //
            // See if what the user has typed matches an extension in the listbox.
            // Set the item to be the current one.
            //
            SelectTypeCreator((DWORD)m_comboExtension.GetItemData(nIndexFound));
        }

        m_buttonAssociate.EnableWindow(TRUE);
    }
}

void CMacFilesFileAssociation::OnDblclkListTypeCreators(NMHDR* /*pNMHDR*/, LRESULT* pResult) 
{
    CAfpTypeCreator * pAfpTC = GetTCObject(-1); // Get Current TC Object

    //
    // Do not allow editing of the default type/creator
    //
    if (pAfpTC && pAfpTC->QueryId() != AFP_DEF_TCID)
        OnButtonEdit();

    *pResult = 0;
}


/////////////////////////////////////////////////////////////////////////////
// CMacFilesFileAssociation helper functions

void CMacFilesFileAssociation::EnableControls(BOOL fEnable)
{

    if (fEnable)
    {
        m_buttonDelete.EnableWindow(TRUE);
        m_buttonEdit.EnableWindow(TRUE);
    }
    else
    {
        if ( (m_buttonEdit.GetState() & 0x0008) || 
             (m_buttonDelete.GetState() & 0x0008) )
        {
            //m_listctrlCreators.SetFocus();
        }

        m_buttonDelete.EnableWindow(FALSE);
        m_buttonEdit.EnableWindow(FALSE);
    }
} 


DWORD CMacFilesFileAssociation::SelectTypeCreator(DWORD dwId)
{
    DWORD dwIdSelected = (DWORD)-1;

    // 
    // Find the corresponding type creator if there is one
    // and select it
    //
    for (int i = 0; i < m_listctrlCreators.GetItemCount(); i++)
    {
        CAfpTypeCreator * pAfpTC = GetTCObject(i);  // Get TC object associated with this item

        if (pAfpTC && pAfpTC->QueryId() == dwId)
        {
            SetCurSel(i);
            dwIdSelected = pAfpTC->QueryId();
            break;
        }
    }

    if (dwIdSelected == AFP_DEF_TCID || dwIdSelected == (DWORD)-1)
        EnableControls(FALSE);
    else
        EnableControls(TRUE);

    return dwIdSelected;
}

DWORD CMacFilesFileAssociation::SelectTypeCreator(CString & strCreator, CString & strType)
{
    DWORD dwIdSelected = (DWORD)-1;
    
    // 
    // Find the corresponding type creator if there is one
    // and select it
    //
    for (int i = 0; i < m_listctrlCreators.GetItemCount(); i++)
    {
        CAfpTypeCreator * pAfpTC = GetTCObject(i);  // Get TC object associated with this item

        if ( pAfpTC &&
             (lstrcmp(strCreator, pAfpTC->QueryCreator()) == 0) && 
             (lstrcmp(strType, pAfpTC->QueryType()) == 0) )
        {
            SetCurSel(i);
            dwIdSelected = pAfpTC->QueryId();
            break;
        }
    }

    if (dwIdSelected == AFP_DEF_TCID || dwIdSelected == (DWORD)-1)
        EnableControls(FALSE);
    else
        EnableControls(TRUE);

    return dwIdSelected;
}

DWORD CMacFilesFileAssociation::Update()
{
  PAFP_ETCMAP_INFO    pAfpEtcMapInfo = NULL;
    DWORD                err;
    
  if ( !g_SfmDLL.LoadFunctionPointers() )
    return S_OK;

  //
  // Get the new data
  //
  err = ((ETCMAPGETINFOPROC) g_SfmDLL[AFP_ETC_MAP_GET_INFO])(m_pSheet->m_hAfpServer, 
                                                             (LPBYTE *)&pAfpEtcMapInfo);
  if ( err != NO_ERROR )
  {
      // 
      // Couldn't get the info...
      // 
      return err;
    }

    //
    // Update the extensions COMBOBOX.
    //
    m_comboExtension.ResetContent();
    PAFP_EXTENSION pAfpExtensions = pAfpEtcMapInfo->afpetc_extension;

    for (UINT i = 0; i < pAfpEtcMapInfo->afpetc_num_extensions; i++)
    {
        int nIndex = m_comboExtension.AddString(pAfpExtensions->afpe_extension);
        m_comboExtension.SetItemData(nIndex, pAfpExtensions->afpe_tcid);
        
        pAfpExtensions++;
    }

    m_comboExtension.SetCurSel(-1);
    m_buttonAssociate.EnableWindow(FALSE);

  //
  //  Update the type/creator listbox
  //
  //
  //  let's nuke everything in the listbox.
  //
  ClearListCtrl();

    PAFP_TYPE_CREATOR pAfpTypeCreators = pAfpEtcMapInfo->afpetc_type_creator;

    for (i = 0; i < pAfpEtcMapInfo->afpetc_num_type_creators; i++)
    {
        CAfpTypeCreator * pItemData = new CAfpTypeCreator(pAfpTypeCreators);

    InsertItem(pItemData);

        pAfpTypeCreators++;
    }
    
  if ( pAfpEtcMapInfo != NULL )
  {
    ((SFMBUFFERFREEPROC) g_SfmDLL[AFP_BUFFER_FREE])(pAfpEtcMapInfo);
  }

  m_listctrlCreators.SortItems(CompareFunc, m_nSortColumn);

  // 
    // Set the current selection to be the default type creator
    //
  SelectTypeCreator(AFP_DEF_TCID);

    return NO_ERROR;
}

void CMacFilesFileAssociation::InitListCtrl()
{
    CString strText;

    strText.LoadString(IDS_CREATOR);
    m_listctrlCreators.InsertColumn(0, strText, LVCFMT_LEFT, 50);

    strText.LoadString(IDS_TYPE);
    m_listctrlCreators.InsertColumn(1, strText, LVCFMT_LEFT, 50);

    strText.LoadString(IDS_DESCRIPTION);
    m_listctrlCreators.InsertColumn(2, strText, LVCFMT_LEFT, 175);

    ListView_SetExtendedListViewStyle(m_listctrlCreators.GetSafeHwnd(), LVS_EX_FULLROWSELECT);
}

void CMacFilesFileAssociation::ClearListCtrl()
{
    m_listctrlCreators.DeleteAllItems();
}

void CMacFilesFileAssociation::InsertItem(CAfpTypeCreator * pItemData)
{
    int nIndex = m_listctrlCreators.InsertItem(0, pItemData->QueryCreator());
    m_listctrlCreators.SetItemText(nIndex, 1, pItemData->QueryType());
    m_listctrlCreators.SetItemText(nIndex, 2, pItemData->QueryComment());

    m_listctrlCreators.SetItemData(nIndex, (DWORD_PTR) pItemData);
}

void CMacFilesFileAssociation::SetCurSel(int nIndex)
{
    LV_ITEM lvItem;

    ZeroMemory(&lvItem, sizeof(lvItem));

    lvItem.iItem = nIndex;
    lvItem.mask = LVIF_STATE;
    lvItem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
    lvItem.state = LVIS_SELECTED | LVIS_FOCUSED;
    
    m_listctrlCreators.SetItem(&lvItem);

    m_listctrlCreators.EnsureVisible(nIndex, FALSE);
}

int CMacFilesFileAssociation::GetCurSel()
{
    return m_listctrlCreators.GetNextItem(-1, LVNI_SELECTED);
}

DWORD CMacFilesFileAssociation::Refresh()
{
    //
    // Find out the type creator that has the current focus.
    //
    CAfpTypeCreator *   pAfpTC = GetTCObject(-1);  // Get Current TC Object
    if (!pAfpTC)
        return NO_ERROR;

    DWORD dwIdCreator = pAfpTC->QueryId();
    
    CWnd * pFocusWnd = CWnd::GetFocus();

    //
    // Find out the extension that has the current focus
    //
    DWORD    err;
    CString    strCurExtension;

    m_comboExtension.GetWindowText(strCurExtension);
    strCurExtension.MakeUpper();
   
    if ( (err = Update()) != NO_ERROR )
    {
        if (pFocusWnd)
            pFocusWnd->SetFocus();

        return err;
    }

    DWORD dwIdSelected = SelectTypeCreator(dwIdCreator);

  //
  // Set the extension to what it was before
  //
  if (strCurExtension.IsEmpty())
  {
    m_buttonAssociate.EnableWindow(FALSE);
  }
  else
  {
    m_comboExtension.SetWindowText(strCurExtension);
    m_buttonAssociate.EnableWindow(TRUE);
  }

    if (pFocusWnd)
        pFocusWnd->SetFocus();

    return NO_ERROR;
}

CAfpTypeCreator * CMacFilesFileAssociation::GetTCObject(int nIndex)
{
    if (-1 == nIndex)
        nIndex = GetCurSel();

    if (-1 == nIndex)
        return NULL;

    return (CAfpTypeCreator *) m_listctrlCreators.GetItemData(nIndex);
}

void CMacFilesFileAssociation::OnClose() 
{
    ClearListCtrl();

    m_comboExtension.ResetContent();
    
    CPropertyPage::OnClose();
}

BOOL CMacFilesFileAssociation::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
                   m_pSheet->m_strHelpFilePath,
                   HELP_WM_HELP,
                   g_aHelpIDs_CONFIGURE_SFM);
    }
    
    return TRUE;
}

void CMacFilesFileAssociation::OnContextMenu(CWnd* pWnd, CPoint /*point*/) 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (this == pWnd)
        return;

    ::WinHelp (pWnd->m_hWnd,
               m_pSheet->m_strHelpFilePath,
               HELP_CONTEXTMENU,
               g_aHelpIDs_CONFIGURE_SFM);
}

void CMacFilesFileAssociation::OnItemchangedListTypeCreators(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    // 
    // Get the selected item's data which points to a TypeCreator object.
    // Check the ID of that object to see how we should enable the buttons.
    //
  if (pNMListView->uNewState & LVIS_SELECTED)
  {
      CAfpTypeCreator * pAfpTC = GetTCObject(-1);  // Get Current TC Object
      if (pAfpTC)
      {
          DWORD dwId = pAfpTC->QueryId();

          if (dwId == AFP_DEF_TCID || dwId == (DWORD)-1)
              EnableControls(FALSE);
          else
              EnableControls(TRUE);
      }
  }
    
    *pResult = 0;
}

void CMacFilesFileAssociation::OnColumnclickListTypeCreators(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    m_nSortColumn = pNMListView->iSubItem;
    m_listctrlCreators.SortItems(CompareFunc, m_nSortColumn);
    
    *pResult = 0;
}

void CMacFilesFileAssociation::OnDestroy() 
{
    CPropertyPage::OnDestroy();
    
    ClearListCtrl();

    m_comboExtension.ResetContent();
}

void CMacFilesFileAssociation::OnDeleteitemListTypeCreators(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;

    delete (CAfpTypeCreator *) pNMListView->lParam;
    
    *pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\sfmcfg.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    sfmcfg.cpp
        Implementation for the configuration property page.

    FILE HISTORY:
    8/20/97 ericdav     Code moved into file managemnet snapin
        
*/

#include "stdafx.h"
#include "sfmcfg.h"
#include "sfmutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//
// CMacFilesConfiguration property page
//
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNCREATE(CMacFilesConfiguration, CPropertyPage)

CMacFilesConfiguration::CMacFilesConfiguration() 
    : CPropertyPage(CMacFilesConfiguration::IDD),
      m_bIsNT5(FALSE)
{
  //{{AFX_DATA_INIT(CMacFilesConfiguration)
  //}}AFX_DATA_INIT
}

CMacFilesConfiguration::~CMacFilesConfiguration()
{
}

void CMacFilesConfiguration::DoDataExchange(CDataExchange* pDX)
{
  CPropertyPage::DoDataExchange(pDX);
  //{{AFX_DATA_MAP(CMacFilesConfiguration)
  DDX_Control(pDX, IDC_COMBO_AUTHENTICATION, m_comboAuthentication);
  DDX_Control(pDX, IDC_RADIO_SESSSION_LIMIT, m_radioSessionLimit);
  DDX_Control(pDX, IDC_EDIT_LOGON_MESSAGE, m_editLogonMessage);
  DDX_Control(pDX, IDC_RADIO_SESSION_UNLIMITED, m_radioSessionUnlimited);
  DDX_Control(pDX, IDC_CHECK_SAVE_PASSWORD, m_checkSavePassword);
  DDX_Control(pDX, IDC_EDIT_SESSION_LIMIT, m_editSessionLimit);
  DDX_Control(pDX, IDC_EDIT_SERVER_NAME, m_editServerName);
  //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMacFilesConfiguration, CPropertyPage)
  //{{AFX_MSG_MAP(CMacFilesConfiguration)
  ON_BN_CLICKED(IDC_RADIO_SESSION_UNLIMITED, OnRadioSessionUnlimited)
  ON_BN_CLICKED(IDC_RADIO_SESSSION_LIMIT, OnRadioSesssionLimit)
  ON_BN_CLICKED(IDC_CHECK_SAVE_PASSWORD, OnCheckSavePassword)
  ON_EN_CHANGE(IDC_EDIT_LOGON_MESSAGE, OnChangeEditLogonMessage)
  ON_EN_CHANGE(IDC_EDIT_SERVER_NAME, OnChangeEditServerName)
  ON_EN_CHANGE(IDC_EDIT_SESSION_LIMIT, OnChangeEditSessionLimit)
  ON_WM_CREATE()
  ON_WM_DESTROY()
  ON_WM_HELPINFO()
  ON_WM_CONTEXTMENU()
  ON_CBN_SELCHANGE(IDC_COMBO_AUTHENTICATION, OnSelchangeComboAuthentication)
  //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
//
// CMacFilesConfiguration message handlers
//
/////////////////////////////////////////////////////////////////////////////
BOOL CMacFilesConfiguration::OnInitDialog() 
{
  CPropertyPage::OnInitDialog();

    AFX_MANAGE_STATE(AfxGetStaticModuleState());
  
    PAFP_SERVER_INFO        pAfpServerInfo;
  DWORD              err;
    CString                         strTemp;

  if ( !g_SfmDLL.LoadFunctionPointers() )
    return S_OK;

    //
  // Setup our controls
  //
  m_editSessionLimit.LimitText(10);
  
  //
  // Get the info from the server
  //
  err = ((SERVERGETINFOPROC) g_SfmDLL[AFP_SERVER_GET_INFO])(m_pSheet->m_hAfpServer,
                                                              (LPBYTE*) &pAfpServerInfo);
  if (err != NO_ERROR)
  {
    ::SFMMessageBox(err);
    
    //
    // Just to setup the radio buttons
    //
    SetSessionLimit(AFP_MAXSESSIONS);

    return TRUE;
  }

    err = m_pSheet->IsNT5Machine(m_pSheet->m_strMachine, &m_bIsNT5);
  if (err != NO_ERROR)
  {
    m_bIsNT5 = FALSE;   // Assume NT4
  }

  //
  // Since we can't just specify which options we want to set,
  // we need to save off the original options and then just
  // change the ones we expose through this UI.  We don't want
  // to disturb the others.
  //
  m_dwAfpOriginalOptions = pAfpServerInfo->afpsrv_options;

    // 
    // Set the information
    // 
  m_editServerName.SetLimitText(AFP_SERVERNAME_LEN);
    m_editServerName.SetWindowText(pAfpServerInfo->afpsrv_name);

    m_checkSavePassword.SetCheck( 
        (INT)(pAfpServerInfo->afpsrv_options &
              AFP_SRVROPT_ALLOWSAVEDPASSWORD ));

    // fill in the combo box and select the correct item
    // combobox is not sorted so this is the order of the items
    strTemp.LoadString(IDS_AUTH_MS_ONLY);
    m_comboAuthentication.AddString(strTemp);

    strTemp.LoadString(IDS_AUTH_APPLE_CLEARTEXT);
    m_comboAuthentication.AddString(strTemp);

    if (m_bIsNT5)
    {
        strTemp.LoadString(IDS_AUTH_APPLE_ENCRYPTED);
        m_comboAuthentication.AddString(strTemp);
    
        strTemp.LoadString(IDS_AUTH_CLEARTEXT_OR_MS);
        m_comboAuthentication.AddString(strTemp);
    
        strTemp.LoadString(IDS_AUTH_ENCRYPTED_OR_MS);
        m_comboAuthentication.AddString(strTemp);
    }
    
    BOOL bCleartext = pAfpServerInfo->afpsrv_options & AFP_SRVROPT_CLEARTEXTLOGONALLOWED;
    
    // default NT4 value for MS AUM 
    BOOL bMS = (bCleartext) ? FALSE : TRUE;
    if (m_bIsNT5)
    {
        bMS = pAfpServerInfo->afpsrv_options & AFP_SRVROPT_MICROSOFT_UAM;
    }

    BOOL bEncrypted = pAfpServerInfo->afpsrv_options & AFP_SRVROPT_NATIVEAPPLEUAM;

    if (bEncrypted && bMS)
        m_comboAuthentication.SetCurSel(4);
    else
    if (bCleartext && bMS)
        m_comboAuthentication.SetCurSel(3);
    else
    if (bEncrypted)
        m_comboAuthentication.SetCurSel(2);
    else
    if (bCleartext)
        m_comboAuthentication.SetCurSel(1);
    else
        m_comboAuthentication.SetCurSel(0);

  SetSessionLimit(pAfpServerInfo->afpsrv_max_sessions);
  
    //
    //  Direct the message edit control not to add end-of-line
    //  character from wordwrapped text lines.
    //
  m_editLogonMessage.SetLimitText(AFP_MESSAGE_LEN);
    m_editLogonMessage.FmtLines(FALSE);

    m_editLogonMessage.SetWindowText(pAfpServerInfo->afpsrv_login_msg);

    ((SFMBUFFERFREEPROC) g_SfmDLL[AFP_BUFFER_FREE])(pAfpServerInfo);

    SetModified(FALSE);

  return TRUE;  // return TRUE unless you set the focus to a control
          // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CMacFilesConfiguration::OnKillActive() 
{
  // TODO: Add your specialized code here and/or call the base class
  
  return CPropertyPage::OnKillActive();
}

void CMacFilesConfiguration::OnOK() 
{
  // TODO: Add your specialized code here and/or call the base class
  
  CPropertyPage::OnOK();
}

BOOL CMacFilesConfiguration::OnSetActive() 
{
  // TODO: Add your specialized code here and/or call the base class
  
  return CPropertyPage::OnSetActive();
}

void CMacFilesConfiguration::OnRadioSessionUnlimited() 
{
  SetModified(TRUE);
  UpdateRadioButtons(TRUE);
}

void CMacFilesConfiguration::OnRadioSesssionLimit() 
{
  SetModified(TRUE);
  UpdateRadioButtons(FALSE);
}

void 
CMacFilesConfiguration::UpdateRadioButtons
(
  BOOL  bUnlimitedClicked
)
{
  if (bUnlimitedClicked)
  {
    m_radioSessionUnlimited.SetCheck(1);
    m_radioSessionLimit.SetCheck(0);

    m_editSessionLimit.EnableWindow(FALSE);  
  }
  else
  {
    m_radioSessionUnlimited.SetCheck(0);
    m_radioSessionLimit.SetCheck(1);

    m_editSessionLimit.EnableWindow(TRUE);  
  }
}

void 
CMacFilesConfiguration::SetSessionLimit
(
  DWORD dwSessionLimit 
)
{
  if ( dwSessionLimit == AFP_MAXSESSIONS )
  {
    //
    // Set selection to the  Unlimited button
    //
    m_radioSessionUnlimited.SetCheck(1);

    dwSessionLimit = 1; 
    UpdateRadioButtons(TRUE);
  }
  else 
  {
    //
    // Set the sessions button to the value
    //
    m_radioSessionUnlimited.SetCheck(0);

    m_spinSessionLimit.SetPos( dwSessionLimit );
    UpdateRadioButtons(FALSE);
  }

  CString cstrSessionLimit;
  cstrSessionLimit.Format(_T("%u"), dwSessionLimit);
  m_editSessionLimit.SetWindowText(cstrSessionLimit);
}

DWORD 
CMacFilesConfiguration::QuerySessionLimit()
{
  if (m_radioSessionUnlimited.GetCheck())
  {
    return AFP_MAXSESSIONS;
  }
  else
  {
    CString strSessionLimit;

    m_editSessionLimit.GetWindowText(strSessionLimit);

    strSessionLimit.TrimLeft();
    strSessionLimit.TrimRight();

    //
    // Strip off any leading zeros
    //
    int nCount = 0;

    while (strSessionLimit[nCount] == _T('0'))
    {
      nCount++;
    }
      
    if (nCount)
    {
      //
      // Leading zeros, strip off and set the text
      //
      strSessionLimit = strSessionLimit.Right(strSessionLimit.GetLength() - nCount);
    }

    // set dwSessionLimit to 0 if it is outside the range [1, AFP_MAXSESSIONS]
    DWORD dwSessionLimit = 0;
    if (!strSessionLimit.IsEmpty())
    {
        __int64 i64SessionLimit = _wtoi64(strSessionLimit);
        if (i64SessionLimit <= AFP_MAXSESSIONS)
            dwSessionLimit = (DWORD)i64SessionLimit;
    }

    return dwSessionLimit;
  }
}

void CMacFilesConfiguration::OnSelchangeComboAuthentication() 
{
  SetModified(TRUE);
}

void CMacFilesConfiguration::OnCheckSavePassword() 
{
  SetModified(TRUE);
}

void CMacFilesConfiguration::OnChangeEditLogonMessage() 
{
  SetModified(TRUE);
}

void CMacFilesConfiguration::OnChangeEditServerName() 
{
  SetModified(TRUE);
}

void CMacFilesConfiguration::OnChangeEditSessionLimit() 
{
  SetModified(TRUE);
}

BOOL CMacFilesConfiguration::OnApply() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

  AFP_SERVER_INFO  AfpServerInfo;
  DWORD      dwParmNum = 0;
  DWORD      err;
  CString      strServerName;
  CString      strLogonMessage;

  if ( !g_SfmDLL.LoadFunctionPointers() )
    return S_OK;

    ::ZeroMemory(&AfpServerInfo, sizeof(AfpServerInfo));

  //
    // Get the server name
    //
  if (m_editServerName.GetModify())
  {
    m_editServerName.GetWindowText(strServerName);
    strServerName.TrimLeft();
    strServerName.TrimRight();

    if ( strServerName.IsEmpty() )
    {
      ::AfxMessageBox(IDS_NEED_SERVER_NAME);
      m_editServerName.SetFocus();

      return FALSE;
    }

    //
    // Validate the server name
    // 

    if ( strServerName.Find(_T(':') ) != -1 )
    {
      ::AfxMessageBox( IDS_AFPERR_InvalidServerName );

      m_editServerName.SetFocus();
      m_editServerName.SetSel(0, -1);

      return FALSE;
    }

         //
    // Warn the user that the change won't take effect until 
    // the service is restarted.
    //
    if (!m_bIsNT5)
        {
            ::AfxMessageBox(IDS_SERVERNAME_CHANGE, MB_ICONEXCLAMATION);
        }

    AfpServerInfo.afpsrv_name = (LPWSTR) ((LPCWSTR) strServerName);
      dwParmNum |= AFP_SERVER_PARMNUM_NAME;
  
    m_editServerName.SetModify(FALSE);
  }
  
    //
    // Get the logon message 
    //
  if (m_editLogonMessage.GetModify())
  {
    m_editLogonMessage.GetWindowText(strLogonMessage);
    strLogonMessage.TrimLeft();
    strLogonMessage.TrimRight();

    //
    // Was there any text ?
    //
    if ( strLogonMessage.IsEmpty() )    // always has a terminating NULL
    {
         AfpServerInfo.afpsrv_login_msg = NULL;
    }
    else
    {
      if ( strLogonMessage.GetLength() > AFP_MESSAGE_LEN )
      {
        ::AfxMessageBox(IDS_MESSAGE_TOO_LONG);

        // Set focus to the edit box and select the text
        m_editLogonMessage.SetFocus();
        m_editLogonMessage.SetSel(0, -1);

        return(FALSE);
      }

      AfpServerInfo.afpsrv_login_msg = (LPWSTR) ((LPCWSTR) strLogonMessage);
    }

    dwParmNum |= AFP_SERVER_PARMNUM_LOGINMSG;

    m_editLogonMessage.SetModify(FALSE);
  }

    //
  // Restore the original options and then just update the ones we 
  // are able to change
  //
  AfpServerInfo.afpsrv_options = m_dwAfpOriginalOptions;

    //
  // Set the server options to whatever the user set
    //
  if (m_checkSavePassword.GetCheck())
  {
    //
    // Set the option bit
    //
    AfpServerInfo.afpsrv_options |= AFP_SRVROPT_ALLOWSAVEDPASSWORD;
  }
  else
  {
    //
    // Clear the option bit
    //
    AfpServerInfo.afpsrv_options &= ~AFP_SRVROPT_ALLOWSAVEDPASSWORD;
  }

    // set the correct authentication options depending upon what is selected
    switch (m_comboAuthentication.GetCurSel())
    {
        case 0:
            // MS Auth only
            if (!m_bIsNT5)
            {
            AfpServerInfo.afpsrv_options &= ~AFP_SRVROPT_MICROSOFT_UAM;
            }
            else
            {
            AfpServerInfo.afpsrv_options |= AFP_SRVROPT_MICROSOFT_UAM;
            }

            AfpServerInfo.afpsrv_options &= ~AFP_SRVROPT_CLEARTEXTLOGONALLOWED;
        AfpServerInfo.afpsrv_options &= ~AFP_SRVROPT_NATIVEAPPLEUAM;
            break;

        case 1:
            // Apple cleartext
            AfpServerInfo.afpsrv_options |= AFP_SRVROPT_CLEARTEXTLOGONALLOWED;
        AfpServerInfo.afpsrv_options &= ~AFP_SRVROPT_MICROSOFT_UAM;
        AfpServerInfo.afpsrv_options &= ~AFP_SRVROPT_NATIVEAPPLEUAM;
            break;

        case 2:
            // Apple encrypted (only on NT5)
        AfpServerInfo.afpsrv_options &= ~AFP_SRVROPT_CLEARTEXTLOGONALLOWED;
        AfpServerInfo.afpsrv_options &= ~AFP_SRVROPT_MICROSOFT_UAM;
        AfpServerInfo.afpsrv_options |= AFP_SRVROPT_NATIVEAPPLEUAM;
            break;

        case 3:
            // Cleartext or MS (only on NT5)
        AfpServerInfo.afpsrv_options |= AFP_SRVROPT_CLEARTEXTLOGONALLOWED;
        AfpServerInfo.afpsrv_options |= AFP_SRVROPT_MICROSOFT_UAM;
        AfpServerInfo.afpsrv_options &= ~AFP_SRVROPT_NATIVEAPPLEUAM;
            break;

        case 4:
            // Apple Encrypted or MS (only on NT5)
        AfpServerInfo.afpsrv_options &= ~AFP_SRVROPT_CLEARTEXTLOGONALLOWED;
        AfpServerInfo.afpsrv_options |= AFP_SRVROPT_MICROSOFT_UAM;
        AfpServerInfo.afpsrv_options |= AFP_SRVROPT_NATIVEAPPLEUAM;
            break;

        default:
            ASSERT(FALSE);
            break;
    }

    // if we are enabling an authentication type that has apple encrypted
    // then we need to warn the user.
    if ( (AfpServerInfo.afpsrv_options & AFP_SRVROPT_NATIVEAPPLEUAM) &&
         !(m_dwAfpOriginalOptions & AFP_SRVROPT_NATIVEAPPLEUAM) )
    {
        if (AfxMessageBox(IDS_AUTH_WARNING, MB_OKCANCEL) == IDCANCEL)
        {
            m_comboAuthentication.SetFocus();
            return FALSE;
        }
    }

    //
  // Get the session limit
  //
  AfpServerInfo.afpsrv_max_sessions = QuerySessionLimit();
  if (0 == AfpServerInfo.afpsrv_max_sessions)
  {
      DoErrMsgBox(
           m_hWnd,
           MB_OK,
           0,
           IDS_INVALID_SESSIONLIMIT,
           AFP_MAXSESSIONS);
      m_editSessionLimit.SetFocus();

      return FALSE;
  }

    //
    //  Now tell the server about it
    //
  dwParmNum |= ( AFP_SERVER_PARMNUM_OPTIONS  |
           AFP_SERVER_PARMNUM_MAX_SESSIONS );

    err = ((SERVERSETINFOPROC) g_SfmDLL[AFP_SERVER_SET_INFO])(m_pSheet->m_hAfpServer,  
                                              (LPBYTE)&AfpServerInfo, 
                                              dwParmNum );
    if ( err != NO_ERROR )
    {
    ::SFMMessageBox(err);
    
    return FALSE;
  }

  // update our options
    m_dwAfpOriginalOptions = AfpServerInfo.afpsrv_options;

    //
  // Clear the modified status for this page
  //
  SetModified(FALSE);

  return TRUE;
}


int CMacFilesConfiguration::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
  if (CPropertyPage::OnCreate(lpCreateStruct) == -1)
    return -1;
  
    HWND hParent = ::GetParent(m_hWnd);
  _ASSERTE(hParent);
  
    if (m_pSheet)
    {
        m_pSheet->AddRef();
        m_pSheet->SetSheetWindow(hParent);
    }

  return 0;
}

void CMacFilesConfiguration::OnDestroy() 
{
  CPropertyPage::OnDestroy();
  
    if (m_pSheet)
    {
        SetEvent(m_pSheet->m_hDestroySync);
        m_pSheet->SetSheetWindow(NULL);
        m_pSheet->Release();
    }
  
}

BOOL CMacFilesConfiguration::OnHelpInfo(HELPINFO* pHelpInfo) 
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  
  if (pHelpInfo->iContextType == HELPINFO_WINDOW)
  {
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
               m_pSheet->m_strHelpFilePath,
               HELP_WM_HELP,
               g_aHelpIDs_CONFIGURE_SFM);
  }
  
  return TRUE;
}

void CMacFilesConfiguration::OnContextMenu(CWnd* pWnd, CPoint /*point*/) 
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (this == pWnd)
    return;

    ::WinHelp (pWnd->m_hWnd,
               m_pSheet->m_strHelpFilePath,
               HELP_CONTEXTMENU,
           g_aHelpIDs_CONFIGURE_SFM);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\sfmhelp.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
	sfmhelp.h
		help file ID map
		
    FILE HISTORY:
    8/20/97 ericdav     Code moved into file managemnet snapin
    8/27/97 ericdav     HIDx's generated on 8/27/97
    12/18/97 ericdav    removed AUTH checkbox and added AUTH combobox    
*/

// FILEMGMT Identifiers 
// Dialogs (IDD_*) 
#define HIDD_FILEMANAGEMENT_GENERAL             0x20064
#define HIDD_FILE_FILEMANAGEMENT_GENERAL        0x20065
#define HIDD_PROPPAGE_SERVICE_GENERAL           0x200D3
#define HIDD_PROPPAGE_SERVICE_HWPROFILE         0x200D4
#define HIDD_PROPPAGE_SERVICE_RECOVERY          0x200D5
#define HIDD_SERVICE_REBOOT_COMPUTER            0x200D6
#define HIDD_SERVICE_STOP_DEPENDENCIES          0x200D7
#define HIDD_SERVICE_CONTROL_PROGRESS           0x200DB
#define HIDD_SHAREPROP_GENERAL                  0x200DF
#define HIDD_CHOOSER_CHOOSE_MACHINE             0x203CA
#define HIDD_SFM_TYPE_CREATOR_ADD               0x22D82
#define HIDD_SFM_TYPE_CREATOR_EDIT              0x22D9B
 
// Property Pages (IDP_*) 
#define HIDP_SFM_CONFIGURATION                  0x32CD3
#define HIDP_SFM_SESSIONS                       0x32D69
#define HIDP_SFM_FILE_ASSOCIATION               0x32DB4
 
// Wizard Pages (IDW_*) 
 
// Controls (IDC_*) 
#define HIDC_GEN_DATE                           0x500C9
#define HIDC_GEN_TIME                           0x500CB
#define HIDC_GEN_USER                           0x500CC
#define HIDC_GEN_COMPUTER                       0x500CD
#define HIDC_GEN_EVENTID                        0x500CE
#define HIDC_GEN_SRC                            0x500CF
#define HIDC_BUTTON_SEND                        0x500CF
#define HIDC_GEN_TYPE                           0x500D0
#define HIDC_STATIC_SESSIONS                    0x500D0
#define HIDC_GEN_CATEGORY                       0x500D1
#define HIDC_STATIC_FORKS                       0x500D1
#define HIDC_STATIC_FILE_LOCKS                  0x500D2
#define HIDC_FIELD_LIST                         0x500D4
#define HIDC_EDIT_SERVER_NAME                   0x500D4
#define HIDC_EDIT_DISPLAY_NAME                  0x500D5
#define HIDC_EDIT_SESSION_LIMIT                 0x500D5
#define HIDC_STATIC_SERVICE_NAME                0x500D6
#define HIDC_STATIC_PATH_TO_EXECUTABLE          0x500D7
#define HIDC_COMBO_CREATOR                      0x500D7
#define HIDC_STATIC_CURRENT_STATUS              0x500D8
#define HIDC_BUTTON_START                       0x500D9
#define HIDC_COMBO_FILE_TYPE                    0x500D9
#define HIDC_BUTTON_STOP                        0x500DA
#define HIDC_BUTTON_PAUSE                       0x500DB
#define HIDC_BUTTON_RESUME                      0x500DC
#define HIDC_EDIT_DESCRIPTION                   0x500DD
#define HIDC_SFM_EDIT_PASSWORD                  0x500DF
#define HIDC_COMBO_STARTUP_TYPE                 0x500E0
#define HIDC_EDIT_STARTUP_PARAMETERS            0x500E1
#define HIDC_RADIO_LOGONAS_SYSTEMACCOUNT        0x500E2
#define HIDC_RADIO_LOGONAS_THIS_ACCOUNT         0x500E3
#define HIDC_CHECK_SERVICE_INTERACT_WITH_DESKTOP	0x500E4
#define HIDC_COMBO_LOGONAS_THIS_ACCOUNT         0x500E5
#define HIDC_EDIT_PASSWORD                      0x500E6
#define HIDC_EDIT_PASSWORD_CONFIRM              0x500E7
#define HIDC_BUTTON_ENABLE                      0x500E8
#define HIDC_BUTTON_DISABLE                     0x500E9
#define HIDC_EDIT_ACCOUNTNAME                   0x500EA
#define HIDC_EDIT_RUNFILE_FILENAME              0x500EB
#define HIDC_COMBO_SECOND_ATTEMPT               0x500EC
#define HIDC_COMBO_SUBSEQUENT_ATTEMPTS          0x500ED
#define HIDC_EDIT_SERVICE_RESET_ABEND_COUNT     0x500EE
#define HIDC_BUTTON_BROWSE                      0x500EF
#define HIDC_EDIT_RUNFILE_PARAMETERS            0x500F0
#define HIDC_SFM_CHECK_READONLY                 0x500F1
#define HIDC_EDIT1                              0x500F4
#define HIDC_BUTTON_CHOOSE_USER                 0x500F5
#define HIDC_BUTTON_REBOOT_COMPUTER             0x500F6
#define HIDC_COMBO_FIRST_ATTEMPT                0x500F7
//#define HIDC_GROUP_RESTARTSERVICE               0x500F8
#define HIDC_STATIC_RESTARTSERVICE              0x500F9
#define HIDC_STATIC_RESTARTSERVICE_3            0x500FA
#define HIDC_STATIC_RUNFILE_1                   0x500FB
#define HIDC_STATIC_RUNFILE_2                   0x500FC
#define HIDC_STATIC_RUNFILE_3                   0x500FD
#define HIDC_LIST_HARDWARE_PROFILES             0x500FE
#define HIDC_RADIO_ALL                          0x500FF
#define HIDC_RADIO_SHARES                       0x50100
#define HIDC_RADIO_SESSIONS                     0x50101
#define HIDC_RADIO_RESOURCES                    0x50102
#define HIDC_RADIO_SERVICES                     0x50103
#define HIDC_STATIC_PROGRESS_MSG                0x50104
#define HIDC_LIST_SERVICES                      0x50105
#define HIDC_STATIC_SERVICE_NAME_STATIC         0x50106
#define HIDC_STATIC_STARTUP_PARAMETERS          0x50107
#define HIDC_STATIC_DISPLAY_NAME                0x50108
#define HIDC_EDIT_PATH_NAME                     0x50109
#define HIDC_STATIC_SHARE_NAME                  0x5010A
#define HIDC_STATIC_PATH_NAME                   0x5010B
#define HIDC_PROGRESS                           0x5010D
#define HIDC_SHRPROP_MAX_ALLOWED                0x5010F
#define HIDC_SHRPROP_ALLOW_SPECIFIC             0x50110
#define HIDC_SHRPROP_SPIN_USERS                 0x50114
#define HIDC_SFM_GROUPBOX                       0x50115
#define HIDC_SFM_STATIC1                        0x50116
#define HIDC_STATIC_PATH_TO_EXECUTABLE_STATIC   0x5011B
#define HIDC_STATIC_CURRENT_STATUS_STATIC       0x5011C
#define HIDC_STATIC_STARTUP_TYPE                0x5011D
#define HIDC_GROUP_STARTUP_TYPE                 0x5011E
//#define HIDC_GROUP_CURRENT_STATUS               0x5011F
#define HIDC_GROUP_LOGON_AS                     0x50120
#define HIDC_STATIC_FAILURE_ACTIONS             0x50121
#define HIDC_STATIC_FIRST_ATTEMPT               0x50122
#define HIDC_STATIC_SECOND_ATTEMPT              0x50123
#define HIDC_STATIC_SUBSEQUENT_ATTEMPTS         0x50124
#define HIDC_STATIC_RESET_FAIL_COUNT            0x50125
#define HIDC_STATIC_SHARE_NAME_STATIC           0x50126
#define HIDC_STATIC_PATH_NAME_STATIC            0x50127
#define HIDC_STATIC_COMMENT_STATIC              0x50128
#define HIDC_GROUP_USER_LIMIT                   0x50129
#define HIDC_GROUP_VIEW                         0x5012B
#define HIDC_STATIC_STOP_SERVICES               0x5012D
#define HIDC_STATIC_MINUTES                     0x5012E
#define HIDC_STATIC_PASSWORD                    0x5012F
#define HIDC_STATIC_PASSWORD_CONFIRM            0x50130
#define HIDC_STATIC_DESCRIPTION                 0x50131
#define HIDC_STATIC_REBOOT_MESSAGE              0x50132
#define HIDC_STATIC_REBOOT_COMPUTER_DELAY       0x50133
#define HIDC_EDIT_REBOOT_MESSAGE                0x50134
#define HIDC_EDIT_SERVICE_RESTART_DELAY         0x50135
#define HIDC_CHECK_APPEND_ABENDNO               0x50136
#define HIDC_EDIT_REBOOT_COMPUTER_DELAY         0x50137
#define HIDC_STATIC_EVERYONE                    0x5013C
#define HIDC_STATIC_PRIMARY_GROUP               0x5013D
#define HIDC_STATIC_OWNER                       0x5013E
#define HIDC_GROUP_PERMISSIONS                  0x5013F
#define HIDC_STATIC_PATH                        0x50140
#define HIDC_REBOOT_MESSAGE_CHECKBOX            0x50141
#define HIDC_COMBO_AUTHENTICATION               0x50143
#define HIDC_EDIT_LOGON_MESSAGE                 0x52CD6
#define HIDC_CHECK_SAVE_PASSWORD                0x52CD8
#define HIDC_RADIO_SESSION_UNLIMITED            0x52CDA
#define HIDC_RADIO_SESSSION_LIMIT               0x52CDB
#define HIDC_EDIT_MESSAGE                       0x52D6B
#define HIDC_STATIC_CREATOR                     0x52D9D
#define HIDC_STATIC_FILE_TYPE                   0x52D9E
#define HIDC_COMBO_EXTENSION                    0x52DB5
#define HIDC_BUTTON_ADD                         0x52DB6
#define HIDC_BUTTON_EDIT                        0x52DB7
#define HIDC_BUTTON_DELETE                      0x52DB8
#define HIDC_BUTTON_ASSOCIATE                   0x52DB9
#define HIDC_LIST_TYPE_CREATORS                 0x52DBA

extern const ULONG_PTR g_aHelpIDs_CONFIGURE_SFM;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\sfmfasoc.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
	sfmfasoc.h
		prototypes for the file association property page.
		
    FILE HISTORY:
    8/20/97 ericdav     Code moved into file managemnet snapin
        
*/

#ifndef _SFMFASOC_H
#define _SFMFASOC_H

#ifndef _SFMUTIL_H
#include "sfmutil.h"
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CAfpTypeCreator
{
public:
	CAfpTypeCreator(PAFP_TYPE_CREATOR pAfpTypeCreator)
	{
		ASSERT(pAfpTypeCreator != NULL);

		m_strCreator = pAfpTypeCreator->afptc_creator;
		m_strType = pAfpTypeCreator->afptc_type;
		m_strComment = pAfpTypeCreator->afptc_comment;
		m_dwId = pAfpTypeCreator->afptc_id;
	}

// interface
public:
	LPCTSTR QueryCreator() { return (LPCTSTR) m_strCreator; };
	int     QueryCreatorLength() { return m_strCreator.GetLength(); };
	
	LPCTSTR QueryType() { return (LPCTSTR) m_strType; };
	int     QueryTypeLength() { return m_strType.GetLength(); };
	
	LPCTSTR QueryComment() { return (LPCTSTR) m_strComment; };
	int		QueryCommentLength() { return m_strComment.GetLength(); };
	
	DWORD	QueryId() { return m_dwId; };

	void SetCreator(LPCTSTR pCreator) { m_strCreator = pCreator; };
	void SetType(LPCTSTR pType) { m_strType = pType; };
	void SetComment(LPCTSTR pComment) { m_strComment = pComment; };
	void SetId(DWORD dwId) { m_dwId = dwId; };

// attributes
private:
	CString m_strCreator;
	CString m_strType;
	CString m_strComment;
	DWORD	m_dwId;
};	

/////////////////////////////////////////////////////////////////////////////
// CMacFilesFileAssociation dialog

class CMacFilesFileAssociation : public CPropertyPage
{
	DECLARE_DYNCREATE(CMacFilesFileAssociation)

// Construction
public:
	CMacFilesFileAssociation();
	~CMacFilesFileAssociation();

// Dialog Data
	//{{AFX_DATA(CMacFilesFileAssociation)
	enum { IDD = IDP_SFM_FILE_ASSOCIATION };
	CListCtrl	m_listctrlCreators;
	CComboBox	m_comboExtension;
	CButton	m_buttonEdit;
	CButton	m_buttonDelete;
	CButton	m_buttonAssociate;
	CButton	m_buttonAdd;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMacFilesFileAssociation)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMacFilesFileAssociation)
	afx_msg void OnButtonAdd();
	afx_msg void OnButtonAssociate();
	afx_msg void OnButtonDelete();
	afx_msg void OnButtonEdit();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeComboExtension();
	afx_msg void OnEditchangeComboExtension();
	afx_msg void OnDblclkListTypeCreators(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnClose();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnItemchangedListTypeCreators(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclickListTypeCreators(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDestroy();
	afx_msg void OnDeleteitemListTypeCreators(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void    InitListCtrl();
    void    ClearListCtrl();
    void    SetCurSel(int nIndex);
    int     GetCurSel();    
    void    InsertItem(CAfpTypeCreator * pItemData);

	void	EnableControls(BOOL fEnable);
	DWORD	SelectTypeCreator(DWORD dwId);
	DWORD	SelectTypeCreator(CString & strCreator, CString & strType);
	DWORD	Update();
	DWORD	Refresh();
	
    CAfpTypeCreator * GetTCObject(int nIndex);

public:
    CSFMPropertySheet *     m_pSheet;
    int                     m_nSortColumn;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif _SFMFASOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\sfmsess.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
	sfmsess.h
		Prototypes for the sessions property page.
		
    FILE HISTORY:
    8/20/97 ericdav     Code moved into file managemnet snapin
        
*/

#ifndef _SFMSESS_H
#define _SFMSESS_H

#ifndef _SFMUTIL_H
#include "sfmutil.h"
#endif

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// Sessions.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMacFilesSessions dialog

class CMacFilesSessions : public CPropertyPage
{
	DECLARE_DYNCREATE(CMacFilesSessions)

// Construction
public:
	CMacFilesSessions();
	~CMacFilesSessions();

// Dialog Data
	//{{AFX_DATA(CMacFilesSessions)
	enum { IDD = IDP_SFM_SESSIONS };
	CEdit	m_editMessage;
	CStatic	m_staticSessions;
	CStatic	m_staticForks;
	CStatic	m_staticFileLocks;
	CButton	m_buttonSend;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CMacFilesSessions)
	public:
	virtual BOOL OnApply();
	virtual BOOL OnKillActive();
	virtual void OnOK();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CMacFilesSessions)
	afx_msg void OnButtonSend();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeEditMessage();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
    CSFMPropertySheet *     m_pSheet;

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif _SFMSESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\sfmsess.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
	sfmsess.cpp
		Implementation for the sessions property page.
		
    FILE HISTORY:
    8/20/97 ericdav     Code moved into file managemnet snapin
        
*/

#include "stdafx.h"
#include "sfmcfg.h"
#include "sfmsess.h"
#include "sfmutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMacFilesSessions property page

IMPLEMENT_DYNCREATE(CMacFilesSessions, CPropertyPage)

CMacFilesSessions::CMacFilesSessions() : CPropertyPage(CMacFilesSessions::IDD)
{
	//{{AFX_DATA_INIT(CMacFilesSessions)
	//}}AFX_DATA_INIT
}

CMacFilesSessions::~CMacFilesSessions()
{
}

void CMacFilesSessions::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMacFilesSessions)
	DDX_Control(pDX, IDC_EDIT_MESSAGE, m_editMessage);
	DDX_Control(pDX, IDC_STATIC_SESSIONS, m_staticSessions);
	DDX_Control(pDX, IDC_STATIC_FORKS, m_staticForks);
	DDX_Control(pDX, IDC_STATIC_FILE_LOCKS, m_staticFileLocks);
	DDX_Control(pDX, IDC_BUTTON_SEND, m_buttonSend);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMacFilesSessions, CPropertyPage)
	//{{AFX_MSG_MAP(CMacFilesSessions)
	ON_BN_CLICKED(IDC_BUTTON_SEND, OnButtonSend)
	ON_EN_CHANGE(IDC_EDIT_MESSAGE, OnChangeEditMessage)
	ON_WM_HELPINFO()
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMacFilesSessions message handlers

BOOL CMacFilesSessions::OnApply() 
{
	// TODO: Add your specialized code here and/or call the base class
	
	return CPropertyPage::OnApply();
}

BOOL CMacFilesSessions::OnKillActive() 
{
	// TODO: Add your specialized code here and/or call the base class
	
	return CPropertyPage::OnKillActive();
}

void CMacFilesSessions::OnOK() 
{
	// TODO: Add your specialized code here and/or call the base class
	
	CPropertyPage::OnOK();
}

BOOL CMacFilesSessions::OnSetActive() 
{
	// TODO: Add your specialized code here and/or call the base class
	
	return CPropertyPage::OnSetActive();
}

void CMacFilesSessions::OnButtonSend() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    AFP_MESSAGE_INFO    AfpMsg;
	CString				strMessage;
    DWORD				err;

    if ( !g_SfmDLL.LoadFunctionPointers() )
		return;

    // 
    // Message goes to everybody
    //
    AfpMsg.afpmsg_session_id = 0;

    //
    // Attempt to send the message
    //
	m_editMessage.GetWindowText(strMessage);

    //
    // Was there any text? -- should never happen
    //
    if (strMessage.IsEmpty()) 
    {
		CString strTemp;
		strTemp.LoadString(IDS_NEED_TEXT_TO_SEND);

        ::AfxMessageBox(IDS_NEED_TEXT_TO_SEND);

    	m_editMessage.SetFocus();

    	return;
    }

	//
	// Message too long? -- should never happen
	//
	if (strMessage.GetLength() > AFP_MESSAGE_LEN)
	{
		CString strTemp;
		strTemp.LoadString(IDS_MESSAGE_TOO_LONG);

		::AfxMessageBox(strTemp);

    	m_editMessage.SetFocus();
    	m_editMessage.SetSel(0, -1);

    	return;
    }

    AfpMsg.afpmsg_text = (LPWSTR) ((LPCTSTR) strMessage);

    err = ((MESSAGESENDPROC) g_SfmDLL[AFP_MESSAGE_SEND])(m_pSheet->m_hAfpServer, &AfpMsg);

	CString strTemp;
    switch( err )
    {
		case AFPERR_InvalidId:
			strTemp.LoadString(IDS_SESSION_DELETED);
			::AfxMessageBox(strTemp);
	  		break;

		case NO_ERROR:
			strTemp.LoadString(IDS_MESSAGE_SENT);
			::AfxMessageBox(strTemp, MB_ICONINFORMATION);
			break;

		case AFPERR_InvalidSessionType:
			strTemp.LoadString(IDS_NOT_RECEIVED);
			::AfxMessageBox(strTemp);
			break;

		default:
            ::SFMMessageBox(err);
            break;
    }

}

BOOL CMacFilesSessions::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
    DWORD err;

    if ( !g_SfmDLL.LoadFunctionPointers() )
		return S_OK;

    //
    //  This string will contain our "??" string.
    //
    const TCHAR * pszNotAvail = _T("??");

    //
    //  Retrieve the statitistics server info.
    //
    PAFP_STATISTICS_INFO pAfpStats;

    err = ((STATISTICSGETPROC) g_SfmDLL[AFP_STATISTICS_GET])(m_pSheet->m_hAfpServer, (LPBYTE*)&pAfpStats);
    if( err == NO_ERROR )
    {
		CString strTemp;

		strTemp.Format(_T("%u"), pAfpStats->stat_CurrentSessions);
    	m_staticSessions.EnableWindow(TRUE);
    	m_staticSessions.SetWindowText(strTemp);

		strTemp.Format(_T("%u"), pAfpStats->stat_CurrentFilesOpen);
    	m_staticForks.EnableWindow(TRUE);
    	m_staticForks.SetWindowText(strTemp);

		strTemp.Format(_T("%u"), pAfpStats->stat_CurrentFileLocks);
    	m_staticFileLocks.EnableWindow(TRUE);
    	m_staticFileLocks.SetWindowText(strTemp);

		((SFMBUFFERFREEPROC) g_SfmDLL[AFP_BUFFER_FREE])(pAfpStats);
    }
    else
    {
    	m_staticSessions.SetWindowText(pszNotAvail);
    	m_staticSessions.EnableWindow(FALSE);

    	m_staticForks.SetWindowText(pszNotAvail);
    	m_staticForks.EnableWindow(FALSE);

    	m_staticFileLocks.SetWindowText(pszNotAvail);
    	m_staticFileLocks.EnableWindow(FALSE);

    }

	//
	// Setup the message edit box
	//
	m_editMessage.SetLimitText(AFP_MESSAGE_LEN);
	m_editMessage.FmtLines(FALSE);

	//
	// Set the state of the send button
	//
	OnChangeEditMessage();

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CMacFilesSessions::OnChangeEditMessage() 
{
	CString strTemp;
	
	m_editMessage.GetWindowText(strTemp);

	if (strTemp.IsEmpty())
	{
		//
		// Disable the send button
		//
		m_buttonSend.EnableWindow(FALSE);
	}
	else
	{
		//
		// Enable the send button
		//
		m_buttonSend.EnableWindow(TRUE);
	}

}

BOOL CMacFilesSessions::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
		           m_pSheet->m_strHelpFilePath,
		           HELP_WM_HELP,
		           g_aHelpIDs_CONFIGURE_SFM);
	}
	
	return TRUE;
}

void CMacFilesSessions::OnContextMenu(CWnd* pWnd, CPoint /*point*/) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (this == pWnd)
		return;

    ::WinHelp (pWnd->m_hWnd,
               m_pSheet->m_strHelpFilePath,
               HELP_CONTEXTMENU,
		       g_aHelpIDs_CONFIGURE_SFM);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\sfmtypes.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
	sfmtypes.cpp
		Implementation for the type creator add and edit dialog boxes.
		
    FILE HISTORY:
    8/20/97 ericdav     Code moved into file managemnet snapin
	
*/

#include "stdafx.h"
#include "sfmfasoc.h"
#include "sfmtypes.h"
#include "sfmutil.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTypeCreatorAddDlg dialog

CTypeCreatorAddDlg::CTypeCreatorAddDlg
(
	CListCtrl *              pListCreators,
	AFP_SERVER_HANDLE       hAfpServer,
    LPCTSTR                 pHelpFilePath,
	CWnd*                   pParent /*=NULL*/
)
	: CDialog(CTypeCreatorAddDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CTypeCreatorAddDlg)
	m_strCreator = _T("");
	m_strType = _T("");
	//}}AFX_DATA_INIT

	m_pListCreators = pListCreators;
	m_hAfpServer = hAfpServer;
    m_strHelpFilePath = pHelpFilePath;
}


void CTypeCreatorAddDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTypeCreatorAddDlg)
	DDX_Control(pDX, IDC_COMBO_FILE_TYPE, m_comboFileType);
	DDX_Control(pDX, IDC_EDIT_DESCRIPTION, m_editDescription);
	DDX_Control(pDX, IDC_COMBO_CREATOR, m_comboCreator);
	DDX_CBString(pDX, IDC_COMBO_CREATOR, m_strCreator);
	DDX_CBString(pDX, IDC_COMBO_FILE_TYPE, m_strType);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTypeCreatorAddDlg, CDialog)
	//{{AFX_MSG_MAP(CTypeCreatorAddDlg)
	ON_WM_CONTEXTMENU()
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTypeCreatorAddDlg message handlers

BOOL CTypeCreatorAddDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	//
	// Add all of the items to the two combo boxes
	//
	for (int i = 0; i < m_pListCreators->GetItemCount(); i++)
	{
		CAfpTypeCreator * pAfpTC = (CAfpTypeCreator *) m_pListCreators->GetItemData(i);

		if (m_comboCreator.FindStringExact(-1, pAfpTC->QueryCreator()) == CB_ERR)
		{
			// 
			// Creator not yet in the combobox, add.
			//
			m_comboCreator.AddString(pAfpTC->QueryCreator());
		}

		if (m_comboFileType.FindStringExact(-1, pAfpTC->QueryType()) == CB_ERR)
		{
			// 
			// Creator not yet in the combobox, add.
			//
			m_comboFileType.AddString(pAfpTC->QueryType());
		}
	}
	
	// 
	// Setup some control limits
	//
	m_comboCreator.LimitText(AFP_CREATOR_LEN);
	m_comboFileType.LimitText(AFP_TYPE_LEN);
	m_editDescription.LimitText(AFP_ETC_COMMENT_LEN);

	return TRUE;  // return TRUE unless you set the focus to a control
		      // EXCEPTION: OCX Property Pages should return FALSE
}

void CTypeCreatorAddDlg::OnOK() 
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

	AFP_TYPE_CREATOR	AfpTypeCreator;
    CString             strTemp;
    DWORD               err;

    if ( !g_SfmDLL.LoadFunctionPointers() )
		return;

    //
    // Validate all the information
    //
	m_comboCreator.GetWindowText(strTemp);
	if (strTemp.IsEmpty())
    {
		::AfxMessageBox(IDS_NEED_TYPE_CREATOR);
		m_comboCreator.SetFocus();
		
		return;
    }

	m_comboFileType.GetWindowText(strTemp);
	if (strTemp.IsEmpty())
    {
		::AfxMessageBox(IDS_NEED_TYPE_CREATOR);
		m_comboFileType.SetFocus();
		
		return;
    }

    //
    // Everything checked out ok, so now tell the server
    // what we've done
	//
	::ZeroMemory(&AfpTypeCreator, sizeof(AfpTypeCreator));
	
	m_comboCreator.GetWindowText(strTemp);
	::CopyMemory(AfpTypeCreator.afptc_creator, (LPCTSTR) strTemp, strTemp.GetLength() * sizeof(TCHAR));

	m_comboFileType.GetWindowText(strTemp);
	::CopyMemory(AfpTypeCreator.afptc_type, (LPCTSTR) strTemp, strTemp.GetLength() * sizeof(TCHAR));

	m_editDescription.GetWindowText(strTemp);
	::CopyMemory(AfpTypeCreator.afptc_comment, (LPCTSTR) strTemp, strTemp.GetLength() * sizeof(TCHAR));

	err = ((ETCMAPADDPROC) g_SfmDLL[AFP_ETC_MAP_ADD])(m_hAfpServer, &AfpTypeCreator);
	if (err != NO_ERROR)
	{
		::SFMMessageBox(err);

		return;
	}
	
	CDialog::OnOK();
}

void CTypeCreatorAddDlg::OnContextMenu(CWnd* pWnd, CPoint /*point*/) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (this == pWnd)
		return;

    ::WinHelp (pWnd->m_hWnd,
               m_strHelpFilePath,
               HELP_CONTEXTMENU,
		       g_aHelpIDs_CONFIGURE_SFM);
}

BOOL CTypeCreatorAddDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
		           m_strHelpFilePath,
		           HELP_WM_HELP,
		           g_aHelpIDs_CONFIGURE_SFM);
	}
	
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CTypeCreatorEditDlg dialog


CTypeCreatorEditDlg::CTypeCreatorEditDlg
(
	CAfpTypeCreator *       pAfpTypeCreator,
	AFP_SERVER_HANDLE       hAfpServer,
    LPCTSTR                 pHelpFilePath,
	CWnd*                   pParent /*=NULL*/
)
	: CDialog(CTypeCreatorEditDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CTypeCreatorEditDlg)
	m_strDescription = _T("");
	//}}AFX_DATA_INIT

	m_pAfpTypeCreator = pAfpTypeCreator;
	m_hAfpServer = hAfpServer;
    m_strHelpFilePath = pHelpFilePath;
}


void CTypeCreatorEditDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CTypeCreatorEditDlg)
	DDX_Control(pDX, IDC_STATIC_FILE_TYPE, m_staticFileType);
	DDX_Control(pDX, IDC_STATIC_CREATOR, m_staticCreator);
	DDX_Control(pDX, IDC_EDIT_DESCRIPTION, m_editDescription);
	DDX_Text(pDX, IDC_EDIT_DESCRIPTION, m_strDescription);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CTypeCreatorEditDlg, CDialog)
	//{{AFX_MSG_MAP(CTypeCreatorEditDlg)
	ON_WM_CONTEXTMENU()
	ON_WM_HELPINFO()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTypeCreatorEditDlg message handlers

BOOL CTypeCreatorEditDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	//
	// Set the creator and type fields.  Call fixup string to handle the & case.
	//
	CString strTemp;
	strTemp = m_pAfpTypeCreator->QueryCreator();
	FixupString(strTemp);
	m_staticCreator.SetWindowText(strTemp);
	
	strTemp = m_pAfpTypeCreator->QueryType();
	FixupString(strTemp);
	m_staticFileType.SetWindowText(strTemp);
	
	//
	// Fill in the description field
	//
	m_editDescription.LimitText(AFP_ETC_COMMENT_LEN);
	m_editDescription.SetWindowText(m_pAfpTypeCreator->QueryComment());

	return TRUE;  // return TRUE unless you set the focus to a control
		      // EXCEPTION: OCX Property Pages should return FALSE
}

void CTypeCreatorEditDlg::OnOK() 
{
    if ( !g_SfmDLL.LoadFunctionPointers() )
		return;

    if (m_editDescription.GetModify())
	{
		AFP_TYPE_CREATOR    AfpTypeCreator;
		CString             strDescription;
        DWORD               err;
		
        //
		// Fill in the type creator struct and notify the server
		//
		::ZeroMemory(&AfpTypeCreator, sizeof(AfpTypeCreator));
		
		::CopyMemory(AfpTypeCreator.afptc_creator, 
					 m_pAfpTypeCreator->QueryCreator(), 
					 m_pAfpTypeCreator->QueryCreatorLength() * sizeof(TCHAR));
		
		::CopyMemory(AfpTypeCreator.afptc_type, 
					 m_pAfpTypeCreator->QueryType(), 
					 m_pAfpTypeCreator->QueryTypeLength() * sizeof(TCHAR));
		
		m_editDescription.GetWindowText(strDescription);
		::CopyMemory(AfpTypeCreator.afptc_comment, 
					 (LPCTSTR) strDescription, 
					 strDescription.GetLength() * sizeof(TCHAR));
		
		AfpTypeCreator.afptc_id = m_pAfpTypeCreator->QueryId();

		err = ((ETCMAPSETINFOPROC) g_SfmDLL[AFP_ETC_MAP_SET_INFO])(m_hAfpServer,
									                               &AfpTypeCreator);
		if ( err != NO_ERROR )
		{
			::SFMMessageBox(err);
			
			return;
		}
	}       

	CDialog::OnOK();
}

void CTypeCreatorEditDlg::OnContextMenu(CWnd* pWnd, CPoint /*point*/) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (this == pWnd)
		return;

    ::WinHelp (pWnd->m_hWnd,
               m_strHelpFilePath,
               HELP_CONTEXTMENU,
		       g_aHelpIDs_CONFIGURE_SFM);
}

BOOL CTypeCreatorEditDlg::OnHelpInfo(HELPINFO* pHelpInfo) 
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
	{
        ::WinHelp ((HWND)pHelpInfo->hItemHandle,
		           m_strHelpFilePath,
		           HELP_WM_HELP,
		           g_aHelpIDs_CONFIGURE_SFM);
	}
	
	return TRUE;
}

void CTypeCreatorEditDlg::FixupString(CString& strText)
{
	CString strTemp;
	
	for (int i = 0; i < strText.GetLength(); i++)
	{
		if (strText[i] == '&')
			strTemp += _T("&&");
		else
			strTemp += strText[i];
	}

	strText = strTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\sfmtypes.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
	sfmtypes.h
		Prototypes for the type creator add and edit dialog boxes.
		
    FILE HISTORY:
    8/20/97 ericdav     Code moved into file managemnet snapin
        
*/

#ifndef _SFMTYPES_H
#define _SFMTYPES_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// TCreate.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CTypeCreatorAddDlg dialog

class CTypeCreatorAddDlg : public CDialog
{
// Construction
public:
	CTypeCreatorAddDlg
	(
		CListCtrl *			pListCreators, 
		AFP_SERVER_HANDLE	hAfpServer,
        LPCTSTR             pHelpFilePath = NULL,
		CWnd*				pParent = NULL
	);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CTypeCreatorAddDlg)
	enum { IDD = IDD_SFM_TYPE_CREATOR_ADD };
	CComboBox	m_comboFileType;
	CEdit	m_editDescription;
	CComboBox	m_comboCreator;
	CString	m_strCreator;
	CString	m_strType;
	//}}AFX_DATA

    CString m_strHelpFilePath;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTypeCreatorAddDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTypeCreatorAddDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Attributes
private:
	CListCtrl *			m_pListCreators;
	AFP_SERVER_HANDLE	m_hAfpServer;
};

/////////////////////////////////////////////////////////////////////////////
// CTypeCreatorEditDlg dialog

class CTypeCreatorEditDlg : public CDialog
{
// Construction
public:
	CTypeCreatorEditDlg
	(
		CAfpTypeCreator *	pAfpTypeCreator,
		AFP_SERVER_HANDLE	hAfpServer,
        LPCTSTR             pHelpFilePath = NULL,
		CWnd*				pParent = NULL
	);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CTypeCreatorEditDlg)
	enum { IDD = IDD_SFM_TYPE_CREATOR_EDIT };
	CStatic	m_staticFileType;
	CStatic	m_staticCreator;
	CEdit	m_editDescription;
	CString	m_strDescription;
	//}}AFX_DATA

    CString m_strHelpFilePath;

	void FixupString(CString & strText);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CTypeCreatorEditDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CTypeCreatorEditDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Attributes
public:
	BOOL	m_bDescriptionChanged;

private:
	CAfpTypeCreator *	m_pAfpTypeCreator;
	AFP_SERVER_HANDLE	m_hAfpServer;
};
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif _SFMTYPES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\sfmutil.h ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    sfmutil.h
        Misc utility routines for SFM dialogs/property pages

    FILE HISTORY:
        
*/

#ifndef _SFMUTIL_H
#define _SFMUTIL_H

// global SFM stuff from the file management snapin
#include "cookie.h"     // required for sfm.h
#include "sfm.h"        // sfm entry points
#include "DynamLnk.h"		// DynamicDLL

// help stuff
#include "sfmhelp.h"

#define IDS_AFPMGR_BASE                 22000
#define IDS_AFPMGR_LAST                 (IDS_AFPMGR_BASE+200)

#define ERROR_ALREADY_REPORTED          0xFFFFFFFF
#define COMPUTERNAME_LEN_MAX			255

//
// Do not change the ID numbers of these strings. AFPERR_*
// map to these string ids via the formula:
// -(AFPERR_*) + IDS_AFPMGR_BASE + AFPERR_BASE + 100 = IDS_*
// 
#define AFPERR_TO_STRINGID( AfpErr )                            \
								\
    ((( AfpErr <= AFPERR_BASE ) && ( AfpErr >= AFPERR_MIN )) ?  \
    (IDS_AFPMGR_BASE+100+AFPERR_BASE-AfpErr) : IDS_ERROR_BASE + AfpErr )

// procedure defines for SFM API entry points
typedef DWORD (*SERVERGETINFOPROC)    (AFP_SERVER_HANDLE,LPBYTE*);
typedef DWORD (*SERVERSETINFOPROC)    (AFP_SERVER_HANDLE,LPBYTE,DWORD);
typedef DWORD (*ETCMAPASSOCIATEPROC)  (AFP_SERVER_HANDLE,PAFP_TYPE_CREATOR,PAFP_EXTENSION);
typedef DWORD (*ETCMAPADDPROC)        (AFP_SERVER_HANDLE,PAFP_TYPE_CREATOR);
typedef DWORD (*ETCMAPDELETEPROC)     (AFP_SERVER_HANDLE,PAFP_TYPE_CREATOR);
typedef DWORD (*ETCMAPGETINFOPROC)    (AFP_SERVER_HANDLE,LPBYTE*);
typedef DWORD (*ETCMAPSETINFOPROC)    (AFP_SERVER_HANDLE,PAFP_TYPE_CREATOR);
typedef DWORD (*MESSAGESENDPROC)      (AFP_SERVER_HANDLE,PAFP_MESSAGE_INFO);
typedef DWORD (*STATISTICSGETPROC)    (AFP_SERVER_HANDLE,LPBYTE*);
typedef void  (*SFMBUFFERFREEPROC)    (PVOID);

HWND FindMMCMainWindow();
void SFMMessageBox(DWORD dwErrCode);

class CSfmFileServiceProvider;

class CSFMPropertySheet
{
  friend class CMacFilesConfiguration;
  friend class CMacFilesSessions;
  friend class CMacFilesFileAssociation;

public:
    CSFMPropertySheet();
    ~CSFMPropertySheet();

    BOOL FInit(LPDATAOBJECT             lpDataObject,
               AFP_SERVER_HANDLE        hAfpServer,
               LPCTSTR                  pSheetTitle,
               SfmFileServiceProvider * pSfmProvider,
               LPCTSTR                  pMachine);

    // actions for the property sheet
    BOOL    DoModelessSheet(LPDATAOBJECT pDataObject);
    void    CancelSheet();
    HWND    SetActiveWindow() { return ::SetActiveWindow(m_hSheetWindow); }

    // data access
    void    SetProvider(SfmFileServiceProvider * pSfmProvider) { m_pSfmProvider = pSfmProvider; }
    
    // the first individual property page calls this to set the sheet window
    void    SetSheetWindow(HWND hWnd);

    int     AddRef();
    int     Release();

    DWORD   IsNT5Machine(LPCTSTR pszMachine, BOOL *pfNt4);

protected:
    void   Destroy();

public:
    AFP_SERVER_HANDLE           m_hAfpServer;
    HANDLE                      m_hDestroySync;
    CString                     m_strMachine;

protected:
    CMacFilesConfiguration *    m_pPageConfig;
    CMacFilesSessions *         m_pPageSessions;
    CMacFilesFileAssociation *  m_pPageFileAssoc;

	IDataObjectPtr              m_spDataObject;		// Used for MMCPropertyChangeNotify

    HWND                        m_hSheetWindow;
    SfmFileServiceProvider *    m_pSfmProvider;
    int                         m_nRefCount;
    HANDLE                      m_hThread;
    CString                     m_strTitle;
    CString                     m_strHelpFilePath;
};

#endif _SFMUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\sfmutil.cpp ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1997                **/
/**********************************************************************/

/*
    sfmutil.cpp
        Misc utility routines for SFM dialogs/property pages

    FILE HISTORY:
    8/20/97 ericdav     Code moved into file managemnet snapin
        
*/

#include "stdafx.h"
#include "sfmutil.h"
#include "sfmcfg.h"
#include "sfmsess.h"
#include "sfmfasoc.h"
#include "macros.h" // MFC_TRY/MFC_CATCH

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

TCHAR c_szSoftware[] = _T("Software");
TCHAR c_szMicrosoft[] = _T("Microsoft");
TCHAR c_szWindowsNT[] = _T("Windows NT");
TCHAR c_szCurrentVersion[] = _T("CurrentVersion");

ULONG arrayHelpIDs_CONFIGURE_SFM[]=
{
	IDC_BUTTON_ADD,	            HIDC_BUTTON_ADD,        	// File Association: "A&dd..." (Button)
	IDC_BUTTON_EDIT,	        HIDC_BUTTON_EDIT,	        // File Association: "&Edit..." (Button)
	IDC_COMBO_CREATOR,	        HIDC_COMBO_CREATOR,	        // Add Document Type: "" (ComboBox)
	IDC_BUTTON_DELETE,	        HIDC_BUTTON_DELETE,	        // File Association: "De&lete" (Button)
	IDC_BUTTON_ASSOCIATE,	    HIDC_BUTTON_ASSOCIATE,	    // File Association: "&Associate" (Button)
	IDC_COMBO_FILE_TYPE,	    HIDC_COMBO_FILE_TYPE,	    // Add Document Type: "" (ComboBox)
	IDC_LIST_TYPE_CREATORS,	    HIDC_LIST_TYPE_CREATORS,	// File Association: "" (ListBox)
	IDC_EDIT_LOGON_MESSAGE,	    HIDC_EDIT_LOGON_MESSAGE,	// Configuration: "" (Edit)
	IDC_COMBO_AUTHENTICATION,   HIDC_COMBO_AUTHENTICATION,  // Configuration: "Authentication type combo box"
	IDC_CHECK_SAVE_PASSWORD,    HIDC_CHECK_SAVE_PASSWORD,	// Configuration: "Allow &Workstations to Save Password" (Button)
	IDC_RADIO_SESSION_UNLIMITED,HIDC_RADIO_SESSION_UNLIMITED,// Configuration: "&Unlimited" (Button)
	IDC_RADIO_SESSSION_LIMIT,	HIDC_RADIO_SESSSION_LIMIT,	// Configuration: "Li&mit to" (Button)
	IDC_BUTTON_SEND,	        HIDC_BUTTON_SEND,	        // Sessions: "&Send" (Button)
	IDC_EDIT_MESSAGE,	        HIDC_EDIT_MESSAGE,	        // Sessions: "" (Edit)
	IDC_STATIC_SESSIONS,	    HIDC_STATIC_SESSIONS,	    // Sessions: "Static" (Static)
	IDC_EDIT_DESCRIPTION,	    HIDC_EDIT_DESCRIPTION,	    // Add Document Type: "" (Edit)
	IDC_STATIC_FORKS,	        HIDC_STATIC_FORKS,	        // Sessions: "Static" (Static)
	IDC_STATIC_FILE_LOCKS,      HIDC_STATIC_FILE_LOCKS,     // Sessions: "Static" (Static)
	IDC_STATIC_CREATOR,	        HIDC_STATIC_CREATOR,	    // Edit Document Type: "Static" (Static)
	IDC_EDIT_SERVER_NAME,	    HIDC_EDIT_SERVER_NAME,	    // Configuration: "" (Edit)
	IDC_COMBO_EXTENSION,	    HIDC_COMBO_EXTENSION,	    // File Association: "" (ComboBox)
	IDC_EDIT_SESSION_LIMIT,	    HIDC_EDIT_SESSION_LIMIT,	// Configuration: "0" (Edit)
	IDC_SFM_EDIT_PASSWORD,      HIDC_SFM_EDIT_PASSWORD,
	IDC_SFM_CHECK_READONLY,     HIDC_SFM_CHECK_READONLY,
	(ULONG)IDC_STATIC,          (ULONG)-1,
	0, 0
};

// these are the only controls we care about....
const ULONG_PTR g_aHelpIDs_CONFIGURE_SFM = (ULONG_PTR)&arrayHelpIDs_CONFIGURE_SFM[0];

USE_HANDLE_MACROS("FILEMGMT(sfmutil.cpp)")

HRESULT 
GetErrorMessageFromModule(
  IN  DWORD       dwError,
  IN  LPCTSTR     lpszDll,
  OUT LPTSTR      *ppBuffer
)
{
  if (0 == dwError || !lpszDll || !*lpszDll || !ppBuffer)
    return E_INVALIDARG;

  HRESULT      hr = S_OK;

  HINSTANCE  hMsgLib = LoadLibrary(lpszDll);
  if (!hMsgLib)
    hr = HRESULT_FROM_WIN32(GetLastError());
  else
  {
    DWORD dwRet = ::FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
        hMsgLib, dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR)ppBuffer, 0, NULL);

    if (0 == dwRet)
      hr = HRESULT_FROM_WIN32(GetLastError());

    FreeLibrary(hMsgLib);
  }

  return hr;
}

HRESULT 
GetErrorMessage(
  IN  DWORD        i_dwError,
  OUT CString&     cstrErrorMsg
)
{
  if (0 == i_dwError)
    return E_INVALIDARG;

  HRESULT      hr = S_OK;
  LPTSTR       lpBuffer = NULL;

  DWORD dwRet = ::FormatMessage(
              FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
              NULL, i_dwError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
              (LPTSTR)&lpBuffer, 0, NULL);
  if (0 == dwRet)
  {
    // if no message is found, GetLastError will return ERROR_MR_MID_NOT_FOUND
    hr = HRESULT_FROM_WIN32(GetLastError());

    if (HRESULT_FROM_WIN32(ERROR_MR_MID_NOT_FOUND) == hr ||
        0x80070000 == (i_dwError & 0xffff0000) ||
        0 == (i_dwError & 0xffff0000) )
    {
      hr = GetErrorMessageFromModule((i_dwError & 0x0000ffff), _T("netmsg.dll"), &lpBuffer);
      if (HRESULT_FROM_WIN32(ERROR_MR_MID_NOT_FOUND) == hr)
      {
        int iError = i_dwError;  // convert to a signed integer
        if (iError >= AFPERR_MIN && iError < AFPERR_BASE)
        { 
          // use a positive number to search sfmmsg.dll
          hr = GetErrorMessageFromModule(-iError, _T("sfmmsg.dll"), &lpBuffer);
        }
      }
    }
  }

  if (SUCCEEDED(hr))
  {
    cstrErrorMsg = lpBuffer;
    LocalFree(lpBuffer);
  }
  else
  {
    // we failed to retrieve the error message from system/netmsg.dll/sfmmsg.dll,
    // report the error code directly to user
    hr = S_OK;
    cstrErrorMsg.Format(_T("0x%x"), i_dwError);
  }

  return S_OK;
}

void SFMMessageBox(DWORD dwErrCode)
{
  HRESULT hr = S_OK;
  CString strMessage;

  if (!dwErrCode)
    return;  // not expected

  hr = GetErrorMessage(dwErrCode, strMessage);

  if (FAILED(hr))
  {
   // Failed to retrieve the proper message, report the failure directly to user
    strMessage.Format(_T("0x%x"), hr);
  }

  AfxMessageBox(strMessage);
}

BOOL CALLBACK EnumThreadWndProc(HWND hwnd, /* enumerated HWND */
								LPARAM lParam /* pass a HWND* for return value*/ )
{
	_ASSERTE(hwnd);
	HWND hParentWnd = GetParent(hwnd);
	// the main window of the MMC console should staitsfy this condition
	if ( ((hParentWnd == GetDesktopWindow()) || (hParentWnd == NULL))  && IsWindowVisible(hwnd) )
	{
		HWND* pH = (HWND*)lParam;
		*pH = hwnd;
		return FALSE; // stop enumerating
	}
	return TRUE;
}
 
HWND FindMMCMainWindow()
{
	DWORD dwThreadID = ::GetCurrentThreadId();
	_ASSERTE(dwThreadID != 0);
	HWND hWnd = NULL;
	BOOL bEnum = EnumThreadWindows(dwThreadID, EnumThreadWndProc,(LPARAM)&hWnd);
	_ASSERTE(hWnd != NULL);
	return hWnd;
}

/////////////////////////////////////////////////////////////////////
//	Constructor for CSFMPropertySheet object
CSFMPropertySheet::CSFMPropertySheet()
{
    m_pPageConfig = new CMacFilesConfiguration;
	m_pPageConfig->m_pSheet = this;
	m_pPageSessions = new CMacFilesSessions;
	m_pPageSessions->m_pSheet = this;
	m_pPageFileAssoc = new CMacFilesFileAssociation;
	m_pPageFileAssoc->m_pSheet = this;

    m_hSheetWindow = NULL;
    m_hThread = NULL;
    m_nRefCount =1;

} // CSFMPropertySheet::CSFMPropertySheet()


CSFMPropertySheet::~CSFMPropertySheet()
{
	delete m_pPageConfig;
	delete m_pPageSessions;	
	delete m_pPageFileAssoc;

    if (m_hDestroySync)
    {
        CloseHandle(m_hDestroySync);
        m_hDestroySync = NULL;
    }

} // CServicePropertyData::~CServicePropertyData()

BOOL 
CSFMPropertySheet::FInit
(
    LPDATAOBJECT             lpDataObject,
    AFP_SERVER_HANDLE        hAfpServer,
    LPCTSTR                  pSheetTitle,
    SfmFileServiceProvider * pSfmProvider,
    LPCTSTR                  pMachine
)
{
    m_spDataObject = lpDataObject;
    m_strTitle = pSheetTitle;
    m_hAfpServer = hAfpServer;
    m_pSfmProvider = pSfmProvider;

    m_strHelpFilePath = _T("sfmmgr.hlp"); // does not need to be localized

    m_strMachine = pMachine;

    m_hDestroySync = ::CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!m_hDestroySync)
        return FALSE;
    
    return TRUE;
}

BOOL 
CSFMPropertySheet::DoModelessSheet(LPDATAOBJECT pDataObject)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

    LPPROPERTYSHEETCALLBACK  pCallback = NULL;
    LPPROPERTYSHEETPROVIDER  pProvider = NULL;
	HPROPSHEETPAGE           hPage;
    HRESULT                  hr = S_OK;
    HWND                     hWnd;
    BOOL                     bReturn = TRUE;

    // get the property sheet provider interface
    hr = ::CoCreateInstance(CLSID_NodeManager, NULL, CLSCTX_INPROC, 
                IID_IPropertySheetProvider, reinterpret_cast<void **>(&pProvider));
    
    if (FAILED(hr))
        return FALSE;

    _ASSERTE(pProvider != NULL);

	// get an interface to a sheet callback
    hr = pProvider->QueryInterface(IID_IPropertySheetCallback, (void**) &pCallback);
    if (FAILED(hr))
    {
        bReturn = FALSE;
        goto Error;
    }

    _ASSERTE(pCallback != NULL);

	// create sheet
    hr = pProvider->CreatePropertySheet(m_strTitle,
		 				                TRUE /* prop page */, 
                                        NULL, 
                                        //m_spDataObject, 
                                        pDataObject, 
                                        0);
	// add pages to sheet - config
	MMCPropPageCallback(INOUT &m_pPageConfig->m_psp);
	hPage = MyCreatePropertySheetPage(IN &m_pPageConfig->m_psp);
	Report(hPage != NULL);
	if (hPage != NULL)
		pCallback->AddPage(hPage);
	
    // now the Sessions page
    MMCPropPageCallback(INOUT &m_pPageFileAssoc->m_psp);
	hPage = MyCreatePropertySheetPage(IN &m_pPageFileAssoc->m_psp);
	Report(hPage != NULL);
	if (hPage != NULL)
		pCallback->AddPage(hPage);

    // finally the File Association page
    MMCPropPageCallback(INOUT &m_pPageSessions->m_psp);
	hPage = MyCreatePropertySheetPage(IN &m_pPageSessions->m_psp);
	Report(hPage != NULL);
	if (hPage != NULL)
		pCallback->AddPage(hPage);
	
	// add pages
	hr = pProvider->AddPrimaryPages(NULL, FALSE, NULL, FALSE);
    if (FAILED(hr))
    {
        bReturn = FALSE;
        goto Error;
    }

	hWnd = ::FindMMCMainWindow();
	_ASSERTE(hWnd != NULL);

	hr = pProvider->Show((LONG_PTR) hWnd, 0);
    if (FAILED(hr))
    {
        bReturn = FALSE;
        goto Error;
    }
    
Error:
    if (pCallback)
        pCallback->Release();

    if (pProvider)
        pProvider->Release();

    // release our data object... we don't need it anymore
    m_spDataObject = NULL;

    return bReturn;
}

int 
CSFMPropertySheet::AddRef()
{
    return ++m_nRefCount;    
}

int
CSFMPropertySheet::Release()
{
    int nRefCount = --m_nRefCount;

    if (nRefCount == 0)
        Destroy();

    return nRefCount;
}

void 
CSFMPropertySheet::SetSheetWindow
(
	HWND hSheetWindow
)
{
	if (m_hSheetWindow && !hSheetWindow)
	{
		// The Property Sheet is going away.  Notify the provider so it can release 
		// any references to the object.
		if (m_pSfmProvider)
			m_pSfmProvider->SetSfmPropSheet(NULL);
	}

	m_hSheetWindow = hSheetWindow;

	if (!m_hThread)
	{
		HANDLE hPseudohandle;
		
		hPseudohandle = GetCurrentThread();
		BOOL bRet = DuplicateHandle(GetCurrentProcess(), 
									 hPseudohandle,
									 GetCurrentProcess(),
									 &m_hThread,
									 0,
									 FALSE,
									 DUPLICATE_SAME_ACCESS);
		if (!bRet)
		{
			DWORD dwLastErr = GetLastError();
		}

		TRACE(_T("SfmProperty Sheet - Thread ID = %lx\n"), GetCurrentThreadId());
	}
}

void
CSFMPropertySheet::Destroy()
{ 
    m_hSheetWindow = NULL;

    delete this; 
}

void
CSFMPropertySheet::CancelSheet()
{ 
	HWND hSheetWindow = m_hSheetWindow;
	if (hSheetWindow != NULL)
	{
		// this message will cause the sheet to close all the pages,
		// and eventually the destruction of "this"
		VERIFY(::PostMessage(hSheetWindow, WM_COMMAND, IDCANCEL, 0L) != 0);
	}

    // now, if we've been initialized then wait for the property sheet thread
    // to terminate.  The property sheet provider is holding onto our dataobject
    // that needs to be freed up before we can continue our cleanup.
    if (m_hThread)
    {
	    DWORD dwRet;
	    MSG msg;

	    while(1)
	    {
		    dwRet = MsgWaitForMultipleObjects(1, &m_hThread, FALSE, INFINITE, QS_ALLINPUT);

		    if (dwRet == WAIT_OBJECT_0)
			    return;    // The event was signaled

		    if (dwRet != WAIT_OBJECT_0 + 1)
			    break;          // Something else happened

		    // There is one or more window message available. Dispatch them
		    while(PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
		    {
			    TranslateMessage(&msg);
			    DispatchMessage(&msg);
			    if (WaitForSingleObject(m_hThread, 0) == WAIT_OBJECT_0)
				    return; // Event is now signaled.
		    }
	    }
    }       
}

/*!--------------------------------------------------------------------------
	IsNT5Machine
		-
	Author: EricDav
 ---------------------------------------------------------------------------*/
DWORD
CSFMPropertySheet::IsNT5Machine(LPCTSTR pszMachine, BOOL *pfNt4)
{
	// Look at the HKLM\Software\Microsoft\Windows NT\CurrentVersion
	//					CurrentVersion = REG_SZ "5.0"
	CString skey;
	DWORD	dwErr = ERROR_SUCCESS;
	TCHAR	szVersion[64];
    HKEY    hkeyMachine, hKey;
    DWORD   dwType = REG_SZ;
    DWORD   dwSize = sizeof(szVersion);

    if (!pszMachine || !lstrlen(pszMachine))
	{
        hkeyMachine = HKEY_LOCAL_MACHINE;
    }
    else
	{
        //
        // Make the connection
        //

        dwErr = ::RegConnectRegistry(
                    (LPTSTR)pszMachine, HKEY_LOCAL_MACHINE, &hkeyMachine
                    );
    }
    
    if (dwErr != ERROR_SUCCESS)
        return dwErr;
    
    ASSERT(pfNt4);

    skey = c_szSoftware;
	skey += TEXT('\\');
	skey += c_szMicrosoft;
	skey += TEXT('\\');
	skey += c_szWindowsNT;
	skey += TEXT('\\');
	skey += c_szCurrentVersion;

    dwErr = ::RegOpenKeyEx( hkeyMachine, skey, 0, KEY_READ, & hKey ) ;
	if (dwErr != ERROR_SUCCESS)
		return dwErr;

	// Ok, now try to get the current version value
	dwErr = ::RegQueryValueEx( hKey, 
							   c_szCurrentVersion, 
							   0, 
                               &dwType,
							   (LPBYTE) szVersion, 
                               &dwSize ) ;
	if (dwErr == ERROR_SUCCESS)
	{
		*pfNt4 = ((szVersion[0] == _T('5')) && (szVersion[1] == _T('.')));
	}

    ::RegCloseKey( hKey );
    
    if (hkeyMachine != HKEY_LOCAL_MACHINE)
        ::RegCloseKey( hkeyMachine );

	return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\shrpgsfm.cpp ===
// ShrPgSFM.cpp : implementation file
//

#include "stdafx.h"
#include "ShrPgSFM.h"
#include "SFMhelp.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSharePageGeneralSFM property page

IMPLEMENT_DYNCREATE(CSharePageGeneralSFM, CSharePageGeneral)

CSharePageGeneralSFM::CSharePageGeneralSFM() : CSharePageGeneral(CSharePageGeneralSFM::IDD)
{
  //{{AFX_DATA_INIT(CSharePageGeneralSFM)
  m_strSfmPassword = _T("");
  m_bSfmReadonly = FALSE;
  //}}AFX_DATA_INIT
}

CSharePageGeneralSFM::~CSharePageGeneralSFM()
{
}

void CSharePageGeneralSFM::DoDataExchange(CDataExchange* pDX)
{
  CSharePageGeneral::DoDataExchange(pDX);
  //{{AFX_DATA_MAP(CSharePageGeneralSFM)
  DDX_Control(pDX, IDC_SFM_CHECK_READONLY, m_checkboxSfmReadonly);
  DDX_Control(pDX, IDC_SFM_EDIT_PASSWORD, m_editSfmPassword);
  DDX_Control(pDX, IDC_SFM_GROUPBOX, m_groupboxSfm);
  DDX_Control(pDX, IDC_SFM_STATIC1, m_staticSfmText);
  DDX_Text(pDX, IDC_SFM_EDIT_PASSWORD, m_strSfmPassword);
  DDV_MaxChars(pDX, m_strSfmPassword, 8); // AFP_VOLPASS_LEN
  DDX_Check(pDX, IDC_SFM_CHECK_READONLY, m_bSfmReadonly);
  //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSharePageGeneralSFM, CSharePageGeneral)
  //{{AFX_MSG_MAP(CSharePageGeneralSFM)
  ON_BN_CLICKED(IDC_SFM_CHECK_READONLY, OnSfmCheckReadonly)
  ON_EN_CHANGE(IDC_SFM_EDIT_PASSWORD, OnChangeSfmEditPassword)
  ON_MESSAGE(WM_HELP, OnHelp)
  ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
  //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSharePageGeneralSFM message handlers
BOOL CSharePageGeneralSFM::Load( CFileMgmtComponentData* pFileMgmtData, LPDATAOBJECT piDataObject )
{
  if ( CSharePageGeneral::Load (pFileMgmtData, piDataObject) )
  {
    ReadSfmSettings();
  }
  else
    return FALSE;

  return TRUE;
}


// These two functions are implemented in sfm.cpp:
// void CSharePageGeneralSFM::ReadSfmSettings()
// void CSharePageGeneralSFM::WriteSfmSettings()

BOOL CSharePageGeneralSFM::OnApply()
{  
  // UpdateData (TRUE) has already been called by OnKillActive () just before OnApply ()
//  if ( !UpdateData(TRUE) )
//    return FALSE;

  WriteSfmSettings();

  return CSharePageGeneral::OnApply();
}

void CSharePageGeneralSFM::OnSfmCheckReadonly() 
{
  SetModified (TRUE);
}

void CSharePageGeneralSFM::OnChangeSfmEditPassword() 
{
  SetModified (TRUE);
}

/////////////////////////////////////////////////////////////////////
//  Help
BOOL CSharePageGeneralSFM::OnHelp(WPARAM wParam, LPARAM lParam)
{
  LPHELPINFO  lphi = (LPHELPINFO) lParam;

  if ( HELPINFO_WINDOW == lphi->iContextType )  // a control
  {
    if (IDC_SFM_EDIT_PASSWORD == lphi->iCtrlId ||
        IDC_SFM_CHECK_READONLY == lphi->iCtrlId)
    {
      return ::WinHelp ((HWND) lphi->hItemHandle, L"sfmmgr.hlp", 
          HELP_WM_HELP,
          g_aHelpIDs_CONFIGURE_SFM);
    }
  }

  return CSharePageGeneral::OnHelp (wParam, lParam);
}

BOOL CSharePageGeneralSFM::OnContextHelp(WPARAM wParam, LPARAM lParam)
{
  int  ctrlID = ::GetDlgCtrlID ((HWND) wParam);
  if (IDC_SFM_EDIT_PASSWORD == ctrlID ||
      IDC_SFM_CHECK_READONLY == ctrlID)
  {
    return ::WinHelp ((HWND) wParam, L"sfmmgr.hlp", HELP_CONTEXTMENU,
        g_aHelpIDs_CONFIGURE_SFM);
  }
  return CSharePageGeneral::OnContextHelp (wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\shrpgsfm.h ===
#if !defined(AFX_SHRPGSFM_H__6819CF67_C424_11D1_A6C6_00C04FB94F17__INCLUDED_)
#define AFX_SHRPGSFM_H__6819CF67_C424_11D1_A6C6_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ShrPgSFM.h : header file
//
#include "shrprop.h"

/////////////////////////////////////////////////////////////////////////////
// CSharePageGeneralSFM dialog

class CSharePageGeneralSFM : public CSharePageGeneral
{
  DECLARE_DYNCREATE(CSharePageGeneralSFM)

// Construction
public:
  CSharePageGeneralSFM();
  virtual ~CSharePageGeneralSFM();

  virtual BOOL Load( CFileMgmtComponentData* pFileMgmtData, LPDATAOBJECT piDataObject );
  // these are implemented in sfm.cpp
  void ReadSfmSettings();
  void WriteSfmSettings();

// Dialog Data
  //{{AFX_DATA(CSharePageGeneralSFM)
  enum { IDD = IDD_SHAREPROP_GENERAL_SFM };
  CButton  m_checkboxSfmReadonly;
  CEdit  m_editSfmPassword;
  CButton  m_groupboxSfm;
  CStatic  m_staticSfmText;
  CString  m_strSfmPassword;
  BOOL  m_bSfmReadonly;
  //}}AFX_DATA


// Overrides
  // ClassWizard generate virtual function overrides
  //{{AFX_VIRTUAL(CSharePageGeneralSFM)
  public:
  virtual BOOL OnApply();
  protected:
  virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
  //}}AFX_VIRTUAL

// Implementation
protected:
  // Generated message map functions
  //{{AFX_MSG(CSharePageGeneralSFM)
  afx_msg void OnSfmCheckReadonly();
  afx_msg void OnChangeSfmEditPassword();
  afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
  afx_msg BOOL OnContextHelp(WPARAM wParam, LPARAM lParam);
  //}}AFX_MSG
  DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SHRPGSFM_H__6819CF67_C424_11D1_A6C6_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\shrpgsmb.cpp ===
// ShrPgSMB.cpp : implementation file
//

#include "stdafx.h"
#include "ShrPgSMB.h"
#include "compdata.h"
#include "filesvc.h"
#include "CacheSet.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSharePageGeneralSMB property page

IMPLEMENT_DYNCREATE(CSharePageGeneralSMB, CSharePageGeneral)

CSharePageGeneralSMB::CSharePageGeneralSMB() : 
	CSharePageGeneral(CSharePageGeneralSMB::IDD),
	m_fEnableCacheFlag( FALSE ),
	m_dwFlags( 0 ),
	m_fEnableCachingButton (TRUE)
{
	//{{AFX_DATA_INIT(CSharePageGeneralSMB)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CSharePageGeneralSMB::~CSharePageGeneralSMB()
{
}

void CSharePageGeneralSMB::DoDataExchange(CDataExchange* pDX)
{
	CSharePageGeneral::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSharePageGeneralSMB)
	DDX_Control(pDX, IDC_CACHING, m_cacheBtn);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSharePageGeneralSMB, CSharePageGeneral)
	//{{AFX_MSG_MAP(CSharePageGeneralSMB)
	ON_BN_CLICKED(IDC_CACHING, OnCaching)
	ON_MESSAGE(WM_HELP, OnHelp)
	ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSharePageGeneralSMB message handlers
BOOL CSharePageGeneralSMB::Load( CFileMgmtComponentData* pFileMgmtData, LPDATAOBJECT piDataObject )
{
	ASSERT( NULL == m_pFileMgmtData && NULL != pFileMgmtData && NULL != piDataObject );
	if ( CSharePageGeneral::Load (pFileMgmtData, piDataObject) )
	{
		NET_API_STATUS retval = m_pFileMgmtData->GetFileServiceProvider(
				m_transport)->ReadShareFlags(
				m_strMachineName,
				m_strShareName,
				&m_dwFlags );
		switch (retval)
		{
		case NERR_Success:
			m_fEnableCacheFlag = TRUE;
			break;

		case NERR_InvalidAPI:
		case ERROR_INVALID_LEVEL:
			m_fEnableCachingButton = FALSE;
			break;

		default:
			m_fEnableCachingButton = FALSE;
			break;
		}
	}
	else
		return FALSE;

	return TRUE;
}

BOOL CSharePageGeneralSMB::OnApply()
{	
  if (m_dwShareType & STYPE_IPC)
    return TRUE;

	// UpdateData (TRUE) has already been called by OnKillActive () just before OnApply ()
	if ( m_fEnableCacheFlag && IsModified () )
	{
		NET_API_STATUS retval =
			m_pFileMgmtData->GetFileServiceProvider(m_transport)->WriteShareFlags(
					m_strMachineName,
					m_strShareName,
					m_dwFlags );
		if (0L == retval)
		{
			return CSharePageGeneral::OnApply();
		}
		else
		{
			CString	introMsg;
			VERIFY (introMsg.LoadString (IDS_CANT_SAVE_CHANGES));

			DisplayNetMsgError (introMsg, retval);
		}
	}
	else
		return CSharePageGeneral::OnApply();

	return FALSE;
}

void CSharePageGeneralSMB::DisplayNetMsgError (CString introMsg, NET_API_STATUS dwErr)
{
	AFX_MANAGE_STATE (AfxGetStaticModuleState ());
	LPVOID	lpMsgBuf = 0;
	HMODULE hNetMsgDLL = ::LoadLibrary (L"netmsg.dll");
	if ( hNetMsgDLL )
	{
		::FormatMessage (
				FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
				hNetMsgDLL,
				dwErr,
				MAKELANGID (LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
				(LPTSTR) &lpMsgBuf, 0, NULL);
			
		// Display the string.
		CString	caption;
		VERIFY (caption.LoadString (AFX_IDS_APP_TITLE));
		introMsg += L"  ";
		introMsg += (LPTSTR) lpMsgBuf;
		CThemeContextActivator activator;
		MessageBox (introMsg, caption, MB_ICONWARNING | MB_OK);

		// Free the buffer.
		::LocalFree (lpMsgBuf);

		::FreeLibrary (hNetMsgDLL);
	}
}

void CSharePageGeneralSMB::OnCaching() 
{
	CCacheSettingsDlg	dlg (this, INOUT m_dwFlags);
	CThemeContextActivator activator;
	if ( IDOK == dlg.DoModal () )
	{
		SetModified (TRUE);
	}
}

BOOL CSharePageGeneralSMB::OnInitDialog() 
{
	CSharePageGeneral::OnInitDialog();
	
	m_cacheBtn.EnableWindow (m_fEnableCachingButton);

  if (m_dwShareType & STYPE_IPC)
  {
    m_editShareName.SetReadOnly(TRUE);
    m_editPath.SetReadOnly(TRUE);
    m_editDescription.SetReadOnly(TRUE);
    m_checkBoxMaxAllowed.EnableWindow(FALSE);
    m_checkboxAllowSpecific.EnableWindow(FALSE);
    GetDlgItem(IDC_SHRPROP_EDIT_USERS)->EnableWindow(FALSE);
    GetDlgItem(IDC_SHRPROP_SPIN_USERS)->EnableWindow(FALSE);
    m_cacheBtn.EnableWindow(FALSE);
    (GetParent()->GetDlgItem(IDCANCEL))->EnableWindow(FALSE);
  }
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


static DWORD rgCSCUIHelpIds[] =
{
	IDC_CACHING, 1019, //IDH_SHARE_CACHING_BTN,
	0, 0
};

/////////////////////////////////////////////////////////////////////
//	Help
BOOL CSharePageGeneralSMB::OnHelp(WPARAM wParam, LPARAM lParam)
{
	LPHELPINFO	lphi = (LPHELPINFO) lParam;

	if ( HELPINFO_WINDOW == lphi->iContextType )  // a control
	{
		if ( IDC_CACHING == lphi->iCtrlId )
		{
			return ::WinHelp ((HWND) lphi->hItemHandle, L"cscui.hlp", 
					HELP_WM_HELP,
					(DWORD_PTR) rgCSCUIHelpIds);
		}
	}

	return CSharePageGeneral::OnHelp (wParam, lParam);
}

BOOL CSharePageGeneralSMB::OnContextHelp(WPARAM wParam, LPARAM lParam)
{
	int	ctrlID = ::GetDlgCtrlID ((HWND) wParam);
	if ( IDC_CACHING == ctrlID )
	{
		return ::WinHelp ((HWND) wParam, L"cscui.hlp", HELP_CONTEXTMENU,
				(DWORD_PTR) rgCSCUIHelpIds);
	}
	return CSharePageGeneral::OnContextHelp (wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\shrpgsmb.h ===
#if !defined(AFX_SHRPGSMB_H__A1211F5C_C439_11D1_A6C7_00C04FB94F17__INCLUDED_)
#define AFX_SHRPGSMB_H__A1211F5C_C439_11D1_A6C7_00C04FB94F17__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// ShrPgSMB.h : header file
//
#include "ShrProp.h"

/////////////////////////////////////////////////////////////////////////////
// CSharePageGeneralSMB dialog

class CSharePageGeneralSMB : public CSharePageGeneral
{
	DECLARE_DYNCREATE(CSharePageGeneralSMB)

// Construction
public:
	CSharePageGeneralSMB();
	virtual ~CSharePageGeneralSMB();

	virtual BOOL Load( CFileMgmtComponentData* pFileMgmtData, LPDATAOBJECT piDataObject );

// Dialog Data
	//{{AFX_DATA(CSharePageGeneralSMB)
	enum { IDD = IDD_SHAREPROP_GENERAL_SMB };
	CButton	m_cacheBtn;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CSharePageGeneralSMB)
	public:
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CSharePageGeneralSMB)
	afx_msg void OnCaching();
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	afx_msg BOOL OnContextHelp(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void DisplayNetMsgError (CString introMsg, NET_API_STATUS dwErr);

private:
	BOOL m_fEnableCachingButton;
    BOOL m_fEnableCacheFlag;
	DWORD m_dwFlags;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SHRPGSMB_H__A1211F5C_C439_11D1_A6C7_00C04FB94F17__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\shrprop.cpp ===
// svcprop1.cpp : implementation file
//

#include "stdafx.h"
#include "compdata.h"
#include "resource.h"
#include "shrprop.h"
#include "filesvc.h"
#include "dataobj.h" // CFileMgmtDataObject::m_CFMachineName

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSharePage property page

IMPLEMENT_DYNCREATE(CSharePage, CPropertyPage)

CSharePage::CSharePage(UINT nIDTemplate) : 
  CPropertyPage(nIDTemplate ? nIDTemplate : CSharePageGeneral::IDD),
  m_pfnOriginalPropSheetPageProc( NULL ),
  m_pFileMgmtData( NULL ),
  m_transport( FILEMGMT_OTHER ),
  m_handle (0),
  m_pDataObject (0),
  m_bChanged (FALSE)
{
}

CSharePage::~CSharePage()
{
  if (NULL != m_pFileMgmtData)
  {
    ((IComponentData*)m_pFileMgmtData)->Release();
    m_pFileMgmtData = NULL;
  }

  if ( m_pDataObject )
    m_pDataObject->Release ();

  if ( m_handle )
  {
    ::MMCFreeNotifyHandle (m_handle);
    m_handle = NULL;
  }
}

BOOL CSharePage::Load( CFileMgmtComponentData* pFileMgmtData, LPDATAOBJECT piDataObject )
{
  ASSERT( NULL == m_pFileMgmtData && NULL != pFileMgmtData && NULL != piDataObject );
  if ( !pFileMgmtData || !piDataObject )
    return FALSE;

  m_pDataObject = piDataObject;
  m_pDataObject->AddRef ();
  m_pFileMgmtData = pFileMgmtData;
  ((IComponentData*)m_pFileMgmtData)->AddRef();
  HRESULT hr = ExtractString( piDataObject, CFileMgmtDataObject::m_CFMachineName, &m_strMachineName, MAX_PATH );
  if ( FAILED(hr) )
  {
    ASSERT( FALSE );
    return FALSE;
  }
  if (m_strMachineName.IsEmpty())
  {
    // local computer
    TCHAR achComputerName[ MAX_COMPUTERNAME_LENGTH+1 ];
    DWORD dwSize = sizeof(achComputerName)/sizeof(TCHAR);
    GetComputerName( achComputerName, &dwSize );
    m_strMachineName = achComputerName;
  }

  hr = ExtractString( piDataObject, CFileMgmtDataObject::m_CFShareName, &m_strShareName, MAX_PATH );
  if ( FAILED(hr) )
  {
    ASSERT( FALSE );
    return FALSE;
  }

  hr = ExtractData( piDataObject,
                  CFileMgmtDataObject::m_CFTransport,
            &m_transport,
            sizeof(DWORD) );
  if ( FAILED(hr) )
  {
    ASSERT( FALSE );
    return FALSE;
  }

  return TRUE;
}

void CSharePage::DoDataExchange(CDataExchange* pDX)
{
  CPropertyPage::DoDataExchange(pDX);
  //{{AFX_DATA_MAP(CSharePage)
  //}}AFX_DATA_MAP
} // CSharePage::DoDataExchange()



BEGIN_MESSAGE_MAP(CSharePage, CPropertyPage)
  //{{AFX_MSG_MAP(CSharePage)
  //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSharePage message handlers

BOOL CSharePage::OnApply()
{  
  if ( IsModified () )
  {
    m_pDataObject->AddRef ();
    HRESULT hr = MMCPropertyChangeNotify (m_handle, reinterpret_cast <LONG_PTR>(m_pDataObject));
    ASSERT (SUCCEEDED (hr));
    if ( !SUCCEEDED (hr) )
      m_pDataObject->Release ();  // released in OnPropertyChange () if successful
  }

  BOOL bResult = CPropertyPage::OnApply();
  if ( bResult )
	  m_bChanged = FALSE;
  return bResult;
}

// This mechanism deletes the CFileMgmtGeneral when the property sheet is finished
UINT CALLBACK CSharePage::PropSheetPageProc(
    HWND hwnd,  
    UINT uMsg,  
    LPPROPSHEETPAGE ppsp )
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());

  if (!ppsp || !ppsp->lParam)
      return 0; // unexpected

  CSharePage* pThis = reinterpret_cast<CSharePage*>(ppsp->lParam);
  LPFNPSPCALLBACK pfnOrig = pThis->m_pfnOriginalPropSheetPageProc;
  if (!pfnOrig)
      return 0; // unexpected

  UINT i = (pfnOrig)(hwnd,uMsg,ppsp);

  if (uMsg == PSPCB_RELEASE)
      delete pThis;

  return i;
}

void CSharePage::SetModified(BOOL bChanged)
{
	m_bChanged = bChanged;
	CPropertyPage::SetModified (bChanged);
}

BOOL CSharePage::IsModified() const
{
	return m_bChanged;
}

/////////////////////////////////////////////////////////////////////////////
// CSharePageGeneral property page

IMPLEMENT_DYNCREATE(CSharePageGeneral, CSharePage)

CSharePageGeneral::CSharePageGeneral(UINT nIDTemplate) : 
  CSharePage(nIDTemplate ? nIDTemplate : CSharePageGeneral::IDD),
  m_pvPropertyBlock( NULL ),
  m_fEnableDescription( TRUE ),
  m_fEnablePath( TRUE ),
  m_dwShareType(0)
{
  //{{AFX_DATA_INIT(CSharePageGeneral)
  m_strShareName = _T("");
  m_strPath = _T("");
  m_strDescription = _T("");
  m_iMaxUsersAllowed = -1;
  m_dwMaxUsers = 0;

  //}}AFX_DATA_INIT
}

CSharePageGeneral::~CSharePageGeneral()
{
  if (NULL != m_pvPropertyBlock)
  {
    ASSERT( NULL != m_pFileMgmtData && FILEMGMT_OTHER != m_transport );
    m_pFileMgmtData->GetFileServiceProvider(m_transport)->FreeData(m_pvPropertyBlock);
  }
}

BOOL CSharePageGeneral::Load( CFileMgmtComponentData* pFileMgmtData, LPDATAOBJECT piDataObject )
{
    if (FALSE == CSharePage::Load(pFileMgmtData, piDataObject))
        return FALSE;

  BOOL fEditDescription = TRUE;
  BOOL fEditPath = TRUE;
  NET_API_STATUS retval =
    m_pFileMgmtData->GetFileServiceProvider(m_transport)->ReadShareProperties(
      m_strMachineName,
      m_strShareName,
      &m_pvPropertyBlock,
      m_strDescription,
      m_strPath,
      &m_fEnableDescription,
      &m_fEnablePath,
      &m_dwShareType);
  if (0L != retval)
  {
    (void) DoErrMsgBox(m_hWnd, MB_OK | MB_ICONSTOP, retval, IDS_POPUP_QUERY_SHARE, m_strShareName );
    return FALSE;
  }

  m_dwMaxUsers = m_pFileMgmtData->GetFileServiceProvider(
      m_transport)->QueryMaxUsers(m_pvPropertyBlock);

  if ((DWORD)-1 == m_dwMaxUsers)
  {
    m_iMaxUsersAllowed = 0;
    m_dwMaxUsers = 1;
  }
  else
  {
    m_iMaxUsersAllowed = 1;
  }

  return TRUE;
}

#define SHARE_DESCRIPTION_LIMIT   MAXCOMMENTSZ
#define MYUD_MAXVAL32             0x7FFFFFFF

void CSharePageGeneral::DoDataExchange(CDataExchange* pDX)
{
  CSharePage::DoDataExchange(pDX);
  //{{AFX_DATA_MAP(CSharePageGeneral)
  DDX_Control(pDX, IDC_SHRPROP_SPIN_USERS, m_spinMaxUsers);
  DDX_Control(pDX, IDC_EDIT_SHARE_NAME, m_editShareName);
  DDX_Control(pDX, IDC_EDIT_PATH_NAME, m_editPath);
  DDX_Control(pDX, IDC_EDIT_DESCRIPTION, m_editDescription);
  DDX_Control(pDX, IDC_SHRPROP_ALLOW_SPECIFIC, m_checkboxAllowSpecific);
  DDX_Control(pDX, IDC_SHRPROP_MAX_ALLOWED, m_checkBoxMaxAllowed);

  DDX_Text(pDX, IDC_EDIT_SHARE_NAME, m_strShareName);
  DDX_Text(pDX, IDC_EDIT_PATH_NAME, m_strPath);
  DDX_Text(pDX, IDC_EDIT_DESCRIPTION, m_strDescription);
  DDV_MaxChars(pDX, m_strDescription, SHARE_DESCRIPTION_LIMIT);

  DDX_Radio(pDX, IDC_SHRPROP_MAX_ALLOWED, m_iMaxUsersAllowed);
  DDX_Text(pDX, IDC_SHRPROP_EDIT_USERS, m_dwMaxUsers);
  DDV_MinMaxDWord(pDX, m_dwMaxUsers, 1, MYUD_MAXVAL32);
  //}}AFX_DATA_MAP
  if ( !pDX->m_bSaveAndValidate )
  {
    m_spinMaxUsers.SendMessage(UDM_SETRANGE32, 1, MYUD_MAXVAL32);

    if (0 == m_iMaxUsersAllowed)
    {
      GetDlgItem(IDC_SHRPROP_EDIT_USERS)->EnableWindow(FALSE);
      GetDlgItem(IDC_SHRPROP_SPIN_USERS)->EnableWindow(FALSE);
    }

    if ( !m_fEnableDescription ) {
      // m_staticDescription.SetWindowText(m_strDescription);
      // m_staticDescription.EnableWindow();
      // m_staticDescription.ShowWindow(SW_SHOW);
      m_editDescription.EnableWindow(FALSE);
      m_editDescription.ShowWindow(SW_HIDE);
      GetDlgItem(IDC_STATIC_COMMENT_STATIC)->EnableWindow(FALSE);
      GetDlgItem(IDC_STATIC_COMMENT_STATIC)->ShowWindow(SW_HIDE);

         // make read-only
      //   m_editDescription.SetReadOnly(TRUE);
    }
    if ( m_fEnablePath ) {
      // m_staticPath.EnableWindow(FALSE);
      // m_staticPath.ShowWindow(SW_HIDE);
      // m_editPath.EnableWindow();
      // m_editPath.ShowWindow(SW_SHOW);

         // make read-write
         m_editPath.SetReadOnly(FALSE);
    }
    else {
      // m_staticPath.SetWindowText(m_strPath);

         // leave read-only
    }
  }
} // CSharePageGeneral::DoDataExchange()



BEGIN_MESSAGE_MAP(CSharePageGeneral, CSharePage)
  //{{AFX_MSG_MAP(CSharePageGeneral)
  ON_MESSAGE(WM_HELP, OnHelp)
  ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
  ON_EN_CHANGE(IDC_EDIT_PATH_NAME, OnChangeEditPathName)
  ON_EN_CHANGE(IDC_EDIT_DESCRIPTION, OnChangeEditDescription)
  ON_EN_CHANGE(IDC_EDIT_SHARE_NAME, OnChangeEditShareName)
  ON_BN_CLICKED(IDC_SHRPROP_ALLOW_SPECIFIC, OnShrpropAllowSpecific)
  ON_BN_CLICKED(IDC_SHRPROP_MAX_ALLOWED, OnShrpropMaxAllowed)
  ON_EN_CHANGE(IDC_SHRPROP_EDIT_USERS, OnChangeShrpropEditUsers)
  //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSharePageGeneral message handlers

/////////////////////////////////////////////////////////////////////
//  Help
BOOL CSharePageGeneral::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
  return DoHelp(lParam, HELP_DIALOG_TOPIC(IDD_SHAREPROP_GENERAL));
}

BOOL CSharePageGeneral::OnContextHelp(WPARAM wParam, LPARAM /*lParam*/)
{
  return DoContextHelp(wParam, HELP_DIALOG_TOPIC(IDD_SHAREPROP_GENERAL));
}

BOOL CSharePageGeneral::OnApply()
{  
  if ( IsModified () )
  {
    ASSERT(NULL != m_pFileMgmtData);
    // UpdateData (TRUE) has already been called by OnKillActive () just before OnApply ()

    DWORD dwMaxUsers = (0 == m_iMaxUsersAllowed) ? (DWORD)-1 : m_dwMaxUsers;
    m_pFileMgmtData->GetFileServiceProvider(
        m_transport)->SetMaxUsers(m_pvPropertyBlock,dwMaxUsers);

    NET_API_STATUS retval =
      m_pFileMgmtData->GetFileServiceProvider(m_transport)->WriteShareProperties(
        m_strMachineName,
        m_strShareName,
        m_pvPropertyBlock,
        m_strDescription,
        m_strPath);
    if (0L != retval)
    {
      DoErrMsgBox(m_hWnd, MB_OK | MB_ICONEXCLAMATION, retval, IDS_POPUP_WRITE_SHARE, m_strShareName);
      return FALSE;
    }
  }

  return CSharePage::OnApply();
}

void CSharePageGeneral::OnChangeEditPathName() 
{
  SetModified (TRUE);
}

void CSharePageGeneral::OnChangeEditDescription() 
{
  SetModified (TRUE);
}

void CSharePageGeneral::OnChangeEditShareName() 
{
  SetModified (TRUE);
}

void CSharePageGeneral::OnShrpropAllowSpecific() 
{
  GetDlgItem(IDC_SHRPROP_EDIT_USERS)->EnableWindow(TRUE);
  GetDlgItem(IDC_SHRPROP_SPIN_USERS)->EnableWindow(TRUE);

  SetModified (TRUE);
}

void CSharePageGeneral::OnShrpropMaxAllowed() 
{
  SetDlgItemText(IDC_SHRPROP_EDIT_USERS, _T("1"));

  GetDlgItem(IDC_SHRPROP_EDIT_USERS)->EnableWindow(FALSE);
  GetDlgItem(IDC_SHRPROP_SPIN_USERS)->EnableWindow(FALSE);
  
  SetModified (TRUE);
}

void CSharePageGeneral::OnChangeShrpropEditUsers() 
{
    SetModified (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\shrpub.cpp ===
// svcprop1.cpp : implementation file
//

#include "stdafx.h"
#include "compdata.h"
#include "resource.h"
#include "shrpub.h"
#include "mvedit.h"
#include "filesvc.h"
#include "dataobj.h" // CFileMgmtDataObject::m_CFMachineName

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSharePagePublish property page

IMPLEMENT_DYNCREATE(CSharePagePublish, CSharePage)

CSharePagePublish::CSharePagePublish() : 
  CSharePage(CSharePagePublish::IDD)
{
  m_bExposeKeywords = TRUE;
  m_bExposeManagedBy = TRUE;

  //{{AFX_DATA_INIT(CSharePagePublish)
  m_iPublish = BST_UNCHECKED;
  //}}AFX_DATA_INIT
}

CSharePagePublish::~CSharePagePublish()
{
    m_handle = NULL; // let General page call MMCFreeNotifyHandle
}

BOOL CSharePagePublish::Load( CFileMgmtComponentData* pFileMgmtData, LPDATAOBJECT piDataObject )
{
  if ( FALSE == CSharePage::Load (pFileMgmtData, piDataObject) )
      return FALSE;

  if (FILEMGMT_SMB != m_transport)
      return FALSE;

  return TRUE;
}

void CSharePagePublish::DoDataExchange(CDataExchange* pDX)
{
  CSharePage::DoDataExchange(pDX);
  //{{AFX_DATA_MAP(CSharePagePublish)
  DDX_Check(pDX, IDC_CHECK_SHRPUB_PUBLISH, m_iPublish);

  DDX_Text(pDX, IDC_STATIC_SHRPUB_ERRORMSG, m_strError);
  DDX_Text(pDX, IDC_EDIT_SHRPUB_UNCPATH, m_strUNCPath);
  DDX_Text(pDX, IDC_EDIT_SHRPUB_DESCRIPTION, m_strDescription);
  DDX_Text(pDX, IDC_EDIT_SHRPUB_KEYWORDS, m_strKeywords);
  DDX_Text(pDX, IDC_EDIT_SHRPUB_MANAGEDBY, m_strManagedBy);
  DDV_MaxChars(pDX, m_strDescription, 1024);  // AD schema defines its upper to be 1024
  //}}AFX_DATA_MAP
  if ( !pDX->m_bSaveAndValidate )
  {
    if (BST_CHECKED != m_iPublish)
    {
      GetDlgItem(IDC_LABEL_SHRPUB_UNCPATH)->EnableWindow(FALSE);
      GetDlgItem(IDC_EDIT_SHRPUB_UNCPATH)->EnableWindow(FALSE);
      GetDlgItem(IDC_LABEL_SHRPUB_DESCRIPTION)->EnableWindow(FALSE);
      GetDlgItem(IDC_EDIT_SHRPUB_DESCRIPTION)->EnableWindow(FALSE);
      GetDlgItem(IDC_LABEL_SHRPUB_KEYWORDS)->EnableWindow(FALSE);
      GetDlgItem(IDC_EDIT_SHRPUB_KEYWORDS)->EnableWindow(FALSE);
      GetDlgItem(IDC_LABEL_SHRPUB_MANAGEDBY)->EnableWindow(FALSE);
      GetDlgItem(IDC_EDIT_SHRPUB_MANAGEDBY)->EnableWindow(FALSE);
      GetDlgItem(IDC_BUTTON_SHRPUB_CHANGE)->EnableWindow(FALSE);
    }
  }
} // CSharePagePublish::DoDataExchange()



BEGIN_MESSAGE_MAP(CSharePagePublish, CSharePage)
  //{{AFX_MSG_MAP(CSharePagePublish)
  ON_MESSAGE(WM_HELP, OnHelp)
  ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
  ON_EN_CHANGE(IDC_EDIT_SHRPUB_DESCRIPTION, OnChangeEditDescription)
  ON_BN_CLICKED(IDC_BUTTON_SHRPUB_CHANGE, OnChangeKeywords)
  ON_EN_CHANGE(IDC_EDIT_SHRPUB_MANAGEDBY, OnChangeEditManagedBy)
  ON_BN_CLICKED(IDC_CHECK_SHRPUB_PUBLISH, OnShrpubPublish)
  //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSharePagePublish message handlers
#define MAX_RDN_KEY_SIZE            64   // ds\src\inc\ntdsa.h

BOOL CSharePagePublish::OnInitDialog()
{
    BOOL bPublish = FALSE;
    HRESULT hr = S_OK;

    BOOL bLongShareName = (lstrlen(m_strShareName) > MAX_RDN_KEY_SIZE);
    if (!bLongShareName)
        m_pFileMgmtData->GetFileServiceProvider(FILEMGMT_SMB)->ReadSharePublishInfo(
                                        m_strMachineName,
                                        m_strShareName,
                                        &bPublish,
                                        m_strUNCPath,
                                        m_strDescription,
                                        m_strKeywords,
                                        m_strManagedBy
                                        );
    if (bLongShareName || FAILED(hr))
    {
        if (bLongShareName)
        {
            (void) GetMsg(m_strError, 0, IDS_MSG_SHRPUB_ERRMSG_64);
        } else
        {
            (void) GetMsg(m_strError, hr, IDS_MSG_READ_SHRPUB, m_strShareName);
        }

        //
        // show errmsg, hide all the other controls
        //
        GetDlgItem(IDC_CHECK_SHRPUB_PUBLISH)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_CHECK_SHRPUB_PUBLISH)->EnableWindow(FALSE);

        GetDlgItem(IDC_LABEL_SHRPUB_UNCPATH)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_LABEL_SHRPUB_UNCPATH)->EnableWindow(FALSE);
        GetDlgItem(IDC_EDIT_SHRPUB_UNCPATH)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_EDIT_SHRPUB_UNCPATH)->EnableWindow(FALSE);
        GetDlgItem(IDC_LABEL_SHRPUB_DESCRIPTION)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_LABEL_SHRPUB_DESCRIPTION)->EnableWindow(FALSE);
        GetDlgItem(IDC_EDIT_SHRPUB_DESCRIPTION)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_EDIT_SHRPUB_DESCRIPTION)->EnableWindow(FALSE);
        GetDlgItem(IDC_LABEL_SHRPUB_KEYWORDS)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_LABEL_SHRPUB_KEYWORDS)->EnableWindow(FALSE);
        GetDlgItem(IDC_EDIT_SHRPUB_KEYWORDS)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_EDIT_SHRPUB_KEYWORDS)->EnableWindow(FALSE);
        GetDlgItem(IDC_BUTTON_SHRPUB_CHANGE)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_BUTTON_SHRPUB_CHANGE)->EnableWindow(FALSE);
        GetDlgItem(IDC_LABEL_SHRPUB_MANAGEDBY)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_LABEL_SHRPUB_MANAGEDBY)->EnableWindow(FALSE);
        GetDlgItem(IDC_EDIT_SHRPUB_MANAGEDBY)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_EDIT_SHRPUB_MANAGEDBY)->EnableWindow(FALSE);
    } else
    {
        GetDlgItem(IDC_STATIC_SHRPUB_ERRORMSG)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_STATIC_SHRPUB_ERRORMSG)->EnableWindow(FALSE);

        if (!m_bExposeKeywords)
        {
            GetDlgItem(IDC_LABEL_SHRPUB_KEYWORDS)->ShowWindow(SW_HIDE);
            GetDlgItem(IDC_LABEL_SHRPUB_KEYWORDS)->EnableWindow(FALSE);
            GetDlgItem(IDC_EDIT_SHRPUB_KEYWORDS)->ShowWindow(SW_HIDE);
            GetDlgItem(IDC_EDIT_SHRPUB_KEYWORDS)->EnableWindow(FALSE);
            GetDlgItem(IDC_BUTTON_SHRPUB_CHANGE)->ShowWindow(SW_HIDE);
            GetDlgItem(IDC_BUTTON_SHRPUB_CHANGE)->EnableWindow(FALSE);
        }

        if (!m_bExposeManagedBy)
        {
            GetDlgItem(IDC_LABEL_SHRPUB_MANAGEDBY)->ShowWindow(SW_HIDE);
            GetDlgItem(IDC_LABEL_SHRPUB_MANAGEDBY)->EnableWindow(FALSE);
            GetDlgItem(IDC_EDIT_SHRPUB_MANAGEDBY)->ShowWindow(SW_HIDE);
            GetDlgItem(IDC_EDIT_SHRPUB_MANAGEDBY)->EnableWindow(FALSE);
        }

        if (!bPublish)
        {
            if (m_strMachineName.Left(2) == _T("\\\\"))
            {
                m_strUNCPath = m_strMachineName;
            } else
            {
                m_strUNCPath = _T("\\\\");
                m_strUNCPath += m_strMachineName;
            }
            m_strUNCPath += _T("\\");
            m_strUNCPath += m_strShareName;
        }

        m_iPublish = (bPublish ? BST_CHECKED : BST_UNCHECKED);
    }

    return CSharePage::OnInitDialog();
}

/////////////////////////////////////////////////////////////////////
//  Help
BOOL CSharePagePublish::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
  return DoHelp(lParam, HELP_DIALOG_TOPIC(IDD_SHAREPROP_PUBLISH));
}

BOOL CSharePagePublish::OnContextHelp(WPARAM wParam, LPARAM /*lParam*/)
{
  return DoContextHelp(wParam, HELP_DIALOG_TOPIC(IDD_SHAREPROP_PUBLISH));
}

BOOL CSharePagePublish::OnApply()
{  
  if ( IsModified () )
  {
    ASSERT(NULL != m_pFileMgmtData);
    // UpdateData (TRUE) has already been called by OnKillActive () just before OnApply ()

    HRESULT hr =
      m_pFileMgmtData->GetFileServiceProvider(FILEMGMT_SMB)->WriteSharePublishInfo(
                                        m_strMachineName,
                                        m_strShareName,
                                        (BST_CHECKED==m_iPublish),
                                        m_strDescription,
                                        m_strKeywords,
                                        m_strManagedBy);
    if (FAILED(hr))
    {
      DoErrMsgBox(m_hWnd, MB_OK | MB_ICONEXCLAMATION, hr, IDS_POPUP_WRITE_SHRPUB, m_strShareName);
      return FALSE;
    }
  }

  return CSharePage::OnApply();
}

void CSharePagePublish::OnChangeEditDescription() 
{
  SetModified (TRUE);
}

#define KEYTWORDS_UPPER_RANGER  256

void CSharePagePublish::OnChangeKeywords() 
{
    if (S_OK == InvokeMultiValuedStringEditDlg(
                                this,
                                m_strKeywords,
                                _T(";"), 
                                IDS_MVSTRINGEDIT_TITLE_KEYWORDS,
                                IDS_MVSTRINGEDIT_TEXT_KEYWORDS,
                                KEYTWORDS_UPPER_RANGER))
    {
        SetDlgItemText(IDC_EDIT_SHRPUB_KEYWORDS, m_strKeywords);
        SetModified (TRUE);
    }
}

void CSharePagePublish::OnChangeEditManagedBy() 
{
  SetModified (TRUE);
}

void CSharePagePublish::OnShrpubPublish() 
{
  BOOL bPublish = (BST_CHECKED == IsDlgButtonChecked(IDC_CHECK_SHRPUB_PUBLISH));

  GetDlgItem(IDC_LABEL_SHRPUB_UNCPATH)->EnableWindow(bPublish);
  GetDlgItem(IDC_EDIT_SHRPUB_UNCPATH)->EnableWindow(bPublish);
  GetDlgItem(IDC_LABEL_SHRPUB_DESCRIPTION)->EnableWindow(bPublish);
  GetDlgItem(IDC_EDIT_SHRPUB_DESCRIPTION)->EnableWindow(bPublish);
  GetDlgItem(IDC_LABEL_SHRPUB_KEYWORDS)->EnableWindow(bPublish);
  GetDlgItem(IDC_EDIT_SHRPUB_KEYWORDS)->EnableWindow(bPublish);
  GetDlgItem(IDC_LABEL_SHRPUB_MANAGEDBY)->EnableWindow(bPublish);
  GetDlgItem(IDC_EDIT_SHRPUB_MANAGEDBY)->EnableWindow(bPublish);
  GetDlgItem(IDC_BUTTON_SHRPUB_CHANGE)->EnableWindow(bPublish);

  SetModified (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\shrprop.h ===
// shrprop.h : header file
//

#ifndef _SHRPROP_H_
#define _SHRPROP_H_

#include "cookie.h" // FILEMGMT_TRANSPORT
#include "comptr.h" // CIP<typename>

// forward delarations
class CFileMgmtComponent;
class CFileMgmtComponentData;

/////////////////////////////////////////////////////////////////////////////
// CSharePage dialog - 4/25/2000, LinanT
//
// MFC-based property page inherits from this page.
//            CPropertyPage
//                  |
//              CSharePage
//            /            \
//           /              \
// CSharePagePublish      CSharePageGeneral
//                      /                   \
//                     /                     \
//            SharePageGeneralSMB   CSharePageGeneralSFM
//

class CSharePage : public CPropertyPage
{
  DECLARE_DYNCREATE(CSharePage)

// Construction
public:
  CSharePage(UINT nIDTemplate = 0);
  virtual ~CSharePage();

// User defined variables
  LPFNPSPCALLBACK m_pfnOriginalPropSheetPageProc;

  // load initial state into CFileMgmtGeneral
  virtual BOOL Load( CFileMgmtComponentData* pFileMgmtData, LPDATAOBJECT piDataObject );
  CString m_strMachineName;
  CString m_strShareName;
  CFileMgmtComponentData* m_pFileMgmtData;
  FILEMGMT_TRANSPORT m_transport;
  LONG_PTR m_handle;  // notification handle for changes, can only be freed once by MMCFreeNotifyHandle
  LPDATAOBJECT m_pDataObject;  // use as hint for change notification

// Dialog Data
  //{{AFX_DATA(CSharePage)
  //}}AFX_DATA


// Overrides
  // ClassWizard generate virtual function overrides
  //{{AFX_VIRTUAL(CSharePage)
  public:
  virtual BOOL OnApply();
  protected:
  virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
  //}}AFX_VIRTUAL

// Implementation
protected:
  // Generated message map functions
  //{{AFX_MSG(CSharePage)
 // virtual BOOL OnInitDialog();
  //}}AFX_MSG
  DECLARE_MESSAGE_MAP()

public:
	BOOL IsModified () const;
	void SetModified (BOOL bChanged);

// User defined functions
  // This mechanism deletes the page when the property sheet is finished
  static UINT CALLBACK PropSheetPageProc(
    HWND hwnd,  
    UINT uMsg,  
    LPPROPSHEETPAGE ppsp );

private:
  BOOL	m_bChanged;

};

/////////////////////////////////////////////////////////////////////////////
// CSharePageGeneral dialog

class CSharePageGeneral : public CSharePage
{
  DECLARE_DYNCREATE(CSharePageGeneral)

// Construction
public:
  CSharePageGeneral(UINT nIDTemplate = 0);
  virtual ~CSharePageGeneral();

  // load initial state into CFileMgmtGeneral
  virtual BOOL Load( CFileMgmtComponentData* pFileMgmtData, LPDATAOBJECT piDataObject );
  PVOID m_pvPropertyBlock;
  BOOL m_fEnableDescription;
  BOOL m_fEnablePath;
  DWORD m_dwShareType;

// Dialog Data
  //{{AFX_DATA(CSharePageGeneral)
  enum { IDD = IDD_SHAREPROP_GENERAL };
  CSpinButtonCtrl  m_spinMaxUsers;
  CButton m_checkboxAllowSpecific;
  CButton m_checkBoxMaxAllowed;
   CEdit m_editShareName;

   CEdit  m_editPath;
  CEdit  m_editDescription;
  CString  m_strPath;
  CString  m_strDescription;
  int    m_iMaxUsersAllowed;
  DWORD  m_dwMaxUsers;
  //}}AFX_DATA


// Overrides
  // ClassWizard generate virtual function overrides
  //{{AFX_VIRTUAL(CSharePageGeneral)
  public:
  virtual BOOL OnApply();
  protected:
  virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
  //}}AFX_VIRTUAL

// Implementation
protected:
  // Generated message map functions
  //{{AFX_MSG(CSharePageGeneral)
  afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
  afx_msg BOOL OnContextHelp(WPARAM wParam, LPARAM lParam);
  afx_msg void OnChangeEditPathName();
  afx_msg void OnChangeEditDescription();
  afx_msg void OnChangeEditShareName();
  afx_msg void OnShrpropAllowSpecific();
  afx_msg void OnShrpropMaxAllowed();
  afx_msg void OnChangeShrpropEditUsers();
  //}}AFX_MSG
  DECLARE_MESSAGE_MAP()

};

#endif // _SHRPROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\smb.h ===
// smb.h: SMB shares, sessions and open resources

#ifndef __SMB_H_INCLUDED__
#define __SMB_H_INCLUDED__

#include "FileSvc.h" // FileServiceProvider
#include "shlobj.h"  // LPITEMIDLIST

//
// helper functions
//
HRESULT GetDCInfo(
    IN LPCTSTR ptchServerName,
    OUT CString& strDCName
    );

HRESULT GetADsPathOfComputerObject(
    IN LPCTSTR ptchServerName,
    OUT CString& strADsPath,
    OUT CString& strDCName
    );

HRESULT CheckSchemaVersion(IN LPCTSTR ptchServerName);

BOOL CheckPolicyOnSharePublish(IN LPCTSTR ptchShareName);

HRESULT PutMultiValuesIntoVarArray(
    IN LPCTSTR      pszValues,
    OUT VARIANT*    pVar
    );

HRESULT GetSingleOrMultiValuesFromVarArray(
    IN VARIANT* pVar,
    OUT CString& strValues
    );

HRESULT IsValueInVarArray(
    IN VARIANT* pVar,
    IN LPCTSTR  ptchValue
    );

// forward declarations
class CSmbCookieBlock;

class SmbFileServiceProvider : public FileServiceProvider
{
public:
  SmbFileServiceProvider( CFileMgmtComponentData* pFileMgmtData );

  virtual DWORD OpenShare(LPCTSTR ptchServerName, LPCTSTR ptchShareName);
  virtual HRESULT ConfirmDeleteShare(LPCTSTR ptchServerName, LPCTSTR ptchShareName);
  virtual DWORD DeleteShare(LPCTSTR ptchServerName, LPCTSTR ptchShareName);
  virtual DWORD CloseSession(CFileMgmtResultCookie* pcookie);
  virtual DWORD CloseResource(CFileMgmtResultCookie* pcookie);

  virtual VOID DisplayShareProperties(
    LPPROPERTYSHEETCALLBACK pCallBack,
    LPDATAOBJECT pDataObject,
    LONG_PTR handle);
  virtual DWORD ReadShareProperties(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    OUT PVOID* ppvPropertyBlock,
    OUT CString& strDescription,
    OUT CString& strPath,
    OUT BOOL* pfEditDescription,
    OUT BOOL* pfEditPath,
    OUT DWORD* pdwShareType);
  virtual DWORD WriteShareProperties(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    PVOID pvPropertyBlock,
    LPCTSTR ptchDescription,
    LPCTSTR ptchPath);
  virtual HRESULT ReadSharePublishInfo(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    OUT BOOL* pbPublish,
    OUT CString& strUNCPath,
    OUT CString& strDescription,
    OUT CString& strKeywords,
    OUT CString& strManagedBy);
  virtual HRESULT WriteSharePublishInfo(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    IN BOOL bPublish,
    LPCTSTR ptchDescription,
    LPCTSTR ptchKeywords,
    LPCTSTR ptchManagedBy);
  virtual DWORD ReadShareType(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    DWORD* pdwShareType );
  virtual DWORD ReadShareFlags(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    DWORD* pdwFlags );
  virtual DWORD WriteShareFlags(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    DWORD dwFlags );
  virtual BOOL GetCachedFlag( DWORD dwFlags, DWORD dwFlagToCheck );
  virtual VOID SetCachedFlag( DWORD* pdwFlags, DWORD dwNewFlag );
  virtual VOID FreeShareProperties(PVOID pvPropertyBlock);

  virtual HRESULT PopulateShares(
    IResultData* pResultData,
    CFileMgmtCookie* pcookie);
  //   if pResultData is not NULL, add sessions/resources to the listbox
  //   if pResultData is NULL, delete all sessions/resources
  //   if pResultData is NULL, return SUCCEEDED(hr) to continue or
  //     FAILED(hr) to abort
  virtual HRESULT EnumerateSessions(
    IResultData* pResultData,
    CFileMgmtCookie* pcookie,
    bool bAddToResultPane);
  virtual HRESULT EnumerateResources(
    IResultData* pResultData,
    CFileMgmtCookie* pcookie);

  virtual VOID FreeData(PVOID pv);

  virtual DWORD QueryMaxUsers(PVOID pvPropertyBlock);
  virtual VOID  SetMaxUsers(  PVOID pvPropertyBlock, DWORD dwMaxUsers);

  virtual LPCTSTR QueryTransportString();

  HRESULT AddSMBShareItems(
    IResultData* pResultData,
    CFileMgmtCookie* pParentCookie,
    PVOID pinfo,
    DWORD nItems);
  HRESULT HandleSMBSessionItems(
    IResultData* pResultData,
    CFileMgmtCookie* pParentCookie,
    PVOID pinfo,
    DWORD nItems,
    BOOL bAddToResultPane);
  HRESULT HandleSMBResourceItems(
    IResultData* pResultData,
    CFileMgmtCookie* pParentCookie,
    PVOID pinfo,
    DWORD nItems);

private:
    CString m_strTransportSMB;
};

class CSmbCookie : public CFileMgmtResultCookie
{
public:
  inline CSmbCookie( FileMgmtObjectType objecttype )
    : CFileMgmtResultCookie( objecttype ),
    m_pCookieBlock (0)
  {}
  virtual HRESULT GetTransport( OUT FILEMGMT_TRANSPORT* pTransport );

  virtual void AddRefCookie();
  virtual void ReleaseCookie();

// CHasMachineName
  CSmbCookieBlock* m_pCookieBlock;
  DECLARE_FORWARDS_MACHINE_NAME(m_pCookieBlock)
};


class CSmbCookieBlock : public CCookieBlock<CSmbCookie>, public CStoresMachineName
{
public:
  inline CSmbCookieBlock(
    CSmbCookie* aCookies, // use vector ctor, we use vector dtor
    INT cCookies,
    LPCTSTR lpcszMachineName,
    PVOID pvCookieData)
    :  CCookieBlock<CSmbCookie>( aCookies, cCookies ),
      CStoresMachineName( lpcszMachineName ),
      m_pvCookieData( pvCookieData )
  {
    for (int i = 0; i < cCookies; i++)
//    {
//      aCookies[i].ReadMachineNameFrom( (CHasMachineName*)this );
       aCookies[i].m_pCookieBlock = this;
//    }
  }
  virtual ~CSmbCookieBlock();
private:
  PVOID m_pvCookieData;
};

class CSmbShareCookie : public CSmbCookie
{
public:
  inline CSmbShareCookie() : CSmbCookie( FILEMGMT_SHARE ) {}
  virtual HRESULT GetShareName( OUT CString& strShareName );
  virtual HRESULT GetExplorerViewDescription( OUT CString& strExplorerViewDescription );

  inline virtual DWORD GetNumOfCurrentUses() { return GetShareInfo()->shi2_current_uses; }
  virtual BSTR GetColumnText(int nCol);
 
  virtual BSTR QueryResultColumnText( int nCol, CFileMgmtComponentData& refcdata );

  inline SHARE_INFO_2* GetShareInfo()
  {
    ASSERT( NULL != m_pobject );
    return (SHARE_INFO_2*)m_pobject;
  }
  virtual HRESULT GetSharePIDList( OUT LPITEMIDLIST *ppidl );

};

class CSmbSessionCookie : public CSmbCookie
{
public:
  inline CSmbSessionCookie() : CSmbCookie( FILEMGMT_SESSION )
    {
    }
  virtual HRESULT GetSessionClientName( OUT CString& strShareName );
  virtual HRESULT GetSessionUserName( OUT CString& strShareName );

  inline virtual DWORD GetNumOfOpenFiles() { return GetSessionInfo()->sesi1_num_opens; }
  inline virtual DWORD GetConnectedTime() { return GetSessionInfo()->sesi1_time; }
  inline virtual DWORD GetIdleTime() { return GetSessionInfo()->sesi1_idle_time; }
  virtual BSTR GetColumnText(int nCol);

  virtual BSTR QueryResultColumnText( int nCol, CFileMgmtComponentData& refcdata );

  inline SESSION_INFO_1* GetSessionInfo()
  {
    ASSERT( NULL != m_pobject );
    return (SESSION_INFO_1*)m_pobject;
  }
};

class CSmbResourceCookie : public CSmbCookie
{
public:
  inline CSmbResourceCookie() : CSmbCookie( FILEMGMT_RESOURCE ) {}
  virtual HRESULT GetFileID( DWORD* pdwFileID );

  inline virtual DWORD GetNumOfLocks() { return GetFileInfo()->fi3_num_locks; }
  virtual BSTR GetColumnText(int nCol);

  virtual BSTR QueryResultColumnText( int nCol, CFileMgmtComponentData& refcdata );
  inline FILE_INFO_3* GetFileInfo()
  {
    ASSERT( NULL != m_pobject );
    return (FILE_INFO_3*)m_pobject;
  }
};

#endif // ~__SMB_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\snapmgr.cpp ===
// SnapMgr.cpp : implementation file for Snapin Manager property page
//

#include "stdafx.h"
#include "SnapMgr.h"
#include "compdata.h" // CFileMgmtComponentData

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// This array is used to map a radio button to an object type
static const FileMgmtObjectType rgRadioToObjectType[] =
	{
	FILEMGMT_ROOT,
	FILEMGMT_SHARES,
	FILEMGMT_SESSIONS,
	FILEMGMT_RESOURCES,
	FILEMGMT_SERVICES,
	};


/////////////////////////////////////////////////////////////////////////////
// CFileMgmtGeneral property page

// IMPLEMENT_DYNCREATE(CFileMgmtGeneral, CChooseMachinePropPage)
BEGIN_MESSAGE_MAP(CFileMgmtGeneral, CChooseMachinePropPage)
	//{{AFX_MSG_MAP(CFileMgmtGeneral)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


CFileMgmtGeneral::CFileMgmtGeneral() : CChooseMachinePropPage(IDD_FILE_FILEMANAGEMENT_GENERAL)
{
	m_pFileMgmtData = NULL;
	//{{AFX_DATA_INIT(CFileMgmtGeneral)
	m_iRadioObjectType = 0;
	//}}AFX_DATA_INIT
}

CFileMgmtGeneral::~CFileMgmtGeneral()
{
}


void CFileMgmtGeneral::SetFileMgmtComponentData(CFileMgmtComponentData * pFileMgmtData)
{
	ASSERT(pFileMgmtData != NULL);
	m_pFileMgmtData = pFileMgmtData;
	m_iRadioObjectType = pFileMgmtData->QueryRootCookie().QueryObjectType() - FILEMGMT_ROOT; // CODEWORK dangerous
}


void CFileMgmtGeneral::DoDataExchange(CDataExchange* pDX)
{
	CChooseMachinePropPage::DoDataExchange(pDX);
	DDX_Radio(pDX, IDC_RADIO_ALL, m_iRadioObjectType);
	//{{AFX_DATA_MAP(CFileMgmtGeneral)
	//}}AFX_DATA_MAP
}


BOOL CFileMgmtGeneral::OnWizardFinish()
{
	BOOL f = CChooseMachinePropPage::OnWizardFinish();
	ASSERT(m_pFileMgmtData != NULL);
	ASSERT(m_iRadioObjectType >= 0 && m_iRadioObjectType < LENGTH(rgRadioToObjectType));
	m_pFileMgmtData->QueryRootCookie().SetObjectType( rgRadioToObjectType[m_iRadioObjectType] );
	return f;
}


#include "chooser.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\shrpub.h ===
// shrpub.h : header file
//

#ifndef _SHRPUB_H_
#define _SHRPUB_H_

#include "ShrProp.h"

/////////////////////////////////////////////////////////////////////////////
// CSharePagePublish dialog

class CSharePagePublish : public CSharePage
{
  DECLARE_DYNCREATE(CSharePagePublish)

// Construction
public:
  CSharePagePublish();
  virtual ~CSharePagePublish();

  virtual BOOL Load( CFileMgmtComponentData* pFileMgmtData, LPDATAOBJECT piDataObject );

// Dialog Data
  //{{AFX_DATA(CSharePagePublish)
  enum { IDD = IDD_SHAREPROP_PUBLISH };
  CString  m_strError;
  CString  m_strUNCPath;
  CString  m_strDescription;
  CString  m_strKeywords;
  CString  m_strManagedBy;
  int      m_iPublish;
  //}}AFX_DATA


// Overrides
  // ClassWizard generate virtual function overrides
  //{{AFX_VIRTUAL(CSharePagePublish)
  public:
  virtual BOOL OnApply();
  protected:
  virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
  //}}AFX_VIRTUAL

// Implementation
protected:
  // Generated message map functions
  //{{AFX_MSG(CSharePagePublish)
  virtual BOOL OnInitDialog();
  afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
  afx_msg BOOL OnContextHelp(WPARAM wParam, LPARAM lParam);
  afx_msg void OnChangeEditDescription();
  afx_msg void OnChangeKeywords();
  afx_msg void OnChangeEditManagedBy();
  afx_msg void OnShrpubPublish();
  //}}AFX_MSG
  DECLARE_MESSAGE_MAP()

private:
    BOOL m_bExposeKeywords;
    BOOL m_bExposeManagedBy;
};

#endif // _SHRPUB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\smb.cpp ===
// smb.cpp : SMB shares, sessions and open resources

#include "stdafx.h"
#include "cmponent.h"
#include "safetemp.h"
#include "FileSvc.h"
#include "DynamLnk.h"    // DynamicDLL
#include "smb.h"
#include "ShrPgSMB.h"    // Share Properties Pages
#include "permpage.h"    // CSecurityInformation
#include "compdata.h"
#include "shrpub.h"
#include <activeds.h>
#include <dsrole.h>
#include <dsgetdc.h>
#include <lmwksta.h>
#include <winsock2.h>

#define DONT_WANT_SHELLDEBUG
#include "shlobjp.h"     // LPITEMIDLIST
#include "wraps.h"       // Wrap_ILCreateFromPath   

#include "macros.h"
USE_HANDLE_MACROS("FILEMGMT(smb.cpp)")

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// no Publish page for these system shares
//
LPCTSTR g_pszSystemShares[] = { _T("SYSVOL"), _T("NETLOGON"), _T("DEBUG") };

class CSMBSecurityInformation : public CShareSecurityInformation
{
    STDMETHOD(GetSecurity) (SECURITY_INFORMATION RequestedInformation,
                            PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                            BOOL fDefault );
    STDMETHOD(SetSecurity) (SECURITY_INFORMATION SecurityInformation,
                            PSECURITY_DESCRIPTOR pSecurityDescriptor );
public:
  SHARE_INFO_502* m_pvolumeinfo;
  PSECURITY_DESCRIPTOR m_pDefaultDescriptor;
  CSMBSecurityInformation();
  ~CSMBSecurityInformation();
};

typedef enum _SmbApiIndex
{
  SMB_SHARE_ENUM = 0,
  SMB_SESSION_ENUM,
  SMB_FILE_ENUM,
  SMB_API_BUFFER_FREE,
  SMB_SHARE_DEL,
  SMB_SESSION_DEL,
  SMB_FILE_CLOSE,
  SMB_SHARE_GET_INFO,
  SMB_SHARE_SET_INFO,
  SMB_CONNECTION_ENUM
};

// not subject to localization
static LPCSTR g_apchFunctionNames[] = {
  "NetShareEnum",
  "NetSessionEnum",
  "NetFileEnum",
  "NetApiBufferFree",
  "NetShareDel",
  "NetSessionDel",
  "NetFileClose",
  "NetShareGetInfo",
  "NetShareSetInfo",
  "NetConnectionEnum",
  NULL
};

// not subject to localization
DynamicDLL g_SmbDLL( _T("NETAPI32.DLL"), g_apchFunctionNames );

typedef DWORD (*APIBUFFERFREEPROC) (LPVOID);

VOID SMBFreeData(PVOID* ppv)
{
  if (*ppv != NULL)
  {
    ASSERT( NULL != g_SmbDLL[SMB_API_BUFFER_FREE] );
    (void) ((APIBUFFERFREEPROC)g_SmbDLL[SMB_API_BUFFER_FREE])( *ppv );
    *ppv = NULL;
  }
}


SmbFileServiceProvider::SmbFileServiceProvider( CFileMgmtComponentData* pFileMgmtData )
  // not subject to localization
  : FileServiceProvider( pFileMgmtData )
{
    VERIFY( m_strTransportSMB.LoadString( IDS_TRANSPORT_SMB ) );
}

/*
NET_API_STATUS NET_API_FUNCTION
NetShareEnum (
    IN  LPTSTR      servername,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle
    );
*/

typedef DWORD (*SHAREENUMPROC) (LPTSTR,DWORD,LPBYTE*,DWORD,LPDWORD,LPDWORD,LPDWORD);

HRESULT SmbFileServiceProvider::PopulateShares(
  IResultData* pResultData,
  CFileMgmtCookie* pcookie)
{
  TEST_NONNULL_PTR_PARAM(pcookie);

  if ( !g_SmbDLL.LoadFunctionPointers() )
  {
    ASSERT(FALSE); // NETAPI32 isn't installed?
    return S_OK;
  }

    SHARE_INFO_2* psi2 = NULL;
    DWORD dwEntriesRead = 0;
    DWORD dwTotalEntries = 0;
    DWORD hEnumHandle = 0;
    NET_API_STATUS retval = NERR_Success;
    do {
        retval = ((SHAREENUMPROC)g_SmbDLL[SMB_SHARE_ENUM])(
            const_cast<LPTSTR>(pcookie->QueryTargetServer()),
      2,
      (PBYTE*)&psi2,
      (DWORD)-1L,
      &dwEntriesRead,
      &dwTotalEntries,
      &hEnumHandle );
        if (NERR_Success == retval)
        {
            AddSMBShareItems( pResultData, pcookie, psi2, dwEntriesRead );
            psi2 = NULL;
            break;
        } else if (ERROR_MORE_DATA == retval) {
            ASSERT( NULL != hEnumHandle );
            AddSMBShareItems( pResultData, pcookie, psi2, dwEntriesRead );
            psi2 = NULL;
            continue;
/*
        } else if (RPC_S_SERVER_UNAVAILABLE == retval && 0 == hEnumHandle) {
      // SMB just isn't installed, don't worry about it
            break;
*/
        } else {
            if (ERROR_ACCESS_DENIED == retval)
            {
                (void) DoErrMsgBox(
                            GetActiveWindow(), 
                            MB_OK | MB_ICONSTOP, 
                            0,
                            IDS_POPUP_SMB_SHARES_NOACCESS
                            );
            } else
            {
                (void) DoErrMsgBox(
                            GetActiveWindow(), 
                            MB_OK | MB_ICONSTOP, 
                            retval, 
                            IDS_POPUP_SMB_SHARES
                            );
            }
            break;
        }
    } while (TRUE);

    return HRESULT_FROM_WIN32(retval);
}

//
// skip sharenames that contain leading/trailing spaces
//
BOOL IsInvalidSharename(LPCTSTR psz)
{
    return (!psz || !*psz || _istspace(psz[0]) || _istspace(psz[lstrlen(psz) - 1]));
}

/*
typedef struct _SHARE_INFO_2 {
    LPTSTR  shi2_netname;
    DWORD   shi2_type;
    LPTSTR  shi2_remark;
    DWORD   shi2_permissions;
    DWORD   shi2_max_uses;
    DWORD   shi2_current_uses;
    LPTSTR  shi2_path;
    LPTSTR  shi2_passwd;
} SHARE_INFO_2, *PSHARE_INFO_2, *LPSHARE_INFO_2;
*/
HRESULT SmbFileServiceProvider::AddSMBShareItems(
    IResultData* pResultData,
    CFileMgmtCookie* pParentCookie,
    PVOID pinfo,
    DWORD nItems)
{
  TEST_NONNULL_PTR_PARAM(pParentCookie);
  TEST_NONNULL_PTR_PARAM(pinfo);

  if (0 >= nItems)
    return S_OK;

  RESULTDATAITEM tRDItem;
  ::ZeroMemory( &tRDItem, sizeof(tRDItem) );
  // CODEWORK should use MMC_ICON_CALLBACK
  tRDItem.nCol = COLNUM_SHARES_SHARED_FOLDER;
  tRDItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
  tRDItem.str = MMC_CALLBACK;

  SHARE_INFO_2* psi2 = (SHARE_INFO_2*)pinfo;

  DWORD nItemsToAdd = 0;
  for (DWORD i = 0; i < nItems; i++ )
  {
    switch ((psi2[i]).shi2_type)
    {
      case STYPE_PRINTQ:    // Do not show print shares
      case STYPE_DEVICE:    // Do not show device shares
        break;

      default:
        if (!IsInvalidSharename(psi2[i].shi2_netname))
            nItemsToAdd++;
        break;
    }
  }

  CSmbShareCookie* pcookiearray = new CSmbShareCookie[nItemsToAdd];
  CSmbCookieBlock* pCookieBlock = new CSmbCookieBlock(
    pcookiearray,
    nItemsToAdd,
    pParentCookie->QueryNonNULLMachineName(),
    pinfo );
  pParentCookie->m_listResultCookieBlocks.AddHead( pCookieBlock );

  CString str;

  for ( ; nItems > 0; nItems--, psi2++ )
  {
    switch (psi2->shi2_type)
    {
      case STYPE_PRINTQ:    // Do not show print shares
      case STYPE_DEVICE:    // Do not show device shares
        continue;

      default:
        if (!IsInvalidSharename(psi2->shi2_netname))
        {
            pcookiearray->m_pobject = psi2;
            // WARNING cookie cast
            tRDItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pcookiearray);

            if (psi2->shi2_path &&
                lstrlen(psi2->shi2_path) == 3 &&
                *(psi2->shi2_path + 1) == _T(':') &&
                *(psi2->shi2_path + 2) == _T('\\') &&
                (*psi2->shi2_path >= _T('a') && *psi2->shi2_path <= _T('z') ||
                *psi2->shi2_path >= _T('A') && *psi2->shi2_path <= _T('Z')))
            {
                tRDItem.nImage = iIconSMBShare;
            } else
            {
                tRDItem.nImage = iIconSharesFolder;
            }

            HRESULT hr = pResultData->InsertItem(&tRDItem);
            ASSERT(SUCCEEDED(hr));
            pcookiearray++;
        }
        break;
    }
  }
  ASSERT( pcookiearray ==
    ((CSmbShareCookie*)(pCookieBlock->QueryBaseCookie(0)))+nItemsToAdd );

  return S_OK;
}


/*
NET_API_STATUS NET_API_FUNCTION
NetSessionEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  LPTSTR      UncClientName OPTIONAL,
    IN  LPTSTR      username OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );
*/

typedef DWORD (*SESSIONENUMPROC) (LPTSTR,LPTSTR,LPTSTR,DWORD,LPBYTE*,DWORD,LPDWORD,LPDWORD,LPDWORD);

//   if pResultData is not NULL, add sessions/resources to the listbox
//   if pResultData is NULL, delete all sessions/resources
//   if pResultData is NULL, return SUCCEEDED(hr) to continue or
//     FAILED(hr) to abort
HRESULT SmbFileServiceProvider::EnumerateSessions(
  IResultData* pResultData,
  CFileMgmtCookie* pcookie,
  bool bAddToResultPane)
{
  TEST_NONNULL_PTR_PARAM(pcookie);

  if ( !g_SmbDLL.LoadFunctionPointers() )
    return S_OK;

    SESSION_INFO_1* psi1 = NULL;
    DWORD dwEntriesRead = 0;
    DWORD dwTotalEntries = 0;
    DWORD hEnumHandle = 0;
    HRESULT hr = S_OK;
    NET_API_STATUS retval = NERR_Success;
    do {
        retval = ((SESSIONENUMPROC)g_SmbDLL[SMB_SESSION_ENUM])(
            const_cast<LPTSTR>(pcookie->QueryTargetServer()),
      NULL,
      NULL,
      1,
      (PBYTE*)&psi1,
      (DWORD)-1L,
      &dwEntriesRead,
      &dwTotalEntries,
      &hEnumHandle );
        if (NERR_Success == retval)
        {
            hr = HandleSMBSessionItems( pResultData, pcookie, psi1, dwEntriesRead, 
          bAddToResultPane );
            psi1 = NULL;
            break;
        } else if (ERROR_MORE_DATA == retval) {
            ASSERT( NULL != hEnumHandle );
            hr = HandleSMBSessionItems( pResultData, pcookie, psi1, dwEntriesRead, 
          bAddToResultPane );
            psi1 = NULL;
            continue;
        } else {
            if (ERROR_ACCESS_DENIED == retval)
            {
                (void) DoErrMsgBox(
                            GetActiveWindow(), 
                            MB_OK | MB_ICONSTOP, 
                            0,
                            IDS_POPUP_SMB_SESSIONS_NOACCESS
                            );
            } else
            {
                (void) DoErrMsgBox(
                            GetActiveWindow(), 
                            MB_OK | MB_ICONSTOP, 
                            retval, 
                            IDS_POPUP_SMB_SESSIONS
                            );
            }
            break;
        }
    } while (S_OK == hr);

    return HRESULT_FROM_WIN32(retval);
}


/*
typedef enum _COLNUM_SESSIONS {
  COLNUM_SESSIONS_USERNAME = 0,
  COLNUM_SESSIONS_COMPUTERNAME,
  COLNUM_SESSIONS_NUM_FILES,
  COLNUM_SESSIONS_CONNECTED_TIME,
  COLNUM_SESSIONS_IDLE_TIME,
  COLNUM_SESSIONS_IS_GUEST
} COLNUM_SESSIONS;

typedef struct _SESSION_INFO_1 {
    LPTSTR    sesi1_cname;              // client name (no backslashes)
    LPTSTR    sesi1_username;
    DWORD     sesi1_num_opens;
    DWORD     sesi1_time;
    DWORD     sesi1_idle_time;
    DWORD     sesi1_user_flags;
} SESSION_INFO_1, *PSESSION_INFO_1, *LPSESSION_INFO_1;

*/


//   if pResultData is not NULL, add sessions/resources to the listbox
//   if pResultData is NULL, delete all sessions/resources
//   if pResultData is NULL, return SUCCEEDED(hr) to continue or
//     FAILED(hr) to abort
HRESULT SmbFileServiceProvider::HandleSMBSessionItems(
    IResultData* pResultData,
    CFileMgmtCookie* pParentCookie,
    PVOID pinfo,
    DWORD nItems,
    BOOL bAddToResultPane)
{
  TEST_NONNULL_PTR_PARAM(pParentCookie);
  TEST_NONNULL_PTR_PARAM(pinfo);

  if (0 >= nItems)
    return S_OK;

  BOOL fDeleteAllItems = (NULL == pResultData);

    RESULTDATAITEM tRDItem;
  ::ZeroMemory( &tRDItem, sizeof(tRDItem) );
  // CODEWORK should use MMC_ICON_CALLBACK
  tRDItem.nImage = iIconSMBSession;
  tRDItem.nCol = COLNUM_SESSIONS_USERNAME;
  tRDItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
  tRDItem.str = MMC_CALLBACK;

  SESSION_INFO_1* psi1 = (SESSION_INFO_1*)pinfo;

  CSmbSessionCookie* pcookiearray = new CSmbSessionCookie[nItems];
  CSmbCookieBlock* pCookieBlock = new CSmbCookieBlock(
    pcookiearray,nItems,pParentCookie->QueryNonNULLMachineName(),pinfo );
  bool  bAdded = false;
  if ( !fDeleteAllItems || !bAddToResultPane )
  {
    pParentCookie->m_listResultCookieBlocks.AddHead( pCookieBlock );
    bAdded = true;
  }

  for ( ; nItems > 0; nItems--, psi1++, pcookiearray++ )
  {
    pcookiearray->m_pobject = psi1;

    if ( bAddToResultPane )
    {
      if (fDeleteAllItems)
      {
        DWORD dwApiResult = CloseSession( pcookiearray );
        if (0L != dwApiResult)
        {
            CString strName;
            TranslateIPToComputerName(psi1->sesi1_cname, strName);
          (void) DoErrMsgBox(GetActiveWindow(), MB_OK | MB_ICONSTOP, dwApiResult,
            IDS_POPUP_SMB_DISCONNECTALLSESSION_ERROR,
            strName );
          //return S_FALSE;
        }
        continue;
      }

      // WARNING cookie cast
      if (psi1->sesi1_username && *(psi1->sesi1_username)) // bug#3903: exclude NULL session
      {
          tRDItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pcookiearray);
          HRESULT hr = pResultData->InsertItem(&tRDItem);
          ASSERT(SUCCEEDED(hr));
      }
    }
  }

  if ( !bAdded ) // they were not added to the parent cookie's list
    delete pCookieBlock;

  return S_OK;
}


/*
NET_API_STATUS NET_API_FUNCTION
NetFileEnum (
    IN  LPTSTR      servername OPTIONAL,
    IN  LPTSTR      basepath OPTIONAL,
    IN  LPTSTR      username OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );

*/

typedef DWORD (*FILEENUMPROC) (LPTSTR,LPTSTR,LPTSTR,DWORD,LPBYTE*,DWORD,LPDWORD,LPDWORD,LPDWORD);

//   if pResultData is not NULL, add sessions/resources to the listbox
//   if pResultData is NULL, delete all sessions/resources
//   if pResultData is NULL, return SUCCEEDED(hr) to continue or
//     FAILED(hr) to abort
HRESULT SmbFileServiceProvider::EnumerateResources(
  IResultData* pResultData,
  CFileMgmtCookie* pcookie)
{
  TEST_NONNULL_PTR_PARAM(pcookie);

  if ( !g_SmbDLL.LoadFunctionPointers() )
    return S_OK;

    FILE_INFO_3* pfi3 = NULL;
    DWORD dwEntriesRead = 0;
    DWORD dwTotalEntries = 0;
    DWORD hEnumHandle = 0;
    HRESULT hr = S_OK;
    NET_API_STATUS retval = NERR_Success;
    do {
        retval = ((FILEENUMPROC)g_SmbDLL[SMB_FILE_ENUM])(
            const_cast<LPTSTR>(pcookie->QueryTargetServer()),
      NULL,
      NULL,
      3,
      (PBYTE*)&pfi3,
      (DWORD)-1L,
      &dwEntriesRead,
      &dwTotalEntries,
      &hEnumHandle );
        if (NERR_Success == retval)
        {
            hr = HandleSMBResourceItems( pResultData, pcookie, pfi3, dwEntriesRead );
            pfi3 = NULL;
            break;
        } else if (ERROR_MORE_DATA == retval) {
            ASSERT( NULL != hEnumHandle );
            hr = HandleSMBResourceItems( pResultData, pcookie, pfi3, dwEntriesRead );
            pfi3 = NULL;
            continue;
        } else {
            if (ERROR_ACCESS_DENIED == retval)
            {
                (void) DoErrMsgBox(
                            GetActiveWindow(), 
                            MB_OK | MB_ICONSTOP, 
                            0,
                            IDS_POPUP_SMB_RESOURCES_NOACCESS
                            );
            } else
            {
                (void) DoErrMsgBox(
                            GetActiveWindow(), 
                            MB_OK | MB_ICONSTOP, 
                            retval, 
                            IDS_POPUP_SMB_RESOURCES
                            );
            }
            break;
        }
    } while (S_OK == hr);

    return HRESULT_FROM_WIN32(retval);
}


/*
typedef enum _COLNUM_RESOURCES {
  COLNUM_RESOURCES_FILENAME = 0,
  COLNUM_RESOURCES_USERNAME,
  COLNUM_RESOURCES_NUM_LOCKS,  // we don't try to display sharename for now, since
                // only SMB has this information
  COLNUM_RESOURCES_OPEN_MODE
} COLNUM_RESOURCES;

typedef struct _FILE_INFO_3 {
    DWORD     fi3_id;
    DWORD     fi3_permissions;
    DWORD     fi3_num_locks;
    LPTSTR    fi3_pathname;
    LPTSTR    fi3_username;
} FILE_INFO_3, *PFILE_INFO_3, *LPFILE_INFO_3;
*/

//   if pResultData is not NULL, add sessions/resources to the listbox
//   if pResultData is NULL, delete all sessions/resources
//   if pResultData is NULL, return SUCCEEDED(hr) to continue or
//     FAILED(hr) to abort
HRESULT SmbFileServiceProvider::HandleSMBResourceItems(
    IResultData* pResultData,
    CFileMgmtCookie* pParentCookie,
    PVOID pinfo,
    DWORD nItems)
{
  TEST_NONNULL_PTR_PARAM(pParentCookie);
  TEST_NONNULL_PTR_PARAM(pinfo);

  if (0 >= nItems)
    return S_OK;

  BOOL fDeleteAllItems = (NULL == pResultData);

    RESULTDATAITEM tRDItem;
  ::ZeroMemory( &tRDItem, sizeof(tRDItem) );
  // CODEWORK should use MMC_ICON_CALLBACK
  tRDItem.nImage = iIconSMBResource;
  tRDItem.nCol = COLNUM_RESOURCES_FILENAME;
  tRDItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
  tRDItem.str = MMC_CALLBACK;

    FILE_INFO_3* pfi3 = (FILE_INFO_3*)pinfo;

  CSmbResourceCookie* pcookiearray = new CSmbResourceCookie[nItems];
  CSmbCookieBlock* pCookieBlock = new CSmbCookieBlock(
    pcookiearray,nItems,pParentCookie->QueryNonNULLMachineName(),pinfo );
  if (!fDeleteAllItems)
  {
    pParentCookie->m_listResultCookieBlocks.AddHead( pCookieBlock );
  }

  CString str;
    for ( ; nItems > 0; nItems--, pfi3++, pcookiearray++ )
    {
    pcookiearray->m_pobject = pfi3;

    if (fDeleteAllItems)
    {
      DWORD dwApiResult = CloseResource( pcookiearray );
      if (0L != dwApiResult)
      {
        (void) DoErrMsgBox(GetActiveWindow(), MB_OK | MB_ICONSTOP, dwApiResult,
          IDS_POPUP_SMB_DISCONNECTALLRESOURCE_ERROR,
          pfi3->fi3_pathname );
        return S_FALSE;
      }
      continue;
    }

    // WARNING cookie cast
    tRDItem.lParam = reinterpret_cast<LPARAM>((CCookie*)pcookiearray);
    HRESULT hr = pResultData->InsertItem(&tRDItem);
    ASSERT(SUCCEEDED(hr));
    }

  if (fDeleteAllItems) // they were not added to the parent cookie's list
    delete pCookieBlock;

  return S_OK;
}


/*
NET_API_STATUS NET_API_FUNCTION
NetShareDel     (
    IN  LPTSTR  servername,
    IN  LPTSTR  netname,
    IN  DWORD   reserved
    );
*/

typedef DWORD (*SHAREGETINFOPROC) (LPTSTR,LPTSTR,DWORD,LPBYTE*);
typedef DWORD (*SHAREDELPROC) (LPTSTR,LPTSTR,DWORD);

DWORD SmbFileServiceProvider::OpenShare( LPCTSTR lpcszServerName, LPCTSTR lpcszShareName )
{
    if ( !g_SmbDLL.LoadFunctionPointers() )
        return NERR_Success;

    BOOL bLocal = IsLocalComputername(lpcszServerName);

    PTSTR pszPath = NULL;
    SHARE_INFO_2 *pshi2 = NULL;
    if (bLocal)
    {
        NET_API_STATUS dwRet = ((SHAREGETINFOPROC)g_SmbDLL[SMB_SHARE_GET_INFO])(
                  const_cast<LPTSTR>(lpcszServerName),
                  const_cast<LPTSTR>(lpcszShareName),
                  2,
                  (LPBYTE*)&pshi2);

        if (NERR_Success != dwRet)
            return dwRet;

        pszPath = pshi2->shi2_path;
    } else
    {
        pszPath = (PTSTR)calloc(lstrlen(lpcszServerName) + lstrlen(lpcszShareName) + 4, sizeof(TCHAR));
        if (pszPath)
        {
            TCHAR *p = pszPath;

            if (_T('\\') != *lpcszServerName)
            {
                *p++ = _T('\\');
                *p++ = _T('\\');
            }
            lstrcpy(p, lpcszServerName);
            p += lstrlen(lpcszServerName);
            *p++ = _T('\\');
            lstrcpy(p, lpcszShareName);
        }
    }

    if (!pszPath || !*pszPath)
    {
        (void) DoErrMsgBox(GetActiveWindow(), MB_OK, 0, IDS_CANNOT_OPENSHARE, lpcszShareName);
    } else if (32 >= (INT_PTR) ShellExecute(
                                    NULL,        // Handle to window
                                    _T("explore"),    // Action to take
                                    pszPath,    // Folder to explore
                                    NULL,        // Parameters
                                    NULL,        // Default directory
                                    SW_SHOWNORMAL    // Show command
                                    ))
    {
        (void) DoErrMsgBox(GetActiveWindow(), MB_OK | MB_ICONSTOP, 0, IDS_MSG_EXPLORE_FAILURE, pszPath);

    }

    if (!bLocal && pszPath)
        free(pszPath);

    if (pshi2)
        FreeData(pshi2);

    return NERR_Success;
}

/*
NET_API_STATUS NET_API_FUNCTION
NetConnectionEnum (
    IN  LMSTR   servername OPTIONAL,
    IN  LMSTR   qualifier,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr,
    IN  DWORD   prefmaxlen,
    OUT LPDWORD entriesread,
    OUT LPDWORD totalentries,
    IN OUT LPDWORD resume_handle OPTIONAL
    );
*/

typedef DWORD (*CONNECTIONENUMPROC) (LPTSTR,LPTSTR,DWORD,LPBYTE *,DWORD,LPDWORD,LPDWORD,LPDWORD);

// S_OK:    user wants to continue
// S_FALSE: user wants to cancel the operation and keep the share
// E_FAIL:  share doesn't exist, needs to refresh
HRESULT SmbFileServiceProvider::ConfirmDeleteShare( LPCTSTR lpcszServerName, LPCTSTR lpcszShareName )
{
    if ( !g_SmbDLL.LoadFunctionPointers() )
        return E_FAIL;

    CONNECTION_INFO_1* pBuf = NULL;
    DWORD dwEntry = 0;
    DWORD dwTotal = 0;
    NET_API_STATUS dwRet = ((CONNECTIONENUMPROC)g_SmbDLL[SMB_CONNECTION_ENUM])(
                                    const_cast<LPTSTR>(lpcszServerName),
                                    const_cast<LPTSTR>(lpcszShareName),
                                    1,
                                    (LPBYTE*)&pBuf,
                                    (DWORD)-1, 
                                    &dwEntry,
                                    &dwTotal,
                                    NULL);

    if (NERR_NetNameNotFound == dwRet)
        return E_FAIL;

    if (NERR_Success != dwRet && ERROR_MORE_DATA != dwRet)
        return E_FAIL;

    UINT cConns = dwTotal;
    UINT cOpens = 0;
    for (DWORD i = 0; i < dwEntry; i++)
    {
        cOpens += pBuf[i].coni1_num_opens;
    }

    NetApiBufferFree(pBuf);

    if (cConns > 0)
    {
        if (cOpens > 0)
        {
            if (IDYES != DoErrMsgBox(
                            GetActiveWindow(),
                            MB_YESNO,
                            0,
                            IDS_s_CONFIRM_DELETESHARE_FILE,
                            cOpens,
                            cConns,
                            lpcszShareName))
            {
                return S_FALSE;
            }
        } else              // (cConns > 0)
        {
            if (IDYES != DoErrMsgBox(
                            GetActiveWindow(),
                            MB_YESNO,
                            0,
                            IDS_s_CONFIRM_DELETESHARE_CONN,
                            cConns,
                            lpcszShareName))
            {
                return S_FALSE;
            }
        }
    } else
    {
        if (IDYES != DoErrMsgBox(
                        GetActiveWindow(),
                        MB_YESNO,
                        0,
                        IDS_s_CONFIRM_DELETESHARE,
                        lpcszShareName))
        {
            return S_FALSE;
        }
    }

    return S_OK;
}

DWORD SmbFileServiceProvider::DeleteShare( LPCTSTR lpcszServerName, LPCTSTR lpcszShareName )
{
  if ( !g_SmbDLL.LoadFunctionPointers() )
    return S_OK;

  SHARE_INFO_2    *pshi2 = NULL;
  NET_API_STATUS  dwRet = NERR_Success;
  BOOL            bLocal = TRUE;

  bLocal = IsLocalComputername(lpcszServerName);

  if (bLocal)
  {
    dwRet = ((SHAREGETINFOPROC)g_SmbDLL[SMB_SHARE_GET_INFO])(
              const_cast<LPTSTR>(lpcszServerName),
              const_cast<LPTSTR>(lpcszShareName),
              2,
              (LPBYTE*)&pshi2);

    if (NERR_NetNameNotFound == dwRet)
        return NERR_Success;

    if (NERR_Success != dwRet)
      return dwRet;
  }

  dwRet = ((SHAREDELPROC)g_SmbDLL[SMB_SHARE_DEL])(
    const_cast<LPTSTR>(lpcszServerName),
    const_cast<LPTSTR>(lpcszShareName),
    0L );

  if (NERR_NetNameNotFound == dwRet)
      dwRet = NERR_Success;

  if (NERR_Success == dwRet)
  {
    IADsContainer *piADsContainer = m_pFileMgmtData->GetIADsContainer(); // no need to AddRef
    if (piADsContainer)
    {
        CString strCNName = _T("CN=");
        strCNName += lpcszShareName;
        (void)piADsContainer->Delete(_T("volume"), (LPTSTR)(LPCTSTR)strCNName);
    }
  }

  if (bLocal)
  {
    if (dwRet == NERR_Success)
    {
      SHChangeNotify(
          SHCNE_NETUNSHARE, 
          SHCNF_PATH | SHCNF_FLUSHNOWAIT ,
          pshi2->shi2_path,
          0);
    }

    FreeData( pshi2 );
  }

  return dwRet;
}

/*
NET_API_STATUS NET_API_FUNCTION
NetSessionDel (
    IN  LPTSTR      servername OPTIONAL,
    IN  LPTSTR      UncClientName,
    IN  LPTSTR      username
    );
*/

typedef DWORD (*SESSIONDELPROC) (LPTSTR,LPTSTR,LPTSTR);

BOOL BlockRemoteAdminSession(
    IN PCTSTR i_pszTargetServer,
    IN PCTSTR i_pszClientName,
    IN PCTSTR i_pszUserName,
    IN DWORD  i_dwNumOpenSessions
);

BOOL BlockRemoteAdminFile(
    IN PCTSTR i_pszTargetServer,
    IN PCTSTR i_pszPathName,
    IN PCTSTR i_pszUserName
);

DWORD SmbFileServiceProvider::CloseSession(CFileMgmtResultCookie* pcookie)
{
  if ( !g_SmbDLL.LoadFunctionPointers() )
    return S_OK;

  ASSERT( FILEMGMT_SESSION == pcookie->QueryObjectType() );
  SESSION_INFO_1* psi1 = (SESSION_INFO_1*)pcookie->m_pobject;
  ASSERT( NULL != psi1 &&
          NULL != psi1->sesi1_cname &&
          TEXT('\0') != *(psi1->sesi1_cname) );

  PCTSTR pszTargetServer = pcookie->QueryTargetServer();
  if (BlockRemoteAdminSession(pszTargetServer, psi1->sesi1_cname, psi1->sesi1_username, psi1->sesi1_num_opens))
    return NERR_Success;

  CString strCName = _T("\\\\");
  strCName += psi1->sesi1_cname;
  DWORD dwRetval = ((SESSIONDELPROC)g_SmbDLL[SMB_SESSION_DEL])(
    const_cast<LPTSTR>(pszTargetServer),
    const_cast<LPTSTR>((LPCTSTR)strCName),
    psi1->sesi1_username );
  return (NERR_NoSuchSession == dwRetval) ? NERR_Success : dwRetval;
}

/*
NET_API_STATUS NET_API_FUNCTION
NetFileClose (
    IN LPTSTR   servername OPTIONAL,
    IN DWORD    fileid
    );
*/

typedef DWORD (*FILECLOSEPROC) (LPTSTR,DWORD);

DWORD SmbFileServiceProvider::CloseResource(CFileMgmtResultCookie* pcookie)
{
  if ( !g_SmbDLL.LoadFunctionPointers() )
    return S_OK;

  ASSERT( FILEMGMT_RESOURCE == pcookie->QueryObjectType() );
  FILE_INFO_3* pfileinfo = (FILE_INFO_3*)pcookie->m_pobject;
  ASSERT( NULL != pfileinfo );

  PCTSTR pszTargetServer = pcookie->QueryTargetServer();
  if (BlockRemoteAdminFile(pszTargetServer, pfileinfo->fi3_pathname, pfileinfo->fi3_username))
    return NERR_Success;

  DWORD dwRetval = ((FILECLOSEPROC)g_SmbDLL[SMB_FILE_CLOSE])(
    const_cast<LPTSTR>(pszTargetServer),
    pfileinfo->fi3_id );
  return (NERR_FileIdNotFound == dwRetval) ? NERR_Success : dwRetval;
}

/*
NET_API_STATUS NET_API_FUNCTION
NetShareGetInfo (
    IN  LPTSTR  servername,
    IN  LPTSTR  netname,
    IN  DWORD   level,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetShareSetInfo (
    IN  LPTSTR  servername,
    IN  LPTSTR  netname,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    OUT LPDWORD parm_err
    );

typedef struct _SHARE_INFO_2 {
    LPTSTR  shi2_netname;
    DWORD   shi2_type;
    LPTSTR  shi2_remark;
    DWORD   shi2_permissions;
    DWORD   shi2_max_uses;
    DWORD   shi2_current_uses;
    LPTSTR  shi2_path;
    LPTSTR  shi2_passwd;
} SHARE_INFO_2, *PSHARE_INFO_2, *LPSHARE_INFO_2;
*/

typedef DWORD (*SHARESETINFOPROC) (LPTSTR,LPTSTR,DWORD,LPBYTE,LPDWORD);

VOID SmbFileServiceProvider::DisplayShareProperties(
    LPPROPERTYSHEETCALLBACK pCallBack,
    LPDATAOBJECT pDataObject,
    LONG_PTR handle)
{
  HRESULT hr = S_OK;
  CSharePageGeneralSMB * pPage = new CSharePageGeneralSMB();
  if ( !pPage->Load( m_pFileMgmtData, pDataObject ) )
    return;

  //
  // enforce the following calling order to work around MMC bug#464475:
  // m_psp.pfnCallback ==> my PropSheetPageProc ==> MMC callback ==> MFC callback
  //
  MMCPropPageCallback(INOUT &pPage->m_psp);

  // This mechanism deletes the CFileMgmtGeneral when the property sheet is finished
  pPage->m_pfnOriginalPropSheetPageProc = pPage->m_psp.pfnCallback;
  pPage->m_psp.lParam = reinterpret_cast<LPARAM>(pPage);
  pPage->m_psp.pfnCallback = &CSharePageGeneralSMB::PropSheetPageProc;
  pPage->m_handle = handle;

  HPROPSHEETPAGE hPage=MyCreatePropertySheetPage(&pPage->m_psp);
  pCallBack->AddPage(hPage);

  if (pPage->m_dwShareType & (STYPE_IPC | STYPE_SPECIAL))
  {
    (void) DoErrMsgBox(GetActiveWindow(), MB_OK | MB_ICONINFORMATION, 0, IDS_s_POPUP_ADMIN_SHARE);
    return;
  }
  
  //
  // display the "Publish" page
  //
  if (m_pFileMgmtData->GetSchemaSupportSharePublishing() && CheckPolicyOnSharePublish(pPage->m_strShareName))
  {
      CSharePagePublish * pPagePublish = new CSharePagePublish();
      if ( !pPagePublish->Load( m_pFileMgmtData, pDataObject ) )
        return;

      //
      // enforce the following calling order to work around MMC bug#464475:
      // m_psp.pfnCallback ==> my PropSheetPageProc ==> MMC callback ==> MFC callback
      //
      MMCPropPageCallback(INOUT &pPagePublish->m_psp);

      // This mechanism deletes the pPagePublish when the property sheet is finished
      pPagePublish->m_pfnOriginalPropSheetPageProc = pPagePublish->m_psp.pfnCallback;
      pPagePublish->m_psp.lParam = reinterpret_cast<LPARAM>(pPagePublish);
      pPagePublish->m_psp.pfnCallback = &CSharePagePublish::PropSheetPageProc;
      pPagePublish->m_handle = handle;

      HPROPSHEETPAGE hPagePublish=MyCreatePropertySheetPage(&pPagePublish->m_psp);
      pCallBack->AddPage(hPagePublish);
  }

  //
  // display the "Share Security" page
  //
  CComObject<CSMBSecurityInformation>* psecinfo = NULL;
  hr = CComObject<CSMBSecurityInformation>::CreateInstance(&psecinfo);
  if ( SUCCEEDED(hr) )
    MyCreateShareSecurityPage(
      pCallBack,
      psecinfo,
      pPage->m_strMachineName,
      pPage->m_strShareName );

  CreateFolderSecurityPropPage(pCallBack, pDataObject);

}

DWORD SmbFileServiceProvider::ReadShareType(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    OUT DWORD* pdwShareType)
{
  if ( !g_SmbDLL.LoadFunctionPointers() )
  {
    ASSERT(FALSE);
    return S_OK;
  }
  *pdwShareType = 0;

  SHARE_INFO_2* psi2 = NULL;
  NET_API_STATUS retval = ((SHAREGETINFOPROC)g_SmbDLL[SMB_SHARE_GET_INFO])(
    const_cast<LPTSTR>(ptchServerName),
    const_cast<LPTSTR>(ptchShareName),
    2,
    (LPBYTE*)&psi2);
  if (NERR_Success != retval)
    return retval;

  ASSERT( NULL != psi2 );
  *pdwShareType = psi2->shi2_type;

  FreeData(psi2);

  return NERR_Success;
}

DWORD SmbFileServiceProvider::ReadShareProperties(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    OUT PVOID* ppvPropertyBlock,
    OUT CString& strDescription,
    OUT CString& strPath,
    OUT BOOL* pfEditDescription,
    OUT BOOL* pfEditPath,
    OUT DWORD* pdwShareType)
{
  if ( !g_SmbDLL.LoadFunctionPointers() )
  {
    ASSERT(FALSE);
    return S_OK;
  }

  if (ppvPropertyBlock)     *ppvPropertyBlock = NULL;
  if (pdwShareType)         *pdwShareType = 0;
  if (pfEditDescription)    *pfEditDescription = TRUE;
  if (pfEditPath)           *pfEditPath = FALSE;

  SHARE_INFO_2* psi2 = NULL;
  NET_API_STATUS retval = ((SHAREGETINFOPROC)g_SmbDLL[SMB_SHARE_GET_INFO])(
                                                                    const_cast<LPTSTR>(ptchServerName),
                                                                    const_cast<LPTSTR>(ptchShareName),
                                                                    2,
                                                                    (LPBYTE*)&psi2);
  if (NERR_Success != retval)
    return retval;

  strDescription = psi2->shi2_remark;
  strPath = psi2->shi2_path;

  if (pdwShareType)
      *pdwShareType = psi2->shi2_type;

  if (ppvPropertyBlock)
  {
      *ppvPropertyBlock = psi2;  // will be freed by the caller
  } else
  {
      FreeData((LPVOID)psi2);
  }

  return NERR_Success;
}

DWORD SmbFileServiceProvider::WriteShareProperties(
    OUT LPCTSTR ptchServerName,
    OUT LPCTSTR ptchShareName,
    OUT PVOID pvPropertyBlock,
    OUT LPCTSTR ptchDescription,
    OUT LPCTSTR ptchPath)
{
  ASSERT( NULL != pvPropertyBlock );
  if ( !g_SmbDLL.LoadFunctionPointers() )
    return S_OK;

  SHARE_INFO_2* psi2 = (SHARE_INFO_2*)pvPropertyBlock;
  //
  // CODEWORK Note that this leaves psi2 invalid after the call, but that any subsequent
  // use will replace these pointers.
  //
  psi2->shi2_remark = const_cast<LPTSTR>(ptchDescription);
  psi2->shi2_path = const_cast<LPTSTR>(ptchPath);
  DWORD dwDummy;
  DWORD retval = ((SHARESETINFOPROC)g_SmbDLL[SMB_SHARE_SET_INFO])(
    const_cast<LPTSTR>(ptchServerName),
    const_cast<LPTSTR>(ptchShareName),
    2,
    (LPBYTE)psi2,
    &dwDummy);
  psi2->shi2_remark = NULL;
  psi2->shi2_path = NULL;
  return retval;
}

HRESULT TranslateManagedBy(
    IN  PCTSTR              i_pszDCName,
    IN  PCTSTR              i_pszIn,
    OUT CString&            o_strOut,
    IN ADS_NAME_TYPE_ENUM   i_formatIn,
    IN ADS_NAME_TYPE_ENUM   i_formatOut
    )
{
    o_strOut.Empty();

    HRESULT hr = S_OK;
    if (!i_pszIn || !*i_pszIn)
        return hr;

    CComPtr<IADsNameTranslate> spiADsNameTranslate;
    hr = CoCreateInstance(CLSID_NameTranslate, NULL, CLSCTX_INPROC_SERVER, IID_IADsNameTranslate, (void **)&spiADsNameTranslate);
    if (FAILED(hr)) return hr;

    hr = spiADsNameTranslate->Init(ADS_NAME_INITTYPE_SERVER, (LPTSTR)i_pszDCName);
    if (FAILED(hr)) return hr;

    hr = spiADsNameTranslate->Set(i_formatIn, (LPTSTR)i_pszIn);
    if (FAILED(hr)) return hr;

    CComBSTR sbstr;
    hr = spiADsNameTranslate->Get(i_formatOut, &sbstr);

    if (SUCCEEDED(hr))
        o_strOut = (BSTR)sbstr;

    return hr;
}

HRESULT SmbFileServiceProvider::ReadSharePublishInfo(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    OUT BOOL* pbPublish,
    OUT CString& strUNCPath,
    OUT CString& strDescription,
    OUT CString& strKeywords,
    OUT CString& strManagedBy)
{
    HRESULT hr = S_OK;

    do {
        CString strADsPath, strDCName;
        hr = GetADsPathOfComputerObject(ptchServerName, strADsPath, strDCName);
        if (S_OK != hr) break;

        CComPtr<IADsContainer> spiADsContainer;
        hr = ADsGetObject(strADsPath, IID_IADsContainer, (void**)&spiADsContainer);
        if (FAILED(hr)) break;

        CString strCNName = _T("CN=");
        strCNName += ptchShareName;

        CComPtr<IDispatch> spiDispatch;
        hr = spiADsContainer->GetObject(_T("volume"), (LPTSTR)(LPCTSTR)strCNName, &spiDispatch);
        if (HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT) == hr)
        {
            hr = S_OK;
            *pbPublish = FALSE;
            break;
        }
        if (FAILED(hr)) break;

        *pbPublish = TRUE;

        CComPtr<IADs> spiADs;
        hr = spiDispatch->QueryInterface(IID_IADs, (void**)&spiADs);
        if (FAILED(hr)) break;

        VARIANT var;
        VariantInit(&var);
 
        hr = spiADs->Get(_T("uNCName"), &var);
        if (FAILED(hr)) break;
        strUNCPath = V_BSTR(&var);
        VariantClear(&var);

        hr = spiADs->Get(_T("description"), &var);
        if (SUCCEEDED(hr))
        {
            hr = GetSingleOrMultiValuesFromVarArray(&var, strDescription);
            VariantClear(&var);
        } else if (E_ADS_PROPERTY_NOT_FOUND == hr)
            hr = S_OK;
        else
            break;

        hr = spiADs->Get(_T("keywords"), &var);
        if (SUCCEEDED(hr))
        {
            hr = GetSingleOrMultiValuesFromVarArray(&var, strKeywords);
            VariantClear(&var);
        } else if (E_ADS_PROPERTY_NOT_FOUND == hr)
            hr = S_OK;
        else
            break;

        hr = spiADs->Get(_T("managedBy"), &var);
        if (SUCCEEDED(hr))
        {
            // 1st, try map to a UPN user@xyz.com
            hr = TranslateManagedBy(strDCName,
                                    V_BSTR(&var),
                                    strManagedBy,
                                    ADS_NAME_TYPE_1779,
                                    ADS_NAME_TYPE_USER_PRINCIPAL_NAME);

            // in case no UPN, map to NT4 style domain\user
            if (FAILED(hr))
                hr = TranslateManagedBy(strDCName,
                                        V_BSTR(&var),
                                        strManagedBy,
                                        ADS_NAME_TYPE_1779,
                                        ADS_NAME_TYPE_NT4);
            VariantClear(&var);
        } else if (E_ADS_PROPERTY_NOT_FOUND == hr)
            hr = S_OK;
        else
            break;

    } while (0);

    return hr;
}

HRESULT SmbFileServiceProvider::WriteSharePublishInfo(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    IN BOOL bPublish,
    LPCTSTR ptchDescription,
    LPCTSTR ptchKeywords,
    LPCTSTR ptchManagedBy)
{
    HRESULT hr = S_OK;

    do {
        CString strADsPath, strDCName;
        hr = GetADsPathOfComputerObject(ptchServerName, strADsPath, strDCName);
        if (S_OK != hr) break;

        CComPtr<IADsContainer> spiADsContainer;
        hr = ADsGetObject(strADsPath, IID_IADsContainer, (void**)&spiADsContainer);
        if (FAILED(hr)) break;

        CString strCNName = _T("CN=");
        strCNName += ptchShareName;

        if (!bPublish)
        {
            hr = spiADsContainer->Delete(_T("volume"), (LPTSTR)(LPCTSTR)strCNName);
            if (HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT) == hr)
                hr = S_OK;
            break;
        }

        BOOL bNewObject = FALSE;
        CComPtr<IDispatch> spiDispatch;
        hr = spiADsContainer->GetObject(_T("volume"), (LPTSTR)(LPCTSTR)strCNName, &spiDispatch);
        if (HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT) == hr)
        {
            hr = spiADsContainer->Create(_T("volume"), (LPTSTR)(LPCTSTR)strCNName, &spiDispatch);
            bNewObject = TRUE;
        }
        if (FAILED(hr)) break;

        CComPtr<IADs> spiADs;
        hr = spiDispatch->QueryInterface(IID_IADs, (void**)&spiADs);
        if (FAILED(hr)) break;

        VARIANT var;
        VariantInit(&var);

        if (bNewObject)
        {
            CString strUNCName;
            if (!_tcsncmp(ptchServerName, _T("\\\\"), 2))
            {
                strUNCName = ptchServerName;
            } else
            {
                strUNCName = _T("\\\\");
                strUNCName += ptchServerName;
            }
            strUNCName += _T("\\");
            strUNCName += ptchShareName;

            V_BSTR(&var) = SysAllocString(strUNCName);
            V_VT(&var) = VT_BSTR;

            hr = spiADs->Put(_T("uNCName"), var);
            VariantClear(&var);
            if (FAILED(hr)) break;
        }

        // according to schema, description is multi valued.
        // but we're treating it as single value 
        if (ptchDescription && *ptchDescription)
        {
            V_BSTR(&var) = SysAllocString(ptchDescription);
            V_VT(&var) = VT_BSTR;
            hr = spiADs->Put(_T("description"), var);
            VariantClear(&var);
        } else if (!bNewObject)
        {
            V_VT(&var)=VT_NULL;
            hr = spiADs->PutEx(ADS_PROPERTY_CLEAR, _T("description"), var);
            VariantClear(&var);
        }

        if (FAILED(hr)) break;

        if (ptchKeywords && *ptchKeywords)
        {
            hr = PutMultiValuesIntoVarArray(ptchKeywords, &var);

            if (SUCCEEDED(hr))
            {
                hr = spiADs->Put(_T("keywords"), var);
                VariantClear(&var);
            }
        } else if (!bNewObject)
        {
            V_VT(&var)=VT_NULL;
            hr = spiADs->PutEx(ADS_PROPERTY_CLEAR, _T("keywords"), var);
            VariantClear(&var);
        }

        if (FAILED(hr)) break;

        if (ptchManagedBy && *ptchManagedBy)
        {
            CString strManagedByFQDN;
            hr = TranslateManagedBy(strDCName,
                                    ptchManagedBy,
                                    strManagedByFQDN,
                                    (_tcschr(ptchManagedBy, _T('@')) ? ADS_NAME_TYPE_USER_PRINCIPAL_NAME : ADS_NAME_TYPE_NT4),
                                    ADS_NAME_TYPE_1779);
            if (SUCCEEDED(hr))
            {
                V_BSTR(&var) = SysAllocString(strManagedByFQDN);
                V_VT(&var) = VT_BSTR;
                hr = spiADs->Put(_T("managedBy"), var);
                VariantClear(&var);
            }
        } else if (!bNewObject)
        {
            V_VT(&var)=VT_NULL;
            hr = spiADs->PutEx(ADS_PROPERTY_CLEAR, _T("managedBy"), var);
            VariantClear(&var);
        }

        if (FAILED(hr)) break;

        hr = spiADs->SetInfo(); // commit

    } while (0);

    return hr;
}

//
// These methods cover the seperate API to determine whether IntelliMirror
// caching is enabled.  By default, SFM they are disabled.
//
// We read this data at level 501 in order to determine whether the target
// server is NT4.  NetShareGetInfo[1005] actually succeeds on an NT4 server,
// whereas NetShareGetInfo[501] fails with ERROR_INVALID_LEVEL.  We want this
// to fail so that we can disable the checkbox where the underlying
// functionality is not supported.
//
DWORD SmbFileServiceProvider::ReadShareFlags(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    DWORD* pdwFlags )
{
  ASSERT( NULL != pdwFlags );

  if ( !g_SmbDLL.LoadFunctionPointers() )
  {
    ASSERT(FALSE);
    return S_OK;
  }

  *pdwFlags = 0;
  SHARE_INFO_501* pshi501 = NULL;
  NET_API_STATUS retval = ((SHAREGETINFOPROC)g_SmbDLL[SMB_SHARE_GET_INFO])(
    const_cast<LPTSTR>(ptchServerName),
    const_cast<LPTSTR>(ptchShareName),
    501,
    (LPBYTE*)&pshi501);
  if (NERR_Success != retval)
    return retval;
    ASSERT( NULL != pshi501 );
  *pdwFlags = pshi501->shi501_flags;
    FreeData( pshi501 );

  return NERR_Success;
}

DWORD SmbFileServiceProvider::WriteShareFlags(
    LPCTSTR ptchServerName,
    LPCTSTR ptchShareName,
    DWORD dwFlags )
{
  if ( !g_SmbDLL.LoadFunctionPointers() )
    return S_OK;

  SHARE_INFO_1005 shi1005;
  ZeroMemory( &shi1005, sizeof(shi1005) );
  shi1005.shi1005_flags = dwFlags;
  DWORD dwDummy;
  DWORD retval = ((SHARESETINFOPROC)g_SmbDLL[SMB_SHARE_SET_INFO])(
    const_cast<LPTSTR>(ptchServerName),
    const_cast<LPTSTR>(ptchShareName),
    1005,
    (LPBYTE)&shi1005,
    &dwDummy);
  return retval;
}

BOOL SmbFileServiceProvider::GetCachedFlag( DWORD dwFlags, DWORD dwFlagToCheck )
{
    return (dwFlags & CSC_MASK) == dwFlagToCheck;
}

VOID SmbFileServiceProvider::SetCachedFlag( DWORD* pdwFlags, DWORD dwNewFlag )
{
    *pdwFlags &= ~CSC_MASK;

  *pdwFlags |= dwNewFlag;
}

VOID SmbFileServiceProvider::FreeShareProperties(PVOID pvPropertyBlock)
{
  FreeData( pvPropertyBlock );
}

DWORD SmbFileServiceProvider::QueryMaxUsers(PVOID pvPropertyBlock)
{
  SHARE_INFO_2* psi2 = (SHARE_INFO_2*)pvPropertyBlock;
  ASSERT( NULL != psi2 );
  return psi2->shi2_max_uses;
}

VOID SmbFileServiceProvider::SetMaxUsers(PVOID pvPropertyBlock, DWORD dwMaxUsers)
{
  SHARE_INFO_2* psi2 = (SHARE_INFO_2*)pvPropertyBlock;
  ASSERT( NULL != psi2 );
  psi2->shi2_max_uses = dwMaxUsers;
}

VOID SmbFileServiceProvider::FreeData(PVOID pv)
{
  SMBFreeData( &pv );
}

LPCTSTR SmbFileServiceProvider::QueryTransportString()
{
  return m_strTransportSMB;
}

CSmbCookieBlock::~CSmbCookieBlock()
{
  SMBFreeData( &m_pvCookieData );
}

DEFINE_COOKIE_BLOCK(CSmbCookie)
DEFINE_FORWARDS_MACHINE_NAME( CSmbCookie, m_pCookieBlock )

void CSmbCookie::AddRefCookie() { m_pCookieBlock->AddRef(); }
void CSmbCookie::ReleaseCookie() { m_pCookieBlock->Release(); }

HRESULT CSmbCookie::GetTransport( FILEMGMT_TRANSPORT* pTransport )
{
  *pTransport = FILEMGMT_SMB;
  return S_OK;
}

HRESULT CSmbShareCookie::GetShareName( CString& strShareName )
{
  SHARE_INFO_2* psi2 = (SHARE_INFO_2*)m_pobject;
  ASSERT( NULL != psi2 );
  strShareName = psi2->shi2_netname;
  return S_OK;
}

HRESULT CSmbShareCookie::GetExplorerViewDescription(
    OUT CString& strExplorerViewDescription )
{
  strExplorerViewDescription = GetShareInfo()->shi2_remark;
  return S_OK;
}

HRESULT
CSmbShareCookie::GetSharePIDList( OUT LPITEMIDLIST *ppidl )
{
  ASSERT(ppidl);
  ASSERT(NULL == *ppidl);  // prevent memory leak
  *ppidl = NULL;

  SHARE_INFO_2* psi2 = (SHARE_INFO_2*)m_pobject;
  ASSERT( NULL != psi2 );

  PCTSTR pszTargetServer = m_pCookieBlock->QueryTargetServer();
  CString csPath;

  if (pszTargetServer)
  {
    if ( _tcslen(pszTargetServer) >= 2 &&
         _T('\\') == *pszTargetServer &&
         _T('\\') == *(pszTargetServer + 1) )
    {
      csPath = pszTargetServer;
    } else
    {
      csPath = _T("\\\\");
      csPath += pszTargetServer;
    }
    csPath += _T("\\");
    csPath += psi2->shi2_netname;
  } else
  {
    csPath = psi2->shi2_path;
  }

  if (FALSE == csPath.IsEmpty())
    *ppidl = ILCreateFromPath(csPath);

  return ((*ppidl) ? S_OK : E_FAIL);
}

HRESULT CSmbSessionCookie::GetSessionClientName( CString& strName )
{
  SESSION_INFO_1* psi1 = (SESSION_INFO_1*)m_pobject;
  ASSERT( NULL != psi1 );
  TranslateIPToComputerName(psi1->sesi1_cname, strName);
  return S_OK;
}

HRESULT CSmbSessionCookie::GetSessionUserName( CString& strShareName )
{
  SESSION_INFO_1* psi1 = (SESSION_INFO_1*)m_pobject;
  ASSERT( NULL != psi1 );
  strShareName = psi1->sesi1_username;
  return S_OK;
}

HRESULT CSmbResourceCookie::GetFileID( DWORD* pdwFileID )
{
  FILE_INFO_3* pfileinfo = (FILE_INFO_3*)m_pobject;
  ASSERT( NULL != pdwFileID && NULL != pfileinfo );
  *pdwFileID = pfileinfo->fi3_id;
  return S_OK;
}

BSTR CSmbShareCookie::GetColumnText( int nCol )
{
  switch (nCol)
  {
  case COLNUM_SHARES_SHARED_FOLDER:
    return GetShareInfo()->shi2_netname;
  case COLNUM_SHARES_SHARED_PATH:
    return GetShareInfo()->shi2_path;
  case COLNUM_SHARES_TRANSPORT:
    return const_cast<BSTR>((LPCTSTR)g_strTransportSMB);
  case COLNUM_SHARES_COMMENT:
    return GetShareInfo()->shi2_remark;
  default:
    ASSERT(FALSE);
    break;
  }
  return L"";
}

BSTR CSmbShareCookie::QueryResultColumnText( int nCol, CFileMgmtComponentData& /*refcdata*/ )
{
  if (COLNUM_SHARES_NUM_SESSIONS == nCol)
    return MakeDwordResult( GetNumOfCurrentUses() );

  return GetColumnText(nCol);
}

extern CString g_cstrClientName;
extern CString g_cstrGuest;
extern CString g_cstrYes;
extern CString g_cstrNo;

BSTR CSmbSessionCookie::GetColumnText( int nCol )
{
  switch (nCol)
  {
  case COLNUM_SESSIONS_USERNAME:
    if ( (GetSessionInfo()->sesi1_user_flags & SESS_GUEST) &&
         ( !(GetSessionInfo()->sesi1_username) ||
           _T('\0') == *(GetSessionInfo()->sesi1_username) ) )
    {
      return const_cast<BSTR>(((LPCTSTR)g_cstrGuest));
    } else
    {
      return GetSessionInfo()->sesi1_username;
    }
  case COLNUM_SESSIONS_COMPUTERNAME:
      {
          TranslateIPToComputerName(GetSessionInfo()->sesi1_cname, g_cstrClientName);
          return const_cast<BSTR>(((LPCTSTR)g_cstrClientName));
      }
  case COLNUM_SESSIONS_TRANSPORT:
    return const_cast<BSTR>((LPCTSTR)g_strTransportSMB);
  case COLNUM_SESSIONS_IS_GUEST:
    if (GetSessionInfo()->sesi1_user_flags & SESS_GUEST)
      return const_cast<BSTR>(((LPCTSTR)g_cstrYes));
    else
      return const_cast<BSTR>(((LPCTSTR)g_cstrNo));

  default:
    ASSERT(FALSE);
    break;
  }
  return L"";
}

BSTR CSmbSessionCookie::QueryResultColumnText( int nCol, CFileMgmtComponentData& /*refcdata*/ )
{
  switch (nCol)
  {
  case COLNUM_SESSIONS_NUM_FILES:
    return MakeDwordResult( GetNumOfOpenFiles() );
  case COLNUM_SESSIONS_CONNECTED_TIME:
    return MakeElapsedTimeResult( GetConnectedTime() );
  case COLNUM_SESSIONS_IDLE_TIME:
    return MakeElapsedTimeResult( GetIdleTime() );
  default:
    break;
  }

  return GetColumnText(nCol);
}

BSTR CSmbResourceCookie::GetColumnText( int nCol )
{
  switch (nCol)
  {
  case COLNUM_RESOURCES_FILENAME:
    return GetFileInfo()->fi3_pathname;
  case COLNUM_RESOURCES_USERNAME:
    return GetFileInfo()->fi3_username;
  case COLNUM_RESOURCES_TRANSPORT:
    return const_cast<BSTR>((LPCTSTR)g_strTransportSMB);
  case COLNUM_RESOURCES_OPEN_MODE:
    return MakePermissionsResult( GetFileInfo()->fi3_permissions );
  default:
    ASSERT(FALSE);
    break;
  }

  return L"";
}

BSTR CSmbResourceCookie::QueryResultColumnText( int nCol, CFileMgmtComponentData& /*refcdata*/ )
{
  if (COLNUM_RESOURCES_NUM_LOCKS == nCol)
    return MakeDwordResult( GetNumOfLocks() );

  return GetColumnText(nCol);
}

CSMBSecurityInformation::CSMBSecurityInformation()
: m_pvolumeinfo( NULL ),
  m_pDefaultDescriptor( NULL )
{
}

CSMBSecurityInformation::~CSMBSecurityInformation()
{
  if (NULL != m_pDefaultDescriptor)
  {
    LocalFree(m_pDefaultDescriptor);
    m_pvolumeinfo->shi502_security_descriptor = NULL;
  }
  SMBFreeData( (PVOID*)&m_pvolumeinfo );
}

STDMETHODIMP CSMBSecurityInformation::GetSecurity (
                        SECURITY_INFORMATION RequestedInformation,
                        PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
                        BOOL fDefault )
{
  MFC_TRY;

  // NOTE: we allow NULL == ppSecurityDescriptor, see SetSecurity
    if (0 == RequestedInformation )
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    if (fDefault)
        return E_NOTIMPL;

  if ( NULL != ppSecurityDescriptor )
    *ppSecurityDescriptor = NULL;

  if ( !g_SmbDLL.LoadFunctionPointers() )
  {
    ASSERT(FALSE); // NETAPI32 isn't installed?
    return S_OK;
  }

  SMBFreeData( (PVOID*)&m_pvolumeinfo );
    NET_API_STATUS dwErr = ((SHAREGETINFOPROC)g_SmbDLL[SMB_SHARE_GET_INFO])(
    QueryMachineName(),
    QueryShareName(),
    502,
    (LPBYTE*)&m_pvolumeinfo );
  if (NERR_Success != dwErr)
  {
    return HRESULT_FROM_WIN32(dwErr);
  }
  ASSERT(NULL != m_pvolumeinfo);

  if ( NULL == ppSecurityDescriptor )
    return S_OK;

  if (NULL == m_pvolumeinfo->shi502_security_descriptor)
  {
    if (NULL == m_pDefaultDescriptor)
    {
      HRESULT hr = NewDefaultDescriptor(
        &m_pDefaultDescriptor,
        RequestedInformation );
      if ( !SUCCEEDED(hr) )
        return hr;
    }
    m_pvolumeinfo->shi502_security_descriptor = m_pDefaultDescriptor;
  }
  ASSERT( NULL != m_pvolumeinfo->shi502_security_descriptor );

  // We have to pass back a LocalAlloc'ed copy of the SD
  return MakeSelfRelativeCopy(
    m_pvolumeinfo->shi502_security_descriptor,
    ppSecurityDescriptor );

  MFC_CATCH;
}

STDMETHODIMP CSMBSecurityInformation::SetSecurity (
                        SECURITY_INFORMATION SecurityInformation,
                        PSECURITY_DESCRIPTOR pSecurityDescriptor )
{
  MFC_TRY;

  if ( !g_SmbDLL.LoadFunctionPointers() )
  {
    ASSERT(FALSE); // NETAPI32 isn't installed?
    return S_OK;
  }

  // First get the current settings
  // We call GetSecurity with NULL == ppSecurityDescriptor, this indicates to
  // GetSecurity that it should refresh the shi502 structure but not return
  // a copy of an actual security descriptor.
  HRESULT hr = GetSecurity( SecurityInformation, NULL, FALSE );
  if ( FAILED(hr) )
    return hr;

  // Now set the new values
  m_pvolumeinfo->shi502_security_descriptor = pSecurityDescriptor;
    NET_API_STATUS dwErr = ((SHARESETINFOPROC)g_SmbDLL[SMB_SHARE_SET_INFO])(
    QueryMachineName(),
    QueryShareName(),
    502,
    (LPBYTE)m_pvolumeinfo,
    NULL );
  if (NERR_Success != dwErr)
  {
    return HRESULT_FROM_WIN32(dwErr);
  }

    return S_OK;

  MFC_CATCH;
}


//
// helper functions
//
HRESULT GetDCInfo(
    IN LPCTSTR ptchServerName,
    OUT CString& strDCName
    )
/*
  Function: retrieve DC name of the domain the server belongs to.

  Return:
        S_OK:   if succeeded
        others: if server does not belong to a domain, or error occurred
*/
{
    strDCName.Empty();

    //
    // get domain name of the server
    //
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pBuffer = NULL;
    DWORD dwErr = DsRoleGetPrimaryDomainInformation(
                        ptchServerName,
                        DsRolePrimaryDomainInfoBasic,
                        (PBYTE *)&pBuffer);
    if (ERROR_SUCCESS != dwErr)
        return HRESULT_FROM_WIN32(dwErr);

    if (pBuffer->MachineRole == DsRole_RoleStandaloneWorkstation ||
        pBuffer->MachineRole == DsRole_RoleStandaloneServer)
    {
        DsRoleFreeMemory(pBuffer);
        return S_FALSE; // server does not belong to a domain
    }

    CString strDomainName = (pBuffer->DomainNameDns ? pBuffer->DomainNameDns : pBuffer->DomainNameFlat);

    DsRoleFreeMemory(pBuffer);

    if (!strDomainName)
        return E_OUTOFMEMORY;
            
    if (strDomainName.IsEmpty())
        return S_FALSE; // something is wrong, treat it as server does not belong to a domain

    //
    // In case the DNS name is in absolute form, remove the ending dot
    //
    int nlen = strDomainName.GetLength();
    if ( _T('.') == strDomainName[nlen - 1] )
        strDomainName.SetAt(nlen - 1, _T('\0'));

    //
    // get DC name of that domain
    //
    PDOMAIN_CONTROLLER_INFO    pDCInfo = NULL;
    dwErr = DsGetDcName(
                        NULL,   // Run on Current Server.
                        strDomainName,
                        NULL,
                        NULL,
                        DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME,
                        &pDCInfo
                        );
    if (ERROR_SUCCESS != dwErr)
        return HRESULT_FROM_WIN32(dwErr);

    if ( _T('\\') == *(pDCInfo->DomainControllerName) )
        strDCName = pDCInfo->DomainControllerName + 2;
    else
        strDCName = pDCInfo->DomainControllerName;

    NetApiBufferFree(pDCInfo);

    if (!strDCName)
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT GetADsPathOfComputerObject(
    IN LPCTSTR ptchServerName,
    OUT CString& strADsPath,
    OUT CString& strDCName
    )
/*
  Function: retrieve LDAP://<DC>/<FQDN of computer object>.

  Return:
        S_OK:   if succeeded
        others: if server does not belong to a domain, or error occurred
*/
{
    //
    // Get NT4 account name for this server
    //
    PWKSTA_INFO_100   wki100 = NULL;
    NET_API_STATUS    NetStatus = NetWkstaGetInfo((LPTSTR)ptchServerName, 100, (LPBYTE *)&wki100 );
    if (ERROR_SUCCESS != NetStatus) 
        return HRESULT_FROM_WIN32(NetStatus);

    HRESULT hr = S_FALSE;
    CString strNT4Name;
    if (wki100->wki100_langroup)
    {
        strNT4Name = wki100->wki100_langroup;
        strNT4Name += _T("\\");
        strNT4Name += wki100->wki100_computername;
        strNT4Name += _T("$");
        hr = S_OK;
    }

    NetApiBufferFree((LPBYTE)wki100);

    if (S_OK != hr)
        return hr;

    //
    // get DC name of the server's domain
    //
    hr = GetDCInfo(ptchServerName, strDCName);
    if (S_OK != hr)
        return hr;

    //
    // get computerDN
    //
    CComPtr<IADsNameTranslate> spiADsNameTranslate;
    hr = CoCreateInstance(CLSID_NameTranslate, NULL, CLSCTX_INPROC_SERVER, IID_IADsNameTranslate, (void **)&spiADsNameTranslate);
    if (FAILED(hr)) return hr;

    hr = spiADsNameTranslate->Init(ADS_NAME_INITTYPE_SERVER, (LPTSTR)(LPCTSTR)strDCName);
    if (FAILED(hr)) return hr;

    hr = spiADsNameTranslate->Set(ADS_NAME_TYPE_NT4, (LPTSTR)(LPCTSTR)strNT4Name);
    if (FAILED(hr)) return hr;

    CComBSTR sbstrComputerDN;
    hr = spiADsNameTranslate->Get(ADS_NAME_TYPE_1779, &sbstrComputerDN);
    if (FAILED(hr)) return hr;
    
    strADsPath = _T("LDAP://");
    strADsPath += strDCName;
    strADsPath += _T("/");
    strADsPath += sbstrComputerDN;

    return hr;
}

HRESULT CheckSchemaVersion(IN LPCTSTR ptchServerName)
/*
  Function: check if the schema allows volume object be created as child of computer object.

  Return:
        S_OK:    yes, it's the new schema, it allows
        S_FALSE: it doesn't allow, or the server doesn't belong to a domain at all
        others:  error occurred
*/
{
    HRESULT hr = S_OK;

    //
    // get DC name of the server's domain
    //
    CString strDCName;
    hr = GetDCInfo(ptchServerName, strDCName);
    if (S_OK != hr)
        return hr;

    //
    // Get schema naming context from the rootDSE.
    //
    CComPtr<IADs> spiRootADs;
    hr = ADsGetObject(_T("LDAP://rootDSE"),
                      IID_IADs,
                      (void**)&spiRootADs);
    if (SUCCEEDED(hr))
    {
        VARIANT var;
        VariantInit(&var);
        hr = spiRootADs->Get(_T("schemaNamingContext"), &var);
        if (FAILED(hr)) return hr;
    
        //
        // get LDAP path to the schema of Connection-Point class
        //
        CString strADsPath = _T("LDAP://");
        strADsPath += strDCName;
        strADsPath += _T("/CN=Connection-Point,");
        strADsPath += V_BSTR(&var);

        VariantClear(&var);

        CComPtr<IADs> spiADs;
        hr = ADsGetObject(strADsPath, IID_IADs, (void**)&spiADs);
        if (FAILED(hr)) return hr;

        VariantInit(&var);
        hr = spiADs->Get(_T("systemPossSuperiors"), &var);
        if (SUCCEEDED(hr))
        {
            hr = IsValueInVarArray(&var, _T("computer"));
            VariantClear(&var);
        } else if (E_ADS_PROPERTY_NOT_FOUND == hr)
            hr = S_FALSE;
    }

    return hr;
}

BOOL CheckPolicyOnSharePublish(IN LPCTSTR ptchShareName)
{
    if (!ptchShareName && !*ptchShareName)
        return FALSE;  // invalid share name

    //
    // no publish page on hidden shares
    //
    int len = lstrlen(ptchShareName);
    if (_T('$') == *(ptchShareName + len - 1))
        return FALSE;

    //
    // no publish page on system shares
    //
    int n = sizeof(g_pszSystemShares) / sizeof(LPCTSTR);
    for (int i = 0; i < n; i++)
    {
        if (!lstrcmpi(ptchShareName, g_pszSystemShares[i]))
            return FALSE;
    }

    //
    // check group policy
    //
    BOOL    bAddPublishPage = TRUE; // by default, we display the share publish page

    HKEY    hKey = NULL;
    DWORD   dwType = 0;
    DWORD   dwData = 0;
    DWORD   cbData = sizeof(dwData);
    LONG    lErr = RegOpenKeyEx(
                    HKEY_CURRENT_USER,
                    _T("Software\\Policies\\Microsoft\\Windows NT\\SharedFolders"),
                    0,
                    KEY_QUERY_VALUE,
                    &hKey);
    if (ERROR_SUCCESS == lErr)
    {
        lErr = RegQueryValueEx(hKey, _T("PublishSharedFolders"), 0, &dwType, (LPBYTE)&dwData, &cbData);

        if (ERROR_SUCCESS == lErr && 
            REG_DWORD == dwType && 
            0 == dwData) // policy is disabled
            bAddPublishPage = FALSE;

        RegCloseKey(hKey);
    }

    return bAddPublishPage;
}

void mystrtok(
    IN LPCTSTR  pszString,
    IN OUT int* pnIndex,  // start from 0
    IN LPCTSTR  pszCharSet,
    OUT CString& strToken
    )
{
    strToken.Empty();

    if (!pszString || !*pszString ||
        !pszCharSet || !pnIndex ||
        *pnIndex >= lstrlen(pszString))
    {
        return;
    }

    TCHAR *ptchStart = (PTSTR)pszString + *pnIndex;
    if (!*pszCharSet)
    {
        strToken = ptchStart;
        return;
    }

    //
    // move p to the 1st char of the token
    //
    TCHAR *p = ptchStart;
    while (*p)
    {
        if (_tcschr(pszCharSet, *p))
            p++;
        else
            break;
    }

    ptchStart = p; // adjust ptchStart to point at the 1st char of the token

    //
    // move p to the char after the last char of the token
    //
    while (*p)
    {
        if (_tcschr(pszCharSet, *p))
            break;
        else
            p++;
    }

    //
    // ptchStart:   points at the 1st char of the token
    // p:           points at the char after the last char of the token
    //
    if (ptchStart != p)
    {
        strToken = CString(ptchStart, (int)(p - ptchStart));
        *pnIndex = (int)(p - pszString);
    }

    // return
}

//
// write a semi-colon separated string into a VARIANT
//
HRESULT PutMultiValuesIntoVarArray(
    IN LPCTSTR      pszValues,
    OUT VARIANT*    pVar
    )
{
    if (!pVar || !pszValues || !*pszValues)
        return E_INVALIDARG;

    //
    // get count of items
    //
    int nCount = 0;
    int nIndex = 0;
    CString strToken;
    mystrtok(pszValues, &nIndex, _T(";"), strToken);
    while (!strToken.IsEmpty())
    {
        nCount++;
        mystrtok(pszValues, &nIndex, _T(";"), strToken);
    }

    if (!nCount)
        return E_INVALIDARG;

    //
    // create an array of variants to hold all the data
    //
    SAFEARRAYBOUND  bounds = {nCount, 0};
    SAFEARRAY*      psa = SafeArrayCreate(VT_VARIANT, 1, &bounds);
    VARIANT*        varArray;

    SafeArrayAccessData(psa, (void**)&varArray);

    nCount = 0;
    nIndex = 0;
    mystrtok(pszValues, &nIndex, _T(";"), strToken);
    while (!strToken.IsEmpty())
    {
        strToken.TrimLeft();
        strToken.TrimRight();

        VariantInit(&(varArray[nCount]));
        varArray[nCount].vt        = VT_BSTR;
        varArray[nCount].bstrVal   = SysAllocString(strToken);

        nCount++;

        mystrtok(pszValues, &nIndex, _T(";"), strToken);
    }

    SafeArrayUnaccessData(psa);

    //
    // return the variant array
    //
    VariantInit(pVar);
    pVar->vt        = VT_ARRAY | VT_VARIANT;
    pVar->parray    = psa;

    return S_OK;
}

//
// read a multi-valued VARIANT into a semicolon separated string
//
HRESULT GetSingleOrMultiValuesFromVarArray(
    IN VARIANT* pVar,
    OUT CString& strValues
    )
{
    strValues.Empty();

    if (V_VT(pVar) != VT_BSTR &&
        V_VT(pVar) != (VT_ARRAY | VT_VARIANT))
        return E_INVALIDARG;

    if (V_VT(pVar) == VT_BSTR)
    {
        strValues = V_BSTR(pVar);
    } else
    {
        LONG lstart, lend;
        SAFEARRAY *sa = V_ARRAY(pVar);
        VARIANT varItem;

        SafeArrayGetLBound(sa, 1, &lstart);
        SafeArrayGetUBound(sa, 1, &lend);

        VariantInit(&varItem);
        for (LONG i = lstart; i <= lend; i++)
        {
            SafeArrayGetElement(sa, &i, &varItem);

            if (!strValues.IsEmpty())
                strValues += _T(";");
            strValues += V_BSTR(&varItem);

            VariantClear(&varItem);
        }
    }

    return S_OK;
}

HRESULT IsValueInVarArray(
    IN VARIANT* pVar,
    IN LPCTSTR  ptchValue
    )
{
    if (V_VT(pVar) != VT_BSTR &&
        V_VT(pVar) != (VT_ARRAY | VT_VARIANT))
        return E_INVALIDARG;

    HRESULT hr = S_FALSE;

    if (V_VT(pVar) == VT_BSTR)
    {
        if (!lstrcmpi(ptchValue, V_BSTR(pVar)))
            hr = S_OK;
    } else
    {
        LONG lstart, lend;
        SAFEARRAY *sa = V_ARRAY(pVar);
        VARIANT varItem;

        SafeArrayGetLBound(sa, 1, &lstart);
        SafeArrayGetUBound(sa, 1, &lend);

        VariantInit(&varItem);
        for (LONG i = lstart; (i <= lend) && (S_FALSE == hr); i++)
        {
            SafeArrayGetElement(sa, &i, &varItem);

            if (!lstrcmpi(ptchValue, V_BSTR(&varItem)))
                hr = S_OK;

            VariantClear(&varItem);
        }
    }

    return hr;
}

/*
We block the operation if:
A) You are monitoring a remote computer, not the local one
B) The session username matches the currently logged on user
C) The number of files opened on the server is greater than 0
D) The client name is either one of our IP addresses or our ComputerName.
*/
BOOL BlockRemoteAdminSession(
    IN PCTSTR i_pszTargetServer,
    IN PCTSTR i_pszClientName,
    IN PCTSTR i_pszUserName,
    IN DWORD  i_dwNumOpenSessions
)
{
    if (!i_pszClientName || !i_pszUserName)
        return FALSE;

    // if we're monitoring the local machine
    if (!i_pszTargetServer || !*i_pszTargetServer)
        return FALSE;

    // if number of sessions is not greater than 0
    if (0 == i_dwNumOpenSessions)
        return FALSE;

    // get username, return if user name doesn't match
    TCHAR szUser[UNLEN+1] = _T("");
    DWORD dwSize = UNLEN+1;
    GetUserName(szUser, &dwSize);
    if (lstrcmpi(szUser, i_pszUserName))
        return FALSE;

    // compare with local computer's name
    TCHAR tszComputer[MAX_COMPUTERNAME_LENGTH + 1] = _T("");
    dwSize = MAX_COMPUTERNAME_LENGTH + 1;
    GetComputerName(tszComputer, &dwSize);
    BOOL bMatch = (0 == lstrcmpi(tszComputer, i_pszClientName));

    // compare with each IP address of the local computer
    if (!bMatch)
    {
      // convert WCHAR to char
      int iBytes = 0;
      char szComputer[MAX_COMPUTERNAME_LENGTH + 1] = "";
      char szClientName[MAX_COMPUTERNAME_LENGTH + 1] = "";

#if defined UNICODE
      iBytes = MAX_COMPUTERNAME_LENGTH + 1;
      WideCharToMultiByte(CP_ACP, 0, tszComputer, -1, szComputer, iBytes, NULL, NULL);

      iBytes = MAX_COMPUTERNAME_LENGTH + 1;
      WideCharToMultiByte(CP_ACP, 0, i_pszClientName, -1, szClientName, iBytes, NULL, NULL);
#else
      lstrcpy(szComputer, tszComputer);
      lstrcpy(szClientName, i_pszClientName);
#endif

        WORD wVersionRequested = MAKEWORD( 2, 2 );
        WSADATA wsaData = {0};

        int err = WSAStartup( wVersionRequested, &wsaData );
        if (err == 0)
        {
            struct hostent *pHostEnt = gethostbyname(szComputer);
            if (pHostEnt)
            {
                struct in_addr IPAddr = {0};
                PSTR pszIP = NULL;
                int i = 0;
                while (pHostEnt->h_addr_list[i])
                {
                    memcpy(&IPAddr, pHostEnt->h_addr_list[i++], pHostEnt->h_length);
                    pszIP = inet_ntoa(IPAddr);
                    if (!_stricmp(pszIP, szClientName))
                    {
                        bMatch = TRUE;
                        break;
                    }
                }
            }
            WSACleanup( );
        }
    }

    // keep this session for remote admin purpose
    if (bMatch)
        DoErrMsgBox(GetActiveWindow(), MB_OK, 0, IDS_POPUP_REMOTEADMINSESSION);

    return bMatch;
}

/*
We block the operation if:
A) You are monitoring a remote computer, not the local one
B) The openfile pathname matches \PIPE\srvsvc or \PIPE\MacFile
C) The openfile username matches the currently logged on user
*/
BOOL BlockRemoteAdminFile(
    IN PCTSTR i_pszTargetServer,
    IN PCTSTR i_pszPathName,
    IN PCTSTR i_pszUserName
)
{
    if (!i_pszPathName || !i_pszUserName)
        return FALSE;

    // if we're monitoring the local machine
    if (!i_pszTargetServer || !*i_pszTargetServer)
        return FALSE;

    if (lstrcmpi(_T("\\PIPE\\srvsvc"), i_pszPathName) && lstrcmpi(_T("\\PIPE\\MacFile"), i_pszPathName))
        return FALSE;

    // get username, return if user name doesn't match
    TCHAR szUser[UNLEN+1] = _T("");
    DWORD dwSize = UNLEN+1;
    GetUserName(szUser, &dwSize);
    if (lstrcmpi(szUser, i_pszUserName))
        return FALSE;

    // this is the admin named pipe, keep it for remote admin purpose
    DoErrMsgBox(GetActiveWindow(), MB_OK, 0, IDS_POPUP_REMOTEADMINFILE, i_pszPathName);

    return TRUE;
}

void TranslateIPToComputerName(LPCTSTR ptszIP, CString& strName)
{
      int iBytes = 0;
      char szIP[MAX_PATH] = "";

#if defined UNICODE
      iBytes = MAX_PATH;
      WideCharToMultiByte(CP_ACP, 0, ptszIP, -1, szIP, iBytes, NULL, NULL);
#else
      lstrcpy(szIP, ptszIP);
#endif

      strName = ptszIP;

      ULONG inaddr = inet_addr(szIP);
      if (INADDR_NONE != inaddr)
      {
          struct hostent *pHostEnt = gethostbyaddr((char *)&inaddr, sizeof(inaddr), AF_INET);
          if (pHostEnt)
          {
#if defined UNICODE
              DWORD cb = MultiByteToWideChar(CP_ACP, 0, pHostEnt->h_name, -1, NULL, 0);
              strName = CString(_T('0'), cb);
              LPTSTR ptszName = strName.GetBuffer(cb);
              MultiByteToWideChar(CP_ACP, 0, pHostEnt->h_name, -1, ptszName, cb);
              strName.ReleaseBuffer();
              
#else
              strName = pHostEnt->h_name;
#endif
          }
      }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\snapmgr.h ===
// SnapMgr.h : header file for Snapin Manager property page
//

#ifndef __SNAPMGR_H__
#define __SNAPMGR_H__

#include "cookie.h"

#include "chooser.h"

// forward declarations
class CFileMgmtComponentData;

/////////////////////////////////////////////////////////////////////////////
// CFileMgmtGeneral dialog

class CFileMgmtGeneral : public CChooseMachinePropPage
{
	// DECLARE_DYNCREATE(CFileMgmtGeneral)

// Construction
public:
	CFileMgmtGeneral();
	virtual ~CFileMgmtGeneral();

// Dialog Data
	//{{AFX_DATA(CFileMgmtGeneral)
	int m_iRadioObjectType;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFileMgmtGeneral)
	public:
	virtual BOOL OnWizardFinish();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFileMgmtGeneral)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	// User defined member variables	
	class CFileMgmtComponentData * m_pFileMgmtData;

public:
	void SetFileMgmtComponentData(CFileMgmtComponentData * pFileMgmtData);

}; // CFileMgmtGeneral


#endif // ~__SNAPMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently


#ifndef __STDAFX_H__
#define __STDAFX_H__

#include <afxwin.h>
#include <afxdisp.h>
#include <afxtempl.h>
#include <afxdlgs.h>
#include <afxcmn.h>
#include <afxmt.h> // CCriticalSection

#include <winsvc.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

extern "C"
{
#include <lmcons.h>
#include <lmshare.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <macfile.h>

// User browser stuff
//  We have to define _NTSEAPI_ since ntseapi.h conflicts with winnt.h
#define _NTSEAPI_
#include <getuser.h>		// OpenUserBrowser()

// Hardware profile stuff
#include <regstr.h>         // CSCONFIGFLAG_*
#include <cfgmgr32.h>       // CM_* APIs
}

#ifndef APIERR
	typedef DWORD APIERR;		// Error code typically returned by ::GetLastError()
#endif

/////////////////////////////////////////////////////////////////////
//
// Handy macros
//
#define INOUT		// Dummy macro
#define IGNORED		// Output parameter is ignored
#define LENGTH(x)	(sizeof(x)/sizeof(x[0]))

#ifdef _DEBUG
	#define DebugCode(x)	x
	#define GarbageInit(pv, cb)	memset(pv, 'a', cb)
#else
	#define DebugCode(x)
	#define GarbageInit(pv, cb)
#endif

/////////////////////////////////////////////////////////////////////
//	Macro Endorse()
//
//	This macro is mostly used when validating parameters.
//	Some parameters are allowed to be NULL because they are optional
//	or simply because the interface uses the NULL case as a valid
//	input parameter.  In this case the Endorse() macro is used to
//	acknowledge the validity of such a parameter.
//
//	REMARKS
//	This macro is the opposite of Assert().
//
//	EXAMPLE
//	Endorse(p == NULL);	// Code acknowledge p == NULL to not be (or not cause) an error
//
#define Endorse(x)


/////////////////////////////////////////////////////////////////////
#define Assert(x)		ASSERT(x)


/////////////////////////////////////////////////////////////////////
// Report is an unsual situation.  This is somewhat similar
// to an assert but does not always represent a code bug.
// eg: Unable to load an icon.
#define Report(x)		ASSERT(x)		// Currently defined as an assert because I don't have time to rewrite another macro


/////////////////////////////////////////////////////////////////////
#include "dbg.h"
#include "mmc.h"

#include <windns.h>

#include <comptr.h>


//#define SNAPIN_PROTOTYPER	// Build a snapin prototyper dll instead of FILEMGMT dll

EXTERN_C const CLSID CLSID_FileServiceManagement;
EXTERN_C const CLSID CLSID_SystemServiceManagement;
EXTERN_C const CLSID CLSID_FileServiceManagementExt;
EXTERN_C const CLSID CLSID_SystemServiceManagementExt;
EXTERN_C const CLSID CLSID_FileServiceManagementAbout;
EXTERN_C const CLSID CLSID_SystemServiceManagementAbout;
EXTERN_C const CLSID CLSID_SvcMgmt;
EXTERN_C const IID IID_ISvcMgmtStartStopHelper;
#ifdef SNAPIN_PROTOTYPER
EXTERN_C const CLSID CLSID_SnapinPrototyper;
#endif


#include "regkey.h" // class AMC::CRegKey

/*
// The following defines are required by the framework
#define STD_COOKIE_TYPE CFileMgmtCookie
#define STD_NODETYPE_ENUM FileMgmtObjectType
#define STD_NODETYPE_DEFAULT FILEMGMT_ROOT
#define STD_NODETYPE_NUMTYPES FILEMGMT_NUMTYPES
#define STD_MAX_COLUMNS 7

// CODEWORK are the following ones necessary?
#define STD_COMPONENT_CLASS CFileMgmtComponent
#define STD_COMPONENTDATA_TYPE CFileMgmtComponentData
*/

// Property sheet include files
#include "resource.h"
#include "filemgmt.h" // CLSID_SvcMgmt, ISvcMgmtStartStopHelper
#include "SvcProp.h"
#include "SvcProp1.h"
#include "SvcProp2.h"
#include "SvcProp3.h"
#include "SvcUtils.h"
#include "Utils.h"

#include "svchelp.h"  // Help IDs

#include "guidhelp.h" // ExtractObjectTypeGUID(), ExtractString()

#include "nodetype.h" // FileMgmtObjectType

#include <shfusion.h>

class CThemeContextActivator
{
public:
    CThemeContextActivator() : m_ulActivationCookie(0)
        { SHActivateContext (&m_ulActivationCookie); }

    ~CThemeContextActivator()
        { SHDeactivateContext (m_ulActivationCookie); }

private:
    ULONG_PTR m_ulActivationCookie;
};

#ifdef UNICODE
#define PROPSHEETPAGE_V3 PROPSHEETPAGEW_V3
#else
#define PROPSHEETPAGE_V3 PROPSHEETPAGEA_V3
#endif

HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* psp);

#if _WIN32_IE < 0x0400
// We #define ILCreateFromPath to our wrapper so that we can run on
// both NT4 and NT5, since it was a TCHAR export in NT4 and an xxxA/xxxW 
// export in NT5
#undef ILCreateFromPath
#define ILCreateFromPath Wrap_ILCreateFromPath
#endif

#define RETURN_HR_IF_FAIL if (FAILED(hr)) { ASSERT(FALSE); return hr; }
#define RETURN_FALSE_IF_FAIL if (FAILED(hr)) { ASSERT(FALSE); return FALSE; }
#define RETURN_E_FAIL_IF_NULL(p) if (NULL == p)  { ASSERT(FALSE); return E_FAIL; }

#endif // ~__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\svchelp.h ===
// "File Service Management" Dialog Box (IDD_FILE_FILEMANAGEMENT_GENERAL == 101)

#define IDH_101_972	972	// File Service Management: "&Local computer:  
#define IDH_101_973	973	// File Service Management: "&Another computer:" (Button)
#define IDH_101_974	974	// Another Computer text box
#define IDH_101_975	975	// File Service Management: "B&rowse..." (Button)
#define IDH_101_976	976	// File Service Management: "Allo&w the selected computer
#define IDH_101_255	255	// All radio button
#define IDH_101_256	256	// Shares radio button
#define IDH_101_257	257	// Sessions radio button
#define IDH_101_258	258	// Open Files radio button


const DWORD g_aHelpIDs_IDD_FILE_FILEMANAGEMENT_GENERAL[]=
{
	970,	((DWORD) -1),	//Label
	971,	((DWORD) -1),	//Groupbox
	972,	972,	// File Service Management: "&Local computer:  
	973,	973,	// File Service Management: "&Another computer:" (Button)
	974,	974,	// Another Computer text box
	975,	975,	// File Service Management: "B&rowse..." (Button)
	976,	976,	// File Service Management: "Allo&w the selected computer to be changed 		
	255,	255,	// All radio button
	256,	256,	// Shares radio button
	257,	257,	// Sessions radio button
	258,	258,	// Open Files radio button
	299,	((DWORD) -1),	//Groupbox
	0, 0
};


// "General" Dialog Box (IDD_PROPPAGE_SERVICE_GENERAL == 211)

#define IDH_211_305	305	// General: "&Description:" (Static)
#define IDH_211_213	213	// General: "" (Edit)
#define IDH_211_283	283	// General: "Path to executable:" (Static)
#define IDH_211_214	214	// General: "" (Edit)
#define IDH_211_284	284	// General: "Status:" (Static)
#define IDH_211_215	215	// General: "" (Edit)
#define IDH_211_285	285	// General: "Typ&e:" (Static)
#define IDH_211_262	262	// General: "Service name:" (Static)
#define IDH_211_216	216	// General: "Stopped" (Static)
#define IDH_211_263	263	// General: "Start para&meters:" (Static)
#define IDH_211_217	217	// General: "&Start" (Button)
#define IDH_211_264	264	// General: "Display &name:" (Static)
#define IDH_211_218	218	// General: "S&top" (Button)
#define IDH_211_219	219	// General: "&Pause" (Button)
#define IDH_211_220	220	// General: "&Resume" (Button)
#define IDH_211_221	221	// General: "" (Edit)
#define IDH_211_224	224	// General: "" (ComboBox)
#define IDH_211_225	225	// General: "" (Edit)



const DWORD g_aHelpIDs_IDD_PROPPAGE_SERVICE_GENERAL[]=
{
	305,	305,	// General: "&Description:" (Static)
	213,	213,	// General: "" (Edit)
	283,	283,	// General: "Path to executable:" (Static)
	214,	214,	// General: "" (Edit)
	284,	284,	// General: "Status:" (Static)
	215,	215,	// General: "" (Edit)
	285,	285,	// General: "Typ&e:" (Static)
	262,	262,	// General: "Service name:" (Static)
	216,	216,	// General: "Stopped" (Static)
	263,	263,	// General: "Start para&meters:" (Static)
	217,	217,	// General: "&Start" (Button)
	264,	264,	// General: "Display &name:" (Static)
	218,	218,	// General: "S&top" (Button)
	219,	219,	// General: "&Pause" (Button)
	220,	220,	// General: "&Resume" (Button)
	221,	221,	// General: "" (Edit)
	224,	224,	// General: "" (ComboBox)
	225,	225,	// General: "" (Edit)
	287,	((DWORD) -1),	// General: Current Status Groupbox
	286,	((DWORD) -1),	// General: Startup Groupbox
	0, 0
};


// "Log On" Dialog Box (IDD_PROPPAGE_SERVICE_HWPROFILE == 212)

#define IDH_212_230	230	// Log On: "" (Edit)
#define IDH_212_254	254	// Log On: "List2" (SysListView32)
#define IDH_212_231	231	// Log On: "" (Edit)
#define IDH_212_232	232	// Log On: "&Enable" (Button)
#define IDH_212_233	233	// Log On: "&Disable" (Button)
#define IDH_212_303	303	// Log On: "&Password:" (Static)
#define IDH_212_234	234	// Log On: "" (Edit)
#define IDH_212_304	304	// Log On: "&Confirm password:" (Static)
#define IDH_212_245	245	// Log On: "Choose &User..." (Button)
#define IDH_212_226	226	// Log On: "&System account" (Button)
#define IDH_212_227	227	// Log On: "&This account:" (Button)
#define IDH_212_228	228	// Log On: "Allo&w service to interact with desktop" (Button)



const DWORD g_aHelpIDs_IDD_PROPPAGE_SERVICE_HWPROFILE[]=
{
	230,	230,	// Log On: "" (Edit)
	254,	254,	// Log On: "List2" (SysListView32)
	231,	231,	// Log On: "" (Edit)
	232,	232,	// Log On: "&Enable" (Button)
	233,	233,	// Log On: "&Disable" (Button)
	303,	303,	// Log On: "&Password:" (Static)
	234,	234,	// Log On: "" (Edit)
	304,	304,	// Log On: "&Confirm password:" (Static)
	245,	245,	// Log On: "Choose &User..." (Button)
	226,	226,	// Log On: "&System account" (Button)
	227,	227,	// Log On: "&This account:" (Button)
	228,	228,	// Log On: "Allo&w service to interact with desktop" (Button)
	288,	((DWORD) -1),	// Log On: Log On As groupbox
	0, 0
};


// "Recovery" Dialog Box (IDD_PROPPAGE_SERVICE_RECOVERY == 213)

#define IDH_213_253	253	// Recovery: "&Command line parameters:" (Static)
#define IDH_213_235	235	// Recovery: "" (Edit)
#define IDH_213_236	236	// Recovery: "" (ComboBox)
#define IDH_213_237	237	// Recovery: "" (ComboBox)
#define IDH_213_238	238	// Recovery: "" (Edit)
#define IDH_213_239	239	// Recovery: "Bro&wse..." (Button)
#define IDH_213_309	309	// Recovery: "" (Edit)
#define IDH_213_240	240	// Recovery: "" (Edit)
#define IDH_213_310	310	// Recovery: "Append 'Fail Count' to &end of command line 
#define IDH_213_290	290	// Recovery: "&First attempt:" (Static)
#define IDH_213_291	291	// Recovery: "&Second attempt:" (Static)
#define IDH_213_292	292	// Recovery: "S&ubsequent attempts:" (Static)
#define IDH_213_246	246	// Recovery: "Re&boot Computer Information..." (Button)
#define IDH_213_293	293	// Recovery: "Reset 'Fail Count' to &zero after:" (Static)
#define IDH_213_247	247	// Recovery: "" (ComboBox)
#define IDH_213_249	249	// Recovery: "Restart the service" label
#define IDH_213_250	250	// Recovery: Minutes label



const DWORD g_aHelpIDs_IDD_PROPPAGE_SERVICE_RECOVERY[]=
{
	253,	253,	// Recovery: "&Command line parameters:" (Static)
	235,	235,	// Recovery: "" (Edit)
	236,	236,	// Recovery: "" (ComboBox)
	237,	237,	// Recovery: "" (ComboBox)
	238,	238,	// Recovery: "" (Edit)
	239,	239,	// Recovery: "Bro&wse..." (Button)
	309,	309,	// Recovery: "" (Edit)
	240,	240,	// Recovery: "" (Edit)
	289,	((DWORD) -1),	// Recovery: "Actions to take when service fails:" (Static)
	310,	310,	// Recovery: "Append 'Fail Count' to &end of command line 
	290,	290,	// Recovery: "&First attempt:" (Static)
	291,	291,	// Recovery: "&Second attempt:" (Static)
	292,	292,	// Recovery: "S&ubsequent attempts:" (Static)
	246,	246,	// Recovery: "Re&boot Computer Information..." (Button)
	293,	293,	// Recovery: "Reset 'Fail Count' to &zero after:" (Static)
	247,	247,	// Recovery: "" (ComboBox)
	248,	((DWORD) -1),	// Recovery: "Restart the service" (Button)
	249,	249,	// Recovery: "Restart the serice" label
	250,	250,	// Recovery: Minutes label
	251,	((DWORD) -1),	// Recovery Run File group box
	0, 0
};


// "Reboot Computer Information" Dialog Box (IDD_SERVICE_REBOOT_COMPUTER == 214)

#define IDH_214_307	307	// Reboot Computer Information: "&Delay before rebooting
#define IDH_214_308	308	// Reboot Computer Information: "" (Edit)
#define IDH_214_311	311	// Reboot Computer Information: "" (Edit)
#define IDH_214_268	268	// Reboot Computer Information: "This message" (Button)
#define IDH_214_270	270	// Reboot Computer Information: "None" (Button)


const DWORD g_aHelpIDs_IDD_SERVICE_REBOOT_COMPUTER[]=
{
	302,	((DWORD) -1),	//Label
	306,	((DWORD) -1),	//Groupbox
	307,	307,	// Reboot Computer Information: "&Delay before rebooting computer:" 
	308,	308,	// Reboot Computer Information: "" (Edit)
	311,	311,	// Reboot Computer Information: "" (Edit)
	322,	268,	// Reboot Computer Information: "This message" (Button)
	321,	270,	// Reboot Computer Information: "None" (Button)
	0, 0
};


// "Stop Service %s" Dialog Box (IDD_SERVICE_STOP_DEPENDENCIES == 215)

#define IDH_215_261	261	// Stop Service %s: "" (ListBox)


const DWORD g_aHelpIDs_IDD_SERVICE_STOP_DEPENDENCIES[]=
{
	301,	((DWORD) -1),	//Stop Service label
	261,	261,	// Stop Service %s: "" (ListBox)
	0, 0
};


// "Service Control" Dialog Box (IDD_SERVICE_CONTROL_PROGRESS == 219)



const DWORD g_aHelpIDs_IDD_SERVICE_CONTROL_PROGRESS[]=
{
	0, 0
};


// "General" Dialog Box (IDD_SHAREPROP_GENERAL_SFM == 223)

#define IDH_223_278	278	// General: "Password:" (Static)
#define IDH_223_241	241	// General: "This volume is read-only" (Button)
#define IDH_223_265	265	// General: "" (Edit)
#define IDH_223_266	266	// General: "" (Static)
#define IDH_223_221	999	// General: "" (Edit)
#define IDH_223_222	222	// General: "0" (Edit)
#define IDH_223_223	223	// General: "" (Edit)
#define IDH_223_294	294	// General: "Share &Name:" (Static)
#define IDH_223_271	271	// General: "Maximum Allowed" (Button)
#define IDH_223_295	295	// General: "Path:" (Static)
#define IDH_223_272	272	// General: "Allow" (Button)
#define IDH_223_296	296	// General: "Comment:" (Static)
#define IDH_223_315	315	// General Users label


const DWORD g_aHelpIDs_IDD_SHAREPROP_GENERAL[]=
{
	278,	278,	// General: "Password:" (Static)
	297,	((DWORD) -1),	//User Limit Group Box
	277,	((DWORD) -1),	//SFM Group Box
	241,	241,	// General: "This volume is read-only" (Button)
	265,	265,	// General: "" (Edit)
	266,	266,	// General: "" (Static)
	221,	999,	// General: "" (Edit)
	222,	222,	// General: "0" (Edit)
	223,	223,	// General: "" (Edit)
	294,	294,	// General: "Share &Name:" (Static)
	271,	271,	// General: "Maximum Allowed" (Button)
	295,	295,	// General: "Path:" (Static)
	272,	272,	// General: "Allow" (Button)
	296,	296,	// General: "Comment:" (Static)
	315,	315,	// General: Users label
	0, 0
};

#define IDH_340_341	341	// Publish: Publish checkbox
#define IDH_340_342	342	// Publish: UNCPath label - static
#define IDH_340_343	343	// Publish: UNCPath editbox
#define IDH_340_344	344	// Publish: Description label - static
#define IDH_340_345	345	// Publish: Description editbox
#define IDH_340_346	346	// Publish: ManagedBy label - static
#define IDH_340_347	347	// Publish: ManagedBy editbox
#define IDH_340_348	348	// Publish: Keywords label - static
#define IDH_340_349	349	// Publish: Keywords editbox
#define IDH_340_350	350	// Publish: Edit button
#define IDH_340_351	351	// Publish: static errmsg

const DWORD g_aHelpIDs_IDD_SHAREPROP_PUBLISH[]=
{
	341,	341,		// Publish: Publish checkbox
	342,	(DWORD)-1,	// Publish: UNCPath label - static
	343,	343,		// Publish: UNCPath editbox
	344,	(DWORD)-1,	// Publish: Description label - static
	345,	345,		// Publish: Description editbox
	346,	(DWORD)-1,	// Publish: ManagedBy label - static
	347,	347,		// Publish: ManagedBy editbox
	348,	(DWORD)-1,	// Publish: Keywords label - static
	349,	349,		// Publish: Keywords editbox
	350,	350,		// Publish: Edit button
	351,	(DWORD)-1,	// Publish: static errmsg
	0, 0
};

#define IDH_360_361	361	// MVSTRINGEDIT: Static text
#define IDH_360_362	362	// MVSTRINGEDIT: edit box
#define IDH_360_363	363	// MVSTRINGEDIT: list box
#define IDH_360_364	364	// MVSTRINGEDIT: Add button
#define IDH_360_365	365	// MVSTRINGEDIT: Remove button

const DWORD g_aHelpIDs_IDD_MVSTRINGEDIT[]=
{
	361,	(DWORD)-1,	// MVSTRINGEDIT: Static text
	362,	362,	// MVSTRINGEDIT: edit box
	363,	363,	// MVSTRINGEDIT: list box
	364,	364,	// MVSTRINGEDIT: Add button
	365,	365,	// MVSTRINGEDIT: Remove button
	0, 0
};

// "Choose Target Machine" Dialog Box

#define IDH_970_972	9972	// Choose Target Machine: "&Local computer: 
#define IDH_970_973	9973	// Choose Target Machine: "&Another computer:" (Button)
#define IDH_970_974	9974	// Another Computer text box
#define IDH_970_975	9975	// Choose Target Machine: "B&rowse..." (Button)
#define IDH_970_976	9976	// Choose Target Machine: "Allo&w the selected computer to be 


const DWORD g_a970HelpIDs[]=
{
	970,	((DWORD) -1),	// Choose Target Machine: Label
	971,	((DWORD) -1),	// Choose Target Machine: "This snap-in will always manage:" 
	972,	9972,	// Choose Target Machine: "&Local computer:  
	973,	9973,	// Choose Target Machine: "&Another computer:" (Button)
	974,	9974,	// Another Computer text box
	975,	9975,	// Choose Target Machine: "B&rowse..." (Button)
	976,	9976,	// Choose Target Machine: "Allo&w the selected computer to be 
	0, 0
};

const DWORD g_aHelpIDs_IDD_SMB_CACHE_SETTINGS[]=
{
    IDC_CACHE_OPTIONS_MANUAL, IDC_CACHE_OPTIONS_MANUAL,
    IDC_CACHE_OPTIONS_AUTO, IDC_CACHE_OPTIONS_AUTO,
    IDC_CACHE_OPTIONS_NOCACHE, IDC_CACHE_OPTIONS_NOCACHE,
    IDC_CACHE_OPTIONS_AUTO_CHECK, IDC_CACHE_OPTIONS_AUTO_CHECK,
    IDC_STATIC_HELPLESS, -1,
    IDC_STATIC_HELPLESS2, -1,
    IDC_CACHE_HELPLINK, -1,
    0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\svcprop.h ===
// SvcProp.h : header file
//
//	Data object used to display service properties.
//
//

#ifndef __SVCPROP_H__
#define __SVCPROP_H__

/////////////////////////////////////////////////////////////////////
//	Structure used by the hardware profile listbox.  One of these
//	structure is allocated per listbox item.
//
//	Typically the listbox has very few entries.
//
class CHardwareProfileEntry	// hpe
{
  public:
	CHardwareProfileEntry * m_pNext;	// Next item of the linked-list
	HWPROFILEINFO m_hpi;				// Hardware profile info returned by CM_Get_Hardware_Profile_Info_Ex()
	ULONG m_uHwFlags;					// Hardware profile flags for the given device instance
	CString m_strDeviceName;
	CString m_strDeviceNameFriendly;
	BOOL m_fReadOnly;					// TRUE => Cannot disable this hardware profile entry
	BOOL m_fEnabled;					// TRUE => Given hardware profile entry is enabled.

  public:
	CHardwareProfileEntry(
		IN CONST HWPROFILEINFO * phpi,
		IN ULONG uHwFlags,
		TCHAR * pszDeviceName,
		CString * pstrDeviceNameFriendly);

	~CHardwareProfileEntry();

	BOOL FWriteHardwareProfile(HMACHINE hMachine);
		
}; // CHardwareProfileEntry


#define SERVICE_cchDisplayNameMax		256
#define SERVICE_cchDescriptionMax		2048	// Maximum number of character in the description
#define SERVICE_cbQueryServiceConfigMax	4096	// Maximum number of bytes required by QueryServiceConfig()
#define SERVICE_cchRebootMessageMax		2048	// Longest length of the reboot message

#define cActionsMax		3		// Maximum number of failure/actions supported

// Macros to convert one time unit to another
#define CvtMillisecondsIntoMinutes(dwMilliseconds)		((dwMilliseconds) / (1000 * 60))
#define CvtSecondsIntoDays(dwSeconds)					((dwSeconds) / (60 * 60 * 24))

#define CvtMinutesIntoMilliseconds(dwMinutes)			((dwMinutes) * 60 * 1000)
#define CvtDaysIntoSeconds(dwDays)						((dwDays) * 60 * 60 * 24)


/////////////////////////////////////////////////////////////////////
//	class CDlgPropService - Service dialog properties
//
//	This object is created only to display the service properties
//	of a given service.
//
class CServicePropertyData
{
  friend class CServicePageGeneral;
  friend class CServicePageHwProfile;
  friend class CServicePageRecovery;
  friend class CServicePageRecovery2;
  friend class CServiceDlgRebootComputer;

  protected:
	enum _DIRTYFLAGS
		{
		mskzValidNone			= 0x00000000,		// None of the fields are valid

		mskfValidSS				= 0x00000001,		// Content of m_SS is valid
		mskfValidQSC			= 0x00000002,		// Content of m_paQSC is valid
		mskfValidSFA			= 0x00000004,		// Content of m_SFA is valid
		mskfValidDescr			= 0x00000008,		// Service description is valid
		mskfSystemProcess		= 0x00000010,		// Service runs in system process
		//mskfValidAll			= 0x00000080,		// All the fields are valid
		mskfErrorBAADF00D		= 0x00008000,		// Workaround for the error code returned by CM_Get_Hardware_Profile_Info_Ex()

		// General
#ifdef EDIT_DISPLAY_NAME_373025
		mskfDirtyDisplayName	= 0x00010000,		// Service display name has been modified
		mskfDirtyDescription	= 0x00020000,		// Service description has been modified
#endif // EDIT_DISPLAY_NAME_373025
		mskfDirtyStartupType	= 0x00040000,		// Startup type has been modified
		// mskfDirtyStartupParam	= 0x00080000,		// IGNORED: Startup parameters are not persistent

		// Log On
		mskfDirtyAccountName	= 0x01000000,
		mskfDirtyPassword		= 0x02000000,
		mskfDirtySvcType		= 0x04000000,


		// Recovery
		mskfDirtySFA			= 0x10000000,		// Content of m_SFA has been modified
		mskfDirtyRunFile		= 0x20000000,		// Command to run a file has been modified
		mskfDirtyRebootMessage	= 0x40000000,		// Reboot message has been modified
		mskfDirtyActionType		= 0x80000000,		// Only the action type has been changed

		mskmDirtyAll			= 0xFFFF0000,		// Mask to check if one of the field has been modified
	} DIRTYFLAGS;

  protected:
	IDataObjectPtr m_spDataObject;		// Used for MMCPropertyChangeNotify
	LONG_PTR m_lNotifyHandle;				// Handle used to notify SnapIn parent when properties are modified
	HMACHINE m_hMachine;				// Handle of computer for Configuration Manager.
	SC_HANDLE m_hScManager;				// Handle to service control manager database
	CString m_strMachineName;			// Name of the computer.  Empty for 'local machine'.
	CString m_strUiMachineName;			// Name of the computer in a friendly way (should not be used with the APIs)
	CString m_strServiceName;			// Name of the service
	CONST TCHAR * m_pszServiceName;		// Pointer to service name (pointing to m_strServiceName)
	CString m_strServiceDisplayName;	// Display name of the service
	BOOL m_fQueryServiceConfig2;		// TRUE => Machine support QueryServiceConfig2() API

	UINT m_uFlags;						// Flags about which fields are dirty

	//
	//	General Dialog
	//

	// JonN 4/21/01 348163
	// Note that this structure may not be initialized, or only the
	// SERVICE_STATUS field may be initialized
	SERVICE_STATUS_PROCESS m_SS;		// Service Status structure

	QUERY_SERVICE_CONFIG * m_paQSC;		// Pointer to allocated QSC structure
	CString m_strDescription;			// Description of service

	//
	//	Logon As Dialog
	//
	CString	m_strLogOnAccountName;
	CString	m_strPassword;

	//
	//	Hardware profile
	//
	CHardwareProfileEntry * m_paHardwareProfileEntryList;	// Pointer to linked list of entries
	BOOL m_fShowHwProfileInstances;		// TRUE => Show the device instances
	INT m_iSubItemHwProfileStatus;		// Always 1 or 2 (computed from 1 + m_fShowHwProfileInstance)

	//
	//	Recovery Dialog
	//
	SERVICE_FAILURE_ACTIONS * m_paSFA;		// Pointer to allocated SFA structure
	SERVICE_FAILURE_ACTIONS m_SFA;		// Output SFA structure
	SC_ACTION m_rgSA[cActionsMax];		// Array to hold first, second and subsequent failures
	BOOL m_fAllSfaTakeNoAction;			// TRUE => All SFA recovery attemps do take no actions

    // JonN 3/28/00 28975
    // IIS 5.0 Reliability : SCM Snap-in :
    //     The snap-in is changing the failure action delay value
    //
    // We remember the initial value and what we initially displayed.
    //  if the user does not change the value of DelayAbendCount,
    //  DelayRestartService, or DelayRebootComputer.

	UINT m_secOriginalAbendCount;
	UINT m_daysOriginalAbendCount;
	UINT m_daysDisplayAbendCount;

	UINT m_msecOriginalRestartService;
	UINT m_minOriginalRestartService;
	UINT m_minDisplayRestartService;

	UINT m_msecOriginalRebootComputer;
	UINT m_minOriginalRebootComputer;
	UINT m_minDisplayRebootComputer;

	CString m_strRunFileCommand;		// Command line with arguments and abend number (if any)
	CString m_strRebootMessage;			// Reboot message
	
	HWND m_hwndPropertySheet;			// Handle of the property sheet
	CServicePageGeneral * m_pPageGeneral;
	CServicePageHwProfile * m_pPageHwProfile;
	CServicePageRecovery * m_pPageRecovery;
	CServicePageRecovery2 * m_pPageRecovery2; // JonN 4/20/01 348163

  public:
	CServicePropertyData();
	~CServicePropertyData();
	BOOL FInit(
		LPDATAOBJECT lpDataObject,
		CONST TCHAR pszMachineName[],
		CONST TCHAR pszServiceName[],
		CONST TCHAR pszServiceDisplayName[],
		LONG_PTR lNotifyHandle);

	BOOL CreatePropertyPages(LPPROPERTYSHEETCALLBACK pCallback);

	BOOL FOpenScManager();
	BOOL FQueryServiceInfo();
	BOOL FUpdateServiceInfo();
	void FCheckLSAAccount();
	BOOL FOnApply();
	void NotifySnapInParent();
	void UpdateCaption();

	void FlushHardwareProfileEntries();
	BOOL FQueryHardwareProfileEntries();
	BOOL FChangeHardwareProfileEntries();

	void SetDirty(enum CServicePropertyData::_DIRTYFLAGS uDirtyFlag)
		{
		Assert((uDirtyFlag & ~mskmDirtyAll) == 0);
		m_uFlags |= uDirtyFlag;
		}
	
	UINT GetDelayForActionType(SC_ACTION_TYPE actionType, BOOL * pfDelayFound);
	void SetDelayForActionType(SC_ACTION_TYPE actionType, UINT uDelay);
	UINT QueryUsesActionType(SC_ACTION_TYPE actionType);
	BOOL FAllSfaTakeNoAction();

}; // CServicePropertyData


/*
These functions call through to the appropriate ADVAPI32 calls
and set the last parameter to FALSE 
*/
/* ISSUE-2002/03/06-JonN not used
BOOL MyChangeServiceConfig2(
	BOOL* pfDllPresentLocally, // will set to FALSE if new ADVAPI32 not present
    SC_HANDLE hService,	// handle to service 
    DWORD dwInfoLevel,	// which configuration information to change
    LPVOID lpInfo		// pointer to configuration information
   );
*/

BOOL MyQueryServiceConfig2(
	BOOL* pfDllPresentLocally, // will set to FALSE if new ADVAPI32 not present
    SC_HANDLE hService,	// handle of service 
    DWORD dwInfoLevel,		// which configuration data is requested
    LPBYTE lpBuffer,		// pointer to service configuration buffer
    DWORD cbBufSize,		// size of service configuration buffer 
    LPDWORD pcbBytesNeeded 	// address of variable for bytes needed  
   );


#endif // ~__SVCPROP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\svcprop1.h ===
// svcprop1.h : header file
//


/////////////////////////////////////////////////////////////////////
// This structure is used to initialize the thread associated with
// the CServicePageGeneral.
class CThreadProcInit
{
  public:
	CServicePageGeneral * m_pThis;	// 'this' pointer
	volatile HWND m_hwnd;			// Handle to send the notification message
	volatile BOOL m_fAutoDestroy;	// TRUE => The thread should free this object and terminate itself
	volatile SC_HANDLE m_hScManager;	// Handle to service control manager database
	CString m_strServiceName;
	CCriticalSection m_CriticalSection;

  public:
	CThreadProcInit(CServicePageGeneral * pThis)
		{
		Assert(pThis != NULL);
		m_pThis = pThis;
		m_hwnd = NULL;
		m_fAutoDestroy = FALSE;
		m_hScManager = NULL;
		}
}; // CThreadProcInit


/////////////////////////////////////////////////////////////////////////////
// CServicePageGeneral dialog
class CServicePageGeneral : public CPropertyPage
{
	DECLARE_DYNCREATE(CServicePageGeneral)

// Construction
public:
	CServicePageGeneral();
	~CServicePageGeneral();

// Dialog Data
	//{{AFX_DATA(CServicePageGeneral)
	enum { IDD = IDD_PROPPAGE_SERVICE_GENERAL };
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CServicePageGeneral)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	virtual BOOL OnApply();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CServicePageGeneral)
#ifdef EDIT_DISPLAY_NAME_373025
	afx_msg void OnChangeEditDisplayName();
	afx_msg void OnChangeEditDescription();
#endif // EDIT_DISPLAY_NAME_373025
	virtual BOOL OnInitDialog();
	afx_msg void OnDestroy();
	afx_msg void OnSelchangeComboStartupType();
	afx_msg void OnButtonPauseService();
	afx_msg void OnButtonStartService();
	afx_msg void OnButtonStopService();
	afx_msg void OnButtonResumeService();
	afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	afx_msg BOOL OnContextHelp(WPARAM wParam, LPARAM lParam);
	// CODEWORK remove this method and the WM_ definition
	// afx_msg LRESULT OnCompareIDataObject(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnUpdateServiceStatus(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	static DWORD ThreadProcPeriodicServiceStatusUpdate(CThreadProcInit * paThreadProcInit);

public:
// User defined variables
	CServicePropertyData * m_pData;
	DWORD m_dwCurrentStatePrev;
	HANDLE m_hThread;
	CThreadProcInit * m_pThreadProcInit;

// User defined functions
	void SetDlgItemFocus(INT nIdDlgItem);
	void EnableDlgItem(INT nIdDlgItem, BOOL fEnable);
	void RefreshServiceStatusButtons();

}; // CServicePageGeneral
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\svcprop1.cpp ===
// svcprop1.cpp : implementation file
//
// Implementation of page "General" of service property.
//
// HISTORY
// 30-Sep-96	t-danmo		Creation
//

#include "stdafx.h"
#include "progress.h"
#include "cookie.h"
#include "dataobj.h"
#include "DynamLnk.h"		// DynamicDLL

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/*
// ISSUE-2002/03/06-JonN no longer used
/////////////////////////////////////////////////////////////////////
//	WM_COMPARE_IDATAOBJECT
//
//		wParam = (WPARAM)(IDataObject *)pDataObject;
//		lParam = 0;
//
//	Return TRUE if content of pDataObject matches current data object,
//	otherwise return FALSE.
//
//	USAGE
//	This message is sent to a property page asking to
//	compare content pDataObject with its current data object.
//	The comparison is done by comparing data strings from
//	the various clipboard formats supported by pDataObject.
//	
#define WM_COMPARE_IDATAOBJECT		(WM_USER+1234)
*/

/////////////////////////////////////////////////////////////////////
//	WM_UPDATE_SERVICE_STATUS
//
//		wParam = (WPARAM)(BOOL *)rgfEnableButton;
//		lParam = (LPARAM)dwCurrentState;
//
//	Notification message of the current service status.
//
#define WM_UPDATE_SERVICE_STATUS	(WM_USER+1235)



/////////////////////////////////////////////////////////////////////
static const TStringParamEntry rgzspeStartupType[] =
	{
	{ IDS_SVC_STARTUP_AUTOMATIC, SERVICE_AUTO_START },
	{ IDS_SVC_STARTUP_MANUAL, SERVICE_DEMAND_START },
	{ IDS_SVC_STARTUP_DISABLED, SERVICE_DISABLED },
	{ 0, 0 }
	};

#ifdef EDIT_DISPLAY_NAME_373025
const UINT rgzidDisableServiceDescription[] =
	{
	IDC_STATIC_DESCRIPTION,
	IDC_EDIT_DESCRIPTION,
	0,
	};
#endif // EDIT_DISPLAY_NAME_373025
	
const UINT rgzidDisableStartupParameters[] =
	{
	IDC_STATIC_STARTUP_PARAMETERS,
	IDC_EDIT_STARTUP_PARAMETERS,
	0,
	};



/////////////////////////////////////////////////////////////////////
// CServicePageGeneral property page
IMPLEMENT_DYNCREATE(CServicePageGeneral, CPropertyPage)

CServicePageGeneral::CServicePageGeneral() : CPropertyPage(CServicePageGeneral::IDD)
	, m_dwCurrentStatePrev( 0 ) // 581167-2002/03/06-JonN initialize
	{
	//{{AFX_DATA_INIT(CServicePageGeneral)
	//}}AFX_DATA_INIT
	m_pData = NULL;
	m_hThread = NULL;
	m_pThreadProcInit = NULL;
	}

CServicePageGeneral::~CServicePageGeneral()
	{
	}

void CServicePageGeneral::DoDataExchange(CDataExchange* pDX)
	{
	Assert(m_pData != NULL);

	HWND hwndCombo = HGetDlgItem(m_hWnd, IDC_COMBO_STARTUP_TYPE);
	if (!pDX->m_bSaveAndValidate)
		{
		//
		//	Initialize data from m_pData into UI
		//
		ComboBox_FlushContent(hwndCombo);
		(void)ComboBox_FFill(hwndCombo, IN rgzspeStartupType,
			m_pData->m_paQSC->dwStartType);

		//
		// JonN 4/10/00
		// 89823: RPC Service:Cannot restart the service when you disable it
		//
		// Do not allow the RpcSs service to change from Automatic
		//
		// JonN 10/23/01 472867 also the PlugPlay service
		//
		if ( ( !lstrcmpi(m_pData->m_strServiceName,L"RpcSs") ||
		       !lstrcmpi(m_pData->m_strServiceName,L"PlugPlay") )
		  && SERVICE_AUTO_START == m_pData->m_paQSC->dwStartType )
			{
			EnableDlgItem(IDC_COMBO_STARTUP_TYPE, FALSE);
			}

#ifndef EDIT_DISPLAY_NAME_373025
	    DDX_Text(pDX, IDC_EDIT_DISPLAY_NAME, m_pData->m_strServiceDisplayName);
	    DDX_Text(pDX, IDC_EDIT_DESCRIPTION, m_pData->m_strDescription);
#endif // EDIT_DISPLAY_NAME_373025
		} // if

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServicePageGeneral)
	//}}AFX_DATA_MAP
#ifdef EDIT_DISPLAY_NAME_373025
	DDX_Text(pDX, IDC_EDIT_DISPLAY_NAME, m_pData->m_strServiceDisplayName);
	DDV_MaxChars(pDX, m_pData->m_strServiceDisplayName, 255);
	DDX_Text(pDX, IDC_EDIT_DESCRIPTION, m_pData->m_strDescription);
	DDV_MaxChars(pDX, m_pData->m_strDescription, 2047);
#endif // EDIT_DISPLAY_NAME_373025

	if (pDX->m_bSaveAndValidate)
		{
		//
		//	Write data from UI into m_pData
		//
#ifdef EDIT_DISPLAY_NAME_373025
		if (m_pData->m_strServiceDisplayName.IsEmpty())
			{
			DoServicesErrMsgBox(m_hWnd, MB_OK | MB_ICONEXCLAMATION, 0, IDS_MSG_PLEASE_ENTER_DISPLAY_NAME);
			pDX->PrepareEditCtrl(IDC_EDIT_DISPLAY_NAME);
			pDX->Fail();
			}
#endif // EDIT_DISPLAY_NAME_373025
		m_pData->m_paQSC->dwStartType = (DWORD)ComboBox_GetSelectedItemData(hwndCombo);
		} // if
	} // CServicePageGeneral::DoDataExchange()


BEGIN_MESSAGE_MAP(CServicePageGeneral, CPropertyPage)
	//{{AFX_MSG_MAP(CServicePageGeneral)
#ifdef EDIT_DISPLAY_NAME_373025
	ON_EN_CHANGE(IDC_EDIT_DISPLAY_NAME, OnChangeEditDisplayName)
	ON_EN_CHANGE(IDC_EDIT_DESCRIPTION, OnChangeEditDescription)
#endif // EDIT_DISPLAY_NAME_373025
	ON_CBN_SELCHANGE(IDC_COMBO_STARTUP_TYPE, OnSelchangeComboStartupType)
	ON_BN_CLICKED(IDC_BUTTON_PAUSE, OnButtonPauseService)
	ON_BN_CLICKED(IDC_BUTTON_START, OnButtonStartService)
	ON_BN_CLICKED(IDC_BUTTON_STOP, OnButtonStopService)
	ON_BN_CLICKED(IDC_BUTTON_RESUME, OnButtonResumeService)
	ON_WM_DESTROY()
	ON_MESSAGE(WM_HELP, OnHelp)
	ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
//	ON_MESSAGE(WM_COMPARE_IDATAOBJECT, OnCompareIDataObject)
	ON_MESSAGE(WM_UPDATE_SERVICE_STATUS, OnUpdateServiceStatus)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
	

/////////////////////////////////////////////////////////////////////////////
// CServicePageGeneral message handlers
BOOL CServicePageGeneral::OnInitDialog()
	{
	CPropertyPage::OnInitDialog();
	Assert(m_pData != NULL);
	Assert(m_pData->m_paQSC != NULL);
	m_pData->m_hwndPropertySheet = ::GetParent(m_hWnd);
	m_pData->UpdateCaption();
	SetDlgItemText(IDC_STATIC_SERVICE_NAME, m_pData->m_pszServiceName);
	SetDlgItemText(IDC_STATIC_PATH_TO_EXECUTABLE, m_pData->m_paQSC->lpBinaryPathName);
#ifdef EDIT_DISPLAY_NAME_373025
	EnableDlgItemGroup(m_hWnd, rgzidDisableServiceDescription, m_pData->m_fQueryServiceConfig2);
#endif // EDIT_DISPLAY_NAME_373025
	RefreshServiceStatusButtons();

	// Create a thread for periodic update
	m_pThreadProcInit = new CThreadProcInit(this);	// Note the object will be freed by the thread
	m_pThreadProcInit->m_strServiceName = m_pData->m_strServiceName;

	Assert(m_hThread == NULL);
	m_hThread = ::CreateThread(
		NULL,
		0,
		(LPTHREAD_START_ROUTINE)ThreadProcPeriodicServiceStatusUpdate,
		m_pThreadProcInit,
		0,
		NULL);
	Report(m_hThread != NULL && "Unable to create thread");
	return TRUE;
	}

/////////////////////////////////////////////////////////////////////
void CServicePageGeneral::OnDestroy()
	{
		{
		CSingleLock lock(&m_pThreadProcInit->m_CriticalSection, TRUE);
		m_pThreadProcInit->m_hwnd = NULL;
		m_pThreadProcInit->m_fAutoDestroy = TRUE;
		}
	if (NULL != m_hThread)
		{
		VERIFY(::CloseHandle(m_hThread));
		m_hThread = NULL;
		}
	CPropertyPage::OnDestroy();
	delete m_pData;
	m_pData = NULL; // 581167-2002/03/07-JonN set m_pData to NULL
	}

/////////////////////////////////////////////////////////////////////
BOOL CServicePageGeneral::OnSetActive()
	{
	Assert(m_pData != NULL);
	if (m_pData->m_hScManager == NULL)
		{
		AFX_MANAGE_STATE(AfxGetStaticModuleState( )); // required for CWaitCursor
		CWaitCursor wait;
		(void)m_pData->FOpenScManager();	// Re-open the service control manager database (if previously closed)
		}
	{
	CSingleLock lock(&m_pThreadProcInit->m_CriticalSection, TRUE);
	m_pThreadProcInit->m_hScManager = m_pData->m_hScManager;
	m_pThreadProcInit->m_hwnd = m_hWnd;
	}
	return CPropertyPage::OnSetActive();
	}

/////////////////////////////////////////////////////////////////////
BOOL CServicePageGeneral::OnKillActive()
	{
	if (!CPropertyPage::OnKillActive())
		return FALSE;
	{
	CSingleLock lock(&m_pThreadProcInit->m_CriticalSection, TRUE);
	m_pThreadProcInit->m_hwnd = NULL;
	}
	return TRUE;
	}

#ifdef EDIT_DISPLAY_NAME_373025
void CServicePageGeneral::OnChangeEditDisplayName()
	{
	m_pData->SetDirty(CServicePropertyData::mskfDirtyDisplayName);
	SetModified();	
	}

void CServicePageGeneral::OnChangeEditDescription()
	{
	m_pData->SetDirty(CServicePropertyData::mskfDirtyDescription);
	SetModified();
	}
#endif // EDIT_DISPLAY_NAME_373025

void CServicePageGeneral::OnSelchangeComboStartupType()
	{
	m_pData->SetDirty(CServicePropertyData::mskfDirtyStartupType);
	SetModified();
	}

void CServicePageGeneral::SetDlgItemFocus(INT nIdDlgItem)
	{
	::SetDlgItemFocus(m_hWnd, nIdDlgItem);
	}

void CServicePageGeneral::EnableDlgItem(INT nIdDlgItem, BOOL fEnable)
	{
	::EnableDlgItem(m_hWnd, nIdDlgItem, fEnable);
	}


/////////////////////////////////////////////////////////////////////
//	RefreshServiceStatusButtons()
//
//	Query the service manager to get the status of the service, and
//	enable/disable buttons Start, Stop, Pause and Continue accordingly.
//
void CServicePageGeneral::RefreshServiceStatusButtons()
	{
	BOOL rgfEnableButton[iServiceActionMax];
	DWORD dwCurrentState;
	
	// ISSUE-2002/03/07-JonN Don't we need to call AFX_MANAGE_STATE before
	//   CWaitCursor?
	CWaitCursor wait;
	if (!Service_FGetServiceButtonStatus(
		m_pData->m_hScManager,
		m_pData->m_pszServiceName,
		OUT rgfEnableButton,
		OUT &dwCurrentState))
		{
		// let's not do this m_pData->m_hScManager = NULL;
		}
	m_dwCurrentStatePrev = !dwCurrentState;	// Force a refresh
	OnUpdateServiceStatus((WPARAM)rgfEnableButton, dwCurrentState);
	} // CServicePageGeneral::RefreshServiceStatusButtons()


typedef enum _SVCPROP_Shell32ApiIndex
{
	CMDLINE_ENUM = 0
};

// not subject to localization
static LPCSTR g_apchShell32FunctionNames[] = {
	"CommandLineToArgvW",
	NULL
};

typedef LPWSTR * (*COMMANDLINETOARGVWPROC)(LPCWSTR, int*);

// not subject to localization
DynamicDLL g_SvcpropShell32DLL( _T("SHELL32.DLL"), g_apchShell32FunctionNames );

/////////////////////////////////////////////////////////////////////
void CServicePageGeneral::OnButtonStartService()
	{
	CString strStartupParameters;
	LPCWSTR * lpServiceArgVectors = NULL;  // Array of pointers to strings
	int cArgs = 0;                         // Count of arguments

	// Get the startup parameters
	GetDlgItemText(IDC_EDIT_STARTUP_PARAMETERS, OUT strStartupParameters);
	if ( !strStartupParameters.IsEmpty() )
		{
#ifndef UNICODE
#error CODEWORK t-danmo: CommandLineToArgvW will only work for unicode strings
#endif
		if ( !g_SvcpropShell32DLL.LoadFunctionPointers() )
			{
			ASSERT(FALSE);
			return;
			}
		lpServiceArgVectors = (LPCWSTR *)((COMMANDLINETOARGVWPROC)g_SvcpropShell32DLL[CMDLINE_ENUM])
			(strStartupParameters, OUT &cArgs);
		if (lpServiceArgVectors == NULL)
			{
			DoServicesErrMsgBox(m_hWnd, MB_OK | MB_ICONEXCLAMATION, 0, IDS_MSG_INVALID_STARTUP_PARAMETERS);
			SetDlgItemFocus(IDC_EDIT_STARTUP_PARAMETERS);
			return;
			}
		}
	// Disable the edit control for better UI
	EnableDlgItemGroup(m_hWnd, rgzidDisableStartupParameters, FALSE);
	DWORD dwErr = CServiceControlProgress::S_EStartService(
		m_hWnd,
		m_pData->m_hScManager,
		m_pData->m_strUiMachineName,
		m_pData->m_pszServiceName,
		m_pData->m_strServiceDisplayName,
		cArgs,
		lpServiceArgVectors);

	// ISSUE-2002/03/07-JonN MSDN says we should use GlobalFree here
	if (NULL != lpServiceArgVectors)
		LocalFree(lpServiceArgVectors);
	if (dwErr == CServiceControlProgress::errUserAbort)
		return;
	RefreshServiceStatusButtons();
	SetDlgItemFocus(IDC_BUTTON_STOP);
	m_pData->NotifySnapInParent();
	}


/////////////////////////////////////////////////////////////////////
void CServicePageGeneral::OnButtonStopService()
	{
	DWORD dwErr = CServiceControlProgress::S_EControlService(
		m_hWnd,
		m_pData->m_hScManager,
		m_pData->m_strUiMachineName,
		m_pData->m_pszServiceName,
		m_pData->m_strServiceDisplayName,
		SERVICE_CONTROL_STOP);
	if (dwErr == CServiceControlProgress::errUserAbort)
		return;
	RefreshServiceStatusButtons();
	SetDlgItemFocus(IDC_BUTTON_START);
	m_pData->NotifySnapInParent();
	}


/////////////////////////////////////////////////////////////////////
void CServicePageGeneral::OnButtonPauseService()
	{
	DWORD dwErr = CServiceControlProgress::S_EControlService(
		m_hWnd,
		m_pData->m_hScManager,
		m_pData->m_strUiMachineName,
		m_pData->m_pszServiceName,
		m_pData->m_strServiceDisplayName,
		SERVICE_CONTROL_PAUSE);
	if (dwErr == CServiceControlProgress::errUserAbort)
		return;
	RefreshServiceStatusButtons();
	SetDlgItemFocus(IDC_BUTTON_RESUME);
	m_pData->NotifySnapInParent();
	}


/////////////////////////////////////////////////////////////////////
void CServicePageGeneral::OnButtonResumeService()
	{
	DWORD dwErr = CServiceControlProgress::S_EControlService(
		m_hWnd,
		m_pData->m_hScManager,
		m_pData->m_strUiMachineName,
		m_pData->m_pszServiceName,
		m_pData->m_strServiceDisplayName,
		SERVICE_CONTROL_CONTINUE);
	if (dwErr == CServiceControlProgress::errUserAbort)
		return;
	RefreshServiceStatusButtons();
	SetDlgItemFocus(IDC_BUTTON_PAUSE);
	m_pData->NotifySnapInParent();
	}

/////////////////////////////////////////////////////////////////////
BOOL CServicePageGeneral::OnApply()
	{	
	// Write the data into the service control database
	if (!m_pData->FOnApply())
		{
		// Unable to write the information
		return FALSE;
		}
	UpdateData(FALSE);
	RefreshServiceStatusButtons();
	m_pData->UpdateCaption();
	return CPropertyPage::OnApply();
	}

/*
/////////////////////////////////////////////////////////////////////
//	OnCompareIDataObject()
//
//	Return TRUE if 'service name' and 'machine name' of pDataObject
//	matches 'service name' and 'machine name' of current property sheet.
//
LRESULT CServicePageGeneral::OnCompareIDataObject(WPARAM wParam, LPARAM lParam)
	{
	IDataObject * pDataObject;
	CString strServiceName;
	CString strMachineName;
	HRESULT hr;

	pDataObject = reinterpret_cast<IDataObject *>(wParam);
	Assert(pDataObject != NULL);

	// Get the service name from IDataObject
	hr = ::ExtractString(
		pDataObject,
		CFileMgmtDataObject::m_CFServiceName,
		OUT &strServiceName,
		255);
	if (FAILED(hr))
		return FALSE;
	if (0 != lstrcmpi(strServiceName, m_pData->m_strServiceName))
		{
		// Service name do not match
		return FALSE;
		}

	// Get the machine name (computer name) from IDataObject
	hr = ::ExtractString(
		pDataObject,
		CFileMgmtDataObject::m_CFMachineName,
		OUT &strMachineName,
		255);
	if (FAILED(hr))
		return FALSE;
	return FCompareMachineNames(m_pData->m_strMachineName, strMachineName);
	} // CServicePageGeneral::OnCompareIDataObject()
*/

/////////////////////////////////////////////////////////////////////
LRESULT CServicePageGeneral::OnUpdateServiceStatus(WPARAM wParam, LPARAM lParam)
	{
	const BOOL * rgfEnableButton = (BOOL *)wParam;
	const DWORD dwCurrentState = (DWORD)lParam;

	Assert(rgfEnableButton != NULL);
	if (dwCurrentState != m_dwCurrentStatePrev)
		{
		m_dwCurrentStatePrev = dwCurrentState;
		SetDlgItemText(IDC_STATIC_CURRENT_STATUS,
			Service_PszMapStateToName(dwCurrentState, TRUE));
		EnableDlgItem(IDC_BUTTON_START, rgfEnableButton[iServiceActionStart]);
		EnableDlgItem(IDC_BUTTON_STOP, rgfEnableButton[iServiceActionStop]);
		EnableDlgItem(IDC_BUTTON_PAUSE, rgfEnableButton[iServiceActionPause]);
		EnableDlgItem(IDC_BUTTON_RESUME, rgfEnableButton[iServiceActionResume]);
		// Enable/disable the edit box of the startup parameter according
		// to the state of the 'start' button
		EnableDlgItemGroup(m_hWnd, rgzidDisableStartupParameters, rgfEnableButton[iServiceActionStart]);
		if (dwCurrentState == 0)
			{
			// Service state is unknown
			m_pData->m_hScManager = NULL;
			DoServicesErrMsgBox(m_hWnd, MB_OK | MB_ICONEXCLAMATION, 0, IDS_MSG_ss_UNABLE_TO_QUERY_SERVICE_STATUS,
				(LPCTSTR)m_pData->m_strServiceDisplayName, (LPCTSTR)m_pData->m_strUiMachineName);
			}
		}
	return 0;
	} // CServicePageGeneral::OnUpdateServiceStatus()


/////////////////////////////////////////////////////////////////////
//	Periodically update the service status.
//
//	Send a message to CServicePageGeneral object to notify the update.
//
//	INTERFACE NOTES
//	The thread is responsible of deleting the paThreadProcInit object
//	before terminating itself.
//
DWORD CServicePageGeneral::ThreadProcPeriodicServiceStatusUpdate(CThreadProcInit * paThreadProcInit)
	{
	Assert(paThreadProcInit != NULL);
	Assert(paThreadProcInit->m_pThis != NULL);
	Assert(paThreadProcInit->m_fAutoDestroy == FALSE);
	
	BOOL rgfEnableButton[iServiceActionMax];
	DWORD dwCurrentState;

	// Infinite loop querying the service status
	while (!paThreadProcInit->m_fAutoDestroy)
		{
		if (paThreadProcInit->m_hwnd != NULL)
			{
			SC_HANDLE hScManager;
				{
				CSingleLock lock(&paThreadProcInit->m_CriticalSection, TRUE);
				hScManager = paThreadProcInit->m_hScManager;
				}
			BOOL fSuccess = Service_FGetServiceButtonStatus(
				hScManager,
				paThreadProcInit->m_strServiceName,
				OUT rgfEnableButton,
				OUT &dwCurrentState,
				TRUE /* fSilentError */);

			HWND hwnd = NULL;
				{
				CSingleLock lock(&paThreadProcInit->m_CriticalSection, TRUE);
				hwnd = paThreadProcInit->m_hwnd;
				}
			if (hwnd != NULL)
				{
				Assert(IsWindow(hwnd));
				::SendMessage(hwnd, WM_UPDATE_SERVICE_STATUS,
					(WPARAM)rgfEnableButton, (LPARAM)dwCurrentState);
				}
			if (!fSuccess)
				{
				CSingleLock lock(&paThreadProcInit->m_CriticalSection, TRUE);
				paThreadProcInit->m_hwnd = NULL;
				}
			}
		Sleep(1000);
		} // while

	delete paThreadProcInit;
	return 0;
	} // CServicePageGeneral::ThreadProcPeriodicServiceStatusUpdate()


/////////////////////////////////////////////////////////////////////
//	Help
BOOL CServicePageGeneral::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
	return DoHelp(lParam, HELP_DIALOG_TOPIC(IDD_PROPPAGE_SERVICE_GENERAL));
}

BOOL CServicePageGeneral::OnContextHelp(WPARAM wParam, LPARAM /*lParam*/)
{
	return DoContextHelp(wParam, HELP_DIALOG_TOPIC(IDD_PROPPAGE_SERVICE_GENERAL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\svcprop.cpp ===
//	SvcProp.cpp
//
//	Data object used to display service properties.
//
//	HISTORY
//	10-Oct-96	t-danmo		Creation.
//

#include "stdafx.h"
#include "DynamLnk.h" // DynamicDLL
#include "cmponent.h" // FILEMGMTPROPERTYCHANGE

extern "C"
{
	#define NTSTATUS LONG
	#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)
	#define SE_SHUTDOWN_PRIVILEGE             (19L)
}


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/*
Create an instance of this class to expand your token privileges
to the maximum possible.  Your privileges will return to normal
when this object is destroyed.  I don't think that you can have
more than one of these at a time.  There is no error handling,
this class fails silently.
jonn
*/
class Impersonator
{
public:
	Impersonator();
	~Impersonator();
	void ClaimPrivilege(DWORD dwPrivilege);
	void ReleasePrivilege();
private:
	BOOL m_fImpersonating;
};

/////////////////////////////////////////////////////////////////////
//	ReportCfgMgrError()
//
//	Display a message box reporting the error encountered
//	by the Configuration Manager.
//
//	The error strings are included from \nt\private\windows\pnp\msg\cmapi.rc
//	and IDS_CFGMGR32_BASE may be defined to any number not conflicting with
//	the resources.
//
void ReportCfgMgrError(CONFIGRET cr)
	{
	if (cr > NUM_CR_RESULTS)
		{
		TRACE2("INFO: ReportCfgMgrError() - Error code 0x%X (%u) out of range.\n", cr, cr);
		// ASSERT(FALSE && "ReportCfgMgrError() - Error code out of range");
		cr = CR_FAILURE;
		}
	UINT ids = IDS_CFGMGR32_BASE + cr;
	DWORD dwErr = 0;

	if (cr == CR_OUT_OF_MEMORY)
		{
		ids = 0;
		dwErr = ERROR_NOT_ENOUGH_MEMORY;
		}
	DoServicesErrMsgBox(::GetActiveWindow(), MB_OK | MB_ICONEXCLAMATION, dwErr, ids);
	}


/////////////////////////////////////////////////////////////////////
typedef enum _AdvApiIndex
{
	QUERY_SERVICE_CONFIG_2 = 0,
	CHANGE_SERVICE_CONFIG_2
};

// not subject to localization
static LPCSTR g_apchFunctionNames[] = {
	"QueryServiceConfig2W",
	"ChangeServiceConfig2W",
	NULL
};

// not subject to localization
DynamicDLL g_AdvApi32DLL( _T("ADVAPI32.DLL"), g_apchFunctionNames );

typedef DWORD (*CHANGESERVICECONFIG2PROC) (SC_HANDLE,DWORD,LPVOID);
typedef DWORD (*QUERYSERVICECONFIG2PROC)  (SC_HANDLE,DWORD,LPBYTE,DWORD,LPDWORD);


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//	Constructor for CServicePropertyData object
CServicePropertyData::CServicePropertyData()
	: m_pszServiceName( NULL )
	, m_uFlags( 0 )
	, m_fShowHwProfileInstances( FALSE )
	, m_iSubItemHwProfileStatus( 0 )
	, m_secOriginalAbendCount( 0 )
	, m_daysOriginalAbendCount( 0 )
	, m_daysDisplayAbendCount( 0 )
	, m_msecOriginalRestartService( 0 )
	, m_minOriginalRestartService( 0 )
	, m_minDisplayRestartService( 0 )
	, m_msecOriginalRebootComputer( 0 )
	, m_minOriginalRebootComputer( 0 )
	, m_minDisplayRebootComputer( 0 )
	, m_hwndPropertySheet( NULL )
	{
	// 581167-2002/03/05-JonN Initialize m_lNotifyHandle,
	//   m_pszServiceName, m_uFlags, m_SS, m_fShowHwProfileInstances,
	//   m_iSubItemHwProfileStatus, m_SFA, m_secOriginalAbendCount,
	//   m_daysOriginalAbendCount, m_daysDisplayAbendCount,
	//   m_msecOriginalRestartService, m_minOriginalRestartService,
	//   m_minDisplayRestartService, m_msecOriginalRebootComputer,
	//   m_minOriginalRebootComputer, m_minDisplayRebootComputer,
	//   m_hwndPropertySheet

	m_hMachine = NULL;
	m_hScManager = NULL;
	m_paQSC = NULL;
	m_paSFA = NULL;
	m_paHardwareProfileEntryList = NULL;
	m_fAllSfaTakeNoAction = FALSE;

	m_fQueryServiceConfig2 = g_AdvApi32DLL.LoadFunctionPointers();

	::ZeroMemory(&m_rgSA, sizeof(m_rgSA));
	::ZeroMemory(&m_SS, sizeof(m_SS));
	::ZeroMemory(&m_SFA, sizeof(m_SFA));

	m_pPageGeneral = new CServicePageGeneral;
	m_pPageGeneral->m_pData = this;
	m_pPageHwProfile = new CServicePageHwProfile;
	m_pPageHwProfile->m_pData = this;
	m_pPageRecovery = new CServicePageRecovery;
	m_pPageRecovery->m_pData = this;
	m_pPageRecovery2 = new CServicePageRecovery2; // JonN 4/20/01 348163
	m_pPageRecovery2->m_pData = this;             // JonN 4/20/01 348163
	} // CServicePropertyData::CServicePropertyData()


/////////////////////////////////////////////////////////////////////
CServicePropertyData::~CServicePropertyData()
	{
	// m_spDataObject is a smartpointer
	// Close the machine handle opened by CM_Connect_Machine()
	if (m_hMachine != NULL)
		{
		(void)::CM_Disconnect_Machine(m_hMachine);
		}
	// Close the service control manager database
	if (m_hScManager != NULL)
		{
		(void)::CloseServiceHandle(m_hScManager);
		}

	// Free the allocated pointers
	delete m_paQSC;
	delete m_paSFA;
	FlushHardwareProfileEntries();

	delete m_pPageGeneral;
	delete m_pPageHwProfile;	// 77831: deletion now in place
	delete m_pPageRecovery;
	delete m_pPageRecovery2; // JonN 4/20/01 348163

	// Decrement the reference count of the parent object
	MMCFreeNotifyHandle(m_lNotifyHandle);
	} // CServicePropertyData::~CServicePropertyData()


/////////////////////////////////////////////////////////////////////
//	FInit()
//
//	Initialize the object by connecting to the target machine and
//	openning its service control manager database.
//
//	RETURN VALUES
//	Return TRUE if successful, otherwise FALSE.
//
//	ERRORS
//	- Unable to open service control manager.
//	- Unable to connect to remote machine.
//	- Unable to open service.
//	- Unable to query service data.
//
BOOL
CServicePropertyData::FInit(
	LPDATAOBJECT lpDataObject,
	CONST TCHAR pszMachineName[],			// IN: Machine name
	CONST TCHAR pszServiceName[],			// IN: Service name
	CONST TCHAR pszServiceDisplayName[],	// IN: Service display name (for UI purpose)
	LONG_PTR lNotifyHandle)						// IN: Handle to notify parent
	{
	Assert(lpDataObject != NULL);
	Endorse(pszMachineName == NULL);	// NULL => Local Machine
	Assert(pszServiceName != NULL);
	Assert(pszServiceDisplayName != NULL);

	m_spDataObject = lpDataObject;			// m_pDataObject is a smartpointer
	m_strMachineName = pszMachineName;		// Make a copy of the computer name
	m_strServiceName = pszServiceName;		// Make a copy of the service name

	// NTRAID#NTBUG9-581232-2002/03/05 JonN If m_strServiceName changes,
	// its internal pointer will become invalid.  There is no good reason
	// for m_pszServiceName to exist.  That said, I don't see any instances
	// where this causes a bug with current code, since m_strServiceName
	// does not change after construction.
	m_pszServiceName = m_strServiceName;	// Cast a pointer to the service name

	m_strServiceDisplayName = pszServiceDisplayName;
	m_lNotifyHandle = lNotifyHandle;
	m_strUiMachineName = m_strMachineName.IsEmpty() ? g_strLocalMachine : m_strMachineName;

	Assert(m_hScManager == NULL);
	Assert(m_hMachine == NULL);
	return FQueryServiceInfo();
	} // CServicePropertyData::FInit()


/////////////////////////////////////////////////////////////////////
//	FOpenScManager()
//
//	Open the service control manager database (if not already opened).
//	The idea for such a function is to recover from a broken connection.
//
//	Return TRUE if the service control database was opened successfully,
//	othersise false.
//
BOOL
CServicePropertyData::FOpenScManager()
	{
	if (m_hScManager == NULL)
		{
		m_hScManager = ::OpenSCManager(
			m_strMachineName,
			NULL,
			SC_MANAGER_CONNECT);
		}
	if (m_hScManager == NULL)
		{
		DoServicesErrMsgBox(
			::GetActiveWindow(),
			MB_OK | MB_ICONEXCLAMATION, 
			::GetLastError(),
			IDS_MSG_s_UNABLE_TO_OPEN_SERVICE_DATABASE,
			(LPCTSTR)m_strUiMachineName);
		return FALSE;
		}
	
    // JonN 2/14/01 315244
    // CM_Connect_Machine depends on Remote Registry Service which is
    // not present on Personal.  NULL is OK for local focus, so skip this for
    // local focus.
	if (m_hMachine == NULL && !m_strMachineName.IsEmpty())
		{
		//
		// JonN 02/08/99: CM_Connect_Machine insists on whackwhack in machine names
		// per 288294.
		//
		CString strConnect;
		if (   m_strMachineName[0] != L'\\'
		    && m_strMachineName[1] != L'\\' )
		{
			strConnect = L"\\\\";
		}
		strConnect += m_strMachineName;

		CONFIGRET cr;
		cr = ::CM_Connect_Machine((LPCTSTR)strConnect, OUT &m_hMachine);
		if (cr != CR_SUCCESS)
			{
			Assert(m_hMachine == NULL);
			// This might happen e.g. if PNP is stopped
			ReportCfgMgrError(cr);
			}
		}
	return TRUE;
	} // CServicePropertyData::FOpenScManager()


/////////////////////////////////////////////////////////////////////
//	Create property pages of the service
//
BOOL
CServicePropertyData::CreatePropertyPages(
	LPPROPERTYSHEETCALLBACK pCallback)	// OUT: Object to append property pages
	{
	// ISSUE-2002/03/05-JonN should handle this and also check m_pPage*
	ASSERT(pCallback != NULL);
	HPROPSHEETPAGE hPage;

	MMCPropPageCallback(INOUT &m_pPageGeneral->m_psp);
	hPage = MyCreatePropertySheetPage(IN &m_pPageGeneral->m_psp);
	Report(hPage != NULL);
	if (hPage != NULL)
		pCallback->AddPage(hPage);
	MMCPropPageCallback(INOUT &m_pPageHwProfile->m_psp);
	hPage = MyCreatePropertySheetPage(IN &m_pPageHwProfile->m_psp);
	Report(hPage != NULL);
	if (hPage != NULL)
		pCallback->AddPage(hPage);

	if (m_uFlags & mskfValidSFA)
		{
		// Add the last page only if we were able to successfully
		// load the service failure action data structures.
		Assert(m_fQueryServiceConfig2);
		if (!(m_uFlags & mskfSystemProcess)) // JonN 4/20/01 348163
			{
			MMCPropPageCallback(INOUT &m_pPageRecovery->m_psp);
			hPage = MyCreatePropertySheetPage(IN &m_pPageRecovery->m_psp);
			}
		else
			{
			MMCPropPageCallback(INOUT &m_pPageRecovery2->m_psp);
			hPage = MyCreatePropertySheetPage(IN &m_pPageRecovery2->m_psp);
			}
		Report(hPage != NULL);
		if (hPage != NULL)
			pCallback->AddPage(hPage);
		}

	return TRUE;
	} // CServicePropertyData::CreatePropertyPages()


/////////////////////////////////////////////////////////////////////
//	Query the service for its latest information.
//
//	Return TRUE if ALL the service info could be successfully read.
//	Otherwise return FALSE if any error occured (such as not able to
//	or not able to query a specific key).
//
BOOL
CServicePropertyData::FQueryServiceInfo()
	{
	SC_HANDLE hService = NULL;
	DWORD cbBytesNeeded = 0;
	BOOL fSuccess = TRUE;
	BOOL f;
	DWORD dwErr = 0;

	m_uFlags = mskzValidNone;
	if (!FOpenScManager())
		{
		// Unable to open service control database
		return FALSE;
		}

	TRACE1("INFO: Collecting data for service %s...\n", (LPCTSTR)m_strServiceDisplayName);

	(void)FQueryHardwareProfileEntries();

	
	/*
	**	Open service with querying access-control
	*/
	hService = ::OpenService(
		m_hScManager,
		m_pszServiceName,
		SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG);
	if (hService == NULL)
		{
		DoServicesErrMsgBox(
			::GetActiveWindow(),
			MB_OK | MB_ICONEXCLAMATION, 
			::GetLastError(),
			IDS_MSG_ss_UNABLE_TO_OPEN_READ_SERVICE,
			(LPCTSTR)m_strServiceDisplayName,
			(LPCTSTR)m_strUiMachineName);
		return FALSE;
		}
	/*
	**	Query the service status
	**  JonN 4/20/01 348163
	**  Try to determine whether this service runs in the system process
	*/
	TRACE1("# QueryServiceStatusEx(%s)...\n", m_pszServiceName);
	f = ::QueryServiceStatusEx(
		hService,
		SC_STATUS_PROCESS_INFO,
		(LPBYTE)&m_SS,
		sizeof(m_SS),
		&cbBytesNeeded);
	if (f)
		{
		if (m_SS.dwServiceFlags & SERVICE_RUNS_IN_SYSTEM_PROCESS)
			m_uFlags |= mskfSystemProcess;
		}
	else // QueryServiceStatusEx failed
		{
		TRACE1("# QueryServiceStatus(%s)...\n", m_pszServiceName);
		f = ::QueryServiceStatus(
			hService,
			(LPSERVICE_STATUS)&m_SS);
		}
	if (f)
		{
		m_uFlags |= mskfValidSS;
		}
	else
		{
		DoErrMsgBox(::GetActiveWindow(), MB_OK | MB_ICONEXCLAMATION, ::GetLastError());
		fSuccess = FALSE;
		}
	

	/*
	**	Query the service config
	*/
	TRACE1("# QueryServiceConfig(%s)...\n", m_pszServiceName);
	f = ::QueryServiceConfig(
		hService,
		NULL,
		0,
		OUT &cbBytesNeeded);	// Compute how many bytes we need to allocate
	Report((f == FALSE) && "Query should fail on first attempt");
	Report(cbBytesNeeded > 0);
	cbBytesNeeded += 100;		// Add extra bytes (just in case)
	delete m_paQSC;				// Free previously allocated memory (if any)
	m_paQSC = (QUERY_SERVICE_CONFIG *) new BYTE[cbBytesNeeded];
	f = ::QueryServiceConfig(
		hService,
		OUT m_paQSC,
		cbBytesNeeded,
		OUT IGNORED &cbBytesNeeded);
	if (f)
		{
		m_uFlags |= mskfValidQSC;
		m_strServiceDisplayName = m_paQSC->lpDisplayName;
		m_strLogOnAccountName = m_paQSC->lpServiceStartName;
		}
	else
		{
		DoServicesErrMsgBox(::GetActiveWindow(), MB_OK | MB_ICONEXCLAMATION, ::GetLastError());
		fSuccess = FALSE;
		}

	/*
	**	Query service description
	*/
	if (m_fQueryServiceConfig2)
		{
		TRACE1("# QueryServiceConfig2(%s, SERVICE_CONFIG_DESCRIPTION)...\n", m_pszServiceName);
		union
			{
			// Service description
			SERVICE_DESCRIPTION sd;
			BYTE rgbBufferSd[SERVICE_cchDescriptionMax * sizeof(TCHAR) + 16];
			};
		f = ((QUERYSERVICECONFIG2PROC)g_AdvApi32DLL[QUERY_SERVICE_CONFIG_2])(
			hService,
			SERVICE_CONFIG_DESCRIPTION,
			OUT rgbBufferSd,		// Description of service
			sizeof(rgbBufferSd),
			OUT IGNORED &cbBytesNeeded);
		if (f)
			{
			m_uFlags |= mskfValidDescr;
			Assert(cbBytesNeeded <= sizeof(rgbBufferSd));
			m_strDescription = sd.lpDescription;
			}
		else
			{
			Assert(m_strDescription.IsEmpty());
			// JonN-2002/04/04-544089 handle long DisplayName value
			if ( ERROR_INSUFFICIENT_BUFFER != ::GetLastError() )
				m_fQueryServiceConfig2 = FALSE;
			}
		} // if
	
	/*
	**	Query service failure actions
	*/
	Assert((m_uFlags & mskfValidSFA) == 0);
	if (m_fQueryServiceConfig2)
		{
		TRACE1("# QueryServiceConfig2(%s, SERVICE_CONFIG_FAILURE_ACTIONS)...\n", m_pszServiceName);

		cbBytesNeeded = sizeof(SERVICE_FAILURE_ACTIONS);
		delete m_paSFA;		// Free previously allocated memory (if any)
		m_paSFA = (SERVICE_FAILURE_ACTIONS *) new BYTE[cbBytesNeeded];
		
		f = ((QUERYSERVICECONFIG2PROC)g_AdvApi32DLL[QUERY_SERVICE_CONFIG_2])(
			hService,
			SERVICE_CONFIG_FAILURE_ACTIONS,
			OUT (BYTE *)m_paSFA,
			cbBytesNeeded,
			OUT &cbBytesNeeded);	// Compute how many bytes we need to allocate
		if (!f)
			{
			// API failed, probably because buffer was too small
			dwErr = ::GetLastError();
			if (dwErr == ERROR_INSUFFICIENT_BUFFER)
				{
				Assert(cbBytesNeeded > sizeof(SERVICE_FAILURE_ACTIONS));
				cbBytesNeeded += 100;	// Add extra bytes (just in case)
				delete m_paSFA;			// Free previously allocated memory
				m_paSFA = (SERVICE_FAILURE_ACTIONS *) new BYTE[cbBytesNeeded];

				// Call the API again
				TRACE2("# QueryServiceConfig2(%s, SERVICE_CONFIG_FAILURE_ACTIONS) [cbBytesNeeded=%u]...\n",
					m_pszServiceName, cbBytesNeeded);
				f = ((QUERYSERVICECONFIG2PROC)g_AdvApi32DLL[QUERY_SERVICE_CONFIG_2])(
					hService,
					SERVICE_CONFIG_FAILURE_ACTIONS,
					OUT (BYTE *)m_paSFA,	// Get the actual failure/action data
					cbBytesNeeded,
					OUT IGNORED &cbBytesNeeded);
				if (!f)
					{
					dwErr = ::GetLastError();
					DoServicesErrMsgBox(::GetActiveWindow(), MB_OK | MB_ICONEXCLAMATION, dwErr);
					}
				}
			} // if
		if (f)
			{
			m_uFlags |= mskfValidSFA;
			// Make a copy of the data
			memcpy(OUT &m_SFA, m_paSFA, sizeof(m_SFA));
			}
		else
			{
			Assert(dwErr != ERROR_SUCCESS);
			TRACE2("Unable to get SERVICE_CONFIG_FAILURE_ACTIONS (err=%u).\n  ->Therefore Service Failure Actoin property page won't be added.\n",
				dwErr, m_pszServiceName);
			if (dwErr != 0)
				{
				DoServicesErrMsgBox(::GetActiveWindow(), MB_OK | MB_ICONEXCLAMATION, dwErr);
				}
			::ZeroMemory(OUT &m_SFA, sizeof(m_SFA));
			}

		// Extra processing to avoid nasty bugs
		if (m_SFA.lpsaActions == NULL || m_SFA.cActions < cActionsMax)
			{
			if (m_SFA.cActions >= 1 && m_SFA.lpsaActions != NULL)
				{
				// 384647: We need to fill in something for the latter actions
				// make them the same as the last real action
				memcpy(OUT &(m_rgSA[0]),
				       m_SFA.lpsaActions,
				       m_SFA.cActions*sizeof(SC_ACTION));
				for (int i = m_SFA.cActions; i < cActionsMax; i++)
					{
					memcpy(OUT &(m_rgSA[i]),
					       &(m_SFA.lpsaActions[m_SFA.cActions-1]),
					       sizeof(SC_ACTION) );
					}
				}
			m_SFA.lpsaActions = m_rgSA;		// Use an alternative failure/action array
			m_SFA.cActions = cActionsMax;
			}
		m_strRunFileCommand = m_SFA.lpCommand;
		m_strRebootMessage = m_SFA.lpRebootMsg;

		// Convert time units for the UI
		m_secOriginalAbendCount = m_SFA.dwResetPeriod;
		m_daysOriginalAbendCount = CvtSecondsIntoDays(m_secOriginalAbendCount);
		m_daysDisplayAbendCount = m_daysOriginalAbendCount;

		m_msecOriginalRestartService =
				GetDelayForActionType(SC_ACTION_RESTART, OUT &f);
		if (!f) // 1 minute default
			m_msecOriginalRestartService = CvtMinutesIntoMilliseconds(1);
		m_minOriginalRestartService = CvtMillisecondsIntoMinutes(m_msecOriginalRestartService);
		m_minDisplayRestartService = m_minOriginalRestartService;

		m_msecOriginalRebootComputer =
				GetDelayForActionType(SC_ACTION_REBOOT, OUT &f);
		if (!f) // 1 minute default
			m_msecOriginalRebootComputer = CvtMinutesIntoMilliseconds(1);
		m_minOriginalRebootComputer = CvtMillisecondsIntoMinutes(m_msecOriginalRebootComputer);
		m_minDisplayRebootComputer = m_minOriginalRebootComputer;

		// Check wherever all action type are "None"
		m_fAllSfaTakeNoAction = FAllSfaTakeNoAction();
		} // if (m_fQueryServiceConfig2)

	VERIFY(::CloseServiceHandle(hService));
	return fSuccess;
	} // CServicePropertyData::FQueryServiceInfo()


/////////////////////////////////////////////////////////////////////
//	FUpdateServiceInfo()
//
//	Return TRUE if ALL the modified data were successfully written.
//	Return FALSE if any error occured.
//
// ISSUE-2002/03/05-JonN This function should reset the dirty flags when
//   it successfully writes data
//
BOOL
CServicePropertyData::FUpdateServiceInfo()
	{
	SC_HANDLE hService = NULL;
	BOOL fSuccess = TRUE;
	BOOL f;
    BOOL fSkipPrivEnable = FALSE;

	TRACE1("INFO: Updating data for service %s...\n", (LPCTSTR)m_strServiceDisplayName);
	// Re-open service control manager (in case it was closed)
	if (!FOpenScManager())
		{
		return FALSE;
		}

	BOOL fRebootAction = FALSE;
	BOOL fRestartAction = FALSE;
	BOOL fChangedLogonAccountMessage = FALSE;
	if (m_uFlags & mskfValidSFA)
		{
		fRebootAction  = !!QueryUsesActionType(SC_ACTION_REBOOT);
		fRestartAction = !!QueryUsesActionType(SC_ACTION_RESTART);
		}
	/*
	**	Open service with write access
	**
	**  CODEWORK Could provide a more specific error message
	**    if SERVICE_CHANGE_CONFIG is available but not SERVICE_START
	*/
	hService = ::OpenService(
		m_hScManager,
		m_pszServiceName,
		SERVICE_CHANGE_CONFIG |
		SERVICE_QUERY_STATUS | 
		((fRestartAction)?SERVICE_START:0) );
	if (hService == NULL)
		{
		DoServicesErrMsgBox(
			::GetActiveWindow(),
			MB_OK | MB_ICONEXCLAMATION, 
			::GetLastError(),
			IDS_MSG_ss_UNABLE_TO_OPEN_WRITE_SERVICE,
			(LPCTSTR)m_strServiceName,
			(LPCTSTR)m_strUiMachineName);
		return FALSE;
		}

	if (m_uFlags & (
#ifdef EDIT_DISPLAY_NAME_373025
			mskfDirtyDisplayName |
#endif // EDIT_DISPLAY_NAME_373025
			mskfDirtyStartupType |
			mskfDirtyAccountName |
			mskfDirtyPassword |
			mskfDirtySvcType))
		{
		TRACE1("# ChangeServiceConfig(%s)...\n", m_pszServiceName);
		Assert(m_paQSC != NULL);
		f = ::ChangeServiceConfig(
			hService,					// Handle to service 
			(m_uFlags & mskfDirtySvcType) ? m_paQSC->dwServiceType : SERVICE_NO_CHANGE,		// Type of service 
			(m_uFlags & mskfDirtyStartupType) ? m_paQSC->dwStartType : SERVICE_NO_CHANGE,	// When/How to start service
			SERVICE_NO_CHANGE, // dwErrorControl - severity if service fails to start 
			NULL, // Pointer to service binary file name 
			NULL, // lpLoadOrderGroup - pointer to load ordering group name 
			NULL, // lpdwTagId - pointer to variable to get tag identifier 
			NULL, // lpDependencies - pointer to array of dependency names 
			(m_uFlags & mskfDirtyAccountName) ? (LPCTSTR)m_strLogOnAccountName : NULL, // Pointer to account name of service 
			(m_uFlags & mskfDirtyPassword) ? (LPCTSTR)m_strPassword : NULL, // Pointer to password for service account
			m_strServiceDisplayName);
			
		if (!f)
			{
			DWORD dwErr = ::GetLastError();
			Assert(dwErr != ERROR_SUCCESS);
			TRACE2("ERR: ChangeServiceConfig(%s) failed. err=%u.\n",
				m_pszServiceName, dwErr);

            if ( ERROR_INVALID_SERVICE_ACCOUNT == dwErr && 
                    (m_paQSC->dwServiceType & SERVICE_WIN32_SHARE_PROCESS))
            {
		        DoServicesErrMsgBox(
			        ::GetActiveWindow(),
			        MB_OK | MB_ICONEXCLAMATION,
			        dwErr,
			        IDS_MSG_s_UNABLE_TO_OPEN_WRITE_ACCT_INFO_DOWNLEVEL,
			        (LPCTSTR)m_strServiceName,
			        (LPCTSTR)m_strLogOnAccountName,
			        (LPCTSTR)m_strUiMachineName);
            }
            else
			    DoServicesErrMsgBox(::GetActiveWindow(), MB_OK | MB_ICONEXCLAMATION, dwErr);
			    fSkipPrivEnable = TRUE;
			fSuccess = FALSE;
			}
		else if (m_uFlags & mskfDirtyAccountName)
			{
			fChangedLogonAccountMessage = TRUE;
			}
		} // if

#ifdef EDIT_DISPLAY_NAME_373025
	if (   (m_uFlags & mskfDirtyDescription)
        && m_fQueryServiceConfig2) //  // JonN 03/07/00: PREFIX 56276
		{
		/*
		**	Write the service description
		*/
		TRACE1("# ChangeServiceConfig2(%s, SERVICE_CONFIG_DESCRIPTION)...\n", m_pszServiceName);
		SERVICE_DESCRIPTION sd;
		sd.lpDescription = const_cast<LPTSTR>((LPCTSTR)m_strDescription);
		f = ((CHANGESERVICECONFIG2PROC)g_AdvApi32DLL[CHANGE_SERVICE_CONFIG_2])(
			hService,
			SERVICE_CONFIG_DESCRIPTION,
			IN &sd);
		if (!f)
			{
			DoServicesErrMsgBox(::GetActiveWindow(), MB_OK | MB_ICONEXCLAMATION, ::GetLastError());
			fSuccess = FALSE;
			} // if
		} // if
#endif // EDIT_DISPLAY_NAME_373025

	if (m_uFlags & mskfDirtyActionType)
		{
		// The idea here is to find out if any of the action type has
		// been modified by the user.  For instance, the user may
		// change the action type to a specific action and then set
		// it back to where it was originally.
		if (m_fAllSfaTakeNoAction && FAllSfaTakeNoAction())
			{
			TRACE0("# No changes detected in Recovery Action Type");
			// Turn off the mskfDirtyActionType flag
			m_uFlags &= ~mskfDirtyActionType;
			}
		} // if
	if ((m_uFlags & (mskfDirtySFA | mskfDirtyRunFile | mskfDirtyRebootMessage | mskfDirtyActionType))
         && m_fQueryServiceConfig2) // JonN 03/07/00: PREFIX 56276
		{
		/*
		**	Write the service failure actions
		*/

		/*
		AnirudhS 1/24/97
		Sure, [zero is] a reasonable default delay time to display
		[for SC_ACTION_RUN_COMMAND].
		Or, you could make it something like 5 seconds or whatever.
		The point of the delay time is to reduce the CPU impact
		of a service that continuously crashes and gets restarted.
		This makes the most sense for SC_ACTION_RESTART.
		For SC_ACTION_RUN_COMMAND the admin could have the command
		itself introduce its own delay.
		*/
		TRACE1("# ChangeServiceConfig2(%s, SERVICE_CONFIG_FAILURE_ACTIONS)...\n", m_pszServiceName);

		Assert(m_fQueryServiceConfig2);
		Assert(m_uFlags & mskfValidSFA);

		UINT secNewAbendCount = m_secOriginalAbendCount;
        if (m_daysDisplayAbendCount != m_daysOriginalAbendCount)
			secNewAbendCount = CvtDaysIntoSeconds(m_daysDisplayAbendCount);
		UINT msecNewRestartService = m_msecOriginalRestartService;
		if (m_minDisplayRestartService != m_minOriginalRestartService)
			msecNewRestartService = CvtMinutesIntoMilliseconds(m_minDisplayRestartService);
		UINT msecNewRebootComputer = m_msecOriginalRebootComputer;
		if (m_minDisplayRebootComputer != m_minOriginalRebootComputer)
			msecNewRebootComputer = CvtMinutesIntoMilliseconds(m_minDisplayRebootComputer);

		m_SFA.dwResetPeriod = secNewAbendCount;
		SetDelayForActionType(SC_ACTION_RESTART, msecNewRestartService);
		SetDelayForActionType(SC_ACTION_RUN_COMMAND, 0);
		SetDelayForActionType(SC_ACTION_REBOOT, msecNewRebootComputer);
		m_SFA.lpCommand = (m_uFlags & mskfDirtyRunFile) ? (LPTSTR)(LPCTSTR)m_strRunFileCommand : NULL;
		m_SFA.lpRebootMsg = (m_uFlags & mskfDirtyRebootMessage) ? (LPTSTR)(LPCTSTR)m_strRebootMessage : NULL;

		//
		// The Service Controller will not permit us to set any
		// service failure action to Reboot unless our process token
		// has SE_SHUTDOWN_PRIVILEGE.
		//
		Impersonator priv;
		if (fRebootAction)
			priv.ClaimPrivilege(SE_SHUTDOWN_PRIVILEGE);

		f = ((CHANGESERVICECONFIG2PROC)g_AdvApi32DLL[CHANGE_SERVICE_CONFIG_2])(
			hService,
			SERVICE_CONFIG_FAILURE_ACTIONS,
			IN (void *)&m_SFA);
		if (!f)
			{
			DoServicesErrMsgBox(::GetActiveWindow(), MB_OK | MB_ICONEXCLAMATION, ::GetLastError());
			fSuccess = FALSE;
			} // if
		else
			{
			// We have successfully written the data, so refresh flag m_fAllSfaTakeNoAction
			m_secOriginalAbendCount = secNewAbendCount;
			m_daysOriginalAbendCount = m_daysDisplayAbendCount;
			m_msecOriginalRestartService = msecNewRestartService;
			m_minOriginalRestartService = m_minDisplayRestartService;
			m_msecOriginalRebootComputer = msecNewRebootComputer;
			m_minOriginalRebootComputer = m_minDisplayRebootComputer;
			m_fAllSfaTakeNoAction = FAllSfaTakeNoAction();
			}
		} // if

	if (!fSkipPrivEnable && (m_uFlags & mskfDirtyAccountName) &&
		(0 != lstrcmpi(m_strLogOnAccountName,_T("LocalSystem"))) ) // CODEWORK 317039
		{
		/*
		**	Make sure there is an LSA account with POLICY_MODE_SERVICE privilege
		**  This function reports its own errors, failure is only advisory
		*/
		FCheckLSAAccount();
		} // if

	if (fChangedLogonAccountMessage && hService)
		{
		// check whether the service is running
		SERVICE_STATUS ss;
		if (!::QueryServiceStatus(hService, OUT &ss))
			{
			TRACE3("QueryServiceStatus(%s [hService=%p]) failed. err=%u.\n",
				m_pszServiceName, hService, GetLastError());
			}
		else if (SERVICE_STOPPED == ss.dwCurrentState)
			{
			// the service is stopped so there is no need for this message
			// when in doubt (SERVICE_anythingelse), go ahead and display the message
			fChangedLogonAccountMessage = FALSE;
			}
		}
	VERIFY(::CloseServiceHandle(hService));
	NotifySnapInParent();
	if (fChangedLogonAccountMessage)
		{
		DoServicesErrMsgBox(
			::GetActiveWindow(), MB_OK | MB_ICONEXCLAMATION,
			0, IDS_CHANGED_LOGON_NAME);
		}
	return fSuccess;
	} // FUpdateServiceInfo()


/////////////////////////////////////////////////////////////////////
//	FOnApply()
//
//	Return FALSE if some data could not be written.
//	Otherwise return TRUE.
//
BOOL CServicePropertyData::FOnApply()
	{
	BOOL fSuccess = TRUE;
	if (!FChangeHardwareProfileEntries())
		{
		// Error writing the modified hardware profile(s)
		fSuccess = FALSE;
		}
	if ((m_uFlags & mskmDirtyAll) == 0)
		{
		// Nothing has been modified, so we are done
		return fSuccess;
		}
	if (!FUpdateServiceInfo())
		{
		fSuccess = FALSE;
		}
	if (fSuccess)
		{
		(void)FQueryServiceInfo();
		}
	return fSuccess;
	} // FOnApply()


/////////////////////////////////////////////////////////////////////
//	NotifySnapInParent()
//
//	This function is used to notify the parent the properties has
//	been modified.  The parent will then refresh the list.
//
//  This notifcation is asynchronous.  The recipient of this
//  notification required to release the data object.
//
void
CServicePropertyData::NotifySnapInParent()
	{
	/*
	FILEMGMTPROPERTYCHANGE propchange;
	::ZeroMemory( &propchange, sizeof(propchange) );
	propchange.fServiceChange = TRUE;
	propchange.lpcszMachineName = (LPCTSTR)m_strMachineName;

	// Tell all views to clear contents
	propchange.fClear = TRUE;
	MMCPropertyChangeNotify(
		m_lNotifyHandle,
		reinterpret_cast<long>(&propchange) );

	// Tell all views to reload contents
	propchange.fClear = FALSE;
	MMCPropertyChangeNotify(
		m_lNotifyHandle,
		reinterpret_cast<long>(&propchange) );
	*/
	Assert(m_spDataObject != NULL);
	(void) m_spDataObject->AddRef();
	MMCPropertyChangeNotify(
		m_lNotifyHandle,
		reinterpret_cast<LPARAM>((LPDATAOBJECT)m_spDataObject) );
	}

/////////////////////////////////////////////////////////////////////
void
CServicePropertyData::FlushHardwareProfileEntries()
	{
	delete m_paHardwareProfileEntryList;	// Recursively delete hardware profile entries
	m_paHardwareProfileEntryList = NULL;
	}


/////////////////////////////////////////////////////////////////////
//	FQueryHardwareProfileEntries()
//
//	Read the available hardware profiles and device instances
//	used to fill in the listbox.
//
//	Return FALSE if an error occured, otherwise TRUE.
//	If no hardware profiles are available return TRUE.
//
BOOL
CServicePropertyData::FQueryHardwareProfileEntries()
	{
	Endorse(m_hMachine == NULL); // This might happen e.g. if PNP is stopped
	FlushHardwareProfileEntries();
	Assert(m_paHardwareProfileEntryList == NULL);
	if (m_hMachine == NULL && !m_strMachineName.IsEmpty()) // JonN 2/14/01 315244
		{
		// Cannot enumerate hw profiles
		return FALSE;
		}

	BOOL fSuccess = FALSE;
	CONFIGRET cr;
	
	ULONG cchDeviceList = 0;	// Number of characters required to store a list of all device identifiers
	TCHAR * pagrszDeviceNameList = NULL;	// Pointer to allocated group of strings
	LPTSTR * pargzpszDeviceName = NULL;		// Pointer to allocated array of strings
	CString * pargstrDeviceNameFriendly = NULL;	// Pointer to allocated array of CString

	DEVNODE hDevNodeInst;		// Handle to a device node instance
	INT iDevNodeInst;			// Index of the device node instance
	INT cDevNodeInst = 0;		// Number of device node instances
	INT iHwProfile;
		
	// Get the size, in characters, of a list of device identifiers
	// necessary for a call to CM_Get_Device_ID_List()
	cr = ::CM_Get_Device_ID_List_Size_Ex(
		OUT &cchDeviceList,
		IN m_pszServiceName,
		IN CM_GETIDLIST_FILTER_SERVICE,
		IN m_hMachine);
	if (cr != CR_SUCCESS)
		{
		if (cr == CR_NO_SUCH_VALUE)
			{
			// This service cannot be disabled for hardware profiles
			Assert(m_paHardwareProfileEntryList == NULL);	// No hardware profiles in the list
			return TRUE;
            }
		else
			{
			ReportCfgMgrError(cr);
			}
		return FALSE;
		} // if
	
	// Allocate memory for the device list
	cchDeviceList += 100;	// Just in case
	// "pagrsz" == "p" + "a" + "gr" + "sz" == pointer to allocated group of string zero terminated
	pagrszDeviceNameList = new TCHAR[cchDeviceList];

	// Get the list of devices in its grsz format
	cr = ::CM_Get_Device_ID_List_Ex(
		IN m_pszServiceName,
		OUT pagrszDeviceNameList,
		IN cchDeviceList,
		CM_GETIDLIST_FILTER_SERVICE,
		m_hMachine);
	if (cr != CR_SUCCESS)
		{
		ReportCfgMgrError(cr);
		goto DoCleanup;
		}

	// Parse the group of strings int an array of strings
	pargzpszDeviceName = PargzpszFromPgrsz(pagrszDeviceNameList, OUT &cDevNodeInst);
	Assert(cDevNodeInst > 0);
	// Now allocate an array of CStrings for the friendly names
	pargstrDeviceNameFriendly = new CString[cDevNodeInst];
	// We only show the hw profile instance if there are more than one node instance
	m_fShowHwProfileInstances = (cDevNodeInst > 1);
	// m_fShowHwProfileInstances = TRUE;
	// 581256-2002/03/05 JonN You can't reliably add a BOOL to an INT
	m_iSubItemHwProfileStatus = 1 + (m_fShowHwProfileInstances ? 1 : 0);
	
	for (iDevNodeInst = 0; iDevNodeInst < cDevNodeInst; iDevNodeInst++)
		{
		Assert(pargzpszDeviceName[iDevNodeInst] != NULL);	// Little consistency check

		TCHAR szFriendlyNameT[2048];		// Temporary buffer to hold friendly name
		ULONG cbBufferLen = sizeof(szFriendlyNameT);

		// Get the handle of the device instance that corresponds
		// to the specified device identifier.
		// ISSUE-2002/03/05-JonN We never free hDevNodeInst, is it unnecessary?
		cr = ::CM_Locate_DevNode_Ex(
			OUT &hDevNodeInst,
			IN pargzpszDeviceName[iDevNodeInst],
			CM_LOCATE_DEVNODE_PHANTOM,
			m_hMachine);
		if (cr != CR_SUCCESS)
			{
			ReportCfgMgrError(cr);
			goto DoCleanup;
			}

		szFriendlyNameT[0] = '\0';
		// Get the friendly name of the device node
		cr = ::CM_Get_DevNode_Registry_Property_Ex(
			hDevNodeInst,
			CM_DRP_FRIENDLYNAME,
			NULL,
			OUT szFriendlyNameT,
			INOUT &cbBufferLen,
			0,
			m_hMachine);
		Report(cr != CR_BUFFER_SMALL);
		if (cr == CR_NO_SUCH_VALUE || cr == CR_INVALID_PROPERTY)
			{
			// No friendly name for device node, so try to get the description instead
			cbBufferLen = sizeof(szFriendlyNameT);
			cr = ::CM_Get_DevNode_Registry_Property_Ex(
				hDevNodeInst,
				CM_DRP_DEVICEDESC,
				NULL,
				OUT szFriendlyNameT,
				INOUT &cbBufferLen,
				0,
				m_hMachine);
			Report(cr != CR_BUFFER_SMALL);
			Report(!(cr == CR_NO_SUCH_VALUE || cr == CR_INVALID_PROPERTY) && "Device node should have a description");
			if (cr != CR_SUCCESS)
				{
				ReportCfgMgrError(cr);
				goto DoCleanup;
				}
			} // if
		if (szFriendlyNameT[0] == '\0')
			{
			Report(FALSE && "Device node should have a friendly name");
			// Make a 'friendly' name ourselves
			// 581272-2002/06/14 JonN fixed potential buffer overrun
			//   if the device name string is too long
			lstrcpyn(OUT szFriendlyNameT,
			         pargzpszDeviceName[iDevNodeInst],
			         sizeof(szFriendlyNameT)/sizeof(szFriendlyNameT[0]) );
			}
		// Make a copy of the friendly name
		pargstrDeviceNameFriendly[iDevNodeInst] = szFriendlyNameT;
		} // for

	// 2002/03/19-JonN changed from 10000000 to 10000
	#define MAX_HW_PROFILES		10000	// Just in case of an infinite loop
	for (iHwProfile = 0; iHwProfile < MAX_HW_PROFILES; iHwProfile++)
		{
		HWPROFILEINFO hpi;

		cr = ::CM_Get_Hardware_Profile_Info_Ex(
			iHwProfile,
			OUT &hpi,
			0,
			m_hMachine);
		if (cr == CR_NO_MORE_HW_PROFILES)
			break;
		if (cr != CR_SUCCESS)
			{
			if (cr == 0xBAADF00D)
				{
				TRACE0("INFO: CM_Get_Hardware_Profile_Info_Ex() returned error 0xBAADF00D.\n");
				// This is a workaround for bug #69142: CM_Get_Hardware_Profile_Info_Ex() returns error 0xBAADF00D.
				Assert((m_uFlags & mskfErrorBAADF00D) == 0);
				m_uFlags |= mskfErrorBAADF00D;
				}
			else
				{
				ReportCfgMgrError(cr);
				}
			goto DoCleanup;
			}
		for (iDevNodeInst = 0; iDevNodeInst < cDevNodeInst; iDevNodeInst++)
			{
			Assert(pargzpszDeviceName[iDevNodeInst] != NULL);	// Little consistency check

			ULONG uHwFlags = 0;
			// Get the hardware profile flags for the given device instance
			cr = ::CM_Get_HW_Prof_Flags_Ex(
				IN pargzpszDeviceName[iDevNodeInst],
				IN hpi.HWPI_ulHWProfile,
				OUT &uHwFlags,
				0,
				m_hMachine);
			if (cr != CR_SUCCESS)
				{
				ReportCfgMgrError(cr);
				goto DoCleanup;
				}
			// If this profile/devinst is marked as 'removed'
			// then don't display it into the UI.
			if (uHwFlags & CSCONFIGFLAG_DO_NOT_CREATE)
				continue;

			CHardwareProfileEntry * pHPE = new CHardwareProfileEntry(
				&hpi,
				uHwFlags,
				pargzpszDeviceName[iDevNodeInst],
				&pargstrDeviceNameFriendly[iDevNodeInst]);
			pHPE->m_pNext = m_paHardwareProfileEntryList;
			m_paHardwareProfileEntryList = pHPE;

			} // for (each device instance)
		} // for (each hardware profile)
	
        Assert(fSuccess == FALSE);
        fSuccess = TRUE;
DoCleanup:
	// Free memory allocated by routine
	// 581272 JonN 2002/04/03 pargzpszDeviceName contains pointers into
	//   pagrszDeviceNameList, so delete pargzpszDeviceName first.
	delete pargzpszDeviceName;
	delete []pagrszDeviceNameList;
	delete []pargstrDeviceNameFriendly;
	return fSuccess;
	} // FQueryHardwareProfileEntries()


/////////////////////////////////////////////////////////////////////
//	Write the modified hardware profile(s) back into
//	the registry.
BOOL
CServicePropertyData::FChangeHardwareProfileEntries()
	{
	CHardwareProfileEntry * pHPE;
	BOOL fSuccess = TRUE;

	for (pHPE = m_paHardwareProfileEntryList; pHPE != NULL; pHPE = pHPE->m_pNext)
		{
		if (!pHPE->FWriteHardwareProfile(m_hMachine))
			{
			// Unable to write the given hw profile
			fSuccess = FALSE;
			}
		} // for

	return fSuccess;
	} // FChangeHardwareProfileEntries()


/////////////////////////////////////////////////////////////////////	
//	Find the delay (in milliseconds) unit for a given action type
//
//	Return the delay of the first matching actiontype,
//	Otherwise return 0 and set content of pfFound to FALSE.
//
UINT
CServicePropertyData::GetDelayForActionType(
	SC_ACTION_TYPE actionType,
	BOOL * pfDelayFound)		// OUT: OPTIONAL: TRUE => If delay was found in one actiontype
	{
	for (UINT iAction = 0; iAction < m_SFA.cActions; iAction++)
		{
		Assert(m_SFA.lpsaActions != NULL);
		if (m_SFA.lpsaActions[iAction].Type == actionType)
			{
			if (pfDelayFound != NULL)
				*pfDelayFound = TRUE;
			return m_SFA.lpsaActions[iAction].Delay;
			}
		} // for
	// Delay not found
	if (pfDelayFound != NULL)
		*pfDelayFound = FALSE;
	return 0;
	} // CServicePropertyData::GetDelayForActionType()


/////////////////////////////////////////////////////////////////////
//	Set the delay for every matching actiontype.
//
void CServicePropertyData::SetDelayForActionType(SC_ACTION_TYPE actionType, UINT uDelay)
	{
	for (UINT iAction = 0; iAction < m_SFA.cActions; iAction++)
		{
		Assert(m_SFA.lpsaActions != NULL);
		if (m_SFA.lpsaActions[iAction].Type == actionType)
			m_SFA.lpsaActions[iAction].Delay = uDelay;
		} // for
	} // CServicePropertyData::SetDelayForActionType()


/////////////////////////////////////////////////////////////////////
//	Count the number of actiontype used in the SFA structure.
//
//	Return zero if the actiontype is not in use.
//
UINT CServicePropertyData::QueryUsesActionType(SC_ACTION_TYPE actionType)
	{
	UINT cActionType = 0;		// Number
	for (UINT iAction = 0; iAction < m_SFA.cActions; iAction++)
		{
		Assert(m_SFA.lpsaActions != NULL);
		if (m_SFA.lpsaActions[iAction].Type == actionType)
			cActionType++;
		} // for
	return cActionType;
	} // CServicePropertyData::QueryUsesActionType()


/////////////////////////////////////////////////////////////////////
//	FAllSfaTakeNoAction()
//
//	Return TRUE if all the Service Faillure Actions are SC_ACTION_NONE.
//	If any of the SFA is other than SC_ACTION_NONE, return TRUE.
//
BOOL
CServicePropertyData::FAllSfaTakeNoAction()
	{
	Report(QueryUsesActionType(SC_ACTION_NONE) <= cActionsMax &&
		"UNSUAL: Unsupported number of action types");
	return QueryUsesActionType(SC_ACTION_NONE) == cActionsMax;
	} // CServicePropertyData::FAllSfaTakeNoAction()


/////////////////////////////////////////////////////////////////////
//	Update the caption of the property sheet to reflect changes
//	in the service display name.
void CServicePropertyData::UpdateCaption()
	{
	Assert(IsWindow(m_hwndPropertySheet));
	::SetWindowTextPrintf(
		m_hwndPropertySheet,
		IDS_ss_PROPERTIES_ON,
		(LPCTSTR)m_strServiceDisplayName,
		(LPCTSTR)m_strUiMachineName);
	}


/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
CHardwareProfileEntry::CHardwareProfileEntry(
	IN CONST HWPROFILEINFO * phpi,
	IN ULONG uHwFlags,
	TCHAR * pszDeviceName,
	CString * pstrDeviceNameFriendly)
	{
	Assert(phpi != NULL);
	Assert(pszDeviceName != NULL);
	Assert(pstrDeviceNameFriendly != NULL);

	m_pNext = NULL; // 2002/03/05-JonN
	memcpy(OUT &m_hpi, phpi, sizeof(m_hpi));
	m_uHwFlags = uHwFlags;
	m_strDeviceName = pszDeviceName;
	m_strDeviceNameFriendly = *pstrDeviceNameFriendly;
	Assert(!m_strDeviceName.IsEmpty());
	// ISSUE-2002/03/07-JonN eliminate m_fReadOnly, it is not used
	m_fReadOnly = FALSE;
	m_fEnabled = !(uHwFlags & CSCONFIGFLAG_DISABLED);
	} // CHardwareProfileEntry()


/////////////////////////////////////////////////////////////////////
CHardwareProfileEntry::~CHardwareProfileEntry()
	{
	// Recursively delete the siblings
	delete m_pNext;
	}

/////////////////////////////////////////////////////////////////////
//	FWriteHardwareProfile()
//
//	Write the current hardware profile back into the
//	registry.
//
//	Return FALSE if an error occured, otherwise TRUE
//
BOOL
CHardwareProfileEntry::FWriteHardwareProfile(HMACHINE hMachine)
	{
	Endorse(hMachine == NULL); // JonN 2/14/01 315244

	CONFIGRET cr;
	ULONG uHwFlags;

	uHwFlags = m_uHwFlags | CSCONFIGFLAG_DISABLED;
	if (m_fEnabled)
		uHwFlags &= ~CSCONFIGFLAG_DISABLED;
	if (m_uHwFlags == uHwFlags)
		{
		// Flags have not been modified, nothing to do
		return TRUE;
		}

	// Write the hardware profile flag
	cr = ::CM_Set_HW_Prof_Flags_Ex(
		IN const_cast<LPTSTR>((LPCTSTR)m_strDeviceName),
		IN m_hpi.HWPI_ulHWProfile,
		IN uHwFlags,
		IN 0,
		IN hMachine);
	if (cr != CR_SUCCESS && cr != CR_NEED_RESTART)
		{
		ReportCfgMgrError(cr);
		return FALSE; // JonN 10/3/01 476415
		}
	m_uHwFlags = uHwFlags;
	m_fEnabled = !(uHwFlags & CSCONFIGFLAG_DISABLED);

	// Read it back (just in case of an error)
	cr = ::CM_Get_HW_Prof_Flags_Ex(
		IN const_cast<LPTSTR>((LPCTSTR)m_strDeviceName),
		IN m_hpi.HWPI_ulHWProfile,
		OUT &uHwFlags,
		IN 0,
		IN hMachine);
	if (cr != CR_SUCCESS)
		{
		ReportCfgMgrError(cr);
		return FALSE;
		}

	if (uHwFlags != m_uHwFlags)
		{
		Report(FALSE && "Inconsistent hardware profile flags from registry");
		}
	m_uHwFlags = uHwFlags;
	m_fEnabled = !(uHwFlags & CSCONFIGFLAG_DISABLED);
	return TRUE;
	} // FWriteHardwareProfile()

/* ISSUE-2002/03/06-JonN not used
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
BOOL MyChangeServiceConfig2(
	BOOL* pfDllPresentLocally, // will set to FALSE if new ADVAPI32 not present
    SC_HANDLE hService,	// handle to service 
    DWORD dwInfoLevel,	// which configuration information to change
    LPVOID lpInfo		// pointer to configuration information
   )
{
	*pfDllPresentLocally = g_AdvApi32DLL.LoadFunctionPointers();
	if ( *pfDllPresentLocally )
	{
		return ((CHANGESERVICECONFIG2PROC)g_AdvApi32DLL[CHANGE_SERVICE_CONFIG_2])(
			hService,
			dwInfoLevel,
			lpInfo );
	}
	return FALSE;
}
*/

BOOL MyQueryServiceConfig2(
	BOOL* pfDllPresentLocally, // will set to FALSE if new ADVAPI32 not present
    SC_HANDLE hService,	// handle of service 
    DWORD dwInfoLevel,		// which configuration data is requested
    LPBYTE lpBuffer,		// pointer to service configuration buffer
    DWORD cbBufSize,		// size of service configuration buffer 
    LPDWORD pcbBytesNeeded 	// address of variable for bytes needed  
   )
{
	*pfDllPresentLocally = g_AdvApi32DLL.LoadFunctionPointers();
	if ( *pfDllPresentLocally )
	{
		return ((QUERYSERVICECONFIG2PROC)g_AdvApi32DLL[QUERY_SERVICE_CONFIG_2])(
			hService,
			dwInfoLevel,
			lpBuffer,
			cbBufSize,
			pcbBytesNeeded );
	}
	return FALSE;
}

// core code taken from \nt\private\windows\base\advapi\logon32.c

typedef enum _NtRtlIndex
{
	RTL_IMPERSONATE_SELF = 0,
	RTL_ADJUST_PRIVILEGE
};

// not subject to localization
static LPCSTR g_apchNtRtlFunctionNames[] = {
	"RtlImpersonateSelf",
	"RtlAdjustPrivilege",
	NULL
};

// not subject to localization
DynamicDLL g_NtRtlDLL( _T("NTDLL.DLL"), g_apchNtRtlFunctionNames );

/*
NTSYSAPI
NTSTATUS
NTAPI
RtlImpersonateSelf(
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );
NTSYSAPI
NTSTATUS
NTAPI
RtlAdjustPrivilege(
    ULONG Privilege,
    BOOLEAN Enable,
    BOOLEAN Client,
    PBOOLEAN WasEnabled
    );
*/

typedef DWORD (*RTLIMPERSONATESELFPROC) (SECURITY_IMPERSONATION_LEVEL);
typedef DWORD (*RTLADJUSTPRIVILEGEPROC) (ULONG,BOOLEAN,BOOLEAN,PBOOLEAN);

Impersonator::Impersonator()
: m_fImpersonating( FALSE )
{
}

void Impersonator::ClaimPrivilege(DWORD dwPrivilege)
{
	if ( !g_NtRtlDLL.LoadFunctionPointers() )
	{
		ASSERT(FALSE); // NTDLL not present?
		return;
	}
	NTSTATUS Status = S_OK;
	if (!m_fImpersonating)
	{
		Status = ((RTLIMPERSONATESELFPROC)g_NtRtlDLL[RTL_IMPERSONATE_SELF])(
			SecurityImpersonation );
		if ( !NT_SUCCESS(Status) )
		{
			ASSERT(FALSE); // probably stacked impersonations
			return;
		}
		m_fImpersonating = TRUE;
	}
	BOOLEAN fWasEnabled = FALSE;
	Status = ((RTLADJUSTPRIVILEGEPROC)g_NtRtlDLL[RTL_ADJUST_PRIVILEGE])(
		dwPrivilege,TRUE,TRUE,&fWasEnabled );
	if ( !NT_SUCCESS(Status) )
	{
		// don't assert
	}
}

void Impersonator::ReleasePrivilege()
{
	if (m_fImpersonating)
	{
		VERIFY( ::RevertToSelf() );
		m_fImpersonating = FALSE;
	}
}

Impersonator::~Impersonator()
{
	ReleasePrivilege();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\svcprop2.cpp ===
/////////////////////////////////////////////////////////////////////////////
//	svcprop2.cpp : implementation file
//
//	This file is used to display the 'log on information' and the
//	'hardware profiles' of a given service.
//
//	HISTORY
//	10-Oct-96	t-danmo		Creation.
//	

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// These strings are not localized
// JonN 4/11/00 17756: Changed behavior so that empty string is displayed in
//              account name field when last logon name was LocalSystem
const TCHAR szLocalSystemAccount[] = _T("LocalSystem");
const TCHAR szPasswordNull[] = _T("               ");	// Empty password

// Array of control Ids to prevent user to change account selection
const UINT rgzidDisableAccountSelection[] = 
	{
	IDC_RADIO_LOGONAS_SYSTEMACCOUNT,
	IDC_RADIO_LOGONAS_THIS_ACCOUNT,
	IDC_EDIT_ACCOUNTNAME,
	IDC_BUTTON_CHOOSE_USER,
	IDC_STATIC_PASSWORD,
	IDC_EDIT_PASSWORD,
	IDC_STATIC_PASSWORD_CONFIRM,
	IDC_EDIT_PASSWORD_CONFIRM,
	0
	};

// Array of control Ids to indicate user to not type a password
const UINT rgzidDisablePassword[] = 
	{
	IDC_EDIT_ACCOUNTNAME,
	IDC_BUTTON_CHOOSE_USER,
	IDC_STATIC_PASSWORD,
	IDC_EDIT_PASSWORD,
	IDC_STATIC_PASSWORD_CONFIRM,
	IDC_EDIT_PASSWORD_CONFIRM,
	0
	};

// Array of control Ids to hide hardware profile listbox and releated buttons
const UINT rgzidHwProfileHide[] =
	{
	// JonN-2002/04/04-583004 suppress static text
	IDC_DESCRIBE_HARDWARE_PROFILES,
	IDC_LIST_HARDWARE_PROFILES,
	IDC_BUTTON_ENABLE,
	IDC_BUTTON_DISABLE,
	0
	};


// Column headers for the hardware profiles
const TColumnHeaderItem rgzHardwareProfileHeader[] =
	{
	{ IDS_SVC_HARDWARE_PROFILE, 75 },
	{ IDS_SVC_STATUS, 24 },
	{ 0, 0 },
	};

const TColumnHeaderItem rgzHardwareProfileHeaderInst[] =
	{
	{ IDS_SVC_HARDWARE_PROFILE, 55 },
	{ IDS_SVC_INSTANCE, 22 },
	{ IDS_SVC_STATUS, 22 },
	{ 0, 0 },
	};


/////////////////////////////////////////////////////////////////////////////
// CServicePageHwProfile property page

IMPLEMENT_DYNCREATE(CServicePageHwProfile, CPropertyPage)

CServicePageHwProfile::CServicePageHwProfile() : CPropertyPage(CServicePageHwProfile::IDD)
	, m_pData( NULL )
{
	// 581167-2002/03/06-JonN initialize m_pData, others probably unnecessary
	//{{AFX_DATA_INIT(CServicePageHwProfile)
	m_fAllowServiceToInteractWithDesktop = FALSE;
	//}}AFX_DATA_INIT
	m_idRadioButton = 0;
	m_fPasswordDirty = FALSE;
}

CServicePageHwProfile::~CServicePageHwProfile()
{
}

void CServicePageHwProfile::DoDataExchange(CDataExchange* pDX)
{
	Assert(m_pData != NULL);
	Assert(m_pData->m_paQSC != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());

	if (!pDX->m_bSaveAndValidate)
		{
		// Determine if service is running under 'local system'
		m_fIsSystemAccount = (m_pData->m_paQSC->lpServiceStartName == NULL) ||
			(lstrcmpi(m_pData->m_strLogOnAccountName, szLocalSystemAccount) == 0);

		m_fAllowServiceToInteractWithDesktop = m_fIsSystemAccount &&
			(m_pData->m_paQSC->dwServiceType & SERVICE_INTERACTIVE_PROCESS);
		// JonN 4/11/00: 17756
		if (m_fIsSystemAccount)
			m_strAccountName.Empty();
		else
			m_strAccountName = m_pData->m_strLogOnAccountName;
		m_strPassword =
			(m_fIsSystemAccount) ? szPasswordNull : m_pData->m_strPassword;
		m_strPasswordConfirm = m_strPassword;

		//
		// JonN 4/10/00
		// 89823: RPC Service:Cannot restart the service when you disable it
		//
		// Do not allow the RpcSs service to change from Local System
		//
		// JonN 10/23/01 472867 also the PlugPlay service
		//
		if ( ( !lstrcmpi(m_pData->m_strServiceName,L"RpcSs") ||
		       !lstrcmpi(m_pData->m_strServiceName,L"PlugPlay") )
		  && m_fIsSystemAccount )
			{
			EnableDlgItem(m_hWnd, IDC_RADIO_LOGONAS_SYSTEMACCOUNT, FALSE);
			EnableDlgItem(m_hWnd, IDC_RADIO_LOGONAS_THIS_ACCOUNT, FALSE);
			}
		} // if

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServicePageHwProfile)
	DDX_Check(pDX, IDC_CHECK_SERVICE_INTERACT_WITH_DESKTOP, m_fAllowServiceToInteractWithDesktop);
	DDX_Text(pDX, IDC_EDIT_ACCOUNTNAME, m_strAccountName);
	DDV_MaxChars(pDX, m_strPassword, DNLEN+UNLEN+1);
	DDX_Text(pDX, IDC_EDIT_PASSWORD, m_strPassword);
	DDV_MaxChars(pDX, m_strPassword, PWLEN);
	DDX_Text(pDX, IDC_EDIT_PASSWORD_CONFIRM, m_strPasswordConfirm);
	DDV_MaxChars(pDX, m_strPasswordConfirm, PWLEN);
	//}}AFX_DATA_MAP
	if (pDX->m_bSaveAndValidate)
		{
		if (!m_fIsSystemAccount)
			{
			TrimString(m_strAccountName);
			if (m_strAccountName.IsEmpty()) // JonN 4/11/00: 17756
				{
				m_fIsSystemAccount = TRUE;
				}
			}
		if (!m_fIsSystemAccount)
			{
			//
			// Log On As "This Account"
			//
			// If not system account, can't interact with desktop
			m_pData->m_paQSC->dwServiceType &= ~SERVICE_INTERACTIVE_PROCESS;
			// Search if the string contains a server name
			// JonN 3/16/99: and if name is not a UPN (bug 280254)
			if (m_strAccountName.FindOneOf(_T("@\\")) < 0)
				{
				// Add ".\" at the beginning
				m_strAccountName = _T(".\\") + m_strAccountName;
				}
			if (m_strPassword != m_strPasswordConfirm)
				{
				DoServicesErrMsgBox(m_hWnd, MB_OK | MB_ICONEXCLAMATION, 0, IDS_MSG_PASSWORD_MISMATCH);
				pDX->Fail();
				Assert(FALSE && "Unreachable code");
				}
			} // if (!m_fIsSystemAccount)

		if (m_fIsSystemAccount)
			{
			//
			// Log On As "System Account"
			//
			if (m_fAllowServiceToInteractWithDesktop)
				m_pData->m_paQSC->dwServiceType |= SERVICE_INTERACTIVE_PROCESS;
			else
				m_pData->m_paQSC->dwServiceType &= ~SERVICE_INTERACTIVE_PROCESS;
			m_strAccountName.Empty();	// JonN 4/11/00: 17756
			m_strPassword.Empty();	// Clear the password (system account don't require password)
			m_fPasswordDirty = FALSE;
			}
		// JonN 4/11/00: 17756
		BOOL fWasSystemAccount = !lstrcmpi(
			m_pData->m_strLogOnAccountName, szLocalSystemAccount);
		BOOL fAccountNameModified = (m_fIsSystemAccount)
			? !fWasSystemAccount
			: (fWasSystemAccount || lstrcmpi(m_strAccountName, m_pData->m_strLogOnAccountName));
		// Check if either the Account Name or password was modified
		// CODEWORK Note that fAccountNameModified will be TRUE if the last write
		//          attempt failed.
		if (fAccountNameModified ||	m_fPasswordDirty)
			{
			if (fAccountNameModified && (m_strPassword == szPasswordNull))
				{
				// Account name modified, but password not changed
				DoServicesErrMsgBox(m_hWnd, MB_OK | MB_ICONEXCLAMATION, 0, IDS_MSG_PASSWORD_EMPTY);
				pDX->PrepareEditCtrl(IDC_EDIT_PASSWORD);
				pDX->Fail();
				Assert(FALSE && "Unreacheable code");
				}
			TRACE0("Service log on account name or password modified...\n");
			m_pData->m_strLogOnAccountName = // JonN 4/11/00: 17756
				(m_fIsSystemAccount) ? szLocalSystemAccount : m_strAccountName;
			m_pData->m_strPassword = m_strPassword;
			// If the account name is changed or the password is changed,
			// then all the following parameters must be re-written
			// to the registry.  Otherwise ChangeServiceConfig() will fail.
			// This is not documented; it is the reality.
			m_pData->SetDirty( (enum CServicePropertyData::_DIRTYFLAGS)
				(CServicePropertyData::mskfDirtyAccountName |
				 CServicePropertyData::mskfDirtyPassword |
				 CServicePropertyData::mskfDirtySvcType) );
			}
		} // if
} // CServicePageHwProfile::DoDataExchange()


BEGIN_MESSAGE_MAP(CServicePageHwProfile, CPropertyPage)
	//{{AFX_MSG_MAP(CServicePageHwProfile)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST_HARDWARE_PROFILES, OnItemChangedListHwProfiles)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST_HARDWARE_PROFILES, OnDblclkListHwProfiles)
	ON_MESSAGE(WM_HELP, OnHelp)
	ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
	ON_BN_CLICKED(IDC_BUTTON_DISABLE, OnButtonDisableHwProfile)
	ON_BN_CLICKED(IDC_BUTTON_ENABLE, OnButtonEnableHwProfile)
	ON_BN_CLICKED(IDC_BUTTON_CHOOSE_USER, OnButtonChooseUser)
	ON_BN_CLICKED(IDC_RADIO_LOGONAS_SYSTEMACCOUNT, OnRadioLogonasSystemAccount)
	ON_BN_CLICKED(IDC_RADIO_LOGONAS_THIS_ACCOUNT, OnRadioLogonasThisAccount)
	ON_BN_CLICKED(IDC_CHECK_SERVICE_INTERACT_WITH_DESKTOP, OnCheckServiceInteractWithDesktop)
	ON_EN_CHANGE(IDC_EDIT_ACCOUNTNAME, OnChangeEditAccountName)
	ON_EN_CHANGE(IDC_EDIT_PASSWORD, OnChangeEditPassword)
	ON_EN_CHANGE(IDC_EDIT_PASSWORD_CONFIRM, OnChangeEditPasswordConfirm)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServicePageHwProfile message handlers

BOOL CServicePageHwProfile::OnInitDialog() 
{
	Assert(m_pData != NULL);
	Assert(m_pData->m_paQSC != NULL);

	if (m_pData->m_paQSC == NULL)
		EndDialog(FALSE);		// Just in case
	m_pData->m_strPassword = szPasswordNull; 
	::LoadString(g_hInstanceSave, IDS_SVC_ENABLED,
		OUT m_szHwProfileEnabled, LENGTH(m_szHwProfileEnabled));
	::LoadString(g_hInstanceSave, IDS_SVC_DISABLED,
		OUT m_szHwProfileDisabled, LENGTH(m_szHwProfileDisabled));
	m_hwndListViewHwProfiles = ::GetDlgItem(m_hWnd, IDC_LIST_HARDWARE_PROFILES);
	if (m_pData->m_paHardwareProfileEntryList != NULL)
		{
		ListView_AddColumnHeaders(m_hwndListViewHwProfiles, m_pData->m_fShowHwProfileInstances
			? rgzHardwareProfileHeaderInst : rgzHardwareProfileHeader);
		BuildHwProfileList();
		}
	else
		{
		// There are no hardware profile(s) in the list, so hide
		// all the controls that have something to do with hardware profiles
		ShowDlgItemGroup(m_hWnd, rgzidHwProfileHide, FALSE);
		}
	CPropertyPage::OnInitDialog();
	return TRUE;
} // OnInitDialog()


/////////////////////////////////////////////////////////////////////
//	Select a given radio button and enable/disable
//	controls depending on which radio button is selected
void CServicePageHwProfile::SelectRadioButton(UINT idRadioButtonNew)
{
	Assert(HGetDlgItem(m_hWnd, idRadioButtonNew));
	
	if (idRadioButtonNew == m_idRadioButton)
		return;
	m_fAllowSetModified = FALSE;
	CheckRadioButton(IDC_RADIO_LOGONAS_SYSTEMACCOUNT, IDC_RADIO_LOGONAS_THIS_ACCOUNT, idRadioButtonNew);

	if (idRadioButtonNew == IDC_RADIO_LOGONAS_SYSTEMACCOUNT)
		{
		m_fIsSystemAccount = TRUE;
		::EnableDlgItemGroup(m_hWnd, rgzidDisablePassword, FALSE);
		if (m_idRadioButton != 0)
			{
			GetDlgItemText(IDC_EDIT_ACCOUNTNAME, m_strAccountName);
			GetDlgItemText(IDC_EDIT_PASSWORD, m_strPassword);
			GetDlgItemText(IDC_EDIT_PASSWORD_CONFIRM, m_strPasswordConfirm);
			}
		SetDlgItemText(IDC_EDIT_ACCOUNTNAME, L"");
		SetDlgItemText(IDC_EDIT_PASSWORD, L"");
		SetDlgItemText(IDC_EDIT_PASSWORD_CONFIRM, L"");
		}
	else
		{
		m_fIsSystemAccount = FALSE;
		::EnableDlgItemGroup(m_hWnd, rgzidDisablePassword, TRUE);
		SetDlgItemText(IDC_EDIT_ACCOUNTNAME, m_strAccountName);
		SetDlgItemText(IDC_EDIT_PASSWORD, m_strPassword);
		SetDlgItemText(IDC_EDIT_PASSWORD_CONFIRM, m_strPasswordConfirm);
		}
	GetDlgItem(IDC_CHECK_SERVICE_INTERACT_WITH_DESKTOP)->EnableWindow(m_fIsSystemAccount);
	m_idRadioButton = idRadioButtonNew;
	m_fAllowSetModified = TRUE;
} // CServicePageHwProfile::SelectRadioButton()


/////////////////////////////////////////////////////////////////////
void CServicePageHwProfile::BuildHwProfileList()
{
	LV_ITEM lvItem;
	INT iItem;
	CHardwareProfileEntry * pHPE;
	Assert(IsWindow(m_hwndListViewHwProfiles));
	ListView_DeleteAllItems(m_hwndListViewHwProfiles);
	m_iItemHwProfileEntry = -1;	// No profile selected

	// ISSUE 2002/03/07-JonN replace GarbageInit globally with ZeroMemory
	GarbageInit(OUT &lvItem, sizeof(lvItem));
	lvItem.iItem = 0;
	pHPE = m_pData->m_paHardwareProfileEntryList;
	while (pHPE != NULL)
		{
		lvItem.mask = LVIF_TEXT | LVIF_PARAM;
		lvItem.lParam = (LPARAM)pHPE;
		lvItem.iSubItem = 0;
		lvItem.pszText = pHPE->m_hpi.HWPI_szFriendlyName;
		iItem = ListView_InsertItem(m_hwndListViewHwProfiles, IN &lvItem);
		Report(iItem >= 0);

		lvItem.iItem = iItem;
		lvItem.mask = LVIF_TEXT;
		if (m_pData->m_fShowHwProfileInstances)
			{
			lvItem.iSubItem = 1;
			lvItem.pszText = const_cast<LPTSTR>((LPCTSTR)pHPE->m_strDeviceNameFriendly);
			VERIFY(ListView_SetItem(m_hwndListViewHwProfiles, IN &lvItem));
			Report(iItem >= 0);
			}
		
		lvItem.iSubItem = m_pData->m_iSubItemHwProfileStatus;
		lvItem.pszText = pHPE->m_fEnabled ? m_szHwProfileEnabled : m_szHwProfileDisabled;
		VERIFY(ListView_SetItem(m_hwndListViewHwProfiles, IN &lvItem));
		pHPE = pHPE->m_pNext;
		} // while
	// Select the first item
	ListView_SetItemState(m_hwndListViewHwProfiles, 0, LVIS_SELECTED, LVIS_SELECTED);
} // BuildHwProfileList()


/////////////////////////////////////////////////////////////////////
//	Toggle the current hardware profile item.
void CServicePageHwProfile::ToggleCurrentHwProfileItem()
{
	// ISSUE-2002/03/07-JonN should also check for values too large
	if (m_iItemHwProfileEntry < 0)
		return;
	LV_ITEM lvItem;
	GarbageInit(OUT &lvItem, sizeof(lvItem));
	lvItem.mask = LVIF_PARAM;
	lvItem.iItem = m_iItemHwProfileEntry;
	lvItem.iSubItem = 0;
	VERIFY(ListView_GetItem(m_hwndListViewHwProfiles, OUT &lvItem));
	Assert(lvItem.lParam != NULL);
	CHardwareProfileEntry * pHPE = (CHardwareProfileEntry *)lvItem.lParam;
	if (pHPE != NULL && !pHPE->m_fReadOnly)	// Just in case
		{
		pHPE->m_fEnabled = !pHPE->m_fEnabled;
		lvItem.mask = LVIF_TEXT;
		lvItem.iSubItem = m_pData->m_iSubItemHwProfileStatus;
		lvItem.pszText = pHPE->m_fEnabled ? m_szHwProfileEnabled : m_szHwProfileDisabled;
		VERIFY(ListView_SetItem(m_hwndListViewHwProfiles, IN &lvItem));
		}
	EnableHwProfileButtons();
} // ToggleCurrentHwProfileItem()


/////////////////////////////////////////////////////////////////////
//	Enable/disable buttons according to current hardware profile item.
void CServicePageHwProfile::EnableHwProfileButtons()
{
	BOOL fButtonEnable = FALSE;
	BOOL fButtonDisable = FALSE;

	if (m_iItemHwProfileEntry >= 0)
		{
		LV_ITEM lvItem;
		
		GarbageInit(OUT &lvItem, sizeof(lvItem));
		lvItem.mask = LVIF_PARAM;
		lvItem.iItem = m_iItemHwProfileEntry;
		lvItem.iSubItem = 0;
		VERIFY(ListView_GetItem(m_hwndListViewHwProfiles, OUT &lvItem));
		Assert(lvItem.lParam != NULL);
		CHardwareProfileEntry * pHPE = (CHardwareProfileEntry *)lvItem.lParam;	
		if (pHPE != NULL && !pHPE->m_fReadOnly)
			{
			Assert(pHPE->m_fEnabled == TRUE || pHPE->m_fEnabled == FALSE);
			fButtonEnable = !pHPE->m_fEnabled;
			fButtonDisable = pHPE->m_fEnabled;
			}
		} // if
	EnableDlgItem(m_hWnd, IDC_BUTTON_ENABLE, fButtonEnable);
	EnableDlgItem(m_hWnd, IDC_BUTTON_DISABLE, fButtonDisable);
} // EnableHwProfileButtons()


void CServicePageHwProfile::OnItemChangedListHwProfiles(NMHDR* pNMHDR, LRESULT* pResult) 
{
	m_iItemHwProfileEntry = ((NM_LISTVIEW *)pNMHDR)->iItem;
	EnableHwProfileButtons();
	*pResult = 0;
}

void CServicePageHwProfile::OnDblclkListHwProfiles(NMHDR* /*pNMHDR*/, LRESULT* pResult) 
{
	ToggleCurrentHwProfileItem();
	SetModified();
	*pResult = 0;
}


void CServicePageHwProfile::OnButtonEnableHwProfile() 
{
	ToggleCurrentHwProfileItem();
	SetModified();	
	::SetDlgItemFocus(m_hWnd, IDC_BUTTON_DISABLE);
}

void CServicePageHwProfile::OnButtonDisableHwProfile() 
{
	ToggleCurrentHwProfileItem();
	SetModified();
	::SetDlgItemFocus(m_hWnd, IDC_BUTTON_ENABLE);
}

void CServicePageHwProfile::OnButtonChooseUser() 
{
	Assert(m_pData != NULL);

	PUSERDETAILS paUserDetails = NULL;	// Pointer to allocated USERDETAILS buffer
	LPCTSTR pszServerName = NULL;
	BOOL fSuccess;

	if (!m_pData->m_strMachineName.IsEmpty())
		pszServerName = m_pData->m_strMachineName;

	// Invoke the user picker dialog
	CString str;
	fSuccess = UiGetUser(m_hWnd, FALSE, pszServerName, IN OUT str);
	if (fSuccess)
		{
		SetDlgItemText(IDC_EDIT_ACCOUNTNAME, str);
		SetModified();
		}
} // OnButtonChooseUser()


void CServicePageHwProfile::OnRadioLogonasSystemAccount() 
{
	CString strAccountName;
	GetDlgItemText(IDC_EDIT_ACCOUNTNAME, OUT strAccountName);
	TrimString(strAccountName);
	if (!strAccountName.IsEmpty()) // JonN 4/11/00: 17756
		SetModified();
	SelectRadioButton(IDC_RADIO_LOGONAS_SYSTEMACCOUNT);
}

void CServicePageHwProfile::OnCheckServiceInteractWithDesktop() 
{
	m_pData->SetDirty(CServicePropertyData::mskfDirtySvcType);
	SetModified();
}

void CServicePageHwProfile::OnRadioLogonasThisAccount() 
{
	SelectRadioButton(IDC_RADIO_LOGONAS_THIS_ACCOUNT);
}

void CServicePageHwProfile::OnChangeEditAccountName() 
{
	if (m_fAllowSetModified)
		SetModified();
}

void CServicePageHwProfile::OnChangeEditPassword() 
{
	if (m_fAllowSetModified)
		{
		m_fPasswordDirty = TRUE;
		SetModified();
		}
}

void CServicePageHwProfile::OnChangeEditPasswordConfirm() 
{
	if (m_fAllowSetModified)
		{
		m_fPasswordDirty = TRUE;
		SetModified();
		}
}

BOOL CServicePageHwProfile::OnApply() 
{
	// Write the data into the service control database
	if (!m_pData->FOnApply())
		{
		// Unable to write the information
		return FALSE;
		}
	BOOL f = CPropertyPage::OnApply();
	m_fAllowSetModified = FALSE;
	UpdateData(FALSE);
	BuildHwProfileList();
	m_fAllowSetModified = TRUE;
	return f;
}

BOOL CServicePageHwProfile::OnSetActive() 
{
	Assert(m_pData != NULL);
	m_fAllowSetModified = FALSE;
	BOOL f = CPropertyPage::OnSetActive();
	m_idRadioButton = 0;
	SelectRadioButton(m_fIsSystemAccount ? IDC_RADIO_LOGONAS_SYSTEMACCOUNT : IDC_RADIO_LOGONAS_THIS_ACCOUNT);
	m_fAllowSetModified = TRUE;
	m_fPasswordDirty = FALSE;
	return f;
}

BOOL CServicePageHwProfile::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
	return DoHelp(lParam, HELP_DIALOG_TOPIC(IDD_PROPPAGE_SERVICE_HWPROFILE));
}

BOOL CServicePageHwProfile::OnContextHelp(WPARAM wParam, LPARAM /*lParam*/)
{
	return DoContextHelp(wParam, HELP_DIALOG_TOPIC(IDD_PROPPAGE_SERVICE_HWPROFILE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\svcenum.cpp ===
/////////////////////////////////////////////////////////////////////
//
//	SvcEnum.cpp
//
//	This file contains routines to enumerate services.
//
//	HISTORY
//	t-danmo		96.09.13	Creation (split of log.cpp)
//	t-danm		96.07.14	Moved member functions Service_* from
//							CFileMgmtComponent to CFileMgmtComponentData.
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "cmponent.h"
#include "compdata.h" // QueryComponentDataRef().m_hScManager
#include "safetemp.h"

#include "macros.h"
USE_HANDLE_MACROS("FILEMGMT(SvcEnum.cpp)")

#include "FileSvc.h" // FileServiceProvider

#include "dataobj.h"

#include <comstrm.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "progress.h"

/*
// forward declarations
class CServiceCookieBlock;


/////////////////////////////////////////////////////////////////////
class CServiceCookie : public CFileMgmtResultCookie
{
public:
	CString GetServiceDisplaySecurityContext ();
	CString GetServiceDisplayStartUpType ();
	CString GetServiceDisplayStatus ();
	CString GetServiceDescription ();
	virtual HRESULT CompareSimilarCookies( CCookie* pOtherCookie, int* pnResult);
	CServiceCookie() : CFileMgmtResultCookie( FILEMGMT_SERVICE ) {}
	virtual HRESULT GetServiceName( OUT CString& strServiceName );
	virtual HRESULT GetServiceDisplayName( OUT CString& strServiceName );
	virtual BSTR QueryResultColumnText( int nCol, CFileMgmtComponentData& refcdata );
	inline ENUM_SERVICE_STATUS* GetServiceStatus()
	{
		ASSERT( NULL != m_pobject );
		return (ENUM_SERVICE_STATUS*)m_pobject;
	}

	CString m_strDescription;		// Description of service
	DWORD m_dwCurrentState;
	DWORD m_dwStartType;
	CString m_strServiceStartName;	// Name of the account which the service process will be logged (eg: ".\\Administrator")


	virtual void AddRefCookie();
	virtual void ReleaseCookie();

// CHasMachineName
	CServiceCookieBlock* m_pCookieBlock;
	DECLARE_FORWARDS_MACHINE_NAME(m_pCookieBlock)
};

HRESULT CServiceCookie::GetServiceName(OUT CString& strServiceName )
{
	ENUM_SERVICE_STATUS * pESS = (ENUM_SERVICE_STATUS *)m_pobject;
	ASSERT( NULL != pESS );
	ASSERT( NULL != pESS->lpServiceName );
	strServiceName = pESS->lpServiceName;
	return S_OK;
}

HRESULT CServiceCookie::GetServiceDisplayName(OUT CString& strServiceDisplayName )
{
	ENUM_SERVICE_STATUS * pESS = (ENUM_SERVICE_STATUS *)m_pobject;
	ASSERT( NULL != pESS );
	ASSERT( NULL != pESS->lpDisplayName );
	strServiceDisplayName = pESS->lpDisplayName;
	return S_OK;
}

BSTR CServiceCookie::QueryResultColumnText( int nCol, CFileMgmtComponentData& refcdata )
{
	switch (nCol)
	{
	case COLNUM_SERVICES_SERVICENAME:
		return GetServiceStatus()->lpDisplayName;
	case COLNUM_SERVICES_DESCRIPTION:
		return const_cast<BSTR>((LPCTSTR)m_strDescription);
	case COLNUM_SERVICES_STATUS:
		return const_cast<BSTR>( Service_PszMapStateToName(m_dwCurrentState) );
	case COLNUM_SERVICES_STARTUPTYPE:
		return const_cast<BSTR>( Service_PszMapStartupTypeToName(m_dwStartType) );
	case COLNUM_SERVICES_SECURITYCONTEXT:
		return const_cast<BSTR>((LPCTSTR)m_strServiceStartName);
	default:
		ASSERT(FALSE);
		break;
	}
	return L"";
}

class CServiceCookieBlock : public CCookieBlock<CServiceCookie>,
                            public CStoresMachineName
{
public:
	inline CServiceCookieBlock(
		CServiceCookie* aCookies, // use vector ctor, we use vector dtor
		INT cCookies,
		LPCTSTR lpcszMachineName,
		PVOID pvCookieData)
		: CCookieBlock<CServiceCookie>( aCookies, cCookies ),
		  CStoresMachineName( lpcszMachineName ),
		  m_pvCookieData(pvCookieData)
	{
		for (int i = 0; i < cCookies; i++)
//		{
//			aCookies[i].ReadMachineNameFrom( (CHasMachineName*)this );
		 	aCookies[i].m_pCookieBlock = this;
//		}
	}
	virtual ~CServiceCookieBlock();
private:
	PVOID m_pvCookieData; // actually ENUM_SERVICE_STATUS*
};

DEFINE_COOKIE_BLOCK(CServiceCookie)

CServiceCookieBlock::~CServiceCookieBlock()
{
	if (NULL != m_pvCookieData)
	{
		delete m_pvCookieData;
		m_pvCookieData = NULL;
	}
}

void CServiceCookie::AddRefCookie() { m_pCookieBlock->AddRef(); }
void CServiceCookie::ReleaseCookie() { m_pCookieBlock->Release(); }

DEFINE_FORWARDS_MACHINE_NAME( CServiceCookie, m_pCookieBlock )
*/

int g_marker;

class CNewServiceCookie
	: public CNewResultCookie
{
public:
	// 581167-2002/03/05-JonN should initialize DWORD members
	CNewServiceCookie()
		: CNewResultCookie( (PVOID)&g_marker, FILEMGMT_SERVICE )
		, m_dwState( 0 )
		, m_dwStartType( 0 )
	{}
	virtual ~CNewServiceCookie();

	virtual BSTR QueryResultColumnText( int nCol, CFileMgmtComponentData& refcdata );
	virtual HRESULT CompareSimilarCookies(CCookie * pOtherCookie, int * pnResult);
	virtual HRESULT GetServiceName( OUT CString& strServiceName );
	virtual HRESULT GetServiceDisplayName( OUT CString& strServiceName );
	virtual HRESULT GetExplorerViewDescription( OUT CString& strExplorerViewDescription );

	virtual HRESULT SimilarCookieIsSameObject( CNewResultCookie* pOtherCookie, BOOL* pbSame );
	virtual BOOL CopySimilarCookie( CNewResultCookie* pcookie );

public:
	CString m_strServiceName;
	CString m_strDisplayName;
	CString m_strDescription;
	DWORD m_dwState;
	DWORD m_dwStartType;
	CString m_strStartName;

}; // CNewServiceCookie

CNewServiceCookie::~CNewServiceCookie()
{
}

BSTR CNewServiceCookie::QueryResultColumnText(
	int nCol,
	CFileMgmtComponentData& /*refcdata*/ )
{
	switch (nCol)
	{
	case COLNUM_SERVICES_SERVICENAME:
		return const_cast<BSTR>((LPCTSTR)m_strDisplayName);
	case COLNUM_SERVICES_DESCRIPTION:
		return const_cast<BSTR>((LPCTSTR)m_strDescription);
	case COLNUM_SERVICES_STATUS:
		return const_cast<BSTR>( Service_PszMapStateToName(m_dwState) );
	case COLNUM_SERVICES_STARTUPTYPE:
		return const_cast<BSTR>( Service_PszMapStartupTypeToName(m_dwStartType) );
	case COLNUM_SERVICES_SECURITYCONTEXT:
        // JonN 11/14/00 188203 support LocalService/NetworkService
		return const_cast<BSTR>(
            Service_PszMapStartupAccountToName(m_strStartName) );
	default:
		ASSERT(FALSE);
		break;
	}
	return L"";
}

HRESULT CNewServiceCookie::CompareSimilarCookies(CCookie * pOtherCookie, int * pnResult)
{
	if ( !pOtherCookie || FILEMGMT_SERVICE != QueryObjectType () )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	CNewServiceCookie* pcookie = dynamic_cast <CNewServiceCookie*>(pOtherCookie);
	if (   FILEMGMT_SERVICE != pcookie->QueryObjectType ()
	    || !IsSameType(pcookie) )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	int colNum = *pnResult; // save in case it's overwritten

	HRESULT hr = CHasMachineName::CompareMachineNames( *pcookie, pnResult );
	if (S_OK != hr || 0 != *pnResult)
		return hr;

	switch (colNum)	// column number
	{
	case COMPARESIMILARCOOKIE_FULL: // fall through
	case COLNUM_SERVICES_SERVICENAME:
		*pnResult = lstrcmpi(m_strDisplayName, pcookie->m_strDisplayName);
		break;

	case COLNUM_SERVICES_DESCRIPTION:
		*pnResult = lstrcmpi(m_strDescription, pcookie->m_strDescription);
		break;

	case COLNUM_SERVICES_STATUS:
		{
			CString	strServiceA = Service_PszMapStateToName(m_dwState);
			CString strServiceB = Service_PszMapStateToName(pcookie->m_dwState);
			*pnResult = lstrcmpi(strServiceA, strServiceB);
		}
		break;

	case COLNUM_SERVICES_STARTUPTYPE:
		{
			CString	strServiceA = Service_PszMapStartupTypeToName(m_dwStartType);
			CString strServiceB = Service_PszMapStartupTypeToName(pcookie->m_dwStartType);
			*pnResult = lstrcmpi(strServiceA, strServiceB);
		}
		break;

	case COLNUM_SERVICES_SECURITYCONTEXT:
        // JonN 11/14/00 188203 support LocalService/NetworkService
		{
			CString	strServiceA = Service_PszMapStartupAccountToName(m_strStartName);
			CString strServiceB = Service_PszMapStartupAccountToName(pcookie->m_strStartName);
			*pnResult = lstrcmpi(strServiceA, strServiceB);
		}
		break;

	default:
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	return S_OK;
}

HRESULT CNewServiceCookie::GetServiceName(OUT CString& strServiceName )
{
	strServiceName = m_strServiceName;
	return S_OK;
}

HRESULT CNewServiceCookie::GetServiceDisplayName(OUT CString& strServiceDisplayName )
{
	strServiceDisplayName = m_strDisplayName;
	return S_OK;
}

HRESULT CNewServiceCookie::GetExplorerViewDescription(OUT CString& strExplorerViewDescription )
{
	strExplorerViewDescription = m_strDescription;
	return S_OK;
}

HRESULT CNewServiceCookie::SimilarCookieIsSameObject(
             CNewResultCookie* pOtherCookie,
             BOOL* pbSame )
{
	if ( !pOtherCookie || !IsSameType(pOtherCookie) )
	{
		ASSERT(FALSE);
		return E_FAIL;
	}

	int nResult = 0;
	HRESULT hr = CHasMachineName::CompareMachineNames( *pOtherCookie, &nResult );
	if (S_OK != hr || 0 != nResult)
	{
		*pbSame = FALSE;
		return hr;
	}
	*pbSame = (0 == lstrcmpi(m_strServiceName,
	              ((CNewServiceCookie*)pOtherCookie)->m_strServiceName) );

	return S_OK;
}

BOOL CNewServiceCookie::CopySimilarCookie( CNewResultCookie* pcookie )
{
	if (NULL == pcookie)
	{
		ASSERT(FALSE);
		return FALSE;
	}
	CNewServiceCookie* pnewcookie = (CNewServiceCookie*)pcookie;
	BOOL fChanged = FALSE;
	if (m_strServiceName != pnewcookie->m_strServiceName)
	{
		m_strServiceName = pnewcookie->m_strServiceName;
		fChanged = TRUE;
	}
	if (m_strDisplayName != pnewcookie->m_strDisplayName)
	{
		m_strDisplayName = pnewcookie->m_strDisplayName;
		fChanged = TRUE;
	}
	if (m_strDescription != pnewcookie->m_strDescription)
	{
		m_strDescription = pnewcookie->m_strDescription;
		fChanged = TRUE;
	}
	if (m_dwState != pnewcookie->m_dwState)
	{
		m_dwState = pnewcookie->m_dwState;
		fChanged = TRUE;
	}
	if (m_dwStartType != pnewcookie->m_dwStartType)
	{
		m_dwStartType = pnewcookie->m_dwStartType;
		fChanged = TRUE;
	}
	if (m_strStartName != pnewcookie->m_strStartName)
	{
		m_strStartName = pnewcookie->m_strStartName;
		fChanged = TRUE;
	}
	// don't bother with machine name
	fChanged |= CNewResultCookie::CopySimilarCookie( pcookie );
	return fChanged;
}



/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////
//	Service_EOpenScManager()
//
//	Open the service Service Control Manager database to
//	enumerate all available services.
//
//	If an error occured, return the error code returned by GetLastError(),
//	otherwise return ERROR_SUCCESS.
//
APIERR
CFileMgmtComponentData::Service_EOpenScManager(LPCTSTR pszMachineName)
	{
	Endorse(pszMachineName == NULL);	// TRUE => Local machine
	Assert(m_hScManager == NULL && "Service Control Manager should not have been opened yet");

	APIERR dwErr = ERROR_SUCCESS;
	if (pszMachineName != NULL)
		{
		// 581209-2002/03/04 JonN handle L"\\" case
		if (pszMachineName[0] == _T('\\') && pszMachineName[1] == _T('\\'))
			{
			// Get rid of the \\ at the beginning of machine name
			pszMachineName += 2;
			}
		if (pszMachineName[0] == _T('\0'))
			pszMachineName = NULL;		// Empty string == Local Machine
		}
	CWaitCursor wait;
	m_hScManager = ::OpenSCManager(
		pszMachineName,
		NULL,
		SC_MANAGER_ENUMERATE_SERVICE);
	if (m_hScManager == NULL)
		{
		dwErr = ::GetLastError();
		TRACE3("CFileMgmtComponentData::Service_OpenScManager() - "
			_T("Unable to open Service Control Manager database on machine %s. err=%d (0x%X).\n"),
			(pszMachineName != NULL) ? pszMachineName : _T("LocalMachine"), dwErr, dwErr);
		}
	return dwErr;
	} // CFileMgmtComponentData::Service_EOpenScManager()


/////////////////////////////////////////////////////////////////////
void
CFileMgmtComponentData::Service_CloseScManager()
	{
	if (m_hScManager != NULL)
		{
		CWaitCursor wait;		// Auto-wait cursor
		(void)::CloseServiceHandle(m_hScManager);
		m_hScManager = NULL;
		}
	} // CFileMgmtComponentData::Service_CloseScManager()


/////////////////////////////////////////////////////////////////////
//	CFileMgmtComponentData::Service_PopulateServices()
//
//	Enumerate all available services and display them
//	into the listview control.
//
//  12/03/98 JonN     With the mark-and-sweep change, this no longer adds the items
//                    the the view
//
HRESULT
CFileMgmtComponentData::Service_PopulateServices(LPRESULTDATA pResultData, CFileMgmtScopeCookie* pcookie)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( )); // required for CWaitCursor
	TEST_NONNULL_PTR_PARAM(pResultData);
	TEST_NONNULL_PTR_PARAM(pcookie);

	DWORD cbBytesNeeded = 0;		// Number of necessary bytes to return all service entries
	DWORD dwServicesReturned = 0;	// Number of services returned
	DWORD dwResumeHandle = 0;
	BOOL fRet;
	DWORD dwErr = ERROR_SUCCESS;

	if (m_hScManager == NULL)
		{
		dwErr = Service_EOpenScManager(pcookie->QueryTargetServer());
		}
	if (m_hScManager == NULL)
		{
		Assert(dwErr != ERROR_SUCCESS);
		DoServicesErrMsgBox(::GetActiveWindow(), MB_OK | MB_ICONEXCLAMATION, dwErr,
			IDS_MSG_s_UNABLE_TO_OPEN_SERVICE_DATABASE, pcookie->QueryNonNULLMachineName());
		return S_OK;
		}

	//
	// The idea here is to ask the enum Api how much memory is
	// needed to enumerate all services.
	//
	{
	CWaitCursor wait;		// Auto-wait cursor
	fRet = ::EnumServicesStatus(
			m_hScManager,
			SERVICE_WIN32,		// Type of services to enumerate
			SERVICE_ACTIVE | SERVICE_INACTIVE,	// State of services to enumerate
			NULL,						// Pointer to service status buffer
			0,							// Size of service status buffer
			OUT &cbBytesNeeded,			// Number of necessary bytes to return the remaining service entries
			OUT &dwServicesReturned,	// Number returned services
			OUT &dwResumeHandle); 		// Pointer to variable for next entry (unused)
	}

	Report(fRet == FALSE);		// First attempt should fail
	Report(cbBytesNeeded > 0);
	// Add room for 10 extra services (just in case)
	cbBytesNeeded += 10 * sizeof(ENUM_SERVICE_STATUS);
	// Allocate memory for the enumeration
	ENUM_SERVICE_STATUS * prgESS = (ENUM_SERVICE_STATUS *) new BYTE[cbBytesNeeded];
	//
	// Now call the enum Api to retreive the services
	//
	{
	CWaitCursor wait;		// Auto-wait cursor
	fRet = ::EnumServicesStatus(
			m_hScManager,
			SERVICE_WIN32,	   // Type of services to enumerate
			SERVICE_ACTIVE | SERVICE_INACTIVE, // State of services to enumerate
			OUT prgESS,		// Pointer to service status buffer
			IN cbBytesNeeded,	// Size of service status buffer
			OUT &cbBytesNeeded, // Number of necessary bytes to return the remaining service entries
			OUT &dwServicesReturned,	// Number of sercvices returned
			OUT &dwResumeHandle); 		// Pointer to variable for next entry
	dwErr = ::GetLastError();
	}
	if (!fRet)
		{
		Assert(dwErr != ERROR_SUCCESS);
		DoServicesErrMsgBox(::GetActiveWindow(), MB_OK | MB_ICONEXCLAMATION, dwErr,
			IDS_MSG_s_UNABLE_TO_READ_SERVICES, pcookie->QueryNonNULLMachineName());
		delete prgESS;
		return S_OK; // PREFIX ISSUE-2002/04/15-JonN should delete[] as BYTE*
		}
	
	{
	CWaitCursor wait;		// Auto-wait cursor
	// Add the services to listview
	Service_AddServiceItems(pResultData, pcookie, prgESS, dwServicesReturned);
	delete prgESS; // PREFIX ISSUE-2002/04/15-JonN should delete[] as BYTE*
	}
	
	return S_OK;
} // CFileMgmtComponentData::Service_PopulateServices()


/////////////////////////////////////////////////////////////////////
//	CFileMgmtComponentData::Service_AddServiceItems()
//
//	Insert service items to the result pane (listview control).
//
//  12/03/98 JonN     With the mark-and-sweep change, this no longer adds the items
//                    the the view
//  04/07/02 JonN     544137: Rebuilt this function to handle extralong return buffers
//
HRESULT
CFileMgmtComponentData::Service_AddServiceItems(
	LPRESULTDATA /*pResultData*/,
	CFileMgmtScopeCookie * pParentCookie,
	ENUM_SERVICE_STATUS * prgESS,	// IN: Array of structures of services
	DWORD nDataItems)				// IN: Number of structures in prgESS
{
	Assert(pParentCookie != NULL);
	Assert(prgESS != NULL);

	CString str;
	BOOL fResult;

	ASSERT(m_hScManager != NULL);	// Service control manager should be already opened

	DWORD cbActiveBufferSize = max(max(sizeof(QUERY_SERVICE_CONFIG),
	                                   SERVICE_cbQueryServiceConfigMax),
	                               max(sizeof(SERVICE_DESCRIPTION),
	                                   SERVICE_cchDescriptionMax * sizeof(TCHAR) + 16));
	LPBYTE pActiveBuffer = new BYTE[cbActiveBufferSize];
	if (NULL == pActiveBuffer)
	{
		ASSERT(FALSE);
		return ERROR_NOT_ENOUGH_MEMORY;
	}

	for ( ; nDataItems > 0; nDataItems--, prgESS++ )
		{
		/*
		**	Add one line per service
		*/

		// Open service to get its configuration
		SC_HANDLE hService = ::OpenService(
			m_hScManager,
			prgESS->lpServiceName,
			SERVICE_QUERY_CONFIG);
		if (hService == NULL)
			{
			TRACE2("Failed to open service %s. err=%u.\n",
				prgESS->lpServiceName, ::GetLastError());
			}


		// Query config description
		DWORD cbBytesNeeded = 0;
		CString strDescription;
		if (m_fQueryServiceConfig2 && NULL != hService)
			{
			// We only call this API if it is supported by target machine
			// JonN-2002/04/04-544089 ensure NULL-termination
			::ZeroMemory(pActiveBuffer, cbActiveBufferSize);
			fResult = ::MyQueryServiceConfig2(
				&m_fQueryServiceConfig2,
				hService,
				SERVICE_CONFIG_DESCRIPTION,
				OUT pActiveBuffer,
				cbActiveBufferSize,
				OUT &cbBytesNeeded);
			if ( !fResult
			  && m_fQueryServiceConfig2
			  && ERROR_INSUFFICIENT_BUFFER == ::GetLastError())
				{
				if (cbBytesNeeded <= cbActiveBufferSize
				 || cbBytesNeeded > 100000)
					{
					ASSERT(FALSE); // inappropriate size request
					}
				else
					{ // try to reallocate larger buffer
					LPBYTE pNewActiveBuffer = new BYTE[cbBytesNeeded+1000];
					if (NULL == pNewActiveBuffer)
						{
							Report("FILEMGMT: Cannot reallocate MyQueryServiceConfig2 buffer: out of memory");
						}
					else
						{ // larger buffer allocated, start using it
						delete[] pActiveBuffer;
						pActiveBuffer = pNewActiveBuffer;
						cbActiveBufferSize = cbBytesNeeded+1000;

						// retry API
						::ZeroMemory(pActiveBuffer, cbActiveBufferSize);
						cbBytesNeeded = 0;
						fResult = ::MyQueryServiceConfig2(
							&m_fQueryServiceConfig2,
							hService,
							SERVICE_CONFIG_DESCRIPTION,
							OUT pActiveBuffer,
							cbActiveBufferSize,
							OUT &cbBytesNeeded);
						} // larger buffer allocated
					} // appropriate size request
				} // ERROR_INSUFFICIENT_BUFFER
			if (!fResult)
				{
				if (!m_fQueryServiceConfig2)
					{
					// the local machine does not support QueryServiceConfig2
					// CODEWORK How could we get here anyhow?  JonN 1/31/97
					}
				else
					{
					// This is probably because the target machine is running
					// an older version of NT not supporting this API.
					DWORD dwErr = ::GetLastError();
					TRACE2("QueryServiceConfig2(%s) failed. err=%u.\n",
						prgESS->lpServiceName, dwErr);
					TRACE1("INFO: Machine %s does not support QueryServiceConfig2() API.\n",
						pParentCookie->QueryTargetServer() ? pParentCookie->QueryTargetServer() : _T("(Local)"));
					Report(dwErr == RPC_S_PROCNUM_OUT_OF_RANGE && 
						"Unusual Situation: Expected error should be RPC_S_PROCNUM_OUT_OF_RANGE");
					Report(m_fQueryServiceConfig2 != FALSE && "How can this happen???");
					m_fQueryServiceConfig2 = FALSE;
					}
				}
			else // fResult is true
				{
				// MyQueryServiceConfig2 succeeded
				// We limit the length of the service description to 1000 characters
				// otherwise mmc.exe will AV.
				// CODEWORK remove this when the bug is fixed in MMC
				SERVICE_DESCRIPTION* psd = (SERVICE_DESCRIPTION*)pActiveBuffer;
				if (NULL != psd->lpDescription)
					{
					if (lstrlen(psd->lpDescription) >= 1000)
						{
						TRACE1("INFO: Description of service %s is too long. Only the first 1000 characters will be displayed.\n", prgESS->lpServiceName);
						psd->lpDescription[1000] = _T('\0');
						}
					strDescription = psd->lpDescription;
					} // if (NULL != psd->lpDescription)
				} // if (fResult is true)
			} // if (m_fQueryServiceConfig2 && NULL != hService)


		// Query service config
		// This might fail e.g. if insufficient permissions
		BOOL fQSCResult = FALSE;
		QUERY_SERVICE_CONFIG* pqsc = (QUERY_SERVICE_CONFIG*)pActiveBuffer;
		if (NULL != hService)
			{
			cbBytesNeeded = 0;
			::ZeroMemory(pActiveBuffer, cbActiveBufferSize);
			fQSCResult = ::QueryServiceConfig(
				hService,
				OUT pqsc,
				cbActiveBufferSize,
				OUT &cbBytesNeeded);
			// JonN-2002/04/04-544089 handle long DisplayName value
			if (!fQSCResult && ERROR_INSUFFICIENT_BUFFER == ::GetLastError())
				{
				if (cbBytesNeeded <= cbActiveBufferSize
				 || cbBytesNeeded > 100000)
					{
					ASSERT(FALSE); // inappropriate size request
					}
				else
					{ // try to reallocate larger buffer
					LPBYTE pNewActiveBuffer = new BYTE[cbBytesNeeded+1000];
					if (NULL == pNewActiveBuffer)
						{
							Report("FILEMGMT: Cannot reallocate QueryServiceConfig buffer: out of memory");
						}
					else
						{ // larger buffer allocated, start using it
							delete[] pActiveBuffer;
							pActiveBuffer = pNewActiveBuffer;
							cbActiveBufferSize = cbBytesNeeded+1000;

							// retry API
							::ZeroMemory(pActiveBuffer, cbActiveBufferSize);
							cbBytesNeeded = 0;
							pqsc = (QUERY_SERVICE_CONFIG*)pActiveBuffer;
							cbBytesNeeded = 0;
							::ZeroMemory(pActiveBuffer, cbActiveBufferSize);
							fQSCResult = ::QueryServiceConfig(
								hService,
								OUT pqsc,
								cbActiveBufferSize,
								OUT &cbBytesNeeded);
						} // larger buffer allocated
					} // appropriate size request
				} // ERROR_INSUFFICIENT_BUFFER
			} // if (NULL != hService)

		// Add the first column
		CNewServiceCookie * pnewcookie = new CNewServiceCookie;
		pnewcookie->m_strServiceName = prgESS->lpServiceName;
		pnewcookie->m_strDisplayName = prgESS->lpDisplayName;
		pnewcookie->m_strDescription = strDescription;
		pnewcookie->m_dwState = prgESS->ServiceStatus.dwCurrentState;
		pnewcookie->m_dwStartType =
			((!fQSCResult) ? (DWORD)-1 : pqsc->dwStartType);

		// JonN 4/11/00 17756: The description of "Account Run under" is unlocalized.
		// Display empty string instead of "LocalSystem"
		pnewcookie->m_strStartName =
			((!fQSCResult || !lstrcmpi(L"LocalSystem",pqsc->lpServiceStartName))
				? NULL : pqsc->lpServiceStartName);

		pnewcookie->SetMachineName( pParentCookie->QueryTargetServer() );
		pParentCookie->ScanAndAddResultCookie( pnewcookie );

		if (NULL != hService)
		{
			VERIFY(::CloseServiceHandle(hService));
		}
	} // for

	if (pActiveBuffer)
		delete[] pActiveBuffer;

	return S_OK;

	} // CFileMgmtComponentData::Service_AddServiceItems()


/////////////////////////////////////////////////////////////////////
//	CFileMgmtComponentData::Service_FGetServiceInfoFromIDataObject()
//
//	Extract 'machine name', 'service name' and/or 'service display name'
//	from the data object.
//
//	Return FALSE if data could not be retrived, otherwise return TRUE.
//
BOOL
CFileMgmtComponentData::Service_FGetServiceInfoFromIDataObject(
	IDataObject * pDataObject,			// IN: Data object
	CString * pstrMachineName,			// OUT: OPTIONAL: Machine name
	CString * pstrServiceName,			// OUT: OPTIONAL: Service name
	CString * pstrServiceDisplayName)	// OUT: OPTIONAL: Service display name
	{
	// ISSUE-2002/03/05-JonN should handle this case better
	Assert(pDataObject != NULL);
	Endorse(pstrMachineName == NULL);
	Endorse(pstrServiceName == NULL);
	Endorse(pstrServiceDisplayName == NULL);

	HRESULT hr;
	BOOL fSuccess = TRUE;

	if (pstrMachineName != NULL)
		{
		// Get the machine name (computer name) from IDataObject
		hr = ::ExtractString(
			pDataObject,
			CFileMgmtDataObject::m_CFMachineName,
			OUT pstrMachineName,
			DNS_MAX_NAME_BUFFER_LENGTH);
		if (FAILED(hr))
			{
			TRACE0("CFileMgmtComponentData::Service_FGetServiceInfoFromIDataObject() - Failed to get machine name.\n");
			fSuccess = FALSE;
			}
		} // if
	if (pstrServiceName != NULL)
		{
		// Get the service name from IDataObject
		hr = ::ExtractString(
			pDataObject,
			CFileMgmtDataObject::m_CFServiceName,
			OUT pstrServiceName,
			255);
		if (FAILED(hr) || pstrServiceName->IsEmpty())
			{
			TRACE0("CFileMgmtComponentData::Service_FGetServiceInfoFromIDataObject() - Failed to get service name.\n");
			fSuccess = FALSE;
			}
		} // if
	if (pstrServiceDisplayName != NULL)
		{
		// Get the service display name from IDataObject
		hr = ::ExtractString(
			pDataObject,
			CFileMgmtDataObject::m_CFServiceDisplayName,
			OUT pstrServiceDisplayName,
			255);
		if (FAILED(hr) || pstrServiceDisplayName->IsEmpty())
			{
			TRACE0("CFileMgmtComponentData::Service_FGetServiceInfoFromIDataObject() - Failed to get service display name\n");
			fSuccess = FALSE;
			}
		} // if
	return fSuccess;
	} // CFileMgmtComponentData::Service_FGetServiceInfoFromIDataObject()


/////////////////////////////////////////////////////////////////////
//	CFileMgmtComponentData::Service_FAddMenuItems()
//
//	Add menuitems to the service context menu.
//	The same routine will be used to extend context menus of
//	others snapins who wants to have "Start", "Stop", "Pause",
//	"Resume" and "Restart" menuitems.
//
//	Return TRUE if successful, otherwise FALSE.
//
BOOL
CFileMgmtComponentData::Service_FAddMenuItems(
	IContextMenuCallback * pContextMenuCallback,	// OUT: Object to append menuitems
	IDataObject * pDataObject,						// IN: Data object
	BOOL fIs3rdPartyContextMenuExtension)			// IN: TRUE => Add the menu items as a 3rd party extension
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState( )); // required for CWaitCursor
	Assert(pContextMenuCallback != NULL);
	Assert(pDataObject != NULL);
	Endorse(m_hScManager == NULL);		// TRUE => Network connection was broken

	CString strMachineName;
	CString strServiceName;
	CString strServiceDisplayName;
	BOOL fSuccess = TRUE;

	if (!Service_FGetServiceInfoFromIDataObject(
		pDataObject,
		OUT &strMachineName,
		OUT &strServiceName,
		OUT &strServiceDisplayName))
	{
		TRACE0("CFileMgmtComponentData::Service_FAddMenuItems() - Unable to query IDataObject for correct clipboard format.\n");
		return FALSE;
	}
	
	if (fIs3rdPartyContextMenuExtension)
	{
		Assert(m_hScManager == NULL);
		// ISSUE-2002/03/05-JonN should use CWaitCursor
		if (m_hScManager == NULL)
			(void)Service_EOpenScManager(strMachineName);
	}

	BOOL rgfMenuFlags[iServiceActionMax];
	{
		//
		// Get the menu flags
		//
		CWaitCursor wait;
		if (!Service_FGetServiceButtonStatus(
			m_hScManager,
			strServiceName,
			OUT rgfMenuFlags,
			NULL,  // pdwCurrentState
			TRUE)) // fSilentError
		{
			// Nothing to do here
		}
	}
	
	if (strMachineName.IsEmpty())
		strMachineName = g_strLocalMachine;
	if (strServiceDisplayName.IsEmpty())
		strServiceDisplayName = g_strUnknown;
	CString strMenuItem;
	CString strStatusBar;

	CComQIPtr<IContextMenuCallback2, &IID_IContextMenuCallback2>
		 spContextMenuCallback2 = pContextMenuCallback;

	// Add the menu items
	for (INT i = iServiceActionStart; i < iServiceActionMax; i++)
	{
		LoadStringWithInsertions(IDS_SVC_MENU_SERVICE_START + i, OUT &strMenuItem);
		
		LoadStringWithInsertions(IDS_SVC_STATUSBAR_ss_SERVICE_START + i,
			OUT &strStatusBar,
			(LPCTSTR)strServiceDisplayName,
			(LPCTSTR)strMachineName);

		CONTEXTMENUITEM2 contextmenuitem;
		::ZeroMemory(OUT &contextmenuitem, sizeof(contextmenuitem));
		// ISSUE-2002/03/05-JonN remote USES_CONVERSION and T2OLE
		//   I don't trust this, doesn't T2OLE reuse a global buffer?
		USES_CONVERSION;
		contextmenuitem.strName = T2OLE(const_cast<LPTSTR>((LPCTSTR)strMenuItem));
		contextmenuitem.strStatusBarText = T2OLE(const_cast<LPTSTR>((LPCTSTR)strStatusBar));
		contextmenuitem.lCommandID = cmServiceStart + i;
		contextmenuitem.lInsertionPointID = fIs3rdPartyContextMenuExtension ? CCM_INSERTIONPOINTID_3RDPARTY_TASK : CCM_INSERTIONPOINTID_PRIMARY_TOP;
		contextmenuitem.fFlags = rgfMenuFlags[i] ? MF_ENABLED : MF_GRAYED;

		// JonN 4/18/00 Explorer View requires Callback2
		static LPTSTR astrLanguageIndependentMenuNames[iServiceActionMax] =
			{ _T("Start"),
			  _T("Stop"),
			  _T("Pause"),
			  _T("Resume"),
			  _T("Restart")
			};
		contextmenuitem.strLanguageIndependentName =
			astrLanguageIndependentMenuNames[i];

		HRESULT hr = S_OK;
		if (spContextMenuCallback2)
			hr = spContextMenuCallback2->AddItem( &contextmenuitem );
		else
			hr = pContextMenuCallback->AddItem( (CONTEXTMENUITEM*)(&contextmenuitem) );
		ASSERT( SUCCEEDED(hr) && "Unable to add menu item" );

		if ( !fIs3rdPartyContextMenuExtension )
		{
			contextmenuitem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TASK;
			if (spContextMenuCallback2)
				hr = spContextMenuCallback2->AddItem( &contextmenuitem );
			else
				hr = pContextMenuCallback->AddItem( (CONTEXTMENUITEM*)(&contextmenuitem) );
			ASSERT( SUCCEEDED(hr) && "Unable to add menu item" );
		}
	} // for

	return fSuccess;
} // CFileMgmtComponentData::Service_FAddMenuItems()


/////////////////////////////////////////////////////////////////////
//	CFileMgmtComponentData::Service_FDispatchMenuCommand()
//
//	Dispatch a menu command for a given service
//
//	Return TRUE if result pane need to be updated, otherwise FALSE.
//
//  We might get a cmStart command on a paused service, if the command
//  came from the toolbar.  For that matter, we might get a command
//  on a non-service, until we fix the toolbar button updating.
//
BOOL
CFileMgmtComponentData::Service_FDispatchMenuCommand(
	INT nCommandId,
	IDataObject * pDataObject)
{
	Assert(pDataObject != NULL);
	Endorse(m_hScManager == NULL);

	CString strMachineName;
	CString strServiceName;
	CString strServiceDisplayName;
	DWORD dwLastError;

	if (!Service_FGetServiceInfoFromIDataObject(
		pDataObject,
		OUT &strMachineName,
		OUT &strServiceName,
		OUT &strServiceDisplayName))
	{
		TRACE0("CFileMgmtComponentData::Service_FDispatchMenuCommand() - Unable to read data from IDataObject.\n");
		return FALSE;
	}

	if (m_hScManager == NULL)
	{
		TRACE0("CFileMgmtComponentData::Service_FDispatchMenuCommand() - Handle m_hScManager is NULL.\n");
		return FALSE;
	}
	
	if (nCommandId == cmServiceStart || nCommandId == cmServiceStartTask )
	{
		dwLastError = CServiceControlProgress::S_EStartService(
			::GetActiveWindow(),
			m_hScManager,
			strMachineName,
			strServiceName,
			strServiceDisplayName,
			0,
			NULL); // no startup parameters passed from menu command
	}
	else
	{
		DWORD dwControlCode;
		switch (nCommandId)
		{
		default:
			Assert(FALSE); // fall through

		case cmServiceStop:
		case cmServiceStopTask:
			dwControlCode = SERVICE_CONTROL_STOP;
			break;

		case cmServicePause:
		case cmServicePauseTask:
			dwControlCode = SERVICE_CONTROL_PAUSE;
			break;

		case cmServiceResume:
		case cmServiceResumeTask:
			dwControlCode = SERVICE_CONTROL_CONTINUE;
			break;

		case cmServiceRestart:
		case cmServiceRestartTask:
			dwControlCode = SERVICE_CONTROL_RESTART;
			break;
		} // switch

		dwLastError = CServiceControlProgress::S_EControlService(
			::GetActiveWindow(),
			m_hScManager,
			strMachineName,
			strServiceName,
			strServiceDisplayName,
			dwControlCode);

	} // if...else

	// We do want to to keep the connection opened
	
	return (dwLastError != CServiceControlProgress::errUserCancelStopDependentServices);
} // CFileMgmtComponentData::Service_FDispatchMenuCommand()


/////////////////////////////////////////////////////////////////////
//	CFileMgmtComponentData::Service_FInsertPropertyPages()
//
//	Insert property pages of the data object (service).
//
//	Return TRUE if successful, otherwise FALSE.
//
//	IMPLEMENTATION NOTES
//	The routine allocates a CServicePropertyData object which
//	is auto-deleted by the property sheet.  The property sheet will
//	delete the CServicePropertyData object on its WM_DESTROY message.
//
BOOL
CFileMgmtComponentData::Service_FInsertPropertyPages(
	LPPROPERTYSHEETCALLBACK pCallBack,	// OUT: Object to append property pages
	IDataObject * pDataObject,			// IN: Data object
	LONG_PTR lNotifyHandle)					// IN: Handle to notify the parent
	{
	Assert(pCallBack != NULL);
	Assert(pDataObject != NULL);
	Endorse(m_hScManager != NULL);

	if (m_hScManager == NULL)
		{
		// Typically because network connection was broken
		TRACE0("INFO: m_hScManager is NULL.\n");
		return FALSE;
		}

	CString strMachineName;
	CString strServiceName;
	CString strServiceDisplayName;

	if (!Service_FGetServiceInfoFromIDataObject(
		pDataObject,
		OUT &strMachineName,
		OUT &strServiceName,
		OUT &strServiceDisplayName))
		{
		Assert(FALSE);
		return FALSE;
		}

	CServicePropertyData * pSPD = new CServicePropertyData;
	if (!pSPD->FInit(
		pDataObject,
		strMachineName,
		strServiceName,
		strServiceDisplayName,
		lNotifyHandle))
		{
		TRACE1("Failure to query service %s.\n", (LPCTSTR)strServiceName);
		delete pSPD;
		return FALSE;
		}
	return pSPD->CreatePropertyPages(pCallBack);
	} // CFileMgmtComponentData::Service_FInsertPropertyPages()

#ifdef SNAPIN_PROTOTYPER
#include "protyper.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\svcprop2.h ===
// svcprop2.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CServicePageHwProfile dialog

class CServicePageHwProfile : public CPropertyPage
{
	DECLARE_DYNCREATE(CServicePageHwProfile)

// Construction
public:
	CServicePageHwProfile();
	~CServicePageHwProfile();

// Dialog Data
	//{{AFX_DATA(CServicePageHwProfile)
	enum { IDD = IDD_PROPPAGE_SERVICE_HWPROFILE };
	BOOL	m_fAllowServiceToInteractWithDesktop;
	CString m_strAccountName;
	CString	m_strPassword;
	CString	m_strPasswordConfirm;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CServicePageHwProfile)
	public:
	virtual BOOL OnApply();
	virtual BOOL OnSetActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CServicePageHwProfile)
	virtual BOOL OnInitDialog();
	afx_msg void OnItemChangedListHwProfiles(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDblclkListHwProfiles(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	afx_msg BOOL OnContextHelp(WPARAM wParam, LPARAM lParam);
	afx_msg void OnButtonDisableHwProfile();
	afx_msg void OnButtonEnableHwProfile();
	afx_msg void OnButtonChooseUser();
	afx_msg void OnChangeEditAccountName();
	afx_msg void OnRadioLogonasSystemAccount();
	afx_msg void OnRadioLogonasThisAccount();
	afx_msg void OnCheckServiceInteractWithDesktop();
	afx_msg void OnChangeEditPassword();
	afx_msg void OnChangeEditPasswordConfirm();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
// User defined variables
	CServicePropertyData * m_pData;

	// Logon stuff
	BOOL m_fAllowSetModified;	// TRUE => Respond to EN_CHANGE and call SetModified().  This is a workaround for a windows bug in the edit control
	BOOL m_fIsSystemAccount;	// TRUE => Service is running under 'LocalSystem'
	BOOL m_fPasswordDirty;		// TRUE => The user has modified the password
	UINT m_idRadioButton;		// Id of the last radio button selected

	// Hardware profile stuff
	HWND m_hwndListViewHwProfiles;
	INT m_iItemHwProfileEntry;
	TCHAR m_szHwProfileEnabled[64];		// To hold string "Enabled"
	TCHAR m_szHwProfileDisabled[64];	// To hold string "Disabled"
	

// User defined functions
	void SelectRadioButton(UINT idRadioButtonNew);
	void BuildHwProfileList();
	void ToggleCurrentHwProfileItem();
	void EnableHwProfileButtons();

}; // CServicePageHwProfile
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\svcprop3.cpp ===
// svcprop3.cpp : implementation file
//

#include "stdafx.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const UINT rgidComboFailureAction[cActionsMax] =
	{
	IDC_COMBO_FIRST_ATTEMPT,
	IDC_COMBO_SECOND_ATTEMPT,
	IDC_COMBO_SUBSEQUENT_ATTEMPTS,
	};

const TStringParamEntry rgzspeRecoveryAction[] = 
	{
	{ IDS_SVC_RECOVERY_NOACTION, SC_ACTION_NONE },
	{ IDS_SVC_RECOVERY_RESTARTSERVICE, SC_ACTION_RESTART },
	{ IDS_SVC_RECOVERY_RUNFILE, SC_ACTION_RUN_COMMAND },
	{ IDS_SVC_RECOVERY_REBOOTCOMPUTER, SC_ACTION_REBOOT },
	{ 0, 0 }
	};

// Group of control Ids to restart service
const UINT rgzidRestartService[] =
	{
//	IDC_GROUP_RESTARTSERVICE,
	IDC_STATIC_RESTARTSERVICE,
	IDC_STATIC_RESTARTSERVICE_3,
	IDC_EDIT_SERVICE_RESTART_DELAY,
	0
	};

const UINT rgzidRunFile[] =
	{
	IDC_STATIC_RUNFILE_1,
	IDC_STATIC_RUNFILE_2,
	IDC_STATIC_RUNFILE_3,
	IDC_EDIT_RUNFILE_FILENAME,
	IDC_BUTTON_BROWSE,
	IDC_EDIT_RUNFILE_PARAMETERS,
	IDC_CHECK_APPEND_ABENDNO,
	0
	};

const UINT rgzidRebootComputer[] =
	{
	IDC_BUTTON_REBOOT_COMPUTER,
	0
	};


/////////////////////////////////////////////////////////////////////////////
// CServicePageRecovery property page

IMPLEMENT_DYNCREATE(CServicePageRecovery, CPropertyPage)

CServicePageRecovery::CServicePageRecovery() : CPropertyPage(CServicePageRecovery::IDD)
	, m_pData( NULL ) // 581167-2002/03/07-JonN initialize m_pData
{
	//{{AFX_DATA_INIT(CServicePageRecovery)
	m_strRunFileCommand = _T("");
	m_strRunFileParam = _T("");
	m_fAppendAbendCount = FALSE;
	//}}AFX_DATA_INIT
}

CServicePageRecovery::~CServicePageRecovery()
{
}

void CServicePageRecovery::DoDataExchange(CDataExchange* pDX)
{
	// ISSUE-2002/03/07-JonN should handle these better
	Assert(m_pData != NULL);
	Assert(m_pData->m_SFA.cActions >= cActionsMax);
	Assert(m_pData->m_SFA.lpsaActions != NULL);

	if (m_pData->m_SFA.lpsaActions == NULL)	// Temporary checking for safety
		return;

	if (!pDX->m_bSaveAndValidate)
		{
		//
		//	Initialize data from m_pData into UI 
		//

		for (INT i = 0; i < cActionsMax; i++) 
			{
			// Fill each combobox with the list of failure/actions
			// and select the right failure/action
			HWND hwndCombo = HGetDlgItem(m_hWnd, rgidComboFailureAction[i]);
			ComboBox_FlushContent(hwndCombo);
			(void)ComboBox_FFill(
				hwndCombo,
				IN rgzspeRecoveryAction,
				m_pData->m_SFA.lpsaActions[i].Type);
			} // for
		Service_SplitCommandLine(
			IN m_pData->m_strRunFileCommand,
			OUT &m_strRunFileCommand,
			OUT &m_strRunFileParam,
			OUT &m_fAppendAbendCount);
		} // if

	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServicePageRecovery)
	DDX_Text(pDX, IDC_EDIT_RUNFILE_FILENAME, m_strRunFileCommand);
	DDX_Text(pDX, IDC_EDIT_RUNFILE_PARAMETERS, m_strRunFileParam);
	DDX_Check(pDX, IDC_CHECK_APPEND_ABENDNO, m_fAppendAbendCount);
	//}}AFX_DATA_MAP
	(void) SendDlgItemMessage(IDC_EDIT_SERVICE_RESET_ABEND_COUNT, EM_LIMITTEXT, 4);
	(void) SendDlgItemMessage(IDC_EDIT_SERVICE_RESTART_DELAY,     EM_LIMITTEXT, 4);
	DDX_Text(pDX, IDC_EDIT_SERVICE_RESET_ABEND_COUNT, m_pData->m_daysDisplayAbendCount);
	DDX_Text(pDX, IDC_EDIT_SERVICE_RESTART_DELAY, m_pData->m_minDisplayRestartService);

	if (pDX->m_bSaveAndValidate)
		{
		TrimString(m_strRunFileCommand);
		TrimString(m_strRunFileParam);
		Service_UnSplitCommandLine(
			OUT &m_pData->m_strRunFileCommand,
			IN m_strRunFileCommand,
			IN m_strRunFileParam);
		if (m_fAppendAbendCount)
			m_pData->m_strRunFileCommand += szAbend;
		} // if

} // CServicePageRecovery::DoDataExchange()


BEGIN_MESSAGE_MAP(CServicePageRecovery, CPropertyPage)
	//{{AFX_MSG_MAP(CServicePageRecovery)
	ON_CBN_SELCHANGE(IDC_COMBO_FIRST_ATTEMPT, OnSelchangeComboFirstAttempt)
	ON_CBN_SELCHANGE(IDC_COMBO_SECOND_ATTEMPT, OnSelchangeComboSecondAttempt)
	ON_CBN_SELCHANGE(IDC_COMBO_SUBSEQUENT_ATTEMPTS, OnSelchangeComboSubsequentAttempts)
	ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
	ON_BN_CLICKED(IDC_BUTTON_REBOOT_COMPUTER, OnButtonRebootComputer)
	ON_BN_CLICKED(IDC_CHECK_APPEND_ABENDNO, OnCheckAppendAbendno)
	ON_EN_CHANGE(IDC_EDIT_RUNFILE_FILENAME, OnChangeEditRunfileFilename)
	ON_EN_CHANGE(IDC_EDIT_RUNFILE_PARAMETERS, OnChangeEditRunfileParameters)
	ON_EN_CHANGE(IDC_EDIT_SERVICE_RESET_ABEND_COUNT, OnChangeEditServiceResetAbendCount)
	ON_EN_CHANGE(IDC_EDIT_SERVICE_RESTART_DELAY, OnChangeEditServiceRestartDelay)
	ON_MESSAGE(WM_HELP, OnHelp)
	ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServicePageRecovery message handlers

BOOL CServicePageRecovery::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
	
	UpdateUI();
	return TRUE;
} // CServicePageRecovery::OnInitDialog()


void CServicePageRecovery::UpdateUI()
{
	// ISSUE-2002/03/07-JonN should handle these better
	Assert(m_pData->m_SFA.cActions >= cActionsMax);
	Assert(m_pData->m_SFA.lpsaActions != NULL);
	// Get the failure/action code of each combobox
	for (INT i = 0; i < cActionsMax; i++) 
		{
		m_pData->m_SFA.lpsaActions[i].Type = (SC_ACTION_TYPE)ComboBox_GetSelectedItemData(
			HGetDlgItem(m_hWnd, rgidComboFailureAction[i]));
		Assert((int)m_pData->m_SFA.lpsaActions[i].Type != CB_ERR);
		} // for
	
	// The idea here is to enable/disable controls
	// depending on the chosen failure/action from
	// the comboboxes.
	BOOL fFound = FALSE;
	(void)m_pData->GetDelayForActionType(SC_ACTION_RESTART, OUT &fFound);
	EnableDlgItemGroup(m_hWnd, rgzidRestartService, fFound);
	(void)m_pData->GetDelayForActionType(SC_ACTION_RUN_COMMAND, OUT &fFound);
	EnableDlgItemGroup(m_hWnd, rgzidRunFile, fFound);
	(void)m_pData->GetDelayForActionType(SC_ACTION_REBOOT, OUT &fFound);
	EnableDlgItemGroup(m_hWnd, rgzidRebootComputer, fFound);

    //
    // JonN 9/4/01 463674
    // Services targeted to another computer: Service_ Properties->Recovery->Browse: Path...
    //
    if (!m_pData->m_strMachineName.IsEmpty())
    {
        GetDlgItem(IDC_BUTTON_BROWSE)->EnableWindow(FALSE);
    }
}

// ISSUE-2002/03/18-JonN We probably only need one MarkDirtyActionType method
void CServicePageRecovery::OnSelchangeComboFirstAttempt() 
{
	UpdateUI();
	SetModified();
	m_pData->SetDirty(CServicePropertyData::mskfDirtyActionType);
}

void CServicePageRecovery::OnSelchangeComboSecondAttempt() 
{
	UpdateUI();
	SetModified();
	m_pData->SetDirty(CServicePropertyData::mskfDirtyActionType);
}

void CServicePageRecovery::OnSelchangeComboSubsequentAttempts() 
{
	UpdateUI();
	SetModified();
	m_pData->SetDirty(CServicePropertyData::mskfDirtyActionType);
}

void CServicePageRecovery::OnButtonBrowse() 
{
	TCHAR szFileName[MAX_PATH];

	szFileName[0] = 0;
	if (UiGetFileName(m_hWnd,
		OUT szFileName,
		LENGTH(szFileName)))
		{
		SetDlgItemText(IDC_EDIT_RUNFILE_FILENAME, szFileName);
		SetModified();
		}
}

void CServicePageRecovery::OnButtonRebootComputer() 
{
	Assert(m_pData != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	CServiceDlgRebootComputer dlg(this);
	dlg.m_pData = m_pData;
	CThemeContextActivator activator;
	if (dlg.DoModal() == IDOK)
		{
		// The user has modified some data
		SetModified();
		}
}

// ISSUE-2002/03/18-JonN We probably only need one MarkDirtySFA method
/////////////////////////////////////////////////////////////////////
// "Reset 'Fail Count' after %d days"
void CServicePageRecovery::OnChangeEditServiceResetAbendCount() 
{
	SetModified();
	m_pData->SetDirty(CServicePropertyData::mskfDirtySFA);
}

/////////////////////////////////////////////////////////////////////
// "Restart service in %d minutes"
void CServicePageRecovery::OnChangeEditServiceRestartDelay() 
{
	SetModified();
	m_pData->SetDirty(CServicePropertyData::mskfDirtySFA);
}

// ISSUE-2002/03/18-JonN We probably only need one MarkDirtyRunFile method
/////////////////////////////////////////////////////////////////////
// "Run %s file"
void CServicePageRecovery::OnChangeEditRunfileFilename() 
{
	SetModified();
	m_pData->SetDirty(CServicePropertyData::mskfDirtyRunFile);
}

void CServicePageRecovery::OnChangeEditRunfileParameters() 
{
	SetModified();
	m_pData->SetDirty(CServicePropertyData::mskfDirtyRunFile);
}

void CServicePageRecovery::OnCheckAppendAbendno() 
{
	SetModified();
	m_pData->SetDirty(CServicePropertyData::mskfDirtyRunFile);
}

/////////////////////////////////////////////////////////////////////
//	Help
BOOL CServicePageRecovery::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
	return DoHelp(lParam, HELP_DIALOG_TOPIC(IDD_PROPPAGE_SERVICE_RECOVERY));
}

BOOL CServicePageRecovery::OnContextHelp(WPARAM wParam, LPARAM /*lParam*/)
{
	return DoContextHelp(wParam, HELP_DIALOG_TOPIC(IDD_PROPPAGE_SERVICE_RECOVERY));
}


/////////////////////////////////////////////////////////////////////////////
// CServicePageRecovery2 property page
// JonN 4/20/01 348163
IMPLEMENT_DYNCREATE(CServicePageRecovery2, CPropertyPage)

CServicePageRecovery2::CServicePageRecovery2() : CPropertyPage(CServicePageRecovery2::IDD)
	, m_pData( NULL ) // 581167-2002/03/07-JonN should initialize m_pData
{
	//{{AFX_DATA_INIT(CServicePageRecovery2)
	//}}AFX_DATA_INIT
}

CServicePageRecovery2::~CServicePageRecovery2()
{
}

BEGIN_MESSAGE_MAP(CServicePageRecovery2, CPropertyPage)
	//{{AFX_MSG_MAP(CServicePageRecovery2)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CServiceDlgRebootComputer dialog
CServiceDlgRebootComputer::CServiceDlgRebootComputer(CWnd* pParent /*=NULL*/)
	: CDialog(CServiceDlgRebootComputer::IDD, pParent)
	, m_pData( NULL ) // 581167-2002/03/07-JonN should initialize m_pData
{
	//{{AFX_DATA_INIT(CServiceDlgRebootComputer)
	m_uDelayRebootComputer = 0;
	m_fRebootMessage = FALSE;
	//}}AFX_DATA_INIT
}


void CServiceDlgRebootComputer::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServiceDlgRebootComputer)
	DDX_Text(pDX, IDC_EDIT_REBOOT_COMPUTER_DELAY, m_uDelayRebootComputer);
	DDV_MinMaxUInt(pDX, m_uDelayRebootComputer, 0, 100000);
	DDX_Check(pDX, IDC_REBOOT_MESSAGE_CHECKBOX, m_fRebootMessage);
	DDX_Text(pDX, IDC_EDIT_REBOOT_MESSAGE, m_strRebootMessage);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CServiceDlgRebootComputer, CDialog)
	//{{AFX_MSG_MAP(CServiceDlgRebootComputer)
	ON_BN_CLICKED(IDC_REBOOT_MESSAGE_CHECKBOX, OnCheckboxClicked)
	ON_EN_CHANGE(IDC_EDIT_REBOOT_MESSAGE, OnChangeEditRebootMessage)
	ON_MESSAGE(WM_HELP, OnHelp)
	ON_MESSAGE(WM_CONTEXTMENU, OnContextHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CServiceDlgRebootComputer::OnInitDialog() 
{
	// ISSUE-2002/03/18-JonN handle null m_pData
	Assert(m_pData != NULL);
	m_uDelayRebootComputer = m_pData->m_minDisplayRebootComputer;
	m_strRebootMessage = m_pData->m_strRebootMessage;
	TrimString(m_strRebootMessage);
	m_fRebootMessage = !m_strRebootMessage.IsEmpty();
	CDialog::OnInitDialog();
	if (m_strRebootMessage.IsEmpty())
		{
		// Load a default message
		if (NULL != m_pData)
			{
			TCHAR szName[MAX_COMPUTERNAME_LENGTH + 1];
			LPCTSTR pszTargetMachine = L"";
			if ( !m_pData->m_strMachineName.IsEmpty() )
				{
				pszTargetMachine = m_pData->m_strMachineName;
		        }
			else
				{
                // JonN 11/21/00 PREFIX 226771
				DWORD dwSize = sizeof(szName)/sizeof(TCHAR);
				::ZeroMemory( szName, sizeof(szName) );
				VERIFY( ::GetComputerName(szName, &dwSize) );
				pszTargetMachine = szName;
			    }
			m_strRebootMessage.FormatMessage(
						IDS_SVC_REBOOT_MESSAGE_DEFAULT,
						m_pData->m_strServiceDisplayName,
						pszTargetMachine );
			}
		else
			{
			ASSERT(FALSE);
			}
		}
	return TRUE;
}

void CServiceDlgRebootComputer::OnCheckboxClicked() 
{
	if ( IsDlgButtonChecked(IDC_REBOOT_MESSAGE_CHECKBOX) )
	{
		SetDlgItemText(IDC_EDIT_REBOOT_MESSAGE, m_strRebootMessage);
	}
	else
	{
		CString strTemp;
		GetDlgItemText(IDC_EDIT_REBOOT_MESSAGE, OUT strTemp);
		if (!strTemp.IsEmpty())
			m_strRebootMessage = strTemp;
		SetDlgItemText(IDC_EDIT_REBOOT_MESSAGE, _T(""));
	}
}

void CServiceDlgRebootComputer::OnChangeEditRebootMessage() 
{
	LRESULT cch = SendDlgItemMessage(IDC_EDIT_REBOOT_MESSAGE, WM_GETTEXTLENGTH);
	if ( (cch==0) != !IsDlgButtonChecked(IDC_REBOOT_MESSAGE_CHECKBOX) )
		CheckDlgButton(IDC_REBOOT_MESSAGE_CHECKBOX, (cch!=0));
}

BOOL CServiceDlgRebootComputer::OnHelp(WPARAM /*wParam*/, LPARAM lParam)
{
	return DoHelp(lParam, HELP_DIALOG_TOPIC(IDD_SERVICE_REBOOT_COMPUTER));
}

BOOL CServiceDlgRebootComputer::OnContextHelp(WPARAM wParam, LPARAM /*lParam*/)
{
	return DoContextHelp(wParam, HELP_DIALOG_TOPIC(IDD_SERVICE_REBOOT_COMPUTER));
}

void CServiceDlgRebootComputer::OnOK() 
{
	if (!UpdateData())
		{
		return;
		}	
	Assert(m_pData != NULL);
	if (m_uDelayRebootComputer != m_pData->m_minDisplayRebootComputer)
		{
		m_pData->m_minDisplayRebootComputer = m_uDelayRebootComputer;
		m_pData->SetDirty(CServicePropertyData::mskfDirtyRebootMessage);
		}
	if (!m_fRebootMessage)
		{
		// No reboot message
		m_strRebootMessage.Empty();
		}
	else
		{
		TrimString(m_strRebootMessage);
		}
	if (m_strRebootMessage != m_pData->m_strRebootMessage)
		{
		m_pData->m_strRebootMessage = m_strRebootMessage;
		m_pData->SetDirty(CServicePropertyData::mskfDirtyRebootMessage);
		}
	EndDialog(IDOK);
} // CServiceDlgRebootComputer::OnOK()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\svcutils.h ===
//	SvcUtils.h

#include "stdutils.h" // FCompareMachineNames

// Help file for filemgmt.dll
const TCHAR g_szHelpFileFilemgmt[] = _T("filemgmt.hlp");	// Not subject to localization


// This enumeration should not be changed unless the string resources
// and all the array indices updated.
enum
	{
	iServiceActionNil = -1,
	iServiceActionStart,		// Start service
	iServiceActionStop,			// Stop service
	iServiceActionPause,		// Pause service
	iServiceActionResume,		// Resume service
	iServiceActionRestart,		// Stop and Start service

	iServiceActionMax			// Must be last
	};

/////////////////////////////////////////////////////////////////////
// String szAbend
// This string is used for the 'Service Failure Recovery' dialog
// to append the 'Fail Count' to the command line.  This string
// is not localized, so it should not be moved into the
// resources.
//
// NOTES
// The variable should be renamed to reflect its content.  Currently
// 'abend' means 'fails'.
const TCHAR szAbend[] = L" /fail=%1%";


//
//	Service running state
//
extern CString g_strSvcStateStarted;
extern CString g_strSvcStateStarting;
extern CString g_strSvcStateStopped;
extern CString g_strSvcStateStopping;
extern CString g_strSvcStatePaused;
extern CString g_strSvcStatePausing;
extern CString g_strSvcStateResuming;

//
//	Service startup type
//
extern CString g_strSvcStartupBoot;
extern CString g_strSvcStartupSystem;
extern CString g_strSvcStartupAutomatic;
extern CString g_strSvcStartupManual;
extern CString g_strSvcStartupDisabled;

//
//	Service startup account
//  JonN 188203 11/13/00
//
extern CString g_strLocalSystem;
extern CString g_strLocalService;
extern CString g_strNetworkService;

extern CString g_strUnknown;
extern CString g_strLocalMachine;


void Service_LoadResourceStrings();

LPCTSTR Service_PszMapStateToName(DWORD dwServiceState, BOOL fLongString = FALSE);

// -1L is blank string
LPCTSTR Service_PszMapStartupTypeToName(DWORD dwStartupType);

// JonN 11/14/00 188203 support LocalService/NetworkService
LPCTSTR Service_PszMapStartupAccountToName(LPCTSTR pcszStartupAccount);

BOOL Service_FGetServiceButtonStatus(
	SC_HANDLE hScManager,
	CONST TCHAR * pszServiceName,
	OUT BOOL rgfEnableButton[iServiceActionMax],
	OUT DWORD * pdwCurrentState = NULL,
	BOOL fSilentError = FALSE);

void Service_SplitCommandLine(
	LPCTSTR pszFullCommand,
	CString * pstrBinaryPath,
	CString * pstrParameters,
	BOOL * pfAbend = NULL);

void Service_UnSplitCommandLine(
	CString * pstrFullCommand,
	LPCTSTR pszBinaryPath,
	LPCTSTR pszParameters);

void GetMsg(OUT CString& strMsg, DWORD dwErr, UINT wIdString = 0, ...);

// title is "Shared Folders"
INT DoErrMsgBox(HWND hwndParent, UINT uType, DWORD dwErr, UINT wIdString = 0, ...);

// title is "Services"
INT DoServicesErrMsgBox(HWND hwndParent, UINT uType, DWORD dwErr, UINT wIdString = 0, ...);

BOOL UiGetUser(
	HWND hwndOwner,
	BOOL fIsContainer,
	LPCTSTR pszServerName,
	IN OUT CString& strrefUser);

// Help Support
#define HELP_DIALOG_TOPIC(DialogName)	g_aHelpIDs_##DialogName

BOOL DoHelp(LPARAM lParam, const DWORD rgzHelpIDs[]);
BOOL DoContextHelp(WPARAM wParam, const DWORD rgzHelpIDs[]);


#ifdef SNAPIN_PROTOTYPER
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
class CStringIterator
{
  private:
	CString m_strData;		// Data string to parse
	CONST TCHAR * m_pszDataNext;	// Pointer to the next data to parse

  public:
	CStringIterator()
		{
		m_pszDataNext = m_strData;
		}

	void SetString(CONST TCHAR * pszStringData)
		{
		m_strData = pszStringData;
		m_pszDataNext = m_strData;
		}

	BOOL FGetNextString(OUT CString& rStringOut)
		{
		Assert(m_pszDataNext != NULL);

		if (*m_pszDataNext == '\0')
			{
			rStringOut.Empty();
			return FALSE;
			}
		CONST TCHAR * pchStart = m_pszDataNext;
		while (*m_pszDataNext != '\0')
			{
			if (*m_pszDataNext == ';')
				{
				// HACK: Truncating the string
				*(TCHAR *)m_pszDataNext++ = '\0';
				break;
				}
			m_pszDataNext++;
			}
		rStringOut = pchStart;	// Copy the string
		return TRUE;
		}
}; // CStringIterator

#endif // SNAPIN_PROTOTYPER
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\toolbar.cpp ===
// toolbar.cpp : Implementation of toolbars for snapin

#include "stdafx.h"
#include "cookie.h"
#include "cmponent.h"
#include "compdata.h"
#include "dataobj.h"

#include <compuuid.h> // UUIDs for Computer Management

#include "macros.h"
USE_HANDLE_MACROS("FILEMGMT(toolbar.cpp)")

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

// We keep the strings in globals because multiple IComponents will all
// have their own IToolbars.  We do not keep the bitmaps in globals because
// of difficulties with the global destruction mechanism, see compdata.h.

// The MMCBUTTON structures contain resource IDs for the strings which will
// be loaded into the CString array when the first instance of the toolbar
// is loaded.
//
// CODEWORK We need a mechanism to free these strings.

MMCBUTTON g_FileMgmtSnapinButtons[] =
{
 { 0, IDS_BUTTON_NEWSHARE, TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
};
CString* g_astrFileMgmtButtonStrings = NULL; // dynamic array of CStrings
BOOL g_bLoadedFileMgmtStrings = FALSE;

MMCBUTTON g_SvcMgmtSnapinButtons[] =
{
 // The first button will be either Start or Resume.
 // One of these two entries will be removed later.
 { 0, cmServiceResume, !TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
 { 0, cmServiceStart, !TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
 { 1, cmServiceStop, !TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
 { 2, cmServicePause, !TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
 { 3, cmServiceRestart, !TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0 },
};
CString* g_astrSvcMgmtButtonStrings = NULL; // dynamic array of CStrings
BOOL g_bLoadedSvcMgmtStrings = FALSE;


void LoadButtonArray(
  MMCBUTTON* pButtonArray,
  BOOL* pbLoadedStrings,
  CString** pastrStringArray,
  UINT cButtons
  )
{
  ASSERT( NULL != pbLoadedStrings &&
      NULL != pButtonArray &&
      NULL != pastrStringArray);

  if ( !*pbLoadedStrings )
  {
    // load strings
    MMCBUTTON* pLoadButtonArray = pButtonArray;
    UINT cLoadButtons = cButtons;
    *pastrStringArray = new CString[2*cButtons];
    for (UINT i = 0; i < cButtons; i++)
    {
      UINT iButtonTextId = 0, iTooltipTextId = 0;
      
      switch (pButtonArray[i].idCommand)
      {
      case IDS_BUTTON_NEWSHARE:
        iButtonTextId = IDS_BUTTON_NEWSHARE;
        iTooltipTextId = IDS_TOOLTIP_NEWSHARE;
        break;
      case cmServiceResume:
        iButtonTextId = IDS_BUTTON_SERVICE_RESUME;
        iTooltipTextId = IDS_TOOLTIP_SERVICE_RESUME;
        break;
      case cmServiceStart:
        iButtonTextId = IDS_BUTTON_SERVICE_START;
        iTooltipTextId = IDS_TOOLTIP_SERVICE_START;
        break;
      case cmServiceStop:
        iButtonTextId = IDS_BUTTON_SERVICE_STOP;
        iTooltipTextId = IDS_TOOLTIP_SERVICE_STOP;
        break;
      case cmServicePause:
        iButtonTextId = IDS_BUTTON_SERVICE_PAUSE;
        iTooltipTextId = IDS_TOOLTIP_SERVICE_PAUSE;
        break;
      case cmServiceRestart:
        iButtonTextId = IDS_BUTTON_SERVICE_RESTART;
        iTooltipTextId = IDS_TOOLTIP_SERVICE_RESTART;
        break;
      default:
        ASSERT(FALSE);
        break;
      }

      VERIFY( (*pastrStringArray)[i*2].LoadString(iButtonTextId) );
      pButtonArray[i].lpButtonText =
        const_cast<BSTR>((LPCTSTR)((*pastrStringArray)[i*2]));

      VERIFY( (*pastrStringArray)[(i*2)+1].LoadString(iTooltipTextId) );
      pButtonArray[i].lpTooltipText =
        const_cast<BSTR>((LPCTSTR)((*pastrStringArray)[(i*2)+1]));
    }

    *pbLoadedStrings = TRUE;
  }
}


HRESULT LoadToolbar(
  LPTOOLBAR pToolbar,
  CBitmap& refbitmap,
  MMCBUTTON* pButtonArray,
  UINT cButtons
  )
{
  ASSERT( NULL != pToolbar &&
        NULL != pButtonArray );

  HRESULT hr = pToolbar->AddBitmap(cButtons, refbitmap, 16, 16, RGB(255,0,255) );
  if ( FAILED(hr) )
  {
    ASSERT(FALSE);
    return hr;
  }

  hr = pToolbar->AddButtons(cButtons, pButtonArray);
  if ( FAILED(hr) )
  {
    ASSERT(FALSE);
    return hr;
  }

  return hr;
}

STDMETHODIMP CFileMgmtComponent::SetControlbar(LPCONTROLBAR pControlbar)
{
  MFC_TRY;

  SAFE_RELEASE(m_pControlbar); // just in case

  if (NULL != pControlbar)
  {
    m_pControlbar = pControlbar; // CODEWORK should use smartpointer
    m_pControlbar->AddRef();
  }

  return S_OK;

  MFC_CATCH;
}

STDMETHODIMP CFileMgmtComponent::ControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
  MFC_TRY;

  #ifdef SNAPIN_PROTOTYPER
  return S_OK;
  #endif

    HRESULT hr=S_OK;

    switch (event)
    {

    case MMCN_BTN_CLICK:
    TRACE(_T("CFileMgmtComponent::ControlbarNotify - MMCN_BTN_CLICK\n"));
    {
      LPDATAOBJECT pDataObject = reinterpret_cast<LPDATAOBJECT>(arg);
      UINT idButton = (UINT)param;
      hr = OnToolbarButton( pDataObject, idButton );
    }
    break;

    case MMCN_SELECT:
    TRACE(_T("CFileMgmtComponent::ControlbarNotify - MMCN_SELECT\n"));
    {
      if (!(LOWORD(arg))) // bScope
      {
        // result pane
        hr = UpdateToolbar(
          reinterpret_cast<LPDATAOBJECT>(param),
          !!(HIWORD(arg)) );
      }
      else
      {
        // scope pane
        hr = AddToolbar( reinterpret_cast<LPDATAOBJECT>(param),
                                 !!(HIWORD(arg))  );
      }
    }
    break;
    
    default:
        ASSERT(FALSE); // Unhandled event 
    }

    return hr;

  MFC_CATCH;
}

HRESULT CFileMgmtComponent::ServiceToolbarButtonState(
  LPDATAOBJECT pServiceDataObject,
  BOOL fSelected )
{
  BOOL rgfMenuFlags[iServiceActionMax];
  for (INT i = 0; i < iServiceActionMax; i++)
    rgfMenuFlags[i] = FALSE;

  if ( fSelected )
  {
    CString strMachineName;
    CString strServiceName;
    if (!QueryComponentDataRef().Service_FGetServiceInfoFromIDataObject(
      pServiceDataObject,
      OUT &strMachineName,
      OUT &strServiceName,
      NULL))
    {
      ASSERT(FALSE);
    }
    else
    {
      if (strMachineName.IsEmpty())
        strMachineName = g_strLocalMachine;

      // Get the menu flags
      {
        ASSERT(NULL != QueryComponentDataRef().m_hScManager);
        CWaitCursor wait;
        if (!Service_FGetServiceButtonStatus( // this will report errors itself
          QueryComponentDataRef().m_hScManager,
          strServiceName,
          OUT rgfMenuFlags,
          NULL,  // pdwCurrentState
          TRUE)) // fSilentError
        {
          // let's not do this m_hScManager = NULL;
        }
      }
    }
  }

  // update toolbar
  ASSERT( NULL != m_pSvcMgmtToolbar );
//
// JonN 5/2/00 106431:
// Services snapin calls DeleteButton with an index but never called InsertButton
//
//  HRESULT hr = m_pSvcMgmtToolbar->DeleteButton(0);
//  if ( FAILED(hr) )
//    return hr;
  HRESULT hr = S_OK;

  // JonN 3/15/01 210065
  // Services snapin: "Resume service" toolbar button stays enabled after it is first displayed
  BOOL fShowResumeButton = !rgfMenuFlags[iServiceActionStart] &&
                            rgfMenuFlags[iServiceActionResume];
  VERIFY( SUCCEEDED( m_pSvcMgmtToolbar->SetButtonState(
      cmServiceStart, HIDDEN, fShowResumeButton)));
  VERIFY( SUCCEEDED( m_pSvcMgmtToolbar->SetButtonState(
      cmServiceResume, HIDDEN, !fShowResumeButton)));
  VERIFY( SUCCEEDED( m_pSvcMgmtToolbar->SetButtonState(
      cmServiceStart, ENABLED, rgfMenuFlags[iServiceActionStart])));
  VERIFY( SUCCEEDED( m_pSvcMgmtToolbar->SetButtonState(
      cmServiceResume, ENABLED, rgfMenuFlags[iServiceActionResume])));

  hr = m_pSvcMgmtToolbar->SetButtonState(
        cmServiceStop, ENABLED, rgfMenuFlags[iServiceActionStop] );
  if ( FAILED(hr) )
    return hr;
  hr = m_pSvcMgmtToolbar->SetButtonState(
        cmServicePause, ENABLED, rgfMenuFlags[iServiceActionPause] );
  if ( FAILED(hr) )
    return hr;
  hr = m_pSvcMgmtToolbar->SetButtonState(
        cmServiceRestart, ENABLED, rgfMenuFlags[iServiceActionRestart] );
  return hr;
}

// CODEWORK  The following algorithm is imperfect, but will do
// for now.  We ignore the old selection, and attach
// our fixed toolbar iff the new selection is our type.
HRESULT CFileMgmtComponent::AddToolbar(LPDATAOBJECT pdoScopeIsSelected,
                                       BOOL fSelected)
{
  HRESULT hr = S_OK;
  int i = 0;
  GUID guidSelectedObject;
  do { // false loop
    if (NULL == pdoScopeIsSelected)
    {
      // toolbar will be automatically detached
      return S_OK;
    }

    if ( FAILED(ExtractObjectTypeGUID(pdoScopeIsSelected,
                                    &guidSelectedObject)) )
    {
      ASSERT(FALSE); // shouldn't have given me non-MMC data object
      return S_OK;
    }
    if (NULL == m_pControlbar)
    {
      ASSERT(FALSE);
      return S_OK;
    }
#ifdef DEBUG
    if ( QueryComponentDataRef().IsExtendedNodetype(guidSelectedObject) )
    {
      ASSERT(FALSE && "shouldn't have given me extension parent nodetype");
      return S_OK;
    }
#endif

    switch (CheckObjectTypeGUID( &guidSelectedObject ) )
    {
    case FILEMGMT_SHARES:
      if (QueryComponentDataRef().GetIsSimpleUI() || IsServiceSnapin())
        break;
      if (NULL == m_pFileMgmtToolbar)
      {
        hr = m_pControlbar->Create( 
          TOOLBAR, this, reinterpret_cast<LPUNKNOWN*>(&m_pFileMgmtToolbar) );
        if ( FAILED(hr) )
        {
          ASSERT(FALSE);
          break;
        }
        ASSERT(NULL != m_pFileMgmtToolbar);
        if ( !QueryComponentDataRef().m_fLoadedFileMgmtToolbarBitmap )
        {
          VERIFY( QueryComponentDataRef().m_bmpFileMgmtToolbar.LoadBitmap(
            IDB_FILEMGMT_TOOLBAR ) );
          QueryComponentDataRef().m_fLoadedFileMgmtToolbarBitmap = TRUE;
        }
        LoadButtonArray(
          g_FileMgmtSnapinButtons,
          &g_bLoadedFileMgmtStrings,
          &g_astrFileMgmtButtonStrings,
          ARRAYLEN(g_FileMgmtSnapinButtons)
          );
        hr = LoadToolbar(
          m_pFileMgmtToolbar,
          QueryComponentDataRef().m_bmpFileMgmtToolbar,
          g_FileMgmtSnapinButtons,
          ARRAYLEN(g_FileMgmtSnapinButtons)
          );
      }
      if (FAILED(hr))
        break;
      // New Share is always enabled
      VERIFY( SUCCEEDED(m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pFileMgmtToolbar)) );
      for (i = 0; i < ARRAYLEN(g_FileMgmtSnapinButtons); i++) {
        m_pFileMgmtToolbar->SetButtonState(
          g_FileMgmtSnapinButtons[i].idCommand, 
          ENABLED, 
          fSelected);
      }
      break;
    case FILEMGMT_SERVICES:
      if ( !IsServiceSnapin() )
        break;
      if (NULL == m_pSvcMgmtToolbar)
      {
        hr = m_pControlbar->Create( 
          TOOLBAR, this, reinterpret_cast<LPUNKNOWN*>(&m_pSvcMgmtToolbar) );
        if ( FAILED(hr) )
        {
          ASSERT(FALSE);
          break;
        }
        ASSERT(NULL != m_pSvcMgmtToolbar);
        if ( !QueryComponentDataRef().m_fLoadedSvcMgmtToolbarBitmap )
        {
          VERIFY( QueryComponentDataRef().m_bmpSvcMgmtToolbar.LoadBitmap(
            IDB_SVCMGMT_TOOLBAR ) );
          QueryComponentDataRef().m_fLoadedSvcMgmtToolbarBitmap = TRUE;
        }
        LoadButtonArray(
          g_SvcMgmtSnapinButtons,
          &g_bLoadedSvcMgmtStrings,
          &g_astrSvcMgmtButtonStrings,
          ARRAYLEN(g_SvcMgmtSnapinButtons)
          );
        // JonN 3/15/01 210065
        // "Resume service" toolbar button stays enabled after it is first displayed
        hr = LoadToolbar(
          m_pSvcMgmtToolbar,
          QueryComponentDataRef().m_bmpSvcMgmtToolbar,
          g_SvcMgmtSnapinButtons,
          ARRAYLEN(g_SvcMgmtSnapinButtons)
          );
      }
      if (FAILED(hr))
        break;
      VERIFY( SUCCEEDED(m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pSvcMgmtToolbar)) );
      break;
    case FILEMGMT_ROOT:
    case FILEMGMT_SESSIONS:
    case FILEMGMT_RESOURCES:
      if (m_pControlbar && m_pFileMgmtToolbar)
      {
        m_pControlbar->Detach(m_pFileMgmtToolbar);
      }
      break;

    #ifdef SNAPIN_PROTOTYPER
    case FILEMGMT_PROTOTYPER:
      break; // no toolbar
    case FILEMGMT_PROTOTYPER_LEAF:
      break; // no toolbar
    #endif    

    default:
          ASSERT(FALSE); // unknown type
      break;
    }
  } while (FALSE); // false loop

  return hr;
}

HRESULT CFileMgmtComponent::UpdateToolbar(
  LPDATAOBJECT pdoResultIsSelected,
  BOOL fSelected )
{
  int i = 0;
  GUID guidSelectedObject;
  HRESULT hr = S_OK;
  BOOL bMultiSelectObject = IsMultiSelectObject(pdoResultIsSelected);
  if (bMultiSelectObject)
  {
    //
    // pdoResultIsSelected is the composite data object (MMC_MS_DO) created by MMC.
    // We need to crack it to retrieve the multiselect data object (SI_MS_DO)
    // we provided to MMC in QueryDataObject().
    //
    IDataObject *piSIMSDO = NULL;
    hr = GetSnapinMultiSelectDataObject(pdoResultIsSelected, &piSIMSDO);
    if (SUCCEEDED(hr))
    {
        CFileMgmtDataObject *pDataObj = NULL;
        hr = ExtractData(piSIMSDO, CFileMgmtDataObject::m_CFInternal, &pDataObj, sizeof(pDataObj));
        if (SUCCEEDED(hr))
        {
            //
            // get the internal list of data objects of selected items, operate on one of them.
            //
            CDataObjectList* pMultiSelectObjList = pDataObj->GetMultiSelectObjList();
            ASSERT(!pMultiSelectObjList->empty());
            hr = ExtractObjectTypeGUID(*(pMultiSelectObjList->begin()), &guidSelectedObject);
        }

        piSIMSDO->Release();
    }
  } else
  {
    hr = ExtractObjectTypeGUID(pdoResultIsSelected, &guidSelectedObject);
  }

  if (FAILED(hr)) // shouldn't have given me non-MMC data object
    return hr;

  int objecttype = CheckObjectTypeGUID( &guidSelectedObject );

  switch (objecttype)
  {
  case FILEMGMT_SERVICE:
    ServiceToolbarButtonState( pdoResultIsSelected, fSelected );
    break;
  case FILEMGMT_SHARES:
    if (m_pControlbar && m_pFileMgmtToolbar && !QueryComponentDataRef().GetIsSimpleUI())
    {
      m_pControlbar->Attach(TOOLBAR, m_pFileMgmtToolbar);
      for (i = 0; i < ARRAYLEN(g_FileMgmtSnapinButtons); i++) {
        m_pFileMgmtToolbar->SetButtonState(
          g_FileMgmtSnapinButtons[i].idCommand, 
          ENABLED, 
          fSelected);
      }
    }
    break;
  case FILEMGMT_SHARE:
  case FILEMGMT_SESSIONS:
  case FILEMGMT_RESOURCES:
    if (m_pControlbar && m_pFileMgmtToolbar)
    {
      m_pControlbar->Detach(m_pFileMgmtToolbar);
    }
  case FILEMGMT_SESSION:
  case FILEMGMT_RESOURCE:
    break;
  default:
    break;
  }

  return S_OK;
}

HRESULT CFileMgmtComponent::OnToolbarButton(LPDATAOBJECT pDataObject, UINT idButton)
{
  switch (idButton)
  {
  case IDS_BUTTON_NEWSHARE:
    {
      BOOL fRefresh = QueryComponentDataRef().NewShare( pDataObject );
      if (fRefresh)
      {
        // JonN 12/03/98 updated to use new method
        VERIFY(SUCCEEDED( RefreshAllViews(pDataObject) ));
      }
    }
    break;
  case cmServiceStart:
  case cmServiceStop:
  case cmServicePause:
  case cmServiceResume:
  case cmServiceRestart:
    VERIFY( SUCCEEDED(Command(idButton, pDataObject)) );
    break;
  default:
    ASSERT(FALSE);
    break;
  }
  return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\svcutils.cpp ===
/////////////////////////////////////////////////////////////////////
//
//    SvcUtils.cpp
//
//    Utilities routines specific for system services.
//    Mostly used to display services properties.
//
//    HISTORY
//    t-danmo        96.10.10    Creation.
//
/////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include <iads.h>            
#include <iadsp.h>            // IADsPathname
#include <atlcom.h>            // CComPtr and CComBSTR
extern "C"
{
#include <objsel.h>            // IDsObjectPicker
}

//
//    Service current state
//
CString g_strSvcStateStarted;    // Service is started
CString g_strSvcStateStarting;    // Service is starting
CString g_strSvcStateStopped;    // Service is stopped
CString g_strSvcStateStopping;    // Service is stopping
CString g_strSvcStatePaused;    // Service is paused
CString g_strSvcStatePausing;    // Service is pausing
CString g_strSvcStateResuming;    // Service is resuming

//
//    Service startup type
//
CString g_strSvcStartupBoot;
CString g_strSvcStartupSystem;
CString g_strSvcStartupAutomatic;
CString g_strSvcStartupManual;
CString g_strSvcStartupDisabled;

//
//	Service startup account
//  JonN 188203 11/13/00
//
CString g_strLocalSystem;
CString g_strLocalService;
CString g_strNetworkService;

CString g_strUnknown;
CString g_strLocalMachine;        // "Local Machine"

BOOL g_fStringsLoaded = FALSE;

/////////////////////////////////////////////////////////////////////
void
Service_LoadResourceStrings()
    {

    if (g_fStringsLoaded)
        return;
    g_fStringsLoaded = TRUE;

    VERIFY(g_strSvcStateStarted.LoadString(IDS_SVC_STATUS_STARTED));
    VERIFY(g_strSvcStateStarting.LoadString(IDS_SVC_STATUS_STARTING));
    VERIFY(g_strSvcStateStopped.LoadString(IDS_SVC_STATUS_STOPPED));
    VERIFY(g_strSvcStateStopping.LoadString(IDS_SVC_STATUS_STOPPING));
    VERIFY(g_strSvcStatePaused.LoadString(IDS_SVC_STATUS_PAUSED));
    VERIFY(g_strSvcStatePausing.LoadString(IDS_SVC_STATUS_PAUSING));
    VERIFY(g_strSvcStateResuming.LoadString(IDS_SVC_STATUS_RESUMING));

    VERIFY(g_strSvcStartupBoot.LoadString(IDS_SVC_STARTUP_BOOT));
    VERIFY(g_strSvcStartupSystem.LoadString(IDS_SVC_STARTUP_SYSTEM));
    VERIFY(g_strSvcStartupAutomatic.LoadString(IDS_SVC_STARTUP_AUTOMATIC));
    VERIFY(g_strSvcStartupManual.LoadString(IDS_SVC_STARTUP_MANUAL));
    VERIFY(g_strSvcStartupDisabled.LoadString(IDS_SVC_STARTUP_DISABLED));

    // JonN 11/13/00 188203 support LocalService/NetworkService
    VERIFY(g_strLocalSystem.LoadString(IDS_SVC_STARTUP_LOCALSYSTEM));
    VERIFY(g_strLocalService.LoadString(IDS_SVC_STARTUP_LOCALSERVICE));
    VERIFY(g_strNetworkService.LoadString(IDS_SVC_STARTUP_NETWORKSERVICE));

    VERIFY(g_strUnknown.LoadString(IDS_SVC_UNKNOWN));
    VERIFY(g_strLocalMachine.LoadString(IDS_LOCAL_MACHINE));
    } // Service_LoadResourceStrings()


/////////////////////////////////////////////////////////////////////
//    Service_PszMapStateToName()
//
//    Map the service state to a null-terminated string.
//    
// ISSUE-2002/03/18-JonN There is a theoretical issue here that the returned
// LPCTSTR could go bad if the global strings are reloaded.  This is unlikely.
LPCTSTR
Service_PszMapStateToName(
    DWORD dwServiceState,    // From SERVICE_STATUS.dwCurrentState
    BOOL fLongString)        // TRUE => Display the name in a long string format
    {
    switch(dwServiceState)
        {
    case SERVICE_STOPPED:
        if (fLongString)
            {
            return g_strSvcStateStopped;
            }
        //  Note that, by design, we never display the service
        //  status as "Stopped".  Instead, we just don't display
        //  the status.  Hence, the empty string.
        return _T("");

    case SERVICE_STOP_PENDING:
        return g_strSvcStateStopping;

    case SERVICE_RUNNING:
         return g_strSvcStateStarted;
    
    case SERVICE_START_PENDING:
        return g_strSvcStateStarting;

    case SERVICE_PAUSED:
        return g_strSvcStatePaused;

    case SERVICE_PAUSE_PENDING:
        return g_strSvcStatePausing;

    case SERVICE_CONTINUE_PENDING:
        return g_strSvcStateResuming;

    default:
        TRACE0("INFO Unknown service state.\n");
        } // switch
    return g_strUnknown;
    } // Service_PszMapStateToName()


/////////////////////////////////////////////////////////////////////
//    Service_PszMapStartupTypeToName()
//
//    Map the service startup type to a null-terminated string.
//  -1L is blank string
//
LPCTSTR
Service_PszMapStartupTypeToName(DWORD dwStartupType)
    {
    switch(dwStartupType)
        {
    case SERVICE_BOOT_START:
        return g_strSvcStartupBoot;

    case SERVICE_SYSTEM_START:
        return g_strSvcStartupSystem;

    case SERVICE_AUTO_START:
        return g_strSvcStartupAutomatic;

    case SERVICE_DEMAND_START:
        return g_strSvcStartupManual;

    case SERVICE_DISABLED :
        return g_strSvcStartupDisabled;

    case -1L:
        return L"";

    default:
        ASSERT(FALSE);
        }
    return g_strUnknown;
    } // Service_PszMapStartupTypeToName()


/////////////////////////////////////////////////////////////////////
//    Service_PszMapStartupAccountToName()
//
//    Map the service startup account to a null-terminated string.
//
//    Note that if they use the localized version of the two special
//    accounts, I just won't pick that up.  JSchwart and I agree that
//    this should be acceptable.
//
//    JonN 188203 11/13/00
//    Services Snapin: Should support NetworkService and LocalService account
//
LPCTSTR
Service_PszMapStartupAccountToName(LPCTSTR pcszStartupAccount)
    {
    if ( !pcszStartupAccount || !*pcszStartupAccount )
        return g_strLocalSystem;
    else if ( !_wcsicmp(pcszStartupAccount,TEXT("NT AUTHORITY\\LocalService")) )
        return g_strLocalService;
    else if ( !_wcsicmp(pcszStartupAccount,TEXT("NT AUTHORITY\\NetworkService")) )
        return g_strNetworkService;
    return pcszStartupAccount;
    } // Service_PszMapStartupAccountToName()


/////////////////////////////////////////////////////////////////////
//    Service_FGetServiceButtonStatus()
//
//    Query the service control manager database and fill in
//    array of flags indicating if the action is enabled.
//        rgfEnableButton[0] = TRUE;   => Button 'start' is enabled
//        rgfEnableButton[0] = FALSE;  => Button 'start' is disabled
//
//    INTERFACE NOTES
//    The length of the array must be length iServiceActionMax (or larger).
//  Each representing start, stop, pause, resume and restart respectively.
//
//    Return TRUE if the service status was queried successfully, otherwise FALSE.
//
BOOL
Service_FGetServiceButtonStatus(
    SC_HANDLE hScManager,            // IN: Handle of service control manager database
    CONST TCHAR * pszServiceName,    // IN: Name of service
    BOOL rgfEnableButton[iServiceActionMax],    // OUT: Array of flags to enable the buttons
    DWORD * pdwCurrentState,        // OUT: Optional: Current state of service
    BOOL fSilentError)                // IN: TRUE => Do not display any error message to user
    {
    Endorse(hScManager == NULL);
    Assert(pszServiceName != NULL);
    Assert(rgfEnableButton != NULL);
    Endorse(pdwCurrentState == NULL);

    // Open service to get its status
    BOOL fSuccess = TRUE;
    SC_HANDLE hService;
    SERVICE_STATUS ss;
    DWORD cbBytesNeeded;
    DWORD dwErr;
        
    ::ZeroMemory(OUT rgfEnableButton, iServiceActionMax * sizeof(BOOL));
    if (pdwCurrentState != NULL)
        *pdwCurrentState = 0;
    if (hScManager == NULL || pszServiceName[0] == '\0')
        return FALSE;

    hService = ::OpenService(
            hScManager,
            pszServiceName,
            SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG);
    if (hService == NULL)
        {
        dwErr = ::GetLastError();
        Assert(dwErr != ERROR_SUCCESS);
        TRACE2("Failed to open service %s. err=%u.\n",
            pszServiceName, dwErr);
        if (!fSilentError)
            DoServicesErrMsgBox(::GetActiveWindow(), MB_OK | MB_ICONEXCLAMATION, dwErr);
        return FALSE;
        }
    if (!::QueryServiceStatus(hService, OUT &ss))
        {
        dwErr = ::GetLastError();
        Assert(dwErr != ERROR_SUCCESS);
        TRACE2("::QueryServiceStatus(Service=%s) failed. err=%u.\n",
            pszServiceName, dwErr);
        if (!fSilentError)
            DoServicesErrMsgBox(::GetActiveWindow(), MB_OK | MB_ICONEXCLAMATION, dwErr);
        fSuccess = FALSE;
        }
    else
        {
        // Determine which menu items should be grayed
        if (pdwCurrentState != NULL)
            *pdwCurrentState = ss.dwCurrentState;

        switch (ss.dwCurrentState)
            {
        default:
            Assert(FALSE && "Illegal service status state.");
        case SERVICE_START_PENDING:
        case SERVICE_STOP_PENDING:
        case SERVICE_PAUSE_PENDING:
        case SERVICE_CONTINUE_PENDING:
            break;
    
        case SERVICE_STOPPED:
            QUERY_SERVICE_CONFIG qsc;
            ZeroMemory( &qsc, sizeof(qsc) );
            qsc.dwStartType = (DWORD)-1;
            // JonN-2002/04/04-544089 handle long DisplayName value
            // If this fails, don't enable the Start button
            //
            // JonN-2002/04/29 fix regression
            // Even if QueryServiceConfig fails, it still fills in the
            // fixed-size area if it can.  So ignore the error in this case.
            (void) ::QueryServiceConfig(
                hService,
                OUT &qsc,
                sizeof(qsc),
                OUT IGNORED &cbBytesNeeded);
            Report(qsc.dwStartType != (DWORD)-1);
            if (qsc.dwStartType != SERVICE_DISABLED)
                {
                rgfEnableButton[iServiceActionStart] = TRUE;    // Enable 'Start' menu item
                }
            break;

        case SERVICE_RUNNING:
            // Some services are not allowed to be stoped and/or paused
            if (ss.dwControlsAccepted & SERVICE_ACCEPT_STOP)
                {
                rgfEnableButton[iServiceActionStop] = TRUE;    // Enable 'Stop' menu item
                }
            if (ss.dwControlsAccepted & SERVICE_ACCEPT_PAUSE_CONTINUE)
                {
                rgfEnableButton[iServiceActionPause] = TRUE;    // Enable 'Pause' menu item
                }
            break;

        case SERVICE_PAUSED:
            if (ss.dwControlsAccepted & SERVICE_ACCEPT_STOP)
                {
                rgfEnableButton[iServiceActionStop] = TRUE;    // Enable 'Stop' menu item
                }
            rgfEnableButton[iServiceActionResume] = TRUE;    // Enable 'Resume' menu item
            break;
            } // switch
        } // if...else

    // A 'Restart' has the same characteristics as a 'Stop'
    rgfEnableButton[iServiceActionRestart] = rgfEnableButton[iServiceActionStop];

    (void)::CloseServiceHandle(hService);
    return fSuccess;
    } // Service_FGetServiceButtonStatus()


/////////////////////////////////////////////////////////////////////
//    Service_SplitCommandLine()
//
//    Split a string into two strings.
//    Very similar to PchParseCommandLine() but uses CString objects.
//
void
Service_SplitCommandLine(
    LPCTSTR pszFullCommand,        // IN: Full command line
    CString * pstrBinaryPath,    // OUT: Path of the executable binary
    CString * pstrParameters,    // OUT: Parameters for the executable
    BOOL * pfAbend)                // OUT: Optional: Search for string "/fail=%1%"
    {
    Assert(pszFullCommand != NULL);
    Assert(pstrBinaryPath != NULL);
    Assert(pstrParameters != NULL);
    Endorse(pfAbend == NULL);

    // Since there is no upper bound on the command
    // arguments, we need to allocate memory for
    // its processing.
    TCHAR * paszCommandT;        // Temporary buffer
    TCHAR * pszCommandArguments;
    INT cchMemAlloc;        // Number of bytes to allocate

    cchMemAlloc = lstrlen(pszFullCommand) + 1;
    paszCommandT = new TCHAR[cchMemAlloc];
    paszCommandT[0] = '\0';        // Just in case
    pszCommandArguments = PchParseCommandLine(
        IN pszFullCommand,
        OUT paszCommandT,
        cchMemAlloc);
    *pstrBinaryPath = paszCommandT;

    if (pfAbend != NULL)
        {
        INT cStringSubstitutions;    // Number of string substitutions
    
        // Find out if the string contains "/fail=%1%"
        // 580255-2002/03/18 JonN fixed Str_SubstituteStrStr buffer overrun
        cStringSubstitutions = Str_RemoveSubStr(
            IN OUT pszCommandArguments,
            IN szAbend );
        Report((cStringSubstitutions == 0 || cStringSubstitutions == 1) &&
            "INFO: Multiple substitutions will be consolidated.");
        *pfAbend = cStringSubstitutions != 0;
        }
    *pstrParameters = pszCommandArguments;
    TrimString(*pstrParameters);

    delete paszCommandT;
    } // Service_SplitCommandLine()


/////////////////////////////////////////////////////////////////////
//    Service_UnSplitCommandLine()
//
//    Just do the opposite of Service_SplitCommandLine().
//    Combine the executable path and its arguments into a single string.
//
void
Service_UnSplitCommandLine(
    CString * pstrFullCommand,    // OUT: Full command line
    LPCTSTR pszBinaryPath,        // IN: Path of the executable binary
    LPCTSTR pszParameters)        // IN: Parameters for the executable
    {
    Assert(pstrFullCommand != NULL);
    Assert(pszBinaryPath != NULL);
    Assert(pszParameters != NULL);

    TCHAR * psz;
    psz = pstrFullCommand->GetBuffer(lstrlen(pszBinaryPath) + lstrlen(pszParameters) + 32);
    // Build a string with the binary path surrounded by quotes
    wsprintf(OUT psz, L"\"%s\" %s", pszBinaryPath, pszParameters);
    pstrFullCommand->ReleaseBuffer();
    } // Service_UnSplitCommandLine()

    
/////////////////////////////////////////////////////////////////////
//    LoadSystemString()
//
//    Load a string from system's resources.  This function will check if
//    the string Id can be located in netmsg.dll before attempting to
//    load the string from the 'system resource'.
//    If string cannot be loaded, *ppaszBuffer is set to NULL.
//
// ISSUE-2002/03/18-JonN The above comment is inaccurate.  If the string
//   cannot be loaded from netmsg.dll, it does not fall back to system.
//
//    RETURN
//    Pointer to allocated string and number of characters put
//    into *ppaszBuffer.
//
//    INTERFACE NOTES
//    Caller must call LocalFree(*ppaszBuffer) when done with the string.
//
//    HISTORY
//    96.10.21    t-danmo        Copied from net\ui\common\src\string\string\strload.cxx.
//
/* JonN-2002/03/18-JonN This function is not used
DWORD
LoadSystemString(
    UINT wIdString,            // IN: String Id.  Typically error code from GetLastError().
    LPTSTR * ppaszBuffer)    // OUT: Address of pointer to allocated string.
    {
    Assert(ppaszBuffer != NULL);

    UINT cch;
    HMODULE hModule = NULL;
    DWORD dwFlags =  FORMAT_MESSAGE_ALLOCATE_BUFFER |
                     FORMAT_MESSAGE_IGNORE_INSERTS  |
                     FORMAT_MESSAGE_MAX_WIDTH_MASK;

    if ((wIdString >= MIN_LANMAN_MESSAGE_ID) && (wIdString <= MAX_LANMAN_MESSAGE_ID))
        {
        // Network Errors
        dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
        hModule = ::LoadLibrary(_T("netmsg.dll"));
        if (hModule == NULL)
            {
            TRACE1("LoadLibrary(\"netmsg.dll\") failed.  err=%u.\n", GetLastError());
            Report("Unable to get module handle for netmsg.dll");
            }
        }
    else
        {
        // Other system errors
        dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
        }

    *ppaszBuffer = NULL;        // Just in case
    cch = ::FormatMessage(
        dwFlags,
        hModule,
        wIdString,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        OUT (LPTSTR)ppaszBuffer,    // Buffer will be allocated by FormatMessage()
        0,
        NULL);
    Report((cch > 0) && "FormatMessage() returned an empty string");
    if (hModule != NULL)
        {
        VERIFY(FreeLibrary(hModule));
        }
    return cch;
    } // LoadSystemString()
*/


/////////////////////////////////////////////////////////////////////
//    GetMsgHelper()
//
//    This function will retrieve the error msg if dwErr is specified,
//    load resource string if specified, and format the string with
//    the error msg and other optional arguments.
//
//
HRESULT
GetMsgHelper(
    OUT CString& strMsg,// OUT: the message
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String ID
    va_list* parglist   // IN: OPTIONAL arguments
    )
{
    if (!dwErr && !wIdString) 
        return E_INVALIDARG;

    TCHAR *pszMsgResourceString = NULL;
    TCHAR *pszT = L"";

    //
    // retrieve error msg
    //
    CString strErrorMessage;
    if (dwErr != 0)
    {
        GetErrorMessage(dwErr, strErrorMessage);
        pszT = (LPTSTR)(LPCTSTR)strErrorMessage;
    }

    //
    // load string resource, and format it with the error msg and 
    // other optional arguments
    //
    if (wIdString == 0)
    {
        strMsg = pszT;
    } else
    {
        pszMsgResourceString = PaszLoadStringPrintf(wIdString, *parglist);
        if (dwErr == 0)
            strMsg = pszMsgResourceString;
        else if ((HRESULT)dwErr < 0)
            LoadStringPrintf(IDS_sus_ERROR_HR, OUT &strMsg, pszMsgResourceString, dwErr, pszT);
        else
            LoadStringPrintf(IDS_sus_ERROR, OUT &strMsg, pszMsgResourceString, dwErr, pszT);
    }

    if (pszMsgResourceString)
        LocalFree(pszMsgResourceString);

    return S_OK;
} // GetMsgHelper()

/////////////////////////////////////////////////////////////////////
//    GetMsg()
//
//    This function will call GetMsgHelp to retrieve the error msg
//    if dwErr is specified, load resource string if specified, and
//    format the string with the error msg and other optional arguments.
//
//
void
GetMsg(
    OUT CString& strMsg,// OUT: the message
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String resource Id
    ...)                // IN: Optional arguments
{
    va_list arglist;
    va_start(arglist, wIdString);

    HRESULT hr = GetMsgHelper(strMsg, dwErr, wIdString, &arglist);
    if (FAILED(hr))
        strMsg.Format(_T("0x%x"), hr);

    va_end(arglist);

} // GetMsg()

/////////////////////////////////////////////////////////////////////
//    DoErrMsgBox()
//
//    Display a message box for the error code.  This function will
//    load the error message from the system resource and append
//    the optional string (if any)
//
//    EXAMPLE
//        DoErrMsgBox(GetActiveWindow(), MB_OK, GetLastError(), IDS_s_FILE_READ_ERROR, L"foo.txt");
//
INT
DoErrMsgBoxHelper(
    HWND hwndParent,    // IN: Parent of the dialog box
    UINT uType,         // IN: style of message box
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String resource Id
	bool fServicesSnapin, // IN: Is this filemgmt or svcmgmt?
    va_list& arglist)   // IN: Optional arguments
{
    //
    // get string and the error msg
    //
    CString strMsg;
    HRESULT hr = GetMsgHelper(strMsg, dwErr, wIdString, &arglist);
    if (FAILED(hr))
        strMsg.Format(_T("0x%x"), hr);

    //
    // Load the caption
    //
    CString strCaption;
    strCaption.LoadString(
        (fServicesSnapin) ? IDS_CAPTION_SERVICES : IDS_CAPTION_FILEMGMT);

    //
    // Display the message.
    //
    CThemeContextActivator activator;;
    return MessageBox(hwndParent, strMsg, strCaption, uType);

} // DoErrMsgBox()

INT
DoErrMsgBox(
    HWND hwndParent,    // IN: Parent of the dialog box
    UINT uType,         // IN: style of message box
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String resource Id
    ...)                // IN: Optional arguments
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    //
    // get string and the error msg
    //
    va_list arglist;
    va_start(arglist, wIdString);

    INT retval = DoErrMsgBoxHelper(
        hwndParent, uType, dwErr, wIdString, false, arglist );

    va_end(arglist);

    return retval;

} // DoErrMsgBox()

//
// JonN 3/5/01 4635
// Services Snapin - String length error dialog title shouldn't be "File Service Management"
//
INT
DoServicesErrMsgBox(
    HWND hwndParent,    // IN: Parent of the dialog box
    UINT uType,         // IN: style of message box
    DWORD dwErr,        // IN: Error code from GetLastError()
    UINT wIdString,     // IN: String resource Id
    ...)                // IN: Optional arguments
{
    //
    // get string and the error msg
    //
    va_list arglist;
    va_start(arglist, wIdString);

    INT retval = DoErrMsgBoxHelper(
        hwndParent, uType, dwErr, wIdString, true, arglist );

    va_end(arglist);

    return retval;

}

//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForUsers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick one user.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//  History:    10-14-1998   DavidMun   Sample code InitObjectPickerForGroups
//              10-14-1998   JonN       Changed to InitObjectPickerForUsers
//              11-11-2000   JonN       188203 support LocalService/NetworkService
//
//---------------------------------------------------------------------------

// CODEWORK do I want to allow USER_ENTERED?
HRESULT
InitObjectPickerForUsers(
    IDsObjectPicker *pDsObjectPicker,
    LPCTSTR pszServerName)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 5;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(aScopeInit));

    //
    // Target computer scope.  This adds a "Look In" entry for the
    // target computer.  Computer scopes are always treated as
    // downlevel (i.e., they use the WinNT provider).
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
    aScopeInit[0].flScope =   DSOP_SCOPE_FLAG_STARTING_SCOPE
                            | DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    // JonN 11/14/00 188203 support LocalService/NetworkService
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS
                                          | DSOP_DOWNLEVEL_FILTER_LOCAL_SERVICE
                                          | DSOP_DOWNLEVEL_FILTER_NETWORK_SERVICE;

    //
    // The domain to which the target computer is joined.  Note we're
    // combining two scope types into flType here for convenience.
    //

    aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[1].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                         | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    aScopeInit[1].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    aScopeInit[1].FilterFlags.Uplevel.flNativeModeOnly =
      DSOP_FILTER_USERS;
    aScopeInit[1].FilterFlags.Uplevel.flMixedModeOnly =
      DSOP_FILTER_USERS;
    aScopeInit[1].FilterFlags.flDownlevel =
      DSOP_DOWNLEVEL_FILTER_USERS;

    //
    // The domains in the same forest (enterprise) as the domain to which
    // the target machine is joined.  Note these can only be DS-aware
    //

    aScopeInit[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[2].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    aScopeInit[2].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    aScopeInit[2].FilterFlags.Uplevel.flNativeModeOnly =
      DSOP_FILTER_USERS;
    aScopeInit[2].FilterFlags.Uplevel.flMixedModeOnly =
      DSOP_FILTER_USERS;

    //
    // Domains external to the enterprise but trusted directly by the
    // domain to which the target machine is joined.
    //
    // If the target machine is joined to an NT4 domain, only the
    // external downlevel domain scope applies, and it will cause
    // all domains trusted by the joined domain to appear.
    //

    aScopeInit[3].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[3].flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                         | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;
    aScopeInit[3].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;

    aScopeInit[3].FilterFlags.Uplevel.flNativeModeOnly =
      DSOP_FILTER_USERS;

    aScopeInit[3].FilterFlags.Uplevel.flMixedModeOnly =
      DSOP_FILTER_USERS;

    aScopeInit[3].FilterFlags.flDownlevel =
      DSOP_DOWNLEVEL_FILTER_USERS;

    //
    // The Global Catalog
    //

    aScopeInit[4].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[4].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    aScopeInit[4].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;

    // Only native mode applies to gc scope.

    aScopeInit[4].FilterFlags.Uplevel.flNativeModeOnly =
      DSOP_FILTER_USERS;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);

    //
    // The pwzTargetComputer member allows the object picker to be
    // retargetted to a different computer.  It will behave as if it
    // were being run ON THAT COMPUTER.
    //

    InitInfo.pwzTargetComputer = pszServerName;  // NULL == local machine
//    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    // JonN 11/14/00 188203 support LocalService/NetworkService
    static PCWSTR g_pszObjectSid = L"objectSid";
    InitInfo.cAttributesToFetch = 1;
    InitInfo.apwzAttributeNames = &g_pszObjectSid;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    HRESULT hr = pDsObjectPicker->Initialize(&InitInfo);
    ASSERT( SUCCEEDED(hr) );

    return hr;
} // InitObjectPickerForUsers

//+--------------------------------------------------------------------------
//
//  Function:   ExtractADsPathAndUPN
//
//  Synopsis:   Retrieve the selected username from the data object
//              created by the object picker.
//
//  Arguments:  [pdo] - data object returned by object picker
//
//  History:    10-14-1998   DavidMun   Sample code ProcessSelectedObjects
//              10-14-1998   JonN       Changed to ExtractADsPath
//              01-25-1999   JonN       Added pflScopeType parameter
//              03-16-1999   JonN       Changed to ExtractADsPathAndUPN
//              11-14-2000   JonN       Added svarrefObjectSid for 188203
//
//---------------------------------------------------------------------------

UINT g_cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

HRESULT
ExtractADsPathAndUPN(
    IN IDataObject *pdo,
    OUT CString& strrefADsPath,
    OUT CString& strrefUPN,
    OUT CComVariant& svarrefObjectSid,
    OUT ULONG *pflScopeType)
{
    if (NULL == pdo)
        return E_POINTER;

    HRESULT hr = S_OK;

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    FORMATETC formatetc =
    {
        (CLIPFORMAT)g_cfDsObjectPicker,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    bool fGotStgMedium = false;

    do
    {
        hr = pdo->GetData(&formatetc, &stgmedium);
        if (FAILED(hr))
        {
          ASSERT(FALSE);
          break;
        }

        fGotStgMedium = true;

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        if (   NULL == pDsSelList
            || 1 != pDsSelList->cItems
           )
        {
          ASSERT(FALSE);
          hr = E_FAIL;
          break;
        }

        DS_SELECTION& sel = pDsSelList->aDsSelection[0];
        strrefADsPath = sel.pwzADsPath;
        strrefUPN     = sel.pwzUPN;
        if ( sel.pvarFetchedAttributes )
            svarrefObjectSid = sel.pvarFetchedAttributes[0];

        if (NULL != pflScopeType)
          *pflScopeType = pDsSelList->aDsSelection[0].flScopeType;

        GlobalUnlock(stgmedium.hGlobal);
    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////
//    UiGetUser()
//
//    Invoke a user picker dialog.
//
//    Return TRUE iff an account was selected.
//    
//    HISTORY
//    96.10.12    t-danmo        Creation. Inspired from function GetUser() located
//                            at \nt\private\windows\shell\security\aclui\misc.cpp.
//    96.10.30    t-danmo        Added/modified comments.
//    98.03.17    jonn        Modified to use User/Group Picker
//    98.10.20    jonn        Modified to use updated Object Picker interfaces
//

//+--------------------------------------------------------------------------
//
//  Function:   ExtractDomainUserString
//
//  Synopsis:   Converts an ADspath to the format needed by Service Controller
//
//  History:    10-14-1998   JonN       Created
//              01-25-1999   JonN       added flScopeType parameter
//
//---------------------------------------------------------------------------

HRESULT
ExtractDomainUserString(
    IN LPCTSTR pwzADsPath,
    IN ULONG flScopeType,
    IN OUT CString& strrefDomainUser)
{
    HRESULT hr = S_OK;

    CComPtr<IADsPathname> spIADsPathname;
    hr = CoCreateInstance(CLSID_Pathname, NULL, CLSCTX_INPROC_SERVER,
                          IID_IADsPathname, (PVOID *)&spIADsPathname);
    RETURN_HR_IF_FAIL;

    hr = spIADsPathname->Set( const_cast<LPTSTR>(pwzADsPath), ADS_SETTYPE_FULL );
    RETURN_HR_IF_FAIL;

    CComBSTR sbstrUser;
    hr = spIADsPathname->GetElement( 0, &sbstrUser );
    RETURN_HR_IF_FAIL;

    CComBSTR sbstrDomain = OLESTR(".");
    if (DSOP_SCOPE_TYPE_TARGET_COMPUTER != flScopeType)
    {
        long lnNumPathElements = 0;
        hr = spIADsPathname->GetNumElements( &lnNumPathElements );
        RETURN_FALSE_IF_FAIL;

        switch (lnNumPathElements)
        {
        case 1:
            hr = spIADsPathname->Retrieve( ADS_FORMAT_SERVER, &sbstrDomain );
            RETURN_HR_IF_FAIL;
            break;
        case 2:
            hr = spIADsPathname->GetElement( 1, &sbstrDomain );
            RETURN_HR_IF_FAIL;
            break;
        default:
            ASSERT(FALSE);
            return E_FAIL;
        }
    }

    strrefDomainUser.Format(L"%s\\%s", sbstrDomain, sbstrUser);

    return hr;
} // ExtractDomainUserString


BOOL
UiGetUser(
    HWND hwndOwner,            // IN: Owner window
    BOOL /*fIsContainer*/,        // IN: TRUE if invoked for a container
    LPCTSTR pszServerName,    // IN: Initial target machine name
    OUT CString& strrefUser) // IN: Allocated buffer containing the user details
{
  HRESULT hr = S_OK;

  CComPtr<IDsObjectPicker> spDsObjectPicker;
  hr = CoCreateInstance(CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER,
                        IID_IDsObjectPicker, (PVOID *)&spDsObjectPicker);
  RETURN_FALSE_IF_FAIL;
  ASSERT( !!spDsObjectPicker );

  hr = InitObjectPickerForUsers(spDsObjectPicker, pszServerName);
  RETURN_FALSE_IF_FAIL;

  CComPtr<IDataObject> spDataObject;
  hr = spDsObjectPicker->InvokeDialog(hwndOwner, &spDataObject);
  RETURN_FALSE_IF_FAIL;
  if (S_FALSE == hr)
    return FALSE; // user cancelled
  ASSERT( !!spDataObject );

  CString strADsPath;
  ULONG flScopeType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
  CComVariant svarObjectSid;
  hr = ExtractADsPathAndUPN( spDataObject,
                             strADsPath,
                             strrefUser,
                             svarObjectSid,
                             &flScopeType );
  RETURN_FALSE_IF_FAIL;

  // JonN 11/15/00 188203 check for LocalService/NetworkService
  if (svarObjectSid.vt == (VT_ARRAY|VT_UI1))
  {
    PSID pSid = svarObjectSid.parray->pvData;
    if ( IsWellKnownSid(pSid, WinLocalServiceSid) )
    {
      strrefUser = TEXT("NT AUTHORITY\\LocalService");
      return TRUE;
    }
    else if ( IsWellKnownSid(pSid, WinNetworkServiceSid) )
    {
      strrefUser = TEXT("NT AUTHORITY\\NetworkService");
      return TRUE;
    }
  }

  if (strrefUser.IsEmpty())
  {
    if (strADsPath.IsEmpty())
    {
      ASSERT(FALSE);
      return FALSE;
    }
    hr = ExtractDomainUserString( strADsPath, flScopeType, strrefUser );
    RETURN_FALSE_IF_FAIL;
  }

  return TRUE;
} // UiGetUser()


/////////////////////////////////////////////////////////////////////
//    DoHelp()
//
//    This routine handles context help for the WM_HELP message.
//
//    The return value is always TRUE.
//
BOOL DoHelp(
    LPARAM lParam,                // Pointer to HELPINFO structure
    const DWORD rgzHelpIDs[])    // Array of HelpIDs
    {
    Assert(rgzHelpIDs != NULL);
    const LPHELPINFO pHelpInfo = (LPHELPINFO)lParam;

    if (pHelpInfo != NULL)
       {
        if (pHelpInfo->iContextType == HELPINFO_WINDOW)
            {
            const HWND hwnd = (HWND)pHelpInfo->hItemHandle;
            Assert(IsWindow(hwnd));
            // Display context help for a control
            WinHelp(
                hwnd,
                g_szHelpFileFilemgmt,
                HELP_WM_HELP,
                (DWORD_PTR)rgzHelpIDs);
            }
        }
    return TRUE;
    } // DoHelp()

/////////////////////////////////////////////////////////////////////
//    DoContextHelp()
//    
//    This routine handles context help for the WM_CONTEXTMENU message.
//
//    The return value is always TRUE.
//
BOOL DoContextHelp(
    WPARAM wParam,                // Window requesting help
    const DWORD rgzHelpIDs[])    // Array of HelpIDs
    {
    const HWND hwnd = (HWND)wParam;
    Assert(IsWindow(hwnd));
    Assert(rgzHelpIDs != NULL);
    WinHelp(hwnd, g_szHelpFileFilemgmt, HELP_CONTEXTMENU, (DWORD_PTR)rgzHelpIDs);
    return TRUE;
    } // DoContextHelp()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\svcprop3.h ===
// svcprop3.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CServicePageRecovery dialog

class CServicePageRecovery : public CPropertyPage
{
	DECLARE_DYNCREATE(CServicePageRecovery)

// Construction
public:
	CServicePageRecovery();
	~CServicePageRecovery();

// Dialog Data
	//{{AFX_DATA(CServicePageRecovery)
	enum { IDD = IDD_PROPPAGE_SERVICE_RECOVERY };
	CString	m_strRunFileCommand;
	CString	m_strRunFileParam;
	BOOL	m_fAppendAbendCount;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CServicePageRecovery)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CServicePageRecovery)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeComboFirstAttempt();
	afx_msg void OnSelchangeComboSecondAttempt();
	afx_msg void OnSelchangeComboSubsequentAttempts();
	afx_msg void OnButtonBrowse();
	afx_msg void OnButtonRebootComputer();
	afx_msg void OnCheckAppendAbendno();
	afx_msg void OnChangeEditRunfileFilename();
	afx_msg void OnChangeEditRunfileParameters();
	afx_msg void OnChangeEditServiceResetAbendCount();
	afx_msg void OnChangeEditServiceRestartDelay();
	afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	afx_msg BOOL OnContextHelp(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
// User defined variables
	CServicePropertyData * m_pData;
// User defined functions
	void UpdateUI();

}; // CServicePageRecovery


/////////////////////////////////////////////////////////////////////////////
// CServicePageRecovery2 dialog
//
// JonN 4/20/01 348163

class CServicePageRecovery2 : public CPropertyPage
{
	DECLARE_DYNCREATE(CServicePageRecovery2)

// Construction
public:
	CServicePageRecovery2();
	~CServicePageRecovery2();

// Dialog Data
	//{{AFX_DATA(CServicePageRecovery2)
	enum { IDD = IDD_PROPPAGE_SERVICE_RECOVERY2 };
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CServicePageRecovery2)
	protected:
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CServicePageRecovery2)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
// User defined variables
	CServicePropertyData * m_pData;
// User defined functions
}; // CServicePageRecovery2


/////////////////////////////////////////////////////////////////////////////
// CServiceDlgRebootComputer dialog

class CServiceDlgRebootComputer : public CDialog
{
// Construction
public:
	CServiceDlgRebootComputer(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CServiceDlgRebootComputer)
	enum { IDD = IDD_SERVICE_REBOOT_COMPUTER };
	UINT	m_uDelayRebootComputer;
	BOOL	m_fRebootMessage;
	CString	m_strRebootMessage;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServiceDlgRebootComputer)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CServiceDlgRebootComputer)
	virtual BOOL OnInitDialog();
	afx_msg void OnCheckboxClicked();
	afx_msg void OnChangeEditRebootMessage();
	afx_msg BOOL OnHelp(WPARAM wParam, LPARAM lParam);
	afx_msg BOOL OnContextHelp(WPARAM wParam, LPARAM lParam);
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
// User defined variables
	CServicePropertyData * m_pData;
public:
// User defined functions
}; // CServiceDlgRebootComputer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\wraps.cpp ===
//
// wraps.cpp - wrapper functions for apis
//

#include "stdafx.h"
#include "cmponent.h"

#define DONT_WANT_SHELLDEBUG
#include "shlobjp.h"     // LPITEMIDLIST

#if _WIN32_IE >= 0x0400

//
// Wrapper unnecessary for WIN64
//

#else

//
// We need this wrapper for ILCreateFromPath since it was a TCHAR exported by ordinal
// on NT4 and now has A/W versions on NT5. Since we want to be able to run on both of
// these platforms we wrap the API here.
//
// This api just loads shell32, and calls ordinal 157 which is the old TCHAR export
//
typedef LPITEMIDLIST (__stdcall *PFNILCREATEFROMPATH)(LPCTSTR pszPath);

STDAPI_(LPITEMIDLIST) Wrap_ILCreateFromPath(LPCWSTR pszPath)
{
    static PFNILCREATEFROMPATH pfn = (PFNILCREATEFROMPATH)-1;

    if (pfn == (PFNILCREATEFROMPATH)-1)
    {
        HINSTANCE hinst = LoadLibrary(TEXT("shell32.dll"));

        if (hinst)
        {
            pfn = (PFNILCREATEFROMPATH) GetProcAddress(hinst, (LPCSTR)157);
        }
        else
        {
            pfn = NULL;
        }
    }

    if (pfn)
    {
        return pfn(pszPath);
    }
    
    // If we failed for some reason, just return NULL
    return NULL;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\utils.cpp ===
/////////////////////////////////////////////////////////////////////
//
//	Utils.cpp
//
//	General-purpose routines that are project independent.
//
//	HISTORY
//	t-danmo		96.09.22	Creation.
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "progress.h" // CServiceControlProgress
#include "macros.h"   // MFC_TRY/MFC_CATCH
USE_HANDLE_MACROS("FILEMGMT(utils.cpp)")


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//
// Fusion MFC-based property page
//
HPROPSHEETPAGE MyCreatePropertySheetPage(AFX_OLDPROPSHEETPAGE* psp)
{
    PROPSHEETPAGE_V3 sp_v3 = {0};
    CopyMemory (&sp_v3, psp, psp->dwSize);
    sp_v3.dwSize = sizeof(sp_v3);

    return (::CreatePropertySheetPage (&sp_v3));
}

/////////////////////////////////////////////////////////////////////
void
ComboBox_FlushContent(HWND hwndCombo)
	{
	Assert(IsWindow(hwndCombo));
	SendMessage(hwndCombo, CB_RESETCONTENT, 0, 0);
	}


/////////////////////////////////////////////////////////////////////
//	ComboBox_FFill()
//
//	Fill a combo box with the array of string Ids.
//
//	Return FALSE if an error occurs (such as stringId not found).
//
BOOL
ComboBox_FFill(
	const HWND hwndCombo,				// IN: Handle of the combobox
	const TStringParamEntry rgzSPE[],	// IN: SPE aray zero terminated
	const LPARAM lItemDataSelect)		// IN: Which item to select
	{	
	CString str;
	TCHAR szBuffer[1024];
	LRESULT lResult;

	Assert(IsWindow(hwndCombo));
	Assert(rgzSPE != NULL);

	for (int i = 0; rgzSPE[i].uStringId != 0; i++)
		{
		if (!::LoadString(g_hInstanceSave, rgzSPE[i].uStringId,
			OUT szBuffer, LENGTH(szBuffer)))
			{
			TRACE1("Unable to load string Id=%d.\n", rgzSPE[i].uStringId);
			Assert(FALSE && "Unable to load string");
			return FALSE;
			}
		lResult = SendMessage(hwndCombo, CB_ADDSTRING, 0,
			reinterpret_cast<LPARAM>(szBuffer));
		Report(lResult >= 0);
		const WPARAM iIndex = lResult;
		lResult = SendMessage(hwndCombo, CB_SETITEMDATA, iIndex,
			rgzSPE[i].lItemData);
		Report(lResult != CB_ERR);
		if (rgzSPE[i].lItemData == lItemDataSelect)
			{
			SendMessage(hwndCombo, CB_SETCURSEL, iIndex, 0);
			}
		} // for
	return TRUE;
	} // ComboBox_FFill()


/////////////////////////////////////////////////////////////////////
//	ComboBox_FGetSelectedItemData()
//
//	Get the value of the lParam field of the current selected item.
//
//	If an error occurs return -1 (CB_ERR).
//	Otherwise the value of the selected item.
//
LPARAM
ComboBox_GetSelectedItemData(HWND hwndComboBox)
	{
	LPARAM l;

	Assert(IsWindow(hwndComboBox));
	l = SendMessage(hwndComboBox, CB_GETCURSEL, 0, 0);
	Report(l != CB_ERR && "Combobox has no item selected");
	l = SendMessage(hwndComboBox, CB_GETITEMDATA, l, 0);
	Assert(l != CB_ERR && "Cannot extract item data from combobox");
	if (l == CB_ERR)
		{
		Assert(CB_ERR == -1);
		return -1;
		}
	return l;
	} // ComboBox_GetSelectedItemData()


/////////////////////////////////////////////////////////////////////
HWND
HGetDlgItem(HWND hdlg, INT nIdDlgItem)
	{
	Assert(IsWindow(hdlg));
	Assert(IsWindow(GetDlgItem(hdlg, nIdDlgItem)));
	return GetDlgItem(hdlg, nIdDlgItem);
	} // HGetDlgItem()


/////////////////////////////////////////////////////////////////////
void
SetDlgItemFocus(HWND hdlg, INT nIdDlgItem)
	{
	Assert(IsWindow(hdlg));
	Assert(IsWindow(GetDlgItem(hdlg, nIdDlgItem)));
	SetFocus(GetDlgItem(hdlg, nIdDlgItem));
	}

/////////////////////////////////////////////////////////////////////
void
EnableDlgItem(HWND hdlg, INT nIdDlgItem, BOOL fEnable)
	{
	Assert(IsWindow(hdlg));
	Assert(IsWindow(GetDlgItem(hdlg, nIdDlgItem)));
	EnableWindow(GetDlgItem(hdlg, nIdDlgItem), fEnable);
	}

/////////////////////////////////////////////////////////////////////
//	Enable/disable one or more controls in a dialog.
void
EnableDlgItemGroup(
	HWND hdlg,				// IN: Parent dialog of the controls
	const UINT rgzidCtl[],	// IN: Group (array) of control Ids to be enabled (or disabled)
	BOOL fEnableAll)		// IN: TRUE => We want to enable the controls; FALSE => We want to disable the controls
	{
	Assert(IsWindow(hdlg));
	Assert(rgzidCtl != NULL);
	for (const UINT * pidCtl = rgzidCtl; *pidCtl != 0; pidCtl++)
		{
		EnableWindow(HGetDlgItem(hdlg, *pidCtl), fEnableAll);
		}
	} // EnableDlgItemGroup()


/////////////////////////////////////////////////////////////////////
//	Show/hide one or more controls in a dialog.
void
ShowDlgItemGroup(
	HWND hdlg,				// IN: Parent dialog of the controls
	const UINT rgzidCtl[],	// IN: Group (array) of control Ids to be shown (or hidden)
	BOOL fShowAll)			// IN: TRUE => We want to show the controls; FALSE => We want to hide the controls
	{
	Assert(IsWindow(hdlg));
	Assert(rgzidCtl != NULL);
	INT nCmdShow = fShowAll ? SW_SHOW : SW_HIDE;
	for (const UINT * pidCtl = rgzidCtl; *pidCtl != 0; pidCtl++)
		{
		ShowWindow(HGetDlgItem(hdlg, *pidCtl), nCmdShow);
		}
	} // ShowDlgItemGroup()


/////////////////////////////////////////////////////////////////////
//	Str_PchCopyChN()
//
//	Copy a string until reaching character chStop or destination buffer full.
//
//	RETURNS
//	Pointer to the last character of source buffer not copied into destination buffer.
//	This may be useful to parse the rest of the source string.
//
//	INTERFACE NOTES
//	Character chStop is not copied into the destination buffer.
//	If cchDstMax==0, the number of characters will not be limited.
//
TCHAR *
Str_PchCopyChN(
	TCHAR * szDst,			// OUT: Destination buffer
	CONST TCHAR * szSrc,	// IN: Source buffer
	TCHAR chStop,			// IN: Character to stop the copying
	INT cchDstMax)			// IN: Length of the output buffer
	{
	Assert(szDst != NULL);
	Assert(szSrc != NULL);
	Assert(cchDstMax >= 0);

	while (*szSrc != '\0' && *szSrc != chStop && --cchDstMax != 0)
		{
		*szDst++ = *szSrc++;
		}
	*szDst = '\0';
	return const_cast<TCHAR *>(szSrc);
	} // Str_PchCopyChN()


/////////////////////////////////////////////////////////////////////
//	Str_RemoveSubStr()
//
//	Scan the source string and remove every occurrence of a
//	sub-string.
//
//	RETURNS
//	Return the number of removals performed.
//
// 580255-2002/03/18 JonN fixed Str_SubstituteStrStr buffer overrun
INT
Str_RemoveSubStr(
	WCHAR * szBuf,				// IN OUT: Source/Destination buffer
	CONST WCHAR * szToken)		// IN: Token to remove
	{
	if (!szBuf || !*szBuf || !szToken || !*szToken)
		return 0;

	INT cSubstitutions = 0;
	size_t cchToken = wcslen(szToken);

	TCHAR* pszFound = NULL;
	while ( NULL != (pszFound = wcsstr(szBuf,szToken)) )
	{
		size_t cchBuf = wcslen(szBuf);
		TCHAR* pszEndToken = pszFound + cchToken;
		size_t cchMove = 1 + (szBuf+cchBuf) - pszEndToken;
		wmemmove(pszFound, pszEndToken, cchMove ); // includes trailing NULL
		cSubstitutions++;
	}

	return cSubstitutions;
	} // Str_SubstituteStrStr()


/////////////////////////////////////////////////////////////////////
//	PchParseCommandLine()
//
//	Split a command line into its path to its executable binary and
//	its command line arguments.  The path to the executable is
//	copied into the output buffer.
//
//	RETURNS
//	Pointer to the next character after path to the executable (Pointer
//  may point to an empty string).  If an error occurs, return NULL.
//
//	FORMATS SUPPORTED
//	1.	"c:\\winnt\\foo.exe /bar"
//	2.	""c:\\winnt\\foo.exe" /bar"
//	The double quotes around the binary path allow
//	the binary path to have spaces.
//

	
// NTRAID#NTBUG9-580255-2002/03/18 JonN PchParseCommandLine buffer overrun
TCHAR *
PchParseCommandLine(
	CONST TCHAR szFullCommand[],	// IN: Full command line
	TCHAR szBinPath[],				// OUT: Path of the executable binary
	INT cchBinPathBuf)				// IN: Size of the buffer
	{
    UNREFERENCED_PARAMETER (cchBinPathBuf);
	CONST TCHAR * pchSrc = szFullCommand;
	TCHAR * pchDst = szBinPath;
	BOOL fQuotesFound = FALSE;		// TRUE => The binary path is surrounded by quotes (")

	Assert(szFullCommand != NULL);
	Assert(szBinPath != NULL);

	// Skip leading spaces
	while (*pchSrc == _T(' '))
		pchSrc++;
	if (*pchSrc == _T('\"'))
		{
		fQuotesFound = TRUE;
		pchSrc++;
		}
	while (TRUE)
		{
		*pchDst = *pchSrc;
		if (*pchSrc == _T('\0'))
			break;
		if (*pchSrc == _T('\"') && fQuotesFound)
			{
			pchSrc++;
			break;
			}
		if (*pchSrc == _T(' ') && !fQuotesFound)
			{
			pchSrc++;
			break;
			}
		pchSrc++;
		pchDst++;
		}
	Assert(pchDst - szBinPath < cchBinPathBuf);
	*pchDst = _T('\0');

	return const_cast<TCHAR *>(pchSrc);	// Return character where arguments starts
	} // PchParseCommandLine()


/////////////////////////////////////////////////////////////////////
void TrimString(CString& rString)
	{
	rString.TrimLeft();
	rString.TrimRight();
	}

/////////////////////////////////////////////////////////////////////
//	PargzpszFromPgrsz()
//
//	Parse a group of strings into an array of pointers to strings.
//	This routine is somewhat similar to CommandLineToArgvW() but
//	uses a group of strings instead of a normal string.
//
//	RETURN
//	Return a pointer to an allocated array of pointers to strings.
//	The array of pointers allocated with the new() operator,
//	therefore the caller must call ONCE delete() to free memory.
//
//	581272 JonN 2002/04/03 With this change, this function returns an
//	  array of pointers to strings, but does not allocate the strings
//	  themselves.  pgrsz must not be deleted before the return value.
//
//	BACKGROUND
//	You need to 'understand' hungarian prefixes to appreciate the
//	name of the function.
//
//	p		Pointer to something
//	psz		Pointer to string terminated.
//	pa		Pointer dynamically allocated.  For instance, pasz is
//			a pointer to an allocated string.  The allocation is
//			to remind the developper he/she have to free the memory
//			when done with the variable.
//	rg		Array (range).  Array (rg) is similar to pointer (p)
//			but may point to more than one element.
//			rgch is an array of characters while pch points to
//			a single character.
//	rgz		Array of which the last element is zero.  The 'last element'
//			may be a character, an integer, a pointer or any other
//			data type found in the array.
//			For instance rgzch would be an array of characters having
//			its last character zero -- a string (sz).
//	gr		Group.  This is different than array because indexing
//			cannot be used.  For instance, a group of strings is
//			not the same as an array of strings.
//			char grsz[] = "DOS\0WfW\0Win95\0WinNT\0";
//			char * rgpsz[] = { "DOS", "WfW", "Win95", "WinNT" };
//			char * rgzpsz[] = { "DOS", "WfW", "Win95", "WinNT", NULL };
//
//	Now it is time to put all the pieces together.
//	pargzpsz = "pa" + "rgz" + "psz"
//	pgrsz = "p" + "gr" + "sz"
//
//	USAGE
//		LPTSTR * pargzpsz;
//		pargzpsz = PargzpszFromPgrsz("DOS\0WfW\0Win95\0WinNT\0", OUT &cStringCount);
//		delete pargzpsz;	// Single delete to free memory
//
//	581272 JonN 2002/04/03 I modified this routine to put minimum trust in
//	  the pgrsz parameter, which originates in the cfgmgr32 APIs.
//
LPTSTR *
PargzpszFromPgrsz(
	CONST LPCTSTR pgrsz,	// IN: Pointer to group of strings
	INT * pcStringCount)	// OUT: OPTIONAL: Count of strings in the  stored into returned value
	{
	if (NULL == pgrsz)
		{
		ASSERT(FALSE);
		return NULL;
		}

	// Compute how much memory is needed for allocation
	int cStringCount = 0;
	CONST TCHAR * pchSrc = pgrsz;
	while (!IsBadStringPtr(pchSrc, (UINT)-1))
		{
		if (*pchSrc == _T('\0'))
			break;
		cStringCount++;
		pchSrc += lstrlen(pchSrc)+1;
		} // while

	// Allocate a single block of memory for all the data
	LPTSTR * pargzpsz = new LPTSTR[cStringCount+1];
	if (NULL == pargzpsz)
		{
		Assert(FALSE);
		return NULL;
		}
	ZeroMemory(pargzpsz, (cStringCount+1)*sizeof(LPTSTR));

	int iString = 0;
	pchSrc = pgrsz;
	while (!IsBadStringPtr(pchSrc, (UINT)-1) && iString < cStringCount)
		{
		pargzpsz[iString++] = (LPTSTR)pchSrc;
		pchSrc += lstrlen(pchSrc)+1;
		} // for
	pargzpsz[cStringCount] = NULL;
	if (pcStringCount != NULL)
		*pcStringCount = cStringCount;
	return pargzpsz;
	} // PargzpszFromPgrsz()


/////////////////////////////////////////////////////////////////////
void
ListView_AddColumnHeaders(
	HWND hwndListview,		// IN: Handle of the listview we want to add columns
	const TColumnHeaderItem rgzColumnHeader[])	// IN: Array of column header items
	{
	RECT rcClient;
	INT cxTotalWidth;		// Total width of the listview control
	LV_COLUMN lvColumn;
	INT cxColumn;	// Width of the individual column
	TCHAR szBuffer[1024];

	Assert(IsWindow(hwndListview));
	Assert(rgzColumnHeader != NULL);

	GetClientRect(hwndListview, OUT &rcClient);
	cxTotalWidth = rcClient.right;
	lvColumn.pszText = szBuffer;

	for (INT i = 0; rgzColumnHeader[i].uStringId != 0; i++)
		{
		if (!::LoadString(g_hInstanceSave, rgzColumnHeader[i].uStringId,
			OUT szBuffer, LENGTH(szBuffer)))
			{
			TRACE1("Unable to load string Id=%d\n", rgzColumnHeader[i].uStringId);
			Assert(FALSE);
			continue;
			}
		lvColumn.mask = LVCF_TEXT;
		cxColumn = rgzColumnHeader[i].nColWidth;
		if (cxColumn > 0)
			{
			Assert(cxColumn <= 100);
			cxColumn = (cxTotalWidth * cxColumn) / 100;
			lvColumn.mask |= LVCF_WIDTH;
			lvColumn.cx = cxColumn;
			}

		INT iColRet = ListView_InsertColumn(hwndListview, i, IN &lvColumn);
		Report(iColRet == i);
		} // for

	} // ListView_AddColumnHeaders()


/////////////////////////////////////////////////////////////////////
int
ListView_InsertItemEx(
    HWND hwndListview,			// IN: Handle of the listview we want to add item
    CONST LV_ITEM * pLvItem)	// IN: Pointer to listview item
	{
	LV_ITEM lvItemT;	// Temporary variable
	TCHAR szT[1024];	// Temporary buffer
	TCHAR * pch;
	INT iItem;	// Index of the item

	Assert(IsWindow(hwndListview));
	Assert(pLvItem != NULL);

	lvItemT = *pLvItem;		// Copy the whole structure
	lvItemT.iSubItem = 0;
	lvItemT.pszText = szT;

	// Copy until the next
	pch = Str_PchCopyChN(OUT szT, pLvItem->pszText, '\t', LENGTH(szT));
	Assert(pch != NULL);

	iItem = ListView_InsertItem(hwndListview, IN &lvItemT);
	Report(iItem >= 0);
	if (*pch == '\0')
		return iItem;
	Assert(*pch == '\t');

	lvItemT.mask = LVIF_TEXT;
	lvItemT.iItem = iItem;
	lvItemT.iSubItem = 1;

	while (*pch != '\0')
		{
		pch = Str_PchCopyChN(OUT szT, pch + 1, '\t', LENGTH(szT));
		BOOL fRet = ListView_SetItem(hwndListview, IN &lvItemT);
		Report(fRet != FALSE);
		lvItemT.iSubItem++;
		break;
		}
	return iItem;
	} // ListView_InsertItemEx()


/////////////////////////////////////////////////////////////////////
//	Display the common dialog to get a filename.
BOOL
UiGetFileName(
	HWND hwnd,
	TCHAR szFileName[],		// OUT: Filename we want to get
	INT cchBufferLength)	// IN: Length of szFileName buffer
	{
    OPENFILENAME ofn;

	Assert(szFileName != NULL);
	Assert(cchBufferLength > 10);		// At least 10 characters

	TCHAR szBufferT[2048];
	::ZeroMemory( szBufferT, sizeof(szBufferT) );
	VERIFY(::LoadString(g_hInstanceSave, IDS_OPENFILE_FILTER, szBufferT, LENGTH(szBufferT)));
	
	::ZeroMemory(OUT &ofn, sizeof(ofn));
	ofn.lStructSize = sizeof(OPENFILENAME);
	ofn.hwndOwner = hwnd;
	ofn.hInstance = g_hInstanceSave;
	ofn.lpstrFilter = szBufferT;
	ofn.nFilterIndex = 1;
	ofn.lpstrFile = szFileName;
	ofn.nMaxFile = cchBufferLength;
	ofn.Flags = OFN_EXPLORER | OFN_HIDEREADONLY;

	return GetOpenFileName(&ofn);
	} // UiGetFileName()


/////////////////////////////////////////////////////////////////////
//	PaszLoadStringPrintf()
//
//	Load a string from the resource, and format it and return
//	pointer allocated string.
//
//	RETURNS
//	Pointer to allocated string.  Must call LocalFree() when
//	done with string.
//
//	INTERFACE NOTES
//	The format of the resource string uses %1 throuth %99 and
//	assumes the arguments are pointers to strings.
//	
//	If you have an argument other than a string, you can append a
//	printf-type within two exclamation marks. 
//	!s!		Insert a string (default)
//	!d!		Insert a decimal integer
//	!u!		Insert an unsigned integer
//	!x!		Insert an hexadecimal integer
//
//	HOW TO AVOID BUGS
//	To avoid bugs using this routine, I strongly suggest to include
//	the format of the string as part of the name of the string Id.
//	If you change the format of the string, you should rename
//	the string Id to reflect the new format.  This will guarantee
//	the correct type and number of arguments are used.
//
//	EXAMPLES
//		IDS_s_PROPERTIES = "%1 Properties"
//		IDS_ss_PROPERTIES = "%1 Properties on %2"
//		IDS_sus_SERVICE_ERROR = "Service %1 encountered error %2!u! while connecting to %3"
//
//	HISTORY
//	96.10.30	t-danmo		Creation
//
TCHAR *
PaszLoadStringPrintf(
	UINT wIdString,			// IN: String Id
	va_list arglist)		// IN: Arguments (if any)
	{
	Assert(wIdString != 0);

	TCHAR szBufferT[2048];
	LPTSTR paszBuffer = NULL;	// Pointer to allocated buffer. Caller must call LocalFree() to free it

	// Load the string from the resource
	VERIFY(::LoadString(g_hInstanceSave, wIdString, szBufferT, LENGTH(szBufferT)));
	
	// Format the string
	::FormatMessage(
		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
		szBufferT,
		0,
		0,
		OUT (LPTSTR)&paszBuffer,		// Buffer will be allocated by FormatMessage()
		0,
		&arglist);
	
#ifdef DEBUG
	if (paszBuffer == NULL)
		{
		DWORD dw = GetLastError();
		Report(FALSE && "FormatMessage() failed.");
		}
#endif
	return paszBuffer;
	} // PaszLoadStringPrintf()


/////////////////////////////////////////////////////////////////////
//	LoadStringPrintf()
//
//	Load a string from the resources, format it and copy the result string
//	into the CString object.
//
//	Can also use LoadStringWithInsertions()
//	AFX_MANAGE_STATE(AfxGetStaticModuleState())
//
//	EXAMPLES
//		LoadStrigPrintf(IDS_s_PROPERTIES, OUT &strCaption, szServiceName);
//		LoadStrigPrintf(IDS_ss_PROPERTIES, OUT &strCaption, szServiceName, szMachineName);
//		LoadStrigPrintf(IDS_sus_SERVICE_ERROR, OUT &strMessage, szServiceName, ::GetLastError(), szMachineName);
//
// ISSUE-2002/03/05-JonN This is a dangerous function
//
void
LoadStringPrintf(
	UINT wIdString,		// IN: String Id
	CString * pString,	// OUT: String to receive the characters
	...)				// IN: Optional arguments
	{
	Assert(wIdString != NULL);
	Assert(pString != NULL);

	va_list arglist;
	va_start(arglist, pString);

	TCHAR * paszBuffer = PaszLoadStringPrintf(wIdString, arglist);
	*pString = paszBuffer;	// Copy the string into the CString object
	LocalFree(paszBuffer);
	}


/////////////////////////////////////////////////////////////////////
//	SetWindowTextPrintf()
//
//	Load a string from the resource, format it and set the window text.
//
//	EXAMPLE
//		SetWindowText(hwndStatic, IDS_s_PROPERTIES, szObjectName);
//
//	HISTORY
//	96.10.30	t-danmo		Creation. Core copied from LoadStringPrintf()
//
void
SetWindowTextPrintf(HWND hwnd, UINT wIdString, ...)
	{
	ASSERT(IsWindow(hwnd));
	ASSERT(wIdString != 0);

	va_list arglist;
	va_start(arglist, wIdString);
	TCHAR * paszBuffer = PaszLoadStringPrintf(wIdString, arglist);
	if (NULL != paszBuffer) // JonN 5/30/00 PREFIX 110941
		SetWindowText(hwnd, paszBuffer);	// Set the text of the window
	LocalFree(paszBuffer);
	} // SetWindowTextPrintf()

#ifdef SNAPIN_PROTOTYPER

const TCHAR rgchHexDigits[]		= _T("00112233445566778899aAbBcCdDeEfF");
const TCHAR szSpcTab[] 			= _T(" \t");
const TCHAR szWhiteSpaces[] 	= _T(" \t\n\r\f\v");
const TCHAR szDecimalDigits[]	= _T("0123456789");

#ifdef UNICODE
	#define strchrT		wcschr
#else
	#define strchrT		strchr
#endif

/////////////////////////////////////////////////////////////////////
//	FParseInteger()
//
//	Parse the source string pchSrc and extract
//	its integer value.
//
//	RETURNS
//	Return TRUE if successful and set uData to integer value
//	of the parsed string.
//	If not successful (ie, illegal digit or overflow), return FALSE,
//	set uData to zero and set nErrCode to error found.
//	Field pi.pchStop is always set to the last valid character
//	parsed.
//
//	INTERFACE NOTES
//	Fields pPI->pchSrc and pPI->nFlags are preserved during
//	the execution of FParseInteger().
//
BOOL
FParseInteger(INOUT TParseIntegerInfo * pPI)
	{
	UINT uDataT;
	UINT uBase;
	UINT iDigit;
	UINT cDigitParsed; // Number of digits parsed
	BOOL fIsNegative = FALSE;
	const TCHAR * pchDigit;

	Assert(pPI != NULL);
	Assert(pPI->pchSrc != NULL);
	pPI->pchStop = pPI->pchSrc;
	pPI->nErrCode = PI_errOK; // No error yet
	pPI->uData = 0;
	uBase = (pPI->nFlags & PI_mskfHexBaseOnly) ? 16 : 10;
	cDigitParsed = 0;

	// Skip leading blanks
	while (*pPI->pchStop ==_T(' '))
		pPI->pchStop++;
	// Check for a minus sign
	if (*pPI->pchStop == _T('-'))
		{
		if (pPI->nFlags & PI_mskfNoMinusSign)
			{
			pPI->nErrCode = PI_errMinusSignFound;
			return FALSE;
			}
		fIsNegative = TRUE;
		pPI->pchStop++;
		}
	//  Skip leading zeroes
	while (*pPI->pchStop == _T('0'))
		{
		pPI->pchStop++;
		cDigitParsed++;
		}
	// Look for the hexadecimal prefix (0x or 0X)
	if (*pPI->pchStop == _T('x') || *pPI->pchStop == _T('X'))
		{
		if ((pPI->nFlags & PI_mskfAllowHexBase) == 0)
			{
			pPI->nErrCode = PI_errInvalidInteger;
			return FALSE;
			}
		pPI->pchStop++;
		cDigitParsed = 0;
		uBase = 16;
		} // if

	while (*pPI->pchStop != _T('\0'))
		{
		pchDigit = wcschr(rgchHexDigits, *pPI->pchStop);
		if (pchDigit == NULL)
			{
			if (pPI->nFlags & PI_mskfAllowRandomTail)
				break;
			// Digit not found while random tail not allowed
			pPI->nErrCode = PI_errInvalidInteger;
			return FALSE;
			} // if
		Assert(pchDigit >= rgchHexDigits);
		iDigit = (pchDigit - rgchHexDigits) >> 1;
		Assert(iDigit <= 0x0F);
		if (iDigit >= uBase)
			{
			// Hex digit found while parsing a decimal string
			pPI->nErrCode = PI_errInvalidInteger;
			return FALSE;
			}
		cDigitParsed++;
		uDataT = pPI->uData * uBase + iDigit;
		if (pPI->uData > ((UINT)-1)/10 || uDataT < pPI->uData)
			{
			pPI->nErrCode = PI_errIntegerOverflow;
			return FALSE;
			}
		pPI->uData = uDataT;
		pPI->pchStop++;
		} // while

	if ((cDigitParsed == 0) && (pPI->nFlags & PI_mskfNoEmptyString))
		{
		// Empty String found while not allowed
		Assert(pPI->uData == 0);
		pPI->nErrCode = PI_errEmptyString;
		return FALSE;
		}
	if (fIsNegative)
		{
		pPI->uData = -(int)pPI->uData;
		}
	if (pPI->nFlags & PI_mskfSingleEntry)
		{
		// Check if there are no more digits at the end of the string
		// Only spaces are allowed
		while (*pPI->pchStop == _T(' '))
			pPI->pchStop++;
		if (*pPI->pchStop != _T('\0'))
			{
			pPI->nErrCode = PI_errInvalidInteger;
			return FALSE;
			}
		}
	return TRUE;
	} // FParseInteger()


/////////////////////////////////////////////////////////////////////
//	FScanf()
//
//	Parse a formatted string and extract the values.
//	FScanf() behaves like the well known scanf() function but
//	has range checking and pattern matching.  The wildcard (*)
//	may be substituded by "%s" with a NULL pointer.
//
//	Return TRUE if successful, otherwise return FALSE
//	and set nErrCode to the error found.
//
//	Formats supported:
//		%d		Extract a decimal integer
//		%i		Extract a generic integer (decimal or hexadecimal)
//		%u		Extract an unsigned decimal integer (return error if minus sign found)
//		%x		Force extraction of an hexadecimal integer
//		%s		Extract a string
//		%v		Void the spaces and tabs characters
//
//	Note:
//	Fields sfi.pchSrc and sfi.nFlags are preserved during
//	the execution of FScanf().
//
//  Example:
//  FScanf(&sfi, "%v%s.%s", " \t foobar.txt",
//      OUT szName, LENGTH(szName), OUT szExt, LENGTH(szExt));
//
BOOL FScanf(
	SCANF_INFO * pSFI,		// INOUT: Control structure
	const TCHAR * pchFmt, 	// IN: Format template string
	...)					// OUT: scanf() arguments
	{
	va_list arglist;
	TParseIntegerInfo pi;

	Assert(pSFI != 0);
	Assert(pchFmt != NULL);
	Assert(pSFI->pchSrc != NULL);

	va_start(INOUT arglist, pchFmt);
	pSFI->pchSrcStop = pSFI->pchSrc;
	pSFI->nErrCode = SF_errOK;
	pSFI->cArgParsed = 0;

	while (TRUE)
		{
		switch (*pchFmt++)
			{
		case 0:	// End of string
			return TRUE;

		case '%':
			switch (*pchFmt++)
				{
			case '%': // "%%"
				if (*pSFI->pchSrcStop++ != '%')
					{
					pSFI->pchSrcStop--;
					pSFI->nErrCode = SF_errTemplateMismatch;
					return FALSE;
					}
				break;

			case 'v':
				while (*pSFI->pchSrcStop == ' ' || *pSFI->pchSrcStop == '\t')
					pSFI->pchSrcStop++;
				break;

			case 'V':
				while ((*pSFI->pchSrcStop != '\0') && 
					(strchrT(szWhiteSpaces, *pSFI->pchSrcStop) != NULL))
					pSFI->pchSrcStop++;
				break;

			case 'd': // "%d" Decimal integer (signed | unsigned)
			case 'u': // "%u" Decimal unsigned integer
			case 'i': // "%i" Generic integer (decimal | hexadecimal / signed | unsigned)
			case 'x': // "%x" Hexadecimal integer
				{
				int * p;

				pi.nFlags = PI_mskfNoEmptyString | PI_mskfAllowRandomTail;
				switch (*(pchFmt-1))
					{
				case 'u':
					pi.nFlags |= PI_mskfNoMinusSign;
					break;
				case 'i':
					pi.nFlags |= PI_mskfAllowHexBase;
					break;
				case 'x':
					pi.nFlags |= PI_mskfHexBaseOnly | PI_mskfNoMinusSign;
					} // switch
				pi.pchSrc = pSFI->pchSrcStop;
				if (!FParseInteger(INOUT &pi))
					{
					pSFI->pchSrcStop = pi.pchStop;
					return FALSE;
					} // if
				pSFI->pchSrcStop = pi.pchStop;
				pSFI->cArgParsed++;
				p = (int *)va_arg(arglist, int *);
				Assert(p != NULL);
				*p = pi.uData;
				}
				break; // Integer

			case 's': // "%s" String
				{
				// To get a clean string, use the format "%v%s%v"
				// which will strip all the spaces and tabs around
				// the string.
				TCHAR * pchDest; 	// Destination buffer
				int cchDestMax;		// Size of destination buffer
				TCHAR chEndScan;
				const TCHAR * pchEndScan = NULL;
	
				// Find out the ending character(s)
				if (*pchFmt == '%')
					{
					switch (*(pchFmt+1))
						{
					case 'd':
					case 'u':
					case 'i':
						pchEndScan = szDecimalDigits;
						chEndScan = '\0';
						break;
					case 'v':	// %v
						pchEndScan = szSpcTab;
						chEndScan = *(pchFmt+2);
						break;
					case 'V':	// %V
						pchEndScan = szWhiteSpaces;
						chEndScan = *(pchFmt+2);
						break;
					case '%':	// %%
						chEndScan = '%';
					default:
						Assert(FALSE);	// Ambiguous compound format (not supported anyway!)
						} // switch
					}
				else
					{
					chEndScan = *pchFmt;
					} // if...else
				
				pSFI->cArgParsed++;
				pchDest = (TCHAR *)va_arg(arglist, TCHAR *);
                if (pchDest != NULL)
                    {
    				cchDestMax = va_arg(arglist, int) - 1;
	    			// Verify if the size of destination buffer
		    		// is a valid size.
			    	// Otherwise, this may be the address of the
				    // next argument
    				Assert(cchDestMax > 0 && cchDestMax < 5000);

	    			while (cchDestMax-- > 0)
		    			{
						if (*pSFI->pchSrcStop == chEndScan)
							break;
						else if (*pSFI->pchSrcStop == '\0')
							break;
						else if (pchEndScan != NULL)
							{
							if (strchrT(pchEndScan, *pSFI->pchSrcStop))
								break;
							} // if...else
						// Copy the character into destination buffer
			    		*pchDest++ = *pSFI->pchSrcStop++;
				    	}
		    		*pchDest = '\0';
                    } // if
				// Skip the characters until reaching either end character
				while (TRUE)
					{
						if (*pSFI->pchSrcStop == chEndScan)
							break;
						else if (*pSFI->pchSrcStop == '\0')
							break;
						else if (pchEndScan != NULL)
							{
							if (strchrT(pchEndScan, *pSFI->pchSrcStop))
								break;
							} // if...else
					pSFI->pchSrcStop++;
					} // while
				}
				break; // "%s"

			default:
				// Unknown "%?" format
				Assert(FALSE);
				pSFI->pchSrcStop--;


				} // switch
			break; // case '%'

		default:
			if (*(pchFmt-1) != *pSFI->pchSrcStop++)
				{
				pSFI->pchSrcStop--;
				pSFI->nErrCode = SF_errTemplateMismatch;
				return FALSE;
				}
			} // switch

		} // while

	return TRUE;
	} // FScanf()


/////////////////////////////////////////////////////////////////////
//	Query the a registry key of type REG_SZ without trowing an exception.
//
BOOL
RegKey_FQueryString(
	HKEY hKey,
	LPCTSTR pszValueName,		// IN: Name of the key
	CString& rstrKeyData)		// OUT: Value (data) of registry key
	{
	Assert(hKey != NULL);
	Assert(pszValueName != NULL);

	TCHAR szBufferT[4096];
	DWORD cbBufferLength = sizeof(szBufferT);
	DWORD dwType;
	DWORD dwErr;

	dwErr = ::RegQueryValueEx(
		hKey,
		pszValueName,
		0,
		OUT &dwType,
		OUT (BYTE *)szBufferT,
		INOUT &cbBufferLength);
	if ((dwErr == ERROR_SUCCESS) && (dwType == REG_SZ))
		{
		rstrKeyData = szBufferT;	// Copy the string
		return TRUE;
		}
	else
		{
		rstrKeyData.Empty();
		return FALSE;
		}
	} // RegKey_FQueryString()

#endif 	// SNAPIN_PROTOTYPER


DWORD DisplayNameHelper(
		HWND hwndParent,
		BSTR pszMachineName,
		BSTR pszServiceName,
		DWORD dwDesiredAccess,
		SC_HANDLE* phSC,
		BSTR* pbstrServiceDisplayName)
{
	*phSC = ::OpenSCManager(
		pszMachineName,
		NULL,
		SC_MANAGER_CONNECT);
	if (NULL == *phSC)
	{
		DWORD dwErr = ::GetLastError();
		ASSERT( NO_ERROR != dwErr );
		return dwErr;
	}

	SC_HANDLE hService = ::OpenService(
		*phSC,
		pszServiceName,
		dwDesiredAccess | SERVICE_QUERY_CONFIG);
	if (NULL == hService)
	{
		DWORD dwErr = ::GetLastError();
		ASSERT( NO_ERROR != dwErr );
		::CloseServiceHandle(*phSC);
		*phSC = NULL;
		return dwErr;
	}

	union
		{
		// Service config
		QUERY_SERVICE_CONFIG qsc;
		BYTE rgbBufferQsc[SERVICE_cbQueryServiceConfigMax];
		};
	::ZeroMemory(&qsc, max(sizeof(qsc), sizeof(rgbBufferQsc)));
	DWORD cbBytesNeeded = 0;
	if (!::QueryServiceConfigW(
			hService,
			OUT &qsc,
			max(sizeof(qsc), sizeof(rgbBufferQsc)),
			OUT &cbBytesNeeded))
	{
		DWORD dwErr = ::GetLastError();
		ASSERT( NO_ERROR != dwErr );
		::CloseServiceHandle(hService);
		::CloseServiceHandle(*phSC);
		*phSC = NULL;
		return dwErr;
	}

	*pbstrServiceDisplayName = ::SysAllocString(
		(qsc.lpDisplayName && qsc.lpDisplayName[0])
			? qsc.lpDisplayName
			: pszServiceName);
	if (NULL == *pbstrServiceDisplayName)
	{
		::CloseServiceHandle(hService);
		::CloseServiceHandle(*phSC);
		*phSC = NULL;
		return E_OUTOFMEMORY;
	}

	::CloseServiceHandle(hService);
	return NO_ERROR;
}

HRESULT CStartStopHelper::StartServiceHelper(
		HWND hwndParent,
		BSTR pszMachineName,
		BSTR pszServiceName,
		DWORD dwNumServiceArgs,
		BSTR * lpServiceArgVectors)
{
	MFC_TRY;

	if (   (   (NULL != pszMachineName)
	        && ::IsBadStringPtr(pszMachineName,0x7FFFFFFF))
		|| ::IsBadStringPtr(pszServiceName,0x7FFFFFFF))
	{
		ASSERT(FALSE);
		return E_POINTER;
	}
	if (0 < dwNumServiceArgs)
	{
		if (::IsBadReadPtr(lpServiceArgVectors,sizeof(lpServiceArgVectors)))
		{
			ASSERT(FALSE);
			return E_POINTER;
		}
		for (DWORD i = 0; i < dwNumServiceArgs; i++)
		{
			if (   (NULL != lpServiceArgVectors[i])
				&& ::IsBadStringPtr(lpServiceArgVectors[i],0x7FFFFFFF))
			{
				ASSERT(FALSE);
				return E_POINTER;
			}
		}
	}

	SC_HANDLE hScManager = NULL;
	CComBSTR sbstrServiceDisplayName;

	DWORD dwErr = DisplayNameHelper(
		hwndParent,
		pszMachineName,
		pszServiceName,
		SERVICE_START,
		&hScManager,
		&sbstrServiceDisplayName);
	if (NO_ERROR != dwErr)
	{
		(void) DoServicesErrMsgBox(
			hwndParent,
			MB_OK | MB_ICONSTOP,
			dwErr,
			IDS_MSG_sss_UNABLE_TO_START_SERVICE,
			pszServiceName,
			(pszMachineName && pszMachineName[0])
				? pszMachineName : (LPCTSTR)g_strLocalMachine,
			L"");
	}
	else
	{
		dwErr = CServiceControlProgress::S_EStartService(
			hwndParent,
			hScManager,
			pszMachineName,
			pszServiceName,
			sbstrServiceDisplayName,
			dwNumServiceArgs,
			(LPCTSTR *)lpServiceArgVectors);
	}

	if (NULL != hScManager)
		(void) ::CloseServiceHandle( hScManager );

	switch (dwErr)
	{
	case CServiceControlProgress::errUserCancelStopDependentServices:
	case CServiceControlProgress::errCannotInitialize:
	case CServiceControlProgress::errUserAbort:
		return S_FALSE;
	default:
		break;
	}
	return HRESULT_FROM_WIN32(dwErr);

	MFC_CATCH;
}

HRESULT CStartStopHelper::ControlServiceHelper(
		HWND hwndParent,
		BSTR pszMachineName,
		BSTR pszServiceName,
		DWORD dwControlCode)
{
	MFC_TRY;

	if (   (   (NULL != pszMachineName)
	        && ::IsBadStringPtr(pszMachineName,0x7FFFFFFF))
		|| ::IsBadStringPtr(pszServiceName,0x7FFFFFFF))
	{
		ASSERT(FALSE);
		return E_POINTER;
	}

	SC_HANDLE hScManager = NULL;
	CComBSTR sbstrServiceDisplayName;
	DWORD dwDesiredAccess = SERVICE_USER_DEFINED_CONTROL;
	UINT idErrorMessageTemplate = IDS_MSG_sss_UNABLE_TO_STOP_SERVICE; // CODEWORK
	switch (dwControlCode)
	{
	case SERVICE_CONTROL_STOP:
		idErrorMessageTemplate = IDS_MSG_sss_UNABLE_TO_STOP_SERVICE;
		dwDesiredAccess = SERVICE_STOP;
		break;
	case SERVICE_CONTROL_PAUSE:
		idErrorMessageTemplate = IDS_MSG_sss_UNABLE_TO_PAUSE_SERVICE;
		dwDesiredAccess = SERVICE_PAUSE_CONTINUE;
		break;
	case SERVICE_CONTROL_CONTINUE:
		idErrorMessageTemplate = IDS_MSG_sss_UNABLE_TO_RESUME_SERVICE;
		dwDesiredAccess = SERVICE_PAUSE_CONTINUE;
		break;
	default:
		break;
	}

	DWORD dwErr = DisplayNameHelper(
		hwndParent,
		pszMachineName,
		pszServiceName,
		dwDesiredAccess,
		&hScManager,
		&sbstrServiceDisplayName);
	if (NO_ERROR != dwErr)
	{
		(void) DoServicesErrMsgBox(
			hwndParent,
			MB_OK | MB_ICONSTOP,
			dwErr,
			idErrorMessageTemplate,
			pszServiceName,
			(pszMachineName && pszMachineName[0])
				? pszMachineName : (LPCTSTR)g_strLocalMachine,
			L"");
	}
	else
	{
		dwErr = CServiceControlProgress::S_EControlService(
			hwndParent,
			hScManager,
			pszMachineName,
			pszServiceName,
			sbstrServiceDisplayName,
			dwControlCode);
	}

	if (NULL != hScManager)
		(void) ::CloseServiceHandle( hScManager );

	switch (dwErr)
	{
	case CServiceControlProgress::errUserCancelStopDependentServices:
	case CServiceControlProgress::errCannotInitialize:
	case CServiceControlProgress::errUserAbort:
		return S_FALSE;
	default:
		break;
	}
	return HRESULT_FROM_WIN32(dwErr);

	MFC_CATCH;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\utils.h ===
/////////////////////////////////////////////////////////////////////
//
//	Utils.h
//
//	General-purpose windows utilities routines.
//
//	HISTORY
//	t-danmo		96.09.22	Creation.
//
/////////////////////////////////////////////////////////////////////

#ifndef __UTILS_H__
#define __UTILS_H__

extern HINSTANCE g_hInstanceSave;  // Instance handle of the DLL (initialized during CFileMgmtComponent::Initialize)

HRESULT 
GetErrorMessage(
  IN  DWORD        i_dwError,
  OUT CString&     cstrErrorMsg
);

void mystrtok(
    IN LPCTSTR  pszString,
    IN OUT int* pnIndex,  // start from 0
    IN LPCTSTR  pszCharSet,
    OUT CString& strToken
    );

BOOL IsInvalidSharename(LPCTSTR psz);

/////////////////////////////////////////////////////////////////////
//	Structure used to add items to a listbox or combobox.
//
struct TStringParamEntry	// spe
	{
	UINT uStringId;		// Id of the resource string
	LPARAM lItemData;	// Optional parameter for the string (stored in lParam field)
	};


void ComboBox_FlushContent(HWND hwndCombo);

BOOL ComboBox_FFill(
	const HWND hwndCombo,				// IN: Handle of the combobox
	const TStringParamEntry rgzSPE[],	// IN: SPE aray zero terminated
	const LPARAM lItemDataSelect);		// IN: Which item to select

LPARAM ComboBox_GetSelectedItemData(HWND hwndComboBox);

HWND HGetDlgItem(HWND hdlg, INT nIdDlgItem);

void SetDlgItemFocus(HWND hdlg, INT nIdDlgItem);

void EnableDlgItem(HWND hdlg, INT nIdDlgItem, BOOL fEnable);

void EnableDlgItemGroup(
	HWND hdlg,
	const UINT rgzidCtl[],
	BOOL fEnable);

void ShowDlgItemGroup(
	HWND hdlg,
	const UINT rgzidCtl[],
	BOOL fShowAll);

TCHAR * Str_PchCopyChN(
	TCHAR * szDst,			// OUT: Destination buffer
	CONST TCHAR * szSrc,	// IN: Source buffer
	TCHAR chStop,			// IN: Character to stop the copying
	INT cchDstMax);			// IN: Length of the output buffer

INT Str_RemoveSubStr(
	WCHAR * szBuf,			// IN OUT: Source/Destination buffer
	CONST WCHAR * szToken);	// IN: Token to remove

TCHAR * PchParseCommandLine(
	CONST TCHAR szFullCommand[],	// IN: Full command line
	TCHAR szBinPath[],				// OUT: Path of the executable binary
	INT cchBinPathBuf);				// IN: Size of the buffer

void TrimString(CString& rString);

/////////////////////////////////////////////////////////////////////
struct TColumnHeaderItem
	{
	UINT uStringId;		// Resource Id of the string
	INT nColWidth;		// % of total width of the column (0 = autowidth, -1 = fill rest of space)
	};

void ListView_AddColumnHeaders(
	HWND hwndListview,
	const TColumnHeaderItem rgzColumnHeader[]);

int ListView_InsertItemEx(
    HWND hwndListview,
    CONST LV_ITEM * pLvItem);

// 581272 JonN 2002/04/03 With this change, this function returns an
//   array of pointers to strings, but does not allocate the strings
//   themselves.  pgrsz must not be deleted before the return value.
LPTSTR * PargzpszFromPgrsz(CONST LPCTSTR pgrsz, INT * pcStringCount);

BOOL UiGetFileName(HWND hwnd, TCHAR szFileName[], INT cchBufferLength);

//
//	Printf-type functions
//
TCHAR * PaszLoadStringPrintf(UINT wIdString, va_list arglist);
void LoadStringPrintf(UINT wIdString, CString * pString, ...);
void SetWindowTextPrintf(HWND hwnd, UINT wIdString, ...);

// If you are looking for MsgBoxPrintf() for slate, go
// take a look at DoErrMsgBox()/DoServicesErrMsgBox() in svcutils.h

// Function LoadStringWithInsertions() is exactly LoadStringPrintf()
#define LoadStringWithInsertions	LoadStringPrintf

#ifdef SNAPIN_PROTOTYPER

///////////////////////////////////////
struct TParseIntegerInfo	// pi
	{
	int nFlags;				// IN: Parsing flags
	const TCHAR * pchSrc;	// IN: Source string
	const TCHAR * pchStop;	// OUT: Pointer to where the parsing stopped
	int nErrCode;			// OUT: Error code
	UINT uData;				// OUT: Integer value
	UINT uRangeBegin;		// IN: Lowest value for range checking
	UINT uRangeEnd;			// IN: Highest value for range checking (inclusive)
	};

#define PI_mskfDecimalBase		0x0000 // Use decimal base (default)
#define PI_mskfHexBaseOnly      0x0001 // Use hexadecimal base only
#define PI_mskfAllowHexBase     0x0002 // Look for a 0x prefix and select the appropriate base
#define PI_mskfAllowRandomTail  0x0010 // Stop parsing as soon as you reach a non-digit character without returning an error
#define PI_mskfNoEmptyString	0x0020 // Interpret an empty string as an error instead of the value zero
#define PI_mskfNoMinusSign		0x0040 // Interpret the minus sign as an error
#define PI_mskfSingleEntry		0x0080 // Return an error if there are more than one integer
#define PI_mskfCheckRange		0x0100 // NYI: Use uRangeBegin and uRangeEnd to validate uData

#define PI_mskfSilentParse		0x8000 // NYI: Used only when calling GetWindowInteger()

#define PI_errOK                0  // No error
#define PI_errIntegerOverflow   1  // Integer too large
#define PI_errInvalidInteger    2  // String is not a valid integer (typically an invalid digit)
#define PI_errEmptyString       3  // Empty string found while not allowed
#define PI_errMinusSignFound	4  // The number was negative

BOOL FParseInteger(INOUT TParseIntegerInfo * pPI);

///////////////////////////////////////
typedef struct _SCANF_INFO	// Scanf info structure (sfi)
	{
	const TCHAR * pchSrc;  		// IN: Source string to be parsed
	const TCHAR * pchSrcStop;	// OUT: Pointer to where the parsing stopped
	int nErrCode;         		// OUT: Error code
	int cArgParsed;       		// OUT: Number of argument parsed
	} SCANF_INFO;

#define SF_errInvalidFormat		(-1)	// Illegal format
#define SF_errOK                 0		// No error parsing
#define SF_errTemplateMismatch   1		// Source string do not match with template string pchFmt

///////////////////////////////////////////////////////////
BOOL FScanf(INOUT SCANF_INFO * pSFI, IN const TCHAR * pchFmt, OUT ...);

BOOL RegKey_FQueryString(
	HKEY hKey,
	LPCTSTR pszValueName,
	CString& rstrKeyData);

#endif // SNAPIN_PROTOTYPER

class CStartStopHelper : public CComObjectRoot,
    public ISvcMgmtStartStopHelper,
	public CComCoClass<CStartStopHelper, &CLSID_SvcMgmt>
{
BEGIN_COM_MAP(CStartStopHelper)
        COM_INTERFACE_ENTRY(ISvcMgmtStartStopHelper)
END_COM_MAP()

public:
//  CStartStopHelper () {}
//  ~CStartStopHelper () {}

DECLARE_AGGREGATABLE(CStartStopHelper)
DECLARE_REGISTRY(CStartStopHelper, _T("SVCMGMT.StartStopObject.1"), _T("SVCMGMT.StartStopObject.1"), IDS_SVCVWR_DESC, THREADFLAGS_BOTH)

    STDMETHOD(StartServiceHelper)(
			HWND hwndParent,
			BSTR pszMachineName,
			BSTR pszServiceName,
			DWORD dwNumServiceArgs,
			BSTR * lpServiceArgVectors );

    STDMETHOD(ControlServiceHelper)(
			HWND hwndParent,
			BSTR pszMachineName,
			BSTR pszServiceName,
			DWORD dwControlCode );
};

DEFINE_GUID(IID_ISvcMgmtStartStopHelper,0xF62DEC25,0xE3CB,0x4D45,0x9E,0x98,0x93,0x3D,0xB9,0x5B,0xCA,0xEA);


#endif // ~__UTILS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\filemgmt\wraps.h ===
// wraps.h: prototypes for wrapped headers

#ifndef __WRAPS_H_INCLUDED__
#define __WRAPS_H_INCLUDED__

#if !defined(_WIN64)
STDAPI_(LPITEMIDLIST) Wrap_ILCreateFromPath(LPCTSTR pszPath);
#endif


#endif // ~__WRAPS_H_INCLUDED__

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\islocal.cpp ===
/////////////////////////////////////////////////////////////////////
//	IsLocal.cpp
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//
//	Determines whether a computername is the local computer
//
//
//	HISTORY
//	09-Jan-1999		jonn  		Creation.
//
/////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "dns.h"
#include <winsock.h>
#include "stdutils.h"

#if _WIN32_WINNT < 0x0500
//
// CODEWORK This was taken from winbase.h.  MFC requires _WIN32_WINNT=0x4000 whereas
// winbase.h only includes this for _WIN32_WINNT=0x5000.  JonN 1/14/99
//
extern "C" {
typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT ;
WINBASEAPI
BOOL
WINAPI
GetComputerNameExA (
    IN COMPUTER_NAME_FORMAT NameType,
    OUT LPSTR lpBuffer,
    IN OUT LPDWORD nSize
    );
WINBASEAPI
BOOL
WINAPI
GetComputerNameExW (
    IN COMPUTER_NAME_FORMAT NameType,
    OUT LPWSTR lpBuffer,
    IN OUT LPDWORD nSize
    );
#ifdef UNICODE
#define GetComputerNameEx  GetComputerNameExW
#else
#define GetComputerNameEx  GetComputerNameExA
#endif // !UNICODE
} // extern "C"

#endif


// ISSUE-2002/03/28-JonN never freed
LPTSTR g_ptzComputerName = NULL;
LPTSTR g_ptzDnsComputerName = NULL;

/////////////////////////////////////////////////////////////////////
//	IsLocalComputername()
//
BOOL
IsLocalComputername( IN LPCTSTR pszMachineName )
{
	if ( NULL == pszMachineName || L'\0' == pszMachineName[0] )
		return TRUE;

	if ( L'\\' == pszMachineName[0] && L'\\' == pszMachineName[1] )
		pszMachineName += 2;

	// compare with the local computer name
	if ( NULL == g_ptzComputerName )
	{
		TCHAR achComputerName[ MAX_COMPUTERNAME_LENGTH+1 ];
		DWORD dwSize = sizeof(achComputerName)/sizeof(TCHAR);
		if ( !GetComputerName( achComputerName, &dwSize ) )
		{
			ASSERT(FALSE);
		}
		else
		{
			g_ptzComputerName = SysAllocString( achComputerName );
			ASSERT( NULL != g_ptzComputerName );
		}
	}
	if ( NULL != g_ptzComputerName && 0 == _tcsicmp( pszMachineName, g_ptzComputerName ) )
	{
		return TRUE;
	}

	// compare with the local DNS name
	// SKwan confirms that ComputerNameDnsFullyQualified is the right name to use
	// when clustering is taken into account
	if ( NULL == g_ptzDnsComputerName )
	{
		TCHAR achDnsComputerName[DNS_MAX_NAME_BUFFER_LENGTH];
		DWORD dwSize = sizeof(achDnsComputerName)/sizeof(TCHAR);
		if ( !GetComputerNameEx(
			ComputerNameDnsFullyQualified,
			achDnsComputerName,
			&dwSize ) )
		{
			ASSERT(FALSE);
		}
		else
		{
			g_ptzDnsComputerName = SysAllocString( achDnsComputerName );
			ASSERT( NULL != g_ptzDnsComputerName );
		}
	}
	if ( NULL != g_ptzDnsComputerName && 0 == _tcsicmp( pszMachineName, g_ptzDnsComputerName ) )
	{
		return TRUE;
	}

  /*
	// compare with alternate DNS names
	do {
		hostent* phostent = gethostbyname( NULL );
		if (NULL == phostent)
			break;
		USES_CONVERSION;
		char** ppaliases = phostent->h_aliases;
		for ( ; *ppaliases != NULL; ppaliases++ )
		{
			TCHAR* ptsz = A2OLE(*ppaliases);
			if (0 == _tcsicmp( pszMachineName, ptsz ))
			{
				return TRUE;
			}
		}
		// these are IP addresses, not strings
		// char** ppaddresses = phostent->h_addr_list;
		// for ( ; *ppaddresses != NULL; ppaliases++ )
		// {
		// 	TCHAR* ptsz = A2OLE(*ppaddresses);
		// 	if (0 == _tcsicmp( pszMachineName, ptsz ))
		// 	{
		// 		return TRUE;
		// 	}
		// }
	} while (false); // false loop
	*/

	return FALSE;

} // IsLocalComputername()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_)
#define AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT

#include <afxwin.h>
#include <afxdisp.h>
#include <afxtempl.h> // CTypedPtrList
#include <afxdlgs.h>  // CPropertyPage

// #define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

// #include "dbg.h"
#include "mmc.h"

EXTERN_C const CLSID CLSID_MyComputer;

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3BFC9651_7A55_11D0_B928_00C04FD8D5B0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\inc\persist.h ===
// persist.h : Declaration of PersistStorage and PersistStream

#ifndef __PERSIST_H_INCLUDED__
#define __PERSIST_H_INCLUDED__

class PersistStorage : public IPersistStorage
{
public:
	STDMETHOD(GetClassID)(CLSID __RPC_FAR * pClassID)
	{
        UNREFERENCED_PARAMETER (pClassID);
		return E_NOTIMPL;
	}

    STDMETHOD(IsDirty)()
	{
		return (m_fDirty) ? S_OK : S_FALSE;
	}

    STDMETHOD(InitNew)(IStorage __RPC_FAR * pStg)
	{
        UNREFERENCED_PARAMETER (pStg);
		return S_OK;
	}

    STDMETHOD(Load)(IStorage __RPC_FAR * pStg)
	{
        UNREFERENCED_PARAMETER (pStg);
		return S_OK;
	}

    STDMETHOD(Save)(IStorage __RPC_FAR * pStgSave, BOOL fSameAsLoad)
	{
        UNREFERENCED_PARAMETER (pStgSave);
        UNREFERENCED_PARAMETER (fSameAsLoad);
		return S_OK;
	}

    STDMETHOD(SaveCompleted)(IStorage __RPC_FAR * pStgNew)
	{
        UNREFERENCED_PARAMETER (pStgNew);
		return S_OK;
	}

    STDMETHOD(HandsOffStorage)()
	{
		return S_OK;
	}

	void SetDirty( BOOL fDirty = TRUE ) { m_fDirty = fDirty; }

	BOOL m_fDirty;

	PersistStorage::PersistStorage() : m_fDirty( FALSE ) {}

}; // class PersistStorage

class PersistStream : public IPersistStream
{
public:
	STDMETHOD(GetClassID)(CLSID __RPC_FAR * pClassID)
	{
        UNREFERENCED_PARAMETER (pClassID);
		return E_NOTIMPL;
	}

    STDMETHOD(IsDirty)()
	{
		return (m_fDirty) ? S_OK : S_FALSE;
	}

    STDMETHOD(Load)(IStorage __RPC_FAR * pStg)
	{
	    UNREFERENCED_PARAMETER (pStg);	
        return S_OK;
	}

    STDMETHOD(Save)(IStorage __RPC_FAR * pStgSave, BOOL fSameAsLoad)
	{
        UNREFERENCED_PARAMETER (pStgSave);
        UNREFERENCED_PARAMETER (fSameAsLoad);
		return S_OK;
	}

    STDMETHOD(GetSizeMax)(ULARGE_INTEGER __RPC_FAR *pcbSize)
	{
		ASSERT(pcbSize);
		if (!pcbSize)
			return E_INVALIDARG;
		::memset(pcbSize, 0, sizeof(*pcbSize));
		return S_OK;
	}

	void SetDirty( BOOL fDirty = TRUE ) { m_fDirty = fDirty; }

	BOOL m_fDirty;

	PersistStream::PersistStream() : m_fDirty( FALSE ) {}

}; // class PersistStream

#endif // ~__PERSIST_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\inc\dynamlnk.h ===
// DynamLnk.h : Base class for DLLs which are loaded only when needed

#ifndef __DYNAMLNK_H_INCLUDED__
#define __DYNAMLNK_H_INCLUDED__

class DynamicDLL
{
public:
	// These strings must remain unchanged until the FileServiceProvider is released
	DynamicDLL(LPCTSTR ptchLibraryName, LPCSTR* apchFunctionNames);
	virtual ~DynamicDLL();

	BOOL LoadFunctionPointers();

	FARPROC QueryFunctionPtr(INT i) const;
	inline FARPROC operator[] (INT i) const
		{ return QueryFunctionPtr(i); }

private:
	HMODULE m_hLibrary;
	FARPROC* m_apfFunctions;
	LPCTSTR m_ptchLibraryName;
	LPCSTR* m_apchFunctionNames;
	INT m_nNumFunctions;
};
#endif // ~__DYNAMLNK_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\dynamlnk.cpp ===
// DynamLnk.cpp : base class for DLLs which are loaded only when needed

#include "stdafx.h"
#include "DynamLnk.h"

DynamicDLL::DynamicDLL(LPCTSTR ptchLibraryName, LPCSTR* apchFunctionNames)
: m_hLibrary( (HMODULE)-1 ),
  m_apfFunctions( NULL ),
  m_ptchLibraryName( ptchLibraryName ),
  m_apchFunctionNames( apchFunctionNames ),
  m_nNumFunctions( 0 )
{
	ASSERT( !IsBadStringPtr(m_ptchLibraryName,MAX_PATH) );
	ASSERT( NULL != apchFunctionNames );
	for (LPCSTR pchFunctionName = *apchFunctionNames;
	     NULL != pchFunctionName;
		 pchFunctionName = *(++apchFunctionNames) )
	{
		m_nNumFunctions++;
		ASSERT( !IsBadStringPtrA(pchFunctionName,MAX_PATH) );
	}
}

DynamicDLL::~DynamicDLL()
{
	if (NULL != m_apfFunctions)
	{
		delete m_apfFunctions;
		m_apfFunctions = NULL;
	}
	if ((HMODULE)-1 != m_hLibrary && NULL != m_hLibrary)
	{
		VERIFY( ::FreeLibrary( m_hLibrary ) );
		m_hLibrary = NULL;
	}
}

BOOL DynamicDLL::LoadFunctionPointers()
{
	if ((HMODULE)-1 != m_hLibrary)
		return (NULL != m_hLibrary);

	m_hLibrary = ::LoadLibrary( m_ptchLibraryName );
	if (NULL == m_hLibrary)
	{
		// The library is not present
		return FALSE;
	}

	// let this throw an exception
	m_apfFunctions = new FARPROC[m_nNumFunctions];

	for (INT i = 0; i < m_nNumFunctions; i++)
	{
		m_apfFunctions[i] = ::GetProcAddress( m_hLibrary, m_apchFunctionNames[i] );
		if ( NULL == m_apfFunctions[i] )
		{
			// The library is present but does not have all of the entrypoints
			VERIFY( ::FreeLibrary( m_hLibrary ) );
			m_hLibrary = NULL;
			return FALSE;
		}
	}

	return TRUE;
}


FARPROC DynamicDLL::QueryFunctionPtr(INT i) const
{
	if ( 0 > i || m_nNumFunctions <= i || NULL == m_apfFunctions || NULL == m_apfFunctions[i] )
	{
		ASSERT( FALSE );
		return NULL;
	}
	return m_apfFunctions[i];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\stdutils.cpp ===
/////////////////////////////////////////////////////////////////////
//
//	StdUtils.cpp
//
//	Utilities routines for any snapin.
//
//	HISTORY
//	t-danmo		96.10.10	Creation.
//
/////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "stdutils.h"


/////////////////////////////////////////////////////////////////////
//	CompareMachineNames()
//
//	Compare if the strings refer to the same machine (computer).
//
//	Return 0 if both strings map to the same machine, otherwise
//	return -1 or +1 if machine name differs.
//
//	INTERFACE NOTES:
//	An empty string means the local machine.
//
//	HISTORY
//	02-Jun-97	t-danm		Creation.
//	14-Jul-97	t-danm		Comment update.
//	29-Jul-97	t-danm		Renamed from FCompareMachineNames().
//
int
CompareMachineNames(
	LPCTSTR pszMachineName1,
	LPCTSTR pszMachineName2)
	{
	TCHAR szThisMachineName[MAX_COMPUTERNAME_LENGTH + 4];
	ZeroMemory( szThisMachineName, sizeof(szThisMachineName) ); // JonN 3/28/02

	BOOL fMachine1IsLocal = (pszMachineName1 == NULL || *pszMachineName1 == '\0');
	BOOL fMachine2IsLocal = (pszMachineName2 == NULL || *pszMachineName2 == '\0');
	if (fMachine1IsLocal)
		pszMachineName1 = szThisMachineName;
	if (fMachine2IsLocal)
		pszMachineName2 = szThisMachineName;
	if (pszMachineName1 == pszMachineName2)
		return 0;
	if (fMachine1IsLocal || fMachine2IsLocal)
		{
		// Get the computer name
		szThisMachineName[0] = _T('\\');
		szThisMachineName[1] = _T('\\');
		DWORD cchBuffer = MAX_COMPUTERNAME_LENGTH + 1;
		VERIFY(::GetComputerName(OUT &szThisMachineName[2], &cchBuffer));
		ASSERT(szThisMachineName[2] != _T('\\') && "Machine name has too many backslashes");
		}
	return lstrcmpi(pszMachineName1, pszMachineName2);
	} // CompareMachineNames()


/////////////////////////////////////////////////////////////////////
//	HrLoadOleString()
//
//	Load a string from the resource and return pointer to allocated
//	OLE string.
//
//	HISTORY
//	29-Jul-97	t-danm		Creation.
//
HRESULT
HrLoadOleString(
	UINT uStringId,					// IN: String Id to load from the resource
	OUT LPOLESTR * ppaszOleString)	// OUT: Pointer to pointer to allocated OLE string
	{
	if (ppaszOleString == NULL)
		{
		TRACE0("HrLoadOleString() - ppaszOleString is NULL.\n");
		return E_POINTER;
		}
	CString strT;		// Temporary string
	// ISSUE-2002/03/28-JonN should call HrCopyToOleString
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Needed for LoadString()
	VERIFY( strT.LoadString(uStringId) );
	*ppaszOleString = reinterpret_cast<LPOLESTR>
	        (CoTaskMemAlloc((strT.GetLength() + 1)* sizeof(wchar_t)));
	if (*ppaszOleString == NULL)
		return E_OUTOFMEMORY;
	// ISSUE-2002/03/28-JonN I don't entirely trust this USES_CONVERSION stuff
	USES_CONVERSION;
	wcscpy(OUT *ppaszOleString, T2OLE((LPTSTR)(LPCTSTR)strT));
	return S_OK;
	} // HrLoadOleString()

/////////////////////////////////////////////////////////////////////
//	HrCopyToOleString()
//
//	Copies a CString into an allocated
//	OLE string.
//
//	HISTORY
//	05-Jun-2001	jeffjon		Creation.
//
HRESULT
HrCopyToOleString(
	const CString& strT,					// IN: String Id to load from the resource
	OUT LPOLESTR * ppaszOleString)	// OUT: Pointer to pointer to allocated OLE string
{
	if (ppaszOleString == NULL)
	{
		TRACE0("HrLoadOleString() - ppaszOleString is NULL.\n");
		return E_POINTER;
	}
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Needed for LoadString()
	*ppaszOleString = reinterpret_cast<LPOLESTR>
	        (CoTaskMemAlloc((strT.GetLength() + 1)* sizeof(wchar_t)));
	if (*ppaszOleString == NULL)
	{
		return E_OUTOFMEMORY;
	}

	USES_CONVERSION;
	wcscpy(OUT *ppaszOleString, T2OLE((LPTSTR)(LPCTSTR)strT));
	return S_OK;
} // HrCopyToOleString()

//
// Nodetype utility routines
// aNodetypeGuids must be defined by the subclass
//

int CheckObjectTypeGUID( const BSTR lpszObjectTypeGUID )
{
	ASSERT(NULL != lpszObjectTypeGUID);
	if (NULL == lpszObjectTypeGUID) // JonN 2002/03/28
		return 0;
	for (	int objecttype = 0;
			objecttype < g_cNumNodetypeGuids;
			objecttype += 1 )
	{
		if ( !::lstrcmpiW(lpszObjectTypeGUID,g_aNodetypeGuids[objecttype].bstr) )
			return objecttype;
	}
	ASSERT( FALSE );
	return 0;
}

int CheckObjectTypeGUID( const GUID* pguid )
{
	ASSERT(NULL != pguid);
	if (NULL == pguid) // JonN 2002/03/28
		return 0;
	for (	int objecttype = 0;
			objecttype < g_cNumNodetypeGuids;
			objecttype += 1 )
	{
		if ( g_aNodetypeGuids[objecttype].guid == *pguid )
			return objecttype;
	}
	ASSERT( FALSE );
	return 0;
}

/////////////////////////////////////////////////////////////////////
//	FilemgmtCheckObjectTypeGUID()
//
//	Compare the GUID and return the objecttype associated with
//	the guid.
//	If no match found, return -1.
//
//	HISTORY
//	14-Jul-97	t-danm		Creation.  Inspired from CheckObjectTypeGUID()
//							but does not assert if the GUID is not found.
//
int FilemgmtCheckObjectTypeGUID(const GUID* pguid )
{
	ASSERT(NULL != pguid);
	if (NULL == pguid) // JonN 2002/03/28
		return -1;
	for (	int objecttype = 0;
			objecttype < g_cNumNodetypeGuids;
			objecttype += 1 )
	{
		if ( g_aNodetypeGuids[objecttype].guid == *pguid )
			return objecttype;
	}
	return -1;
} // FilemgmtCheckObjectTypeGUID()


const BSTR GetObjectTypeString( int objecttype )
{
	if (objecttype < 0 || objecttype >= g_cNumNodetypeGuids)
	{
		ASSERT( FALSE );
		objecttype = 0;
	}
	return g_aNodetypeGuids[objecttype].bstr;
}

const GUID* GetObjectTypeGUID( int objecttype )
{
	if (objecttype < 0 || objecttype >= g_cNumNodetypeGuids)
	{
		ASSERT( FALSE );
		objecttype = 0;
	}
	return &(g_aNodetypeGuids[objecttype].guid);
}

//+--------------------------------------------------------------------------- 
//                                                                             
//  Function:   SynchronousCreateProcess                             
//                                                                             
//  Synopsis:   Invoke a separate UI process as a modal window.                                                    
//                                                                             
//---------------------------------------------------------------------------- 
HRESULT SynchronousCreateProcess(
    HWND    hWnd,
    LPCTSTR pszAppName,
    LPCTSTR pszCommandLine,
    LPDWORD lpdwExitCode
)
{
  HRESULT hr = S_OK;
  BOOL bReturn = FALSE;
  STARTUPINFO si;
  PROCESS_INFORMATION pi;

  //
  // disable the MMC main frame window to prevent it from
  // being shut down. The process we're going to create must
  // display a UI, such that, it behaves like a modal window.
  //
  ::EnableWindow(hWnd, FALSE);

  *lpdwExitCode = 0;

  ZeroMemory(&si, sizeof(STARTUPINFO));
  si.cb = sizeof(STARTUPINFO);
  
  bReturn = CreateProcess(
                pszAppName, //LPCTSTR lpApplicationName
                const_cast<LPTSTR>(pszCommandLine), //LPTSTR lpCommandLine
                NULL, //LPSECURITY_ATTRIBUTES lpProcessAttributes
                NULL, //LPSECURITY_ATTRIBUTES lpThreadAttributes
                FALSE, //BOOL bInheritHandles
                NORMAL_PRIORITY_CLASS, //DWORD dwCreationFlags
                NULL, //LPVOID lpEnvironment
                NULL, //lpCurrentDirectory
                &si, //LPSTARTUPINFO lpStartupInfo
                &pi //LPPROCESS_INFORMATION lpProcessInformation 
                );

  if (!bReturn)
  {
    hr = HRESULT_FROM_WIN32(GetLastError());
  } else
  {
    //
    // while process is still running, pump message to MMC main window,
    // such that it will repaint itself
    //
    while (TRUE)
    {
      MSG tempMSG;
      DWORD dwWait;

      while(::PeekMessage(&tempMSG,NULL, 0, 0, PM_REMOVE))
        DispatchMessage(&tempMSG);

      dwWait = MsgWaitForMultipleObjects(1, &(pi.hProcess), FALSE, INFINITE, QS_ALLINPUT);
      if ( 0 == (dwWait - WAIT_OBJECT_0))
        break;  // process is done
    };

    bReturn = GetExitCodeProcess(pi.hProcess, lpdwExitCode);
    if (!bReturn)
      hr = HRESULT_FROM_WIN32(GetLastError());

    CloseHandle(pi.hThread);
    CloseHandle(pi.hProcess);
  }

  //
  // enable MMC main frame window before return
  //
  ::EnableWindow(hWnd, TRUE);

  return hr;
}

/*

This code is not working yet.  The problem is that it hangs the
message loop, preventing redraw.  One possible approach is to disable the
top-level window and spin off a thread which waits for the process to stop,
then the thread reenables the top-level window and calls UpdateAllViews.

DWORD WINAPI ProcessMonitor(LPVOID pv)
{
}

class CSyncThread : public CThread
{
};

HRESULT SynchronousCreateProcess(LPCTSTR cpszCommandLine,
								 SynchronousProcessCompletionRoutine pfunc,
								 PVOID pvFuncParams)
// does not handle completion routine
{
	PROCESS_INFORMATION piProcInfo;
	(void) ::memset(&piProcInfo,0,sizeof(piProcInfo));
	STARTUPINFO si;
	(void) ::memset(&si,0,sizeof(si));
	::GetStartupInfo( &si );

	//
	// MarkL 1/30/97: Is pszCommandLine a static string?
	// It can not be read only. It is modified temporarily by the call
	// if you do not specify lpszImageName. There is no query to see
	// if a process is running. You can test to see if it has exited
	// using waitforsingleobject to see if the process object is signaled.
	//
	// MarkL also confirms that the handle should absolutely always
	// be signalled when the process dies.
	//
	LPTSTR pszCommandLine = (LPTSTR)
		::alloca(sizeof(TCHAR)*(::_tcslen(cpszCommandLine)+1));
	::_tcscpy(pszCommandLine,cpszCommandLine);
	if ( !::CreateProcess(
		NULL,			// LPCTSTR lpszImageName
		pszCommandLine,	// LPTSTR lpszCommandLine
		NULL,			// LPSECURITY_ATTRIBUTES lpsaProcess
		NULL,			// LPSECURITY_ATTRIBUTES lpsaThread
		FALSE,			// BOOL fInheritHandles
		0L,				// DWORD fdwCreate
		NULL,			// LPVOID lpvEnvironment
		NULL,			// LPTSTR lpszCurDir
		&si,			// LPSTARTUPINFO lpsiStartInfo
		&piProcInfo		// LPPROCESS_INFORMATION lppiProcInfo
		) )
	{
		DWORD dwErr = ::GetLastError();
		ASSERT( ERROR_SUCCESS != dwErr );
		return HRESULT_FROM_WIN32(dwErr);
	}
	ASSERT( NULL != piProcInfo.hProcess );

	VERIFY( WAIT_OBJECT_0 ==
		::WaitForSingleObject( piProcInfo.hProcess, INFINITE ) );

	VERIFY( ::CloseHandle( piProcInfo.hProcess ) );
	VERIFY( ::CloseHandle( piProcInfo.hThread  ) );
	return S_OK;
}
*/

// ISSUE-2002/03/28-JonN duplicates HrCopyToOleString
LPOLESTR CoTaskAllocString( LPCOLESTR psz )
{
	if (NULL == psz)
		return NULL;
	LPOLESTR pszReturn = (LPOLESTR)CoTaskMemAlloc( (lstrlen(psz)+1)*sizeof(OLECHAR) );
	if (NULL != pszReturn)
		lstrcpy( pszReturn, psz );
	ASSERT( NULL != pszReturn );
	return pszReturn;
}

// ISSUE-2002/03/28-JonN duplicates HrLoadOleString
LPOLESTR CoTaskLoadString( UINT nResourceID )
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	// load the resource
	CString strText;
	strText.LoadString( nResourceID );
	ASSERT( !strText.IsEmpty() );
	return CoTaskAllocString( const_cast<BSTR>((LPCTSTR)strText) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\snapreg.cpp ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       SnpInReg.cpp
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11/10/1998 JonN    Created
//
//____________________________________________________________________________


#include "stdafx.h"
#pragma hdrstop
#include "..\corecopy\regkey.h"
#include "snapreg.h"
#include "stdutils.h" // g_aNodetypeGUIDs


HRESULT RegisterNodetypes(
	AMC::CRegKey& regkeyParent,
	int* aiNodetypeIndexes,
	int  cNodetypeIndexes )
{
	try
	{
		AMC::CRegKey regkeyNodeTypes;
		regkeyNodeTypes.CreateKeyEx( regkeyParent, _T("NodeTypes") );
		AMC::CRegKey regkeyNodeType;
		for (int i = 0; i < cNodetypeIndexes; i++)
		{
			regkeyNodeType.CreateKeyEx(
				regkeyNodeTypes,
				g_aNodetypeGuids[aiNodetypeIndexes[i]].bstr );
			regkeyNodeType.CloseKey();
		}
	}
	catch (COleException* e)
	{
		ASSERT(FALSE);
        e->Delete();
		return SELFREG_E_CLASS;
    }
	return S_OK;
}


HRESULT RegisterSnapin(
	AMC::CRegKey& regkeySnapins,
	LPCTSTR pszSnapinGUID,
	BSTR bstrPrimaryNodetype,
	UINT residSnapinName,
	UINT residProvider,
	UINT residVersion,
	bool fStandalone,
	LPCTSTR pszAboutGUID,
	int* aiNodetypeIndexes,
	int  cNodetypeIndexes )
{
   CString strProvider, strVersion;
	if (  !strProvider.LoadString(residProvider)
		|| !strVersion.LoadString(residVersion)
		)
	{
		ASSERT(FALSE);
		return SELFREG_E_CLASS;
	}
	return RegisterSnapin( regkeySnapins,
                          pszSnapinGUID,
                          bstrPrimaryNodetype,
                          residSnapinName,
                          strProvider,
                          strVersion,
                          fStandalone,
                          pszAboutGUID,
                          aiNodetypeIndexes,
                          cNodetypeIndexes);
}

HRESULT RegisterSnapin(
	AMC::CRegKey& regkeySnapins,
	LPCTSTR pszSnapinGUID,
	BSTR bstrPrimaryNodetype,
	UINT residSnapinName,
	const CString& szProvider,
	const CString& szVersion,
	bool fStandalone,
	LPCTSTR pszAboutGUID,
	int* aiNodetypeIndexes,
	int  cNodetypeIndexes )
{
	HRESULT hr = S_OK;
	try
	{
		AMC::CRegKey regkeySnapin;
		CString strSnapinName;
		if (   !strSnapinName.LoadString(residSnapinName)
		   )
		{
			ASSERT(FALSE);
			return SELFREG_E_CLASS;
		}
		regkeySnapin.CreateKeyEx( regkeySnapins, pszSnapinGUID );
		if (NULL != bstrPrimaryNodetype)
		{
			regkeySnapin.SetString( _T("NodeType"), bstrPrimaryNodetype );
		}
		regkeySnapin.SetString( _T("NameString"), strSnapinName );
		regkeySnapin.SetString( _T("Provider"), szProvider );
		regkeySnapin.SetString( _T("Version"), szVersion );
		if (fStandalone)
		{
			AMC::CRegKey regkeyStandalone;
			regkeyStandalone.CreateKeyEx( regkeySnapin, _T("StandAlone") );
		}
		if (NULL != pszAboutGUID)
		{
			regkeySnapin.SetString( _T("About"), pszAboutGUID );
		}
		if ( NULL != aiNodetypeIndexes && 0 != cNodetypeIndexes )
		{
			hr = RegisterNodetypes(
				regkeySnapin,
				aiNodetypeIndexes,
				cNodetypeIndexes );
		}

		//
		// JonN 4/25/00
		// 100624: MUI: MMC: Shared Folders snap-in stores
		//         its display information in the registry
		//
		// MMC now supports NameStringIndirect
		//
		TCHAR achModuleFileName[MAX_PATH+20];
		if (0 < ::GetModuleFileName(
		             AfxGetInstanceHandle(),
		             achModuleFileName,
		             (sizeof(achModuleFileName)/sizeof(TCHAR)) - 1 ))
		{
			achModuleFileName[MAX_PATH+19] = _T('\0'); // 616500-2002/05/07-JonN
			CString strNameIndirect;
			strNameIndirect.Format( _T("@%s,-%d"),
			                        achModuleFileName,
			                        residSnapinName );
			regkeySnapin.SetString( _T("NameStringIndirect"),
			                        strNameIndirect );
		}
	}
	catch (COleException* e)
	{
		ASSERT(FALSE);
        e->Delete();
		return SELFREG_E_CLASS;
    }
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\inc\snapreg.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       SnpInReg.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11/10/1998 JonN    Created
//
//____________________________________________________________________________


#ifndef _SNPINREG_H_
#define _SNPINREG_H_

HRESULT RegisterSnapin(
	AMC::CRegKey& regkeySnapins,
	LPCTSTR pszSnapinGUID,
	BSTR bstrPrimaryNodetype,
	UINT residSnapinName,
	UINT residProvider,
	UINT residVersion,
	bool fStandalone,
	LPCTSTR pszAboutGUID,
	int* aiNodetypeIndexes,
	int  cNodetypeIndexes );

HRESULT RegisterSnapin(
	AMC::CRegKey& regkeySnapins,
	LPCTSTR pszSnapinGUID,
	BSTR bstrPrimaryNodetype,
	UINT residSnapinName,
	const CString& szProvider,
	const CString& szVersion,
	bool fStandalone,
	LPCTSTR pszAboutGUID,
	int* aiNodetypeIndexes,
	int  cNodetypeIndexes );

#endif // _SNPINREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\inc\stdabout.cpp ===
/////////////////////////////////////////////////////////////////////
//	StdAbout.cpp
//
//	Implementation of the ISnapinAbout interface
//
//	HISTORY
//	31-Jul-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

#include "stdutils.h" // HrLoadOleString()

CSnapinAbout::CSnapinAbout()
: m_hSmallImage (0),
  m_hSmallImageOpen (0),
  m_hLargeImage (0)
{
}

CSnapinAbout::~CSnapinAbout()
{
    if ( m_hSmallImage )
        ::DeleteObject (m_hSmallImage);
    
    if ( m_hSmallImageOpen )
        ::DeleteObject (m_hSmallImageOpen);
    
    if ( m_hLargeImage )
        ::DeleteObject (m_hLargeImage);
}

STDMETHODIMP CSnapinAbout::GetSnapinDescription(OUT LPOLESTR __RPC_FAR *lpDescription)
	{
	return HrLoadOleString(m_uIdStrDestription, OUT lpDescription);
	}

STDMETHODIMP CSnapinAbout::GetProvider(OUT LPOLESTR __RPC_FAR *lpName)
	{
	return HrCopyToOleString(m_szProvider, OUT lpName);
	}

STDMETHODIMP CSnapinAbout::GetSnapinVersion(OUT LPOLESTR __RPC_FAR *lpVersion)
	{
	return HrCopyToOleString(m_szVersion, OUT lpVersion);
	}

STDMETHODIMP CSnapinAbout::GetSnapinImage(OUT HICON __RPC_FAR *hAppIcon)
	{
	if (hAppIcon == NULL)
		return E_POINTER;
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
    *hAppIcon = ::LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(m_uIdIconImage));
    if (*hAppIcon == NULL)
		{
		ASSERT(FALSE && "Unable to load icon");
		return E_FAIL;
		}
	return S_OK;
	}

STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
            OUT HBITMAP __RPC_FAR *hSmallImage,
            OUT HBITMAP __RPC_FAR *hSmallImageOpen,
            OUT HBITMAP __RPC_FAR *hLargeImage,
            OUT COLORREF __RPC_FAR *crMask)
{	
	ASSERT(hSmallImage != NULL);
	ASSERT(hSmallImageOpen != NULL);
	ASSERT(hLargeImage != NULL);
	ASSERT(crMask != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
	HINSTANCE hInstance = AfxGetInstanceHandle();

    if ( !m_hSmallImage )
	    m_hSmallImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapSmallImage));
    if ( !m_hSmallImageOpen )
	    m_hSmallImageOpen = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapSmallImageOpen));
    if ( !m_hLargeImage )
	    m_hLargeImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(m_uIdBitmapLargeImage));

	*hSmallImage = m_hSmallImage;
	*hSmallImageOpen = m_hSmallImageOpen;
	*hLargeImage = m_hLargeImage;
    
    *crMask = m_crImageMask;
	#ifdef _DEBUG
	if (NULL == *hSmallImage || NULL == *hSmallImageOpen || NULL == *hLargeImage)
	{
		TRACE0("WRN: CSnapinAbout::GetStaticFolderImage() - Unable to load all the bitmaps.\n");
		return E_FAIL;
	}
	#endif
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\inc\stdabout.h ===
/////////////////////////////////////////////////////////////////////
//	StdAbout.h
//
//	HISTORY
//	31-Jul-97	t-danm		Creation.
/////////////////////////////////////////////////////////////////////

#ifndef __STDABOUT_H_INCLUDED__
#define __STDABOUT_H_INCLUDED__


class CSnapinAbout :
	public ISnapinAbout,
	public CComObjectRoot
{
BEGIN_COM_MAP(CSnapinAbout)
	COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()
public:
	CSnapinAbout();
    virtual ~CSnapinAbout ();

// ISnapinAbout
	STDMETHOD(GetSnapinDescription)(OUT LPOLESTR __RPC_FAR *lpDescription);
	STDMETHOD(GetProvider)(OUT LPOLESTR __RPC_FAR *lpName);
	STDMETHOD(GetSnapinVersion)(OUT LPOLESTR __RPC_FAR *lpVersion);
	STDMETHOD(GetSnapinImage)(OUT HICON __RPC_FAR *hAppIcon);
	STDMETHOD(GetStaticFolderImage)(
            OUT HBITMAP __RPC_FAR *hSmallImage,
            OUT HBITMAP __RPC_FAR *hSmallImageOpen,
            OUT HBITMAP __RPC_FAR *hLargeImage,
            OUT COLORREF __RPC_FAR *crMask);
protected:
	// The following data members MUST be initialized by the constructor
	// of the derived class.
	UINT m_uIdStrDestription;		// Resource Id of the description
	CString m_szProvider;		// string of the provider (ie, Microsoft Corporation)
	CString m_szVersion;			// string of the version of the snapin
	UINT m_uIdIconImage;			// Resource Id for the icon/image of the snapin
	UINT m_uIdBitmapSmallImage;
	UINT m_uIdBitmapSmallImageOpen;
	UINT m_uIdBitmapLargeImage;
	COLORREF m_crImageMask;
    HBITMAP m_hSmallImage;          // cached bitmap for GetStaticFolderImage
    HBITMAP m_hSmallImageOpen;      // cached bitmap for GetStaticFolderImage
    HBITMAP m_hLargeImage;          // cached bitmap for GetStaticFolderImage
}; // CSnapinAbout()

#endif // ~__STDABOUT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\inc\stdcdata.h ===
// stdcdata.h : Declaration of CComponentData

#ifndef __STDCDATA_H_INCLUDED__
#define __STDCDATA_H_INCLUDED__

#include "stdcooki.h"

class CComponentData :
	public IComponentData,
	public CComObjectRoot,
	public ISnapinHelp2
{
BEGIN_COM_MAP(CComponentData)
	COM_INTERFACE_ENTRY(IComponentData)
	COM_INTERFACE_ENTRY(ISnapinHelp2)
// no taskpads	COM_INTERFACE_ENTRY(IComponentData2)
END_COM_MAP()
public:
	CComponentData();
	~CComponentData();

// IComponentData
//   Note: QueryDataObject and CreateComponent must be defined by subclass
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
	STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent) = 0;
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
	STDMETHOD(Destroy)();
	STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject) = 0;
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

/* no taskpads
// IComponentData2
	STDMETHOD(ExpandAndGet)(HSCOPEITEM hsiStartFrom,
	                        LPDATAOBJECT pDataObject,
							HSCOPEITEM* phScopeItem );
*/

// Other stuff
	// needed for Initialize()
	virtual HRESULT LoadIcons(LPIMAGELIST pImageList, BOOL fLoadLargeIcons) = 0;

	// needed for Notify()
	virtual HRESULT OnNotifyPreload(LPDATAOBJECT lpDataObject, HSCOPEITEM hRootScopeItem);
	virtual HRESULT OnNotifyExpand(LPDATAOBJECT lpDataObject, BOOL bExpanding, HSCOPEITEM hParent);
	virtual HRESULT OnNotifyRename(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
	virtual HRESULT OnNotifyDelete(LPDATAOBJECT lpDataObject); // user hit DEL key
	virtual HRESULT OnNotifyRelease(LPDATAOBJECT lpDataObject, HSCOPEITEM hItem); // parent node released
	virtual HRESULT OnPropertyChange( LPARAM param );

	// needed for GetDisplayInfo(), must be defined by subclass
	// ISSUE-2002/03/05-JonN should be type LPOLESTR
	virtual BSTR QueryResultColumnText(CCookie& basecookieref, int nCol ) = 0;
	virtual int QueryImage(CCookie& basecookieref, BOOL fOpenImage) = 0;

	virtual CCookie& QueryBaseRootCookie() = 0;

	inline CCookie* ActiveBaseCookie( CCookie* pcookie )
	{
		return (NULL == pcookie) ? &QueryBaseRootCookie() : pcookie;
	}

	INT DoPopup(	INT nResourceID,
					DWORD dwErrorNumber = 0,
					LPCTSTR pszInsertionString = NULL,
					UINT fuStyle = MB_OK | MB_ICONSTOP );

	LPCONSOLE QueryConsole()
	{
		ASSERT( NULL != m_pConsole );
		return m_pConsole;
	}

	LPCONSOLENAMESPACE QueryConsoleNameSpace()
	{
		ASSERT( NULL != m_pConsoleNameSpace );
		return m_pConsoleNameSpace;
	}

	void SetHtmlHelpFileName (const CString &fileName)
	{
		m_szHtmlHelpFileName = fileName;
	}

	const CString GetHtmlHelpFileName () const
	{
		return m_szHtmlHelpFileName;
	}
	HRESULT GetHtmlHelpFilePath( CString& strref ) const;

	// ISnapinHelp2 interface members
	STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);
    STDMETHOD(GetLinkedTopics)(LPOLESTR* lpCompiledHelpFiles);

protected:
	CString		m_szHtmlHelpFileName;
	LPCONSOLE m_pConsole;
	LPCONSOLENAMESPACE m_pConsoleNameSpace; // My interface pointer to the namespace
};

#endif // ~__STDCDATA_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\inc\stdcooki.cpp ===
// Stdcooki.cpp : Implementation of CCookie and related classes

#include "stdcooki.h"
#include "stdutils.h" // FCompareMachineNames

//
// CHasMachineName
//

// returns <0, 0 or >0
HRESULT CHasMachineName::CompareMachineNames( CHasMachineName& refHasMachineName, int* pnResult )
{
	/*
	// This code is intended to help debug a problem and can be removed later
	LPCWSTR pszTargetServer = QueryTargetServer();
	LPCWSTR pszTargetServer2 = refHasMachineName.QueryTargetServer();
	if (NULL != pszTargetServer && ::IsBadStringPtr(pszTargetServer,MAX_PATH))
	{
		ASSERT(FALSE);
		// repeat operation so that we can find problem
		pszTargetServer = QueryTargetServer();
	}
	if (NULL != pszTargetServer2 && ::IsBadStringPtr(pszTargetServer2,MAX_PATH))
	{
		ASSERT(FALSE);
		// repeat operation so that we can find problem
		pszTargetServer2 = refHasMachineName.QueryTargetServer();
	}
	// This code is intended to help debug a problem and can be removed later
	*/

	if (NULL != pnResult) // JonN 2002/03/28
		*pnResult = ::CompareMachineNames( QueryTargetServer(),
	                                  refHasMachineName.QueryTargetServer() );

	return S_OK;
}

//
// CCookie
//

CCookie::~CCookie()
{
	ReleaseScopeChildren();

	// The views of this cookie should already have been closed
	// ReleaseResultChildren();
	ASSERT( 0 == m_nResultCookiesRefcount );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\inc\stdcdata.cpp ===
// stdcdata.cpp : Implementation of CComponentData

#include "stdcdata.h"
#include "guidhelp.h" // ExtractObjectTypeGUID
#include "stddtobj.h" // CDataObject::m_CFRawCookie
#include "stdrsrc.h"  // IDS_FRAMEWORK_*

//
// CComponentData
//

CComponentData::CComponentData()
: m_pConsole( NULL ),
  m_pConsoleNameSpace( NULL )
{
}

CComponentData::~CComponentData()
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  ASSERT(NULL == m_pConsole && NULL == m_pConsoleNameSpace); // object should be Destroy()ed before being Release()d
  SAFE_RELEASE( m_pConsole );
  SAFE_RELEASE( m_pConsoleNameSpace );
}

HRESULT CComponentData::OnNotifyExpand(LPDATAOBJECT /*lpDataObject*/, BOOL /*bExpanding*/, HSCOPEITEM /*hParent*/)
{
  return S_OK;
}

HRESULT CComponentData::OnNotifyPreload(LPDATAOBJECT /*lpDataObject*/, HSCOPEITEM /*hRootScopeItem*/)
{
  return S_OK;
}

HRESULT CComponentData::OnNotifyRename(LPDATAOBJECT /*lpDataObject*/, LPARAM arg, LPARAM /*param*/)
{
  // by default, do not allow rename
  return (0 == arg) ? S_FALSE : S_OK;
}

HRESULT CComponentData::OnNotifyDelete(LPDATAOBJECT /*lpDataObject*/)
{
  ASSERT(FALSE); // Why did you enable the Delete command if you won't handle it?
  return S_OK;
}
HRESULT CComponentData::OnNotifyRelease(LPDATAOBJECT /*lpDataObject*/, HSCOPEITEM /*hItem*/)
{
  ASSERT(FALSE); // You will leak memory if you don't handle this
  return S_OK;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponentData::IComponentData::Notify(MMCN_PROPERTY_CHANGE)
// OnPropertyChange() is generated by MMCPropertyChangeNotify( param )
HRESULT CComponentData::OnPropertyChange( LPARAM /*param*/ )
{
  return S_OK;
}


/*
 *  IComponentData
 */

STDMETHODIMP CComponentData::Initialize(LPUNKNOWN pUnknown)
{
    MFC_TRY;
    // ISSUE-2002/03/28-JonN handle NULL parameter
    ASSERT(pUnknown != NULL);

    // MMC should only call ::Initialize once!
    ASSERT(NULL == m_pConsoleNameSpace);
    SAFE_RELEASE( m_pConsoleNameSpace );
    HRESULT hr = pUnknown->QueryInterface(IID_IConsoleNameSpace,
                    reinterpret_cast<void**>(&m_pConsoleNameSpace));
    ASSERT( SUCCEEDED(hr) );

    // add the images for the scope tree
    // ISSUE-2002/03/28-JonN use smartpointer
    LPIMAGELIST lpScopeImage = NULL;

    ASSERT(NULL == m_pConsole);
    SAFE_RELEASE( m_pConsole );
    hr = pUnknown->QueryInterface(IID_IConsole, reinterpret_cast<void**>(&m_pConsole));
    ASSERT( SUCCEEDED(hr) );

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);
    ASSERT( SUCCEEDED(hr) );

    hr = LoadIcons(lpScopeImage, FALSE);
    ASSERT( SUCCEEDED(hr) );

    lpScopeImage->Release();

    MFC_CATCH;
    return S_OK;
}

STDMETHODIMP CComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;
    MFC_TRY;

    switch(event)
    {
    case MMCN_EXPAND:
    hr = OnNotifyExpand( lpDataObject, (BOOL)arg, (HSCOPEITEM)param );
        break;
    case MMCN_RENAME:
    hr = OnNotifyRename( lpDataObject, arg, param );
        break;
    case MMCN_DELETE:
    hr = OnNotifyDelete( lpDataObject );
	    break;
    case MMCN_REMOVE_CHILDREN:
    hr = OnNotifyRelease( lpDataObject, arg );
        break;

    case MMCN_PRELOAD:
    hr = OnNotifyPreload (lpDataObject, (HSCOPEITEM) arg);
        break;

    case MMCN_PROPERTY_CHANGE:
    // CODEWORK arg is "fScopePane", should this be passed on?
    hr = OnPropertyChange( param );
        break;

    default:
    TRACE1("INFO: CComponentData::Notify () - Unknown Event %d.\n", event); // add new method for this notification
        break;
    }

    MFC_CATCH;
    return hr;
}

STDMETHODIMP CComponentData::Destroy()
{
    MFC_TRY;
    SAFE_RELEASE(m_pConsoleNameSpace);
    SAFE_RELEASE(m_pConsole);
    MFC_CATCH;
    return S_OK;
}

STDMETHODIMP CComponentData::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
  MFC_TRY;
  // ISSUE-2002/03/28-JonN handle pSDI==NULL and pSDI->lParam==NULL
  // WARNING cookie cast
  CCookie* pcookie = reinterpret_cast<CCookie*>(pScopeDataItem->lParam);
  ASSERT(NULL != pcookie);

  ASSERT( NULL != pScopeDataItem ); // result items never have NULL cookie
  if (SDI_STR & pScopeDataItem->mask)
  {
    pScopeDataItem->displayname = QueryResultColumnText( *pcookie, 0 );
    if ( NULL == pScopeDataItem->displayname )
      pScopeDataItem->displayname = L""; // just in case
  }
  if ( (SDI_IMAGE|SDI_OPENIMAGE) & pScopeDataItem->mask )
  {
    pScopeDataItem->nImage = QueryImage(
      *pcookie, !!(SDI_OPENIMAGE & pScopeDataItem->mask) );
  }
  MFC_CATCH;
  return S_OK;
/*
    ASSERT(pScopeDataItem->mask == TVIF_TEXT);
  pScopeDataItem->displayname = QueryResultColumnText(*pcookie,0);
    ASSERT(pScopeDataItem->displayname != NULL);

    return S_OK;
*/
}

STDMETHODIMP CComponentData::CompareObjects(
  LPDATAOBJECT lpDataObjectA,
  LPDATAOBJECT lpDataObjectB)
{
  int nResult = COMPARESIMILARCOOKIE_FULL;  // a full cookie comparison is desired.
  MFC_TRY;
  GUID guidA, guidB;
  HRESULT hr = ::ExtractObjectTypeGUID( lpDataObjectA, &guidA );
  if ( FAILED(hr) )
    return hr;
  hr = ::ExtractObjectTypeGUID( lpDataObjectB, &guidB );
  if ( FAILED(hr) )
    return hr;
  if ( 0 != ::memcmp( &guidA, &guidB, sizeof(GUID) ) )
    return S_FALSE; // different nodetypes

  // If the two nodetypes are the same, both of these objects
  // must belong to this snapin

  // Extract cookies
  // WARNING cookie cast
  CCookie* pcookieA = NULL;
  hr = ExtractData( lpDataObjectA,
                    CDataObject::m_CFRawCookie,
                    &pcookieA,
                    sizeof(pcookieA) );
  if ( FAILED(hr) )
  {
    ASSERT( FALSE );
    return hr;
  }
  pcookieA = ActiveBaseCookie(pcookieA);
  // WARNING cookie cast
  CCookie* pcookieB = NULL;
  hr = ExtractData( lpDataObjectB,
                    CDataObject::m_CFRawCookie,
                    &pcookieB,
                    sizeof(pcookieB) );
  if ( FAILED(hr) )
  {
    ASSERT( FALSE );
    return hr;
  }
  pcookieB = ActiveBaseCookie(pcookieB);

  // Compare cookies
  if (pcookieA == pcookieB)
    return S_OK;
  hr = pcookieA->CompareSimilarCookies( pcookieB, &nResult );
  if( FAILED(hr) )
    return hr;

  MFC_CATCH;
  return (0 == nResult) ? S_OK : S_FALSE;
}

int
GetErrorMsg(
    IN DWORD    dwError, 
    OUT PTSTR*  pptzMsg
)
{
  // ISSUE-2002/03/28-JonN check for NULL ptr
  ASSERT(dwError != ERROR_SUCCESS);

  int cch = FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER 
        | FORMAT_MESSAGE_FROM_SYSTEM,
        NULL, dwError,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (PTSTR)pptzMsg, 0, NULL);

  if (0 == cch)
  {
    static HMODULE g_hNetMod = 0;
    if (0 == g_hNetMod)
      g_hNetMod = GetModuleHandle (L"netmsg.dll");

    if (g_hNetMod)
      cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
                        | FORMAT_MESSAGE_FROM_HMODULE,
                        g_hNetMod, dwError,
                        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                        (PTSTR)pptzMsg, 0, NULL);
  }

  return cch;
}

INT CComponentData::DoPopup( INT nResourceID, DWORD dwErrorNumber, LPCTSTR pszInsertionString, UINT fuStyle )
{
  AFX_MANAGE_STATE(AfxGetStaticModuleState());
  CString strTitle;
  VERIFY( strTitle.LoadString(
    (MB_ICONSTOP == (fuStyle & 0x000000F0))
    ? IDS_FRAMEWORK_TITLE_ERROR : IDS_FRAMEWORK_TITLE_WARNING ) );
  CString strError;
  if (0 != dwErrorNumber || NULL != pszInsertionString)
  {
    CString strFormat;
    VERIFY( strFormat.LoadString( nResourceID ) );

    // ISSUE-2002/03/28-JonN FormatMessage would be safer than Format
    strError.Format( strFormat, dwErrorNumber, pszInsertionString );

    if (0 != dwErrorNumber)
    {
      PTSTR pszErrorMsg = NULL;
      int cch = GetErrorMsg(dwErrorNumber, &pszErrorMsg);
      if (cch > 0)
      {
        strError += _T("\n\n");
        strError += pszErrorMsg;

        LocalFree(pszErrorMsg);
      }
    }
  }
  else
  {
    VERIFY( strError.LoadString( nResourceID ) );
  }

  INT iRetval = 0;
  USES_CONVERSION;
  HRESULT hr = m_pConsole->MessageBox(
    T2OLE(const_cast<LPTSTR>((LPCTSTR)strError)),
    T2OLE(const_cast<LPTSTR>((LPCTSTR)strTitle)),
    fuStyle,
    &iRetval );
  ASSERT( SUCCEEDED(hr) );

  return iRetval;
}

/////////////////////////////////////////////////////////////////////////////
// CMyComputerComponentData::ISnapinHelp members

// Help on IComponentData just returns the file and no particular topic
STDMETHODIMP CComponentData::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
  MFC_TRY;
  if (lpCompiledHelpFile == NULL)
    return E_INVALIDARG;

  CString szHelpFilePath;
  HRESULT hr = GetHtmlHelpFilePath( szHelpFilePath );
  if ( FAILED(hr) )
    return hr;

  *lpCompiledHelpFile = reinterpret_cast <LPOLESTR> (
      CoTaskMemAlloc ((szHelpFilePath.GetLength () + 1) * sizeof (wchar_t)));
  if ( NULL == *lpCompiledHelpFile )
    return E_OUTOFMEMORY;
  // ISSUE-2002/03/28-JonN remove USES_CONVERSION
  USES_CONVERSION;
  wcscpy (*lpCompiledHelpFile, T2OLE ((LPTSTR)(LPCTSTR) szHelpFilePath));
  
  MFC_CATCH;
  return S_OK;
}

STDMETHODIMP CComponentData::GetLinkedTopics(LPOLESTR* /*lpCompiledHelpFiles*/)
{
    return E_NOTIMPL;
}

HRESULT CComponentData::GetHtmlHelpFilePath( CString& strref ) const
{
  if ( GetHtmlHelpFileName().IsEmpty () )
    return E_NOTIMPL;

  UINT nLen = ::GetSystemWindowsDirectory (strref.GetBufferSetLength(2 * MAX_PATH), 2 * MAX_PATH);
  strref.ReleaseBuffer();
  if (0 == nLen)
  {
    ASSERT(FALSE);
    return E_FAIL;
  }

  strref += L"\\help\\";
  strref += GetHtmlHelpFileName();
  
  return S_OK;
}

/* no taskpads
STDMETHODIMP CComponentData::ExpandAndGet(
  HSCOPEITEM hsiStartFrom,
  LPDATAOBJECT pDataObject,
  HSCOPEITEM* phScopeItem )
{
  ASSERT(FALSE);
  return E_NOTIMPL;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\inc\stdcmpnt.cpp ===
// stdcmpnt.cpp : Implementation of CComponent

#include "guidhelp.h" // ExtractData

// Note that m_pComponentData is still NULL during construction
CComponent::CComponent()
:	m_pConsole( NULL ),
	m_pConsoleVerb( NULL ),
	m_pHeader( NULL ),
	m_pResultData( NULL ),
	m_pConsoleNameSpace( NULL ),
	m_pRsltImageList( NULL ),
	m_pComponentData( NULL )
{
}

CComponent::~CComponent()
{
	VERIFY( SUCCEEDED(ReleaseAll()) );
}

/////////////////////////////////////////////////////////////////////
// CComponent::SetComponentDataPtr()
void CComponent::SetComponentDataPtr(
	CComponentData* pComponentData)
{
    ASSERT(NULL != pComponentData && NULL == m_pComponentData);
	(void) ((IComponentData*)pComponentData)->AddRef();
	m_pComponentData = pComponentData;
}

/////////////////////////////////////////////////////////////////////
// CComponent::IComponent::QueryDataObject()
STDMETHODIMP CComponent::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    HRESULT hr = S_OK;
    MFC_TRY;
    // Delegate it to the IComponentData
    hr = QueryBaseComponentDataRef().QueryDataObject(cookie, type, ppDataObject);
    MFC_CATCH;
    return hr;
}

/////////////////////////////////////////////////////////////////////
// CComponent::IComponent::CompareObjects()
STDMETHODIMP CComponent::CompareObjects(
	LPDATAOBJECT lpDataObjectA,
	LPDATAOBJECT lpDataObjectB)
{
	return QueryBaseComponentDataRef().CompareObjects( lpDataObjectA, lpDataObjectB );
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_PROPERTY_CHANGE)
// OnPropertyChange() is generated by MMCPropertyChangeNotify( param )
HRESULT CComponent::OnPropertyChange( LPARAM /*param*/)
{
	return S_OK;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_SELECT)
HRESULT CComponent::OnNotifySelect( LPDATAOBJECT /*lpDataObject*/, BOOL /*fSelected*/ )
{
	return S_OK;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_ACTIVATE)
HRESULT CComponent::OnNotifyActivate( LPDATAOBJECT /*lpDataObject*/, BOOL /*fActivated*/ )
{
	return S_OK;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_CLICK)
HRESULT CComponent::OnNotifyClick( LPDATAOBJECT /*lpDataObject*/ )
{
	TRACE0("CComponent::OnNotifyClick().\n");
	return S_OK;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_DBLCLICK)
HRESULT CComponent::OnNotifyDblClick( LPDATAOBJECT /*lpDataObject*/ )
{
	// Returning S_FALSE allows MMC to do the default verb.
	return S_FALSE;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_ADD_IMAGES)
HRESULT CComponent::OnNotifyAddImages( LPDATAOBJECT /*lpDataObject*/,
	                                   LPIMAGELIST /*lpImageList*/,
									   HSCOPEITEM /*hSelectedItem*/ )
{
	ASSERT(FALSE); // this should be redefined by all snapins
	return S_OK;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_VIEW_CHANGE)
// OnViewChange is generated by UpdateAllViews( lpDataObject, data, hint )
HRESULT CComponent::OnViewChange( LPDATAOBJECT /*lpDataObject*/, LPARAM /*data*/, LPARAM /*hint*/ )
{
	return S_OK;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_REFRESH)
// OnNotifyRefresh is generated by enabling the verb MMC_VERB_REFRESH.
// Typically this routine will be overriden.
HRESULT CComponent::OnNotifyRefresh( LPDATAOBJECT /*lpDataObject*/ )
{
	TRACE0("CComponent::OnNotifyRefresh() - You must implement your own refresh routine.\n");
	return S_OK;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_DELETE)
HRESULT CComponent::OnNotifyDelete( LPDATAOBJECT /*lpDataObject*/ )
{
	return S_OK;
}

/////////////////////////////////////////////////////////////////////
// Virtual function called by CComponent::IComponent::Notify(MMCN_COLUMN_CLICK)
HRESULT CComponent::OnNotifyColumnClick( LPDATAOBJECT /*lpDataObject*/, LPARAM /*iColumn*/, LPARAM /*uFlags*/ )
{
	return S_OK;
}


/////////////////////////////////////////////////////////////////////
//	CComponent::ReleaseAll()
HRESULT CComponent::ReleaseAll()
{
    MFC_TRY;
	TRACE_METHOD(CComponent,Destructor);

	if (NULL != m_pHeader)
		m_pConsole->SetHeader(NULL);

    SAFE_RELEASE(m_pHeader);

    SAFE_RELEASE(m_pResultData);
    SAFE_RELEASE(m_pConsoleNameSpace);
    SAFE_RELEASE(m_pRsltImageList);
    SAFE_RELEASE(m_pConsole);
	SAFE_RELEASE(m_pConsoleVerb);

	if ( NULL != m_pComponentData )
	{
		((IComponentData*)m_pComponentData)->Release();
		m_pComponentData = NULL;
	}

    MFC_CATCH;
	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CComponent::IComponent::Initialize()
STDMETHODIMP CComponent::Initialize(LPCONSOLE lpConsole)
{
    MFC_TRY;
    TRACE_METHOD(CComponent,Create);
    TEST_NONNULL_PTR_PARAM(lpConsole);

    if (NULL == lpConsole)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

	ASSERT( NULL == m_pConsole );
	SAFE_RELEASE( m_pConsole ); // just in case

	lpConsole->AddRef();
    m_pConsole = lpConsole;

    HRESULT hr = m_pConsole->QueryInterface(IID_IHeaderCtrl, (void**)&m_pHeader);

    ASSERT(hr == S_OK);
    if (FAILED(hr))
        return E_FAIL;

    m_pConsole->SetHeader(m_pHeader);

    hr = m_pConsole->QueryConsoleVerb(OUT &m_pConsoleVerb);
    ASSERT(hr == S_OK);
	if (FAILED(hr))
        return hr;
	ASSERT(NULL != m_pConsoleVerb);

    hr = m_pConsole->QueryInterface(IID_IResultData, (void**)&m_pResultData);
    if (FAILED(hr))
        return hr;

    hr = m_pConsole->QueryInterface(IID_IConsoleNameSpace, (void**)&m_pConsoleNameSpace);
    if (FAILED(hr))
        return hr;

    hr = m_pConsole->QueryInterface(IID_IImageList, (void**)&m_pRsltImageList);
    if (FAILED(hr))
        return hr;

    // Load icons for the scope pane
    LPIMAGELIST pImageList;
    hr = m_pConsole->QueryScopeImageList(&pImageList);
    ASSERT(SUCCEEDED(hr));
//    LoadIconsIntoImageList(pImageList, FALSE);
    pImageList->Release();

    MFC_CATCH;
    return S_OK;
} // CComponent::Initialize()

/////////////////////////////////////////////////////////////////////////////
// CComponent::IComponent::Notify()
// Entry point for all the MMCN_ notification messages.
// The routine will then call virtual functions of the CComponent object.
STDMETHODIMP CComponent::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;
//    MFC_TRY;
    TRACE_METHOD(CComponent,Notify);


    switch (event)
    {
    case MMCN_SHOW:
		// CODEWORK this is hacked together quickly
		{
			CCookie* pcookie = NULL;
			hr = ExtractData( lpDataObject,
		                      CDataObject::m_CFRawCookie,
							  (PBYTE)&pcookie,
							  sizeof(pcookie) );
			ASSERT( SUCCEEDED(hr) );
			CCookie* pActiveCookie = ActiveBaseCookie (pcookie);
			// Save the scope item handle in the cookie
			pActiveCookie->m_hScopeItem = (HSCOPEITEM) param;
			hr = Show (pActiveCookie, arg, (HSCOPEITEM) param);
		}
        break;

    case MMCN_MINIMIZED:
        break;

	case MMCN_SELECT:
		hr = OnNotifySelect( lpDataObject, (BOOL)(HIWORD(arg)) );
		break;

	case MMCN_ACTIVATE:
		hr = OnNotifyActivate( lpDataObject, (BOOL)arg );
		break;

	case MMCN_ADD_IMAGES:
		hr = OnNotifyAddImages( lpDataObject,
		                        reinterpret_cast<IImageList*>(arg),
								(HSCOPEITEM)param );
		break;

	case MMCN_CLICK:
		hr = OnNotifyClick( lpDataObject );
		break;

	case MMCN_DBLCLICK:
		hr = OnNotifyDblClick( lpDataObject );
		break;

	case MMCN_PROPERTY_CHANGE:
		// CODEWORK arg is "fScopePane", should this be passed on?
		hr = OnPropertyChange( param );
		break;

	case MMCN_VIEW_CHANGE:
		hr = OnViewChange( lpDataObject, arg, param );
		break;

	case MMCN_REFRESH:
		hr = OnNotifyRefresh( lpDataObject );
		break;

	case MMCN_DELETE:
		hr = OnNotifyDelete( lpDataObject );
		break;

	case MMCN_COLUMN_CLICK:
		hr = OnNotifyColumnClick( lpDataObject, arg, param );
		break;

	case MMCN_CONTEXTHELP:
		hr = OnNotifyContextHelp( lpDataObject );
		break;

	case MMCN_SNAPINHELP:
		hr = OnNotifySnapinHelp( lpDataObject );
		break;

	default:
		TRACE1("INFO: CComponent::Notify() - Unknown Event %d.\n", event);
		break;
    }

//    MFC_CATCH;
    return hr;
} // CComponent::Notify()


// parameter "MMC_COOKIE cookie" is reserved per MSDN
STDMETHODIMP CComponent::Destroy(MMC_COOKIE /*cookie*/)
{
    MFC_TRY;
	TRACE_METHOD(CComponent,Destroy);

	VERIFY( SUCCEEDED( ReleaseAll() ) );

    MFC_CATCH;
	return S_OK;
}


HRESULT CComponent::InsertResultCookies( CCookie& refparentcookie )
{
	ASSERT( NULL != m_pResultData );

    RESULTDATAITEM tRDItem;
	::ZeroMemory( &tRDItem, sizeof(tRDItem) );
	tRDItem.nCol = 0;
	tRDItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
	tRDItem.str = MMC_CALLBACK;
	// CODEWORK should use MMC_ICON_CALLBACK here

	HRESULT hr = S_OK;
	POSITION pos = refparentcookie.m_listResultCookieBlocks.GetHeadPosition();
	while (NULL != pos)
	{
		CBaseCookieBlock* pblock = refparentcookie.m_listResultCookieBlocks.GetNext( pos );
		ASSERT( NULL != pblock );
		for (INT i = 0; i < pblock->QueryNumCookies(); i++)
		{
			CCookie* pbasecookie = pblock->QueryBaseCookie(i);
			tRDItem.nImage = QueryBaseComponentDataRef().QueryImage( *pbasecookie, FALSE );
			// WARNING cookie cast
			tRDItem.lParam = reinterpret_cast<LPARAM>(pbasecookie);
	        hr = m_pResultData->InsertItem(&tRDItem);
			if ( FAILED(hr) )
			{
				ASSERT(FALSE);
				break;
			}
		}
	}
	return hr;
}


STDMETHODIMP CComponent::GetResultViewType(MMC_COOKIE /*cookie*/,
										   BSTR* ppViewType,
										   long* pViewOptions)
{
    // ISSUE-2002/03/28-JonN check for NULL
    *ppViewType = NULL;
    *pViewOptions = MMC_VIEW_OPTIONS_NONE;
    return S_FALSE;
}

STDMETHODIMP CComponent::GetDisplayInfo(RESULTDATAITEM* pResultDataItem)
{
	MFC_TRY;
	CCookie* pcookie = ActiveBaseCookie(
		reinterpret_cast<CCookie*>(pResultDataItem->lParam));
	// ISSUE-2002/03/28-JonN handle NULL parameter
	ASSERT( NULL != pResultDataItem ); // result items never have NULL cookie
	if (RDI_STR & pResultDataItem->mask)
	{
		pResultDataItem->str = QueryBaseComponentDataRef().QueryResultColumnText(
			*pcookie,
			pResultDataItem->nCol );
		if ( NULL == pResultDataItem->str )
			pResultDataItem->str = L""; // just in case
	}
	if ( RDI_IMAGE & pResultDataItem->mask )
	{
		pResultDataItem->nImage = QueryBaseComponentDataRef().QueryImage(
			*pcookie, FALSE );
	}
	MFC_CATCH;
	return S_OK;
}

// CODEWORK These should be parameters rather than globals
// CODEWORK figure out correct const'ing
extern UINT** g_aColumns;
extern int** g_aColumnWidths;

HRESULT CComponent::LoadColumnsFromArrays(
	INT objecttype )
{
	ASSERT( NULL != m_pHeader );

	CString str;
	// ISSUE-2002/03/28-JonN check objecttype parameter
	// ISSUE-2002/03/28-JonN should invoke AFX_MANAGE_STATE
	const UINT* pColumns = g_aColumns[objecttype];
	const int* pColumnWidths = g_aColumnWidths[objecttype];
	ASSERT( NULL != pColumns && NULL != pColumnWidths );
	for ( INT i = 0; 0 != pColumns[i]; i++)
	{
		VERIFY( str.LoadString( pColumns[i] ) );
		m_pHeader->InsertColumn(i, const_cast<LPTSTR>((LPCTSTR)str), LVCFMT_LEFT,
			pColumnWidths[i]);
	}

	return S_OK;
}

HRESULT CComponent::OnNotifySnapinHelp (LPDATAOBJECT /*pDataObject*/)
{
	return ShowHelpTopic( NULL ); // snapins should redefine this
}

HRESULT CComponent::OnNotifyContextHelp (LPDATAOBJECT pDataObject)
{
	return OnNotifySnapinHelp( pDataObject ); // snapins should redefine this
}

HRESULT CComponent::ShowHelpTopic( LPCWSTR lpcwszHelpTopic )
{
    HRESULT hr = S_OK;
    MFC_TRY;
	CComQIPtr<IDisplayHelp,&IID_IDisplayHelp>	spDisplayHelp = m_pConsole;
	if ( !spDisplayHelp )
	{
		ASSERT(FALSE);
		return E_UNEXPECTED;
	}

	CString strHelpTopic;
	hr = QueryBaseComponentDataRef().GetHtmlHelpFilePath( strHelpTopic );
	if ( FAILED(hr) )
		return hr;
	if (NULL != lpcwszHelpTopic && L'\0' != *lpcwszHelpTopic)
	{
		strHelpTopic += L"::/";
		strHelpTopic += lpcwszHelpTopic;
	}
	hr = spDisplayHelp->ShowTopic (T2OLE ((LPWSTR)(LPCWSTR) strHelpTopic));
	ASSERT (SUCCEEDED (hr));

    MFC_CATCH;
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\inc\stdcmpnt.h ===
// stdcmpnt.h : Declaration of CComponent

#ifndef __STDCMPNT_H_INCLUDED__
#define __STDCMPNT_H_INCLUDED__

#include "stdcooki.h"  // CCookie
#include "stdcdata.h"  // CComponentData

class CComponent :
	public CComObjectRoot,
	public IComponent
{
public:
	CComponent();
	virtual ~CComponent();

BEGIN_COM_MAP(CComponent)
	COM_INTERFACE_ENTRY(IComponent)
END_COM_MAP()

	// IComponent
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie, LPOLESTR* ppViewType, long* pViewOptions);
    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM* pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

	// support methods for IComponent
	virtual HRESULT ReleaseAll();
	virtual HRESULT OnPropertyChange( LPARAM param );
	virtual HRESULT OnViewChange( LPDATAOBJECT lpDataObject, LPARAM data, LPARAM hint );
	virtual HRESULT OnNotifyRefresh( LPDATAOBJECT lpDataObject );
	virtual HRESULT OnNotifyDelete( LPDATAOBJECT lpDataObject );
	virtual HRESULT OnNotifyColumnClick( LPDATAOBJECT lpDataObject, LPARAM iColumn, LPARAM uFlags );
	virtual HRESULT OnNotifySelect( LPDATAOBJECT lpDataObject, BOOL fSelected );
	virtual HRESULT OnNotifyActivate( LPDATAOBJECT lpDataObject, BOOL fActivated );
	virtual HRESULT OnNotifyAddImages( LPDATAOBJECT lpDataObject, LPIMAGELIST lpImageList, HSCOPEITEM hSelectedItem );
	virtual HRESULT OnNotifyClick( LPDATAOBJECT lpDataObject );
	virtual HRESULT OnNotifyDblClick( LPDATAOBJECT lpDataObject );
	virtual HRESULT Show(CCookie* pcookie, LPARAM arg, HSCOPEITEM hScopeItem) = 0;
	virtual HRESULT OnNotifyContextHelp (LPDATAOBJECT pDataObject);
	virtual HRESULT OnNotifySnapinHelp (LPDATAOBJECT pDataObject);

	HRESULT ShowHelpTopic( LPCWSTR lpcwszHelpTopic );

	HRESULT InsertResultCookies( CCookie& refparentcookie );

    void SetComponentDataPtr(CComponentData* pComponentData);
	CComponentData& QueryBaseComponentDataRef()
	{
		// ISSUE-2002/03/28-JonN We need to handle NULL better
		ASSERT( NULL != m_pComponentData );
		return *m_pComponentData;
	}

	inline CCookie& QueryBaseRootCookie()
	{
		return QueryBaseComponentDataRef().QueryBaseRootCookie();
	}

	inline CCookie* ActiveBaseCookie( CCookie* pcookie )
	{
		return QueryBaseComponentDataRef().ActiveBaseCookie( pcookie );
	}

	inline INT DoPopup(	INT nResourceID,
						DWORD dwErrorNumber = 0,
						LPCTSTR pszInsertionString = NULL,
						UINT fuStyle = MB_OK | MB_ICONSTOP )
	{
		return QueryBaseComponentDataRef().DoPopup( nResourceID,
		                                            dwErrorNumber,
												    pszInsertionString,
												    fuStyle );
	}

	HRESULT LoadColumnsFromArrays( INT objecttype );

protected:
    LPCONSOLE       m_pConsole;
    LPCONSOLEVERB   m_pConsoleVerb;
    LPHEADERCTRL    m_pHeader;
    LPRESULTDATA    m_pResultData;
    LPCONSOLENAMESPACE m_pConsoleNameSpace;
    LPIMAGELIST		m_pRsltImageList;

private:
	CComponentData*	m_pComponentData;
};

#endif // ~__STDCMPNT_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\inc\stdcooki.h ===
// stdcooki.h : Declaration of base cookie class and related classes

#ifndef __STDCOOKI_H_INCLUDED__
#define __STDCOOKI_H_INCLUDED__


// forward declarations
class CCookie;

class CRefcountedObject
{
public:
	inline CRefcountedObject()
		: m_nRefcount( 1 )
	{};
	virtual ~CRefcountedObject() {};

	inline void AddRef() {m_nRefcount++;}
	inline void Release()
	{
		if (0 >= --m_nRefcount)
			delete this;
	}
private:
	int m_nRefcount;
};


class CHasMachineName
{
public:
	virtual void SetMachineName( LPCTSTR lpcszMachineName ) = 0;
	virtual LPCTSTR QueryNonNULLMachineName() = 0;
	virtual LPCTSTR QueryTargetServer() = 0;

	// returns <0, 0 or >0
	HRESULT CompareMachineNames( CHasMachineName& refHasMachineName, int* pnResult );
};

//
// CBaseCookieBlock holds a block of cookies and the data
// to which the cookies point.  It starts off with a
// reference count of 1.  When a data object is created
// which references one of these cookies, AddRef() the cookie block; when such
// a data object is released, Release() the cookie block.  Similarly,
// when the parent cookie is finished with the cookie block, it should
// Release() the cookie block.  The cookie block will delete itself
// when the reference count reaches 0.  Do not attempt to explicitly
// delete the cookie block.
//
class CBaseCookieBlock : public CRefcountedObject
{
public:
	virtual CCookie* QueryBaseCookie(int i) = 0;
	virtual int QueryNumCookies() = 0;
};

template<class COOKIE_TYPE>
class CCookieBlock
: public CBaseCookieBlock
{
private:
	COOKIE_TYPE* m_aCookies;
	int m_cCookies;

public:
	CCookieBlock(COOKIE_TYPE* aCookies, // use vector ctor, we use vector dtor
		         int cCookies );
	virtual ~CCookieBlock();

	virtual CCookie* QueryBaseCookie(int i);
	virtual int QueryNumCookies();
};


// ISSUE-2002/03/28-JonN QueryBaseCookie(i) should assert range
#define DEFINE_COOKIE_BLOCK(COOKIE_TYPE)                \
template <>                                             \
CCookieBlock<COOKIE_TYPE>::CCookieBlock<COOKIE_TYPE>    \
	(COOKIE_TYPE* aCookies, int cCookies)               \
	: m_aCookies( aCookies )                            \
	, m_cCookies( cCookies )                            \
{                                                       \
	ASSERT(NULL != aCookies && 0 < cCookies);           \
}                                                       \
template <>                                             \
CCookieBlock<COOKIE_TYPE>::~CCookieBlock<COOKIE_TYPE>() \
{                                                       \
	delete[] m_aCookies;                                \
}                                                       \
template <>                                             \
CCookie* CCookieBlock<COOKIE_TYPE>::QueryBaseCookie(int i) \
{                                                       \
	return (CCookie*)&(m_aCookies[i]);                  \
}                                                       \
template <>                                             \
int CCookieBlock<COOKIE_TYPE>::QueryNumCookies()        \
{                                                       \
	return m_cCookies;                                  \
}

#define COMPARESIMILARCOOKIE_FULL                       -1

//
// I am trying to allow child classes to derive from CCookie using
// multiple inheritance, but this is tricky
//
class CCookie
{
public:
	CTypedPtrList<CPtrList, CBaseCookieBlock*>  m_listScopeCookieBlocks;
	CTypedPtrList<CPtrList, CBaseCookieBlock*>  m_listResultCookieBlocks;
	HSCOPEITEM									m_hScopeItem;

private:
	LONG m_nResultCookiesRefcount;

public:
	inline CCookie()
		: m_nResultCookiesRefcount( 0 ),
		m_hScopeItem (0)
	{
	}

	inline void ReleaseScopeChildren()
	{
		while ( !m_listScopeCookieBlocks.IsEmpty() )
		{
			(m_listScopeCookieBlocks.RemoveHead())->Release();
		}
	}

	// returns new refcount
	inline ULONG AddRefResultChildren()
	{
		return ++m_nResultCookiesRefcount;
	}

	inline void ReleaseResultChildren()
	{
		ASSERT( 0 < m_nResultCookiesRefcount );
		if ( 0 >= --m_nResultCookiesRefcount )
		{
			while ( !m_listResultCookieBlocks.IsEmpty() )
			{
				(m_listResultCookieBlocks.RemoveHead())->Release();
			}
		}
	}

	virtual ~CCookie();

	// On entry, if not COMPARESIMILARCOOKIE_FULL, *pnResult is the column on which to sort,
        // otherwise, try to do a full cookie comparison.
	// On exit, *pnResult should be <0, 0 or >0.
	// Note that this is a sorting function and should not be used to establish
	// object identity where better identity functions are available.
	virtual HRESULT CompareSimilarCookies( CCookie* pOtherCookie, int* pnResult ) = 0;
};

#define DECLARE_FORWARDS_MACHINE_NAME(targ)             \
virtual LPCTSTR QueryNonNULLMachineName();              \
virtual LPCTSTR QueryTargetServer();                    \
virtual void SetMachineName( LPCTSTR lpcszMachineName );

#define DEFINE_FORWARDS_MACHINE_NAME(thisclass,targ)    \
LPCTSTR thisclass::QueryNonNULLMachineName()            \
{                                                       \
	ASSERT( (targ) != NULL );                           \
	return ((CHasMachineName*)(targ))->QueryNonNULLMachineName(); \
}                                                       \
LPCTSTR thisclass::QueryTargetServer()                  \
{                                                       \
	ASSERT( (targ) != NULL );                           \
	return ((CHasMachineName*)(targ))->QueryTargetServer(); \
}                                                       \
void thisclass::SetMachineName( LPCTSTR lpcszMachineName ) \
{                                                       \
	ASSERT( (targ) != NULL );                           \
	((CHasMachineName*)(targ))->SetMachineName( lpcszMachineName ); \
}

#define STORES_MACHINE_NAME                             \
public:                                                 \
	CString m_strMachineName;                           \
virtual void SetMachineName( LPCTSTR lpcszMachineName ) \
{                                                       \
	m_strMachineName = lpcszMachineName;                \
}                                                       \
virtual LPCTSTR QueryNonNULLMachineName()               \
{                                                       \
	return (LPCTSTR)m_strMachineName;                   \
}                                                       \
virtual LPCTSTR QueryTargetServer()                     \
{                                                       \
	return (m_strMachineName.IsEmpty())                 \
		? NULL : (LPCTSTR)(m_strMachineName);           \
}


class CStoresMachineName : public CHasMachineName
{
public:
	CStoresMachineName( LPCTSTR lpcszMachineName )
		: m_strMachineName( lpcszMachineName )
	{}

    STORES_MACHINE_NAME;
};

#endif // ~__STDCOOKI_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\inc\stddtobj.cpp ===
// StdDtObj.cpp : Implementation of DataObject base classe

#include "stddtobj.h"

CDataObject::~CDataObject()
{
}

// Register the clipboard formats
CLIPFORMAT CDataObject::m_CFNodeType =
	(CLIPFORMAT)RegisterClipboardFormat(CCF_NODETYPE);
CLIPFORMAT CDataObject::m_CFNodeTypeString =
	(CLIPFORMAT)RegisterClipboardFormat(CCF_SZNODETYPE);
CLIPFORMAT CDataObject::m_CFSnapInCLSID =
	(CLIPFORMAT)RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
CLIPFORMAT CDataObject::m_CFDataObjectType =
	(CLIPFORMAT)RegisterClipboardFormat(L"FRAMEWRK_DATA_OBJECT_TYPE");
CLIPFORMAT CDataObject::m_CFSnapinPreloads = 
	(CLIPFORMAT)RegisterClipboardFormat(CCF_SNAPIN_PRELOADS);

// m_cfRawCookie must be different for each snapin
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\inc\stdrsrc.h ===
//	StdRsrc.h

#ifndef __STDRSRC_H_INCLUDED__
#define __STDRSRC_H_INCLUDED__

#define IDS_FRAMEWORK_TITLE_ERROR                 98
#define IDS_FRAMEWORK_TITLE_WARNING               99

#endif // ~__STDRSRC_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\inc\stddtobj.h ===
// StdDtObj.h : Declaration of the data object base class

#ifndef __STDDTOBJ_H_INCLUDED__
#define __STDDTOBJ_H_INCLUDED__

class CDataObject : public IDataObject, public CComObjectRoot
{

	BEGIN_COM_MAP(CDataObject)
		COM_INTERFACE_ENTRY(IDataObject)
	END_COM_MAP()

public:

	CDataObject() {}
	virtual ~CDataObject();

    HRESULT STDMETHODCALLTYPE GetData(
		FORMATETC __RPC_FAR * pformatetcIn,
        STGMEDIUM __RPC_FAR * pmedium)
	{
        UNREFERENCED_PARAMETER (pformatetcIn);
        UNREFERENCED_PARAMETER (pmedium);
		return E_NOTIMPL;
	}

    HRESULT STDMETHODCALLTYPE GetDataHere(
        FORMATETC __RPC_FAR * pformatetc,
        STGMEDIUM __RPC_FAR * pmedium)
	{
        UNREFERENCED_PARAMETER (pformatetc);
        UNREFERENCED_PARAMETER (pmedium);
		return E_NOTIMPL;
	}

    HRESULT STDMETHODCALLTYPE QueryGetData(
        FORMATETC __RPC_FAR * pformatetc)
	{
        UNREFERENCED_PARAMETER (pformatetc);
		return E_NOTIMPL;
	}

    HRESULT STDMETHODCALLTYPE GetCanonicalFormatEtc(
        FORMATETC __RPC_FAR * pformatectIn,
        FORMATETC __RPC_FAR * pformatetcOut)
	{
        UNREFERENCED_PARAMETER (pformatectIn);
        UNREFERENCED_PARAMETER (pformatetcOut);
		return E_NOTIMPL;
	}

    HRESULT STDMETHODCALLTYPE SetData(
        FORMATETC __RPC_FAR *pformatetc,
        STGMEDIUM __RPC_FAR *pmedium,
        BOOL fRelease)
	{
        UNREFERENCED_PARAMETER (pformatetc);
        UNREFERENCED_PARAMETER (pmedium);
        UNREFERENCED_PARAMETER (fRelease);
		return E_NOTIMPL;
	}

    HRESULT STDMETHODCALLTYPE EnumFormatEtc(
        DWORD dwDirection,
        IEnumFORMATETC __RPC_FAR *__RPC_FAR * ppenumFormatEtc)
	{
        UNREFERENCED_PARAMETER (dwDirection);
        UNREFERENCED_PARAMETER (ppenumFormatEtc);
		return E_NOTIMPL;
	}

    HRESULT STDMETHODCALLTYPE DAdvise(
        FORMATETC __RPC_FAR * pformatetc,
        DWORD advf,
        IAdviseSink __RPC_FAR * pAdvSink,
        DWORD __RPC_FAR * pdwConnection)
	{
        UNREFERENCED_PARAMETER (pformatetc);
        UNREFERENCED_PARAMETER (advf);
        UNREFERENCED_PARAMETER (pAdvSink);
        UNREFERENCED_PARAMETER (pdwConnection);
		return E_NOTIMPL;
	}

    HRESULT STDMETHODCALLTYPE DUnadvise(
        DWORD dwConnection)
	{
        UNREFERENCED_PARAMETER (dwConnection);
		return E_NOTIMPL;
	}

    HRESULT STDMETHODCALLTYPE EnumDAdvise(
        IEnumSTATDATA __RPC_FAR *__RPC_FAR * ppenumAdvise)
	{
        UNREFERENCED_PARAMETER (ppenumAdvise);
		return E_NOTIMPL;
	}

public:
	// Clipboard formats
	static CLIPFORMAT m_CFNodeType;
	static CLIPFORMAT m_CFNodeTypeString;
	static CLIPFORMAT m_CFSnapInCLSID;
	static CLIPFORMAT m_CFDataObjectType;
	static CLIPFORMAT m_CFRawCookie;
	static CLIPFORMAT m_CFSnapinPreloads;

};

#endif // ~__STDDTOBJ_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\framewrk\inc\stdutils.h ===
//	StdUtils.h

#ifndef __STDUTILS_H_INCLUDED__
#define __STDUTILS_H_INCLUDED__

// returns -1, 0, +1
int CompareMachineNames(LPCTSTR pszMachineName1, LPCTSTR pszMachineName2);
HRESULT HrLoadOleString(UINT uStringId, OUT LPOLESTR * ppaszOleString);
HRESULT HrCopyToOleString(const CString& strT, OUT LPOLESTR * ppaszOleString);

// Nodetype utility routines
int CheckObjectTypeGUID( const GUID* pguid );
int CheckObjectTypeGUID( const BSTR lpszGUID );
int FilemgmtCheckObjectTypeGUID(const GUID* pguid );
const GUID* GetObjectTypeGUID( int objecttype );
const BSTR GetObjectTypeString( int objecttype );

// ISSUE-2002/02/27-JonN this should be LPCWSTR not BSTR
struct NODETYPE_GUID_ARRAYSTRUCT
{
GUID guid;
BSTR bstr;
};

// You must define this struct for the ObjectType utility routines
extern const
struct NODETYPE_GUID_ARRAYSTRUCT* g_aNodetypeGuids;
extern const int g_cNumNodetypeGuids;

/* not working yet
typedef VOID (*SynchronousProcessCompletionRoutine)(PVOID);
HRESULT SynchronousCreateProcess(LPCTSTR cpszCommandLine,
								 SynchronousProcessCompletionRoutine pfunc = NULL,
								 PVOID pvFuncParams = NULL);
*/
HRESULT SynchronousCreateProcess(
    HWND    hWnd,
    LPCTSTR pszAppName,
    LPCTSTR pszCommandLine,
    LPDWORD lpdwExitCode
);
// allocate copy using CoTaskMemAlloc
LPOLESTR CoTaskAllocString( LPCOLESTR psz );
// allocate copy loaded from resource
LPOLESTR CoTaskLoadString( UINT nResourceID );

BOOL
IsLocalComputername( IN LPCTSTR pszMachineName );

#endif // ~__STDUTILS_H_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\about.hpp ===
// Copyright (C) 1997 Microsoft Corporation, 1996 - 1997.
//
// Local Security MMC Snapin About provider
//
// 8-19-97 sburns



#ifndef ABOUT_HPP_INCLUDED
#define ABOUT_HPP_INCLUDED



class SnapinAbout : public ISnapinAbout
{
   // this is the only entity with access to the ctor of this class
   friend class ClassFactory<SnapinAbout>; 
   
   public:

   // IUnknown overrides

   virtual
   ULONG __stdcall
   AddRef();

   virtual
   ULONG __stdcall
   Release();

   virtual 
   HRESULT __stdcall
   QueryInterface(const IID& interfaceID, void** interfaceDesired);

   // ISnapinAbout overrides

   virtual
   HRESULT __stdcall
   GetSnapinDescription(LPOLESTR* description);

   virtual
   HRESULT __stdcall
   GetProvider(LPOLESTR* name);

   virtual
   HRESULT __stdcall
   GetSnapinVersion(LPOLESTR* version);

   virtual
   HRESULT __stdcall
   GetSnapinImage(HICON* icon);

   virtual
   HRESULT __stdcall
   GetStaticFolderImage(
      HBITMAP*    smallImage,	
      HBITMAP*    smallImageOpen,	
      HBITMAP*    largeImage,	
      COLORREF*   cMask);	

   private:

   // only the friend class factory can instantiate us
   SnapinAbout();

   // only Release can cause us to be deleted

   virtual
   ~SnapinAbout();

   // not implemented; no instance copying allowed.
   SnapinAbout(const SnapinAbout&);
   const SnapinAbout& operator=(const SnapinAbout&);

   HBITMAP              smallImage;
   HBITMAP              smallImageOpen;
   HBITMAP              largeImage;

   ComServerReference   dllref;
   long                 refcount;
};



#endif   // ABOUT_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\snapin\localsec\src\about.cpp ===
// Copyright (C) 1997 Microsoft Corporation, 1996 - 1997.
//
// Local Security MMC Snapin About provider
//
// 8-19-97 sburns



#include "headers.hxx"
#include "about.hpp"
#include "resource.h"



SnapinAbout::SnapinAbout()
   :
   refcount(1),    // implicit AddRef
   smallImage(0),
   smallImageOpen(0),
   largeImage(0)
{
   LOG_CTOR(SnapinAbout);

   // These are deleted in the dtor.
   
   HRESULT hr = Win::LoadBitmap(IDB_STATIC_FOLDER_SMALL, smallImage);
   ASSERT(SUCCEEDED(hr));

   hr = Win::LoadBitmap(IDB_STATIC_FOLDER_SMALL_OPEN, smallImageOpen);
   ASSERT(SUCCEEDED(hr));

   hr = Win::LoadBitmap(IDB_STATIC_FOLDER_LARGE, largeImage);
   ASSERT(SUCCEEDED(hr));
}



SnapinAbout::~SnapinAbout()
{
   LOG_DTOR(SnapinAbout);   