&LogonId,
                                    &Token );

    if ( NT_SUCCESS( Status ) )
    {
        *phLocator = (HLOCATOR) Token ;
    }
    else
    {
        LogCertMappingFailureEvent(Status);
    }

    LsaTable->FreeReturnBuffer( Response );

    MIDL_user_free(Pac);

    return ( Status );
}


DWORD
WINAPI
SslLocalCloseLocator(
    IN PHMAPPER Mapper,
    IN HLOCATOR Locator
    )
{
    UNREFERENCED_PARAMETER(Mapper);

    DebugLog(( DEB_TRACE_MAPPER, "SslLocalCloseLocator (%p)\n", Locator ));

    NtClose( (HANDLE) Locator );

    return( SEC_E_OK );
}

DWORD
WINAPI
SslLocalGetAccessToken(
    IN PHMAPPER Mapper,
    IN HLOCATOR Locator,
    OUT HANDLE *Token
    )
{
    UNREFERENCED_PARAMETER(Mapper);

    DebugLog(( DEB_TRACE_MAPPER, "SslLocalGetAccessToken (%p)\n", Locator  ));

    *Token = (HANDLE) Locator ;

    return( SEC_E_OK );
}


BOOL
SslRelocateToken(
    IN HLOCATOR Locator,
    OUT HLOCATOR * NewLocator)
{
    NTSTATUS Status ;

    Status = LsaTable->DuplicateHandle( (HANDLE) Locator,
                                        (PHANDLE) NewLocator );

    if ( NT_SUCCESS( Status ) )
    {
        return( TRUE );
    }

    return( FALSE );
}

#if 0
DWORD
TestExternalMapper(
    PCCERT_CONTEXT pCertContext)
{
    NTSTATUS Status;
    NTSTATUS AuthPackageStatus;
    SSL_EXTERNAL_CERT_LOGON_REQ Request;
    PSSL_EXTERNAL_CERT_LOGON_RESP pResponse;
    ULONG ResponseLength;
    UNICODE_STRING PackageName;

    //
    // Build request.
    //

    memset(&Request, 0, sizeof(SSL_EXTERNAL_CERT_LOGON_REQ));

    Request.MessageType = SSL_LOOKUP_EXTERNAL_CERT_MESSAGE;
    Request.Length = sizeof(SSL_EXTERNAL_CERT_LOGON_REQ);
    Request.CredentialType = X509_ASN_CHAIN;
    Request.Credential = (PVOID)pCertContext;


    //
    // Call security package (must make call as local system).
    //

    RtlInitUnicodeString(&PackageName, L"Schannel");

    Status = LsaICallPackage(
                                &PackageName,
                                &Request,
                                Request.Length,
                                (PVOID *)&pResponse,
                                &ResponseLength,
                                &AuthPackageStatus
                                );

    if(!NT_SUCCESS(Status))
    {
        return Status;
    }

    if(NT_SUCCESS(AuthPackageStatus))
    {
        //
        // Mapping was successful.
        //




    }

    LsaIFreeReturnBuffer( pResponse );

    return ERROR_SUCCESS;
}
#endif


//+-------------------------------------------------------------------------
//
//  Function:   SslDomainChangeCallback
//
//  Synopsis:   Function to be called when domain changes
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID NTAPI
SslDomainChangeCallback(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    )
{
    NTSTATUS Status;
    PLSAPR_POLICY_INFORMATION Policy = NULL;
    BOOL AcquiredLock = FALSE;
    UNICODE_STRING TempDnsDomainName = {0};

    //
    // We only care about domain dns information
    //

    if (ChangedInfoClass != PolicyNotifyDnsDomainInformation)
    {
        return;
    }

    DebugLog((DEB_TRACE,"SSL domain change callback\n"));
//    OutputDebugStringA("SSL domain change callback\n");


    //
    // Get the new domain information
    //

    Status = I_LsaIQueryInformationPolicyTrusted(
                PolicyDnsDomainInformation,
                &Policy
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to query domain dns information %x - not updating.\n", Status));
        goto Cleanup;
    }


    //
    // Copy the domain name
    //

    Status = SslDuplicateString(
                &TempDnsDomainName,
                (PUNICODE_STRING) &Policy->PolicyDnsDomainInfo.DnsDomainName
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Acquire the global lock so we can update the data
    //

    if (!SslGlobalWriteLock())
    {
        DebugLog((DEB_ERROR,"Failed to acquire global resource. Not changing domain.\n"));
        goto Cleanup;
    }
    AcquiredLock = TRUE;


    //
    // Copy all the data to the global structures
    //

    SslFreeString(&SslGlobalDnsDomainName);
    SslGlobalDnsDomainName = TempDnsDomainName;
    TempDnsDomainName.Buffer = NULL;

    DebugLog((DEB_TRACE,"SSL DNS Domain Name changed to:%ls\n", SslGlobalDnsDomainName.Buffer));
    
//    OutputDebugStringA("SSL DNS Domain Name changed to:");
//    OutputDebugStringW(SslGlobalDnsDomainName.Buffer);
//    OutputDebugStringA("\n");

Cleanup:

    if (AcquiredLock)
    {
        SslGlobalReleaseLock();
    }

    if (Policy != NULL)
    {
        I_LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyDnsDomainInformation,
            Policy
            );
    }

    SslFreeString(&TempDnsDomainName);
}


//+-------------------------------------------------------------------------
//
//  Function:   SslRegisterForDomainChange
//
//  Synopsis:   Register with the LSA to be notified of domain changes
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
SslRegisterForDomainChange(
    VOID
    )
{
    NTSTATUS Status;

    Status = I_LsaIRegisterPolicyChangeNotificationCallback(
                SslDomainChangeCallback,
                PolicyNotifyDnsDomainInformation
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to register for domain change notification: 0x%x.\n",Status));
    }
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SslUnregisterForDomainChange
//
//  Synopsis:   Unregister for domain change notification
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
SslUnregisterForDomainChange(
    VOID
    )
{
    (VOID) I_LsaIUnregisterPolicyChangeNotificationCallback(
                SslDomainChangeCallback,
                PolicyNotifyDnsDomainInformation
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\events.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1999
//
// File:        events.c
//
// Contents:    Schannel event log functions.
//
// Functions:   SchInitializeEvents
//              SchReportEvent
//              SchShutdownEvents
//
// History:     03-05-99   jbanes    Created
//
//------------------------------------------------------------------------
#include "sslp.h"
#include <lsapmsgs.h>
#include <netlib.h>

HANDLE g_hEventLog = NULL;
HANDLE g_hDiscardDupEventLog = NULL;

WCHAR   EventSourceName[] = TEXT("Schannel");

#define MAX_EVENT_STRINGS       8

#define SCH_MESSAGE_FILENAME    TEXT("%SystemRoot%\\system32\\lsasrv.dll")

LPWSTR pszClientString = NULL;
LPWSTR pszServerString = NULL;

NTSTATUS
SchGetMessageString(
    LPVOID   Resource,
    DWORD    Index,
    LPWSTR * pRetString);


//+---------------------------------------------------------------------------
//
//  Function:   SchInitializeEvents
//
//  Synopsis:   Connects to event log service.
//
//  Arguments:  (none)
//
//  History:    03-05-99   jbanes    Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SchInitializeEvents(void)
{
    HKEY     hKey;
    int      err;
    DWORD    disp;
    HMODULE  hResource;

    //
    // Create registry entries, whether event logging is currently
    // enabled or not.
    //

    err = RegCreateKeyEx(   HKEY_LOCAL_MACHINE,
                            TEXT("System\\CurrentControlSet\\Services\\EventLog\\System\\Schannel"),
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_WRITE,
                            NULL,
                            &hKey,
                            &disp);
    if(err)
    {
        return(FALSE);
    }

    if (disp == REG_CREATED_NEW_KEY)
    {
        RegSetValueEx(  hKey,
                        TEXT("EventMessageFile"),
                        0,
                        REG_EXPAND_SZ,
                        (PBYTE)SCH_MESSAGE_FILENAME,
                        sizeof(SCH_MESSAGE_FILENAME) );

//        RegSetValueEx(  hKey,
//                        TEXT("CategoryMessageFile"),
//                        0,
//                        REG_EXPAND_SZ,
//                        (PBYTE)SCH_MESSAGE_FILENAME,
//                        sizeof(SCH_MESSAGE_FILENAME) );

        disp = 7;
        RegSetValueEx(  hKey,
                        TEXT("TypesSupported"),
                        0,
                        REG_DWORD,
                        (PBYTE) &disp,
                        sizeof(DWORD) );

//        disp = CATEGORY_MAX_CATEGORY - 1;
//        RegSetValueEx(  hKey,
//                        TEXT("CategoryCount"),
//                        0,
//                        REG_DWORD,
//                        (PBYTE) &disp,
//                        sizeof(DWORD) );

        RegFlushKey(hKey);
    }

    RegCloseKey(hKey);


    //
    // Read the event text strings from the resource file.
    //

    hResource = (HMODULE)LoadLibrary(TEXT("lsasrv.dll"));
    if(hResource == NULL) 
    {
        return(FALSE);
    }

    SchGetMessageString(hResource,
                        SSLEVENTTEXT_CLIENT,
                        &pszClientString);

    SchGetMessageString(hResource,
                        SSLEVENTTEXT_SERVER,
                        &pszServerString);

    FreeLibrary(hResource);

    return(TRUE);
}


//+---------------------------------------------------------------------------
//
//  Function:   SchReportEvent
//
//  Synopsis:   Reports an event to the event log
//
//  Arguments:  [EventType]       -- EventType (ERROR, WARNING, etc.)
//              [EventId]         -- Event ID
//              [SizeOfRawData]   -- Size of raw data
//              [RawData]         -- Raw data
//              [NumberOfStrings] -- number of strings
//              ...               -- PWSTRs to string data
//
//  History:    03-05-99   jbanes    Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
SchReportEvent(
    IN DWORD LogLevel,
    IN DWORD EventType,
    IN DWORD EventId,
    IN DWORD Category,
    IN DWORD SizeOfRawData,
    IN PVOID RawData,
    IN DWORD NumberOfStrings,
    ...
    )
{
    va_list arglist;
    ULONG i;
    PWSTR Strings[ MAX_EVENT_STRINGS ];
    DWORD Status;
    BOOL fDiscardDuplicates = TRUE;
    BOOL fSuccess;


    //
    // Is this event supposed to be logged?
    //

    if ((g_dwEventLogging & LogLevel) == 0)
    {
        return ERROR_SUCCESS;
    }

    
    //
    // Open the event log if necessary. 
    //

    if(g_dwEventLogging == DEFAULT_EVENT_LOGGING_SETTING)
    {
        // Only log identical event once per day.
        if(g_hDiscardDupEventLog == NULL)
        {
            g_hDiscardDupEventLog = NetpEventlogOpen(EventSourceName, 60000*60*24);
            if(g_hDiscardDupEventLog == NULL)
            {
                Status = GetLastError();
                DebugLog((DEB_ERROR, "Could not open duplicate discard event log, error %d\n", Status));
                return Status;
            }
        }
    }
    else
    {
        // Log all events.
        if(g_hEventLog == NULL)
        {
            g_hEventLog = RegisterEventSource(NULL, EventSourceName);
            if(g_hEventLog == NULL)
            {
                Status = GetLastError();
                DebugLog((DEB_ERROR, "Could not open duplicate discard event log, error %d\n", Status));
                return Status;
            }
        }

        fDiscardDuplicates = FALSE;
    }

    
    //
    // Look at the strings, if they were provided
    //
    va_start( arglist, NumberOfStrings );

    if (NumberOfStrings > MAX_EVENT_STRINGS) {
        NumberOfStrings = MAX_EVENT_STRINGS;
    }

    for (i=0; i<NumberOfStrings; i++) 
    {
        Strings[ i ] = va_arg( arglist, PWSTR );
    }


    //
    // Report the event to the eventlog service
    //

    if(fDiscardDuplicates)
    {
        fSuccess = NetpEventlogWriteEx(   
                        g_hDiscardDupEventLog,
                        (WORD) EventType,
                        (WORD) Category,
                        EventId,
                        (WORD)NumberOfStrings,
                        SizeOfRawData,
                        Strings,
                        RawData);
    }
    else
    {
        fSuccess = ReportEvent(   
                        g_hEventLog,
                        (WORD) EventType,
                        (WORD) Category,
                        EventId,
                        NULL,
                        (WORD)NumberOfStrings,
                        SizeOfRawData,
                        Strings,
                        RawData);
    }

    if(!fSuccess)
    {
        Status = GetLastError();
        DebugLog((DEB_ERROR,  "ReportEvent( %u ) failed - %u\n", EventId, Status));
    }
    else
    {
        Status = ERROR_SUCCESS;
    }

    return Status;
}

void
SchShutdownEvents(void)
{
    if(g_hDiscardDupEventLog != NULL)
    {
        NetpEventlogClose(g_hDiscardDupEventLog);
        g_hDiscardDupEventLog = NULL;
    }
    if(g_hEventLog != NULL)
    {
        DeregisterEventSource(g_hEventLog);
        g_hEventLog = NULL;
    }

    if(pszClientString)
    {
        LocalFree(pszClientString);
        pszClientString = NULL;
    }
    if(pszServerString)
    {
        LocalFree(pszServerString);
        pszServerString = NULL;
    }
}


void
LogSchannelStartedEvent(void)
{    
    SchReportEvent( DEB_TRACE,
                    EVENTLOG_INFORMATION_TYPE,
                    SSLEVENT_SCHANNEL_STARTED,
                    0,
                    0,
                    NULL,
                    0,
                    NULL );
}

void
LogGlobalAcquireContextFailedEvent(
    LPWSTR pwszName,
    DWORD Status)
{
    WCHAR wszStatus[20];

    _ltow(Status, wszStatus, 16);

    SchReportEvent( DEB_ERROR,
                    EVENTLOG_ERROR_TYPE,
                    SSLEVENT_GLOBAL_ACQUIRE_CONTEXT_FAILED,
                    0,
                    0,
                    NULL,
                    2,
                    pwszName,
                    wszStatus);
}

void
LogCreateCredEvent(
    DWORD dwProtocol, 
    PLSA_SCHANNEL_CRED pSchannelCred)
{
    SchReportEvent(DEB_TRACE,
                   EVENTLOG_INFORMATION_TYPE,
                   SSLEVENT_CREATE_CRED,
                   0,
                   sizeof(SCHANNEL_CRED),
                   pSchannelCred,
                   1,
                   (dwProtocol & SP_PROT_SERVERS) ? pszServerString : pszClientString);
}

void
LogCredPropertiesEvent(
    DWORD dwProtocol,
    PCRYPT_KEY_PROV_INFO pProvInfo,
    PCCERT_CONTEXT pCertContext)
{
    WCHAR wszType[20];
    WCHAR wszFlags[20];
    LPWSTR pwszKeySpec;

    if(!(g_dwEventLogging & DEB_TRACE))
    {
        return;
    }

    _ltow(pProvInfo->dwProvType, wszType,    10);
    _ltow(pProvInfo->dwFlags,    wszFlags,   16);

    switch(pProvInfo->dwKeySpec)
    {
    case AT_KEYEXCHANGE:
        pwszKeySpec = L"key exchange";
        break;
    case AT_SIGNATURE:
        pwszKeySpec = L"signature";
        break;
    default:
        pwszKeySpec = L"unknown";
    }

    SchReportEvent( DEB_TRACE,
                    EVENTLOG_INFORMATION_TYPE,
                    SSLEVENT_CRED_PROPERTIES,
                    0,
                    pCertContext->cbCertEncoded,
                    pCertContext->pbCertEncoded,
                    6,
                    (dwProtocol & SP_PROT_SERVERS) ? pszServerString : pszClientString,
                    pProvInfo->pwszProvName,
                    wszType,
                    pProvInfo->pwszContainerName,
                    pwszKeySpec,
                    wszFlags);
}

void
LogNoPrivateKeyEvent(
    DWORD dwProtocol)
{
    SchReportEvent( DEB_ERROR,
                    EVENTLOG_ERROR_TYPE,
                    SSLEVENT_NO_PRIVATE_KEY,
                    0,
                    0,
                    NULL,
                    1,
                    (dwProtocol & SP_PROT_SERVERS) ? pszServerString : pszClientString);
}

void
LogCredAcquireContextFailedEvent(
    DWORD dwProtocol, 
    DWORD Status)
{
    WCHAR wszStatus[20];

    _ltow(Status, wszStatus, 16);

    SchReportEvent( DEB_ERROR,
                    EVENTLOG_ERROR_TYPE,
                    SSLEVENT_CRED_ACQUIRE_CONTEXT_FAILED,
                    0,
                    0,
                    NULL,
                    2,
                    (dwProtocol & SP_PROT_SERVERS) ? pszServerString : pszClientString,
                    wszStatus);
}

void
LogCreateCredFailedEvent(
    DWORD dwProtocol)
{
    SchReportEvent(DEB_ERROR,
                   EVENTLOG_ERROR_TYPE,
                   SSLEVENT_CREATE_CRED_FAILED,
                   0,
                   0,
                   NULL,
                   1,
                   (dwProtocol & SP_PROT_SERVERS) ? pszServerString : pszClientString);
}

void
LogNoDefaultServerCredEvent(void)
{
    SchReportEvent(DEB_ERROR,
                   EVENTLOG_WARNING_TYPE,
                   SSLEVENT_NO_DEFAULT_SERVER_CRED,
                   0,
                   0,
                   NULL,
                   0,
                   NULL);
}

           
void
LogNoCiphersSupportedEvent(void)
{
    SchReportEvent(DEB_ERROR,
                   EVENTLOG_ERROR_TYPE,
                   SSLEVENT_NO_CIPHERS_SUPPORTED,
                   0,
                   0,
                   NULL,
                   0,
                   NULL);
}

void
LogCipherMismatchEvent(void)
{
    SchReportEvent(DEB_ERROR,
                   EVENTLOG_ERROR_TYPE,
                   SSLEVENT_CIPHER_MISMATCH,
                   0,
                   0,
                   NULL,
                   0,
                   NULL);
}

void
LogNoClientCertFoundEvent(void)
{
    SchReportEvent(DEB_WARN,
                   EVENTLOG_WARNING_TYPE,
                   SSLEVENT_NO_CLIENT_CERT_FOUND,
                   0,
                   0,
                   NULL,
                   0,
                   NULL);
}

void
LogBogusServerCertEvent(
    PCCERT_CONTEXT pCertContext,
    LPWSTR pwszServerName,
    DWORD Status)
{
    WCHAR wszStatus[20];

    if(!(g_dwEventLogging & DEB_ERROR))
    {
        return;
    }

    switch(Status)
    {
    case SEC_E_CERT_EXPIRED:
        SchReportEvent( DEB_ERROR,
                        EVENTLOG_ERROR_TYPE,
                        SSLEVENT_EXPIRED_SERVER_CERT,
                        0,
                        pCertContext->cbCertEncoded,
                        pCertContext->pbCertEncoded,
                        0,
                        NULL);
        break;

    case SEC_E_UNTRUSTED_ROOT:
        SchReportEvent( DEB_ERROR,
                        EVENTLOG_ERROR_TYPE,
                        SSLEVENT_UNTRUSTED_SERVER_CERT,
                        0,
                        pCertContext->cbCertEncoded,
                        pCertContext->pbCertEncoded,
                        0,
                        NULL);
        break;

    case CRYPT_E_REVOKED:
        SchReportEvent( DEB_ERROR,
                        EVENTLOG_ERROR_TYPE,
                        SSLEVENT_REVOKED_SERVER_CERT,
                        0,
                        pCertContext->cbCertEncoded,
                        pCertContext->pbCertEncoded,
                        0,
                        NULL);
        break;

    case SEC_E_WRONG_PRINCIPAL:
        SchReportEvent( DEB_ERROR,
                        EVENTLOG_ERROR_TYPE,
                        SSLEVENT_NAME_MISMATCHED_SERVER_CERT,
                        0,
                        pCertContext->cbCertEncoded,
                        pCertContext->pbCertEncoded,
                        1,
                        pwszServerName);
        break;
       
    default:
        _ltow(Status, wszStatus, 16);

        SchReportEvent( DEB_ERROR,
                        EVENTLOG_ERROR_TYPE,
                        SSLEVENT_BOGUS_SERVER_CERT,
                        0,
                        pCertContext->cbCertEncoded,
                        pCertContext->pbCertEncoded,
                        1,
                        wszStatus);
    }
}

void
LogBogusClientCertEvent(
    PCCERT_CONTEXT pCertContext,
    DWORD Status)
{
    WCHAR wszStatus[20];

    if(!(g_dwEventLogging & DEB_WARN))
    {
        return;
    }

    _ltow(Status, wszStatus, 16);

    SchReportEvent( DEB_WARN,
                    EVENTLOG_WARNING_TYPE,
                    SSLEVENT_BOGUS_CLIENT_CERT,
                    0,
                    pCertContext->cbCertEncoded,
                    pCertContext->pbCertEncoded,
                    1,
                    wszStatus);
}

void
LogFastMappingFailureEvent(
    PCCERT_CONTEXT pCertContext,
    DWORD Status)
{
    WCHAR wszStatus[20];

    if(!(g_dwEventLogging & DEB_WARN))
    {
        return;
    }

    _ltow(Status, wszStatus, 16);

    SchReportEvent( DEB_WARN,
                    EVENTLOG_WARNING_TYPE,
                    SSLEVENT_FAST_MAPPING_FAILURE,
                    0,
                    pCertContext->cbCertEncoded,
                    pCertContext->pbCertEncoded,
                    1,
                    wszStatus);
}

void
LogCertMappingFailureEvent(
    DWORD Status)
{
    WCHAR wszStatus[20];

    if(!(g_dwEventLogging & DEB_WARN))
    {
        return;
    }

    _ltow(Status, wszStatus, 16);

    SchReportEvent( DEB_WARN,
                    EVENTLOG_WARNING_TYPE,
                    SSLEVENT_CERT_MAPPING_FAILURE,
                    0,
                    0,
                    NULL,
                    1,
                    wszStatus);
}

void
LogHandshakeInfoEvent(
    DWORD dwProtocol,
    PCipherInfo pCipherInfo,
    PHashInfo pHashInfo,
    PKeyExchangeInfo pExchangeInfo,
    DWORD dwExchangeStrength)
{
    WCHAR wszCipherStrength[20];
    WCHAR wszExchangeStrength[20];
    LPWSTR pwszProtocol;
    LPWSTR pwszCipher;
    LPWSTR pwszHash;
    LPWSTR pwszExchange;

    if(!(g_dwEventLogging & DEB_TRACE))
    {
        return;
    }

    switch(dwProtocol)
    {
    case SP_PROT_PCT1_SERVER:
    case SP_PROT_PCT1_CLIENT:
        pwszProtocol = L"PCT";
        break;
    case SP_PROT_SSL2_SERVER:
    case SP_PROT_SSL2_CLIENT:
        pwszProtocol = L"SSL 2.0";
        break;
    case SP_PROT_SSL3_SERVER:
    case SP_PROT_SSL3_CLIENT:
        pwszProtocol = L"SSL 3.0";
        break;
    case SP_PROT_TLS1_SERVER:
    case SP_PROT_TLS1_CLIENT:
        pwszProtocol = L"TLS (SSL 3.1)";
        break;
    default:
        pwszProtocol = L"unknown";
    }

    switch(pCipherInfo->aiCipher)
    {
    case CALG_RC4:
        pwszCipher = L"RC4";
        break;
    case CALG_3DES:
        pwszCipher = L"Triple-DES";
        break;
    case CALG_RC2:
        pwszCipher = L"RC2";
        break;
    case CALG_DES:
        pwszCipher = L"DES";
        break;
    case CALG_SKIPJACK:
        pwszCipher = L"Skipjack";
        break;
    default:
        pwszCipher = L"unknown";
    }

    _ltow(pCipherInfo->dwStrength, wszCipherStrength, 10);

    switch(pHashInfo->aiHash)
    {
    case CALG_MD5:
        pwszHash = L"MD5";
        break;
    case CALG_SHA:
        pwszHash = L"SHA";
        break;
    default:
        pwszHash = L"unknown";
    }

    switch(pExchangeInfo->aiExch)
    {
    case CALG_RSA_SIGN:
    case CALG_RSA_KEYX:
        pwszExchange = L"RSA";
        break;
    case CALG_KEA_KEYX:
        pwszExchange = L"KEA";
        break;
    case CALG_DH_EPHEM:
        pwszExchange = L"Ephemeral DH";
        break;
    default:
        pwszExchange = L"unknown";
    }

    _ltow(dwExchangeStrength, wszExchangeStrength, 10);

    SchReportEvent( DEB_TRACE,
                    EVENTLOG_INFORMATION_TYPE,
                    SSLEVENT_HANDSHAKE_INFO,
                    0,
                    0,
                    NULL,
                    7,
                    (dwProtocol & SP_PROT_SERVERS) ? pszServerString : pszClientString,
                    pwszProtocol,
                    pwszCipher,
                    wszCipherStrength,
                    pwszHash,
                    pwszExchange,
                    wszExchangeStrength);
}

void
LogIssuerOverflowEvent(void)
{
    SchReportEvent( DEB_ERROR,
                    EVENTLOG_WARNING_TYPE,
                    SSLEVENT_ISSUER_LIST_OVERFLOW_FAILURE,
                    0,
                    0,
                    NULL,
                    0,
                    NULL);
}

NTSTATUS
SchGetMessageString(
    LPVOID   Resource,
    DWORD    Index,
    LPWSTR * pRetString)
{
    DWORD Length;

    *pRetString = NULL;

    Length = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                           FORMAT_MESSAGE_ALLOCATE_BUFFER,
                           Resource,
                           Index,
                           0,                 // Use caller's language
                           (LPWSTR)pRetString,
                           0,
                           NULL);

    if(Length == 0 || *pRetString == NULL)
    {
        return(STATUS_RESOURCE_DATA_NOT_FOUND);
    }

    //
    // Note that we are retrieving a message from a message file.
    // This message will have a cr/lf tacked on the end of it
    // (0x0d 0x0a) that we don't want to be part of our returned
    // strings.  However, we do need to null terminate our string
    // so we will convert the 0x0d into a null terminator.
    //
    // Also note that FormatMessage() returns a character count,
    // not a byte count.  So, we have to do some adjusting to make
    // the string lengths correct.
    //

    ASSERT(Length >= 2);    // We always expect cr/lf on our strings

    //
    // Adjust character count
    //

    Length -=  1; // For the lf - we'll convert the cr.

    //
    // Set null terminator
    //

    (*pRetString)[Length - 1] = 0;

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\package.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       package.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-02-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "sslp.h"
#include <ntmsv1_0.h>
#include <wow64t.h>

#define UNISP_NAME_WO     L"Microsoft Unified Security Protocol Provider"
#define SSL2SP_NAME_WO    L"Microsoft SSL"
#define SSL3SP_NAME_WO    L"Microsoft SSL 3.0"
#define PCT1SP_NAME_WO    L"Microsoft PCT"

#define SCHANNEL_PACKAGE_NAME           L"Schannel"
#define SCHANNEL_PACKAGE_NAME_A          "Schannel"
#define SCHANNEL_PACKAGE_COMMENT        L"Schannel Security Package"
#define SCHANNEL_DLL_NAME               L"schannel.dll"

DWORD dwSchannelPackageCapabilities =   SECPKG_FLAG_INTEGRITY           |
                                        SECPKG_FLAG_PRIVACY             |
                                        SECPKG_FLAG_CONNECTION          |
                                        SECPKG_FLAG_MULTI_REQUIRED      |
                                        SECPKG_FLAG_EXTENDED_ERROR      |
                                        SECPKG_FLAG_IMPERSONATION       |
                                        SECPKG_FLAG_ACCEPT_WIN32_NAME   |
                                        // SECPKG_FLAG_NEGOTIABLE          |
                                        SECPKG_FLAG_MUTUAL_AUTH         |
                                        SECPKG_FLAG_STREAM;

// List of (QueryContextAttributes) attributes that are to be
// thunked down to the LSA process.
ULONG ThunkedContextLevels[] = {
        SECPKG_ATTR_AUTHORITY,
        SECPKG_ATTR_ISSUER_LIST,
        SECPKG_ATTR_ISSUER_LIST_EX,
        SECPKG_ATTR_LOCAL_CERT_CONTEXT,
        SECPKG_ATTR_LOCAL_CRED,
        SECPKG_ATTR_EAP_KEY_BLOCK,
        SECPKG_ATTR_USE_VALIDATED,
        SECPKG_ATTR_CREDENTIAL_NAME,
        SECPKG_ATTR_TARGET_INFORMATION,
        SECPKG_ATTR_APP_DATA
};


//
// This package exports the following:  A unified ssl/tls/pct provider, 
// and the same unified provider under a different name. We have to
// keep the original one for backward compatibility, but whistler
// components can start using the new friendlier name.
//

SECPKG_FUNCTION_TABLE   SpTable[] = {
        {                                       // The Schannel Provider
            NULL,
            NULL,
            SpCallPackage,
            SpLogonTerminated,
            SpCallPackageUntrusted,
            SpCallPackagePassthrough,
            NULL,
            NULL,
            SpInitialize,
            SpShutdown,
            SpSslGetInfo,
            SpAcceptCredentials,
            SpUniAcquireCredentialsHandle,
            SpQueryCredentialsAttributes,
            SpFreeCredentialsHandle,
            SpSaveCredentials,
            SpGetCredentials,
            SpDeleteCredentials,
            SpInitLsaModeContext,
            SpAcceptLsaModeContext,
            SpDeleteContext,
            SpApplyControlToken,
            SpGetUserInfo,
            SpGetExtendedInformation,
            SpLsaQueryContextAttributes,
            NULL,
            NULL,
            SpSetContextAttributes
        },
        {                                       // The Unified Provider
            NULL,
            NULL,
            SpCallPackage,
            SpLogonTerminated,
            SpCallPackageUntrusted,
            SpCallPackagePassthrough,
            NULL,
            NULL,
            SpInitialize,
            SpShutdown,
            SpUniGetInfo,
            SpAcceptCredentials,
            SpUniAcquireCredentialsHandle,
            SpQueryCredentialsAttributes,
            SpFreeCredentialsHandle,
            SpSaveCredentials,
            SpGetCredentials,
            SpDeleteCredentials,
            SpInitLsaModeContext,
            SpAcceptLsaModeContext,
            SpDeleteContext,
            SpApplyControlToken,
            SpGetUserInfo,
            SpGetExtendedInformation,
            SpLsaQueryContextAttributes,
            NULL,
            NULL,
            SpSetContextAttributes
        }
    };


ULONG_PTR SpPackageId;
PLSA_SECPKG_FUNCTION_TABLE LsaTable ;
BOOL    SpInitialized = FALSE ;
HINSTANCE hDllInstance ;
BOOL ReplaceBaseProvider = TRUE;
TOKEN_SOURCE SslTokenSource ;
SECURITY_STRING SslNamePrefix = { 8, 10, L"X509" };
SECURITY_STRING SslDomainName ;
SECURITY_STRING SslGlobalDnsDomainName ;
SECURITY_STRING SslPackageName ;
SECURITY_STRING SslLegacyPackageName ;

LSA_STRING SslPackageNameA ;

RTL_RESOURCE SslGlobalLock;


//+---------------------------------------------------------------------------
//
//  Function:   SpLsaModeInitialize
//
//  Synopsis:   LSA Mode Initialization Function
//
//  Arguments:  [LsaVersion]     --
//                              [PackageVersion] --
//                              [Table]                  --
//                              [TableCount]     --
//
//  History:    10-03-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SpLsaModeInitialize(
    IN ULONG LsaVersion,
    OUT PULONG PackageVersion,
    OUT PSECPKG_FUNCTION_TABLE * Table,
    OUT PULONG TableCount)
{
    UNREFERENCED_PARAMETER(LsaVersion);

    *PackageVersion = SECPKG_INTERFACE_VERSION_2;
    *Table = SpTable ;
    *TableCount = sizeof( SpTable ) / sizeof( SECPKG_FUNCTION_TABLE );

    return( SEC_E_OK );
}


//+---------------------------------------------------------------------------
//
//  Function:   SpInitialize
//
//  Synopsis:   Package Initialization Function
//
//  Arguments:  [dwPackageID] --
//              [pParameters] --
//              [Table]           --
//
//  History:    10-03-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SpInitialize(
                ULONG_PTR           dwPackageID,
                PSECPKG_PARAMETERS  pParameters,
                PLSA_SECPKG_FUNCTION_TABLE  Table)
{
    if ( !SpInitialized )
    {
        SpPackageId = dwPackageID ;
        LsaTable = Table ;

        CopyMemory( SslTokenSource.SourceName, SCHANNEL_PACKAGE_NAME_A, 8 );
        AllocateLocallyUniqueId( &SslTokenSource.SourceIdentifier );

        SslDuplicateString( &SslDomainName, &pParameters->DomainName );

        SslDuplicateString( &SslGlobalDnsDomainName, &pParameters->DnsDomainName );

        RtlInitUnicodeString( &SslPackageName, SCHANNEL_PACKAGE_NAME );
        RtlInitUnicodeString( &SslLegacyPackageName, UNISP_NAME_W );

        RtlInitString( &SslPackageNameA, SCHANNEL_PACKAGE_NAME_A );

        __try {
            RtlInitializeResource(&SslGlobalLock);
        } __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        // Register for domain change notifications
        SslRegisterForDomainChange();

        SpInitialized = TRUE;
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   SpUniGetInfo
//
//  Synopsis:   Get Package Information
//
//  Arguments:  [pInfo] --
//
//  History:    10-03-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SpUniGetInfo(
    PSecPkgInfo pInfo
    )
{
    pInfo->wVersion         = 1;
    pInfo->wRPCID           = UNISP_RPC_ID;
    pInfo->fCapabilities    = dwSchannelPackageCapabilities;
    pInfo->cbMaxToken       = 0x4000;
    pInfo->Name             = ReplaceBaseProvider ? UNISP_NAME_WO : UNISP_NAME_W ;
    pInfo->Comment          = UNISP_NAME_W ;

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   SpSslGetInfo
//
//  Synopsis:   Get Package Information
//
//  Arguments:  [pInfo] --
//
//  History:    10-03-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SpSslGetInfo(
    PSecPkgInfo pInfo
    )
{
    pInfo->wVersion         = 1;
    pInfo->wRPCID           = UNISP_RPC_ID;
    pInfo->fCapabilities    = dwSchannelPackageCapabilities;
    pInfo->cbMaxToken       = 0x4000;
    pInfo->Name             = SCHANNEL_PACKAGE_NAME;
    pInfo->Comment          = SCHANNEL_PACKAGE_COMMENT;

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   SslDuplicateString
//
//  Synopsis:   Duplicate a unicode string
//
//  Arguments:  [Dest]   --
//              [Source] --
//
//  History:    10-18-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
SslDuplicateString(
    PUNICODE_STRING Dest,
    PUNICODE_STRING Source
    )
{
    Dest->Buffer = (PWSTR) SPExternalAlloc(  Source->Length + sizeof(WCHAR) );
    if ( Dest->Buffer )
    {
        Dest->Length = Source->Length ;
        Dest->MaximumLength = Source->Length + sizeof(WCHAR) ;
        CopyMemory( Dest->Buffer, Source->Buffer, Source->Length );
        Dest->Buffer[ Dest->Length / 2 ] = L'\0';

        return( STATUS_SUCCESS );
    }

    return( STATUS_NO_MEMORY );
}


//+-------------------------------------------------------------------------
//
//  Function:   SslFreeString
//
//  Synopsis:   Frees a string allocated by KerbDuplicateString
//
//  Effects:
//
//  Arguments:  String - Optionally points to a UNICODE_STRING
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
SslFreeString(
    IN OPTIONAL PUNICODE_STRING String
    )
{
    if (ARGUMENT_PRESENT(String) && String->Buffer != NULL)
    {
        SPExternalFree(String->Buffer);
        ZeroMemory(String, sizeof(UNICODE_STRING));
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   SpGetExtendedInformation
//
//  Synopsis:   Return extended information to the LSA
//
//  Arguments:  [Class] -- Information Class
//              [pInfo] -- Returned Information Pointer
//
//  History:    3-24-97   ramas   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SpGetExtendedInformation(
    SECPKG_EXTENDED_INFORMATION_CLASS   Class,
    PSECPKG_EXTENDED_INFORMATION *      pInfo
    )
{
    PSECPKG_EXTENDED_INFORMATION    Info ;
    PWSTR pszPath;
    SECURITY_STATUS Status ;
    ULONG Size ;

    switch ( Class )
    {
        case SecpkgContextThunks:
            Info = (PSECPKG_EXTENDED_INFORMATION) LsaTable->AllocateLsaHeap(
                            sizeof( SECPKG_EXTENDED_INFORMATION ) +
                            sizeof( ThunkedContextLevels ) );

            if ( Info )
            {
                Info->Class = Class ;
                Info->Info.ContextThunks.InfoLevelCount =
                                sizeof( ThunkedContextLevels ) / sizeof( ULONG );
                CopyMemory( Info->Info.ContextThunks.Levels,
                            ThunkedContextLevels,
                            sizeof( ThunkedContextLevels ) );

                Status = SEC_E_OK ;

            }
            else
            {
                Status = SEC_E_INSUFFICIENT_MEMORY ;
            }

            break;

#ifdef LATER
        case SecpkgGssInfo:
            Info = (PSECPKG_EXTENDED_INFORMATION) LsaTable->AllocateLsaHeap(
                            sizeof( SECPKG_EXTENDED_INFORMATION ) +
                            sizeof( Md5Oid ) );

            if ( Info )
            {
                Info->Class = Class ;

                Info->Info.GssInfo.EncodedIdLength = sizeof( Md5Oid );

                CopyMemory( Info->Info.GssInfo.EncodedId,
                            Md5Oid,
                            sizeof( Md5Oid ) );

                Status = SEC_E_OK ;

            }
            else
            {
                Status = SEC_E_INSUFFICIENT_MEMORY ;
            }
#endif

        case SecpkgWowClientDll:

            //
            // This indicates that we're smart enough to handle wow client processes
            //

            Info = (PSECPKG_EXTENDED_INFORMATION) 
                                LsaTable->AllocateLsaHeap( sizeof( SECPKG_EXTENDED_INFORMATION ) +
                                                           (MAX_PATH * sizeof(WCHAR) ) );

            if ( Info == NULL )
            {
                Status = STATUS_INSUFFICIENT_RESOURCES ;
                break;
            }
            pszPath = (PWSTR) (Info + 1);

            Size = GetSystemWow64Directory(pszPath, MAX_PATH);
            if(Size == 0)
            {
                // This call will fail on x86 platforms.
                Status = SEC_E_UNSUPPORTED_FUNCTION;
                LsaTable->FreeLsaHeap(Info);
                break;
            }

            if(Size + 1 + wcslen(SCHANNEL_DLL_NAME) >= MAX_PATH)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES ;
                LsaTable->FreeLsaHeap(Info);
                break;
            }

            wcscat(pszPath, L"\\");
            wcscat(pszPath, SCHANNEL_DLL_NAME);

            Info->Class = SecpkgWowClientDll ;
            RtlInitUnicodeString(&Info->Info.WowClientDll.WowClientDllPath, pszPath);

            Status = SEC_E_OK;
            break;

        default:
            Status = SEC_E_UNSUPPORTED_FUNCTION ;
            Info = NULL ;
            break;

    }

    *pInfo = Info ;
    return Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\proto.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       proto.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-02-96   RichardW   Created
//
//----------------------------------------------------------------------------
#include <align.h>

//
// RELOCATE_ONE - Relocate a single pointer in a client buffer.
//
// Note: this macro is dependent on parameter names as indicated in the
//       description below.  On error, this macro goes to 'Cleanup' with
//       'Status' set to the NT Status code.
//
// The MaximumLength is forced to be Length.
//
// Define a macro to relocate a pointer in the buffer the client passed in
// to be relative to 'ProtocolSubmitBuffer' rather than being relative to
// 'ClientBufferBase'.  The result is checked to ensure the pointer and
// the data pointed to is within the first 'SubmitBufferSize' of the
// 'ProtocolSubmitBuffer'.
//
// The relocated field must be aligned to a WCHAR boundary.
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define RELOCATE_ONE( _q ) \
    {                                                                       \
        ULONG_PTR Offset;                                                   \
                                                                            \
        Offset = (((PUCHAR)((_q)->Buffer)) - ((PUCHAR)ClientBufferBase));   \
        if ( Offset >= SubmitBufferSize ||                                  \
             Offset + (_q)->Length > SubmitBufferSize ||                    \
             !COUNT_IS_ALIGNED( Offset, ALIGN_WCHAR) ) {                    \
                                                                            \
            Status = STATUS_INVALID_PARAMETER;                              \
            goto Cleanup;                                                   \
        }                                                                   \
                                                                            \
        (_q)->Buffer = (PWSTR)(((PUCHAR)ProtocolSubmitBuffer) + Offset);    \
        (_q)->MaximumLength = (_q)->Length ;                                \
    }

//
// NULL_RELOCATE_ONE - Relocate a single (possibly NULL) pointer in a client
//  buffer.
//
// This macro special cases a NULL pointer then calls RELOCATE_ONE.  Hence
// it has all the restrictions of RELOCATE_ONE.
//
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define NULL_RELOCATE_ONE( _q ) \
    {                                                                       \
        if ( (_q)->Buffer == NULL ) {                                       \
            if ( (_q)->Length != 0 ) {                                      \
                Status = STATUS_INVALID_PARAMETER;                          \
                goto Cleanup;                                               \
            }                                                               \
        } else if ( (_q)->Length == 0 ) {                                   \
            (_q)->Buffer = NULL;                                            \
        } else {                                                            \
            RELOCATE_ONE( _q );                                             \
        }                                                                   \
    }



SpInitializeFn                  SpInitialize;

SpGetInfoFn                     SpUniGetInfo;
SpGetInfoFn                     SpSslGetInfo;

SpAcceptCredentialsFn           SpAcceptCredentials;

SpAcquireCredentialsHandleFn    SpUniAcquireCredentialsHandle;

SpFreeCredentialsHandleFn       SpFreeCredentialsHandle;
SpQueryCredentialsAttributesFn  SpQueryCredentialsAttributes;
SpSaveCredentialsFn             SpSaveCredentials;
SpGetCredentialsFn              SpGetCredentials;
SpDeleteCredentialsFn           SpDeleteCredentials;

SpInitLsaModeContextFn          SpInitLsaModeContext;
SpDeleteContextFn               SpDeleteContext;
SpAcceptLsaModeContextFn        SpAcceptLsaModeContext;

LSA_AP_LOGON_TERMINATED         SpLogonTerminated;
SpApplyControlTokenFn           SpApplyControlToken;
LSA_AP_CALL_PACKAGE             SpCallPackage;
LSA_AP_CALL_PACKAGE             SpCallPackageUntrusted;
LSA_AP_CALL_PACKAGE_PASSTHROUGH SpCallPackagePassthrough;
SpShutdownFn                    SpShutdown;
SpGetUserInfoFn                 SpGetUserInfo;

SpInstanceInitFn                SpInstanceInit;
SpInitUserModeContextFn         SpInitUserModeContext;
SpMakeSignatureFn               SpMakeSignature;
SpVerifySignatureFn             SpVerifySignature;
SpSealMessageFn                 SpSealMessage;
SpUnsealMessageFn               SpUnsealMessage;
SpGetContextTokenFn             SpGetContextToken;
SpQueryContextAttributesFn      SpUserQueryContextAttributes;
SpQueryContextAttributesFn      SpLsaQueryContextAttributes;
SpSetContextAttributesFn        SpSetContextAttributes;
SpDeleteContextFn               SpDeleteUserModeContext;
SpCompleteAuthTokenFn           SpCompleteAuthToken;
SpFormatCredentialsFn           SpFormatCredentials;
SpMarshallSupplementalCredsFn   SpMarshallSupplementalCreds;
SpGetExtendedInformationFn      SpGetExtendedInformation;
SpExportSecurityContextFn       SpExportSecurityContext;
SpImportSecurityContextFn       SpImportSecurityContext;

SECURITY_STATUS
SEC_ENTRY
SpSslGetInfo(
    PSecPkgInfo pInfo);

SECURITY_STATUS PctTranslateError(SP_STATUS spRet);

BOOL
SslRelocateToken(
    IN HLOCATOR Locator,
    OUT HLOCATOR * NewLocator);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\perfmon.c ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1999
//
// File:        perfmon.c
//
// Contents:    Schannel performance counter functions.
//
// Functions:
//
// History:     04-11-2000   jbanes    Created
//
//------------------------------------------------------------------------
#include "sslp.h"
#include "perfmon.h"

DWORD   dwOpenCount = 0;        // count of "Open" threads
BOOL    bInitOK = FALSE;        // true = DLL initialized OK

HANDLE  LsaHandle;
DWORD   PackageNumber;

PM_OPEN_PROC    OpenSslPerformanceData;
PM_COLLECT_PROC CollectSslPerformanceData;
PM_CLOSE_PROC   CloseSslPerformanceData;

#define DWORD_MULTIPLE(x) (((x+sizeof(DWORD)-1)/sizeof(DWORD))*sizeof(DWORD))

SSLPERF_DATA_DEFINITION SslPerfDataDefinition =
{
    // PERF_OBJECT_TYPE
    {
        sizeof(SSLPERF_DATA_DEFINITION) + sizeof(SSLPERF_COUNTER),
        sizeof(SSLPERF_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        SSLPERF_OBJ,
        0,
        SSLPERF_OBJ,
        0,
        PERF_DETAIL_NOVICE,
        (sizeof(SSLPERF_DATA_DEFINITION) - sizeof(PERF_OBJECT_TYPE)) /
            sizeof(PERF_COUNTER_DEFINITION),
        0
        PERF_NO_INSTANCES,
        0
    },

    // PERF_COUNTER_DEFINITION
    {
        sizeof(PERF_COUNTER_DEFINITION),
        SSL_CACHE_ENTRIES,
        0,
        SSL_CACHE_ENTRIES,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FIELD_OFFSET(SSLPERF_COUNTER, dwCacheEntries)
    },

    // PERF_COUNTER_DEFINITION
    {
        sizeof(PERF_COUNTER_DEFINITION),
        SSL_ACTIVE_ENTRIES,
        0,
        SSL_ACTIVE_ENTRIES,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        FIELD_OFFSET(SSLPERF_COUNTER, dwActiveEntries)
    },

    // PERF_COUNTER_DEFINITION
    {
        sizeof(PERF_COUNTER_DEFINITION),
        SSL_HANDSHAKE_COUNT,
        0,
        SSL_HANDSHAKE_COUNT,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FIELD_OFFSET(SSLPERF_COUNTER, dwHandshakeCount)
    },

    // PERF_COUNTER_DEFINITION
    {
        sizeof(PERF_COUNTER_DEFINITION),
        SSL_RECONNECT_COUNT,
        0,
        SSL_RECONNECT_COUNT,
        0,
        0,
        PERF_DETAIL_NOVICE,
        PERF_COUNTER_COUNTER,
        sizeof(DWORD),
        FIELD_OFFSET(SSLPERF_COUNTER, dwReconnectCount)
    }
};


typedef struct _INSTANCE_DATA
{
    DWORD   dwProtocol;
    LPWSTR  szInstanceName;
} INSTANCE_DATA, *PINSTANCE_DATA;

static INSTANCE_DATA wdInstance[]  =
{
    {SP_PROT_CLIENTS, L"Client"},
    {SP_PROT_SERVERS, L"Server"},
    {0,               L"_Total"}
};

static const DWORD    NUM_INSTANCES =
    (sizeof(wdInstance)/sizeof(wdInstance[0]));


/*++

Routine Description:

    This routine will initialize the data structures used to pass
    data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (PerfGen)

Return Value:

    None.

--*/
DWORD APIENTRY
OpenSslPerformanceData(
    LPWSTR lpDeviceNames)
{
    LONG Status;
    HKEY hKey = 0;
    DWORD size;
    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;
    LSA_STRING PackageName;

    UNREFERENCED_PARAMETER(lpDeviceNames);

    //
    //  Since WINLOGON is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    if (!dwOpenCount)
    {
        // get counter and help index base values from registry
        //      Open key to registry entry
        //      read First Counter and First Help values
        //      update static data strucutures by adding base to
        //          offset value in structure.

        Status = RegOpenKeyExA(
            HKEY_LOCAL_MACHINE,
            "SYSTEM\\CurrentControlSet\\Services\\Schannel\\Performance",
            0L,
            KEY_READ,
            &hKey);

        if(Status != ERROR_SUCCESS)
        {
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            goto cleanup;
        }

        size = sizeof (DWORD);
        Status = RegQueryValueExA(
                    hKey,
                    "First Counter",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstCounter,
                    &size);

        if(Status != ERROR_SUCCESS)
        {
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            goto cleanup;
        }

        size = sizeof (DWORD);
        Status = RegQueryValueExA(
                    hKey,
                    "First Help",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstHelp,
                    &size);

        if(Status != ERROR_SUCCESS)
        {
            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            goto cleanup;
        }

        //
        //  NOTE: the initialization program could also retrieve
        //      LastCounter and LastHelp if they wanted to do
        //      bounds checking on the new number. e.g.
        //
        //      counter->CounterNameTitleIndex += dwFirstCounter;
        //      if (counter->CounterNameTitleIndex > dwLastCounter) {
        //          LogErrorToEventLog (INDEX_OUT_OF_BOUNDS);
        //      }


        //
        // Establish connection to schannel.
        //

        Status = LsaConnectUntrusted(&LsaHandle);

        if(!NT_SUCCESS(Status))
        {
            goto cleanup;
        }

        PackageName.Buffer          = UNISP_NAME_A;
        PackageName.Length          = (USHORT)strlen(PackageName.Buffer);
        PackageName.MaximumLength   = PackageName.Length + 1;

        Status = LsaLookupAuthenticationPackage(
                        LsaHandle,
                        &PackageName,
                        &PackageNumber);
        if(FAILED(Status))
        {
            CloseHandle(LsaHandle);
            goto cleanup;
        }


        //
        // Initialize the performance counters.
        //

        SslPerfDataDefinition.SslPerfObjectType.ObjectNameTitleIndex += dwFirstCounter;
        SslPerfDataDefinition.SslPerfObjectType.ObjectHelpTitleIndex += dwFirstHelp;

        // assign index of default counter (Sine Wave)
        SslPerfDataDefinition.SslPerfObjectType.DefaultCounter = 0;

        SslPerfDataDefinition.CacheEntriesDef.CounterNameTitleIndex += dwFirstCounter;
        SslPerfDataDefinition.CacheEntriesDef.CounterHelpTitleIndex += dwFirstHelp;

        SslPerfDataDefinition.ActiveEntriesDef.CounterNameTitleIndex += dwFirstCounter;
        SslPerfDataDefinition.ActiveEntriesDef.CounterHelpTitleIndex += dwFirstHelp;

        SslPerfDataDefinition.HandshakeCountDef.CounterNameTitleIndex += dwFirstCounter;
        SslPerfDataDefinition.HandshakeCountDef.CounterHelpTitleIndex += dwFirstHelp;

        SslPerfDataDefinition.ReconnectCountDef.CounterNameTitleIndex += dwFirstCounter;
        SslPerfDataDefinition.ReconnectCountDef.CounterHelpTitleIndex += dwFirstHelp;

        bInitOK = TRUE;
    }

    dwOpenCount++;

    Status = ERROR_SUCCESS;

cleanup:

    if(hKey)
    {
        RegCloseKey(hKey);
    }

    return Status;
}


DWORD
GetCacheInfo(
    PSSL_PERFMON_INFO_RESPONSE pPerfmonInfo)
{
    PSSL_PERFMON_INFO_REQUEST pRequest = NULL;
    PSSL_PERFMON_INFO_RESPONSE pResponse = NULL;
    DWORD cbResponse = 0;
    NTSTATUS SubStatus;
    NTSTATUS Status;

    pRequest = (PSSL_PERFMON_INFO_REQUEST)LocalAlloc(LPTR, sizeof(SSL_PERFMON_INFO_REQUEST));
    if(pRequest == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    pRequest->MessageType = SSL_PERFMON_INFO_MESSAGE;

    Status = LsaCallAuthenticationPackage(
                    LsaHandle,
                    PackageNumber,
                    pRequest,
                    sizeof(SSL_PERFMON_INFO_REQUEST),
                    &pResponse,
                    &cbResponse,
                    &SubStatus);
    if(FAILED(Status))
    {
        goto cleanup;
    }

    *pPerfmonInfo = *pResponse;

    Status = STATUS_SUCCESS;

cleanup:

    if(pRequest)
    {
        LocalFree(pRequest);
    }

    if (pResponse != NULL)
    {
        LsaFreeReturnBuffer(pResponse);
    }

    return Status;
}

/*++

Routine Description:

    This routine will return the data for the ssl performance counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data.

      ERROR_SUCCESS  if success or any other error.

--*/
DWORD APIENTRY
CollectSslPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes)
{
    PERF_INSTANCE_DEFINITION *pPerfInstanceDefinition;
    SSLPERF_DATA_DEFINITION *pSslPerfDataDefinition;
    PSSLPERF_COUNTER pSC;
    SSL_PERFMON_INFO_RESPONSE PerfmonInfo;

    DWORD   dwThisInstance;
    ULONG   SpaceNeeded;
    DWORD   dwQueryType;
    DWORD   Status;

    //
    // before doing anything else, see if Open went OK
    //
    if (!bInitOK)
    {
        // unable to continue because open failed.
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    //
    // see if this is a foreign (i.e. non-NT) computer data request
    //

    dwQueryType = GetQueryType (lpValueName);

    if (dwQueryType == QUERY_FOREIGN)
    {
        // this routine does not service requests for data from
        // Non-NT computers
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }


    if (dwQueryType == QUERY_ITEMS)
    {
        if(!(IsNumberInUnicodeList(SslPerfDataDefinition.SslPerfObjectType.ObjectNameTitleIndex, lpValueName)))
        {
            // request received for data object not provided by this routine
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }

    pSslPerfDataDefinition = (SSLPERF_DATA_DEFINITION *) *lppData;

    SpaceNeeded = sizeof(SSLPERF_DATA_DEFINITION) +
          (NUM_INSTANCES * (sizeof(PERF_INSTANCE_DEFINITION) +
          (24) +    // size of instance names
          sizeof (SSLPERF_COUNTER)));

    if ( *lpcbTotalBytes < SpaceNeeded )
    {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //
    memmove(pSslPerfDataDefinition,
            &SslPerfDataDefinition,
            sizeof(SSLPERF_DATA_DEFINITION));


    //
    // Get info from schannel.
    //

    Status = GetCacheInfo(&PerfmonInfo);

    if(!NT_SUCCESS(Status))
    {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }


    //
    //  Create data for return for each instance
    //
    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                 &pSslPerfDataDefinition[1];

    for(dwThisInstance = 0; dwThisInstance < NUM_INSTANCES; dwThisInstance++)
    {
        MonBuildInstanceDefinition(
            pPerfInstanceDefinition,
            (PVOID *)&pSC,
            0,
            0,
            (DWORD)-1, // use name
            wdInstance[dwThisInstance].szInstanceName);

        pSC->CounterBlock.ByteLength = sizeof (SSLPERF_COUNTER);

        if(wdInstance[dwThisInstance].dwProtocol & SP_PROT_CLIENTS)
        {
            // client
            pSC->dwCacheEntries     = PerfmonInfo.ClientCacheEntries;
            pSC->dwActiveEntries    = PerfmonInfo.ClientActiveEntries;
            pSC->dwHandshakeCount   = PerfmonInfo.ClientHandshakesPerSecond;
            pSC->dwReconnectCount   = PerfmonInfo.ClientReconnectsPerSecond;
        }
        else if(wdInstance[dwThisInstance].dwProtocol & SP_PROT_SERVERS)
        {
            // server
            pSC->dwCacheEntries     = PerfmonInfo.ServerCacheEntries;
            pSC->dwActiveEntries    = PerfmonInfo.ServerActiveEntries;
            pSC->dwHandshakeCount   = PerfmonInfo.ServerHandshakesPerSecond;
            pSC->dwReconnectCount   = PerfmonInfo.ServerReconnectsPerSecond;
        }
        else
        {
            // total
            pSC->dwCacheEntries     = PerfmonInfo.ClientCacheEntries +
                                      PerfmonInfo.ServerCacheEntries;
            pSC->dwActiveEntries    = PerfmonInfo.ClientActiveEntries +
                                      PerfmonInfo.ServerActiveEntries;
            pSC->dwHandshakeCount   = PerfmonInfo.ClientHandshakesPerSecond +
                                      PerfmonInfo.ServerHandshakesPerSecond;
            pSC->dwReconnectCount   = PerfmonInfo.ClientReconnectsPerSecond +
                                      PerfmonInfo.ServerReconnectsPerSecond;
        }

        // update instance pointer for next instance
        pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)&pSC[1];
    }

    //
    // update arguments for return
    //

    *lppData = (PVOID)pPerfInstanceDefinition;

    *lpNumObjectTypes = 1;

    pSslPerfDataDefinition->SslPerfObjectType.TotalByteLength =
        *lpcbTotalBytes = (DWORD)((LONG_PTR)pPerfInstanceDefinition -
                          (LONG_PTR)pSslPerfDataDefinition);

    // update instance count
    pSslPerfDataDefinition->SslPerfObjectType.NumInstances = NUM_INSTANCES;

    return ERROR_SUCCESS;
}


/*++

Routine Description:

    This routine closes the open handles to the Signal Gen counters.

Arguments:

    None.


Return Value:

    ERROR_SUCCESS

--*/
DWORD APIENTRY
CloseSslPerformanceData(void)
{
    if(--dwOpenCount == 0)
    {
        // when this is the last thread...
        if(LsaHandle)
        {
            CloseHandle(LsaHandle);
        }
    }

    return ERROR_SUCCESS;
}


/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foreign" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
DWORD
GetQueryType (
    IN LPWSTR lpValue)
{
    if(lpValue == NULL || *lpValue == 0)
    {
        return QUERY_GLOBAL;
    }

    if(lstrcmp(lpValue, L"Global") == 0)
    {
        return QUERY_GLOBAL;
    }

    if(lstrcmp(lpValue, L"Foreign") == 0)
    {
        return QUERY_FOREIGN;
    }

    if(lstrcmp(lpValue, L"Costly") == 0)
    {
        return QUERY_COSTLY;
    }

    // if not Global and not Foreign and not Costly,
    // then it must be an item list
    return QUERY_ITEMS;
}


/*++

    MonBuildInstanceDefinition  -   Build an instance of an object

        Inputs:

            pBuffer         -   pointer to buffer where instance is to
                                be constructed

            pBufferNext     -   pointer to a pointer which will contain
                                next available location, DWORD aligned

            ParentObjectTitleIndex
                            -   Title Index of parent object type; 0 if
                                no parent object

            ParentObjectInstance
                            -   Index into instances of parent object
                                type, starting at 0, for this instances
                                parent object instance

            UniqueID        -   a unique identifier which should be used
                                instead of the Name for identifying
                                this instance

            Name            -   Name of this instance
--*/
BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    LPWSTR Name)
{
    DWORD NameLength;
    LPWSTR pName;

    //  Include trailing null in name size
    NameLength = (lstrlenW(Name) + 1) * sizeof(WCHAR);

    pBuffer->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) +
                          DWORD_MULTIPLE(NameLength);

    pBuffer->ParentObjectTitleIndex = ParentObjectTitleIndex;
    pBuffer->ParentObjectInstance = ParentObjectInstance;
    pBuffer->UniqueID = UniqueID;
    pBuffer->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
    pBuffer->NameLength = NameLength;

    // copy name to name buffer
    pName = (LPWSTR)&pBuffer[1];
    RtlMoveMemory(pName,Name,NameLength);

    // update "next byte" pointer
    *pBufferNext = (PVOID) ((PCHAR) pBuffer + pBuffer->ByteLength);

    return 0;
}


/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
BOOL
IsNumberInUnicodeList(
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList)
{
    DWORD dwThisNumber;
    DWORD cDigits;

    if(lpwszUnicodeList == 0) return FALSE;

    while(TRUE)
    {
        // Skip over leading whitespace.
        while(*lpwszUnicodeList && iswspace(*lpwszUnicodeList))
        {
            lpwszUnicodeList++;
        }

        // Get number.
        cDigits = 0;
        dwThisNumber = 0;
        while(iswdigit(*lpwszUnicodeList))
        {
            dwThisNumber *= 10;
            dwThisNumber += (*lpwszUnicodeList - L'0');
            cDigits++;
            lpwszUnicodeList++;
        }
        if(cDigits == 0)
        {
            return FALSE;
        }

        // Compare number to reference.
        if(dwThisNumber == dwNumber)
        {
            return TRUE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\perfmon.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1999
//
// File:        perfmon.h
//
// Contents:    Schannel performance counter functions.
//
// Functions:   
//
// History:     04-11-2000   jbanes    Created
//
//------------------------------------------------------------------------

#include <winperf.h>
#include <sslperf.h>

//
//  Perf Gen Resource object type counter definitions.
//
//  This is the counter structure presently returned by the generator
//

typedef struct _SSLPERF_DATA_DEFINITION 
{
    PERF_OBJECT_TYPE		SslPerfObjectType;
    PERF_COUNTER_DEFINITION	CacheEntriesDef;
    PERF_COUNTER_DEFINITION	ActiveEntriesDef;
    PERF_COUNTER_DEFINITION	HandshakeCountDef;
    PERF_COUNTER_DEFINITION	ReconnectCountDef;
} SSLPERF_DATA_DEFINITION;

//
// This is the block of data that corresponds to each instance of the 
// object. This structure will immediately follow the instance definition
// data structure
//

typedef struct _SSLPERF_COUNTER {
    PERF_COUNTER_BLOCK      CounterBlock;
    DWORD                   dwCacheEntries;
    DWORD                   dwActiveEntries;
    DWORD                   dwHandshakeCount;
    DWORD                   dwReconnectCount;
} SSLPERF_COUNTER, *PSSLPERF_COUNTER;


#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

DWORD
GetQueryType (
    IN LPWSTR lpValue);

BOOL
MonBuildInstanceDefinition(
    PERF_INSTANCE_DEFINITION *pBuffer,
    PVOID *pBufferNext,
    DWORD ParentObjectTitleIndex,
    DWORD ParentObjectInstance,
    DWORD UniqueID,
    LPWSTR Name);

BOOL
IsNumberInUnicodeList(
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\sidfilter.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       sidfilter.h
//
//  Contents:   Defines for schannel SID filtering.
//
//  Classes:
//
//  Functions:
//
//  History:    08-20-2002   jbanes   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

//#define ROGUE_DC        // This must be commented out before checking in!!

extern PLSA_SECPKG_FUNCTION_TABLE LsaTable;

NTSTATUS
SslCheckPacForSidFiltering(
    IN     PSID pTrustSid,
    IN OUT PUCHAR *PacData,
    IN OUT PULONG PacSize);


#ifdef ROGUE_DC

#define SP_REG_ROGUE_BASE_KEY  L"System\\CurrentControlSet\\Services\\Kdc\\Rogue"

extern HKEY g_hSslRogueKey;

NTSTATUS
SslInstrumentRoguePac(
    IN OUT PUCHAR *PacData,
    IN OUT PULONG PacSize);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\sidfilter.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       sidfilter.c
//
//  Contents:   Implements SID filtering for the schannel certificate 
//              mapping layer.
//
//  Classes:
//
//  Functions:
//
//  History:    08-20-2002   jbanes   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#define SECURITY_PACKAGE
#define SECURITY_WIN32
#include <sspi.h>
#include <security.h>
#include <secint.h>

#include <align.h>         // ROUND_UP_COUNT
#include <lsarpc.h>
#include <samrpc.h>
#include <logonmsv.h>
#include <lsaisrv.h>
#include <spreg.h>
#include <debug.h>
#include <dsysdbg.h>
#include <sidfilter.h>

#ifdef ROGUE_DC
#include <ntmsv1_0.h>
#endif
}

#include <pac.hxx>     // MUST be outside of the Extern C since libs are exported as C++

NTSTATUS
SslFilterSids(
    IN     PSID pTrustSid,
    IN     PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo);


//+-------------------------------------------------------------------------
//
//  Function:   SslCheckPacForSidFiltering
//
//  Synopsis:   If the ticket info has a TDOSid then the function
//              makes a check to make sure the SID from the TDO matches
//              the client's home domain SID.  A call to LsaIFilterSids
//              is made to do the check.  If this function fails with
//              STATUS_TRUST_FAILURE then an audit log is generated.
//              Otherwise the function succeeds but SIDs are filtered
//              from the PAC.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:   taken from updated kerberos code
//
//
//--------------------------------------------------------------------------
NTSTATUS
SslCheckPacForSidFiltering(
    IN     PSID pTrustSid,
    IN OUT PUCHAR *PacData,
    IN OUT PULONG PacSize)
{
    NTSTATUS Status = STATUS_SUCCESS;
    PPAC_INFO_BUFFER LogonInfo;
    PPACTYPE OldPac;
    ULONG OldPacSize;
    PPACTYPE NewPac = NULL;
    PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo = NULL;
    SAMPR_PSID_ARRAY ZeroResourceGroups;
    ULONG OldExtraSidCount;
    PPACTYPE RemarshalPac = NULL;
    ULONG RemarshalPacSize = 0;

    OldPac = (PPACTYPE) *PacData;
    OldPacSize = *PacSize;

    DebugLog((DEB_TRACE,"SslCheckPacForSidFiltering\n"));

    if (PAC_UnMarshal(OldPac, OldPacSize) == 0)
    {
        DebugLog((DEB_ERROR,"SslCheckPacForSidFiltering: Failed to unmarshal pac\n"));
        Status = SEC_E_CANNOT_PACK;
        goto Cleanup;
    }

    //
    // Must remember to remarshal the PAC prior to returning
    //

    RemarshalPac = OldPac;
    RemarshalPacSize = OldPacSize;

    RtlZeroMemory(
        &ZeroResourceGroups,
        sizeof(ZeroResourceGroups));  // allows us to use PAC_InitAndUpdateGroups to remarshal the PAC

    //
    // First, find the logon information
    //

    LogonInfo = PAC_Find(
                    OldPac,
                    PAC_LOGON_INFO,
                    NULL
                    );

    if (LogonInfo == NULL)
    {
        DebugLog((DEB_WARN,"SslCheckPacForSidFiltering: No logon info for PAC - not making SID filtering check\n"));
        goto Cleanup;
    }

    //
    // Now unmarshall the validation information and build a list of sids
    //

    Status = PAC_UnmarshallValidationInfo(
                        &ValidationInfo,
                        LogonInfo->Data,
                        LogonInfo->cbBufferSize);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"SslCheckPacForSidFiltering: Failed to unmarshall validation info!   0x%x\n", Status));
        goto Cleanup;
    }

    //
    // Save the old extra SID count (so that if KdcFilterSids compresses
    // the SID array, we can avoid allocating memory for the other-org SID later)
    //

    OldExtraSidCount = ValidationInfo->SidCount;

    //
    // Call lsaifiltersids().
    //

    Status = SslFilterSids(
                pTrustSid,
                ValidationInfo
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"SslCheckPacForSidFiltering: Failed filtering SIDs\n"));
        goto Cleanup;
    }

    // Other org processing was here - not supported currently for Ssl

    //
    // Now build a new pac
    //

    Status = PAC_InitAndUpdateGroups(
                ValidationInfo,
                &ZeroResourceGroups,
                OldPac,
                &NewPac
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"SslCheckPacForSidFiltering: Failed pac init and updating groups    0x%x\n", Status));
        goto Cleanup;
    }

    RemarshalPacSize = PAC_GetSize(NewPac);
    RemarshalPac = NewPac;

Cleanup:

    if ( RemarshalPac != NULL )
    {
        if (!PAC_ReMarshal(RemarshalPac, RemarshalPacSize))
        {
            // PAC_Remarshal Failed
            ASSERT(0);
            Status = SEC_E_CANNOT_PACK;
        }
        else if ( NewPac != NULL &&
                  *PacData != (PBYTE)NewPac )
        {
            MIDL_user_free(*PacData);
            *PacData = (PBYTE) NewPac;
            NewPac = NULL;
            *PacSize = RemarshalPacSize;
        }
    }

    if (NewPac != NULL)
    {
        MIDL_user_free(NewPac);
    }

    if (ValidationInfo != NULL)
    {
        MIDL_user_free(ValidationInfo);
    }

    DebugLog((DEB_TRACE,"SslCheckPacForSidFiltering returns 0x%x\n", Status));

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   SslFilterSids
//
//  Synopsis:   Function that just call LsaIFilterSids.
//
//  Effects:
//
//  Arguments:  ServerInfo      structure containing attributes of the trust
//              ValidationInfo  authorization information to filter
//
//  Requires:
//
//  Returns:    See LsaIFilterSids
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
SslFilterSids(
    IN     PSID pTrustSid,
    IN     PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING pustrTrustedForest = NULL;

    if(pTrustSid == NULL)
    {
        // Member-to-DC boundary
        Status = LsaIFilterSids(
                     pustrTrustedForest,           // Pass domain name here
                     0,
                     0,
                     0,
                     pTrustSid,
                     NetlogonValidationSamInfo2,
                     ValidationInfo,
                     NULL,
                     NULL,
                     NULL
                     );
    }
    else
    {
        // Resource-DC to User-DC boundary
        Status = LsaIFilterSids(
                     pustrTrustedForest,           // Pass domain name here
                     TRUST_DIRECTION_OUTBOUND,
                     TRUST_TYPE_UPLEVEL,
                     0,
                     pTrustSid,
                     NetlogonValidationSamInfo2,
                     ValidationInfo,
                     NULL,
                     NULL,
                     NULL
                     );
    }

    if (!NT_SUCCESS(Status))
    {
        //
        // Create an audit log if it looks like the SID has been tampered with  - ToDo
        //

        /*
        if ((STATUS_DOMAIN_TRUST_INCONSISTENT == Status) &&
            SecData.AuditKdcEvent(KDC_AUDIT_TGS_FAILURE))
        {
            DWORD Dummy = 0;

            KdcLsaIAuditKdcEvent(
                SE_AUDITID_TGS_TICKET_REQUEST,
                &ValidationInfo->EffectiveName,
                &ValidationInfo->LogonDomainName,
                NULL,
                &ServerInfo->AccountName,
                NULL,
                &Dummy,
                (PULONG) &Status,
                NULL,
                NULL,                               // no preauth type
                GET_CLIENT_ADDRESS(NULL),
                NULL                                // no logon guid
                );
        }
        */

        DebugLog((DEB_ERROR,"SslFilterSids: Failed to filter SIDS (LsaIFilterSids): 0x%x\n",Status));
    }
    else
    {
        DebugLog((DEB_TRACE,"SslFilterSids: successfully filtered sids\n",Status));
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   MIDL_user_allocate
//
//  Synopsis:   Allocation routine for use by RPC client stubs
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  BufferSize - size of buffer, in bytes, to allocate
//
//  Requires:
//
//  Returns:    Buffer pointer or NULL on allocation failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------
PVOID
MIDL_user_allocate(
    IN size_t BufferSize
    )
{
    return (LsaTable->AllocateLsaHeap(ROUND_UP_COUNT((ULONG)BufferSize, 8)));
}


//+-------------------------------------------------------------------------
//
//  Function:   MIDL_user_free
//
//  Synopsis:   Memory free routine for RPC client stubs
//
//  Effects:    frees the buffer with LsaFunctions.FreeLsaHeap
//
//  Arguments:  Buffer - Buffer to free
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
MIDL_user_free(
    IN PVOID Buffer
    )
{
    LsaTable->FreeLsaHeap(Buffer);
}


#ifdef ROGUE_DC

#pragma message( "COMPILING A ROGUE DC!!!" )
#pragma message( "MUST NOT SHIP THIS BUILD!!!" )

#pragma warning(disable:4127) // Disable warning/error for conditional expression is constant

#define MAX_SID_LEN (sizeof(SID) + sizeof(ULONG) * SID_MAX_SUB_AUTHORITIES)


extern "C"
{
#include "sddl.h"
#include "stdlib.h"
}

HKEY g_hSslRogueKey = NULL;

NTSTATUS
SslInstrumentRoguePac(
    IN OUT PUCHAR *PacData,
    IN OUT PULONG PacSize
    )
{
    NTSTATUS Status;
    PNETLOGON_VALIDATION_SAM_INFO3 OldValidationInfo = NULL;
    NETLOGON_VALIDATION_SAM_INFO3 NewValidationInfo = {0};
    SAMPR_PSID_ARRAY ZeroResourceGroups = {0};
    PPACTYPE NewPac = NULL;
    ULONG NewPacSize;
    PPAC_INFO_BUFFER LogonInfo;

    PPACTYPE OldPac = NULL;
    ULONG OldPacSize;

    PSID LogonDomainId = NULL;
    PSID ResourceGroupDomainSid = NULL;
    PGROUP_MEMBERSHIP GroupIds = NULL;
    PGROUP_MEMBERSHIP ResourceGroupIds = NULL;
    PNETLOGON_SID_AND_ATTRIBUTES ExtraSids = NULL;
    BYTE FullUserSidBuffer[MAX_SID_LEN];
    SID * FullUserSid = ( SID * )FullUserSidBuffer;
    CHAR * FullUserSidText = NULL;

    DWORD dwType;
    DWORD cbData = 0;
    PCHAR Buffer;
    PCHAR Value = NULL;

    BOOLEAN PacChanged = FALSE;

    DebugLog((DEB_TRACE,"SslInstrumentRoguePac: Entering\n"));

    //
    // Optimization: no "rogue" key in registry - nothing for us to do
    //

    if ( g_hSslRogueKey == NULL )
    {
        DebugLog((DEB_TRACE, "SslInstrumentRoguePac: nothing to do!\n"));
        return STATUS_SUCCESS;
    }


    OldPac = (PPACTYPE) *PacData;
    OldPacSize = *PacSize;

    //
    // Unmarshall the old PAC
    //

    if ( PAC_UnMarshal(OldPac, OldPacSize) == 0 )
    {
        DebugLog((DEB_ERROR,"SslInstrumentRoguePac: Failed to unmarshal pac\n"));
        Status = SEC_E_CANNOT_PACK;
        goto Cleanup;
    }

    //
    // First, find the logon information
    //

    LogonInfo = PAC_Find(
                    OldPac,
                    PAC_LOGON_INFO,
                    NULL
                    );

    if ( LogonInfo == NULL )
    {
        DebugLog((DEB_ERROR, "SslInstrumentRoguePac: No logon info on PAC - not performing substitution\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // Now unmarshall the validation information and build a list of sids
    //

    if ( !NT_SUCCESS(PAC_UnmarshallValidationInfo(
                         &OldValidationInfo,
                         LogonInfo->Data,
                         LogonInfo->cbBufferSize )))
    {
        DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Unable to unmarshal validation info\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // Construct the text form of the full user's SID (logon domain ID + user ID)
    //

    DsysAssert( sizeof( FullUserSidBuffer ) >= MAX_SID_LEN );

    RtlCopySid(
        sizeof( FullUserSidBuffer ),
        FullUserSid,
        OldValidationInfo->LogonDomainId
        );

    FullUserSid->SubAuthority[FullUserSid->SubAuthorityCount] = OldValidationInfo->UserId;
    FullUserSid->SubAuthorityCount += 1;

    if ( FALSE == ConvertSidToStringSidA(
                      FullUserSid,
                      &FullUserSidText ))
    {
        DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Unable to convert user's SID\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    //
    // Now look in the registry for the SID matching the validation info
    //

    if ( ERROR_SUCCESS != RegQueryValueExA(
                              g_hSslRogueKey,
                              FullUserSidText,
                              NULL,
                              &dwType,
                              NULL,
                              &cbData ) ||
         dwType != REG_MULTI_SZ ||
         cbData <= 1 )
    {
        DebugLog((DEB_ERROR, "SslInstrumentRoguePac: No substitution info available for %s\n", FullUserSidText));
        Status = STATUS_SUCCESS;
        goto Error;
    }

    // SafeAllocaAllocate( Value, cbData );
    Value = (PCHAR)LocalAlloc(LPTR, cbData);
    if ( Value == NULL )
    {
        DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Out of memory allocating substitution buffer\n", FullUserSidText));
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    if ( ERROR_SUCCESS != RegQueryValueExA(
                              g_hSslRogueKey,
                              FullUserSidText,
                              NULL,
                              &dwType,
                              (PBYTE)Value,
                              &cbData ) ||
         dwType != REG_MULTI_SZ ||
         cbData <= 1 )
    {
        DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Error reading from registry\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Substituting the PAC for %s\n", FullUserSidText));

    Buffer = Value;

    //
    // New validation info will be overloaded with stuff from the file
    //

    NewValidationInfo = *OldValidationInfo;

    //
    // Read the input file one line at a time
    //

    while ( *Buffer != '\0' )
    {
        switch( Buffer[0] )
        {
        case 'l':
        case 'L': // logon domain ID

            if ( LogonDomainId != NULL )
            {
                DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Logon domain ID specified more than once - only first one kept\n"));
                break;
            }

            DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Substituting logon domain ID by %s\n", &Buffer[1]));

            if ( FALSE == ConvertStringSidToSidA(
                              &Buffer[1],
                              &LogonDomainId ))
            {
                DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Unable to convert SID\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            if ( LogonDomainId == NULL )
            {
                DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Out of memory allocating LogonDomainId\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            NewValidationInfo.LogonDomainId = LogonDomainId;
            LogonDomainId = NULL;
            PacChanged = TRUE;

            break;

        case 'd':
        case 'D': // resource group domain SID

            if ( ResourceGroupDomainSid != NULL )
            {
                DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Resource group domain SID specified more than once - only first one kept\n"));
                break;
            }

            DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Substituting resource group domain SID by %s\n", &Buffer[1]));

            if ( FALSE == ConvertStringSidToSidA(
                              &Buffer[1],
                              &ResourceGroupDomainSid ))
            {
                DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Unable to convert SID\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            if ( ResourceGroupDomainSid == NULL )
            {
                DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Out of memory allocating ResourceGroupDomainSid\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            NewValidationInfo.ResourceGroupDomainSid = ResourceGroupDomainSid;
            ResourceGroupDomainSid = NULL;
            PacChanged = TRUE;

            break;

        case 'p':
        case 'P': // primary group ID

            DebugLog((DEB_WARN, "SslInstrumentRoguePac: Substituting primary group ID by %s\n", &Buffer[1]));

            NewValidationInfo.PrimaryGroupId = atoi(&Buffer[1]);
            PacChanged = TRUE;

            break;

        case 'u':
        case 'U': // User ID

            DebugLog((DEB_WARN, "SslInstrumentRoguePac: Substituting user ID by %s\n", &Buffer[1]));

            NewValidationInfo.UserId = atoi(&Buffer[1]);
            PacChanged = TRUE;

            break;

        case 'e':
        case 'E': // Extra SID

            DebugLog((DEB_WARN, "SslInstrumentRoguePac: Adding an ExtraSid: %s\n", &Buffer[1]));

            if ( ExtraSids == NULL )
            {
                NewValidationInfo.ExtraSids = NULL;
                NewValidationInfo.SidCount = 0;

                ExtraSids = ( PNETLOGON_SID_AND_ATTRIBUTES )HeapAlloc(
                                GetProcessHeap(),
                                0,
                                sizeof( NETLOGON_SID_AND_ATTRIBUTES )
                                );
            }
            else
            {
                ExtraSids = ( PNETLOGON_SID_AND_ATTRIBUTES )HeapReAlloc(
                                GetProcessHeap(),
                                0,
                                NewValidationInfo.ExtraSids,
                                ( NewValidationInfo.SidCount + 1 ) * sizeof( NETLOGON_SID_AND_ATTRIBUTES )
                                );
            }

            if ( ExtraSids == NULL )
            {
                DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Out of memory allocating ExtraSids\n"));
                ExtraSids = NewValidationInfo.ExtraSids;
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            //
            // Read the actual SID
            //

            NewValidationInfo.ExtraSids = ExtraSids;

            if ( FALSE == ConvertStringSidToSidA(
                              &Buffer[1],
                              &NewValidationInfo.ExtraSids[NewValidationInfo.SidCount].Sid ))
            {
                DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Unable to convert SID\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            if ( NewValidationInfo.ExtraSids[NewValidationInfo.SidCount].Sid == NULL )
            {
                DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Out of memory allocating an extra SID\n"));
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            NewValidationInfo.ExtraSids[NewValidationInfo.SidCount].Attributes =
                SE_GROUP_MANDATORY |
                SE_GROUP_ENABLED_BY_DEFAULT |
                SE_GROUP_ENABLED;

            NewValidationInfo.SidCount += 1;
            PacChanged = TRUE;

            break;

        case 'g':
        case 'G': // Group ID

            DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Adding a GroupId: %s\n", &Buffer[1]));

            if ( GroupIds == NULL )
            {
                NewValidationInfo.GroupIds = NULL;
                NewValidationInfo.GroupCount = 0;

                GroupIds = ( PGROUP_MEMBERSHIP )HeapAlloc(
                               GetProcessHeap(),
                               0,
                               sizeof( GROUP_MEMBERSHIP )
                               );
            }
            else
            {
                GroupIds = ( PGROUP_MEMBERSHIP )HeapReAlloc(
                               GetProcessHeap(),
                               0,
                               NewValidationInfo.GroupIds,
                               ( NewValidationInfo.GroupCount + 1 ) * sizeof( GROUP_MEMBERSHIP )
                               );
            }

            if ( GroupIds == NULL )
            {
                DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Out of memory allocating Group IDs\n"));
                GroupIds = NewValidationInfo.GroupIds;
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            //
            // Read the actual ID
            //

            NewValidationInfo.GroupIds = GroupIds;
            NewValidationInfo.GroupIds[NewValidationInfo.GroupCount].RelativeId = atoi(&Buffer[1]);
            NewValidationInfo.GroupIds[NewValidationInfo.GroupCount].Attributes =
                SE_GROUP_MANDATORY |
                SE_GROUP_ENABLED_BY_DEFAULT |
                SE_GROUP_ENABLED;
            NewValidationInfo.GroupCount += 1;
            PacChanged = TRUE;

            break;

        case 'r':
        case 'R': // Resource groups

            DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Adding a ResourceGroupId: %s\n", &Buffer[1]));

            if ( ResourceGroupIds == NULL )
            {
                NewValidationInfo.ResourceGroupIds = NULL;
                NewValidationInfo.ResourceGroupCount = 0;

                ResourceGroupIds = ( PGROUP_MEMBERSHIP )HeapAlloc(
                                       GetProcessHeap(),
                                       0,
                                       sizeof( GROUP_MEMBERSHIP )
                                       );
            }
            else
            {
                ResourceGroupIds = ( PGROUP_MEMBERSHIP )HeapReAlloc(
                                       GetProcessHeap(),
                                       0,
                                       NewValidationInfo.ResourceGroupIds,
                                       ( NewValidationInfo.ResourceGroupCount + 1 ) * sizeof( GROUP_MEMBERSHIP )
                                       );
            }

            if ( ResourceGroupIds == NULL )
            {
                DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Out of memory allocating Resource Group IDs\n"));
                ResourceGroupIds = NewValidationInfo.ResourceGroupIds;
                Status = STATUS_UNSUCCESSFUL;
                goto Error;
            }

            //
            // Read the actual ID
            //

            NewValidationInfo.ResourceGroupIds = ResourceGroupIds;
            NewValidationInfo.ResourceGroupIds[NewValidationInfo.ResourceGroupCount].RelativeId = atoi(&Buffer[1]);
            NewValidationInfo.ResourceGroupIds[NewValidationInfo.ResourceGroupCount].Attributes =
                SE_GROUP_MANDATORY |
                SE_GROUP_ENABLED_BY_DEFAULT |
                SE_GROUP_ENABLED;
            NewValidationInfo.ResourceGroupCount += 1;
            PacChanged = TRUE;

            break;

        default:   // unrecognized

            DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Entry \'%c\' unrecognized\n", Buffer[0]));

            break;
        }

        //
        // Move to the next line
        //

        while (*Buffer++ != '\0');
    }

    if ( !PacChanged )
    {
        DebugLog((DEB_TRACE, "SslInstrumentRoguePac: Nothing to substitute for %s\n", FullUserSidText));
        Status = STATUS_SUCCESS;
        goto Error;
    }

    //
    // If resource group IDs were added, indicate that by setting the corresponding flag
    //

    if ( ResourceGroupIds )
    {
        NewValidationInfo.UserFlags |= LOGON_RESOURCE_GROUPS;
    }

    //
    // If extra SIDs were added, indicate that by setting the corresponding flag
    //

    if ( ExtraSids )
    {
        NewValidationInfo.UserFlags |= LOGON_EXTRA_SIDS;
    }

    //
    // Now build a new pac
    //

    Status = PAC_InitAndUpdateGroups(
                 &NewValidationInfo,
                 &ZeroResourceGroups,
                 OldPac,
                 &NewPac
                 );

    if ( !NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Error 0x%x from PAC_InitAndUpdateGroups\n"));
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    NewPacSize = PAC_GetSize( NewPac );

    if (!PAC_ReMarshal(NewPac, NewPacSize))
    {
        DsysAssert(!"SslInstrumentRoguePac: PAC_Remarshal Failed");
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    MIDL_user_free( *PacData );   // Free up the OldPac structure
    *PacData = (PBYTE) NewPac;
    NewPac = NULL;
    *PacSize = NewPacSize;

    Status = STATUS_SUCCESS;

Cleanup:

    MIDL_user_free( OldValidationInfo );
    LocalFree( FullUserSidText );
    LocalFree( ResourceGroupDomainSid );
    LocalFree( LogonDomainId );
    HeapFree( GetProcessHeap(), 0, ResourceGroupIds );
    HeapFree( GetProcessHeap(), 0, GroupIds );

    if ( ExtraSids )
    {
        for ( ULONG i = 0; i < NewValidationInfo.SidCount; i++ )
        {
            HeapFree( GetProcessHeap(), 0, ExtraSids[i].Sid );
        }

        HeapFree( GetProcessHeap(), 0, ExtraSids );
    }

    MIDL_user_free( NewPac );

    // SafeAllocaFree( Value );
    LocalFree( Value );

    DebugLog((DEB_TRACE, "SslInstrumentRoguePac: Leaving   Status 0x%x\n", Status));

    return Status;

Error:

    if ( !NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "SslInstrumentRoguePac: Substitution encountered an error, not performed\n"));
    }

    if ( !PAC_ReMarshal(OldPac, OldPacSize))
    {
        // PAC_Remarshal Failed
        DsysAssert(!"SslInstrumentRoguePac: PAC_Remarshal Failed");
        Status = SEC_E_CANNOT_PACK;
    }

    goto Cleanup;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\sslpi.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       sslp.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-02-96   RichardW   Created
//
//----------------------------------------------------------------------------

#define SECURITY_PACKAGE
#include <spbasei.h>
#include <security.h>
#include <secint.h>

#include "ssldebug.h"
#include "proto.h"
#include "userctxt.h"

#define CALLBACK_GET_KEYS   1
#define CALLBACK_DO_MAPPING 2


extern  HINSTANCE   hDllInstance ;
extern  PLSA_SECPKG_FUNCTION_TABLE LsaTable ;
extern  TOKEN_SOURCE SslTokenSource ;
extern  SECURITY_STRING SslNamePrefix ;
extern  SECURITY_STRING SslDomainName ;
extern  SECURITY_STRING SslGlobalDnsDomainName ;
extern  SECURITY_STRING SslPackageName ;
extern  SECURITY_STRING SslLegacyPackageName ;

extern  LSA_STRING SslPackageNameA ;

extern RTL_RESOURCE SslGlobalLock;

#define SslGlobalReadLock()    RtlAcquireResourceShared(&SslGlobalLock, TRUE)
#define SslGlobalWriteLock()   RtlAcquireResourceExclusive(&SslGlobalLock, TRUE)
#define SslGlobalReleaseLock() RtlReleaseResource(&SslGlobalLock)

NTSTATUS
SslInitSystemMapper(void);

NTSTATUS
NTAPI
SslDoClientRequest(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLen,
    OUT PVOID * ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
NTAPI
SslMapExternalCredential(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLen,
    OUT PVOID * ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS
SslDuplicateString(
    PUNICODE_STRING Dest,
    PUNICODE_STRING Source
    );


VOID
SslFreeString(
    IN OPTIONAL PUNICODE_STRING String
    );


NTSTATUS
SslRegisterForDomainChange(
    VOID);


#define REQ_UPN_MAPPING          0x00000010
#define REQ_SUBJECT_MAPPING      0x00000020
#define REQ_ISSUER_MAPPING       0x00000040
#define REQ_ISSUER_CHAIN_MAPPING 0x00000080

typedef struct _SSL_CERT_NAME_INFO {
    ULONG IssuerOffset;     // ASN1 encoded
    ULONG IssuerLength;
} SSL_CERT_NAME_INFO, * PSSL_CERT_NAME_INFO;

typedef struct _SSL_CERT_LOGON_REQ {
    ULONG MessageType ;
    ULONG Length ;
    ULONG OffsetCertificate ;
    ULONG CertLength ;
    ULONG Flags;
    ULONG CertCount;
    SSL_CERT_NAME_INFO NameInfo[1];
} SSL_CERT_LOGON_REQ, * PSSL_CERT_LOGON_REQ ;

typedef struct _SSL_CERT_LOGON_RESP {
    ULONG MessageType ;
    ULONG Length ;
    ULONG OffsetAuthData ;
    ULONG AuthDataLength ;
    ULONG Flags ;
    ULONG OffsetDomain ;
    ULONG DomainLength ;
    ULONG Align ;
} SSL_CERT_LOGON_RESP, * PSSL_CERT_LOGON_RESP ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\sslp.h ===
#include "sslpi.h"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\stubs.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       stubs.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-01-95   RichardW   Created
//
//----------------------------------------------------------------------------


#include "sslp.h"
#include <cert509.h>
#include <rsa.h>


CHAR CertTag[ 13 ] = { 0x04, 0x0b, 'c', 'e', 'r', 't', 'i', 'f', 'i', 'c', 'a', 't', 'e' };

// Nonstandard extension, function/data pointer conversion in expression
#pragma warning (disable: 4152)

SecurityFunctionTableW SPFunctionTable = {
    SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
    EnumerateSecurityPackagesW,
    NULL,
    AcquireCredentialsHandleW,
    FreeCredentialsHandle,
    NULL,
    InitializeSecurityContextW,
    AcceptSecurityContext,
    CompleteAuthToken,
    DeleteSecurityContext,
    ApplyControlToken,
    QueryContextAttributesW,
    ImpersonateSecurityContext,
    RevertSecurityContext,
    MakeSignature,
    VerifySignature,
    FreeContextBuffer,
    QuerySecurityPackageInfoW,
    SealMessage,
    UnsealMessage,
    NULL, /* GrantProxyW */
    NULL, /* RevokeProxyW */
    NULL, /* InvokeProxyW */
    NULL, /* RenewProxyW */
    QuerySecurityContextToken,
    SealMessage,
    UnsealMessage,
    SetContextAttributesW
    };

SecurityFunctionTableA SPFunctionTableA = {
    SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
    EnumerateSecurityPackagesA,
    NULL,
    AcquireCredentialsHandleA,
    FreeCredentialsHandle,
    NULL,
    InitializeSecurityContextA,
    AcceptSecurityContext,
    CompleteAuthToken,
    DeleteSecurityContext,
    ApplyControlToken,
    QueryContextAttributesA,
    ImpersonateSecurityContext,
    RevertSecurityContext,
    MakeSignature,
    VerifySignature,
    FreeContextBuffer,
    QuerySecurityPackageInfoA,
    SealMessage,
    UnsealMessage,
    NULL, /* GrantProxyA */
    NULL, /* RevokeProxyA */
    NULL, /* InvokeProxyA */
    NULL, /* RenewProxyA */
    QuerySecurityContextToken,
    SealMessage,
    UnsealMessage,
    SetContextAttributesA
    };


PSecurityFunctionTableW SEC_ENTRY
InitSecurityInterfaceW(
    VOID )
{
    return(&SPFunctionTable);
}

PSecurityFunctionTableA SEC_ENTRY
InitSecurityInterfaceA(
    VOID )
{
    return(&SPFunctionTableA);
}



SECURITY_STATUS SEC_ENTRY
FreeContextBuffer(
    void SEC_FAR *      pvContextBuffer
    )
{
    SPExternalFree( pvContextBuffer );
    return(SEC_E_OK);
}



SECURITY_STATUS SEC_ENTRY
SecurityPackageControl(
    SEC_WCHAR SEC_FAR *      pszPackageName,
    unsigned long           dwFunctionCode,
    unsigned long           cbInputBuffer,
    unsigned char SEC_FAR * pbInputBuffer,
    unsigned long SEC_FAR * pcbOutputBuffer,
    unsigned char SEC_FAR * pbOutputBuffer)
{
    UNREFERENCED_PARAMETER(pszPackageName);
    UNREFERENCED_PARAMETER(dwFunctionCode);
    UNREFERENCED_PARAMETER(cbInputBuffer);
    UNREFERENCED_PARAMETER(pbInputBuffer);
    UNREFERENCED_PARAMETER(pcbOutputBuffer);
    UNREFERENCED_PARAMETER(pbOutputBuffer);

    return(SEC_E_UNSUPPORTED_FUNCTION);
}

SECURITY_STATUS PctTranslateError(SP_STATUS spRet)
{
    if(HRESULT_FACILITY(spRet) == FACILITY_SECURITY)
    {
        return (spRet);
    }

    switch(spRet) {
        case PCT_ERR_OK: return SEC_E_OK;
        case PCT_ERR_BAD_CERTIFICATE: return SEC_E_INVALID_TOKEN;
        case PCT_ERR_CLIENT_AUTH_FAILED: return SEC_E_INVALID_TOKEN;
        case PCT_ERR_ILLEGAL_MESSAGE: return SEC_E_INVALID_TOKEN;
        case PCT_ERR_INTEGRITY_CHECK_FAILED: return SEC_E_MESSAGE_ALTERED;
        case PCT_ERR_SERVER_AUTH_FAILED: return SEC_E_INVALID_TOKEN;
        case PCT_ERR_SPECS_MISMATCH: return SEC_E_ALGORITHM_MISMATCH;
        case PCT_ERR_SSL_STYLE_MSG: return SEC_E_INVALID_TOKEN;
        case SEC_I_INCOMPLETE_CREDENTIALS: return SEC_I_INCOMPLETE_CREDENTIALS;
        case PCT_ERR_RENEGOTIATE: return SEC_I_RENEGOTIATE;
        case PCT_ERR_UNKNOWN_CREDENTIAL: return SEC_E_UNKNOWN_CREDENTIALS;

        case CERT_E_UNTRUSTEDROOT:          return SEC_E_UNTRUSTED_ROOT;
        case CERT_E_EXPIRED:                return SEC_E_CERT_EXPIRED;
        case CERT_E_VALIDITYPERIODNESTING:  return SEC_E_CERT_EXPIRED;
        case CERT_E_REVOKED:                return CRYPT_E_REVOKED;
        case CERT_E_CN_NO_MATCH:            return SEC_E_WRONG_PRINCIPAL;

        case PCT_INT_BAD_CERT: return SEC_E_INVALID_TOKEN;
        case PCT_INT_CLI_AUTH: return SEC_E_INVALID_TOKEN;
        case PCT_INT_ILLEGAL_MSG: return  SEC_E_INVALID_TOKEN;
        case PCT_INT_SPECS_MISMATCH: return SEC_E_ALGORITHM_MISMATCH;
        case PCT_INT_INCOMPLETE_MSG: return SEC_E_INCOMPLETE_MESSAGE;
        case PCT_INT_MSG_ALTERED: return SEC_E_MESSAGE_ALTERED;
        case PCT_INT_INTERNAL_ERROR: return SEC_E_INTERNAL_ERROR;
        case PCT_INT_DATA_OVERFLOW: return SEC_E_INTERNAL_ERROR;
        case SEC_E_INCOMPLETE_CREDENTIALS: return SEC_E_INCOMPLETE_CREDENTIALS;
        case PCT_INT_RENEGOTIATE: return SEC_I_RENEGOTIATE;
        case PCT_INT_UNKNOWN_CREDENTIAL: return SEC_E_UNKNOWN_CREDENTIALS;

        case PCT_INT_BUFF_TOO_SMALL:                return SEC_E_BUFFER_TOO_SMALL;
        case SEC_E_BUFFER_TOO_SMALL:                return SEC_E_BUFFER_TOO_SMALL;

        default: return SEC_E_INTERNAL_ERROR;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SslGenerateRandomBits
//
//  Synopsis:   Hook for setup to get a good random stream
//
//  Arguments:  [pRandomData] --
//              [cRandomData] --
//
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
WINAPI
SslGenerateRandomBits(
    PUCHAR      pRandomData,
    LONG        cRandomData
    )
{
    if(!SchannelInit(TRUE))
    {
        return;
    }
    (void)GenerateRandomBits(pRandomData, (ULONG)cRandomData);
}


//+---------------------------------------------------------------------------
//
//  Function:   SslGenerateKeyPair
//
//  Synopsis:   Generates a public/private key pair, protected by password
//
//  Arguments:  [pCerts]      --
//              [pszDN]       --
//              [pszPassword] --
//              [Bits]        --
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
SslGenerateKeyPair(
    PSSL_CREDENTIAL_CERTIFICATE pCerts,
    PSTR pszDN,
    PSTR pszPassword,
    DWORD Bits )
{
    if(!SchannelInit(TRUE))
    {
        return FALSE;
    }

    return GenerateKeyPair(pCerts, pszDN, pszPassword, Bits);
}


//+---------------------------------------------------------------------------
//
//  Function:   SslGetMaximumKeySize
//
//  Synopsis:   Returns maximum public key size
//
//  Arguments:  [Reserved] --
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WINAPI
SslGetMaximumKeySize(
    DWORD   Reserved )
{
    UNREFERENCED_PARAMETER(Reserved);

    return( 2048 );
}


//+---------------------------------------------------------------------------
//
//  Function:   SslFreeCertificate
//
//  Synopsis:   Frees a certificate created from SslCrackCertificate
//
//  Arguments:  [pCertificate] --
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
WINAPI
SslFreeCertificate(
    PX509Certificate    pCertificate)
{
    if ( pCertificate )
    {

        SPExternalFree(pCertificate->pPublicKey);
        SPExternalFree(pCertificate);
    }
}




//+---------------------------------------------------------------------------
//
//  Function:   SslCrackCertificate
//
//  Synopsis:   Cracks a X509 certificate into remotely easy format
//
//  Arguments:  [pbCertificate] --
//              [cbCertificate] --
//              [dwFlags]       --
//              [ppCertificate] --
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
SslCrackCertificate(
    PUCHAR              pbCertificate,
    DWORD               cbCertificate,
    DWORD               dwFlags,
    PX509Certificate *  ppCertificate)
{


    PX509Certificate    pResult = NULL;
    PCCERT_CONTEXT      pContext = NULL;
    DWORD               cbIssuer;
    DWORD               cbSubject;

    if(!SchannelInit(TRUE))
    {
        return FALSE;
    }

    if (dwFlags & CF_CERT_FROM_FILE)
    {
        if (cbCertificate < CERT_HEADER_LEN + 1 )
        {
            goto error;
        }

        //
        // Sleazy quick check.  Some CAs wrap certs in a cert wrapper.
        // Some don't.  Some do both, but we won't mention any names.
        // Quick check for the wrapper tag.  If so, scoot in by enough
        // to bypass it (17 bytes. Sheesh).
        //

        if ( memcmp( pbCertificate + 4, CertTag, sizeof( CertTag ) ) == 0 )
        {
            pbCertificate += CERT_HEADER_LEN;
            cbCertificate -= CERT_HEADER_LEN;
        }
    }



    pContext = CertCreateCertificateContext(X509_ASN_ENCODING, pbCertificate, cbCertificate);
    if(pContext == NULL)
    {
        SP_LOG_RESULT(GetLastError());
        goto error;
    }

    if(0 >= (cbSubject = CertNameToStrA(pContext->dwCertEncodingType,
                                 &pContext->pCertInfo->Subject,
                                 CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                                 NULL, 0)))
    {
        SP_LOG_RESULT(GetLastError());
        goto error;
    }

    if(0 >= (cbIssuer = CertNameToStrA(pContext->dwCertEncodingType,
                                 &pContext->pCertInfo->Issuer,
                                 CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                                 NULL, 0)))
    {
        SP_LOG_RESULT(GetLastError());
        goto error;
    }


    pResult = SPExternalAlloc(sizeof(X509Certificate) + cbIssuer + cbSubject + 2);
    if(pResult == NULL)
    {
        goto error;
    }
    pResult->pPublicKey = NULL;
    pResult->pszIssuer = (LPSTR)(pResult + 1);
    pResult->pszSubject = pResult->pszIssuer + cbIssuer;

    pResult->Version = pContext->pCertInfo->dwVersion;
    memcpy(pResult->SerialNumber,
           pContext->pCertInfo->SerialNumber.pbData,
           min(sizeof(pResult->SerialNumber), pContext->pCertInfo->SerialNumber.cbData));
    pResult->ValidFrom = pContext->pCertInfo->NotBefore;
    pResult->ValidUntil = pContext->pCertInfo->NotAfter;

    if(0 >= CertNameToStrA(pContext->dwCertEncodingType,
                             &pContext->pCertInfo->Issuer,
                             CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                             pResult->pszIssuer, cbIssuer))
    {
        SP_LOG_RESULT(GetLastError());
        goto error;
    }

    if(0 >= CertNameToStrA(pContext->dwCertEncodingType,
                                 &pContext->pCertInfo->Subject,
                                 CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                                 pResult->pszSubject, cbSubject))
    {
        SP_LOG_RESULT(GetLastError());
        goto error;
    }

    {
        BSAFE_PUB_KEY *pk;
        PUBLICKEY  * pPubKey = NULL;
        SP_STATUS pctRet;

        pResult->pPublicKey = SPExternalAlloc(sizeof(PctPublicKey) + sizeof(BSAFE_PUB_KEY));
        if(pResult->pPublicKey == NULL)
        {
            goto error;
        }
        pResult->pPublicKey->Type = 0;
        pResult->pPublicKey->cbKey = sizeof(BSAFE_PUB_KEY);

        pk = (BSAFE_PUB_KEY *)pResult->pPublicKey->pKey;
        pk->magic = RSA1;

        pctRet = SPPublicKeyFromCert(pContext, &pPubKey, NULL);

        if(pctRet == PCT_ERR_OK)
        {
            if(pPubKey->pPublic->aiKeyAlg == CALG_RSA_KEYX)
            {
                RSAPUBKEY *pRsaKey = (RSAPUBKEY *)(pPubKey->pPublic + 1);
                pk->keylen = pRsaKey->bitlen/8;
                pk->bitlen = pRsaKey->bitlen;
                pk->datalen = pk->bitlen/8 - 1;
                pk->pubexp = pRsaKey->pubexp;
            }
            else
            {
                DHPUBKEY *pDHKey = (DHPUBKEY *)(pPubKey->pPublic + 1);
                pk->keylen = pDHKey->bitlen/8;
                pk->bitlen = pDHKey->bitlen/8;
                pk->datalen = pk->bitlen/8 - 1;
                pk->pubexp = 0;

            }
            SPExternalFree(pPubKey);
        }
        else
        {
            goto error;
        }

    }
    CertFreeCertificateContext(pContext);

    *ppCertificate = pResult;
    return TRUE;

error:
    if(pContext)
    {
        CertFreeCertificateContext(pContext);
    }
    if(pResult)
    {
        if(pResult->pPublicKey)
        {
            SPExternalFree(pResult->pPublicKey);
        }
        SPExternalFree(pResult);
    }
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   SslLoadCertificate
//
//  Synopsis:   Not supported.
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
WINAPI
SslLoadCertificate(
    PUCHAR      pbCertificate,
    DWORD       cbCertificate,
    BOOL        AddToWellKnownKeys)
{
    UNREFERENCED_PARAMETER(pbCertificate);
    UNREFERENCED_PARAMETER(cbCertificate);
    UNREFERENCED_PARAMETER(AddToWellKnownKeys);

    return FALSE;
}


BOOL
SslGetClientProcess(ULONG *pProcessID)
{
    SECPKG_CALL_INFO CallInfo;

    if(LsaTable == NULL)
    {
        *pProcessID = GetCurrentProcessId();
        return TRUE;
    }

    if(LsaTable->GetCallInfo(&CallInfo))
    {
        *pProcessID = CallInfo.ProcessId;
        return TRUE;
    }
    else
    {
        *pProcessID = (ULONG)-1;
        return FALSE;
    }
}

BOOL
SslGetClientThread(ULONG *pThreadID)
{
    SECPKG_CALL_INFO CallInfo;

    if(LsaTable == NULL)
    {
        *pThreadID = GetCurrentThreadId();
        return TRUE;
    }

    if(LsaTable->GetCallInfo(&CallInfo))
    {
        *pThreadID = CallInfo.ThreadId;
        return TRUE;
    }
    else
    {
        *pThreadID = (ULONG)-1;
        return FALSE;
    }
}

BOOL
SslImpersonateClient(void)
{
    SECPKG_CALL_INFO CallInfo;
    SECURITY_STATUS Status;

    // Don't impersonate if we're in the client process.
    if(LsaTable == NULL)
    {
        return FALSE;
    }

    // Don't impersonate if the client is running in the lsass process.
    if(LsaTable->GetCallInfo(&CallInfo))
    {
        if(CallInfo.ProcessId == GetCurrentProcessId())
        {
//            DebugLog((DEB_WARN, "Running locally, so don't impersonate.\n"));
            return FALSE;
        }
    }

    Status = LsaTable->ImpersonateClient();
    if(!NT_SUCCESS(Status))
    {
        SP_LOG_RESULT(Status);
        return FALSE;
    }

    return TRUE;
}

NTSTATUS
SslGetClientLogonId(LUID *pLogonId)
{
    SECPKG_CLIENT_INFO ClientInfo;
    SECURITY_STATUS Status;

    memset(pLogonId, 0, sizeof(LUID));

    Status = LsaTable->GetClientInfo(&ClientInfo);
    if(NT_SUCCESS(Status))
    {
        *pLogonId = ClientInfo.LogonId;
    }

    return Status;
}

PVOID SPExternalAlloc(DWORD cbLength)
{
    if(LsaTable)
    {
        // Lsass process
        return LsaTable->AllocateLsaHeap(cbLength);
    }
    else
    {
        // Application process
        return LocalAlloc(LPTR, cbLength);
    }
}

VOID SPExternalFree(PVOID pMemory)
{
    if(LsaTable)
    {
        // Lsass process
        LsaTable->FreeLsaHeap(pMemory);
    }
    else
    {
        // Application process
        LocalFree(pMemory);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\ssldebug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       debug.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-02-96   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __SSLDEBUG_H__
#define __SSLDEBUG_H__


#include <dsysdbg.h>

#if DBG

DECLARE_DEBUG2( Ssl );

#define DebugOut( x )   SslDebugPrint x

#else

#define DebugOut( x )

#endif

#define DEB_TRACE_FUNC      0x00000008      // Trace Function entry/exit
#define DEB_TRACE_CRED      0x00000010      // Trace Cred functions
#define DEB_TRACE_CTXT      0x00000020      // Trace Context functions
#define DEB_TRACE_MAPPER    0x00000040      // Trace Mapper

#define TRACE_ENTER( Func ) DebugOut(( DEB_TRACE_FUNC, "Entering " #Func "\n" ))

#define TRACE_EXIT( Func, Status ) DebugOut(( DEB_TRACE_FUNC, "Exiting " #Func ", code %x, line %d\n", Status, __LINE__ ));

VOID UnloadDebugSupport( VOID );
#endif //__SSLDEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\userctxt.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       userctxt.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-10-96   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __USERCTXT_H__
#define __USERCTXT_H__

typedef struct _SSL_USER_CONTEXT {
    LIST_ENTRY  List ;
    LSA_SEC_HANDLE LsaHandle;
    ULONG       Align;
    PSPContext  pContext;
} SSL_USER_CONTEXT, * PSSL_USER_CONTEXT ;

BOOL
SslInitContextManager(
    VOID
    );

SECURITY_STATUS
SslAddUserContext(
    IN LSA_SEC_HANDLE LsaHandle,
    IN HANDLE Token,    // optional
    IN PSecBuffer ContextData,
    IN BOOL fImportedContext);

PSSL_USER_CONTEXT
SslFindUserContext(
    IN LSA_SEC_HANDLE LsaHandle
    );

PSSL_USER_CONTEXT
SslFindUserContextEx(
    IN PCRED_THUMBPRINT pThumbprint
    );

VOID
SslDeleteUserContext(
    IN LSA_SEC_HANDLE LsaHandle
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\userctxt.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       userctxt.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-10-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "sslp.h"

#define             SCHANNEL_USERLIST_COUNT         (16)    // count of lists
#define             SCHANNEL_USERLIST_LOCK_COUNT    (2)     // count of locks

RTL_RESOURCE        SslContextLock[ SCHANNEL_USERLIST_LOCK_COUNT ];
LIST_ENTRY          SslContextList[ SCHANNEL_USERLIST_COUNT ] ;

ULONG
HandleToListIndex(
    ULONG_PTR ContextHandle
    );

ULONG
__inline
ListIndexToLockIndex(
    ULONG ListIndex
    );



//+---------------------------------------------------------------------------
//
//  Function:   SslInitContextManager
//
//  Synopsis:   Initializes the context manager controls
//
//  History:    10-10-96   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
SslInitContextManager(
    VOID
    )
{
    ULONG Index;
    NTSTATUS Status = STATUS_SUCCESS;

    for( Index=0 ; Index < SCHANNEL_USERLIST_LOCK_COUNT ; Index++ )
    {
        __try {
            RtlInitializeResource (&SslContextLock[Index]);
        } __except(EXCEPTION_EXECUTE_HANDLER)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
    }

    if( !NT_SUCCESS(Status) )
    {
        DebugLog(( DEB_ERROR, "SslInitContextManager failed!\n" ));
        return FALSE;
    }

    for( Index = 0 ; Index < SCHANNEL_USERLIST_COUNT ; Index++ )
    {
        InitializeListHead( &SslContextList[Index] );
    }

    return( TRUE );
}

#if 0
VOID
SslFreeUserContextElements(PSPContext pContext)
{
    if(pContext->hReadKey)
    {
        if(!CryptDestroyKey(pContext->hReadKey))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hReadKey = 0;

    if(pContext->hReadMAC)
    {
        if(!CryptDestroyKey(pContext->hReadMAC))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hReadMAC = 0;

    if(pContext->hWriteKey)
    {
        if(!CryptDestroyKey(pContext->hWriteKey))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hWriteKey = 0;

    if(pContext->hWriteMAC)
    {
        if(!CryptDestroyKey(pContext->hWriteMAC))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hWriteMAC = 0;
}
#endif

SECURITY_STATUS
SslAddUserContext(
    IN LSA_SEC_HANDLE LsaHandle,
    IN HANDLE Token,    // optional
    IN PSecBuffer ContextData,
    IN BOOL fImportedContext)
{
    PSSL_USER_CONTEXT Context ;
    SP_STATUS Status ;
    ULONG ListIndex;
    ULONG LockIndex;

    DebugLog(( DEB_TRACE, "SslAddUserContext: 0x%p\n", LsaHandle ));

    if ( ContextData->cbBuffer < sizeof( SPPackedContext ) )
    {
        return( SEC_E_INVALID_TOKEN );
    }

    if(!fImportedContext)
    {
        Context = SslFindUserContext( LsaHandle );

        if ( Context )
        {
            DebugLog(( DEB_TRACE, "Replacing existing context!\n" ));

            // Destroy elements of existing context.
            LsaContextDelete(Context->pContext);
            SPExternalFree(Context->pContext);
            Context->pContext = NULL;

            Status = SPContextDeserialize( ContextData->pvBuffer,
                                           &Context->pContext);

            if(Status != PCT_ERR_OK)
            {
                return SP_LOG_RESULT(SEC_E_DECRYPT_FAILURE);
            }

            return( SEC_E_OK );
        }
    }

    Context = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                        sizeof( SSL_USER_CONTEXT ));

    if ( !Context )
    {
        return( SEC_E_INSUFFICIENT_MEMORY );
    }

    Status = SPContextDeserialize( ContextData->pvBuffer,
                                   &Context->pContext);

    if(Status != PCT_ERR_OK)
    {
        LocalFree(Context);
        return SP_LOG_RESULT(SEC_E_DECRYPT_FAILURE);
    }

    if(ARGUMENT_PRESENT(Token))
    {
        Context->pContext->RipeZombie->hLocator = (HLOCATOR)Token;
    }

    Context->LsaHandle = LsaHandle ;
    Context->Align = ContextData->cbBuffer ;

    ListIndex = HandleToListIndex( LsaHandle );
    LockIndex = ListIndexToLockIndex( ListIndex );

    RtlAcquireResourceExclusive( &SslContextLock[LockIndex], TRUE );

    InsertTailList( &SslContextList[ListIndex], &Context->List );

    RtlReleaseResource( &SslContextLock[LockIndex] );

    return( SEC_E_OK );
}

PSSL_USER_CONTEXT
SslReferenceUserContext(
    IN LSA_SEC_HANDLE LsaHandle,
    IN BOOLEAN        Delete
    )
{
    PLIST_ENTRY List ;
    PSSL_USER_CONTEXT Context = NULL ;
    ULONG ListIndex;
    ULONG LockIndex;

    ListIndex = HandleToListIndex( LsaHandle );
    LockIndex = ListIndexToLockIndex( ListIndex );

    if( !Delete )
    {
        RtlAcquireResourceShared( &SslContextLock[LockIndex], TRUE );
    } else {
        RtlAcquireResourceExclusive( &SslContextLock[LockIndex], TRUE );
    }

    List = SslContextList[ListIndex].Flink ;

    while ( List != &SslContextList[ListIndex] )
    {
        Context = CONTAINING_RECORD( List, SSL_USER_CONTEXT, List.Flink );

        if ( Context->LsaHandle == LsaHandle )
        {
            if( Delete )
            {
                RemoveEntryList( &Context->List );
            }

            break;
        }

        Context = NULL ;

        List = List->Flink ;
    }

    RtlReleaseResource( &SslContextLock[LockIndex] );

    return( Context );
}

PSSL_USER_CONTEXT
SslFindUserContext(
    IN LSA_SEC_HANDLE LsaHandle
    )
{
    return SslReferenceUserContext( LsaHandle, FALSE );
}

PSSL_USER_CONTEXT
SslFindUserContextEx(
    IN PCRED_THUMBPRINT pThumbprint
    )
{
    PLIST_ENTRY List ;
    PSSL_USER_CONTEXT Context = NULL ;
    ULONG ListIndex;
    ULONG LockIndex;

    DebugLog(( DEB_TRACE, "SslFindUserContextEx: \n"));

    for (ListIndex = 0 ; ListIndex < SCHANNEL_USERLIST_COUNT ; ListIndex++)
    {
        LockIndex = ListIndexToLockIndex( ListIndex );
        RtlAcquireResourceShared( &SslContextLock[LockIndex], TRUE );

        List = SslContextList[ListIndex].Flink ;

        while ( List != &SslContextList[ListIndex] )
        {
            Context = CONTAINING_RECORD( List, SSL_USER_CONTEXT, List.Flink );

            if(Context->pContext != NULL &&
               IsSameThumbprint(pThumbprint, &Context->pContext->ContextThumbprint))
            {
                RtlReleaseResource( &SslContextLock[LockIndex] );
                goto done;
            }

            List = List->Flink ;
        }

        RtlReleaseResource( &SslContextLock[LockIndex] );
    }

    Context = NULL ;

done:

    return( Context );
}

VOID
SslDeleteUserContext(
    IN LSA_SEC_HANDLE LsaHandle
    )
{
    PSSL_USER_CONTEXT Context ;

    Context = SslReferenceUserContext( LsaHandle, TRUE );

    if ( Context )
    {
        DebugLog(( DEB_TRACE, "Deleting user mode context %x, handle = %x\n",
                        Context, LsaHandle ));

        LsaContextDelete(Context->pContext);
        SPExternalFree(Context->pContext);
        LocalFree( Context );

    }
    else
    {
        DebugLog(( DEB_TRACE, "No context found for handle %x\n", LsaHandle ));
    }
}


ULONG
HandleToListIndex(
    ULONG_PTR ContextHandle
    )
{
    
    ULONG Number ;
    ULONG Hash;
    ULONG HashFinal;

    ASSERT( (SCHANNEL_USERLIST_COUNT != 0) );
    ASSERT( (SCHANNEL_USERLIST_COUNT & 1) == 0 );

    Number       = (ULONG)ContextHandle;

    Hash         = Number;
    Hash        += Number >> 8;
    Hash        += Number >> 16;
    Hash        += Number >> 24;

    HashFinal    = Hash;
    HashFinal   += Hash >> 4;

    //
    // insure power of two if not one.
    //

    return ( HashFinal & (SCHANNEL_USERLIST_COUNT-1) ) ;
}

ULONG
__inline
ListIndexToLockIndex(
    ULONG ListIndex
    )
{
    ASSERT( (SCHANNEL_USERLIST_LOCK_COUNT) != 0 );
    ASSERT( (SCHANNEL_USERLIST_LOCK_COUNT & 1) == 0 );

    //
    // insure power of two if not one.
    //
    
    return ( ListIndex & (SCHANNEL_USERLIST_LOCK_COUNT-1) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\spreg.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       spreg.c
//
//  Contents:   Schannel registry management routines. 
//
//  Classes:
//
//  Functions:
//
//  History:    11-24-97   jbanes   Enabled TLS
//
//----------------------------------------------------------------------------

#include <sslp.h>
#include "spreg.h"
#include <mapper.h>
#include <sidfilter.h>

HKEY   g_hkBase      = NULL;
HANDLE g_hParamEvent = NULL;
HANDLE g_hWait       = NULL;

HKEY   g_hkFipsBase      = NULL;
HANDLE g_hFipsParamEvent = NULL;
HANDLE g_hFipsWait       = NULL;

BOOL g_fManualCredValidation        = MANUAL_CRED_VALIDATION_SETTING;
BOOL g_PctClientDisabledByDefault   = PCT_CLIENT_DISABLED_SETTING;
BOOL g_Ssl2ClientDisabledByDefault  = SSL2_CLIENT_DISABLED_SETTING;

DWORD g_dwEventLogging              = DEFAULT_EVENT_LOGGING_SETTING;
DWORD g_ProtEnabled                 = DEFAULT_ENABLED_PROTOCOLS_SETTING; 

BOOL g_fSendIssuerList              = TRUE;

DWORD g_dwCertMappingMethods        = DEFAULT_CERTMAP_SETTING;

BOOL g_fFipsMode = FALSE;
BOOL g_fFranceLocale = FALSE;

BOOL g_SslS4U2SelfInitialized = FALSE;

typedef struct enamap
{
    TCHAR *pKey;
    DWORD Mask;
} enamap;

enamap g_ProtMap[] =
{
    {SP_REG_KEY_PCT1 TEXT("\\") SP_REG_KEY_CLIENT, SP_PROT_PCT1_CLIENT},
    {SP_REG_KEY_PCT1 TEXT("\\") SP_REG_KEY_SERVER, SP_PROT_PCT1_SERVER},
    {SP_REG_KEY_SSL2 TEXT("\\") SP_REG_KEY_CLIENT, SP_PROT_SSL2_CLIENT},
    {SP_REG_KEY_SSL2 TEXT("\\") SP_REG_KEY_SERVER, SP_PROT_SSL2_SERVER},
    {SP_REG_KEY_SSL3 TEXT("\\") SP_REG_KEY_CLIENT, SP_PROT_SSL3_CLIENT},
    {SP_REG_KEY_SSL3 TEXT("\\") SP_REG_KEY_SERVER, SP_PROT_SSL3_SERVER},
    {SP_REG_KEY_TLS1 TEXT("\\") SP_REG_KEY_CLIENT, SP_PROT_TLS1_CLIENT},
    {SP_REG_KEY_TLS1 TEXT("\\") SP_REG_KEY_SERVER, SP_PROT_TLS1_SERVER}
};

VOID
SslWatchParamKey(
    PVOID    pCtxt,
    BOOLEAN  fWaitStatus);

VOID
FipsWatchParamKey(
    PVOID    pCtxt,
    BOOLEAN  fWaitStatus);

BOOL 
SslReadRegOptions(
    BOOL fFirstTime);

BOOL SPLoadRegOptions(void)
{
    g_hParamEvent = CreateEvent(NULL,
                           FALSE,
                           FALSE,
                           NULL);

    SslWatchParamKey(g_hParamEvent, FALSE);

    g_hFipsParamEvent = CreateEvent(NULL,
                           FALSE,
                           FALSE,
                           NULL);

    FipsWatchParamKey(g_hFipsParamEvent, FALSE);

    return TRUE;
}

void SPUnloadRegOptions(void)
{
    if (NULL != g_hWait) 
    {
        RtlDeregisterWait(g_hWait);
        g_hWait = NULL;
    }

    if(NULL != g_hkBase)
    {
        RegCloseKey(g_hkBase);
    }

    if(NULL != g_hParamEvent)
    {
        CloseHandle(g_hParamEvent);
    }

    if (NULL != g_hFipsWait) 
    {
        RtlDeregisterWait(g_hFipsWait);
        g_hFipsWait = NULL;
    }

    if(NULL != g_hkFipsBase)
    {
        RegCloseKey(g_hkFipsBase);
    }

    if(NULL != g_hFipsParamEvent)
    {
        CloseHandle(g_hFipsParamEvent);
    }
}

BOOL
ReadRegistrySetting(
    HKEY    hReadKey,
    HKEY    hWriteKey,
    LPCTSTR pszValueName,
    DWORD * pdwValue,
    DWORD   dwDefaultValue)
{
    DWORD dwSize;
    DWORD dwType;
    DWORD dwOriginalValue = *pdwValue;

    dwSize = sizeof(DWORD);
    if(RegQueryValueEx(hReadKey, 
                       pszValueName, 
                       NULL, 
                       &dwType, 
                       (PUCHAR)pdwValue, 
                       &dwSize) != STATUS_SUCCESS)
    {
        *pdwValue = dwDefaultValue;

        if(hWriteKey)
        {
            RegSetValueEx(hWriteKey, 
                          pszValueName, 
                          0, 
                          REG_DWORD, 
                          (PUCHAR)pdwValue, 
                          sizeof(DWORD));
        }
    }

    return (dwOriginalValue != *pdwValue);
}


////////////////////////////////////////////////////////////////////
//
//  Name:       SslWatchParamKey
//
//  Synopsis:   Sets RegNotifyChangeKeyValue() on param key, initializes
//              debug level, then utilizes thread pool to wait on
//              changes to this registry key.  Enables dynamic debug
//              level changes, as this function will also be callback
//              if registry key modified.
//
//  Arguments:  pCtxt is actually a HANDLE to an event.  This event
//              will be triggered when key is modified.
//
//  Notes:      .
//
VOID
SslWatchParamKey(
    PVOID    pCtxt,
    BOOLEAN  fWaitStatus)
{
    NTSTATUS    Status;
    LONG        lRes = ERROR_SUCCESS;
    BOOL        fFirstTime = FALSE;
    DWORD       disp;

    UNREFERENCED_PARAMETER(fWaitStatus);

    if(g_hkBase == NULL)
    {
        // First time we've been called.
        Status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                SP_REG_KEY_BASE,
                                0,
                                TEXT(""),
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ,
                                NULL,
                                &g_hkBase,
                                &disp);
        if(Status)
        {
            DebugLog((DEB_WARN,"Failed to open SCHANNEL key: 0x%x\n", Status));
            return;
        }

        fFirstTime = TRUE;
    }

    if(pCtxt != NULL)
    {
        if (NULL != g_hWait) 
        {
            Status = RtlDeregisterWait(g_hWait);
            if(!NT_SUCCESS(Status))
            {
                DebugLog((DEB_WARN, "Failed to Deregister wait on registry key: 0x%x\n", Status));
                goto Reregister;
            }
        }

        lRes = RegNotifyChangeKeyValue(
                    g_hkBase,
                    TRUE,
                    REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                    (HANDLE)pCtxt,
                    TRUE);

        if (ERROR_SUCCESS != lRes) 
        {
            DebugLog((DEB_ERROR,"Debug RegNotify setup failed: 0x%x\n", lRes));
            // we're tanked now. No further notifications, so get this one
        }
    }

    SslReadRegOptions(fFirstTime);

#if DBG
    InitDebugSupport(g_hkBase);
#endif

Reregister:

    if(pCtxt != NULL)
    {
        Status = RtlRegisterWait(&g_hWait,
                                 (HANDLE)pCtxt,
                                 SslWatchParamKey,
                                 (HANDLE)pCtxt,
                                 INFINITE,
                                 WT_EXECUTEINPERSISTENTIOTHREAD|
                                 WT_EXECUTEONLYONCE);
    }
}                       


////////////////////////////////////////////////////////////////////
//
//  Name:       FipsWatchParamKey
//
//  Synopsis:   Sets RegNotifyChangeKeyValue() on param key, initializes
//              debug level, then utilizes thread pool to wait on
//              changes to this registry key.  Enables dynamic debug
//              level changes, as this function will also be callback
//              if registry key modified.
//
//  Arguments:  pCtxt is actually a HANDLE to an event.  This event
//              will be triggered when key is modified.
//
//  Notes:      .
//
VOID
FipsWatchParamKey(
    PVOID    pCtxt,
    BOOLEAN  fWaitStatus)
{
    NTSTATUS    Status;
    LONG        lRes = ERROR_SUCCESS;
    DWORD       disp;

    UNREFERENCED_PARAMETER(fWaitStatus);

    if(g_hkFipsBase == NULL)
    {
        // First time we've been called.
        Status = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                SP_REG_FIPS_BASE_KEY,
                                0,
                                TEXT(""),
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ,
                                NULL,
                                &g_hkFipsBase,
                                &disp);
        if(Status)
        {
            DebugLog((DEB_WARN,"Failed to open FIPS key: 0x%x\n", Status));
            return;
        }
    }

    if(pCtxt != NULL)
    {
        if (NULL != g_hFipsWait) 
        {
            Status = RtlDeregisterWait(g_hFipsWait);
            if(!NT_SUCCESS(Status))
            {
                DebugLog((DEB_WARN, "Failed to Deregister wait on registry key: 0x%x\n", Status));
                goto Reregister;
            }
        }

        lRes = RegNotifyChangeKeyValue(
                    g_hkFipsBase,
                    TRUE,
                    REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                    (HANDLE)pCtxt,
                    TRUE);

        if (ERROR_SUCCESS != lRes) 
        {
            DebugLog((DEB_ERROR,"Debug RegNotify setup failed: 0x%x\n", lRes));
            // we're tanked now. No further notifications, so get this one
        }
    }

    SslReadRegOptions(FALSE);

Reregister:

    if(pCtxt != NULL)
    {
        Status = RtlRegisterWait(&g_hFipsWait,
                                 (HANDLE)pCtxt,
                                 FipsWatchParamKey,
                                 (HANDLE)pCtxt,
                                 INFINITE,
                                 WT_EXECUTEINPERSISTENTIOTHREAD|
                                 WT_EXECUTEONLYONCE);
    }
}                       

                        
BOOL 
SslReadRegOptions(
    BOOL fFirstTime)
{
    DWORD       err;
    DWORD       dwType;
    DWORD       fVal;
    DWORD       dwSize;
    HKEY        hKey;
    HKEY        hWriteKey;
    DWORD       disp;
    DWORD       i;
    HKEY        hkProtocols = NULL;
    HKEY        hkCiphers = NULL;
    HKEY        hkHashes = NULL;
    HKEY        hkKeyExch = NULL;
    DWORD       dwSetting = 0;
    BOOL        fSettingsChanged = FALSE;
    DWORD       dwOriginalValue;

    DebugLog((DEB_TRACE,"Load configuration parameters from registry.\n"));


    // "FipsAlgorithmPolicy"
    ReadRegistrySetting(
        g_hkFipsBase,
        0,
        SP_REG_FIPS_POLICY,
        &dwSetting,
        0);
    if((dwSetting == 1) != g_fFipsMode)
    {
        g_fFipsMode = (dwSetting == 1);
        fSettingsChanged = TRUE;
    }


    //
    // Read top-level configuration options.
    //

    // Open top-level key that has write access.
    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    SP_REG_KEY_BASE,
                    0,
                    KEY_READ | KEY_SET_VALUE,
                    &hWriteKey) != STATUS_SUCCESS)
    {
        hWriteKey = 0;
    }

    // "EventLogging"
    if(ReadRegistrySetting(
        g_hkBase,
        hWriteKey,
        SP_REG_VAL_EVENTLOG,
        &g_dwEventLogging,
        DEFAULT_EVENT_LOGGING_SETTING))
    {
        fSettingsChanged = TRUE;
    }

    // "ManualCredValidation"
    ReadRegistrySetting(
        g_hkBase,
        0,
        SP_REG_VAL_MANUAL_CRED_VALIDATION,
        &dwSetting,
        MANUAL_CRED_VALIDATION_SETTING);
    if((dwSetting != 0) != g_fManualCredValidation)
    {
        g_fManualCredValidation = (dwSetting != 0);
        fSettingsChanged = TRUE;
    }

    // "ClientCacheTime"
    if(ReadRegistrySetting(
        g_hkBase,
        0,
        SP_REG_VAL_CLIENT_CACHE_TIME,
        &SchannelCache.dwClientLifespan,
        SP_CACHE_CLIENT_LIFESPAN))
    {
        fSettingsChanged = TRUE;
    }

    // "ServerCacheTime"
    if(ReadRegistrySetting(
        g_hkBase,
        0,
        SP_REG_VAL_SERVER_CACHE_TIME,
        &SchannelCache.dwServerLifespan,
        SP_CACHE_SERVER_LIFESPAN))
    {
        fSettingsChanged = TRUE;
    }

    // "MaximumCacheSize"
    if(ReadRegistrySetting(
        g_hkBase,
        0,
        SP_REG_VAL_MAXUMUM_CACHE_SIZE,
        &SchannelCache.dwMaximumEntries,
        SP_MAXIMUM_CACHE_ELEMENTS))
    {
        fSettingsChanged = TRUE;
    }
     
    if(fFirstTime)
    {
        SchannelCache.dwCacheSize = SchannelCache.dwMaximumEntries;
    }

    // "MultipleProcessClientCache"
    ReadRegistrySetting(
        g_hkBase,
        0,
        SP_REG_VAL_MULTI_PROC_CLIENT_CACHE,
        &dwSetting,
        FALSE);
    if((dwSetting != 0) != g_fMultipleProcessClientCache)
    {
        g_fMultipleProcessClientCache = (dwSetting != 0);
        fSettingsChanged = TRUE;
    }

    // "SendTrustedIssuerList"
    ReadRegistrySetting(
        g_hkBase,
        0,
        SP_REG_VAL_SEND_ISSUER_LIST,
        &dwSetting,
        TRUE);
    if((dwSetting != 0) != g_fSendIssuerList)
    {
        g_fSendIssuerList = (dwSetting != 0);
        fSettingsChanged = TRUE;
    }

    // "CertificateMappingMethods"
    if(ReadRegistrySetting(
        g_hkBase,
        0,
        SP_REG_VAL_CERT_MAPPING_METHODS,
        &g_dwCertMappingMethods,
        DEFAULT_CERTMAP_SETTING))
    {
        fSettingsChanged = TRUE;

        if((g_dwCertMappingMethods & SP_REG_CERTMAP_SUBJECT_FLAG) == 0)
        {
            DebugLog((DEB_TRACE, "Subject/Issuer certificate mapping disabled\n"));
        }
        if((g_dwCertMappingMethods & SP_REG_CERTMAP_ISSUER_FLAG) == 0)
        {
            DebugLog((DEB_TRACE, "Issuer certificate mapping disabled\n"));
        }
        if((g_dwCertMappingMethods & SP_REG_CERTMAP_UPN_FLAG) == 0)
        {
            DebugLog((DEB_TRACE, "UPN certificate mapping disabled\n"));
        }
        if((g_dwCertMappingMethods & SP_REG_CERTMAP_S4U2SELF_FLAG) == 0)
        {
            DebugLog((DEB_TRACE, "S4U2Self certificate mapping disabled\n"));
        }
    }

    if(hWriteKey)
    {
        RegCloseKey(hWriteKey);
        hWriteKey = 0;
    }


    // "IssuerCacheTime"
    ReadRegistrySetting(
        g_hkBase,
        0,
        SP_REG_VAL_ISSUER_CACHE_TIME,
        &IssuerCache.dwLifespan,
        ISSUER_CACHE_LIFESPAN);

    // "IssuerCacheSize"
    ReadRegistrySetting(
        g_hkBase,
        0,
        SP_REG_VAL_ISSUER_CACHE_SIZE,
        &IssuerCache.dwMaximumEntries,
        ISSUER_CACHE_SIZE);

    if(fFirstTime)
    {
        IssuerCache.dwCacheSize = IssuerCache.dwMaximumEntries;
    }


#ifdef ROGUE_DC
    if(g_hSslRogueKey == NULL)
    {
        if(RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                         SP_REG_ROGUE_BASE_KEY,
                         0,
                         KEY_READ,
                         &g_hSslRogueKey) != STATUS_SUCCESS)
        {
            DebugLog((DEB_WARN,"Failed to open \"rogue\" ssl key\n" ));
            g_hSslRogueKey = NULL;
        }
    }
#endif


    //
    // Enable/Disable Protocols
    //

    if(g_fFipsMode)
    {
        // Disable everything except TLS.
        g_ProtEnabled = SP_PROT_TLS1;
    }
    else
    {
        DWORD dwProtEnabled = DEFAULT_ENABLED_PROTOCOLS_SETTING; 

        err = RegCreateKeyEx(   g_hkBase,
                                SP_REG_KEY_PROTOCOL,
                                0,
                                TEXT(""),
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ,
                                NULL,
                                &hkProtocols,
                                &disp);

        if(err == ERROR_SUCCESS)
        {
            for(i=0; i < (sizeof(g_ProtMap)/sizeof(enamap)); i++)
            {
                if(g_ProtMap[i].Mask & SP_PROT_PCT1)
                {
                    if(g_fFranceLocale)
                    {
                        // Don't allow PCT to be enabled in France.
                        continue;
                    }
                }

                err = RegCreateKeyEx(   hkProtocols,
                                        g_ProtMap[i].pKey,
                                        0,
                                        TEXT(""),
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ,
                                        NULL,
                                        &hKey,
                                        &disp);
                if(!err)
                {
                    dwSize = sizeof(DWORD);
                    err = RegQueryValueEx(hKey, 
                                          SP_REG_VAL_ENABLED, 
                                          NULL, &dwType, 
                                          (PUCHAR)&fVal, 
                                          &dwSize);
                    if(!err)
                    {
                        if(fVal)
                        {
                            dwProtEnabled |= g_ProtMap[i].Mask;
                        }
                        else
                        {
                            dwProtEnabled &= ~g_ProtMap[i].Mask;
                        }
                    }

                    if(g_ProtMap[i].Mask & SP_PROT_PCT1_CLIENT)
                    {
                        // "DisabledByDefault"
                        ReadRegistrySetting(
                            hKey,
                            0,
                            SP_REG_VAL_DISABLED_BY_DEFAULT,
                            &dwSetting,
                            PCT_CLIENT_DISABLED_SETTING);
                        g_PctClientDisabledByDefault = (dwSetting != 0);
                    }

                    if(g_ProtMap[i].Mask & SP_PROT_SSL2_CLIENT)
                    {
                        // "DisabledByDefault"
                        ReadRegistrySetting(
                            hKey,
                            0,
                            SP_REG_VAL_DISABLED_BY_DEFAULT,
                            &dwSetting,
                            SSL2_CLIENT_DISABLED_SETTING);
                        g_Ssl2ClientDisabledByDefault =  (dwSetting != 0);
                    }

                    RegCloseKey(hKey);
                }
            }

            RegCloseKey(hkProtocols);
        }

        if(g_ProtEnabled != dwProtEnabled)
        {
            g_ProtEnabled = dwProtEnabled;
            fSettingsChanged = TRUE;
        }
    }


    //
    // Enable/Disable Ciphers
    //

    if(g_fFipsMode)
    {
        // Disable everything except 3DES.
        for(i=0; i < g_cAvailableCiphers; i++)
        {
            if(g_AvailableCiphers[i].aiCipher != CALG_3DES)
            {
                g_AvailableCiphers[i].fProtocol = 0;
            }
        }
    }
    else
    {
        err = RegCreateKeyEx(   g_hkBase,
                                SP_REG_KEY_CIPHERS,
                                0,
                                TEXT(""),
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ,
                                NULL,
                                &hkCiphers,
                                &disp);

        if(err == ERROR_SUCCESS)
        {
            for(i=0; i < g_cAvailableCiphers; i++)
            {
                dwOriginalValue = g_AvailableCiphers[i].fProtocol;
                
                g_AvailableCiphers[i].fProtocol = g_AvailableCiphers[i].fDefault;
                fVal = g_AvailableCiphers[i].fDefault;
                err = RegCreateKeyExA(  hkCiphers,
                                        g_AvailableCiphers[i].szName,
                                        0,
                                        "",
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ,
                                        NULL,
                                        &hKey,
                                        &disp);
                if(!err)
                {
                    dwSize = sizeof(DWORD);
                    err = RegQueryValueEx(hKey, 
                                          SP_REG_VAL_ENABLED, 
                                          NULL, 
                                          &dwType, 
                                          (PUCHAR)&fVal, 
                                          &dwSize);
                    if(err)
                    {
                        fVal = g_AvailableCiphers[i].fDefault;
                    }
                    RegCloseKey(hKey);
                }
                g_AvailableCiphers[i].fProtocol &= fVal;

                if(g_AvailableCiphers[i].fProtocol != dwOriginalValue)
                {
                    fSettingsChanged = TRUE;
                }
            }

            RegCloseKey(hkCiphers);
        }
    }


    //
    // Enable/Disable Hashes
    //

    err = RegCreateKeyEx(   g_hkBase,
                            SP_REG_KEY_HASHES,
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ,
                            NULL,
                            &hkHashes,
                            &disp);

    if(err == ERROR_SUCCESS)
    {
        for(i = 0; i < g_cAvailableHashes; i++)
        {
            dwOriginalValue = g_AvailableHashes[i].fProtocol;

            g_AvailableHashes[i].fProtocol = g_AvailableHashes[i].fDefault;
            fVal = g_AvailableHashes[i].fDefault;
            err = RegCreateKeyExA(  hkHashes,
                                    g_AvailableHashes[i].szName,
                                    0,
                                    "",
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_READ,
                                    NULL,
                                    &hKey,
                                    &disp);
            if(!err)
            {
                dwSize = sizeof(DWORD);
                err = RegQueryValueEx(hKey, 
                                      SP_REG_VAL_ENABLED, 
                                      NULL, 
                                      &dwType, 
                                      (PUCHAR)&fVal, 
                                      &dwSize);

                if(err)
                {
                    fVal = g_AvailableHashes[i].fDefault;
                }
                RegCloseKey(hKey);
            }
            g_AvailableHashes[i].fProtocol &= fVal;

            if(dwOriginalValue != g_AvailableHashes[i].fProtocol)
            {
                fSettingsChanged = TRUE;
            }
        }

        RegCloseKey(hkHashes);
    }


    //
    // Enable/Disable Key Exchange algs.
    //

    if(g_fFipsMode)
    {
        // Disable everything except RSA.
        for(i=0; i < g_cAvailableExch; i++)
        {
            if(g_AvailableExch[i].aiExch != CALG_RSA_KEYX && 
               g_AvailableExch[i].aiExch != CALG_RSA_SIGN)
            {
                g_AvailableExch[i].fProtocol = 0;
            }
        }
    }
    else
    {
        err = RegCreateKeyEx(   g_hkBase,
                                SP_REG_KEY_KEYEXCH,
                                0,
                                TEXT(""),
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ,
                                NULL,
                                &hkKeyExch,
                                &disp);

        if(err == ERROR_SUCCESS)
        {
            for(i = 0; i < g_cAvailableExch; i++)
            {
                dwOriginalValue = g_AvailableExch[i].fProtocol;

                g_AvailableExch[i].fProtocol = g_AvailableExch[i].fDefault;
                fVal = g_AvailableExch[i].fDefault;
                err = RegCreateKeyExA(  hkKeyExch,
                                        g_AvailableExch[i].szName,
                                        0,
                                        "",
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ,
                                        NULL,
                                        &hKey,
                                        &disp);
                if(!err)
                {
                    dwSize = sizeof(DWORD);
                    err = RegQueryValueEx(hKey, 
                                          SP_REG_VAL_ENABLED, 
                                          NULL, 
                                          &dwType, 
                                          (PUCHAR)&fVal, 
                                          &dwSize);
                    if(err)
                    {
                        fVal = g_AvailableExch[i].fDefault;
                    }
                    g_AvailableExch[i].fProtocol &= fVal;

                    RegCloseKey(hKey);
                }

                if(dwOriginalValue != g_AvailableExch[i].fProtocol)
                {
                    fSettingsChanged = TRUE;
                }
            }

            RegCloseKey(hkKeyExch);
        }
    }

    //
    // Purge the session cache.
    //

    if(g_fCacheInitialized && fSettingsChanged)
    {
        SPCachePurgeEntries(NULL,
                            0,
                            NULL,
                            SSL_PURGE_CLIENT_ALL_ENTRIES |
                            SSL_PURGE_SERVER_ALL_ENTRIES);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\lsa\usermode.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       usermode.c
//
//  Contents:   User mode functions
//
//  Classes:
//
//  Functions:
//
//  History:    10-08-96   RichardW   Created
//
//----------------------------------------------------------------------------

#include "sslp.h"
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <pct1msg.h>
#include <mapper.h>

// Counter for exported handles
ULONG_PTR ExportedContext = 0;


SECURITY_STATUS
UpdateContextUsrToLsa(IN LSA_SEC_HANDLE hContextHandle);


SECPKG_USER_FUNCTION_TABLE  SslTable[ 2 ] =
    {
        {
            SpInstanceInit,
            SpInitUserModeContext,
            SpMakeSignature,
            SpVerifySignature,
            SpSealMessage,
            SpUnsealMessage,
            SpGetContextToken,
            SpUserQueryContextAttributes,
            SpCompleteAuthToken,
            SpDeleteUserModeContext,
            SpFormatCredentials,
            SpMarshallSupplementalCreds,
            SpExportSecurityContext,
            SpImportSecurityContext
        },

        {
            SpInstanceInit,
            SpInitUserModeContext,
            SpMakeSignature,
            SpVerifySignature,
            SpSealMessage,
            SpUnsealMessage,
            SpGetContextToken,
            SpUserQueryContextAttributes,
            SpCompleteAuthToken,
            SpDeleteUserModeContext,
            SpFormatCredentials,
            SpMarshallSupplementalCreds,
            SpExportSecurityContext,
            SpImportSecurityContext
        }
    };

NTSTATUS
SEC_ENTRY
SpUserModeInitialize(
    IN ULONG    LsaVersion,
    OUT PULONG  PackageVersion,
    OUT PSECPKG_USER_FUNCTION_TABLE * UserFunctionTable,
    OUT PULONG  pcTables)
{
    if (LsaVersion != SECPKG_INTERFACE_VERSION)
    {
        DebugLog((DEB_ERROR,"Invalid LSA version: %d\n", LsaVersion));
        return(STATUS_INVALID_PARAMETER);
    }

    *PackageVersion = SECPKG_INTERFACE_VERSION ;

    *UserFunctionTable = &SslTable[0] ;
    *pcTables = 2;

    SslInitContextManager();

    return( STATUS_SUCCESS );

}

NTSTATUS NTAPI
SpInstanceInit(
    IN ULONG Version,
    IN PSECPKG_DLL_FUNCTIONS DllFunctionTable,
    OUT PVOID * UserFunctionTable
    )
{
    NTSTATUS Status;
    DWORD i;

    UNREFERENCED_PARAMETER(Version);
    UNREFERENCED_PARAMETER(UserFunctionTable);

    // Register callback functions.
    for(i = 0; i < g_cSchannelCallbacks; i++)
    {
        Status = DllFunctionTable->RegisterCallback(
                                    g_SchannelCallbacks[i].dwTag,
                                    g_SchannelCallbacks[i].pFunction);
        if(Status != STATUS_SUCCESS)
        {
            return Status;
        }
    }

    return(STATUS_SUCCESS);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpDeleteUserModeContext
//
//  Synopsis:   Deletes a user mode context by unlinking it and then
//              dereferencing it.
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa context handle of the context to delete
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, STATUS_INVALID_HANDLE if the
//              context can't be located
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpDeleteUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle
    )
{
    SslDeleteUserContext( ContextHandle );

    return( SEC_E_OK );

}


//+-------------------------------------------------------------------------
//
//  Function:   SpInitUserModeContext
//
//  Synopsis:   Creates a user-mode context from a packed LSA mode context
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa mode context handle for the context
//              PackedContext - A marshalled buffer containing the LSA
//                  mode context.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpInitUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBuffer PackedContext
    )
{
    SECURITY_STATUS scRet ;

    if(!SchannelInit(TRUE))
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    scRet = SslAddUserContext( ContextHandle, NULL, PackedContext, FALSE );

    if ( NT_SUCCESS( scRet ) )
    {
        if(g_pFreeContextBuffer)
        {
            g_pFreeContextBuffer( PackedContext->pvBuffer );
        }
    }

    return( scRet );
}


//+-------------------------------------------------------------------------
//
//  Function:   SpMakeSignature
//
//  Synopsis:   Signs a message buffer by calculatinga checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              QualityOfProtection - Unused flags.
//              MessageBuffers - Contains an array of buffers to sign and
//                      to store the signature.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found.
//              STATUS_BUFFER_TOO_SMALL - the signature buffer is too small
//                      to hold the signature
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpMakeSignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber
    )
{
    UNREFERENCED_PARAMETER(ContextHandle);
    UNREFERENCED_PARAMETER(QualityOfProtection);
    UNREFERENCED_PARAMETER(MessageBuffers);
    UNREFERENCED_PARAMETER(MessageSequenceNumber);

    return( SEC_E_UNSUPPORTED_FUNCTION );
}

//+-------------------------------------------------------------------------
//
//  Function:   SpVerifySignature
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



NTSTATUS NTAPI
SpVerifySignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    UNREFERENCED_PARAMETER(ContextHandle);
    UNREFERENCED_PARAMETER(MessageBuffers);
    UNREFERENCED_PARAMETER(MessageSequenceNumber);
    UNREFERENCED_PARAMETER(QualityOfProtection);

    return( SEC_E_UNSUPPORTED_FUNCTION );
}

NTSTATUS NTAPI
SpSealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSequenceNumber
    )
{
    PSSL_USER_CONTEXT   Context ;
    PSPContext          pContext;
    PSecBuffer          pHdrBuffer;
    PSecBuffer          pDataBuffer;
    PSecBuffer          pTlrBuffer;
    PSecBuffer          pTokenBuffer;
    SP_STATUS           pctRet = PCT_ERR_OK;
    SPBuffer            CommOut;
    SPBuffer            AppIn;
    DWORD               cbBuffer;
    BOOL                fAlloced = FALSE;
    BOOL                fConnectionMode = FALSE;
    int i;

    UNREFERENCED_PARAMETER(QualityOfProtection);
    UNREFERENCED_PARAMETER(MessageSequenceNumber);

    SP_BEGIN("SpSealMessage");

    Context = SslFindUserContext( ContextHandle );

    if ( !Context )
    {
        SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_HANDLE) );
    }

    pContext = Context->pContext;

    if(pContext == NULL)
    {
        SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_HANDLE) );
    }

    if(!(pContext->State & SP_STATE_CONNECTED) || !pContext->Encrypt)
    {
        SP_RETURN( SP_LOG_RESULT(SEC_E_CONTEXT_EXPIRED) );
    }

    //
    // Find the buffer with the data:
    //

    pHdrBuffer = NULL;
    pDataBuffer = NULL;
    pTlrBuffer = NULL;
    pTokenBuffer = NULL;

    /* Gibraltar passes in the following,
     * a TOKEN buffer (or SECBUFFER_STREAM_HEADER)
     * a DATA buffer
     * a TOKEN buffer (or SECBUFFER_STREAM_TRAILER)
     * or we can get a connection mode as in
     * DATA buffer
     * Token buffer
     */

    if(0 == (pContext->Flags & CONTEXT_FLAG_CONNECTION_MODE))
    {
        // Stream Mode
        // The output buffer should be a concatenation of
        // the header buffer, Data buffer, and Trailer buffers.
        for (i = 0 ; i < (int)pMessage->cBuffers ; i++ )
        {
            switch(pMessage->pBuffers[i].BufferType)
            {
                case SECBUFFER_STREAM_HEADER:
                     pHdrBuffer = &pMessage->pBuffers[i];
                     break;

                case SECBUFFER_DATA :
                     pDataBuffer = &pMessage->pBuffers[i];
                     if(pHdrBuffer == NULL) pHdrBuffer = pDataBuffer;
                     break;

                case SECBUFFER_STREAM_TRAILER:
                     pTlrBuffer = &pMessage->pBuffers[i];
                     break;

                case SECBUFFER_TOKEN:
                     if(pHdrBuffer == NULL)
                     {
                         pHdrBuffer = &pMessage->pBuffers[i];
                     }
                     else if(pTlrBuffer == NULL)
                     {
                         pTlrBuffer = &pMessage->pBuffers[i];
                     }
                     break;
                default:
                    break;
            }
        }

        if (!pHdrBuffer || !pDataBuffer )
        {
            SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_TOKEN) );
        }

#if DBG
        DebugLog((DEB_TRACE, "Header (uninitialized): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pHdrBuffer->cbBuffer,
            pHdrBuffer->pvBuffer));

        DebugLog((DEB_TRACE, "Data (plaintext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pDataBuffer->cbBuffer,
            pDataBuffer->pvBuffer));
        DBG_HEX_STRING(DEB_BUFFERS, pDataBuffer->pvBuffer, pDataBuffer->cbBuffer);

        if(pTlrBuffer)
        {
            DebugLog((DEB_TRACE, "Trailer (uninitialized): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
                pTlrBuffer->cbBuffer,
                pTlrBuffer->pvBuffer));
        }
#endif

        // Now, figure out if all of the buffers are contiguous, if not, then we
        // have to allocate a buffer
        fAlloced = FALSE;

        if((PUCHAR)pDataBuffer->pvBuffer !=
           ((PUCHAR)pHdrBuffer->pvBuffer + pHdrBuffer->cbBuffer))
        {
            fAlloced = TRUE;
        }
        if(pTlrBuffer)
        {
            if((PUCHAR)pTlrBuffer->pvBuffer !=
               ((PUCHAR)pDataBuffer->pvBuffer + pDataBuffer->cbBuffer))
            {
                fAlloced = TRUE;
            }
        }

        if(!fAlloced)
        {
            // All of our buffers are contiguous, so we do
            // not need to allocate a contiguous buffer.
            pTokenBuffer = pHdrBuffer;

            AppIn.pvBuffer = pDataBuffer->pvBuffer;
            AppIn.cbData   = pDataBuffer->cbBuffer;
            AppIn.cbBuffer = pDataBuffer->cbBuffer;

            CommOut.pvBuffer = pHdrBuffer->pvBuffer;
            CommOut.cbData   = 0;
            CommOut.cbBuffer = pHdrBuffer->cbBuffer + pDataBuffer->cbBuffer;
            if(pTlrBuffer)
            {
                CommOut.cbBuffer += pTlrBuffer->cbBuffer;
                AppIn.cbBuffer += pTlrBuffer->cbBuffer;
            }
        }
        else
        {
            // Our buffers are not contiguous, so we must allocate a contiguous
            // buffer to do our work in.

            // Calculate the size of the buffer
            CommOut.cbBuffer = pHdrBuffer->cbBuffer + pDataBuffer->cbBuffer;
            if(pTlrBuffer)
            {
                CommOut.cbBuffer += pTlrBuffer->cbBuffer;
            }
            // Allocate the buffer
            CommOut.pvBuffer = SPExternalAlloc(CommOut.cbBuffer);
            if(CommOut.pvBuffer == NULL)
            {
                SP_RETURN( SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY) );
            }

            // Copy data to encrypt to the buffer
            CommOut.cbData = 0;
            AppIn.pvBuffer = (PBYTE)CommOut.pvBuffer + pHdrBuffer->cbBuffer;
            AppIn.cbBuffer = CommOut.cbBuffer - pHdrBuffer->cbBuffer;
            AppIn.cbData   = pDataBuffer->cbBuffer;
            CopyMemory((PBYTE)AppIn.pvBuffer, (PBYTE)pDataBuffer->pvBuffer,  pDataBuffer->cbBuffer);
        }

        pctRet = pContext->Encrypt(pContext,
                                   &AppIn,
                                   &CommOut);

        if(pctRet == PCT_ERR_OK)
        {
            // Set the various buffer sizes.
            cbBuffer = CommOut.cbData;

            // The first few bytes always go in the header buffer.
            pHdrBuffer->cbBuffer = min(cbBuffer, pHdrBuffer->cbBuffer);
            cbBuffer -= pHdrBuffer->cbBuffer;

            if(pTlrBuffer)
            {
                // The output data buffer is the same size as the input data buffer.
                pDataBuffer->cbBuffer = min(cbBuffer, pDataBuffer->cbBuffer);
                cbBuffer -= pDataBuffer->cbBuffer;

                // The trailer buffer gets the data that's left over.
                pTlrBuffer->cbBuffer = min(cbBuffer, pTlrBuffer->cbBuffer);
                cbBuffer -= pTlrBuffer->cbBuffer;
            }
            else
            {
                pDataBuffer->cbBuffer = min(cbBuffer, pDataBuffer->cbBuffer);
                cbBuffer -= pDataBuffer->cbBuffer;
            }

            if(fAlloced)
            {

                // If we allocated the buffer, then we must copy

                CopyMemory(pHdrBuffer->pvBuffer,
                           CommOut.pvBuffer,
                           pHdrBuffer->cbBuffer);


                CopyMemory(pDataBuffer->pvBuffer,
                           (PUCHAR)CommOut.pvBuffer + pHdrBuffer->cbBuffer,
                           pDataBuffer->cbBuffer);

                if(pTlrBuffer)
                {
                    CopyMemory(pTlrBuffer->pvBuffer,
                               (PUCHAR)CommOut.pvBuffer + pHdrBuffer->cbBuffer + pDataBuffer->cbBuffer,
                               pTlrBuffer->cbBuffer);
                }
            }

#if DBG
            DebugLog((DEB_TRACE, "Header (ciphertext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
                pHdrBuffer->cbBuffer,
                pHdrBuffer->pvBuffer));
            DBG_HEX_STRING(DEB_BUFFERS, pHdrBuffer->pvBuffer, pHdrBuffer->cbBuffer);

            DebugLog((DEB_TRACE, "Data (ciphertext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
                pDataBuffer->cbBuffer,
                pDataBuffer->pvBuffer));
            DBG_HEX_STRING(DEB_BUFFERS, pDataBuffer->pvBuffer, pDataBuffer->cbBuffer);

            if(pTlrBuffer)
            {
                DebugLog((DEB_TRACE, "Trailer (ciphertext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
                    pTlrBuffer->cbBuffer,
                    pTlrBuffer->pvBuffer));
                DBG_HEX_STRING(DEB_BUFFERS, pTlrBuffer->pvBuffer, pTlrBuffer->cbBuffer);
            }
#endif

        }
    }
    else
    {
        // We're doing connection mode, so unpack buffers as a
        // Data and then Token buffer
        fConnectionMode = TRUE;
        for (i = 0 ; i < (int)pMessage->cBuffers ; i++ )
        {
            switch(pMessage->pBuffers[i].BufferType)
            {
                case SECBUFFER_DATA :
                     pDataBuffer = &pMessage->pBuffers[i];
                     break;


                case SECBUFFER_TOKEN:
                     if(pTokenBuffer == NULL)
                     {
                         pTokenBuffer = &pMessage->pBuffers[i];
                     }
                     break;
                default:
                    break;
            }
        }
        if((pTokenBuffer == NULL) || (pDataBuffer == NULL))
        {
            SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_TOKEN) );
        }

        if((pDataBuffer->pvBuffer == NULL) || (pTokenBuffer->pvBuffer == NULL))
        {
            SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_TOKEN) );
        }

#if DBG
        DebugLog((DEB_TRACE, "Data (plaintext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pDataBuffer->cbBuffer,
            pDataBuffer->pvBuffer));
        DBG_HEX_STRING(DEB_BUFFERS, pDataBuffer->pvBuffer, pDataBuffer->cbBuffer);

        DebugLog((DEB_TRACE, "Token (uninitialized): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pTokenBuffer->cbBuffer,
            pTokenBuffer->pvBuffer));
#endif

        // Connection Mode
        // The output should get written to a concatenation of the
        // data buffer and the token buffer.  If no token buffer is
        // given, then we should allocate one.

        if((PUCHAR)pTokenBuffer->pvBuffer ==
           ((PUCHAR)pDataBuffer->pvBuffer + pDataBuffer->cbBuffer))
        {
            // If the buffers are contiguous, we can optimize!
            CommOut.pvBuffer = pDataBuffer->pvBuffer;
            CommOut.cbData   = 0;
            CommOut.cbBuffer = pDataBuffer->cbBuffer + pTokenBuffer->cbBuffer;
        }
        else
        {
            // We have to realloc the buffer
            fAlloced = TRUE;
            CommOut.pvBuffer = SPExternalAlloc(pDataBuffer->cbBuffer + pTokenBuffer->cbBuffer);
            if(CommOut.pvBuffer == NULL)
            {
                SP_RETURN( SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY) );
            }
            CommOut.cbBuffer = pDataBuffer->cbBuffer + pTokenBuffer->cbBuffer;
            CommOut.cbData = 0;
        }

        // The data buffer always goes to AppIn
        AppIn.pvBuffer = pDataBuffer->pvBuffer;
        AppIn.cbData   = pDataBuffer->cbBuffer;
        AppIn.cbBuffer = pDataBuffer->cbBuffer;

        pctRet = pContext->Encrypt(pContext,
                                   &AppIn,
                                   &CommOut);

        if(pctRet == PCT_ERR_OK)
        {
            // Set the various buffer sizes.
            cbBuffer = CommOut.cbData;

            // The first few bytes always go into the data buffer.
            pDataBuffer->cbBuffer = min(cbBuffer, pDataBuffer->cbBuffer);
            cbBuffer -= pDataBuffer->cbBuffer;

            // The remaining bytes go into the token buffer.
            pTokenBuffer->cbBuffer = min(cbBuffer, pTokenBuffer->cbBuffer);

            if(fAlloced)
            {
                // We encrypted into our temporary buffer, so we must
                // copy.
                CopyMemory(pDataBuffer->pvBuffer,
                           CommOut.pvBuffer,
                           pDataBuffer->cbBuffer);

                CopyMemory(pTokenBuffer->pvBuffer,
                           (PUCHAR)CommOut.pvBuffer + pDataBuffer->cbBuffer,
                           pTokenBuffer->cbBuffer);
            }
        }

#if DBG
        DebugLog((DEB_TRACE, "Data (ciphertext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pDataBuffer->cbBuffer,
            pDataBuffer->pvBuffer));
        DBG_HEX_STRING(DEB_BUFFERS, pDataBuffer->pvBuffer, pDataBuffer->cbBuffer);

        DebugLog((DEB_TRACE, "Token (ciphertext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pTokenBuffer->cbBuffer,
            pTokenBuffer->pvBuffer));
        DBG_HEX_STRING(DEB_BUFFERS, pTokenBuffer->pvBuffer, pTokenBuffer->cbBuffer);
#endif

    }

    if(fAlloced)
    {
        SPExternalFree(CommOut.pvBuffer);
    }

    SP_RETURN( PctTranslateError(pctRet) );
}

NTSTATUS NTAPI
SpUnsealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    // Output Buffer Types
    PSSL_USER_CONTEXT   Context ;
    PSecBuffer  pHdrBuffer;
    PSecBuffer  pDataBuffer;
    PSecBuffer  pTokenBuffer;
    PSecBuffer  pTlrBuffer;
    PSecBuffer  pExtraBuffer;
    SP_STATUS   pctRet = PCT_ERR_OK;
    SPBuffer    CommIn;
    SPBuffer    AppOut = {0};
    PSPContext  pContext;
    DWORD       cbHeaderSize;
    BOOL        fAlloced = FALSE;
    SECURITY_STATUS scRet;
    int i;

    UNREFERENCED_PARAMETER(MessageSequenceNumber);
    UNREFERENCED_PARAMETER(QualityOfProtection);

    SP_BEGIN("SpUnsealMessage");

    Context = SslFindUserContext( ContextHandle );

    if ( !Context )
    {
        SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_HANDLE) );
    }

    pContext = Context->pContext;

    if(pContext == NULL)
    {
        SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_HANDLE) );
    }

    if(!(pContext->State & SP_STATE_CONNECTED))
    {
        SP_RETURN( SP_LOG_RESULT(SEC_E_CONTEXT_EXPIRED) );
    }

    //
    // Set up output buffers:
    //

    pHdrBuffer = NULL;
    pDataBuffer = NULL;
    pTokenBuffer = NULL;
    pTlrBuffer = NULL;
    pExtraBuffer = NULL;

    // On input, the buffers can either be
    // DataBuffer
    // TokenBuffer
    //
    // or
    //
    // Data Buffer
    // Empty
    // Empty
    // Empty
    //

    // on Output, the buffers are
    // DataBuffer
    // TokenBuffer
    //
    // or
    // HdrBuffer
    // DataBuffer
    // Tlrbuffer
    // Extrabuffer or Empty

    if(0 == (pContext->Flags & CONTEXT_FLAG_CONNECTION_MODE))
    {
        // Stream Mode
        // The output buffer should be a concatenation of
        // the header buffer, Data buffer, and Trailer buffers.

        for (i = 0 ; i < (int)pMessage->cBuffers ; i++ )
        {
            switch(pMessage->pBuffers[i].BufferType)
            {
                case SECBUFFER_DATA:
                    // The message data buffer on input will be the hdr buffer on
                    // output.
                    pHdrBuffer = &pMessage->pBuffers[i];
                    break;

                case SECBUFFER_EMPTY:
                    if(pDataBuffer == NULL)
                    {
                        pDataBuffer = &pMessage->pBuffers[i];
                    }
                    else if (pTlrBuffer == NULL)
                    {
                        pTlrBuffer = &pMessage->pBuffers[i];
                    }
                    else if (pExtraBuffer == NULL)
                    {
                        pExtraBuffer = &pMessage->pBuffers[i];
                    }
                    break;

                default:
                    break;
            }
        }

        if(!pHdrBuffer || !pDataBuffer || !pTlrBuffer || !pExtraBuffer)
        {
            SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_TOKEN) );
        }
        if(pHdrBuffer->pvBuffer == NULL)
        {
            SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_TOKEN) );
        }

#if DBG
        DebugLog((DEB_TRACE, "Data (ciphertext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pHdrBuffer->cbBuffer,
            pHdrBuffer->pvBuffer));
        DBG_HEX_STRING(DEB_BUFFERS, pHdrBuffer->pvBuffer, pHdrBuffer->cbBuffer);
#endif

        CommIn.pvBuffer = pHdrBuffer->pvBuffer;
        CommIn.cbData   = pHdrBuffer->cbBuffer;
        CommIn.cbBuffer = pHdrBuffer->cbBuffer;

        pctRet = pContext->GetHeaderSize(pContext, &CommIn, &cbHeaderSize);

        if(pctRet == PCT_ERR_OK)
        {
            AppOut.pvBuffer = (PUCHAR)CommIn.pvBuffer + cbHeaderSize;
            AppOut.cbData   = 0;
            AppOut.cbBuffer = CommIn.cbData-cbHeaderSize;

            pctRet = pContext->DecryptHandler(pContext,
                                       &CommIn,
                                       &AppOut);
        }

        if((pctRet == PCT_ERR_OK) ||
           (pctRet == PCT_INT_RENEGOTIATE))
        {
            if(CommIn.cbData < pHdrBuffer->cbBuffer)
            {
                pExtraBuffer->BufferType = SECBUFFER_EXTRA;
                pExtraBuffer->cbBuffer = pHdrBuffer->cbBuffer-CommIn.cbData;
                pExtraBuffer->pvBuffer = (PUCHAR)pHdrBuffer->pvBuffer+CommIn.cbData;
            }
            else
            {
                pExtraBuffer = NULL;
            }
            pHdrBuffer->BufferType = SECBUFFER_STREAM_HEADER;
            pHdrBuffer->cbBuffer = cbHeaderSize;

            pDataBuffer->BufferType = SECBUFFER_DATA;
            pDataBuffer->pvBuffer = AppOut.pvBuffer;
            pDataBuffer->cbBuffer = AppOut.cbData;

            pTlrBuffer->BufferType = SECBUFFER_STREAM_TRAILER;
            pTlrBuffer->pvBuffer = (PUCHAR)pDataBuffer->pvBuffer + AppOut.cbData;
            pTlrBuffer->cbBuffer = CommIn.cbBuffer-(AppOut.cbData+cbHeaderSize);

#if DBG
            DebugLog((DEB_TRACE, "Header (plaintext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
                pHdrBuffer->cbBuffer,
                pHdrBuffer->pvBuffer));
            DBG_HEX_STRING(DEB_BUFFERS, pHdrBuffer->pvBuffer, pHdrBuffer->cbBuffer);

            DebugLog((DEB_TRACE, "Data (plaintext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
                pDataBuffer->cbBuffer,
                pDataBuffer->pvBuffer));
            DBG_HEX_STRING(DEB_BUFFERS, pDataBuffer->pvBuffer, pDataBuffer->cbBuffer);

            DebugLog((DEB_TRACE, "Trailer (plaintext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
                pTlrBuffer->cbBuffer,
                pTlrBuffer->pvBuffer));
            DBG_HEX_STRING(DEB_BUFFERS, pTlrBuffer->pvBuffer, pTlrBuffer->cbBuffer);

            if(pExtraBuffer)
            {
                DebugLog((DEB_TRACE, "Extra (ciphertext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
                    pExtraBuffer->cbBuffer,
                    pExtraBuffer->pvBuffer));
                    DBG_HEX_STRING(DEB_BUFFERS, pExtraBuffer->pvBuffer, pExtraBuffer->cbBuffer);
            }
#endif

            if(pctRet == PCT_INT_RENEGOTIATE)
            {
                // Wow.  Need to notify the lsa mode portion of the context that
                // the caller is about to call AcceptSecurityContext again, and
                // not to panic.  So, we cruft up a magic "token" that we
                // pass along in ApplyControlToken:
                scRet = UpdateContextUsrToLsa(ContextHandle);
                if(FAILED(scRet))
                {
                    SP_RETURN( SP_LOG_RESULT(scRet) );
                }
            }

        }
        else if(pctRet == PCT_INT_INCOMPLETE_MSG)
        {
            pDataBuffer->BufferType = SECBUFFER_MISSING;
            pDataBuffer->cbBuffer = CommIn.cbData - pHdrBuffer->cbBuffer;

            /* This is a hack to work with old code that was designed to work with
             * the old SSL. */

            pHdrBuffer->BufferType = SECBUFFER_MISSING;
            pHdrBuffer->cbBuffer = CommIn.cbData - pHdrBuffer->cbBuffer;
        }
    }
    else
    {
        // Connection Mode
        for (i = 0 ; i < (int)pMessage->cBuffers ; i++ )
        {
            switch(pMessage->pBuffers[i].BufferType)
            {
                case SECBUFFER_DATA :
                     pDataBuffer = &pMessage->pBuffers[i];
                     break;


                case SECBUFFER_TOKEN:
                     if(pTokenBuffer == NULL)
                     {
                         pTokenBuffer = &pMessage->pBuffers[i];
                     }
                     break;
                default:
                    break;
            }
        }
        if((pTokenBuffer == NULL) || (pDataBuffer == NULL))
        {
            SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_TOKEN) );
        }

        if((pDataBuffer->pvBuffer == NULL) || (pTokenBuffer->pvBuffer == NULL))
        {
            SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_TOKEN) );
        }

#if DBG
        DebugLog((DEB_TRACE, "Data (ciphertext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pDataBuffer->cbBuffer,
            pDataBuffer->pvBuffer));
        DBG_HEX_STRING(DEB_BUFFERS, pDataBuffer->pvBuffer, pDataBuffer->cbBuffer);

        DebugLog((DEB_TRACE, "Token (ciphertext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pTokenBuffer->cbBuffer,
            pTokenBuffer->pvBuffer));
        DBG_HEX_STRING(DEB_BUFFERS, pTokenBuffer->pvBuffer, pTokenBuffer->cbBuffer);
#endif

        // The Data and Token buffers are concatenated together to
        // form a single input buffer.
        if((PUCHAR)pDataBuffer->pvBuffer + pDataBuffer->cbBuffer ==
           (PUCHAR)pTokenBuffer->pvBuffer)
        {
            // Speed Opt,  If the buffers really are just one big buffer
            // then we can party on them directly.
            CommIn.pvBuffer = pDataBuffer->pvBuffer;
            CommIn.cbData   = pDataBuffer->cbBuffer + pTokenBuffer->cbBuffer;
            CommIn.cbBuffer = CommIn.cbData;
        }
        else
        {
            // We have to allocate a uniform input buffer
            CommIn.cbData   = pDataBuffer->cbBuffer + pTokenBuffer->cbBuffer;
            CommIn.pvBuffer = SPExternalAlloc(CommIn.cbData);
            if(CommIn.pvBuffer == NULL)
            {
                SP_RETURN( SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY) );
            }
            CommIn.cbBuffer = CommIn.cbData;
            CopyMemory(CommIn.pvBuffer,  pDataBuffer->pvBuffer,  pDataBuffer->cbBuffer);

            CopyMemory((PUCHAR)CommIn.pvBuffer + pDataBuffer->cbBuffer,
                       pTokenBuffer->pvBuffer,
                       pTokenBuffer->cbBuffer);
            fAlloced = TRUE;

        }

        AppOut.pvBuffer = pDataBuffer->pvBuffer;
        AppOut.cbData   = 0;
        AppOut.cbBuffer = pDataBuffer->cbBuffer;

        pctRet = pContext->DecryptHandler(pContext,
                           &CommIn,
                           &AppOut);


        if((pctRet == PCT_ERR_OK) ||
           (pctRet == PCT_INT_RENEGOTIATE))
        {
            pDataBuffer->cbBuffer  = AppOut.cbData;
            pTokenBuffer->cbBuffer = CommIn.cbData - AppOut.cbData;
        }

        if(fAlloced)
        {
            SPExternalFree(CommIn.pvBuffer);
        }

#if DBG
        DebugLog((DEB_TRACE, "Data (plaintext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pDataBuffer->cbBuffer,
            pDataBuffer->pvBuffer));
        DBG_HEX_STRING(DEB_BUFFERS, pDataBuffer->pvBuffer, pDataBuffer->cbBuffer);

        DebugLog((DEB_TRACE, "Token (plaintext): cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
            pTokenBuffer->cbBuffer,
            pTokenBuffer->pvBuffer));
        DBG_HEX_STRING(DEB_BUFFERS, pTokenBuffer->pvBuffer, pTokenBuffer->cbBuffer);
#endif

    }

    DebugOut(( DEB_TRACE, "Unseal returns %x \n", PctTranslateError( pctRet ) ));

    SP_RETURN( PctTranslateError(pctRet) );
}


//+-------------------------------------------------------------------------
//
//  Function:   SpGetContextToken
//
//  Synopsis:   returns a pointer to the token for a server-side context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
SpGetContextToken(
    IN LSA_SEC_HANDLE ContextHandle,
    OUT PHANDLE ImpersonationToken
    )
{
    PSSL_USER_CONTEXT   Context;
    PSPContext          pContext;
    PSessCacheItem      pZombie;

    Context = SslFindUserContext( ContextHandle );

    if ( !Context )
    {
        return( SEC_E_INVALID_HANDLE );
    }

    pContext = Context->pContext;

    if(pContext == NULL)
    {
        SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_HANDLE) );
    }

    pZombie  = pContext->RipeZombie;

    if(pZombie == NULL || 
       pZombie->hLocator == 0)
    {
        if(pZombie->LocatorStatus)
        {
            return(SP_LOG_RESULT(pZombie->LocatorStatus));
        }
        else
        {
            return(SP_LOG_RESULT(SEC_E_NO_IMPERSONATION));
        }
    }

    *ImpersonationToken = (HANDLE)pZombie->hLocator;

    return( SEC_E_OK );
}


//+-------------------------------------------------------------------------
//
//  Function:   SpCompleteAuthToken
//
//  Synopsis:   Completes a context (in Kerberos case, does nothing)
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
NTAPI
SpCompleteAuthToken(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc InputBuffer
    )
{
    UNREFERENCED_PARAMETER(ContextHandle);
    UNREFERENCED_PARAMETER(InputBuffer);

    return(STATUS_SUCCESS);
}


NTSTATUS NTAPI
SpFormatCredentials(
    IN PSecBuffer Credentials,
    OUT PSecBuffer FormattedCredentials
    )
{
    UNREFERENCED_PARAMETER(Credentials);
    UNREFERENCED_PARAMETER(FormattedCredentials);

    return(STATUS_NOT_SUPPORTED);
}

NTSTATUS NTAPI
SpMarshallSupplementalCreds(
    IN ULONG CredentialSize,
    IN PUCHAR Credentials,
    OUT PULONG MarshalledCredSize,
    OUT PVOID * MarshalledCreds
    )
{
    UNREFERENCED_PARAMETER(CredentialSize);
    UNREFERENCED_PARAMETER(Credentials);
    UNREFERENCED_PARAMETER(MarshalledCredSize);
    UNREFERENCED_PARAMETER(MarshalledCreds);

    return(STATUS_NOT_SUPPORTED);
}


//+---------------------------------------------------------------------------
//
//  Function:   UpdateContextUsrToLsa
//
//  Synopsis:   UnsealMessage has just received a redo request, so push the
//              read key over to the LSA process.
//
//  Arguments:  [hLsaContext]   --  Handle to LSA schannel context.
//
//  History:    10-20-97   jbanes   Added CAPI integration.
//
//  Notes:      The format of the buffer sent to ApplyControlToken is:
//
//                  DWORD   dwOperation;    // SCHANNEL_RENEGOTIATE
//                  DWORD   dwNewState;
//
//----------------------------------------------------------------------------
SECURITY_STATUS
UpdateContextUsrToLsa(
    IN LSA_SEC_HANDLE hLsaContext)
{
    PSSL_USER_CONTEXT pUserContext;
    PSPContext  pContext;
    CtxtHandle  hMyContext;
    SecBuffer   RedoNotify;
    SecBufferDesc RedoDesc;
    SECURITY_STATUS scRet;

    PBYTE pbBuffer;
    DWORD cbBuffer;


    pUserContext = SslFindUserContext( hLsaContext );
    if ( !pUserContext )
    {
        return SEC_E_INVALID_HANDLE;
    }

    pContext = pUserContext->pContext;

    if(pContext == NULL)
    {
        SP_RETURN( SP_LOG_RESULT(SEC_E_INVALID_HANDLE) );
    }

    hMyContext.dwLower = (DWORD_PTR) GetCurrentThread() ;
    hMyContext.dwUpper = hLsaContext ;


    //
    // Compute size of output buffer.
    //

    cbBuffer = sizeof(DWORD) * 2;


    //
    // Allocate memory for output buffer.
    //

    pbBuffer = SPExternalAlloc( cbBuffer);
    if(pbBuffer == NULL)
    {
        return SEC_E_INSUFFICIENT_MEMORY;
    }

    RedoNotify.BufferType = SECBUFFER_TOKEN;
    RedoNotify.cbBuffer   = cbBuffer;
    RedoNotify.pvBuffer   = pbBuffer;

    RedoDesc.ulVersion    = SECBUFFER_VERSION ;
    RedoDesc.pBuffers     = &RedoNotify ;
    RedoDesc.cBuffers     = 1 ;


    //
    // Build output buffer.
    //

    *(PDWORD)pbBuffer = SCHANNEL_RENEGOTIATE;
    pbBuffer += sizeof(DWORD);

    *(PDWORD)pbBuffer = pContext->State;
    pbBuffer += sizeof(DWORD);


    //
    // Call ApplyControlToken
    //

    DebugOut(( DEB_TRACE, "Sending state change to LSA since we're renegotiating\n" ));

    scRet = ApplyControlToken( &hMyContext, &RedoDesc );

    LocalFree(RedoNotify.pvBuffer);

    return scRet;
}

BOOL
SslEmptyCacheA(LPSTR  pszTargetName,
               DWORD  dwFlags)
{
    ANSI_STRING String;
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    BOOL fSuccess;

    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = 0;
    UnicodeString.Buffer = NULL;

    // Convert target name to unicode.
    if(pszTargetName)
    {
        RtlInitAnsiString(&String, pszTargetName);

        Status =  RtlAnsiStringToUnicodeString(&UnicodeString,
                                               &String,
                                               TRUE);
        if(!NT_SUCCESS(Status))
        {
            SetLastError(SP_LOG_RESULT((DWORD)SEC_E_INSUFFICIENT_MEMORY));
            return FALSE;
        }
    }

    // Call unicode version of function.
    fSuccess = SslEmptyCacheW(UnicodeString.Buffer, dwFlags);

    if(UnicodeString.Buffer)
    {
        RtlFreeUnicodeString(&UnicodeString);
    }
    
    return fSuccess;
}

BOOL
SslEmptyCacheW(LPWSTR pszTargetName,
               DWORD  dwFlags)
{
    HANDLE LsaHandle = 0;
    DWORD PackageNumber;
    LSA_STRING PackageName;
    PSSL_PURGE_SESSION_CACHE_REQUEST pRequest = NULL;
    DWORD cbTargetName;
    DWORD cbRequest;
    NTSTATUS Status;
    NTSTATUS SubStatus;

    UNREFERENCED_PARAMETER(dwFlags);

    Status = LsaConnectUntrusted(&LsaHandle);

    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }

    RtlInitAnsiString(&PackageName, SCHANNEL_NAME_A);

    Status = LsaLookupAuthenticationPackage(
                    LsaHandle,
                    &PackageName,
                    &PackageNumber);
    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }

    cbRequest = sizeof(SSL_PURGE_SESSION_CACHE_REQUEST);

    if(pszTargetName == NULL)
    {
        pRequest = SPExternalAlloc(cbRequest);
        if(pRequest == NULL)
        {
            Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }
    }
    else
    {
        cbTargetName  = (lstrlen(pszTargetName) + 1) * sizeof(WCHAR);
        cbRequest += cbTargetName;

        pRequest = SPExternalAlloc(cbRequest);
        if(pRequest == NULL)
        {
            Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        memcpy(pRequest + 1, pszTargetName, cbTargetName);

        pRequest->ServerName.Buffer        = (LPWSTR)(pRequest + 1);
        pRequest->ServerName.Length        = (WORD)(wcslen(pszTargetName) * sizeof(WCHAR));
        pRequest->ServerName.MaximumLength = (WORD)cbTargetName;
    }

    pRequest->MessageType = SSL_PURGE_CACHE_MESSAGE;

    pRequest->Flags = SSL_PURGE_CLIENT_ENTRIES | SSL_PURGE_SERVER_ENTRIES;


    Status = LsaCallAuthenticationPackage(
                    LsaHandle,
                    PackageNumber,
                    pRequest,
                    cbRequest,
                    NULL,
                    NULL,
                    &SubStatus);
    if(FAILED(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }

    if(FAILED(SubStatus))
    {
        Status = SP_LOG_RESULT(SubStatus);
    }

cleanup:

    if(LsaHandle)
    {
        CloseHandle(LsaHandle);
    }

    if(pRequest)
    {
        SPExternalFree(pRequest);
    }

    if(FAILED(Status))
    {
        SetLastError(Status);
        return FALSE;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpExportSecurityContext
//
//  Synopsis:   Exports a security context to another process
//
//  Effects:    Allocates memory for output
//
//  Arguments:  ContextHandle - handle to context to export
//              Flags - Flags concerning duplication. Allowable flags:
//                      SECPKG_CONTEXT_EXPORT_DELETE_OLD - causes old context
//                              to be deleted.
//              PackedContext - Receives serialized context to be freed with
//                      FreeContextBuffer
//              TokenHandle - Optionally receives handle to context's token.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
NTAPI 
SpExportSecurityContext(
    LSA_SEC_HANDLE       ContextHandle,         // (in) context to export
    ULONG                fFlags,                // (in) option flags
    PSecBuffer           pPackedContext,        // (out) marshalled context
    PHANDLE              pToken                 // (out, optional) token handle for impersonation
    )
{
    PSSL_USER_CONTEXT Context;
    PSPContext pContext;
    NTSTATUS Status;
    SP_STATUS pctRet;

    DebugLog((DEB_TRACE, "SpExportSecurityContext\n"));

    if (ARGUMENT_PRESENT(pToken))
    {
        *pToken = NULL;
    }

    pPackedContext->pvBuffer = NULL;
    pPackedContext->cbBuffer = 0;
    pPackedContext->BufferType = 0;


    //
    // Get handle to schannel context structure.
    //

    Context = SslFindUserContext( ContextHandle );

    if ( !Context )
    {
        Status = SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
        goto cleanup;
    }

    pContext = Context->pContext;

    if(pContext == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INVALID_HANDLE);
        goto cleanup;
    }

    if(!(pContext->State & SP_STATE_CONNECTED))
    {
        Status = SP_LOG_RESULT(SEC_E_CONTEXT_EXPIRED);
        goto cleanup;
    }

    
    //
    // Build packed context structure.
    //

    pctRet = SPContextSerialize(pContext, 
                                NULL, 
                                (PBYTE *)&pPackedContext->pvBuffer,
                                &pPackedContext->cbBuffer,
                                FALSE);

    if(pctRet != PCT_ERR_OK)
    {
        Status = SP_LOG_RESULT(SEC_E_ENCRYPT_FAILURE);
        goto cleanup;
    }


    //
    // Now either duplicate the token or copy it.
    //

    if (ARGUMENT_PRESENT(pToken) && (pContext->RipeZombie->hLocator))
    {
        if ((fFlags & SECPKG_CONTEXT_EXPORT_DELETE_OLD) != 0)
        {
            *pToken = (HANDLE)pContext->RipeZombie->hLocator;
            pContext->RipeZombie->hLocator = 0;
        }
        else 
        {
            Status = NtDuplicateObject(
                        NtCurrentProcess(),
                        (HANDLE)pContext->RipeZombie->hLocator,
                        NtCurrentProcess(),
                        pToken,
                        0,              // no new access
                        0,              // no handle attributes
                        DUPLICATE_SAME_ACCESS
                        );
            if (!NT_SUCCESS(Status))
            {
                goto cleanup;
            }
        }
    }

    Status = STATUS_SUCCESS;

cleanup:

    DebugLog((DEB_TRACE, "SpExportSecurityContext returned 0x%x\n", Status));

    return(Status);
}


NTSTATUS
NTAPI 
SpImportSecurityContext(
    PSecBuffer           pPackedContext,        // (in) marshalled context
    HANDLE               Token,                 // (in, optional) handle to token for context
    PLSA_SEC_HANDLE      ContextHandle          // (out) new context handle
    )
{
    LSA_SEC_HANDLE LsaHandle;
    NTSTATUS Status;

    // Dummy up an lsa handle by incrementing a global variable. This
    // will ensure that each imported context has a unique handle.
    // Skip over values that could be interpreted as an aligned pointer,
    // so that they won't get mixed up with real lsa handles.
    LsaHandle = InterlockedIncrement((PLONG)&ExportedContext);
    while(LsaHandle % MAX_NATURAL_ALIGNMENT == 0)
    {
        LsaHandle = InterlockedIncrement((PLONG)&ExportedContext);
    }

    
    Status = SslAddUserContext(LsaHandle, Token, pPackedContext, TRUE);

    if(!NT_SUCCESS(Status))
    {
        return Status;
    }

    *ContextHandle = LsaHandle;

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\perfmon\sslperf.h ===
//
//  sslperf.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the 
//  "First Counter" and "First Help" values fo the device they belong to, 
//  in order to determine the  absolute location of the counter and 
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the 
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
#define SSLPERF_OBJ             0
#define SSL_CACHE_ENTRIES       2
#define SSL_ACTIVE_ENTRIES      4
#define SSL_HANDSHAKE_COUNT     6
#define SSL_RECONNECT_COUNT     8
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\asn1enc.c ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for SCHANNEL FORTEZZA and Private Key encoding */

#include "spbase.h"
#include "asn1enc.h"

ASN1module_t ASN1ENC_Module = NULL;

static int ASN1CALL ASN1Enc_FORTPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, FORTPublicKey *val);
static int ASN1CALL ASN1Enc_PrivateKeyInfo_attributes(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo_attributes *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_RSAPrivateKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPrivateKey *val);
static int ASN1CALL ASN1Enc_PrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo *val);
static int ASN1CALL ASN1Enc_PrivateKeyData(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyData *val);
static int ASN1CALL ASN1Enc_PrivateKeyFile(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyFile *val);
static int ASN1CALL ASN1Enc_EnhancedKeyUsage(ASN1encoding_t enc, ASN1uint32_t tag, EnhancedKeyUsage *val);
static int ASN1CALL ASN1Dec_FORTPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, FORTPublicKey *val);
static int ASN1CALL ASN1Dec_PrivateKeyInfo_attributes(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo_attributes *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_RSAPrivateKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPrivateKey *val);
static int ASN1CALL ASN1Dec_PrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo *val);
static int ASN1CALL ASN1Dec_PrivateKeyData(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyData *val);
static int ASN1CALL ASN1Dec_PrivateKeyFile(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyFile *val);
static int ASN1CALL ASN1Dec_EnhancedKeyUsage(ASN1decoding_t dec, ASN1uint32_t tag, EnhancedKeyUsage *val);
static void ASN1CALL ASN1Free_FORTPublicKey(FORTPublicKey *val);
static void ASN1CALL ASN1Free_PrivateKeyInfo_attributes(PrivateKeyInfo_attributes *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_RSAPrivateKey(RSAPrivateKey *val);
static void ASN1CALL ASN1Free_PrivateKeyInfo(PrivateKeyInfo *val);
static void ASN1CALL ASN1Free_PrivateKeyData(PrivateKeyData *val);
static void ASN1CALL ASN1Free_PrivateKeyFile(PrivateKeyFile *val);
static void ASN1CALL ASN1Free_EnhancedKeyUsage(EnhancedKeyUsage *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[5] = {
    (ASN1EncFun_t) ASN1Enc_FORTPublicKey,
    (ASN1EncFun_t) ASN1Enc_RSAPrivateKey,
    (ASN1EncFun_t) ASN1Enc_PrivateKeyInfo,
    (ASN1EncFun_t) ASN1Enc_PrivateKeyFile,
    (ASN1EncFun_t) ASN1Enc_EnhancedKeyUsage,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[5] = {
    (ASN1DecFun_t) ASN1Dec_FORTPublicKey,
    (ASN1DecFun_t) ASN1Dec_RSAPrivateKey,
    (ASN1DecFun_t) ASN1Dec_PrivateKeyInfo,
    (ASN1DecFun_t) ASN1Dec_PrivateKeyFile,
    (ASN1DecFun_t) ASN1Dec_EnhancedKeyUsage,
};
static const ASN1FreeFun_t freefntab[5] = {
    (ASN1FreeFun_t) ASN1Free_FORTPublicKey,
    (ASN1FreeFun_t) ASN1Free_RSAPrivateKey,
    (ASN1FreeFun_t) ASN1Free_PrivateKeyInfo,
    (ASN1FreeFun_t) ASN1Free_PrivateKeyFile,
    (ASN1FreeFun_t) ASN1Free_EnhancedKeyUsage,
};
static const ULONG sizetab[5] = {
    SIZE_ASN1ENC_Module_PDU_0,
    SIZE_ASN1ENC_Module_PDU_1,
    SIZE_ASN1ENC_Module_PDU_2,
    SIZE_ASN1ENC_Module_PDU_3,
    SIZE_ASN1ENC_Module_PDU_4,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL ASN1ENC_Module_Startup(void)
{
    ASN1ENC_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 5, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x61686373);
}

void ASN1CALL ASN1ENC_Module_Cleanup(void)
{
    ASN1_CloseModule(ASN1ENC_Module);
    ASN1ENC_Module = NULL;
}

static int ASN1CALL ASN1Enc_FORTPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, FORTPublicKey *val)
{
    if (!ASN1DEREncBitString(enc, tag ? tag : 0x3, (val)->length, (val)->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_FORTPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, FORTPublicKey *val)
{
    if (!ASN1BERDecBitString2(dec, tag ? tag : 0x3, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_FORTPublicKey(FORTPublicKey *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyInfo_attributes(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo_attributes *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x80000000, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyInfo_attributes(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo_attributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x80000000, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (PrivateKeyInfo_attributes_Set *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyInfo_attributes(PrivateKeyInfo_attributes *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1open_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1open_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1open_free(&(val)->parameters);
	}
    }
}

static int ASN1CALL ASN1Enc_RSAPrivateKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPrivateKey *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->publicExponent))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->privateExponent))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->prime1))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->prime2))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->exponent1))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->exponent2))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->coefficient))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RSAPrivateKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPrivateKey *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->publicExponent))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->privateExponent))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->prime1))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->prime2))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->exponent1))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->exponent2))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->coefficient))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RSAPrivateKey(RSAPrivateKey *val)
{
    if (val) {
	ASN1intx_free(&(val)->modulus);
	ASN1intx_free(&(val)->privateExponent);
	ASN1intx_free(&(val)->prime1);
	ASN1intx_free(&(val)->prime2);
	ASN1intx_free(&(val)->exponent1);
	ASN1intx_free(&(val)->exponent2);
	ASN1intx_free(&(val)->coefficient);
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->privateKey).length, ((val)->privateKey).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_PrivateKeyInfo_attributes(enc, 0, &(val)->attributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->privateKey))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_PrivateKeyInfo_attributes(dd, 0, &(val)->attributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyInfo(PrivateKeyInfo *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->privateKeyAlgorithm);
	ASN1octetstring_free(&(val)->privateKey);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_PrivateKeyInfo_attributes(&(val)->attributes);
	}
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyData(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->privateKey).length, ((val)->privateKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyData(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->privateKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyData(PrivateKeyData *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->privateKeyAlgorithm);
	ASN1octetstring_free(&(val)->privateKey);
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyFile(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyFile *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->name).length, ((val)->name).value))
	return 0;
    if (!ASN1Enc_PrivateKeyData(enc, 0, &(val)->privateKey))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyFile(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyFile *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->name))
	return 0;
    if (!ASN1Dec_PrivateKeyData(dd, 0, &(val)->privateKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyFile(PrivateKeyFile *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->name);
	ASN1Free_PrivateKeyData(&(val)->privateKey);
    }
}

static int ASN1CALL ASN1Enc_EnhancedKeyUsage(ASN1encoding_t enc, ASN1uint32_t tag, EnhancedKeyUsage *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnhancedKeyUsage(ASN1decoding_t dec, ASN1uint32_t tag, EnhancedKeyUsage *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (UsageIdentifier *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnhancedKeyUsage(EnhancedKeyUsage *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\pkiutil\pkialloc.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       pkialloc.cpp
//
//  Contents:   PKI Allocation Functions
//
//  Functions:  PkiAlloc
//
//  History:    19-Jan-98    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

//+-------------------------------------------------------------------------
//  The following functions use the 'C' runtime's allocation functions
//  when DBG is defined.  Otherwise, use LocalAlloc, LocalReAlloc or
//  LocalFree Win32 APIs.
//--------------------------------------------------------------------------

// Calls malloc when DBG is defined. Otherwise, does a
// ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;
    if (NULL == (pv = (LPVOID) LocalAlloc(LPTR, cbBytes)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

// Calls malloc and does a memory clear when DBG is defined.
// Otherwise, does a ZEROINIT LocalAlloc.
LPVOID
WINAPI
PkiZeroAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;
    // LPTR (OR includes ZEROINIT)
    pv = (LPVOID) LocalAlloc(LPTR, cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

// Calls malloc when DBG is defined. Otherwise, does a
// LocalAlloc without ZEOINIT.
LPVOID
WINAPI
PkiNonzeroAlloc(
    IN size_t cbBytes
    )
{
    LPVOID pv;
    pv = (LPVOID) LocalAlloc(NONZEROLPTR, cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

LPVOID
WINAPI
PkiRealloc(
    IN LPVOID pvOrg,
    IN size_t cbBytes
    )
{
    LPVOID pv;
    if (NULL == (pv = pvOrg ?
            (LPVOID) LocalReAlloc((HLOCAL)pvOrg, cbBytes, LMEM_MOVEABLE) :
            (LPVOID) LocalAlloc(NONZEROLPTR, cbBytes)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

VOID
WINAPI
PkiFree(
    IN LPVOID pv
    )
{
    if (pv)
        LocalFree((HLOCAL)pv);
}

//+-------------------------------------------------------------------------
//  The following functions always use LocalAlloc and LocalFree Win32 APIs.
//--------------------------------------------------------------------------
LPVOID
WINAPI
PkiDefaultCryptAlloc(
    IN size_t cbSize
    )
{
    LPVOID pv;
    if (NULL == (pv = (LPVOID) LocalAlloc(NONZEROLPTR, cbSize)))
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}

VOID
WINAPI
PkiDefaultCryptFree(
    IN LPVOID pv
    )
{
    if (pv)
        LocalFree((HLOCAL) pv);
}

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
CRYPT_ENCODE_PARA PkiEncodePara = {
    offsetof(CRYPT_ENCODE_PARA, pfnFree) + sizeof(PkiEncodePara.pfnFree),
    PkiNonzeroAlloc,
    PkiFree
};


//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetEncodeAllocFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    )
{
    if (pEncodePara &&
            pEncodePara->cbSize >= offsetof(CRYPT_ENCODE_PARA, pfnAlloc) +
                sizeof(pEncodePara->pfnAlloc) &&
            pEncodePara->pfnAlloc)
        return pEncodePara->pfnAlloc;
    else
        return PkiDefaultCryptAlloc;
}

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetEncodeFreeFunction(
    IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara
    )
{
    if (pEncodePara &&
            pEncodePara->cbSize >= offsetof(CRYPT_ENCODE_PARA, pfnFree) +
                sizeof(pEncodePara->pfnFree) &&
            pEncodePara->pfnFree)
        return pEncodePara->pfnFree;
    else
        return PkiDefaultCryptFree;
}

//+-------------------------------------------------------------------------
//  The following data structure's pfnAlloc and pfnFree are set to
//  PkiNonzeroAlloc and PkiFree.
//--------------------------------------------------------------------------
CRYPT_DECODE_PARA PkiDecodePara = {
    offsetof(CRYPT_DECODE_PARA, pfnFree) + sizeof(PkiDecodePara.pfnFree),
    PkiNonzeroAlloc,
    PkiFree
};

//+-------------------------------------------------------------------------
//  If pfnAlloc isn't defined, returns PkiDefaultCryptAlloc
//--------------------------------------------------------------------------
PFN_CRYPT_ALLOC
WINAPI
PkiGetDecodeAllocFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    )
{
    if (pDecodePara &&
            pDecodePara->cbSize >= offsetof(CRYPT_DECODE_PARA, pfnAlloc) +
                sizeof(pDecodePara->pfnAlloc) &&
            pDecodePara->pfnAlloc)
        return pDecodePara->pfnAlloc;
    else
        return PkiDefaultCryptAlloc;
}

//+-------------------------------------------------------------------------
//  If pfnFree isn't defined, returns PkiDefaultCryptFree
//--------------------------------------------------------------------------
PFN_CRYPT_FREE
WINAPI
PkiGetDecodeFreeFunction(
    IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara
    )
{
    if (pDecodePara &&
            pDecodePara->cbSize >= offsetof(CRYPT_DECODE_PARA, pfnFree) +
                sizeof(pDecodePara->pfnFree) &&
            pDecodePara->pfnFree)
        return pDecodePara->pfnFree;
    else
        return PkiDefaultCryptFree;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\pkiutil\pkiasn1.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1998
//
//  File:       pkiasn1.cpp
//
//  Contents:   PKI ASN.1 support functions.
//
//  Functions:  PkiAsn1Encode
//              PkiAsn1Decode
//              PkiAsn1SetEncodingRule
//              PkiAsn1GetEncodingRule
//
//              PkiAsn1ReverseBytes
//              PkiAsn1EncodeInfoEx
//              PkiAsn1EncodeInfo
//              PkiAsn1DecodeAndAllocInfo
//              PkiAsn1AllocStructInfoEx
//              PkiAsn1DecodeAndAllocInfoEx
//
//              PkiAsn1ToObjectIdentifier
//              PkiAsn1FromObjectIdentifier
//
//
//  History:    23-Oct-98    philh   created
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)


inline BOOL my_isdigit( char ch)
{
    return (ch >= '0') && (ch <= '9');
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output is allocated and must be freed
//  by calling PkiAsn1FreeEncoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;

    Asn1Err = ASN1_Encode(
        pEnc,
        pvAsn1Info,
        id,
        ASN1ENCODE_ALLOCATEBUFFER,
        NULL,                       // pbBuf
        0                           // cbBufSize
        );

    if (ASN1_SUCCEEDED(Asn1Err)) {
        Asn1Err = ASN1_SUCCESS;
        *ppbEncoded = pEnc->buf;
        *pcbEncoded = pEnc->len;
    } else {
        *ppbEncoded = NULL;
        *pcbEncoded = 0;
    }
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Encode function. The encoded output isn't allocated.
//
//  If pbEncoded is NULL, does a length only calculation.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Encode2(
    IN ASN1encoding_t pEnc,
    IN void *pvAsn1Info,
    IN ASN1uint32_t id,
    OUT OPTIONAL BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;
    DWORD cbEncoded;

    if (NULL == pbEncoded)
        cbEncoded = 0;
    else
        cbEncoded = *pcbEncoded;

    if (0 == cbEncoded) {
        // Length only calculation

        Asn1Err = ASN1_Encode(
            pEnc,
            pvAsn1Info,
            id,
            ASN1ENCODE_ALLOCATEBUFFER,
            NULL,                       // pbBuf
            0                           // cbBufSize
            );

        if (ASN1_SUCCEEDED(Asn1Err)) {
            if (pbEncoded)
                Asn1Err = ASN1_ERR_OVERFLOW;
            else
                Asn1Err = ASN1_SUCCESS;
            cbEncoded = pEnc->len;
            PkiAsn1FreeEncoded(pEnc, pEnc->buf);
        }
    } else {
        Asn1Err = ASN1_Encode(
            pEnc,
            pvAsn1Info,
            id,
            ASN1ENCODE_SETBUFFER,
            pbEncoded,
            cbEncoded
            );

        if (ASN1_SUCCEEDED(Asn1Err)) {
            Asn1Err = ASN1_SUCCESS;
            cbEncoded = pEnc->len;
        } else if (ASN1_ERR_OVERFLOW == Asn1Err) {
            // Re-do as length only calculation
            Asn1Err = PkiAsn1Encode2(
                pEnc,
                pvAsn1Info,
                id,
                NULL,   // pbEncoded
                &cbEncoded
                );
            if (ASN1_SUCCESS == Asn1Err)
                Asn1Err = ASN1_ERR_OVERFLOW;
        } else
            cbEncoded = 0;
    }

    *pcbEncoded = cbEncoded;
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    Asn1Err = ASN1_Decode(
        pDec,
        ppvAsn1Info,
        id,
        ASN1DECODE_SETBUFFER,
        (BYTE *) pbEncoded,
        cbEncoded
        );
    if (ASN1_SUCCEEDED(Asn1Err))
        Asn1Err = ASN1_SUCCESS;
    else {
        if (ASN1_ERR_BADARGS == Asn1Err)
            Asn1Err = ASN1_ERR_EOD;
        *ppvAsn1Info = NULL;
    }
    return Asn1Err;
}

//+-------------------------------------------------------------------------
//  Asn1 Decode function. The allocated, decoded structure, **pvAsn1Info, must
//  be freed by calling PkiAsn1FreeDecoded().
//
//  For a successful decode, *ppbEncoded is advanced
//  past the decoded bytes and *pcbDecoded is decremented by the number
//  of decoded bytes.
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1Decode2(
    IN ASN1decoding_t pDec,
    OUT void **ppvAsn1Info,
    IN ASN1uint32_t id,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    Asn1Err = ASN1_Decode(
        pDec,
        ppvAsn1Info,
        id,
        ASN1DECODE_SETBUFFER,
        *ppbEncoded,
        *pcbEncoded
        );
    if (ASN1_SUCCEEDED(Asn1Err)) {
        Asn1Err = ASN1_SUCCESS;
        *ppbEncoded += pDec->len;
        *pcbEncoded -= pDec->len;
    } else {
        if (ASN1_ERR_BADARGS == Asn1Err)
            Asn1Err = ASN1_ERR_EOD;
        *ppvAsn1Info = NULL;
    }
    return Asn1Err;
}


//+-------------------------------------------------------------------------
//  Asn1 Set/Get encoding rules functions
//--------------------------------------------------------------------------
ASN1error_e
WINAPI
PkiAsn1SetEncodingRule(
    IN ASN1encoding_t pEnc,
    IN ASN1encodingrule_e eRule
    )
{
    ASN1optionparam_s OptParam;

    OptParam.eOption = ASN1OPT_CHANGE_RULE;
    OptParam.eRule = eRule;

    return ASN1_SetEncoderOption(pEnc, &OptParam);
}

ASN1encodingrule_e
WINAPI
PkiAsn1GetEncodingRule(
    IN ASN1encoding_t pEnc
    )
{
    ASN1error_e Asn1Err;
    ASN1encodingrule_e eRule;
    ASN1optionparam_s OptParam;
    OptParam.eOption = ASN1OPT_GET_RULE;

    Asn1Err = ASN1_GetEncoderOption(pEnc, &OptParam);
    if (ASN1_SUCCEEDED(Asn1Err))
        eRule = OptParam.eRule;
    else
        eRule = ASN1_BER_RULE_DER;

    return eRule;
}


//+-------------------------------------------------------------------------
//  Reverses a buffer of bytes in place
//--------------------------------------------------------------------------
void
WINAPI
PkiAsn1ReverseBytes(
			IN OUT PBYTE pbIn,
			IN DWORD cbIn
            )
{
    // reverse in place
    PBYTE	pbLo;
    PBYTE	pbHi;
    BYTE	bTmp;

    if (0 == cbIn)
        return;
    
    for (pbLo = pbIn, pbHi = pbIn + cbIn - 1; pbLo < pbHi; pbHi--, pbLo++) {
        bTmp = *pbHi;
        *pbHi = *pbLo;
        *pbLo = bTmp;
    }
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure.
//
//  If CRYPT_ENCODE_ALLOC_FLAG is set, allocate memory for pbEncoded and
//  return *((BYTE **) pvEncoded) = pbAllocEncoded. Otherwise,
//  pvEncoded points to byte array to be updated.
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfoEx(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_ENCODE_PARA pEncodePara,
        OUT OPTIONAL void *pvEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BOOL fResult;
    ASN1error_e Asn1Err;
    DWORD cbEncoded;

    if (dwFlags & CRYPT_ENCODE_ALLOC_FLAG) {
        BYTE *pbEncoded;
        BYTE *pbAllocEncoded;
        PFN_CRYPT_ALLOC pfnAlloc;

        PkiAsn1SetEncodingRule(pEnc, ASN1_BER_RULE_DER);
        Asn1Err = PkiAsn1Encode(
            pEnc,
            pvAsn1Info,
            id,
            &pbEncoded,
            &cbEncoded
            );

        if (ASN1_SUCCESS != Asn1Err) {
            *((void **) pvEncoded) = NULL;
            goto Asn1EncodeError;
        }

        pfnAlloc = PkiGetEncodeAllocFunction(pEncodePara);
        if (NULL == (pbAllocEncoded = (BYTE *) pfnAlloc(cbEncoded))) {
            PkiAsn1FreeEncoded(pEnc, pbEncoded);
            *((void **) pvEncoded) = NULL;
            goto OutOfMemory;
        }
        memcpy(pbAllocEncoded, pbEncoded, cbEncoded);
        *((BYTE **) pvEncoded) = pbAllocEncoded;
        PkiAsn1FreeEncoded(pEnc, pbEncoded);
    } else {
        cbEncoded = *pcbEncoded;
        PkiAsn1SetEncodingRule(pEnc, ASN1_BER_RULE_DER);
        Asn1Err = PkiAsn1Encode2(
            pEnc,
            pvAsn1Info,
            id,
            (BYTE *) pvEncoded,
            &cbEncoded
            );

        if (ASN1_SUCCESS != Asn1Err) {
            if (ASN1_ERR_OVERFLOW == Asn1Err)
                goto LengthError;
            else
                goto Asn1EncodeError;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbEncoded = cbEncoded;
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

OutOfMemory:
    goto ErrorReturn;

LengthError:
    SetLastError(ERROR_MORE_DATA);
    goto ErrorReturn;

Asn1EncodeError:
    SetLastError(PkiAsn1ErrToHr(Asn1Err));
    goto ErrorReturn;
}

//+-------------------------------------------------------------------------
//  Encode an ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1EncodeInfo(
        IN ASN1encoding_t pEnc,
        IN ASN1uint32_t id,
        IN void *pvAsn1Info,
        OUT OPTIONAL BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfoEx(
        pEnc,
        id,
        pvAsn1Info,
        0,                  // dwFlags
        NULL,               // pEncodePara
        pbEncoded,
        pcbEncoded
        );
}


//+-------------------------------------------------------------------------
//  Decode into an allocated, ASN1 formatted info structure
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfo(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppvAsn1Info
        )
{
    BOOL fResult;
    ASN1error_e Asn1Err;

    *ppvAsn1Info = NULL;
    if (ASN1_SUCCESS != (Asn1Err = PkiAsn1Decode(
            pDec,
            ppvAsn1Info,
            id,
            pbEncoded,
            cbEncoded
            )))
        goto Asn1DecodeError;
    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    *ppvAsn1Info = NULL;
    fResult = FALSE;
    goto CommonReturn;

Asn1DecodeError:
    SetLastError(PkiAsn1ErrToHr(Asn1Err));
    goto ErrorReturn;
}


//+-------------------------------------------------------------------------
//  Call the callback to convert the ASN1 structure into the 'C' structure.
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1AllocStructInfoEx(
        IN void *pvAsn1Info,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    LONG lRemainExtra;
    DWORD cbStructInfo;

    if (NULL == pvStructInfo || (dwFlags & CRYPT_DECODE_ALLOC_FLAG)) {
        cbStructInfo = 0;
        lRemainExtra = 0;
    } else {
        cbStructInfo = *pcbStructInfo;
        lRemainExtra = (LONG) cbStructInfo;
    }

    if (!pfnDecodeExCallback(
            pvAsn1Info,
            dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
            pDecodePara,
            pvStructInfo,
            &lRemainExtra
            )) goto DecodeCallbackError;

    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG) {
        void *pv;
        PFN_CRYPT_ALLOC pfnAlloc = PkiGetDecodeAllocFunction(pDecodePara);

        assert(0 > lRemainExtra);
        lRemainExtra = -lRemainExtra;
        cbStructInfo = (DWORD) lRemainExtra;

        if (NULL == (pv = pfnAlloc(cbStructInfo)))
            goto OutOfMemory;
        if (!pfnDecodeExCallback(
                pvAsn1Info,
                dwFlags & ~CRYPT_DECODE_ALLOC_FLAG,
                pDecodePara,
                pv,
                &lRemainExtra
                )) {
            PFN_CRYPT_FREE pfnFree = PkiGetDecodeFreeFunction(pDecodePara);
            pfnFree(pv);
            goto DecodeCallbackError;
        }
        *((void **) pvStructInfo) = pv;
        assert(0 <= lRemainExtra);
    }

    if (0 <= lRemainExtra) {
        cbStructInfo = cbStructInfo - (DWORD) lRemainExtra;
    } else {
        cbStructInfo = cbStructInfo + (DWORD) -lRemainExtra;
        if (pvStructInfo) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
            goto CommonReturn;
        }
    }

    fResult = TRUE;
CommonReturn:
    *pcbStructInfo = cbStructInfo;
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    cbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;

DecodeCallbackError:
    goto ErrorReturn;

OutOfMemory:
    goto ErrorReturn;
}

//+-------------------------------------------------------------------------
//  Decode the ASN1 formatted info structure and call the callback
//  function to convert the ASN1 structure to the 'C' structure.
//
//  If CRYPT_DECODE_ALLOC_FLAG is set allocate memory for the 'C'
//  structure and call the callback initially to get the length and then
//  a second time to update the allocated 'C' structure.
//
//  Allocated structure is returned:
//      *((void **) pvStructInfo) = pvAllocStructInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1DecodeAndAllocInfoEx(
        IN ASN1decoding_t pDec,
        IN ASN1uint32_t id,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        IN OPTIONAL PCRYPT_DECODE_PARA pDecodePara,
        IN PFN_PKI_ASN1_DECODE_EX_CALLBACK pfnDecodeExCallback,
        OUT OPTIONAL void *pvStructInfo,
        IN OUT DWORD *pcbStructInfo
        )
{
    BOOL fResult;
    void *pvAsn1Info = NULL;

    if (!PkiAsn1DecodeAndAllocInfo(
            pDec,
            id,
            pbEncoded,
            cbEncoded,
            &pvAsn1Info
            )) goto Asn1DecodeError;

    fResult = PkiAsn1AllocStructInfoEx(
        pvAsn1Info,
        dwFlags,
        pDecodePara,
        pfnDecodeExCallback,
        pvStructInfo,
        pcbStructInfo
        );
CommonReturn:
    PkiAsn1FreeInfo(pDec, id, pvAsn1Info);
    return fResult;

ErrorReturn:
    if (dwFlags & CRYPT_DECODE_ALLOC_FLAG)
        *((void **) pvStructInfo) = NULL;
    *pcbStructInfo = 0;
    fResult = FALSE;
    goto CommonReturn;

Asn1DecodeError:
    goto ErrorReturn;
}

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to ASN1's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion. 
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1ToObjectIdentifier(
    IN LPCSTR pszObjId,
    IN OUT ASN1uint16_t *pCount,
    OUT ASN1uint32_t rgulValue[]
    )
{
    BOOL fResult = TRUE;
    unsigned short c = 0;
    LPSTR psz = (LPSTR) pszObjId;
    char    ch;

    if (psz) {
        ASN1uint16_t cMax = *pCount;
        ASN1uint32_t *pul = rgulValue;
        while ((ch = *psz) != '\0' && c++ < cMax) {
            *pul++ = (ASN1uint32_t)atol(psz);
            while (my_isdigit(ch = *psz++))
                ;
            if (ch != '.')
                break;
        }
        if (ch != '\0')
            fResult = FALSE;
    }
    *pCount = c;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Convert from ASN1's Object Identifier represented as an array of
//  unsigned longs to an ascii string ("1.2.9999").
//
//  Returns TRUE for a successful conversion
//--------------------------------------------------------------------------
BOOL
WINAPI
PkiAsn1FromObjectIdentifier(
    IN ASN1uint16_t Count,
    IN ASN1uint32_t rgulValue[],
    OUT LPSTR pszObjId,
    IN OUT DWORD *pcbObjId
    )
{
    BOOL fResult = TRUE;
    LONG lRemain;

    if (pszObjId == NULL)
        *pcbObjId = 0;

    lRemain = (LONG) *pcbObjId;
    if (Count == 0) {
        if (--lRemain > 0)
            pszObjId++;
    } else {
        char rgch[36];
        LONG lData;
        ASN1uint32_t *pul = rgulValue;
        for (; Count > 0; Count--, pul++) {
            _ltoa(*pul, rgch, 10);
            lData = strlen(rgch);
            lRemain -= lData + 1;
            if (lRemain >= 0) {
                if (lData > 0) {
                    memcpy(pszObjId, rgch, lData);
                    pszObjId += lData;
                }
                *pszObjId++ = '.';
            }
        }
    }

    if (lRemain >= 0) {
        *(pszObjId -1) = '\0';
        *pcbObjId = *pcbObjId - (DWORD) lRemain;
    } else {
        *pcbObjId = *pcbObjId + (DWORD) -lRemain;
        if (pszObjId) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        }
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\asn1enc.h ===
/* Copyright (C) Microsoft Corporation, 1996-1999. All rights reserved. */
/* ASN.1 definitions for SCHANNEL FORTEZZA and Private Key encoding */

#ifndef _ASN1ENC_Module_H_
#define _ASN1ENC_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1open_t PrivateKeyInfo_attributes_Set;

typedef ASN1intx_t HUGEINTEGER;

typedef ASN1bitstring_t BITSTRING;

typedef ASN1octetstring_t OCTETSTRING;

typedef ASN1open_t NOCOPYANY;

typedef ASN1charstring_t NUMERICSTRING;

typedef ASN1charstring_t PRINTABLESTRING;

typedef ASN1charstring_t TELETEXSTRING;

typedef ASN1charstring_t T61STRING;

typedef ASN1charstring_t VIDEOTEXSTRING;

typedef ASN1charstring_t IA5STRING;

typedef ASN1charstring_t GRAPHICSTRING;

typedef ASN1charstring_t VISIBLESTRING;

typedef ASN1charstring_t ISO646STRING;

typedef ASN1charstring_t GENERALSTRING;

typedef ASN1char32string_t UNIVERSALSTRING;

typedef ASN1char16string_t BMPSTRING;

typedef ASN1objectidentifier2_t ObjectID;

typedef BITSTRING FORTPublicKey;
#define FORTPublicKey_PDU 0
#define SIZE_ASN1ENC_Module_PDU_0 sizeof(FORTPublicKey)

typedef ASN1octetstring_t EncryptedData;

typedef ObjectID UsageIdentifier;

typedef struct PrivateKeyInfo_attributes {
    ASN1uint32_t count;
    PrivateKeyInfo_attributes_Set *value;
} PrivateKeyInfo_attributes;

typedef struct AlgorithmIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID algorithm;
#   define parameters_present 0x80
    ASN1open_t parameters;
} AlgorithmIdentifier;

typedef struct RSAPrivateKey {
    ASN1int32_t version;
    HUGEINTEGER modulus;
    ASN1int32_t publicExponent;
    HUGEINTEGER privateExponent;
    HUGEINTEGER prime1;
    HUGEINTEGER prime2;
    HUGEINTEGER exponent1;
    HUGEINTEGER exponent2;
    HUGEINTEGER coefficient;
} RSAPrivateKey;
#define RSAPrivateKey_PDU 1
#define SIZE_ASN1ENC_Module_PDU_1 sizeof(RSAPrivateKey)

typedef struct PrivateKeyInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    AlgorithmIdentifier privateKeyAlgorithm;
    ASN1octetstring_t privateKey;
#   define attributes_present 0x80
    PrivateKeyInfo_attributes attributes;
} PrivateKeyInfo;
#define PrivateKeyInfo_PDU 2
#define SIZE_ASN1ENC_Module_PDU_2 sizeof(PrivateKeyInfo)

typedef struct PrivateKeyData {
    AlgorithmIdentifier privateKeyAlgorithm;
    EncryptedData privateKey;
} PrivateKeyData;

typedef struct PrivateKeyFile {
    ASN1octetstring_t name;
    PrivateKeyData privateKey;
} PrivateKeyFile;
#define PrivateKeyFile_PDU 3
#define SIZE_ASN1ENC_Module_PDU_3 sizeof(PrivateKeyFile)

typedef struct EnhancedKeyUsage {
    ASN1uint32_t count;
    UsageIdentifier *value;
} EnhancedKeyUsage;
#define EnhancedKeyUsage_PDU 4
#define SIZE_ASN1ENC_Module_PDU_4 sizeof(EnhancedKeyUsage)


extern ASN1module_t ASN1ENC_Module;
extern void ASN1CALL ASN1ENC_Module_Startup(void);
extern void ASN1CALL ASN1ENC_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _ASN1ENC_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\cache.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cache.c
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes    LSA integration stuff.
//              07-31-98   jbanes    Made thread-safe. 
//
//----------------------------------------------------------------------------

#include "spbase.h"
#include <limits.h>
#include <mapper.h>
#include <sslcache.h>
#include <crypt.h>

SCHANNEL_CACHE SchannelCache = 
{
    NULL,                           // SessionCache 

    SP_CACHE_CLIENT_LIFESPAN,       // dwClientLifespan
    SP_CACHE_SERVER_LIFESPAN,       // dwServerLifespan
    SP_CACHE_CLEANUP_INTERVAL,      // dwCleanupInterval
    SP_MAXIMUM_CACHE_ELEMENTS,      // dwCacheSize
    SP_MAXIMUM_CACHE_ELEMENTS,      // dwMaximumEntries
    0                               // dwUsedEntries
};

RTL_CRITICAL_SECTION g_CacheCleanupLock;
BOOL             g_CacheCleanupCritSectInitialized = FALSE;
LIST_ENTRY       g_CacheCleanupList;
HANDLE           g_CacheCleanupEvent = NULL;
HANDLE           g_CacheCleanupWaitObject = NULL;
BOOL             g_fMultipleProcessClientCache = FALSE;
BOOL             g_fCacheInitialized = FALSE;

// Perf counter values.
LONG g_cClientHandshakes = 0;
LONG g_cServerHandshakes = 0;
LONG g_cClientReconnects = 0;
LONG g_cServerReconnects = 0;


BOOL
SPCacheDelete(
    PSessCacheItem pItem);

BOOL
CacheExpireElements(
    BOOL fBackground);

VOID 
CacheCleanupHandler(
    PVOID pVoid, 
    BOOLEAN fTimeout);


SP_STATUS
SPInitSessionCache(VOID)
{
    DWORD i;
    NTSTATUS Status = STATUS_SUCCESS;

    // 
    // Allocate memory for cache, and initialize synchronization resource.
    //

    InitializeListHead(&SchannelCache.EntryList);

    __try {
        RtlInitializeResource(&SchannelCache.Lock);
    } __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }
    SchannelCache.LockInitialized = TRUE;

    SchannelCache.SessionCache = (PLIST_ENTRY)SPExternalAlloc(SchannelCache.dwCacheSize * sizeof(LIST_ENTRY));
    if(SchannelCache.SessionCache == NULL)
    {
        Status = SP_LOG_RESULT(STATUS_NO_MEMORY);
        goto cleanup;
    }

    for(i = 0; i < SchannelCache.dwCacheSize; i++)
    {
        InitializeListHead(&SchannelCache.SessionCache[i]);
    }

    DebugLog((DEB_TRACE, "Space reserved at 0x%x for %d cache entries.\n", 
        SchannelCache.SessionCache,
        SchannelCache.dwCacheSize));


    //
    // Initialize issuer cache.
    //

    SPInitIssuerCache();


    //
    // Initialize cache cleanup objects.
    //

    InitializeListHead(&g_CacheCleanupList);
    Status = RtlInitializeCriticalSection(&g_CacheCleanupLock);
    if(!NT_SUCCESS(Status))
    {
        goto cleanup;
    }
    g_CacheCleanupCritSectInitialized = TRUE;

    
    g_CacheCleanupEvent = CreateEvent(NULL,
                                      FALSE,
                                      FALSE,
                                      NULL);

    if(NULL == g_CacheCleanupEvent)
    {
        Status = GetLastError();
        goto cleanup;
    }

    if(!RegisterWaitForSingleObject(&g_CacheCleanupWaitObject,
                                    g_CacheCleanupEvent,
                                    CacheCleanupHandler,
                                    NULL,
                                    SchannelCache.dwCleanupInterval,
                                    WT_EXECUTEDEFAULT))
    {
        Status = GetLastError();
        goto cleanup;
    }

    g_fCacheInitialized = TRUE;

    Status = STATUS_SUCCESS;

cleanup:

    if(!NT_SUCCESS(Status))
    {
        SPShutdownSessionCache();
    }

    return Status;
}


SP_STATUS
SPShutdownSessionCache(VOID)
{
    PSessCacheItem pItem;
    PLIST_ENTRY pList;

    SP_BEGIN("SPShutdownSessionCache");

    if(SchannelCache.LockInitialized)
    {
        RtlAcquireResourceExclusive(&SchannelCache.Lock, TRUE);
    }

    g_fCacheInitialized = FALSE;

    if(SchannelCache.SessionCache != NULL)
    {
        // Blindly kill all cache items.
        // No contexts should be running at
        // this time.
        pList = SchannelCache.EntryList.Flink;

        while(pList != &SchannelCache.EntryList)
        {
            pItem  = CONTAINING_RECORD(pList, SessCacheItem, EntryList.Flink);
            pList  = pList->Flink;

            SPCacheDelete(pItem);
        }

        SPExternalFree(SchannelCache.SessionCache);
    }

    if(g_CacheCleanupCritSectInitialized)
    {
        RtlDeleteCriticalSection(&g_CacheCleanupLock);
        g_CacheCleanupCritSectInitialized = FALSE;
    }

    if(g_CacheCleanupWaitObject)
    {
        UnregisterWaitEx(g_CacheCleanupWaitObject, INVALID_HANDLE_VALUE);
        g_CacheCleanupWaitObject = NULL;
    }

    if(g_CacheCleanupEvent)
    {
        CloseHandle(g_CacheCleanupEvent);
        g_CacheCleanupEvent = NULL;
    }

    if(SchannelCache.LockInitialized)
    {
        RtlDeleteResource(&SchannelCache.Lock);
        SchannelCache.LockInitialized = FALSE;
    }

    SPShutdownIssuerCache();

    SP_RETURN(PCT_ERR_OK);
}


LONG
SPCacheReference(
    PSessCacheItem pItem)
{
    LONG cRet;

    if(pItem == NULL)
    {
        return -1;
    }

    ASSERT(pItem->Magic == SP_CACHE_MAGIC);

    cRet = InterlockedIncrement(&pItem->cRef);

    return cRet;
}


LONG
SPCacheDereference(PSessCacheItem pItem)
{
    long cRet;

    if(pItem == NULL)
    {
        return -1;
    }

    ASSERT(pItem->Magic == SP_CACHE_MAGIC);

    cRet = InterlockedDecrement(&pItem->cRef);

    ASSERT(cRet > 0);

    return cRet;
}


BOOL
SPCacheDelete(
    PSessCacheItem pItem)
{
    DebugLog((DEB_TRACE, "Delete cache item:0x%x\n", pItem));

    if(pItem == NULL)
    {
        return FALSE;
    }

    ASSERT(pItem->Magic == SP_CACHE_MAGIC);

    if(pItem->hMasterKey)
    {
        if(!CryptDestroyKey(pItem->hMasterKey))
        {
            SP_LOG_RESULT(GetLastError());
        }
        pItem->hMasterKey = 0;
    }

    if(pItem->pRemoteCert)
    {
        CertFreeCertificateContext(pItem->pRemoteCert);
        pItem->pRemoteCert = NULL;
    }

    if(pItem->pRemotePublic)
    {
        SPExternalFree(pItem->pRemotePublic);
        pItem->pRemotePublic = NULL;
    }

    if(pItem->phMapper)
    {
        if(pItem->hLocator)
        {
            SslCloseLocator(pItem->phMapper, pItem->hLocator);
            pItem->hLocator = 0;
        }
        SslDereferenceMapper(pItem->phMapper);
    }
    pItem->phMapper = NULL;

    if(pItem->pbServerCertificate)
    {
        SPExternalFree(pItem->pbServerCertificate);
        pItem->pbServerCertificate = NULL;
        pItem->cbServerCertificate = 0;
    }

    pItem->pActiveServerCred = NULL;

    if(pItem->pServerCred)
    {
        SPDereferenceCredential(pItem->pServerCred, FALSE);
        pItem->pServerCred = NULL;
    }

    if(pItem->szCacheID)
    {
        SPExternalFree(pItem->szCacheID);
        pItem->szCacheID = NULL;
    }

    if(pItem->pClientCred)
    {
        SPDeleteCred(pItem->pClientCred, TRUE);
        pItem->pClientCred = NULL;
    }

    if(pItem->pClientCert)
    {
        CertFreeCertificateContext(pItem->pClientCert);
        pItem->pClientCert = NULL;
    }

    if(pItem->pClonedItem)
    {
        SPCacheDereference(pItem->pClonedItem);
        pItem->pClonedItem = NULL;
    }

    if(pItem->pbAppData)
    {
        SPExternalFree(pItem->pbAppData);
        pItem->pbAppData = NULL;
    }

    SPExternalFree(pItem);

    return TRUE;
}


void
SPCachePurgeCredential(
    PSPCredentialGroup pCred)
{
    PSessCacheItem pItem;
    PLIST_ENTRY pList;
   

    //
    // If this is a client credential and the cross-process cache is enabled, then
    // don't purge its cache entries.
    //

    if(g_fMultipleProcessClientCache && (pCred->grbitProtocol & SP_PROT_CLIENTS))
    {
        return;
    }


    //
    // Search through the cache entries looking for entries that are
    // bound to the specified server credential.
    //

    if(SchannelCache.dwUsedEntries == 0)
    {
        return;
    }

    RtlAcquireResourceShared(&SchannelCache.Lock, TRUE);

    pList = SchannelCache.EntryList.Flink;

    while(pList != &SchannelCache.EntryList)
    {
        pItem = CONTAINING_RECORD(pList, SessCacheItem, EntryList.Flink);
        pList = pList->Flink;

        ASSERT(pItem->Magic == SP_CACHE_MAGIC);

        // Does this item match the current credentials?
        if(!IsSameThumbprint(&pCred->CredThumbprint, &pItem->CredThumbprint))
        {
            continue;
        }

        // Mark this entry as non-resumable. This will cause the entry to 
        // be deleted automatically by the cleanup routines.
        pItem->ZombieJuju = FALSE;
        pItem->DeferredJuju = FALSE;
    }

    RtlReleaseResource(&SchannelCache.Lock);


    //
    // Delete all unused non-resumable cache entries. This will release all of
    // the cached master key objects belonging to this credential. This must be 
    // done now because the owning provider context will often be destroyed 
    // along with the credential.
    //

    CacheExpireElements(FALSE);
}


void 
SPCachePurgeProcessId(
    ULONG ProcessId)
{
    PSessCacheItem pItem;
    PLIST_ENTRY pList;
   
    //
    // Search through the cache entries looking for entries that are
    // bound to the specified process.
    //

    RtlAcquireResourceShared(&SchannelCache.Lock, TRUE);

    pList = SchannelCache.EntryList.Flink;

    while(pList != &SchannelCache.EntryList)
    {
        pItem = CONTAINING_RECORD(pList, SessCacheItem, EntryList.Flink);
        pList = pList->Flink;

        ASSERT(pItem->Magic == SP_CACHE_MAGIC);

        // Does this item match the specified process?
        if(pItem->ProcessID != ProcessId)
        {
            continue;
        }

        // Mark the entry as ownerless.
        pItem->ProcessID = 0;

        // Mark this entry as non-resumable. This will cause the entry to 
        // be deleted automatically by the cleanup routines.
        pItem->ZombieJuju = FALSE;
        pItem->DeferredJuju = FALSE;
    }

    RtlReleaseResource(&SchannelCache.Lock);
}


BOOL 
IsSameTargetName(
    LPWSTR Name1,
    LPWSTR Name2)
{
    if(Name1 == Name2)
    {
        return TRUE;
    }

    if(Name1 == NULL || Name2 == NULL || wcscmp(Name1, Name2) != 0)
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
DoesAppAllowCipher(
    PSPCredentialGroup  pCredGroup,
    PSessCacheItem      pItem)
{
    PKeyExchangeInfo pExchInfo;

    if(pCredGroup == NULL)
    {
        return FALSE;
    }

    //
    // Is protocol supported?
    //

    if((pItem->fProtocol & pCredGroup->grbitEnabledProtocols) == 0)
    {
        return FALSE;
    }

    //
    // Is cipher supported?
    //

    if(pItem->dwStrength < pCredGroup->dwMinStrength)
    {
        return FALSE;
    }

    if(pItem->dwStrength > pCredGroup->dwMaxStrength)
    {
        return FALSE;
    }

    if(!IsAlgAllowed(pCredGroup, pItem->aiCipher))
    {
        return FALSE;
    }


    //
    // Is hash supported?
    //

    if(!IsAlgAllowed(pCredGroup, pItem->aiHash))
    {
        return FALSE;
    }


    //
    // Is exchange alg supported?
    //

    if(pItem->SessExchSpec != SP_EXCH_UNKNOWN)
    {
        pExchInfo = GetKeyExchangeInfo(pItem->SessExchSpec);
        if(pExchInfo == NULL)
        {
            return FALSE;
        }

        if((pExchInfo->fProtocol & pItem->fProtocol) == 0)
        {
            return FALSE;
        }

        if(!IsAlgAllowed(pCredGroup, pExchInfo->aiExch))
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL SPCacheRetrieveBySession(
    struct _SPContext * pContext, 
    PBYTE pbSessionID,
    DWORD cbSessionID,
    PSessCacheItem *ppRetItem)
{
    DWORD index;
    DWORD timeNow;
    ULONG ProcessID;
    PSessCacheItem pItem = NULL;
    PLIST_ENTRY pList;
    BOOL fFound = FALSE;

    DebugLog((DEB_TRACE, "SPCacheRetrieveBySession (0x%x) called\n", pContext));

    if(ppRetItem == NULL)
    {
        return FALSE;
    }


    // 
    // Compute the cache index.
    //

    if(cbSessionID < sizeof(DWORD))
    {
        DebugLog((DEB_TRACE, "    FAILED\n"));
        return FALSE;
    }
    CopyMemory((PBYTE)&index, pbSessionID, sizeof(DWORD));

    if(index >= SchannelCache.dwCacheSize)
    {
        DebugLog((DEB_TRACE, "    FAILED\n"));
        return FALSE;
    }


    //
    // Retrieve the current time and application process id.
    // 

    timeNow = GetTickCount();

    SslGetClientProcess(&ProcessID);


    //
    // Lock the cache for read.
    //

    RtlAcquireResourceShared(&SchannelCache.Lock, TRUE);


    // 
    // Search through the cache entries at the computed index.
    // 

    pList = SchannelCache.SessionCache[index].Flink;

    while(pList != &SchannelCache.SessionCache[index])
    {
        pItem = CONTAINING_RECORD(pList, SessCacheItem, IndexEntryList.Flink);
        pList = pList->Flink ;

        ASSERT(pItem->Magic == SP_CACHE_MAGIC);

        // Is this entry resumable?
        if(!pItem->ZombieJuju)
        {
            continue;
        }

        // Has this item expired?
        if(HasTimeElapsed(pItem->CreationTime, timeNow, pItem->Lifespan))
        {
            continue;
        }

        // Does the session id match?
        if(cbSessionID != pItem->cbSessionID)
        {
            continue;
        }
        if(memcmp(pbSessionID, pItem->SessionID, cbSessionID) != 0)
        {
            continue;
        }

        // Is this item for the protocol we're using.
        if(0 == (pContext->dwProtocol & pItem->fProtocol))
        {
            continue;
        }

        // Does this item belong to our client process?
        if(pItem->ProcessID != ProcessID)
        {
            continue;
        }

        // Does this item match the current server credentials? 
        //
        // We don't allow different server credentials to share cache
        // entries, because if the credential that was used during
        // the original full handshake is deleted, then the cache
        // entry is unusable. Some server applications (I won't name names)
        // create a new credential for each connection, and we have to
        // guard against this.
        //
        // Note that this restriction may result in an extra full
        // handshake when IE accesses an IIS site enabled for certificate
        // mapping, mostly because IE's behavior is broken.
        if(!IsSameThumbprint(&pContext->pCredGroup->CredThumbprint, 
                             &pItem->CredThumbprint))
        {
            continue;
        }

#if 0
        // Make sure that the application supports the cipher suite
        // used by this cache entry. This becomes important now that 
        // we're allowing different server credentials to share 
        // cache entries.
        if(!DoesAppAllowCipher(pContext->pCredGroup, pItem))
        {
            continue;
        }
#endif


        //
        // Found item in cache!!
        //

        fFound = TRUE;
        SPCacheReference(pItem);

        // Are we replacing something?
        // Then dereference the thing we are replacing.
        if(*ppRetItem)
        {
            SPCacheDereference(*ppRetItem);
        }

        // Return item referenced.
        *ppRetItem = pItem;
        break;
    }


    RtlReleaseResource(&SchannelCache.Lock);

    if(fFound)
    {
        DebugLog((DEB_TRACE, "    FOUND IT(0x%x)\n", pItem));
        InterlockedIncrement(&g_cServerReconnects);
    }
    else
    {
        DebugLog((DEB_TRACE, "    FAILED\n"));
    }

    return fFound;
}


DWORD
ComputeClientCacheIndex(
    LPWSTR pszTargetName)
{
    DWORD index;
    MD5_CTX Md5Hash;
    DWORD cbTargetName;

    if(pszTargetName == NULL)
    {
        index = 0;
    }
    else
    {
        cbTargetName = lstrlenW(pszTargetName) * sizeof(WCHAR);

        MD5Init(&Md5Hash);
        MD5Update(&Md5Hash, 
                  (PBYTE)pszTargetName, 
                  cbTargetName);
        MD5Final(&Md5Hash);
        CopyMemory((PBYTE)&index, 
                   Md5Hash.digest, 
                   sizeof(DWORD));

        index %= SchannelCache.dwCacheSize;
    }

    return index;
}


BOOL 
SPCacheRetrieveByName(
    LPWSTR pszTargetName,
    PSPCredentialGroup pCredGroup,
    PSessCacheItem *ppRetItem)
{
    DWORD index;
    PSessCacheItem pItem;
    PSessCacheItem pFoundEntry = NULL;
    DWORD timeNow;
    LUID LogonId;
    PLIST_ENTRY pList;

    DebugLog((DEB_TRACE, "SPCacheRetrieveByName (%ls) called\n", pszTargetName));

    if(ppRetItem == NULL)
    {
        return FALSE;
    }


    //
    // Retrieve the current time and user logon id.
    // 

    timeNow = GetTickCount();

    SslGetClientLogonId(&LogonId);


    // 
    // Compute the cache index.
    //

    index = ComputeClientCacheIndex(pszTargetName);


    //
    // Lock the cache for read.
    //

    RtlAcquireResourceShared(&SchannelCache.Lock, TRUE);


    // 
    // Search through the cache entries at the computed index.
    // 

    pList = SchannelCache.SessionCache[index].Flink;

    while(pList != &SchannelCache.SessionCache[index])
    {
        pItem = CONTAINING_RECORD(pList, SessCacheItem, IndexEntryList.Flink);
        pList = pList->Flink ;

        ASSERT(pItem->Magic == SP_CACHE_MAGIC);

        // Is this entry resumable?
        if(!pItem->ZombieJuju)
        {
            continue;
        }

        // Is this item for the protocol we're using?
        if(0 == (pCredGroup->grbitEnabledProtocols & pItem->fProtocol))
        {
            continue;
        }

        // Has this item expired?
        if(HasTimeElapsed(pItem->CreationTime, timeNow, pItem->Lifespan))
        {
            continue;
        }

        // Does this item belong to our client?
        if(!RtlEqualLuid(&pItem->LogonId, &LogonId))
        {
            continue;
        }

        // Does this item match our current credentials? 
        if(g_fMultipleProcessClientCache)
        {
            // If this cache entry has a client certificate associated with it 
            // and the passed in client credentials contain one or more certificates, 
            // then we need to make sure that they overlap.
            if(IsValidThumbprint(&pItem->CertThumbprint) && pCredGroup->CredCount != 0)
            {
                if(!DoesCredThumbprintMatch(pCredGroup, &pItem->CertThumbprint))
                {
                    continue;
                }
            }
        }
        else
        {
            // Make sure the thumbprint of the credential group matches the
            // thumbprint of the cache entry.
            if(!IsSameThumbprint(&pCredGroup->CredThumbprint, 
                                 &pItem->CredThumbprint))
            {
                continue;
            }
        }


        if(!IsSameTargetName(pItem->szCacheID, pszTargetName))
        {
            continue;
        }

        // Make sure that the application supports the cipher suite
        // used by this cache entry. This becomes important in the 
        // multi-process client cache scenario, since different client
        // applications may be running with different settings.
        if(!DoesAppAllowCipher(pCredGroup, pItem))
        {
            continue;
        }

        
        //
        // Found item in cache!!
        //

        if(pFoundEntry == NULL)
        {
            // This is the first matching entry found.
            SPCacheReference(pItem);

            // Remember the current entry.
            pFoundEntry = pItem;
        }
        else
        {
            if(pItem->CreationTime > pFoundEntry->CreationTime)
            {
                // We found a newer entry.
                SPCacheReference(pItem);

                // Disable searching on the previous item.
                pFoundEntry->ZombieJuju = FALSE;

                // Release the previous item.
                SPCacheDereference(pFoundEntry);

                // Remember the current entry.
                pFoundEntry = pItem;
            }
            else
            {
                // This item is older than the previously found entry.

                // Disable searching on the current entry.
                pItem->ZombieJuju = FALSE;
            }
        }
    }

    RtlReleaseResource(&SchannelCache.Lock);

    if(pFoundEntry)
    {
        // Found item in cache!!

        // Are we replacing something?
        // Then dereference the thing we are replacing.
        if(*ppRetItem)
        {
            SPCacheDereference(*ppRetItem);
        }

        // Return item referenced.
        *ppRetItem = pFoundEntry;

        DebugLog((DEB_TRACE, "    FOUND IT(0x%x)\n", pFoundEntry));
        InterlockedIncrement(&g_cClientReconnects);
    }
    else
    {
        DebugLog((DEB_TRACE, "    FAILED\n"));
    }

    return (pFoundEntry != NULL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CacheExpireElements
//
//  Synopsis:   Traverse the session cache and remove all expired entries. 
//              If the cache is oversized, then expire some entries
//              early.
//
//  Arguments:  [fCleanupOnly]  --  If this is set, then attempt to delete
//                                  cache entries previously expired. Don't
//                                  traverse the cache.
//
//  History:    01-02-2000  jbanes  Created.
//
//  Notes:      This routine should be called only once every five or ten
//              minutes. 
//
//----------------------------------------------------------------------------
BOOL
CacheExpireElements(
    BOOL fBackground)
{
    static LONG     RefCount = 0;
    LONG            LocalRefCount;
    DWORD           timeNow;
    PSessCacheItem  pItem;
    PLIST_ENTRY     pList;

    // 
    // If another thread is currently expiring elements, then try again 
    // later. 
    //

    LocalRefCount = InterlockedIncrement(&RefCount);

    if(fBackground && LocalRefCount > 1)
    {
        InterlockedDecrement(&RefCount);
        return FALSE;
    }

    RtlEnterCriticalSection(&g_CacheCleanupLock);


    //
    // Retrieve the current time.
    // 

    timeNow = GetTickCount();


    //
    // Search through the cache entries looking for expired entries.
    //

    RtlAcquireResourceExclusive(&SchannelCache.Lock, TRUE);

    pList = SchannelCache.EntryList.Flink;

    while(pList != &SchannelCache.EntryList)
    {
        pItem = CONTAINING_RECORD(pList, SessCacheItem, EntryList.Flink);
        pList = pList->Flink;

        ASSERT(pItem->Magic == SP_CACHE_MAGIC);

        // Is the cache entry currently being used?
        if(pItem->cRef > 1)
        {
            continue;
        }

        // Mark all expired cache entries as non-resumable.
        if(HasTimeElapsed(pItem->CreationTime, timeNow, pItem->Lifespan))
        {
            pItem->ZombieJuju = FALSE;
            pItem->DeferredJuju = FALSE;
        }

        // If the cache has gotten too large, then expire elements early. The 
        // cache elements are sorted by creation time, so the oldest
        // entries will be expired first.
        if(SchannelCache.dwUsedEntries > SchannelCache.dwMaximumEntries)
        {
            pItem->ZombieJuju = FALSE;
            pItem->DeferredJuju = FALSE;
        }
            
        // Don't remove entries that are still valid.
        if((pItem->ZombieJuju == TRUE) || (pItem->DeferredJuju == TRUE))
        {
            continue;
        }


        //
        // Remove this entry from the cache, and add it to the list of
        // entries to be destroyed.
        //

        RemoveEntryList(&pItem->IndexEntryList);
        RemoveEntryList(&pItem->EntryList);
        SchannelCache.dwUsedEntries--;

        InsertTailList(&g_CacheCleanupList, &pItem->EntryList);
    }

    RtlReleaseResource(&SchannelCache.Lock);


    // 
    // Kill the expired zombies.
    //

    pList = g_CacheCleanupList.Flink;

    while(pList != &g_CacheCleanupList)
    {
        pItem = CONTAINING_RECORD(pList, SessCacheItem, EntryList.Flink);
        pList = pList->Flink;

        ASSERT(pItem->Magic == SP_CACHE_MAGIC);

        // Remove entry from cleanup list.
        RemoveEntryList(&pItem->EntryList);

        // Destroy cache entry.
        SPCacheDelete(pItem);
    }

    RtlLeaveCriticalSection(&g_CacheCleanupLock);

    InterlockedDecrement(&RefCount);

    return TRUE;
}


VOID 
CacheCleanupHandler(
    PVOID pVoid, 
    BOOLEAN fTimeout)
{
    UNREFERENCED_PARAMETER(pVoid);

    if(SchannelCache.dwUsedEntries > 0)
    {
        if(fTimeout)
        {
            DebugLog((DEB_WARN, "Initiate periodic cache cleanup.\n"));
        }

        CacheExpireElements(TRUE);

        SPExpireIssuerCacheElements();

        ResetEvent(g_CacheCleanupEvent);
    }

    if(fTimeout)
    {
        GlobalCheckForCertificateRenewal();
    }
}


/* allocate a new cache item to be used
 * by a context.  Initialize it with the
 * pszTarget if the target exists.
 * Auto-Generate a SessionID
 */
BOOL
SPCacheRetrieveNew(
    BOOL                fServer,
    LPWSTR              pszTargetName,
    PSessCacheItem *    ppRetItem)
{
    DWORD           index;
    DWORD           timeNow;
    ULONG           ProcessID;
    LUID            LogonId = {0};
    PSessCacheItem pItem;
    BYTE            rgbSessionId[SP_MAX_SESSION_ID];

    DebugLog((DEB_TRACE, "SPCacheRetrieveNew called\n"));


    //
    // Trigger cache cleanup if too many cache entries already exist.
    //

    if(SchannelCache.dwUsedEntries > (SchannelCache.dwMaximumEntries * 21) / 20)
    {
        DebugLog((DEB_WARN, "Cache size (%d) exceeded threshold (%d), trigger cache cleanup.\n",
            SchannelCache.dwUsedEntries,
            SchannelCache.dwMaximumEntries));
        SetEvent(g_CacheCleanupEvent);
    }


    //
    // Retrieve the current time and user logon id.
    // 

    timeNow = GetTickCount();

    SslGetClientProcess(&ProcessID);

    if(!fServer)
    {
        SslGetClientLogonId(&LogonId);
    }


    // 
    // Compute the session id and the cache index.
    //

    if(fServer)
    {
        if(!RtlGenRandom(rgbSessionId, sizeof(rgbSessionId)))
        {
            return FALSE;
        }
        index = *(DWORD *)rgbSessionId % SchannelCache.dwCacheSize;
        *(DWORD *)rgbSessionId = index;
    }
    else
    {
        ZeroMemory(rgbSessionId, sizeof(rgbSessionId));
        index = ComputeClientCacheIndex(pszTargetName);
    }

    //
    // Allocate a new cache entry.
    //

    pItem = SPExternalAlloc(sizeof(SessCacheItem));
    if(pItem == NULL)
    {
        SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        return FALSE;
    }

    
    //
    // Fill in the cache internal fields.
    //

    pItem->Magic           = SP_CACHE_MAGIC;
    pItem->cRef            = 1;

    pItem->CreationTime    = timeNow;
    if(fServer)
    {
        pItem->Lifespan    = SchannelCache.dwServerLifespan;
    }
    else
    {
        pItem->Lifespan    = SchannelCache.dwClientLifespan;
    }

    pItem->ProcessID       = ProcessID;
    pItem->LogonId         = LogonId;

    if(pszTargetName)
    {
        pItem->szCacheID = SPExternalAlloc((lstrlenW(pszTargetName) + 1) * sizeof(WCHAR));
        if(pItem->szCacheID == NULL)
        {
            SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            SPExternalFree(pItem);
            return FALSE;
        }
        wcscpy(pItem->szCacheID, pszTargetName);
    }
    else
    {
        pItem->szCacheID = NULL;
    }

    memcpy(pItem->SessionID, rgbSessionId, sizeof(rgbSessionId));


    //
    // Give the caller a reference.
    //

    SPCacheReference(pItem);
    *ppRetItem = pItem;


    // 
    // Add the new entry to the cache.
    //

    RtlAcquireResourceExclusive(&SchannelCache.Lock, TRUE);

    InsertTailList(&SchannelCache.SessionCache[index], &pItem->IndexEntryList);
    InsertTailList(&SchannelCache.EntryList, &pItem->EntryList);
    SchannelCache.dwUsedEntries++;

    RtlReleaseResource(&SchannelCache.Lock);

    DebugLog((DEB_TRACE, "Create new cache entry at: 0x%x\n", pItem));
    
    return TRUE;
}

 
BOOL 
SPCacheAdd(
    PSPContext pContext)
{
    PSessCacheItem     pItem;
    PSPCredentialGroup  pCred;
    DWORD               dwLifespan;
    DWORD               timeNow;

    timeNow =  GetTickCount();

    pItem = pContext->RipeZombie;
    if(!pItem) return FALSE;

    ASSERT(pItem->Magic == SP_CACHE_MAGIC);

    pCred = pContext->pCredGroup;
    if(!pCred) return FALSE;

    if(pItem->fProtocol & SP_PROT_CLIENTS)
    {
        dwLifespan = min(pCred->dwSessionLifespan, SchannelCache.dwClientLifespan);
    }
    else
    {
        dwLifespan = min(pCred->dwSessionLifespan, SchannelCache.dwServerLifespan);
    }   


    // Remember which client certificate we used.
    if(pItem->fProtocol & SP_PROT_CLIENTS)
    {
        pItem->CredThumbprint = pContext->pCredGroup->CredThumbprint;

        if(pContext->pActiveClientCred)
        {
            DebugLog((DEB_TRACE, "Assign client certificate to cache entry: 0x%x\n", pItem));
            pItem->CertThumbprint = pContext->pActiveClientCred->CertThumbprint;
            pItem->pClientCert = CertDuplicateCertificateContext(pContext->pActiveClientCred->pCert);
            if(pItem->pClientCert == NULL)
            {
                SP_LOG_RESULT(GetLastError());
            }
        }
        else
        {
            DebugLog((DEB_TRACE, "Client cache entry 0x%x is anonymous.\n", pItem));
        }
    }

    // Are we supposed to defer reconnects for this connection?
    if(pItem->pServerCred != NULL)
    {
        if(pItem->pServerCred->dwFlags & CRED_FLAG_DISABLE_RECONNECTS)
        {
            pItem->DeferredJuju = TRUE;
        }
    }

    // Allow cache ownership of this item
    pItem->dwFlags |= SP_CACHE_FLAG_READONLY;
    if(!pItem->DeferredJuju)
    {
        pItem->ZombieJuju = TRUE;
    }

    // if we are a cloned item, abort the old
    // item, and then dereference it.
    if(pItem->pClonedItem)
    {
        pItem->pClonedItem->ZombieJuju = FALSE;
        SPCacheDereference(pItem->pClonedItem);
        pItem->pClonedItem = NULL;
    }

    pItem->Lifespan = dwLifespan;

    return TRUE;
}


void
SPCacheAssignNewServerCredential(
    PSessCacheItem pItem,
    PSPCredentialGroup pCred)
{
    SPReferenceCredential(pCred);

    if(pItem->pServerCred)
    {
        SPDereferenceCredential(pItem->pServerCred, FALSE);
    }

    pItem->pServerCred = pCred;
}


/* Allocate a new cache item, and copy 
 * over relevant information from old item,
 * and dereference old item.  This is a helper
 * for REDO
 */
BOOL
SPCacheClone(PSessCacheItem *ppItem)
{
    PSessCacheItem pNewItem;
    PSessCacheItem pOldItem;

    if(ppItem == NULL || *ppItem == NULL)
    {
        return FALSE;
    }
    pOldItem = *ppItem;

    ASSERT(pOldItem->Magic == SP_CACHE_MAGIC);
    ASSERT(!(pOldItem->fProtocol & SP_PROT_CLIENTS) || !(pOldItem->fProtocol & SP_PROT_SERVERS));

    // Get a fresh cache item.
    pNewItem = NULL;
    if(!SPCacheRetrieveNew((pOldItem->fProtocol & SP_PROT_CLIENTS) == 0,
                           pOldItem->szCacheID, 
                           &pNewItem))
    {
        return FALSE;
    }
    
    // Copy the master CSP prov handle.
    pNewItem->hMasterProv = pOldItem->hMasterProv;

    // Copy over old relevant data
    pNewItem->fProtocol         = pOldItem->fProtocol;
    pNewItem->dwCF              = pOldItem->dwCF;
    pNewItem->phMapper          = pOldItem->phMapper;

    if(pOldItem->pServerCred)
    {
        SPReferenceCredential(pOldItem->pServerCred);
        pNewItem->pServerCred   = pOldItem->pServerCred;
    }
    pNewItem->pActiveServerCred = pOldItem->pActiveServerCred;

    if(pOldItem->dwFlags & SP_CACHE_FLAG_MASTER_EPHEM)
    {
        pNewItem->dwFlags |= SP_CACHE_FLAG_MASTER_EPHEM;
    }

    pNewItem->CredThumbprint = pOldItem->CredThumbprint,

    // This item will be dereferenced, and 
    // Aborted when the new item is completed.
    pNewItem->pClonedItem = pOldItem;

    *ppItem = pNewItem;

    return TRUE;
}


NTSTATUS
SetCacheAppData(
    PSessCacheItem pItem,
    PBYTE pbAppData,
    DWORD cbAppData)
{
    RtlAcquireResourceExclusive(&SchannelCache.Lock, TRUE);

    if(pItem->pbAppData)
    {
        SPExternalFree(pItem->pbAppData);
    }

    pItem->pbAppData = pbAppData;
    pItem->cbAppData = cbAppData;

    RtlReleaseResource(&SchannelCache.Lock);

    return STATUS_SUCCESS;
}


NTSTATUS
GetCacheAppData(
    PSessCacheItem pItem,
    PBYTE *ppbAppData,
    DWORD *pcbAppData)
{
    if(pItem->pbAppData == NULL)
    {
        *ppbAppData = NULL;
        *pcbAppData = 0;
        return STATUS_SUCCESS;
    }

    RtlAcquireResourceShared(&SchannelCache.Lock, TRUE);

    *pcbAppData = pItem->cbAppData;
    *ppbAppData = SPExternalAlloc(pItem->cbAppData);
    if(*ppbAppData == NULL)
    {
        RtlReleaseResource(&SchannelCache.Lock);
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    memcpy(*ppbAppData, pItem->pbAppData, pItem->cbAppData);

    RtlReleaseResource(&SchannelCache.Lock);

    return STATUS_SUCCESS;
}


BOOL
IsEntryToBeProcessed(
    PSessCacheItem pItem,
    PLUID   LogonID,
    ULONG   ProcessID,
    LPWSTR  pszTargetName,
    DWORD   dwFlags)
{
    //
    // Validate client entries.
    //

    if(pItem->fProtocol & SP_PROT_CLIENTS)
    {
        if((dwFlags & SSL_PURGE_CLIENT_ENTRIES) == 0 &&
           (dwFlags & SSL_PURGE_CLIENT_ALL_ENTRIES) == 0)
        {
            return FALSE;
        }

        if((dwFlags & SSL_PURGE_CLIENT_ALL_ENTRIES) == 0)
        {
            if(!RtlEqualLuid(&pItem->LogonId, LogonID))
            {
                return FALSE;
            }
        }

        if(pszTargetName != NULL)
        {
            if(pItem->szCacheID == NULL || 
               wcscmp(pItem->szCacheID, pszTargetName) != 0)
            {
                return FALSE;
            }
        }

        return TRUE;
    }


    //
    // Validate server entries.
    //

    if(pItem->fProtocol & SP_PROT_SERVERS)
    {
        if((dwFlags & SSL_PURGE_SERVER_ENTRIES) == 0 &&
           (dwFlags & SSL_PURGE_SERVER_ALL_ENTRIES) == 0)
        {
            return FALSE;
        }

        if(ProcessID != pItem->ProcessID)
        {
            if((dwFlags & SSL_PURGE_SERVER_ALL_ENTRIES) == 0)
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}



NTSTATUS
SPCachePurgeEntries(
    LUID *LogonID,
    ULONG ProcessID,
    LPWSTR pszTargetName,
    DWORD dwFlags)
{
    PSessCacheItem pItem;
    PLIST_ENTRY pList;
    LIST_ENTRY DeleteList;


    //
    // Initialize the list of deleted entries.
    //

    InitializeListHead(&DeleteList);


    //
    // Enumerate through the cache entries.
    //

    RtlAcquireResourceExclusive(&SchannelCache.Lock, TRUE);

    pList = SchannelCache.EntryList.Flink;

    while(pList != &SchannelCache.EntryList)
    {
        pItem = CONTAINING_RECORD(pList, SessCacheItem, EntryList.Flink);
        pList = pList->Flink;

        ASSERT(pItem->Magic == SP_CACHE_MAGIC);

        if(!IsEntryToBeProcessed(pItem,
                                 LogonID,
                                 ProcessID,
                                 pszTargetName,
                                 dwFlags))
        {
            continue;
        }

        if(pItem->cRef > 1)
        {
            // This entry is currently being used, so don't delete.
            // Mark it as non-resumable, though.
            pItem->ZombieJuju = FALSE;
            pItem->DeferredJuju = FALSE;
            continue;
        }

        //
        // Remove this entry from the cache, and add it to the list of
        // entries to be destroyed.
        //

        RemoveEntryList(&pItem->IndexEntryList);
        RemoveEntryList(&pItem->EntryList);
        SchannelCache.dwUsedEntries--;

        InsertTailList(&DeleteList, &pItem->EntryList);
    }

    RtlReleaseResource(&SchannelCache.Lock);


    // 
    // Kill the purged zombies.
    //

    pList = DeleteList.Flink;

    while(pList != &DeleteList)
    {
        pItem = CONTAINING_RECORD(pList, SessCacheItem, EntryList.Flink);
        pList = pList->Flink;

        ASSERT(pItem->Magic == SP_CACHE_MAGIC);

        SPCacheDelete(pItem);
    }

    //
    // Purge the issuer cache.
    //

    if(dwFlags & SSL_PURGE_SERVER_ENTRIES)
    {
        SPPurgeIssuerCache();
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SPCacheGetInfo(
    LUID *  LogonID,
    LPWSTR  pszTargetName,
    DWORD   dwFlags,
    PSSL_SESSION_CACHE_INFO_RESPONSE pCacheInfo)
{
    PSessCacheItem pItem;
    PLIST_ENTRY pList;
    DWORD timeNow;
    ULONG ProcessID;

    UNREFERENCED_PARAMETER(LogonID);
    UNREFERENCED_PARAMETER(pszTargetName);

    pCacheInfo->CacheSize       = SchannelCache.dwMaximumEntries;
    pCacheInfo->Entries         = 0;
    pCacheInfo->ActiveEntries   = 0;
    pCacheInfo->Zombies         = 0;
    pCacheInfo->ExpiredZombies  = 0;
    pCacheInfo->AbortedZombies  = 0;
    pCacheInfo->DeletedZombies  = 0;

    timeNow = GetTickCount();

    SslGetClientProcess(&ProcessID);


    RtlAcquireResourceExclusive(&SchannelCache.Lock, TRUE);

    pList = SchannelCache.EntryList.Flink;

    while(pList != &SchannelCache.EntryList)
    {
        pItem = CONTAINING_RECORD(pList, SessCacheItem, EntryList.Flink);
        pList = pList->Flink;

        ASSERT(pItem->Magic == SP_CACHE_MAGIC);

        if(pItem->fProtocol & SP_PROT_CLIENTS)
        {
            if((dwFlags & SSL_RETRIEVE_CLIENT_ENTRIES) == 0)
            {
                continue;
            }
        }
        else
        {
            if((dwFlags & SSL_RETRIEVE_SERVER_ENTRIES) == 0)
            {
                continue;
            }
        }

        pCacheInfo->Entries++;

        if(pItem->cRef == 1)
        {
            pCacheInfo->Zombies++;

            if(HasTimeElapsed(pItem->CreationTime, 
                              timeNow, 
                              pItem->Lifespan))
            {
                pCacheInfo->ExpiredZombies++;
            }
            if(pItem->ZombieJuju == FALSE)
            {
                pCacheInfo->AbortedZombies++;
            }
        }
        else
        {
            pCacheInfo->ActiveEntries++;
        }
    }

    RtlReleaseResource(&SchannelCache.Lock);

    return STATUS_SUCCESS;
}


NTSTATUS
SPCacheGetPerfmonInfo(
    DWORD   dwFlags,
    PSSL_PERFMON_INFO_RESPONSE pPerfmonInfo)
{
    PSessCacheItem pItem;
    PLIST_ENTRY pList;

    UNREFERENCED_PARAMETER(dwFlags);

    // 
    // Compute performance numbers.
    //

    pPerfmonInfo->ClientHandshakesPerSecond = g_cClientHandshakes;
    pPerfmonInfo->ServerHandshakesPerSecond = g_cServerHandshakes;
    pPerfmonInfo->ClientReconnectsPerSecond = g_cClientReconnects;
    pPerfmonInfo->ServerReconnectsPerSecond = g_cServerReconnects;


    //
    // Compute cache info.
    //

    pPerfmonInfo->ClientCacheEntries  = 0;
    pPerfmonInfo->ServerCacheEntries  = 0;
    pPerfmonInfo->ClientActiveEntries = 0;
    pPerfmonInfo->ServerActiveEntries = 0;

    RtlAcquireResourceShared(&SchannelCache.Lock, TRUE);

    pList = SchannelCache.EntryList.Flink;

    while(pList != &SchannelCache.EntryList)
    {
        pItem = CONTAINING_RECORD(pList, SessCacheItem, EntryList.Flink);
        pList = pList->Flink;

        ASSERT(pItem->Magic == SP_CACHE_MAGIC);


        if(pItem->fProtocol & SP_PROT_CLIENTS)
        {
            pPerfmonInfo->ClientCacheEntries++;

            if(pItem->cRef > 1)
            {
                pPerfmonInfo->ClientActiveEntries++;
            }
        }
        else
        {
            pPerfmonInfo->ServerCacheEntries++;

            if(pItem->cRef > 1)
            {
                pPerfmonInfo->ServerActiveEntries++;
            }
        }
    }

    RtlReleaseResource(&SchannelCache.Lock);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\cert.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cert.c
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//              01-05-98   jbanes   Use WinVerifyTrust to validate certs.
//              03-26-99   jbanes   Fix CTL support, bug #303246 
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <spbase.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <wincrypt.h>
#include <oidenc.h>
#include <softpub.h>

#define CERT_HEADER_CONST "certificate"
#define CERT_HEADER_LENGTH 11
#define CERT_HEADER_OFFSET 6

SP_STATUS
SchGetTrustedRoots(
    HCERTSTORE *phClientRootStore);

BOOL
WINAPI
SchCreateWorldStore (
     IN HCERTSTORE hRoot,
     IN DWORD cAdditionalStore,
     IN HCERTSTORE* rghAdditionalStore,
     OUT HCERTSTORE* phWorld);

BOOL
IsCertSelfSigned(PCCERT_CONTEXT pCertContext);


// typedef struct _OIDPROVMAP
// {
//     LPSTR   szOid;
//     DWORD   dwExchSpec;
//     DWORD   dwCertType;         // used for SSL 3.0 client auth
// }  OIDPROVMAP, *POIDPROVMAP;

OIDPROVMAP g_CertTypes[] = 
{
    { szOID_RSA_RSA,                  SP_EXCH_RSA_PKCS1,     SSL3_CERTTYPE_RSA_SIGN},
    { szOID_RSA_MD2RSA,               SP_EXCH_RSA_PKCS1,     SSL3_CERTTYPE_RSA_SIGN},
    { szOID_RSA_MD4RSA,               SP_EXCH_RSA_PKCS1,     SSL3_CERTTYPE_RSA_SIGN},
    { szOID_RSA_MD5RSA,               SP_EXCH_RSA_PKCS1,     SSL3_CERTTYPE_RSA_SIGN},
    { szOID_RSA_SHA1RSA,              SP_EXCH_RSA_PKCS1,     SSL3_CERTTYPE_RSA_SIGN},
    { szOID_OIWSEC_dsa,               SP_EXCH_DH_PKCS3,      SSL3_CERTTYPE_DSS_SIGN},
    { szOID_X957_DSA,                 SP_EXCH_DH_PKCS3,      SSL3_CERTTYPE_DSS_SIGN},
};

DWORD g_cCertTypes = sizeof(g_CertTypes)/sizeof(OIDPROVMAP);


DWORD 
MapOidToKeyExch(LPSTR szOid)
{
    DWORD i;

    for(i = 0; i < g_cCertTypes; i++)
    {
        if(strcmp(szOid, g_CertTypes[i].szOid) == 0)
        {
            return g_CertTypes[i].dwExchSpec;
        }
    }
    return 0;
}

DWORD 
MapOidToCertType(LPSTR szOid)
{
    DWORD i;

    for(i = 0; i < g_cCertTypes; i++)
    {
        if(strcmp(szOid, g_CertTypes[i].szOid) == 0)
        {
            return g_CertTypes[i].dwCertType;
        }
    }
    return 0;
}


// SPLoadCertificate takes a string of encoded cert bytes
// and decodes them into the local certificate cache.  It
// then returns the first certificate of the group.

SP_STATUS
SPLoadCertificate(
    DWORD      fProtocol,
    DWORD      dwCertEncodingType,
    PUCHAR     pCertificate,
    DWORD      cbCertificate,
    PCCERT_CONTEXT *ppCertContext)
{
    HCERTSTORE      hCertStore   = NULL;
    PCCERT_CONTEXT  pCertContext = NULL;

    PBYTE           pbCurrentRaw;
    DWORD           cbCurrentRaw;
    BOOL            fLeafCert;
    SP_STATUS       pctRet;


    //
    // Dereference the cert that we are replacing.
    //

    if(ppCertContext == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(*ppCertContext != NULL)
    {
        CertFreeCertificateContext(*ppCertContext);
    }
    *ppCertContext = NULL;


    //
    // Create an in-memory certificate store.
    //

    hCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY, 
                               0, 0, 
                               CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG, 
                               0);
    if(hCertStore == NULL)
    {
        SP_LOG_RESULT(GetLastError());
        return SEC_E_INSUFFICIENT_MEMORY;
    }

    fLeafCert    = TRUE;
    pbCurrentRaw = pCertificate;
    cbCurrentRaw = cbCertificate;

    do 
    {

        //
        // Skip to beginning of certificate.
        //

        if((fProtocol & SP_PROT_SSL3TLS1) && cbCurrentRaw > 3)
        {
            // SSL3 style cert chain, where the length
            // of each cert is prepended.
            pbCurrentRaw += 3;
            cbCurrentRaw -= 3;
        }

        // Skip past the "certificate" header
        if((cbCurrentRaw > (CERT_HEADER_OFFSET + CERT_HEADER_LENGTH)) && 
            (memcmp(pbCurrentRaw + CERT_HEADER_OFFSET, CERT_HEADER_CONST, CERT_HEADER_LENGTH) == 0))
        {
            pbCurrentRaw += CERT_HEADER_OFFSET + CERT_HEADER_LENGTH;
            cbCurrentRaw -= CERT_HEADER_OFFSET + CERT_HEADER_LENGTH;
        }


        //
        // Decode this certificate context.
        //

        if(!CertAddEncodedCertificateToStore(hCertStore, 
                                             dwCertEncodingType,
                                             pbCurrentRaw,
                                             cbCurrentRaw,
                                             CERT_STORE_ADD_USE_EXISTING,
                                             &pCertContext))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_ERR_BAD_CERTIFICATE;
            goto cleanup;
        }

        pbCurrentRaw += pCertContext->cbCertEncoded;
        if(cbCurrentRaw < pCertContext->cbCertEncoded)
        {
            pctRet =  SP_LOG_RESULT(PCT_ERR_BAD_CERTIFICATE);
            goto cleanup;
        }
        cbCurrentRaw -= pCertContext->cbCertEncoded;

        if(fLeafCert)
        {
            fLeafCert = FALSE;
            *ppCertContext = pCertContext;
        }
        else
        {
            CertFreeCertificateContext(pCertContext);
        }
        pCertContext = NULL;

    } while(cbCurrentRaw);

    pctRet = PCT_ERR_OK;


cleanup:

    CertCloseStore(hCertStore, 0);

    if(pctRet != PCT_ERR_OK)
    {
        if(pCertContext)
        {
            CertFreeCertificateContext(pCertContext);
        }
        if(*ppCertContext)
        {
            CertFreeCertificateContext(*ppCertContext);
            *ppCertContext = NULL;
        }
    }

    return pctRet;
}


SP_STATUS  
SPPublicKeyFromCert(
    PCCERT_CONTEXT  pCert, 
    PUBLICKEY **    ppKey,
    ExchSpec *      pdwExchSpec)
{
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo;
    PUBLICKEY * pPublicKey;
    DWORD       dwExchSpec;
    DWORD       cbBlob;
    SP_STATUS   pctRet;

    //
    // Log the subject and issuer names.
    //

    LogDistinguishedName(DEB_TRACE, 
                         "Subject: %s\n", 
                         pCert->pCertInfo->Subject.pbData, 
                         pCert->pCertInfo->Subject.cbData);

    LogDistinguishedName(DEB_TRACE, 
                         "Issuer: %s\n", 
                         pCert->pCertInfo->Issuer.pbData, 
                         pCert->pCertInfo->Issuer.cbData);

    //
    // Determine type of public key embedded in the certificate.
    //

    pPubKeyInfo = &pCert->pCertInfo->SubjectPublicKeyInfo;
    if(pPubKeyInfo == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    dwExchSpec = MapOidToKeyExch(pPubKeyInfo->Algorithm.pszObjId);

    if(dwExchSpec == 0)
    {
        return PCT_INT_UNKNOWN_CREDENTIAL;
    }

    //
    // Build public key blob from encoded public key.
    //

    switch(dwExchSpec)
    {
    case SP_EXCH_RSA_PKCS1:
        pctRet = RsaPublicKeyFromCert(pPubKeyInfo,
                                      NULL,
                                      &cbBlob);
        if(pctRet != PCT_ERR_OK)
        {
            return pctRet;
        }

        pPublicKey = SPExternalAlloc(sizeof(PUBLICKEY) + cbBlob);
        if(pPublicKey == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }

        pPublicKey->pPublic  = (BLOBHEADER *)(pPublicKey + 1);
        pPublicKey->cbPublic = cbBlob;

        pctRet = RsaPublicKeyFromCert(pPubKeyInfo,
                                      pPublicKey->pPublic,
                                      &pPublicKey->cbPublic);
        if(pctRet != PCT_ERR_OK)
        {
            SPExternalFree(pPublicKey);
            return pctRet;
        }
        break;

    case SP_EXCH_DH_PKCS3:
        pctRet = DssPublicKeyFromCert(pPubKeyInfo,
                                      NULL,
                                      &cbBlob);
        if(pctRet != PCT_ERR_OK)
        {
            return pctRet;
        }

        pPublicKey = SPExternalAlloc(sizeof(PUBLICKEY) + cbBlob);
        if(pPublicKey == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }

        pPublicKey->pPublic  = (BLOBHEADER *)(pPublicKey + 1);
        pPublicKey->cbPublic = cbBlob;

        pctRet = DssPublicKeyFromCert(pPubKeyInfo,
                                      pPublicKey->pPublic,
                                      &pPublicKey->cbPublic);
        if(pctRet != PCT_ERR_OK)
        {
            SPExternalFree(pPublicKey);
            return pctRet;
        }
        break;

    default:
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }


    //
    // Set function outputs.
    //

    *ppKey = pPublicKey;

    if(pdwExchSpec)
    {
        *pdwExchSpec = dwExchSpec;
    }

    return PCT_ERR_OK;
}


SP_STATUS
SPSerializeCertificate(
    DWORD           dwProtocol,         // in
    BOOL            fBuildChain,        // in
    PBYTE *         ppCertChain,        // out
    DWORD *         pcbCertChain,       // out
    PCCERT_CONTEXT  pCertContext,       // in
    DWORD           dwChainingFlags)    // in
{
    PCCERT_CHAIN_CONTEXT pChainContext = NULL;
    CERT_CHAIN_PARA      ChainPara;
    PCERT_SIMPLE_CHAIN   pSimpleChain;
    PCCERT_CONTEXT       pCurrentCert;

    BOOL        fSuccess = FALSE;
    PBYTE       pbCertChain;
    DWORD       cbCertChain;
    DWORD       i;
    SP_STATUS   pctRet;
    BOOL        fImpersonating = FALSE;

    SP_BEGIN("SPSerializeCertificate");

    if(pcbCertChain == NULL)
    {
        SP_RETURN( SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    if(fBuildChain)
    {
        ZeroMemory(&ChainPara, sizeof(ChainPara));
        ChainPara.cbSize = sizeof(ChainPara);

        fImpersonating = SslImpersonateClient();

        if(!(fSuccess = CertGetCertificateChain(
                                NULL,
                                pCertContext,
                                NULL,
                                NULL,
                                &ChainPara,
                                dwChainingFlags,
                                NULL,
                                &pChainContext)))
        {
            DebugLog((DEB_WARN, "Error 0x%x returned by CertGetCertificateChain!\n", GetLastError()));
            pChainContext = NULL;
        }

        if(fImpersonating) 
        {
            RevertToSelf();
            fImpersonating = FALSE;
        }
    }

    if(!fSuccess)
    {
        //
        // Send the leaf certificate only.
        //

        // Compute size of chain.
        cbCertChain = pCertContext->cbCertEncoded;
        if(dwProtocol & SP_PROT_SSL3TLS1)
        {
            cbCertChain += CB_SSL3_CERT_VECTOR;
        }

        // Allocate memory for chain.
        if(ppCertChain == NULL)
        {
            *pcbCertChain = cbCertChain;
            pctRet = PCT_ERR_OK;
            goto cleanup;
        }
        else if(*ppCertChain == NULL)
        {
            *ppCertChain = SPExternalAlloc(cbCertChain);
            if(*ppCertChain == NULL)
            {
                pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                goto cleanup;
            }
        }
        else if(*pcbCertChain < cbCertChain)
        {
            pctRet = SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
            goto cleanup;
        }
        *pcbCertChain = cbCertChain;

        // Place chain in output buffer.
        pbCertChain = *ppCertChain;

        if(dwProtocol & SP_PROT_SSL3TLS1)
        {
            pbCertChain[0] = MS24BOF(pCertContext->cbCertEncoded);
            pbCertChain[1] = MSBOF(pCertContext->cbCertEncoded);
            pbCertChain[2] = LSBOF(pCertContext->cbCertEncoded);
            pbCertChain += CB_SSL3_CERT_VECTOR;
        }
        CopyMemory(pbCertChain, pCertContext->pbCertEncoded, pCertContext->cbCertEncoded);

        pctRet = PCT_ERR_OK;
        goto cleanup;
    }


    //
    // Compute size of chain.
    //

    pSimpleChain = pChainContext->rgpChain[0];
    cbCertChain  = 0;

    for(i = 0; i < pSimpleChain->cElement; i++)
    {
        pCurrentCert = pSimpleChain->rgpElement[i]->pCertContext;
        
        if(i > 0)
        {
            // Verify that this is not a root certificate.
            if(CertCompareCertificateName(pCurrentCert->dwCertEncodingType, 
                                          &pCurrentCert->pCertInfo->Issuer,
                                          &pCurrentCert->pCertInfo->Subject))
            {
                break;
            }
        }

        cbCertChain += pCurrentCert->cbCertEncoded;
        if(dwProtocol & SP_PROT_SSL3TLS1)
        {
            cbCertChain += CB_SSL3_CERT_VECTOR;
        }
    }


    //
    // Allocate memory for chain.
    //

    if(ppCertChain == NULL)
    {
        *pcbCertChain = cbCertChain;
        pctRet = PCT_ERR_OK;
        goto cleanup;
    }
    else if(*ppCertChain == NULL)
    {
        *ppCertChain = SPExternalAlloc(cbCertChain);
        if(*ppCertChain == NULL)
        {
            pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }
    }
    else if(*pcbCertChain < cbCertChain)
    {
        pctRet = SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        goto cleanup;
    }
    *pcbCertChain = cbCertChain;


    //
    // Place chain in output buffer.
    //

    pbCertChain = *ppCertChain;

    for(i = 0; i < pSimpleChain->cElement; i++)
    {
        pCurrentCert = pSimpleChain->rgpElement[i]->pCertContext;
        
        if(i > 0)
        {
            // Verify that this is not a root certificate.
            if(CertCompareCertificateName(pCurrentCert->dwCertEncodingType, 
                                          &pCurrentCert->pCertInfo->Issuer,
                                          &pCurrentCert->pCertInfo->Subject))
            {
                break;
            }
        }

        if(dwProtocol & SP_PROT_SSL3TLS1)
        {
            pbCertChain[0] = MS24BOF(pCurrentCert->cbCertEncoded);
            pbCertChain[1] = MSBOF(pCurrentCert->cbCertEncoded);
            pbCertChain[2] = LSBOF(pCurrentCert->cbCertEncoded);
            pbCertChain += CB_SSL3_CERT_VECTOR;
        }
        CopyMemory(pbCertChain, pCurrentCert->pbCertEncoded, pCurrentCert->cbCertEncoded);
        pbCertChain += pCurrentCert->cbCertEncoded;
    }

    SP_ASSERT(*ppCertChain + cbCertChain == pbCertChain);

    pctRet = PCT_ERR_OK;

cleanup:

    if(pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }

    SP_RETURN(pctRet);
}


/*****************************************************************************/
SP_STATUS 
ExtractIssuerNamesFromStore(
    HCERTSTORE  hStore,         // in
    PBYTE       pbIssuers,      // out
    DWORD       *pcbIssuers)    // in, out
{
    DWORD cbCurIssuerLen = 0;
    DWORD cbIssuerLen = *pcbIssuers;
    PBYTE pbCurIssuer = pbIssuers;
    PCCERT_CONTEXT pCurrent = NULL;
    SECURITY_STATUS scRet;
    BOOL fIsAllowed;

    // Initialize output to zero.
    *pcbIssuers = 0;

    while(TRUE)
    {
        pCurrent = CertEnumCertificatesInStore(hStore, pCurrent);
        if(pCurrent == NULL) break;

        // Is this a client-auth certificate?
        scRet = SPCheckKeyUsage(pCurrent,
                                szOID_PKIX_KP_CLIENT_AUTH,
                                FALSE,
                                &fIsAllowed);
        if(scRet != SEC_E_OK)
        {
            continue;
        }
        if(!fIsAllowed)
        {
            continue;
        }

        cbCurIssuerLen += 2 + pCurrent->pCertInfo->Subject.cbData;

        // Are we writing?
        if(pbIssuers)
        {
            if(cbCurIssuerLen > cbIssuerLen)
            {
                // Memory overrun
                CertFreeCertificateContext(pCurrent);
                return SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW);
            }

            pbCurIssuer[0] = MSBOF(pCurrent->pCertInfo->Subject.cbData);
            pbCurIssuer[1] = LSBOF(pCurrent->pCertInfo->Subject.cbData);
            pbCurIssuer += 2;

            CopyMemory(pbCurIssuer, pCurrent->pCertInfo->Subject.pbData,
            pCurrent->pCertInfo->Subject.cbData);
            pbCurIssuer += pCurrent->pCertInfo->Subject.cbData;
        }
    }

    *pcbIssuers = cbCurIssuerLen;

    return PCT_ERR_OK;
}


/*****************************************************************************/
SP_STATUS 
GetDefaultIssuers(
    PBYTE   pbIssuers,      // out
    DWORD   *pcbIssuers)    // in, out
{
    HCERTSTORE  hStore;
    SP_STATUS   pctRet;

    pctRet = SchGetTrustedRoots(&hStore);
    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }

    pctRet = ExtractIssuerNamesFromStore(hStore, pbIssuers, pcbIssuers);
    if(pctRet != PCT_ERR_OK)
    {
        CertCloseStore(hStore, 0);
        return pctRet;
    }

    CertCloseStore(hStore, 0);
    return PCT_ERR_OK;
}


SP_STATUS
SchGetTrustedRoots(
    HCERTSTORE *phClientRootStore)
{
    HTTPSPolicyCallbackData  polHttps;
    CERT_CHAIN_POLICY_PARA   PolicyPara;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_PARA          ChainPara;
    PCCERT_CHAIN_CONTEXT     pChainContext = NULL;
    LPSTR                    pszUsage;

    PCCERT_CONTEXT  pCertContext;
    HCERTSTORE      hClientRootStore = 0;
    HCERTSTORE      hRootStore       = 0;
    HCERTSTORE      hWorldStore      = 0;
    SP_STATUS       Status           = SEC_E_OK;
    BOOL            fImpersonating   = FALSE;



    // Open output store.
    hClientRootStore = CertOpenStore(CERT_STORE_PROV_MEMORY, 
                                     0, 0, 
                                     CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG, 
                                     0);
    if(hClientRootStore == NULL)
    {
        //SP_LOG_RESULT(GetLastError());
        Status = SEC_E_INSUFFICIENT_MEMORY;
        goto cleanup;
    }

    fImpersonating = SslImpersonateClient();

    // Open root store.
    hRootStore = CertOpenSystemStore(0, "ROOT");
    if(hRootStore == NULL)
    {
        DebugLog((DEB_WARN, "Error 0x%x opening root store\n", GetLastError()));
    }

    // Create world store.
    if(!SchCreateWorldStore(hRootStore,
                            0, NULL, 
                            &hWorldStore))
    {
        DebugLog((DEB_ERROR, "Error 0x%x creating world store\n", GetLastError()));
        goto cleanup;
    }

    // Enumerate the certificates in the world store, looking 
    // for trusted roots. This approach will automatically take
    // advantage of any CTLs that are installed on the system.
    pCertContext = NULL;
    while(TRUE)
    {
        pCertContext = CertEnumCertificatesInStore(hWorldStore, pCertContext);
        if(pCertContext == NULL) break;

        if(!IsCertSelfSigned(pCertContext))
        {
            continue;
        }

        pszUsage = szOID_PKIX_KP_CLIENT_AUTH;

        ZeroMemory(&ChainPara, sizeof(ChainPara));
        ChainPara.cbSize = sizeof(ChainPara);
        ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_OR;
        ChainPara.RequestedUsage.Usage.cUsageIdentifier     = 1;
        ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = &pszUsage;

        if(!CertGetCertificateChain(
                                NULL,
                                pCertContext,
                                NULL,
                                0,
                                &ChainPara,
                                0,
                                NULL,
                                &pChainContext))
        {
            SP_LOG_RESULT(GetLastError());
            continue;
        }

        // Set up validate chain structures.
        ZeroMemory(&polHttps, sizeof(HTTPSPolicyCallbackData));
        polHttps.cbStruct           = sizeof(HTTPSPolicyCallbackData);
        polHttps.dwAuthType         = AUTHTYPE_CLIENT;
        polHttps.fdwChecks          = 0;
        polHttps.pwszServerName     = NULL;

        ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
        PolicyStatus.cbSize         = sizeof(PolicyStatus);

        ZeroMemory(&PolicyPara, sizeof(PolicyPara));
        PolicyPara.cbSize           = sizeof(PolicyPara);
        PolicyPara.pvExtraPolicyPara= &polHttps;
        PolicyPara.dwFlags = CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS;

        // Validate chain
        if(!CertVerifyCertificateChainPolicy(
                                CERT_CHAIN_POLICY_SSL,
                                pChainContext,
                                &PolicyPara,
                                &PolicyStatus))
        {
            SP_LOG_RESULT(GetLastError());
            CertFreeCertificateChain(pChainContext);
            continue;
        }

        if(PolicyStatus.dwError)
        {
            // Certificate did not validate, move on to the next one.
            CertFreeCertificateChain(pChainContext);
            continue;
        }

        CertFreeCertificateChain(pChainContext);

        // Add the root certificate to the list of trusted ones.
        if(!CertAddCertificateContextToStore(hClientRootStore,
                                             pCertContext,
                                             CERT_STORE_ADD_USE_EXISTING,
                                             NULL))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }

cleanup:

    if(hRootStore)
    {
        CertCloseStore(hRootStore, 0);
    }

    if(hWorldStore)
    {
        CertCloseStore(hWorldStore, 0);
    }

    if(fImpersonating)
    {
        RevertToSelf();
    }

    if(Status == SEC_E_OK)
    {
        *phClientRootStore = hClientRootStore;
    }

    return Status;
}


//+---------------------------------------------------------------------------
//
//  Function:   ChainCreateCollectionIncludingCtlCertificates
//
//  Synopsis:   create a collection which includes the source store hStore and
//              any CTL certificates from it
//
//----------------------------------------------------------------------------
BOOL WINAPI
ChainCreateCollectionIncludingCtlCertificates (
     IN HCERTSTORE hStore,
     OUT HCERTSTORE* phCollection
     )
{
    BOOL          fResult = FALSE;
    HCERTSTORE    hCollection;
    PCCTL_CONTEXT pCtlContext = NULL;
    HCERTSTORE    hCtlStore;

    hCollection = CertOpenStore(
                      CERT_STORE_PROV_COLLECTION,
                      X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                      0,
                      CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                      NULL
                      );

    if ( hCollection == NULL )
    {
        return( FALSE );
    }

    fResult = CertAddStoreToCollection( hCollection, hStore, 0, 0 );

    while ( ( fResult == TRUE ) &&
            ( ( pCtlContext = CertEnumCTLsInStore(
                                  hStore,
                                  pCtlContext
                                  ) ) != NULL ) )
    {
        hCtlStore = CertOpenStore(
                        CERT_STORE_PROV_MSG,
                        X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                        0,
                        0,
                        pCtlContext->hCryptMsg
                        );

        if ( hCtlStore != NULL )
        {
            fResult = CertAddStoreToCollection(
                          hCollection,
                          hCtlStore,
                          0,
                          0
                          );

            CertCloseStore( hCtlStore, 0 );
        }
    }

    if ( fResult == TRUE )
    {
        *phCollection = hCollection;
    }
    else
    {
        CertCloseStore( hCollection, 0 );
    }

    return( fResult );
}


BOOL
WINAPI
SchCreateWorldStore (
     IN HCERTSTORE hRoot,
     IN DWORD cAdditionalStore,
     IN HCERTSTORE* rghAdditionalStore,
     OUT HCERTSTORE* phWorld)
{
    BOOL       fResult;
    HCERTSTORE hWorld;
    HCERTSTORE hStore, hCtl;
    DWORD      cCount;

    hWorld = CertOpenStore(
                 CERT_STORE_PROV_COLLECTION,
                 X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                 0,
                 CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                 NULL
                 );

    if ( hWorld == NULL )
    {
        return( FALSE );
    }

    fResult = CertAddStoreToCollection( hWorld, hRoot, 0, 0 );

    for ( cCount = 0;
          ( cCount < cAdditionalStore ) && ( fResult == TRUE );
          cCount++ )
    {
        fResult = CertAddStoreToCollection(
                      hWorld,
                      rghAdditionalStore[ cCount ],
                      0,
                      0
                      );
    }

    if ( fResult == TRUE )
    {
        hStore = CertOpenSystemStore(0, "trust");
        if( hStore != NULL )
        {
            if(ChainCreateCollectionIncludingCtlCertificates(hStore, &hCtl))
            {
                if(!CertAddStoreToCollection( hWorld, hCtl, 0, 0 ))
                {
                    DebugLog((DEB_WARN, "Error 0x%x adding CTL collection\n", GetLastError()));
                }
                CertCloseStore( hCtl, 0 );
            }
            else
            {
                DebugLog((DEB_WARN, "Error 0x%x creating CTL collection\n", GetLastError()));
            }
            CertCloseStore( hStore, 0 );
        }
    }

    if ( fResult == TRUE )
    {
        hStore = CertOpenSystemStore(0, "ca");
        if ( hStore != NULL )
        {
            fResult = CertAddStoreToCollection( hWorld, hStore, 0, 0 );
            CertCloseStore( hStore, 0 );
        }
        else
        {
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        hStore = CertOpenSystemStore(0, "my");
        if ( hStore != NULL )
        {
            fResult = CertAddStoreToCollection( hWorld, hStore, 0, 0 );
            CertCloseStore( hStore, 0 );
        }
        else
        {
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        *phWorld = hWorld;
    }
    else
    {
        CertCloseStore( hWorld, 0 );
    }

    return( fResult );
}


BOOL
IsCertSelfSigned(PCCERT_CONTEXT pCertContext)
{
    // Compare subject and issuer names.
    if(pCertContext->pCertInfo->Subject.cbData == pCertContext->pCertInfo->Issuer.cbData)
    {
        if(memcmp(pCertContext->pCertInfo->Subject.pbData,
                  pCertContext->pCertInfo->Issuer.pbData,  
                  pCertContext->pCertInfo->Issuer.cbData) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}


SECURITY_STATUS
MapWinTrustError(
    SECURITY_STATUS Status, 
    SECURITY_STATUS DefaultError, 
    DWORD dwIgnoreErrors)
{
    if((Status == CRYPT_E_NO_REVOCATION_CHECK) &&
       (dwIgnoreErrors & CRED_FLAG_IGNORE_NO_REVOCATION_CHECK))
    {
        DebugLog((DEB_WARN, "MapWinTrustError: Ignoring CRYPT_E_NO_REVOCATION_CHECK\n"));
        Status = STATUS_SUCCESS;
    }
    if((Status == CRYPT_E_REVOCATION_OFFLINE) &&
       (dwIgnoreErrors & CRED_FLAG_IGNORE_REVOCATION_OFFLINE))
    {
        DebugLog((DEB_WARN, "MapWinTrustError: Ignoring CRYPT_E_REVOCATION_OFFLINE\n"));
        Status = STATUS_SUCCESS;
    }

    if(HRESULT_FACILITY(Status) == FACILITY_SECURITY)
    {
        return (Status);
    }

    switch(Status)
    {
        case ERROR_SUCCESS:
            return SEC_E_OK;

        // Expired certificate.
        case CERT_E_EXPIRED:
        case CERT_E_VALIDITYPERIODNESTING:
            return SEC_E_CERT_EXPIRED;

        // Unknown CA
        case CERT_E_UNTRUSTEDROOT:
        case CERT_E_UNTRUSTEDCA:
            return SEC_E_UNTRUSTED_ROOT;

        // Certificate revoked.
        case CERT_E_REVOKED:
            return CRYPT_E_REVOKED;

        // Target name doesn't match name in certificate.
        case CERT_E_CN_NO_MATCH:
            return SEC_E_WRONG_PRINCIPAL;

        // Certificate contains wrong EKU.
        case CERT_E_WRONG_USAGE:
            return SEC_E_CERT_WRONG_USAGE;

        // Some other error.
        default:
            if(DefaultError)
            {
                return DefaultError;
            }
            else
            {
                return SEC_E_CERT_UNKNOWN;
            }
    }
}

NTSTATUS
VerifyClientCertificate(
    PCCERT_CONTEXT  pCertContext,
    DWORD           dwCertFlags,
    DWORD           dwIgnoreErrors,
    LPCSTR          pszPolicyOID,
    PCCERT_CHAIN_CONTEXT *ppChainContext)   // optional
{
    HTTPSPolicyCallbackData  polHttps;
    CERT_CHAIN_POLICY_PARA   PolicyPara;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_PARA          ChainPara;
    PCCERT_CHAIN_CONTEXT     pChainContext = NULL;
    DWORD                    Status;
    LPSTR                    pszUsage;
    BOOL                     fImpersonating = FALSE;

    //
    // Build certificate chain.
    //

    fImpersonating = SslImpersonateClient();

    pszUsage = szOID_PKIX_KP_CLIENT_AUTH;

    ZeroMemory(&ChainPara, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);
    ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_OR;
    ChainPara.RequestedUsage.Usage.cUsageIdentifier     = 1;
    ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = &pszUsage;

    if(!CertGetCertificateChain(
                            NULL,                       // hChainEngine
                            pCertContext,               // pCertContext
                            NULL,                       // pTime
                            pCertContext->hCertStore,   // hAdditionalStore
                            &ChainPara,                 // pChainPara
                            dwCertFlags,                // dwFlags
                            NULL,                       // pvReserved
                            &pChainContext))            // ppChainContext
    {
        Status = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }


    //
    // Validate certificate chain.
    // 

    if(pszPolicyOID == CERT_CHAIN_POLICY_NT_AUTH)
    {
        ZeroMemory(&PolicyPara, sizeof(PolicyPara));
        PolicyPara.cbSize   = sizeof(PolicyPara);
        PolicyPara.dwFlags  = BASIC_CONSTRAINTS_CERT_CHAIN_POLICY_END_ENTITY_FLAG;
    }
    else
    {
        ZeroMemory(&polHttps, sizeof(HTTPSPolicyCallbackData));
        polHttps.cbStruct   = sizeof(HTTPSPolicyCallbackData);
        polHttps.dwAuthType = AUTHTYPE_CLIENT;
        polHttps.fdwChecks  = 0;

        ZeroMemory(&PolicyPara, sizeof(PolicyPara));
        PolicyPara.cbSize            = sizeof(PolicyPara);
        PolicyPara.pvExtraPolicyPara = &polHttps;
    }

    ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);

    if(!CertVerifyCertificateChainPolicy(
                            pszPolicyOID,
                            pChainContext,
                            &PolicyPara,
                            &PolicyStatus))
    {
        Status = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }

#if DBG
    if(PolicyStatus.dwError)
    {
        DebugLog((DEB_WARN, "CertVerifyCertificateChainPolicy returned 0x%x\n", PolicyStatus.dwError));
    }
#endif

    Status = MapWinTrustError(PolicyStatus.dwError, 0, dwIgnoreErrors);

    if(Status)
    {
        DebugLog((DEB_ERROR, "MapWinTrustError returned 0x%x\n", Status));
        goto cleanup;
    }

    Status = STATUS_SUCCESS;

    if(ppChainContext != NULL)
    {
        *ppChainContext = pChainContext;
        pChainContext = NULL;
    }

cleanup:

    if(pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }

    if(fImpersonating) RevertToSelf();

    return Status;
}


NTSTATUS
AutoVerifyServerCertificate(PSPContext pContext)
{
    PSPCredentialGroup pCredGroup;
    DWORD dwCertFlags = 0;
    DWORD dwIgnoreErrors = 0;

    if(pContext->Flags & CONTEXT_FLAG_MANUAL_CRED_VALIDATION)
    {
        return STATUS_SUCCESS;
    }

    pCredGroup = pContext->pCredGroup;
    if(pCredGroup == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    if(pCredGroup->dwFlags & CRED_FLAG_REVCHECK_END_CERT)
        dwCertFlags |= CERT_CHAIN_REVOCATION_CHECK_END_CERT;
    if(pCredGroup->dwFlags & CRED_FLAG_REVCHECK_CHAIN)
        dwCertFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN;
    if(pCredGroup->dwFlags & CRED_FLAG_REVCHECK_CHAIN_EXCLUDE_ROOT)
        dwCertFlags |= CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    if(pCredGroup->dwFlags & CRED_FLAG_IGNORE_NO_REVOCATION_CHECK)
        dwIgnoreErrors |= CRED_FLAG_IGNORE_NO_REVOCATION_CHECK;
    if(pCredGroup->dwFlags & CRED_FLAG_IGNORE_REVOCATION_OFFLINE)
        dwIgnoreErrors |= CRED_FLAG_IGNORE_REVOCATION_OFFLINE;

    return VerifyServerCertificate(pContext, dwCertFlags, dwIgnoreErrors);
}


NTSTATUS
VerifyServerCertificate(
    PSPContext  pContext,
    DWORD       dwCertFlags,
    DWORD       dwIgnoreErrors)
{
    HTTPSPolicyCallbackData  polHttps;
    CERT_CHAIN_POLICY_PARA   PolicyPara;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_PARA          ChainPara;
    PCCERT_CHAIN_CONTEXT     pChainContext = NULL;

    #define SERVER_USAGE_COUNT 3
    LPSTR               rgszUsages[SERVER_USAGE_COUNT] = {
                            szOID_PKIX_KP_SERVER_AUTH,
                            szOID_SERVER_GATED_CRYPTO,
                            szOID_SGC_NETSCAPE };
 
    NTSTATUS            Status;
    PWSTR               pwszServerName = NULL;
    PSPCredentialGroup  pCred;
    PCCERT_CONTEXT      pCertContext;
    BOOL                fImpersonating = FALSE;

    pCred = pContext->pCredGroup;
    if(pCred == NULL)
    {
        return SEC_E_INTERNAL_ERROR;
    }

    pCertContext = pContext->RipeZombie->pRemoteCert;
    if(pCertContext == NULL)
    {
        return SEC_E_INTERNAL_ERROR;
    }


    //
    // Build certificate chain.
    //

    fImpersonating = SslImpersonateClient();

    ZeroMemory(&ChainPara, sizeof(ChainPara));
    ChainPara.cbSize = sizeof(ChainPara);
    ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_OR;
    ChainPara.RequestedUsage.Usage.cUsageIdentifier     = SERVER_USAGE_COUNT;
    ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = rgszUsages;

    if(!CertGetCertificateChain(
                            NULL,                       // hChainEngine
                            pCertContext,               // pCertContext
                            NULL,                       // pTime
                            pCertContext->hCertStore,   // hAdditionalStore
                            &ChainPara,                 // pChainPara
                            dwCertFlags,                // dwFlags
                            NULL,                       // pvReserved
                            &pChainContext))            // ppChainContext
    {
        Status = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }


    //
    // Validate certificate chain.
    // 

    if(!(pCred->dwFlags & CRED_FLAG_NO_SERVERNAME_CHECK))
    {
        pwszServerName = pContext->RipeZombie->szCacheID;

        if(pwszServerName == NULL || lstrlenW(pwszServerName) == 0)
        {
            Status = SP_LOG_RESULT(SEC_E_WRONG_PRINCIPAL);
            goto cleanup;
        }
    }

    ZeroMemory(&polHttps, sizeof(HTTPSPolicyCallbackData));
    polHttps.cbStruct           = sizeof(HTTPSPolicyCallbackData);
    polHttps.dwAuthType         = AUTHTYPE_SERVER;
    polHttps.fdwChecks          = 0;
    polHttps.pwszServerName     = pwszServerName;

    ZeroMemory(&PolicyPara, sizeof(PolicyPara));
    PolicyPara.cbSize            = sizeof(PolicyPara);
    PolicyPara.pvExtraPolicyPara = &polHttps;

    ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
    PolicyStatus.cbSize = sizeof(PolicyStatus);

    if(!CertVerifyCertificateChainPolicy(
                            CERT_CHAIN_POLICY_SSL,
                            pChainContext,
                            &PolicyPara,
                            &PolicyStatus))
    {
        Status = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }

#if DBG
    if(PolicyStatus.dwError)
    {
        DebugLog((DEB_WARN, "CertVerifyCertificateChainPolicy returned 0x%x\n", PolicyStatus.dwError));
    }
#endif

    Status = MapWinTrustError(PolicyStatus.dwError, 0, dwIgnoreErrors);

    if(Status)
    {
        DebugLog((DEB_ERROR, "MapWinTrustError returned 0x%x\n", Status));
        LogBogusServerCertEvent(pCertContext, pwszServerName, Status);
        goto cleanup;
    }

    Status = STATUS_SUCCESS;


cleanup:

    if(pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }

    if(fImpersonating) RevertToSelf();

    return Status;
}


SECURITY_STATUS
SPCheckKeyUsage(
    PCCERT_CONTEXT  pCertContext, 
    PSTR            pszUsage,
    BOOL            fOnCertOnly,
    PBOOL           pfIsAllowed)
{
    PCERT_ENHKEY_USAGE pKeyUsage;
    DWORD cbKeyUsage;
    DWORD j;
    BOOL  fFound;
    DWORD dwFlags = 0;

    if(fOnCertOnly)
    {
        dwFlags = CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG;
    }

    // Determine size of usage information.
    if(!CertGetEnhancedKeyUsage(pCertContext,
                                dwFlags, 
                                NULL,
                                &cbKeyUsage))
    {
        // No usage information exists.
        *pfIsAllowed = TRUE;
        return SEC_E_OK;
    }

    SafeAllocaAllocate(pKeyUsage, cbKeyUsage);
    if(pKeyUsage == NULL)
    {
        *pfIsAllowed = FALSE;
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    // Read key usage information.
    if(!CertGetEnhancedKeyUsage(pCertContext,
                                dwFlags, 
                                pKeyUsage,
                                &cbKeyUsage))
    {
        // No usage information exists.
        SafeAllocaFree(pKeyUsage);
        *pfIsAllowed = TRUE;
        return SEC_E_OK;
    }

    if(pKeyUsage->cUsageIdentifier == 0 && GetLastError() == CRYPT_E_NOT_FOUND)
    {
        // No usage information exists.
        SafeAllocaFree(pKeyUsage);
        *pfIsAllowed = TRUE;
        return SEC_E_OK;
    }

    // See if requested usage is in list of supported usages.
    fFound = FALSE;
    for(j = 0; j < pKeyUsage->cUsageIdentifier; j++)
    {
        if(strcmp(pszUsage, pKeyUsage->rgpszUsageIdentifier[j]) == 0)
        {
            fFound = TRUE;
            break;
        }
    }

    SafeAllocaFree(pKeyUsage);

    if(!fFound)
    {
        // Usage extensions found, but doesn't list ours.
        *pfIsAllowed = FALSE;
    }
    else
    {
        *pfIsAllowed = TRUE;
    }

    return SEC_E_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\certmap.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       certmap.c
//
//  Contents:   Routines to call appropriate mapper, be it the system
//              default one (in the LSA process) or an application one (in
//              the application process).
//
//  Classes:
//
//  Functions:
//
//  History:    12-23-96   jbanes   Created.
//
//----------------------------------------------------------------------------

#include <spbase.h>

DWORD
WINAPI
SslReferenceMapper(HMAPPER *phMapper)
{
    if(phMapper == NULL)
    {
        return SP_LOG_RESULT((DWORD)-1);
    }

    // System mapper.
    return phMapper->m_vtable->ReferenceMapper(phMapper);
}


DWORD
WINAPI
SslDereferenceMapper(HMAPPER *phMapper)
{
    if(phMapper == NULL)
    {
        return SP_LOG_RESULT(0);
    }

    // System mapper.
    return phMapper->m_vtable->DeReferenceMapper(phMapper);
}


SECURITY_STATUS
WINAPI
SslGetMapperIssuerList(
    HMAPPER *   phMapper,           // in
    BYTE **     ppIssuerList,       // out
    DWORD *     pcbIssuerList)      // out
{
    SECURITY_STATUS Status;

    if(phMapper == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    // System mapper.
    Status = phMapper->m_vtable->GetIssuerList(phMapper,
                                          0,
                                          NULL,
                                          pcbIssuerList);

    if(!NT_SUCCESS(Status))
    {
        return SP_LOG_RESULT(Status);
    }

    *ppIssuerList = SPExternalAlloc(*pcbIssuerList);
    if(*ppIssuerList == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    Status = phMapper->m_vtable->GetIssuerList(phMapper,
                                          0,
                                          *ppIssuerList,
                                          pcbIssuerList);
    if(!NT_SUCCESS(Status))
    {
        SPExternalFree(*ppIssuerList);
        return SP_LOG_RESULT(Status);
    }

    return Status;
}


SECURITY_STATUS
WINAPI
SslGetMapperChallenge(
    HMAPPER *   phMapper,           // in
    BYTE *      pAuthenticatorId,   // in
    DWORD       cbAuthenticatorId,  // in
    BYTE *      pChallenge,         // out
    DWORD *     pcbChallenge)       // out
{
    UNREFERENCED_PARAMETER(phMapper);
    UNREFERENCED_PARAMETER(pAuthenticatorId);
    UNREFERENCED_PARAMETER(cbAuthenticatorId);
    UNREFERENCED_PARAMETER(pChallenge);
    UNREFERENCED_PARAMETER(pcbChallenge);

    return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
}


SECURITY_STATUS
WINAPI
SslMapCredential(
    HMAPPER *   phMapper,           // in
    DWORD       dwCredentialType,   // in
    PCCERT_CONTEXT pCredential,     // in
    PCCERT_CONTEXT pAuthority,      // in
    HLOCATOR *  phLocator)          // out
{
    SECURITY_STATUS scRet;

    if(phMapper == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    // System mapper.
    scRet = phMapper->m_vtable->MapCredential(phMapper,
                                             dwCredentialType,
                                             pCredential,
                                             pAuthority,
                                             phLocator);
    return MapWinTrustError(scRet, SEC_E_NO_IMPERSONATION, 0);
}


SECURITY_STATUS
WINAPI
SslCloseLocator(
    HMAPPER *   phMapper,           // in
    HLOCATOR    hLocator)           // in
{
    if(phMapper == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
    }

    // System mapper.
    return phMapper->m_vtable->CloseLocator(phMapper,
                                            hLocator);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\context.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       context.c
//
//  Contents:   Schannel context management routines.
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <certmap.h>
#include <mapper.h>
#include <dsysdbg.h>

DWORD g_cContext = 0;

/************************************************************************
* SPContextCreate
*
* Create a new SPContext, and initialize it.
*
* Returns - PSPContext pointer to context object.
*
\***********************************************************************/

PSPContext SPContextCreate(LPWSTR pszTarget)
{

    PSPContext pContext;

    SP_BEGIN("SPContextCreate");

    pContext = (PSPContext)SPExternalAlloc( sizeof(SPContext));
    if(!pContext)
    {
        SP_RETURN(NULL);
    }

    DebugLog((DEB_TRACE, "Create context:0x%p\n", pContext));

    FillMemory(pContext, sizeof(SPContext), 0);

    pContext->Magic = SP_CONTEXT_MAGIC;
    pContext->Flags = 0;

    if(!NT_SUCCESS(GenerateRandomThumbprint(&pContext->ContextThumbprint)))
    {
        SPExternalFree(pContext);
        SP_RETURN(NULL);
    }

    if(pszTarget)
    {
        pContext->pszTarget = SPExternalAlloc((lstrlenW(pszTarget) + 1) * sizeof(WCHAR));
        if(pContext->pszTarget == NULL)
        {
            SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            SPExternalFree(pContext);
            SP_RETURN(NULL);
        }
        lstrcpyW(pContext->pszTarget, pszTarget);
    }


    pContext->dwRequestedCF = CF_EXPORT;
    pContext->dwRequestedCF |= CF_DOMESTIC;

    pContext->fCertChainsAllowed = FALSE;

    g_cContext++;

    SP_RETURN(pContext);
}


/************************************************************************
* VOID SPContextClean(PSPContext pContext)
*
* Clean out everything used by the handshake (in case we want
* to do another).
*
\***********************************************************************/

BOOL
SPContextClean(PSPContext pContext)
{
    SP_BEGIN("SPContextClean");

    if(pContext == NULL || pContext->Magic != SP_CONTEXT_MAGIC) {
        DebugLog((DEB_WARN, "Attempt to delete invalid context\n"));
        SP_RETURN(FALSE);
    }

    if(pContext->pbEncryptedKey)
    {
        SPExternalFree(pContext->pbEncryptedKey);
        pContext->pbEncryptedKey = NULL;
    }

    if(pContext->pbServerKeyExchange)
    {
        SPExternalFree(pContext->pbServerKeyExchange);
        pContext->pbServerKeyExchange = NULL;
    }

    if(pContext->pbIssuerList)
    {
        SPExternalFree(pContext->pbIssuerList);
        pContext->pbIssuerList = NULL;
    }

    if(pContext->pClientHello)
    {
        SPExternalFree(pContext->pClientHello);
        pContext->pClientHello = NULL;
    }

    if((pContext->Flags & CONTEXT_FLAG_FULL_HANDSHAKE) &&
       (pContext->RipeZombie != NULL) &&
       (pContext->RipeZombie->pClientCred != NULL))
    {
        // We've just done a client-side full handshake in which a default
        // client certificate was selected. This client credential 
        // technically belongs to the cache (so that other contexts can
        // query the certificate etc) but we want to free up the 
        // application-process hProv now, while we're in the context
        // of the owning process.
        PSPCredential pClientCred = pContext->RipeZombie->pClientCred;

        if(pClientCred->hRemoteProv)
        {
            if(!RemoteCryptReleaseContext(
                                pClientCred->hRemoteProv,
                                0))
            {
                SP_LOG_RESULT(GetLastError());
            }
            pClientCred->hRemoteProv = 0;
        }
    }

    pContext->fExchKey = FALSE;

    SP_RETURN(TRUE);
}


/************************************************************************
* VOID SPDeleteContext(PSPContext pContext)
*
* Delete an existing context object.
*
\***********************************************************************/

BOOL
SPContextDelete(PSPContext pContext)
{
    SP_BEGIN("SPContextDelete");

    DebugLog((DEB_TRACE, "Delete context:0x%p\n", pContext));

    if(pContext == NULL || pContext->Magic != SP_CONTEXT_MAGIC)
    {
        DebugLog((DEB_WARN, "Attempt to delete invalid context\n"));
        SP_RETURN(FALSE);
    }

//    DsysAssert((pContext->pCredGroup->dwFlags & CRED_FLAG_DELETED) == 0);

    if(pContext->State != SP_STATE_CONNECTED &&
       pContext->State != SP_STATE_SHUTDOWN)
    {
        DebugLog((DEB_WARN, "Attempting to delete an incompleted context\n"));

        // The context is being deleted in the middle of a handshake, 
        // which is curious. This may be caused by the user aborting
        // an operation, or it may be caused by a reconfiguration of 
        // the remote computer that caused the reconnect attempt to
        // fail. If it's the latter cause, then the only way to recover
        // is to request a full handshake next time. We have no way 
        // of knowing which it is, so it's probably best that we kill 
        // the current cache  entry.
        if(pContext->RipeZombie)
        {
            pContext->RipeZombie->ZombieJuju = FALSE;
            pContext->RipeZombie->DeferredJuju = FALSE;
        }
    }

    SPContextClean(pContext);

    if(pContext->pszTarget)
    {
        SPExternalFree(pContext->pszTarget);
        pContext->pszTarget = NULL;
    }

    if(pContext->pszCredentialName)
    {
        SPExternalFree(pContext->pszCredentialName);
        pContext->pszCredentialName = NULL;
    }

    //
    // Delete session keys.
    //

    if(pContext->hReadKey)
    {
        CryptDestroyKey(pContext->hReadKey);
        pContext->hReadKey = 0;
    }
    if(pContext->hPendingReadKey)
    {
        CryptDestroyKey(pContext->hPendingReadKey);
        pContext->hPendingReadKey = 0;
    }
    if(pContext->hWriteKey)
    {
        CryptDestroyKey(pContext->hWriteKey);
        pContext->hWriteKey = 0;
    }
    if(pContext->hPendingWriteKey)
    {
        CryptDestroyKey(pContext->hPendingWriteKey);
        pContext->hPendingWriteKey = 0;
    }

    if(pContext->hReadMAC)
    {
        CryptDestroyKey(pContext->hReadMAC);
        pContext->hReadMAC = 0;
    }
    if(pContext->hPendingReadMAC)
    {
        CryptDestroyKey(pContext->hPendingReadMAC);
        pContext->hPendingReadMAC = 0;
    }
    if(pContext->hWriteMAC)
    {
        CryptDestroyKey(pContext->hWriteMAC);
        pContext->hWriteMAC = 0;
    }
    if(pContext->hPendingWriteMAC)
    {
        CryptDestroyKey(pContext->hPendingWriteMAC);
        pContext->hPendingWriteMAC = 0;
    }


    //
    // Delete the handshake hashes
    //

    if(pContext->hMd5Handshake)
    {
        CryptDestroyHash(pContext->hMd5Handshake);
        pContext->hMd5Handshake = 0;
    }
    if(pContext->hShaHandshake)
    {
        CryptDestroyHash(pContext->hShaHandshake);
        pContext->hShaHandshake = 0;
    }

    SPDereferenceCredential(pContext->pCredGroup, FALSE);

    SPCacheDereference(pContext->RipeZombie);

    FillMemory( pContext, sizeof( SPContext ), 0 );
    g_cContext--;

    SPExternalFree( pContext );
    SP_RETURN(TRUE);
}

/************************************************************************
* SPContext SPContextSetCredentials
*
* Associate a set of credentials with a context.
*
* Returns - PSPContext pointer to context object.
*
\***********************************************************************/
SP_STATUS
SPContextSetCredentials(
    PSPContext pContext,
    PSPCredentialGroup  pCred)
{
    BOOL fNewCredentials = FALSE;

    SP_BEGIN("SPContextSetCredentials");

    if(pContext->Magic != SP_CONTEXT_MAGIC)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }


    //
    // Associate the credential group with the context.
    //

    if(pCred != pContext->pCredGroup)
    {
        if(pContext->pCredGroup)
        {
            SPDereferenceCredential(pContext->pCredGroup, FALSE);
        }

        SPReferenceCredential(pCred);

        pContext->pCredGroup = pCred;

        fNewCredentials = TRUE;
    }


    //
    // Set the protocol.
    //

    if(pContext->State == SP_STATE_NONE)
    {
        switch(pCred->grbitProtocol)
        {
            case SP_PROT_UNI_CLIENT:
            case SP_PROT_UNI_SERVER:
            case SP_PROT_PCT1_CLIENT:
            case SP_PROT_PCT1_SERVER:
            case SP_PROT_SSL2_CLIENT:
            case SP_PROT_SSL2_SERVER:
            case SP_PROT_SSL3_CLIENT:
            case SP_PROT_SSL3_SERVER:
            case SP_PROT_TLS1_CLIENT:
            case SP_PROT_TLS1_SERVER:
                pContext->ProtocolHandler = ServerProtocolHandler;
                pContext->InitiateHello   = GenerateHello;
                break;

            default:
                SP_RETURN(SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH));
        }
    }


    //
    // If the client application has supplied a new credential, then
    // attempt to choose a suitable client certificate to send to
    // the server.
    //

    if(fNewCredentials &&
       pContext->State == SSL3_STATE_GEN_SERVER_HELLORESP)
    {
        Ssl3CheckForExistingCred(pContext);
    }


    //
    // Allow the "manual cred validation" flag to be set from either
    // AcquireCredentialsHandle or InitializeSecurityContext.
    //

    if(pCred->dwFlags & CRED_FLAG_MANUAL_CRED_VALIDATION)
    {
        if((pContext->Flags & CONTEXT_FLAG_MUTUAL_AUTH) == 0)
        {
            pContext->Flags |= CONTEXT_FLAG_MANUAL_CRED_VALIDATION;
        }
    }

    SP_RETURN(PCT_ERR_OK);
}

SP_STATUS
ContextInitCiphersFromCache(SPContext *pContext)
{
    PSessCacheItem     pZombie;
    SP_STATUS           pctRet;

    pZombie = pContext->RipeZombie;

    pContext->pPendingCipherInfo = GetCipherInfo(pZombie->aiCipher, pZombie->dwStrength);
    pContext->pPendingHashInfo = GetHashInfo(pZombie->aiHash);
    pContext->pKeyExchInfo = GetKeyExchangeInfo(pZombie->SessExchSpec);

    pContext->dwPendingCipherSuiteIndex = pZombie->dwCipherSuiteIndex;

    if(!IsCipherAllowed(pContext,
                        pContext->pPendingCipherInfo,
                        pZombie->fProtocol,
                        pZombie->dwCF))
    {
        pContext->pPendingCipherInfo = NULL;
        return (SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH));
    }

    // Load the pending hash structure
    pContext->pPendingHashInfo = GetHashInfo(pZombie->aiHash);

    if(!IsHashAllowed(pContext,
                      pContext->pPendingHashInfo,
                      pZombie->fProtocol))
    {
        pContext->pPendingHashInfo = NULL;
        return (SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH));
    }

    // load the exch info structure
    pContext->pKeyExchInfo = GetKeyExchangeInfo(pZombie->SessExchSpec);
    if(!IsExchAllowed(pContext,
                      pContext->pKeyExchInfo,
                      pZombie->fProtocol))
    {
        pContext->pKeyExchInfo = NULL;
        return (SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH));
    }


    // Determine the CSP to use, based on the key exchange algorithm.
    pctRet = DetermineClientCSP(pContext);
    if(pctRet != PCT_ERR_OK)
    {
        return SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
    }

#if DBG
    switch(pZombie->fProtocol)
    {
    case SP_PROT_PCT1_CLIENT:
        DebugLog((DEB_TRACE, "Protocol:PCT Client\n"));
        break;

    case SP_PROT_PCT1_SERVER:
        DebugLog((DEB_TRACE, "Protocol:PCT Server\n"));
        break;

    case SP_PROT_SSL2_CLIENT:
        DebugLog((DEB_TRACE, "Protocol:SSL2 Client\n"));
        break;

    case SP_PROT_SSL2_SERVER:
        DebugLog((DEB_TRACE, "Protocol:SSL2 Server\n"));
        break;

    case SP_PROT_SSL3_CLIENT:
        DebugLog((DEB_TRACE, "Protocol:SSL3 Client\n"));
        break;

    case SP_PROT_SSL3_SERVER:
        DebugLog((DEB_TRACE, "Protocol:SSL3 Server\n"));
        break;

    case SP_PROT_TLS1_CLIENT:
        DebugLog((DEB_TRACE, "Protocol:TLS Client\n"));
        break;

    case SP_PROT_TLS1_SERVER:
        DebugLog((DEB_TRACE, "Protocol:TLS Server\n"));
        break;

    default:
        DebugLog((DEB_TRACE, "Protocol:0x%x\n", pZombie->fProtocol));
    }

    DebugLog((DEB_TRACE, "Cipher:  %s\n", pContext->pPendingCipherInfo->szName));
    DebugLog((DEB_TRACE, "Strength:%d\n", pContext->pPendingCipherInfo->dwStrength));
    DebugLog((DEB_TRACE, "Hash:    %s\n", pContext->pPendingHashInfo->szName));
    DebugLog((DEB_TRACE, "Exchange:%s\n", pContext->pKeyExchInfo->szName));
#endif

    return PCT_ERR_OK;
}


SP_STATUS
DetermineClientCSP(PSPContext pContext)
{
    if(!(pContext->RipeZombie->fProtocol & SP_PROT_CLIENTS))
    {
        return PCT_ERR_OK;
    }

    if(pContext->RipeZombie->hMasterProv != 0)
    {
        return PCT_ERR_OK;
    }

    switch(pContext->pKeyExchInfo->Spec)
    {
        case SP_EXCH_RSA_PKCS1:
            pContext->RipeZombie->hMasterProv = g_hRsaSchannel;
            break;

        case SP_EXCH_DH_PKCS3:
            pContext->RipeZombie->hMasterProv = g_hDhSchannelProv;
            break;

        default:
            DebugLog((DEB_ERROR, "Appropriate Schannel CSP not available!\n"));
            pContext->RipeZombie->hMasterProv = 0;
            return SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
    }

    return PCT_ERR_OK;
}


SP_STATUS
ContextInitCiphers(
    SPContext *pContext,
    BOOL fRead,
    BOOL fWrite)
{
    SP_BEGIN("ContextInitCiphers");

    if((pContext == NULL) ||
        (pContext->RipeZombie == NULL))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }


    pContext->pCipherInfo = pContext->pPendingCipherInfo;
    if ((NULL == pContext->pCipherInfo) || ((pContext->RipeZombie->fProtocol & pContext->pCipherInfo->fProtocol) == 0))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH));
    }

    pContext->pHashInfo = pContext->pPendingHashInfo;
    if ((NULL == pContext->pHashInfo)|| ((pContext->RipeZombie->fProtocol & pContext->pHashInfo->fProtocol) == 0))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH));
    }

    if (NULL == pContext->pKeyExchInfo)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH));
    }

    if(fRead)
    {
        pContext->pReadCipherInfo = pContext->pPendingCipherInfo;
        pContext->pReadHashInfo   = pContext->pPendingHashInfo;
    }
    if(fWrite)
    {
        pContext->pWriteCipherInfo = pContext->pPendingCipherInfo;
        pContext->pWriteHashInfo   = pContext->pPendingHashInfo;
    }


    SP_RETURN(PCT_ERR_OK);
}


SP_STATUS
SPContextDoMapping(
    PSPContext pContext)
{
    PSessCacheItem     pZombie;
    PSPCredentialGroup  pCred;
    SP_STATUS           pctRet;
    LONG                iMapper;

    SP_BEGIN("SPContextDoMapping");

    if(pContext->Flags & CONTEXT_FLAG_NO_CERT_MAPPING)
    {
        DebugLog((DEB_TRACE, "Skip certificate mapper\n"));
        SP_RETURN(PCT_ERR_OK);
    }

    pZombie = pContext->RipeZombie;
    pCred   = pContext->RipeZombie->pServerCred;

    for(iMapper = 0; iMapper < pCred->cMappers; iMapper++)
    {
        DebugLog((DEB_TRACE, "Invoke certificate mapper\n"));

        // Invoke mapper.
        pctRet = SslMapCredential(
                            pCred->pahMappers[iMapper],
                            X509_ASN_CHAIN,
                            pZombie->pRemoteCert,
                            NULL,
                            &pZombie->hLocator);

        pCred->pahMappers[iMapper]->m_dwFlags |= SCH_FLAG_MAPPER_CALLED;

        if(NT_SUCCESS(pctRet))
        {
            // Mapping was successful.
            DebugLog((DEB_TRACE, "Mapping was successful (0x%p)\n", pZombie->hLocator));

            SslReferenceMapper(pCred->pahMappers[iMapper]);
            if(pZombie->phMapper)
            {
                SslDereferenceMapper(pZombie->phMapper);
            }
            pZombie->phMapper = pCred->pahMappers[iMapper];
            pZombie->LocatorStatus = SEC_E_OK;
            break;
        }
        else
        {
            // Mapping failed.
            DebugLog((DEB_TRACE, "Mapping failed (0x%x)\n", pctRet));

            pZombie->LocatorStatus = pctRet;
        }
    }

    SP_RETURN(PCT_ERR_OK);
}

SP_STATUS
RemoveDuplicateIssuers(
    PBYTE  pbIssuers,
    PDWORD pcbIssuers)
{
    DWORD cbIssuers = *pcbIssuers;
    DWORD cBlob;
    PCRYPT_DATA_BLOB rgBlob;
    DWORD cbIssuer;
    PBYTE pbIssuer;
    PBYTE pbSource, pbDest;
    DWORD i, j;


    if(pbIssuers == NULL || cbIssuers < 2)
    {
        return PCT_ERR_OK;
    }

    // Count number of issuers.
    cBlob = 0;
    pbIssuer = pbIssuers;
    while(pbIssuer + 1 < pbIssuers + cbIssuers)
    {
        cbIssuer = MAKEWORD(pbIssuer[1], pbIssuer[0]);

        pbIssuer += 2 + cbIssuer;
        cBlob++;
    }

    // Allocate memory for blob list.
    rgBlob = SPExternalAlloc(cBlob * sizeof(CRYPT_DATA_BLOB));
    if(rgBlob == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    // Build blob list.
    cBlob = 0;
    pbIssuer = pbIssuers;
    while(pbIssuer + 1 < pbIssuers + cbIssuers)
    {
        cbIssuer = MAKEWORD(pbIssuer[1], pbIssuer[0]);
        rgBlob[cBlob].cbData = 2 + cbIssuer;
        rgBlob[cBlob].pbData = pbIssuer;

        pbIssuer += 2 + cbIssuer;
        cBlob++;
    }

    // Mark duplicates.
    for(i = 0; i < cBlob; i++)
    {
        if(rgBlob[i].pbData == NULL) continue;

        for(j = i + 1; j < cBlob; j++)
        {
            if(rgBlob[j].pbData == NULL) continue;

            if(rgBlob[i].cbData == rgBlob[j].cbData &&
               memcmp(rgBlob[i].pbData, rgBlob[j].pbData, rgBlob[j].cbData) == 0)
            {
                // duplicate found
                rgBlob[j].pbData = NULL;
            }
        }
    }

    // Compact list.
    pbSource = pbIssuers;
    pbDest   = pbIssuers;
    for(i = 0; i < cBlob; i++)
    {
        if(rgBlob[i].pbData)
        {
            if(pbDest != pbSource)
            {
                MoveMemory(pbDest, pbSource, rgBlob[i].cbData);
            }
            pbDest += rgBlob[i].cbData;
        }
        pbSource += rgBlob[i].cbData;
    }
    *pcbIssuers = (DWORD)(pbDest - pbIssuers);

    // Free blob list.
    SPExternalFree(rgBlob);

    return PCT_ERR_OK;
}


SP_STATUS
SPContextGetIssuers(
    PSPCredentialGroup pCredGroup)
{
    LONG    i;
    PBYTE   pbIssuerList;
    DWORD   cbIssuerList;
    PBYTE   pbIssuer;
    DWORD   cbIssuer;
    PBYTE   pbNew;
    DWORD   Status;

    LockCredentialExclusive(pCredGroup);

    if((pCredGroup->pbTrustedIssuers != NULL) && 
       !(pCredGroup->dwFlags & CRED_FLAG_UPDATE_ISSUER_LIST))
    {
        // Issuer list has already been built.
        Status = PCT_ERR_OK;
        goto cleanup;
    }


    // Free existing issuer list.
    if(pCredGroup->pbTrustedIssuers)
    {
        LocalFree(pCredGroup->pbTrustedIssuers);
        pCredGroup->pbTrustedIssuers = NULL;
        pCredGroup->cbTrustedIssuers = 0;
    }
    pCredGroup->dwFlags &= ~CRED_FLAG_UPDATE_ISSUER_LIST;


    //
    // Get issuers from application-specified ROOT store.
    //

    pbIssuerList  = NULL;
    cbIssuerList = 0;

    while(pCredGroup->hApplicationRoots)
    {
        Status = ExtractIssuerNamesFromStore(pCredGroup->hApplicationRoots,
                                             NULL, 
                                             &cbIssuerList);
        if(Status != PCT_ERR_OK)                                             
        {
            break;
        }

        pbIssuerList = LocalAlloc(LPTR, cbIssuerList);
        if(pbIssuerList == NULL)
        {
            cbIssuerList = 0;
            break;
        }

        Status = ExtractIssuerNamesFromStore(pCredGroup->hApplicationRoots,
                                             pbIssuerList, 
                                             &cbIssuerList);
        if(Status != PCT_ERR_OK)                                             
        {
            LocalFree(pbIssuerList);
            pbIssuerList = NULL;
            cbIssuerList = 0;
        }

        break;
    }


    //
    // Call each of the mappers in turn, building a large
    // list of all trusted issuers.
    //

    for(i = 0; i < pCredGroup->cMappers; i++)
    {
        Status = SslGetMapperIssuerList(pCredGroup->pahMappers[i],
                                        &pbIssuer,
                                        &cbIssuer);
        if(!NT_SUCCESS(Status))
        {
            continue;
        }

        if(pbIssuerList == NULL)
        {
            pbIssuerList = LocalAlloc(LPTR, cbIssuer);
            if(pbIssuerList == NULL)
            {
                SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                break;
            }
        }
        else
        {
            pbNew = LocalReAlloc(pbIssuerList, 
                                 cbIssuerList + cbIssuer,
                                 LMEM_MOVEABLE);
            if(pbNew == NULL)
            {
                SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                break;
            }
            pbIssuerList = pbNew;
        }

        CopyMemory(pbIssuerList + cbIssuerList,
                   pbIssuer,
                   cbIssuer);

        cbIssuerList += cbIssuer;

        SPExternalFree(pbIssuer);
    }


    //
    // Remove duplicates from list.
    //

    if(pbIssuerList)
    {
        Status = RemoveDuplicateIssuers(pbIssuerList, &cbIssuerList);
        if(!NT_SUCCESS(Status))
        {
            LocalFree(pbIssuerList);
            goto cleanup;
        }
    }


    //
    // Check for issuer list overflow
    //

    if((pbIssuerList != NULL) && (cbIssuerList > SSL3_MAX_ISSUER_LIST))
    {
        DWORD cbList = 0;
        PBYTE pbList = pbIssuerList;
        DWORD cbIssuer;

        while(cbList < cbIssuerList)
        {
            cbIssuer = COMBINEBYTES(pbList[0], pbList[1]);

            if(cbList + 2 + cbIssuer > SSL3_MAX_ISSUER_LIST)
            {
                // This issuer puts us over the limit.
                cbIssuerList = cbList;
                break;
            }

            cbList += 2 + cbIssuer;
            pbList += 2 + cbIssuer;
        }

        // Log warning event
        LogIssuerOverflowEvent();
    }


    pCredGroup->cbTrustedIssuers = cbIssuerList;  // do not reverse these lines
    pCredGroup->pbTrustedIssuers = pbIssuerList;

    Status = PCT_ERR_OK;

cleanup:

    UnlockCredential(pCredGroup);

    return Status;
}


SP_STATUS
SPPickClientCertificate(
    PSPContext  pContext,
    DWORD       dwExchSpec)
{
    PSPCredentialGroup pCred;
    PSPCredential      pCurrentCred;
    SP_STATUS          pctRet;
    PLIST_ENTRY        pList;

    pCred = pContext->pCredGroup;
    if((pCred == NULL) || (pCred->CredCount == 0))
    {
        return SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
    }

    pContext->pActiveClientCred = NULL;

    pctRet = PCT_ERR_SPECS_MISMATCH;

    LockCredentialShared(pCred);

    pList = pCred->CredList.Flink ;

    while ( pList != &pCred->CredList )
    {
        pCurrentCred = CONTAINING_RECORD( pList, SPCredential, ListEntry.Flink );
        pList = pList->Flink ;

        if(pCurrentCred->pCert == NULL)
        {
            continue;
        }

        if(pCurrentCred->pPublicKey == NULL)
        {
            continue;
        }

        // Does this cert contain the proper key type.
        if(dwExchSpec != pCurrentCred->dwExchSpec)
        {
            continue;    // try the next cert.
        }

        // Does this cert have the proper encoding type?
        if(pCurrentCred->pCert->dwCertEncodingType != X509_ASN_ENCODING)
        {
            continue;
        }

        // WE FOUND ONE
        pContext->pActiveClientCred = pCurrentCred;

        pctRet = PCT_ERR_OK;
        break;
    }

    UnlockCredential(pCred);

    return pctRet;
}

SP_STATUS
SPPickServerCertificate(
    PSPContext  pContext,
    DWORD       dwExchSpec)
{
    PSPCredentialGroup pCred;
    PSPCredential      pCurrentCred;
    SP_STATUS          pctRet;
    PLIST_ENTRY        pList;

    //
    // Get pointer to server credential
    //

    pCred = pContext->RipeZombie->pServerCred;
    if((pCred == NULL) || (pCred->CredCount == 0))
    {
        return SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
    }

    DsysAssert((pContext->RipeZombie->dwFlags & SP_CACHE_FLAG_READONLY) == 0);

    pContext->RipeZombie->pActiveServerCred = NULL;


    //
    // Check for certificate renewal.
    //

    if(pCred->dwFlags & CRED_FLAG_CHECK_FOR_RENEWAL)
    {
        CheckForCredentialRenewal(pCred);
    }


    //
    // Enumerate server certificates, looking for a suitable one.
    //

    pctRet = PCT_ERR_SPECS_MISMATCH;

    LockCredentialShared(pCred);

    pList = pCred->CredList.Flink ;

    while ( pList != &pCred->CredList )
    {
        pCurrentCred = CONTAINING_RECORD( pList, SPCredential, ListEntry.Flink );
        pList = pList->Flink ;

        if(pCurrentCred->pCert == NULL)
        {
            continue;
        }

        if(pCurrentCred->pPublicKey == NULL)
        {
            continue;
        }

        // Does this cert contain the proper key type.
        if(dwExchSpec != pCurrentCred->dwExchSpec)
        {
            continue;    // try the next cert.
        }

        // Does this cert have the proper encoding type?
        if(pCurrentCred->pCert->dwCertEncodingType != X509_ASN_ENCODING)
        {
            continue;
        }

        // WE FOUND ONE
        pContext->RipeZombie->pActiveServerCred = pCurrentCred;
        pContext->RipeZombie->CredThumbprint    = pCred->CredThumbprint;
        pContext->RipeZombie->CertThumbprint    = pCurrentCred->CertThumbprint;

        // Set "master" provider handle to current credential's. Note that
        // SSL3 will sometimes overide this selection in favor of its
        // ephemeral key pair.
        pContext->RipeZombie->hMasterProv = pCurrentCred->hProv;

        pctRet = PCT_ERR_OK;
        break;
    }

    UnlockCredential(pCred);

    return pctRet;
}


// This routine is called by the user process. It frees a context
// structure that was originally allocated by the LSA process,
// and passed over via the SPContextDeserialize routine.
BOOL
LsaContextDelete(PSPContext pContext)
{
    if(pContext)
    {
        if(pContext->hReadKey)
        {
            CryptDestroyKey(pContext->hReadKey);
            pContext->hReadKey = 0;
        }
        if(pContext->hReadMAC)
        {
            CryptDestroyKey(pContext->hReadMAC);
            pContext->hReadMAC = 0;
        }
        if(pContext->hWriteKey)
        {
            CryptDestroyKey(pContext->hWriteKey);
            pContext->hWriteKey = 0;
        }
        if(pContext->hWriteMAC)
        {
            CryptDestroyKey(pContext->hWriteMAC);
            pContext->hWriteMAC = 0;
        }

        if(pContext->RipeZombie)
        {
            if(pContext->RipeZombie->hLocator)
            {
                NtClose((HANDLE)pContext->RipeZombie->hLocator);
                pContext->RipeZombie->hLocator = 0;
            }

            if(pContext->RipeZombie->pbServerCertificate)
            {
                SPExternalFree(pContext->RipeZombie->pbServerCertificate);
                pContext->RipeZombie->pbServerCertificate = NULL;
            }
        }
    }
    return TRUE;
}


/*
 *
 * Misc Utility functions.
 *
 */



#if DBG
typedef struct _DbgMapCrypto {
    DWORD   C;
    PSTR    psz;
} DbgMapCrypto;

DbgMapCrypto    DbgCryptoNames[] = { {CALG_RC4, "RC4 "},
};

CHAR    DbgNameSpace[100];
PSTR    DbgAlgNames[] = { "Basic RSA", "RSA with MD2", "RSA with MD5", "RC4 stream"};
#define AlgName(x) ((x < sizeof(DbgAlgNames) / sizeof(PSTR)) ? DbgAlgNames[x] : "Unknown")

PSTR
DbgGetNameOfCrypto(DWORD x)
{
    int i;
    for (i = 0; i < sizeof(DbgCryptoNames) / sizeof(DbgMapCrypto) ; i++ )
    {
        if (x  == DbgCryptoNames[i].C)
        {
            wsprintf(DbgNameSpace, "%s",
                    (DbgCryptoNames[i].psz));
            return DbgNameSpace;
        }
    }

    return("Unknown");
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\cred.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cred.c
//
//  Contents:   Schannel credential management routines.
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//              03-15-99   jbanes   Remove dead code, fix legacy SGC.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <wincrypt.h>
#include <oidenc.h>
#include <mapper.h>
#include <userenv.h>
#include <lsasecpk.h>


RTL_CRITICAL_SECTION g_SslCredLock;
LIST_ENTRY          g_SslCredList;
HANDLE              g_GPEvent;

HCERTSTORE          g_hMyCertStore;
HANDLE              g_hMyCertStoreEvent;

SP_STATUS
GetPrivateFromCert(
    PSPCredential pCred, 
    DWORD dwProtocol,
    PLSA_SCHANNEL_SUB_CRED pSubCred);


BOOL
SslInitCredentialManager(VOID)
{
    NTSTATUS Status;

    //
    // Initialize synchronization objects.
    //

    Status = RtlInitializeCriticalSection( &g_SslCredLock );
    if (!NT_SUCCESS(Status))
    {
        return FALSE;
    }

    InitializeListHead( &g_SslCredList );


    //
    // Register for group policy notifications. Servers rebuild their list
    // of trusted CAs each time this happens (every 8 hours) in case these
    // have changed.
    //

    g_GPEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if(g_GPEvent)
    {
        if(!RegisterGPNotification(g_GPEvent, TRUE))
        {
            DebugLog((DEB_ERROR, "Error 0x%x registering for machine GP notification\n", GetLastError()));
        }
    }


    //
    // Register for changes to the local machine MY store. Each time a change
    // is detected, we check to see if any of our certificates have been renewed.
    //

    g_hMyCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM,
                                   X509_ASN_ENCODING,
                                   0,
                                   CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                   L"MY");

    if(g_hMyCertStore)
    {
        g_hMyCertStoreEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if(g_hMyCertStoreEvent)
        {
            if(!CertControlStore(g_hMyCertStore, 
                                 0,  
                                 CERT_STORE_CTRL_NOTIFY_CHANGE, 
                                 &g_hMyCertStoreEvent))
            {
                DebugLog((DEB_ERROR, "Error 0x%x registering for machine MY store change notification\n", GetLastError()));
            }
        }
    }

    return( TRUE );
}


BOOL
SslFreeCredentialManager(VOID)
{
    if(g_GPEvent)
    {
        if(!UnregisterGPNotification(g_GPEvent))
        {
            DebugLog((DEB_ERROR, "Error 0x%x unregistering for machine GP notification\n", GetLastError()));
        }

        CloseHandle(g_GPEvent);
        g_GPEvent = NULL;
    }

    if(g_hMyCertStore)
    {
        if(g_hMyCertStoreEvent)
        {
            CertControlStore(g_hMyCertStore, 
                             0,  
                             CERT_STORE_CTRL_CANCEL_NOTIFY, 
                             &g_hMyCertStoreEvent);

            CloseHandle(g_hMyCertStoreEvent);
        }

        CertCloseStore(g_hMyCertStore, 0);
    }


    RtlDeleteCriticalSection( &g_SslCredLock );

    return TRUE;
}


BOOL
SslCheckForGPEvent(void)
{
    PLIST_ENTRY pList;
    PSPCredentialGroup pCredGroup;
    DWORD Status;

    if(g_GPEvent)
    {
        Status = WaitForSingleObjectEx(g_GPEvent, 0, FALSE);
        if(Status == WAIT_OBJECT_0)
        {
            DebugLog((DEB_WARN, "GP event detected, so download new trusted issuer list\n"));

            RtlEnterCriticalSection( &g_SslCredLock );

            pList = g_SslCredList.Flink ;

            while ( pList != &g_SslCredList )
            {
                pCredGroup = CONTAINING_RECORD( pList, SPCredentialGroup, GlobalCredList.Flink );
                pList = pList->Flink ;

                pCredGroup->dwFlags |= CRED_FLAG_UPDATE_ISSUER_LIST;
            }

            RtlLeaveCriticalSection( &g_SslCredLock );

            return TRUE;
        }
    }

    return FALSE;
}


SP_STATUS
IsCredentialInGroup(
    PSPCredentialGroup  pCredGroup, 
    PCCERT_CONTEXT      pCertContext,
    PBOOL               pfInGroup)
{
    PSPCredential   pCred;
    BYTE            rgbThumbprint[20];
    DWORD           cbThumbprint;
    BYTE            rgbHash[20];
    DWORD           cbHash;
    PLIST_ENTRY     pList;
    SP_STATUS       pctRet = PCT_ERR_OK;

    *pfInGroup = FALSE;

    if(pCredGroup->CredCount == 0)
    {
        return PCT_ERR_OK;
    }

    // Get thumbprint of certificate.
    cbThumbprint = sizeof(rgbThumbprint);
    if(!CertGetCertificateContextProperty(pCertContext,
                                          CERT_MD5_HASH_PROP_ID,
                                          rgbThumbprint,
                                          &cbThumbprint))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }

    LockCredentialShared(pCredGroup);

    pList = pCredGroup->CredList.Flink ;

    while ( pList != &pCredGroup->CredList )
    {
        pCred = CONTAINING_RECORD( pList, SPCredential, ListEntry.Flink );
        pList = pList->Flink ;

        // Get thumbprint of certificate.
        cbHash = sizeof(rgbHash);
        if(!CertGetCertificateContextProperty(pCred->pCert,
                                              CERT_MD5_HASH_PROP_ID,
                                              rgbHash,
                                              &cbHash))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_UNKNOWN_CREDENTIAL;
            goto cleanup;
        }

        if(memcmp(rgbThumbprint, rgbHash, cbThumbprint) == 0)
        {
            *pfInGroup = TRUE;
            break;
        }
    }

cleanup:

    UnlockCredential(pCredGroup);

    return pctRet;
}

BOOL
IsValidThumbprint(
    PCRED_THUMBPRINT Thumbprint)
{
    if(Thumbprint->LowPart == 0 && Thumbprint->HighPart == 0)
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
IsSameThumbprint(
    PCRED_THUMBPRINT Thumbprint1,
    PCRED_THUMBPRINT Thumbprint2)
{
    if(Thumbprint1->LowPart  == Thumbprint2->LowPart && 
       Thumbprint1->HighPart == Thumbprint2->HighPart)
    {
        return TRUE;
    }

    return FALSE;
}

void
GenerateCertThumbprint(
    PCCERT_CONTEXT pCertContext,
    PCRED_THUMBPRINT Thumbprint)
{
    MD5_CTX Md5Hash;

    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash, 
              pCertContext->pbCertEncoded, 
              pCertContext->cbCertEncoded);
    MD5Final(&Md5Hash);
    CopyMemory((PBYTE)Thumbprint, 
               Md5Hash.digest, 
               sizeof(CRED_THUMBPRINT));
}

NTSTATUS
GenerateRandomThumbprint(
    PCRED_THUMBPRINT Thumbprint)
{
    return GenerateRandomBits((PBYTE)Thumbprint, sizeof(CRED_THUMBPRINT));
}

BOOL
DoesCredThumbprintMatch(
    PSPCredentialGroup pCredGroup,
    PCRED_THUMBPRINT pThumbprint)
{
    PSPCredential pCurrentCred;
    BOOL fFound = FALSE;
    PLIST_ENTRY pList;

    if(pCredGroup->CredCount == 0)
    {
        return FALSE;
    }

    LockCredentialShared(pCredGroup);

    pList = pCredGroup->CredList.Flink ;

    while ( pList != &pCredGroup->CredList )
    {
        pCurrentCred = CONTAINING_RECORD( pList, SPCredential, ListEntry.Flink );
        pList = pList->Flink ;

        if(IsSameThumbprint(pThumbprint, &pCurrentCred->CertThumbprint))
        { 
            fFound = TRUE;
            break;
        }
    }

    UnlockCredential(pCredGroup);

    return fFound;
}


void
ComputeCredExpiry(
    PSPCredentialGroup pCredGroup,
    PTimeStamp ptsExpiry)
{
    PSPCredential pCurrentCred;
    PLIST_ENTRY pList;

    if(ptsExpiry == NULL)
        return;

    // Default to maximum timeout.
    ptsExpiry->QuadPart = MAXTIMEQUADPART;

    if(pCredGroup->CredCount == 0)
        return;

    LockCredentialShared(pCredGroup);

    pList = pCredGroup->CredList.Flink ;

    while ( pList != &pCredGroup->CredList )
    {
        pCurrentCred = CONTAINING_RECORD( pList, SPCredential, ListEntry.Flink );
        pList = pList->Flink ;

        if(pCurrentCred->pCert)
        {
            ptsExpiry->QuadPart = *((LONGLONG *)&pCurrentCred->pCert->pCertInfo->NotAfter);
            break;
        }
    }

    UnlockCredential(pCredGroup);
}


SP_STATUS
SPCreateCred(
    DWORD           dwProtocol,
    PLSA_SCHANNEL_SUB_CRED pSubCred,
    PSPCredential   pCurrentCred,
    BOOL *          pfEventLogged)
{
    SP_STATUS pctRet;
    BOOL fRenewed;
    PCCERT_CONTEXT pNewCertificate = NULL;

    //
    // Check to see if the certificate has been renewed.
    //

    fRenewed = CheckForCertificateRenewal(dwProtocol,
                                          pSubCred->pCert,
                                          &pNewCertificate);

    if(fRenewed)
    {
        pCurrentCred->pCert = pNewCertificate;
        pSubCred->hRemoteProv = 0;
    }
    else
    {
        pCurrentCred->pCert = CertDuplicateCertificateContext(pSubCred->pCert);
        if(pCurrentCred->pCert == NULL)
        {
            pctRet = SP_LOG_RESULT(SEC_E_CERT_UNKNOWN);
            goto error;
        }
    }

    //
    // Obtain the public and private keys for the credential.
    //

    pctRet = SPPublicKeyFromCert(pCurrentCred->pCert,
                                 &pCurrentCred->pPublicKey,
                                 &pCurrentCred->dwExchSpec);
    if(pctRet != PCT_ERR_OK)
    {
        goto error;
    }

    pctRet = GetPrivateFromCert(pCurrentCred, dwProtocol, pSubCred);
    if(pctRet != PCT_ERR_OK)
    {
        *pfEventLogged = TRUE;
        goto error;
    }

    pCurrentCred->dwCertFlags = CF_EXPORT;
    pCurrentCred->dwCertFlags |= CF_DOMESTIC;

    // Generate the credential thumbprint. This is computed by
    // taking the hash of the certificate.
    GenerateCertThumbprint(pCurrentCred->pCert, 
                           &pCurrentCred->CertThumbprint);

    DebugLog((DEB_TRACE, "Credential thumbprint: %x %x\n", 
        pCurrentCred->CertThumbprint.LowPart,
        pCurrentCred->CertThumbprint.HighPart));


    // Read list of supported algorithms.
    if((dwProtocol & SP_PROT_SERVERS) && pCurrentCred->hProv)
    {
        GetSupportedCapiAlgs(pCurrentCred->hProv,
                             &pCurrentCred->pCapiAlgs,
                             &pCurrentCred->cCapiAlgs);
    }


    // Build SSL3 serialized certificate chain. This is an optimization
    // so that we won't have to build it for each connection.
    pctRet = SPSerializeCertificate(
                            SP_PROT_SSL3,
                            TRUE,
                            &pCurrentCred->pbSsl3SerializedChain,
                            &pCurrentCred->cbSsl3SerializedChain,
                            pCurrentCred->pCert,
                            CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL);
    if(pctRet != PCT_ERR_OK)
    {
        goto error;
    }

error:

    return pctRet;
}


SP_STATUS
SPCreateCredential(
   PSPCredentialGroup *ppCred,
   DWORD grbitProtocol,
   PLSA_SCHANNEL_CRED pSchannelCred)
{
    PSPCredentialGroup pCred = NULL;
    PSPCredential pCurrentCred = NULL;
    SECPKG_CALL_INFO CallInfo;

    SP_STATUS   pctRet = PCT_ERR_OK;
    DWORD       i;
    BOOL        fImpersonating = FALSE;
    BOOL        fEventLogged = FALSE;

    SP_BEGIN("SPCreateCredential");

    DebugLog((DEB_TRACE, "  dwVersion:              %d\n",   pSchannelCred->dwVersion));
    DebugLog((DEB_TRACE, "  cCreds:                 %d\n",   pSchannelCred->cSubCreds));
    DebugLog((DEB_TRACE, "  paCred:                 0x%p\n", pSchannelCred->paSubCred));
    DebugLog((DEB_TRACE, "  hRootStore:             0x%p\n", pSchannelCred->hRootStore));
    DebugLog((DEB_TRACE, "  cMappers:               %d\n",   pSchannelCred->cMappers));
    DebugLog((DEB_TRACE, "  aphMappers:             0x%p\n", pSchannelCred->aphMappers));
    DebugLog((DEB_TRACE, "  cSupportedAlgs:         %d\n",   pSchannelCred->cSupportedAlgs));
    DebugLog((DEB_TRACE, "  palgSupportedAlgs:      0x%p\n", pSchannelCred->palgSupportedAlgs));
    DebugLog((DEB_TRACE, "  grbitEnabledProtocols:  0x%x\n", pSchannelCred->grbitEnabledProtocols));
    DebugLog((DEB_TRACE, "  dwMinimumCipherStrength:%d\n",   pSchannelCred->dwMinimumCipherStrength));
    DebugLog((DEB_TRACE, "  dwMaximumCipherStrength:%d\n",   pSchannelCred->dwMaximumCipherStrength));
    DebugLog((DEB_TRACE, "  dwSessionLifespan:      %d\n",   pSchannelCred->dwSessionLifespan));
    DebugLog((DEB_TRACE, "  dwFlags:                0x%x\n", pSchannelCred->dwFlags));
    DebugLog((DEB_TRACE, "  reserved:               0x%x\n", pSchannelCred->reserved));

    LogCreateCredEvent(grbitProtocol, pSchannelCred);


    //
    // Allocate the internal credential structure and perform
    // basic initialization.
    //

    pCred = SPExternalAlloc(sizeof(SPCredentialGroup));
    if(pCred == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
    }

    DebugLog((DEB_TRACE, "New cred:%p, Protocol:%x\n", pCred, grbitProtocol));


    pCred->Magic = PCT_CRED_MAGIC;
    pCred->grbitProtocol = grbitProtocol;

    pCred->RefCount = 0;
    pCred->cMappers = 0;
    pCred->pahMappers = NULL;
    pCred->dwFlags = 0;

    // Initialize this early so that if a failure occurs, the cleanup
    // code won't try to release a non-initialized resource.
    __try {
        RtlInitializeResource(&pCred->csCredListLock);
    } __except(EXCEPTION_EXECUTE_HANDLER)
    {
        pctRet = STATUS_INSUFFICIENT_RESOURCES;
        SPExternalFree(pCred);
        pCred = NULL;
        goto error;
    }

    pctRet = GenerateRandomThumbprint(&pCred->CredThumbprint);
    if(!NT_SUCCESS(pctRet))
    {
        goto error;
    }

    if((grbitProtocol & SP_PROT_SERVERS) && (pSchannelCred->cSubCreds == 0))
    {
        pctRet = SP_LOG_RESULT(SEC_E_NO_CREDENTIALS);
        goto error;
    }

    if(LsaTable->GetCallInfo(&CallInfo))
    {
        pCred->ProcessId = CallInfo.ProcessId;
    }


    //
    // Walk through and initialize all certs and keys.
    //

    InitializeListHead( &pCred->CredList );
    pCred->CredCount = 0;

    if(pSchannelCred->cSubCreds)
    {
        for(i = 0; i < pSchannelCred->cSubCreds; i++)
        {
            pCurrentCred = SPExternalAlloc(sizeof(SPCredential));
            if(pCurrentCred == NULL)
            {
                pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                goto error;
            }

            InsertTailList( &pCred->CredList, &pCurrentCred->ListEntry );
            pCred->CredCount++;

            pctRet = SPCreateCred(grbitProtocol,
                                  pSchannelCred->paSubCred + i,
                                  pCurrentCred,
                                  &fEventLogged);
            if(pctRet != PCT_ERR_OK)
            {
                goto error;
            }
        }
    }


    //
    // Determine which protocols are to be supported.
    //

    if(pSchannelCred->grbitEnabledProtocols == 0)
    {
        pCred->grbitEnabledProtocols = g_ProtEnabled;

        if(g_PctClientDisabledByDefault)
        {
            pCred->grbitEnabledProtocols &= ~SP_PROT_PCT1_CLIENT; 
        }
        if(g_Ssl2ClientDisabledByDefault)
        {
            pCred->grbitEnabledProtocols &= ~SP_PROT_SSL2_CLIENT; 
        }
    }
    else
    {
        pCred->grbitEnabledProtocols = pSchannelCred->grbitEnabledProtocols & g_ProtEnabled;
    }

    // Force credential to client-only or server only.
    if(grbitProtocol & SP_PROT_SERVERS)
    {
        pCred->grbitEnabledProtocols &= SP_PROT_SERVERS;
    }
    else
    {
        pCred->grbitEnabledProtocols &= SP_PROT_CLIENTS;
    }


    //
    // Propagate flags from SCHANNEL_CRED structure.
    //

    if(pSchannelCred->dwFlags & SCH_CRED_NO_SYSTEM_MAPPER)
    {
        pCred->dwFlags |= CRED_FLAG_NO_SYSTEM_MAPPER;
    }
    if(pSchannelCred->dwFlags & SCH_CRED_NO_SERVERNAME_CHECK)
    {
        pCred->dwFlags |= CRED_FLAG_NO_SERVERNAME_CHECK;
    }
    if(pSchannelCred->dwFlags & SCH_CRED_MANUAL_CRED_VALIDATION)
    {
        pCred->dwFlags |= CRED_FLAG_MANUAL_CRED_VALIDATION;
    }
    if(pSchannelCred->dwFlags & SCH_CRED_NO_DEFAULT_CREDS)
    {
        pCred->dwFlags |= CRED_FLAG_NO_DEFAULT_CREDS;
    }
    if(pSchannelCred->dwFlags & SCH_CRED_AUTO_CRED_VALIDATION)
    {
        // Automatically validate server credentials.
        pCred->dwFlags &= ~CRED_FLAG_MANUAL_CRED_VALIDATION;
    }
    if(pSchannelCred->dwFlags & SCH_CRED_USE_DEFAULT_CREDS)
    {
        // Use default client credentials.
        pCred->dwFlags &= ~CRED_FLAG_NO_DEFAULT_CREDS;
    }
    if(pSchannelCred->dwFlags & SCH_CRED_DISABLE_RECONNECTS)
    {
        // Disable reconnects.
        pCred->dwFlags |= CRED_FLAG_DISABLE_RECONNECTS;
    }

    // set revocation flags
    if(pSchannelCred->dwFlags & SCH_CRED_REVOCATION_CHECK_END_CERT)
        pCred->dwFlags |= CRED_FLAG_REVCHECK_END_CERT;
    if(pSchannelCred->dwFlags & SCH_CRED_REVOCATION_CHECK_CHAIN)
        pCred->dwFlags |= CRED_FLAG_REVCHECK_CHAIN;
    if(pSchannelCred->dwFlags & SCH_CRED_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT)
        pCred->dwFlags |= CRED_FLAG_REVCHECK_CHAIN_EXCLUDE_ROOT;
    if(pSchannelCred->dwFlags & SCH_CRED_IGNORE_NO_REVOCATION_CHECK)
        pCred->dwFlags |= CRED_FLAG_IGNORE_NO_REVOCATION_CHECK;
    if(pSchannelCred->dwFlags & SCH_CRED_IGNORE_REVOCATION_OFFLINE)
        pCred->dwFlags |= CRED_FLAG_IGNORE_REVOCATION_OFFLINE;


    // set up the min and max strength
    GetBaseCipherSizes(&pCred->dwMinStrength, &pCred->dwMaxStrength);

    if(pSchannelCred->dwMinimumCipherStrength == 0)
    {
        pCred->dwMinStrength = max(40, pCred->dwMinStrength);
    }
    else if(pSchannelCred->dwMinimumCipherStrength == (DWORD)(-1))
    {
        // Turn on NULL cipher.
        pCred->dwMinStrength = 0;
    }
    else
    {
        pCred->dwMinStrength = pSchannelCred->dwMinimumCipherStrength;
    }

    if(pSchannelCred->dwMaximumCipherStrength == (DWORD)(-1))
    {
        // NULL cipher only.
        pCred->dwMaxStrength = 0;
    }
    else if(pSchannelCred->dwMaximumCipherStrength != 0)
    {
        pCred->dwMaxStrength = pSchannelCred->dwMaximumCipherStrength;
    }

    // set up the allowed ciphers
    BuildAlgList(pCred, pSchannelCred->palgSupportedAlgs, pSchannelCred->cSupportedAlgs);


    //
    // Set up the system certificate mapper.
    //

    pCred->cMappers = 1;
    pCred->pahMappers = SPExternalAlloc(sizeof(HMAPPER *));
    if(pCred->pahMappers == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    pCred->pahMappers[0] = SslGetMapper(TRUE);

    if(pCred->dwFlags & CRED_FLAG_REVCHECK_END_CERT) 
        pCred->pahMappers[0]->m_dwFlags |= SCH_FLAG_REVCHECK_END_CERT;
    if(pCred->dwFlags & CRED_FLAG_REVCHECK_CHAIN)
        pCred->pahMappers[0]->m_dwFlags |= SCH_FLAG_REVCHECK_CHAIN;
    if(pCred->dwFlags & CRED_FLAG_REVCHECK_CHAIN_EXCLUDE_ROOT)
        pCred->pahMappers[0]->m_dwFlags |= SCH_FLAG_REVCHECK_CHAIN_EXCLUDE_ROOT;
    if(pCred->dwFlags & CRED_FLAG_IGNORE_NO_REVOCATION_CHECK)
        pCred->pahMappers[0]->m_dwFlags |= SCH_FLAG_IGNORE_NO_REVOCATION_CHECK;
    if(pCred->dwFlags & CRED_FLAG_IGNORE_REVOCATION_OFFLINE)
        pCred->pahMappers[0]->m_dwFlags |= SCH_FLAG_IGNORE_REVOCATION_OFFLINE;

    SslReferenceMapper(pCred->pahMappers[0]);


    // set up timeouts.
    if(pSchannelCred->dwSessionLifespan == 0)
    {
        if(grbitProtocol & SP_PROT_CLIENTS) 
        {
            pCred->dwSessionLifespan = SchannelCache.dwClientLifespan;
        }
        else
        {
            pCred->dwSessionLifespan = SchannelCache.dwServerLifespan;
        }
    }
    else if(pSchannelCred->dwSessionLifespan == (DWORD)(-1))
    {
        pCred->dwSessionLifespan = 0;
    }
    else
    {
        pCred->dwSessionLifespan = pSchannelCred->dwSessionLifespan;
    }


    //
    // Add credential to global list of credentials.
    //

    RtlEnterCriticalSection( &g_SslCredLock );
    InsertTailList( &g_SslCredList, &pCred->GlobalCredList );
    RtlLeaveCriticalSection( &g_SslCredLock );


    //
    // Get list of trusted issuers.
    //

    if(grbitProtocol & SP_PROT_SERVERS)
    {
        if(pSchannelCred->hRootStore)
        {
            pCred->hApplicationRoots = CertDuplicateStore(pSchannelCred->hRootStore);
            if(!pCred->hApplicationRoots)
            {
                DebugLog((DEB_ERROR, "Error 0x%x duplicating app root store\n", GetLastError()));
            }
        }

        fImpersonating = SslImpersonateClient();

        pCred->hUserRoots = CertOpenSystemStore(0, "ROOT");
        if(!pCred->hUserRoots)
        {
            DebugLog((DEB_ERROR, "Error 0x%x opening user root store\n", GetLastError()));
        }
        else
        {
            if(!CertControlStore(pCred->hUserRoots,
                0,
                CERT_STORE_CTRL_NOTIFY_CHANGE,
                &g_GPEvent))
            {
                DebugLog((DEB_ERROR, "Error 0x%x registering user root change notification\n", GetLastError()));
            }
        }

        if(fImpersonating)
        {
            RevertToSelf();
            fImpersonating = FALSE;
        }
    }


    SPReferenceCredential(pCred);

    *ppCred = pCred;

    SP_RETURN(PCT_ERR_OK);


error:

    if(fEventLogged == FALSE)
    {
        LogCreateCredFailedEvent(grbitProtocol);
    }

    // Error case, free the credential
    if(pCred)
    {
        SPDeleteCredential(pCred, TRUE);
    }

    SP_RETURN(pctRet);
}


BOOL
SPDeleteCredential(
    PSPCredentialGroup pCred,
    BOOL fFreeRemoteHandle)
{
    DWORD i;

    SP_BEGIN("SPDeleteCredential");

    if(pCred == NULL)
    {
        SP_RETURN(TRUE);
    }

    if(pCred->Magic != PCT_CRED_MAGIC)
    {
        DebugLog((SP_LOG_ERROR, "Attempting to delete invalid credential!\n"));
        SP_RETURN (FALSE);
    }

    LockCredentialExclusive(pCred);

    if(pCred->CredCount)
    {
        PLIST_ENTRY pList;
        PSPCredential pCurrentCred;

        pList = pCred->CredList.Flink ;

        while ( pList != &pCred->CredList )
        {
            pCurrentCred = CONTAINING_RECORD( pList, SPCredential, ListEntry.Flink );
            pList = pList->Flink ;

            SPDeleteCred(pCurrentCred, fFreeRemoteHandle);
            SPExternalFree(pCurrentCred);
        }

        pCred->CredCount = 0;
        pCred->CredList.Flink = NULL;
        pCred->CredList.Blink = NULL;
    }

    if(pCred->cMappers && pCred->pahMappers)
    {
        for(i=0; i < (DWORD)pCred->cMappers; i++)
        {
            SslDereferenceMapper(pCred->pahMappers[i]);
        }
        SPExternalFree(pCred->pahMappers);
    }


    if(pCred->palgSupportedAlgs)
    {
        SPExternalFree(pCred->palgSupportedAlgs);
    }
    pCred->Magic = PCT_INVALID_MAGIC;

    if(pCred->GlobalCredList.Flink)
    {
        RtlEnterCriticalSection( &g_SslCredLock );
        RemoveEntryList( &pCred->GlobalCredList );
        RtlLeaveCriticalSection( &g_SslCredLock );
    }

    if(pCred->pbTrustedIssuers)
    {
        // LocalFree is used for the issuer list because realloc 
        // is used when building the list and the LSA doesn't 
        // provide a realloc helper function.
        LocalFree(pCred->pbTrustedIssuers);
    }

    if(pCred->hApplicationRoots)
    {
        CertCloseStore(pCred->hApplicationRoots, 0);
    }

    if(pCred->hUserRoots)
    {
        BOOL fImpersonating = SslImpersonateClient();
        CertCloseStore(pCred->hUserRoots, 0);
        if(fImpersonating) RevertToSelf();
    }

    UnlockCredential(pCred);

    RtlDeleteResource(&pCred->csCredListLock);

    ZeroMemory(pCred, sizeof(SPCredentialGroup));
    SPExternalFree(pCred);

    SP_RETURN(TRUE);
}

void
SPDeleteCred(
    PSPCredential pCred,
    BOOL fFreeRemoteHandle)
{
    BOOL fImpersonating = FALSE;

    if(pCred == NULL)
    {
        return;
    }

    if(pCred->pPublicKey)
    {
        SPExternalFree(pCred->pPublicKey);
        pCred->pPublicKey = NULL;
    }
    if(pCred->pCert)
    {
        CertFreeCertificateContext(pCred->pCert);
        pCred->pCert = NULL;
    }

    if(pCred->hTek)
    {
        if(!CryptDestroyKey(pCred->hTek))
        {
            SP_LOG_RESULT(GetLastError());
        }
        pCred->hTek = 0;
    }

    if(pCred->hProv)
    {
        fImpersonating = SslImpersonateClient();

        if(!CryptReleaseContext(pCred->hProv, 0))
        {
            SP_LOG_RESULT(GetLastError());
        }
        pCred->hProv = 0;

        if(fImpersonating)
        {
            RevertToSelf();
            fImpersonating = FALSE;
        }
    }
    if(pCred->pCapiAlgs)
    {
        SPExternalFree(pCred->pCapiAlgs);
        pCred->pCapiAlgs = NULL;
    }

    if(fFreeRemoteHandle)
    {
        if(pCred->hRemoteProv && !pCred->fAppRemoteProv)
        {
            if(!RemoteCryptReleaseContext(pCred->hRemoteProv, 0))
            {
                SP_LOG_RESULT(GetLastError());
            }
            pCred->hRemoteProv = 0;
        }
    }

    if(pCred->hEphem512Prov)
    {
        if(!CryptReleaseContext(pCred->hEphem512Prov, 0))
        {
            SP_LOG_RESULT(GetLastError());
        }
        pCred->hEphem512Prov = 0;
    }

    if(pCred->pbSsl3SerializedChain)
    {
        SPExternalFree(pCred->pbSsl3SerializedChain);
    }
}

// Reference a credential.
// Note: This should only be called by someone who already
// has a reference to the credential, or by the CreateCredential
// call.

BOOL
SPReferenceCredential(
    PSPCredentialGroup  pCred)
{
    BOOL fRet = FALSE;

    fRet =  (InterlockedIncrement(&pCred->RefCount) > 0);

    DebugLog((SP_LOG_TRACE, "Reference Cred %lx: %d\n", pCred, pCred->RefCount));

    return fRet;
}


BOOL
SPDereferenceCredential(
    PSPCredentialGroup pCred,
    BOOL fFreeRemoteHandle)
{
    BOOL fRet = FALSE;

    if(pCred == NULL)
    {
        return FALSE;
    }
    if(pCred->Magic != PCT_CRED_MAGIC)
    {
        DebugLog((SP_LOG_ERROR, "Attempting to dereference invalid credential!\n"));
        return FALSE;
    }

    fRet = TRUE;

    DebugLog((SP_LOG_TRACE, "Dereference Cred %lx: %d\n", pCred, pCred->RefCount-1));

    if(0 == InterlockedDecrement(&pCred->RefCount))
    {
        fRet = SPDeleteCredential(pCred, fFreeRemoteHandle);
    } 

    return fRet;
}


SECURITY_STATUS
UpdateCredentialFormat(
    PSCH_CRED           pSchCred,       // in
    PLSA_SCHANNEL_CRED  pSchannelCred)  // out
{
    DWORD       dwType;
    SP_STATUS   pctRet;
    DWORD       i;
    PBYTE       pbChain;
    DWORD       cbChain;
    PSCH_CRED_PUBLIC_CERTCHAIN pCertChain;

    SP_BEGIN("UpdateCredentialFormat");

    //
    // Initialize the output structure to null credential.
    //

    if(pSchannelCred == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INTERNAL_ERROR));
    }

    memset(pSchannelCred, 0, sizeof(LSA_SCHANNEL_CRED));
    pSchannelCred->dwVersion = SCHANNEL_CRED_VERSION;


    //
    // If input buffer is empty then we're done.
    //

    if(pSchCred == NULL)
    {
        SP_RETURN(SEC_E_OK);
    }


    //
    // Convert the certificates and private keys.
    //

    if(pSchCred->cCreds == 0)
    {
        SP_RETURN(SEC_E_OK);
    }

    pSchannelCred->cSubCreds = pSchCred->cCreds;

    pSchannelCred->paSubCred = SPExternalAlloc(sizeof(LSA_SCHANNEL_SUB_CRED) * pSchannelCred->cSubCreds);
    if(pSchannelCred->paSubCred == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    // Loop through each of the creds, and convert them into something we know
    for(i = 0; i < pSchannelCred->cSubCreds; i++)
    {
        PLSA_SCHANNEL_SUB_CRED pSubCred = pSchannelCred->paSubCred + i;

        //
        // Decode the certificate.
        //

        dwType = *(PDWORD)pSchCred->paPublic[i];

        if(dwType != SCH_CRED_X509_CERTCHAIN)
        {
            pctRet = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
            goto error;
        }

        pCertChain = (PSCH_CRED_PUBLIC_CERTCHAIN)pSchCred->paPublic[i];

        pbChain = pCertChain->pCertChain;
        cbChain = pCertChain->cbCertChain;

        // Decode the credential
        pctRet = SPLoadCertificate(0,
                                   X509_ASN_ENCODING,
                                   pbChain,
                                   cbChain,
                                   &pSubCred->pCert);
        if(pctRet != PCT_ERR_OK)
        {
            pctRet = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
            goto error;
        }


        //
        // Now deal with the private key.
        //

        dwType = *(DWORD *)pSchCred->paSecret[i];

        if(dwType == SCHANNEL_SECRET_PRIVKEY)
        {
            PSCH_CRED_SECRET_PRIVKEY pPrivKey;
            DWORD Size;

            pPrivKey = (PSCH_CRED_SECRET_PRIVKEY)pSchCred->paSecret[i];

            pSubCred->pPrivateKey  = SPExternalAlloc(pPrivKey->cbPrivateKey);
            if(pSubCred->pPrivateKey == NULL)
            {
                pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                goto error;
            }
            memcpy(pSubCred->pPrivateKey, pPrivKey->pPrivateKey, pPrivKey->cbPrivateKey);
            pSubCred->cbPrivateKey = pPrivKey->cbPrivateKey;

            Size = lstrlen(pPrivKey->pszPassword) + sizeof(CHAR);
            pSubCred->pszPassword = SPExternalAlloc(Size);
            if(pSubCred->pszPassword == NULL)
            {
                pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                goto error;
            }
            memcpy(pSubCred->pszPassword, pPrivKey->pszPassword, Size);
        }

        else if(dwType == SCHANNEL_SECRET_TYPE_CAPI)
        {
            PSCH_CRED_SECRET_CAPI pCapiKey;

            pCapiKey = (PSCH_CRED_SECRET_CAPI)pSchCred->paSecret[i];

            pSubCred->hRemoteProv = pCapiKey->hProv;
        }

        else
        {
            pctRet = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
            goto error;
        }
    }

    SP_RETURN(SEC_E_OK);

error:

    if(pSchannelCred->paSubCred)
    {
        SPExternalFree((PVOID)pSchannelCred->paSubCred);
        pSchannelCred->paSubCred = NULL;
    }

    SP_RETURN(pctRet);
}


SP_STATUS
GetIisPrivateFromCert(
    PSPCredential pCred,
    PLSA_SCHANNEL_SUB_CRED pSubCred)
{
    PBYTE pbPrivate = NULL;
    DWORD cbPrivate;
    PBYTE pbPassword = NULL;
    DWORD cbPassword;

    PPRIVATE_KEY_FILE_ENCODE pPrivateFile = NULL;
    DWORD                    cbPrivateFile;

    BLOBHEADER *pPrivateBlob = NULL;
    DWORD       cbPrivateBlob;
    HCRYPTKEY   hPrivateKey;
    HCRYPTPROV  hProv = 0;
    SP_STATUS   pctRet;

    MD5_CTX md5Ctx;
    struct RC4_KEYSTRUCT rc4Key;

    if(pSubCred->cbPrivateKey == 0 || 
       pSubCred->pPrivateKey == NULL ||
       pSubCred->pszPassword == NULL)
    {
        return SP_LOG_RESULT(SEC_E_NO_CREDENTIALS);
    }
       
    pbPrivate = pSubCred->pPrivateKey;
    cbPrivate = pSubCred->cbPrivateKey;

    pbPassword = (PBYTE)pSubCred->pszPassword;
    cbPassword = lstrlen(pSubCred->pszPassword);


    // We have to do a little fixup here.  Old versions of
    // schannel wrote the wrong header data into the ASN
    // for private key files, so we must fix the size data.
    pbPrivate[2] = MSBOF(cbPrivate - 4);
    pbPrivate[3] = LSBOF(cbPrivate - 4);


    // ASN.1 decode the private key.
    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          szPrivateKeyFileEncode,
                          pbPrivate,
                          cbPrivate,
                          0,
                          NULL,
                          &cbPrivateFile))
    {
        DebugLog((SP_LOG_ERROR, "Error 0x%x decoding the private key\n",
            GetLastError()));
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto error;
    }

    pPrivateFile = SPExternalAlloc(cbPrivateFile);
    if(pPrivateFile == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          szPrivateKeyFileEncode,
                          pbPrivate,
                          cbPrivate,
                          0,
                          pPrivateFile,
                          &cbPrivateFile))
    {
        DebugLog((SP_LOG_ERROR, "Error 0x%x decoding the private key\n",
            GetLastError()));
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto error;
    }


    // Decrypt the decoded private key using the password.
    MD5Init(&md5Ctx);
    MD5Update(&md5Ctx, pbPassword, cbPassword);
    MD5Final(&md5Ctx);

    rc4_key(&rc4Key, 16, md5Ctx.digest);

    rc4(&rc4Key,
        pPrivateFile->EncryptedBlob.cbData,
        pPrivateFile->EncryptedBlob.pbData);

    // Build a PRIVATEKEYBLOB from the decrypted private key.
    if(!CryptDecodeObject(X509_ASN_ENCODING,
                  szPrivateKeyInfoEncode,
                  pPrivateFile->EncryptedBlob.pbData,
                  pPrivateFile->EncryptedBlob.cbData,
                  0,
                  NULL,
                  &cbPrivateBlob))
    {
        // Maybe this was a SGC style key.
        // Re-encrypt it, and build the SGC decrypting
        // key, and re-decrypt it.
        BYTE md5Digest[MD5DIGESTLEN];

        rc4_key(&rc4Key, 16, md5Ctx.digest);
        rc4(&rc4Key,
            pPrivateFile->EncryptedBlob.cbData,
            pPrivateFile->EncryptedBlob.pbData);
        CopyMemory(md5Digest, md5Ctx.digest, MD5DIGESTLEN);

        MD5Init(&md5Ctx);
        MD5Update(&md5Ctx, md5Digest, MD5DIGESTLEN);
        MD5Update(&md5Ctx, (PBYTE)SGC_KEY_SALT, lstrlen(SGC_KEY_SALT));
        MD5Final(&md5Ctx);
        rc4_key(&rc4Key, 16, md5Ctx.digest);
        rc4(&rc4Key,
            pPrivateFile->EncryptedBlob.cbData,
            pPrivateFile->EncryptedBlob.pbData);

        // Try again...
        if(!CryptDecodeObject(X509_ASN_ENCODING,
                      szPrivateKeyInfoEncode,
                      pPrivateFile->EncryptedBlob.pbData,
                      pPrivateFile->EncryptedBlob.cbData,
                      0,
                      NULL,
                      &cbPrivateBlob))
        {
            DebugLog((SP_LOG_ERROR, "Error 0x%x building PRIVATEKEYBLOB\n",
                GetLastError()));
            ZeroMemory(&md5Ctx, sizeof(md5Ctx));
            pctRet =  SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
            goto error;
        }
    }
    ZeroMemory(&md5Ctx, sizeof(md5Ctx));


    pPrivateBlob = SPExternalAlloc(cbPrivateBlob);
    if(pPrivateBlob == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto error;
    }

    if(!CryptDecodeObject(X509_ASN_ENCODING,
                      szPrivateKeyInfoEncode,
                      pPrivateFile->EncryptedBlob.pbData,
                      pPrivateFile->EncryptedBlob.cbData,
                      0,
                      pPrivateBlob,
                      &cbPrivateBlob))
    {
        DebugLog((SP_LOG_ERROR, "Error 0x%x building PRIVATEKEYBLOB\n",
            GetLastError()));
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto error;
    }

    // HACKHACK - Make sure that the key contained within the private
    // key blob is marked for "key exchange".
    pPrivateBlob->aiKeyAlg = CALG_RSA_KEYX;

    // Create an in-memory key container.
    if(!CryptAcquireContext(&hProv,
                            NULL,
                            NULL,
                            PROV_RSA_SCHANNEL,
                            CRYPT_VERIFYCONTEXT))
    {
        DebugLog((SP_LOG_ERROR, "Couldn't Acquire RSA Provider %lx\n", GetLastError()));
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto error;
    }

    // Import the private key blob into the key container.
    if(!CryptImportKey(hProv,
                       (PBYTE)pPrivateBlob,
                       cbPrivateBlob,
                       0, 0,
                       &hPrivateKey))
    {
        DebugLog((SP_LOG_ERROR, "Error 0x%x importing PRIVATEKEYBLOB\n",
            GetLastError()));
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto error;
    }
    CryptDestroyKey(hPrivateKey);

    // Obtain a matching CSP handle in the application process.
    pctRet = RemoteCryptAcquireContextW(
                                    &pCred->hRemoteProv,
                                    NULL,
                                    NULL,
                                    PROV_RSA_SCHANNEL,
                                    CRYPT_VERIFYCONTEXT);
    if(!NT_SUCCESS(pctRet))
    {
        pCred->hRemoteProv = 0;
        SP_LOG_RESULT(pctRet);
        goto error;
    }

    pCred->hProv       = hProv;
    pCred->dwKeySpec   = AT_KEYEXCHANGE;

    pctRet = PCT_ERR_OK;


error:
    if(pPrivateFile)    SPExternalFree(pPrivateFile);
    if(pPrivateBlob)    SPExternalFree(pPrivateBlob);

    return pctRet;
}

SP_STATUS
LocalCryptAcquireContext(
    HCRYPTPROV *         phProv,
    PCRYPT_KEY_PROV_INFO pProvInfo,
    DWORD                dwProtocol,
    BOOL *               pfEventLogged)
{
    BOOL fImpersonating = FALSE;
    BOOL fSuccess;
    SP_STATUS Status;
    HCRYPTPROV hProv;

    // If the private key belongs to one of the Microsoft PROV_RSA_FULL
    // CSPs, then manually divert it to the Microsoft PROV_RSA_SCHANNEL
    // CSP. This works because both CSP types use the same private key
    // storage scheme.
    if(pProvInfo->dwProvType == PROV_RSA_FULL)
    {
        if(lstrcmpW(pProvInfo->pwszProvName, MS_DEF_PROV_W) == 0 ||
           lstrcmpW(pProvInfo->pwszProvName, MS_STRONG_PROV_W) == 0 ||
           lstrcmpW(pProvInfo->pwszProvName, MS_ENHANCED_PROV_W) == 0)
        {
            DebugLog((DEB_WARN, "Force CSP type to PROV_RSA_SCHANNEL.\n"));
            pProvInfo->pwszProvName = MS_DEF_RSA_SCHANNEL_PROV_W;
            pProvInfo->dwProvType   = PROV_RSA_SCHANNEL;
        }
    }

    if(pProvInfo->dwProvType != PROV_RSA_SCHANNEL && 
       pProvInfo->dwProvType != PROV_DH_SCHANNEL)
    {
        DebugLog((SP_LOG_ERROR, "Bad server CSP type:%d\n", pProvInfo->dwProvType));
        return SP_LOG_RESULT(PCT_ERR_UNKNOWN_CREDENTIAL);
    }

    fImpersonating = SslImpersonateClient();

    fSuccess = CryptAcquireContextW(&hProv,
                                    pProvInfo->pwszContainerName,
                                    pProvInfo->pwszProvName,
                                    pProvInfo->dwProvType,
                                    pProvInfo->dwFlags | CRYPT_SILENT);
    if(fImpersonating)
    {
        RevertToSelf();
        fImpersonating = FALSE;
    }

    if(!fSuccess)
    {
        Status = GetLastError();
        DebugLog((SP_LOG_ERROR, "Error 0x%x calling CryptAcquireContextW\n", Status));
        LogCredAcquireContextFailedEvent(dwProtocol, Status);
        *pfEventLogged = TRUE;

        return SP_LOG_RESULT(PCT_ERR_UNKNOWN_CREDENTIAL);
    }


    DebugLog((SP_LOG_TRACE, "Local CSP handle acquired (0x%p)\n", hProv));

    *phProv = hProv;

    return PCT_ERR_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetPrivateFromCert
//
//  Synopsis:   Given a certificate context, somehow obtain a handle to the
//              corresponding key container. Determine the key spec of the
//              private key.
//
//  Arguments:  [pCred]         --  Pointer to the credential.
//
//  History:    09-24-96   jbanes   Hacked for LSA integration.
//
//  Notes:      The private key often lives in a CSP. In this case, a handle
//              to the CSP context is obtained by either reading the
//              CERT_KEY_REMOTE_PROV_HANDLE_PROP_ID property, or by reading
//              the CERT_KEY_PROV_INFO_PROP_ID property and then calling
//              CryptAcquireContext.
//
//              If this fails, then check and see if the private key is
//              stored by IIS. If this is the case, then the encrypted
//              private key is obtained by reading the
//
//----------------------------------------------------------------------------
SP_STATUS
GetPrivateFromCert(
    PSPCredential pCred, 
    DWORD dwProtocol,
    PLSA_SCHANNEL_SUB_CRED pSubCred)
{
    PCRYPT_KEY_PROV_INFO pProvInfo = NULL;
    HCRYPTPROV  hProv;
    DWORD       cbSize;
    BOOL        fRemoteProvider = FALSE;
    NTSTATUS    Status;
    BOOL        fEventLogged = FALSE;


    //
    // Set the output fields to default values.
    //

    pCred->hProv        = 0;
    pCred->hRemoteProv  = 0;
    pCred->dwKeySpec    = AT_KEYEXCHANGE;


    if(dwProtocol & SP_PROT_CLIENTS)
    {
        // Access the CSP from the application process.
        fRemoteProvider = TRUE;
    }


    //
    // Check to see if the application called CryptAcquireContext. If so then
    // we don't have to. This will typically not be the case.
    //

    if(fRemoteProvider && pSubCred->hRemoteProv)
    { 
        DebugLog((SP_LOG_TRACE, "Application provided CSP handle (0x%p)\n", pSubCred->hRemoteProv));
        pCred->hRemoteProv    = pSubCred->hRemoteProv;
        pCred->fAppRemoteProv = TRUE;
    }


    //
    // Read the certificate context's "key info" property.
    //

    if(CertGetCertificateContextProperty(pCred->pCert,
                                         CERT_KEY_PROV_INFO_PROP_ID,
                                         NULL,
                                         &cbSize))
    {
        SafeAllocaAllocate(pProvInfo, cbSize);
        if(pProvInfo == NULL)
        {
            Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        if(!CertGetCertificateContextProperty(pCred->pCert,
                                              CERT_KEY_PROV_INFO_PROP_ID,
                                              pProvInfo,
                                              &cbSize))
        {
            DebugLog((SP_LOG_ERROR, "Error 0x%x reading CERT_KEY_PROV_INFO_PROP_ID\n",GetLastError()));
            SafeAllocaFree(pProvInfo);
            pProvInfo = NULL;
        }
        else
        {
            // Success.
            pCred->dwKeySpec = pProvInfo->dwKeySpec;

            DebugLog((SP_LOG_TRACE, "Container:%ls\n",     pProvInfo->pwszContainerName));
            DebugLog((SP_LOG_TRACE, "Provider: %ls\n",     pProvInfo->pwszProvName));
            DebugLog((SP_LOG_TRACE, "Type:     0x%8.8x\n", pProvInfo->dwProvType));
            DebugLog((SP_LOG_TRACE, "Flags:    0x%8.8x\n", pProvInfo->dwFlags));
            DebugLog((SP_LOG_TRACE, "Key spec: %d\n",      pProvInfo->dwKeySpec));

            LogCredPropertiesEvent(dwProtocol, pProvInfo, pCred->pCert);
        }
    }


    if(pCred->hRemoteProv)
    {
        // The application supplied an hProv for us to use.

        Status = PCT_ERR_OK;
        goto cleanup;
    }


    if(pProvInfo)
    {
        //
        // We read the "key info" property successfully, so call
        // CryptAcquireContext in order to get a handle to the appropriate
        // key container.
        //

        if(!fRemoteProvider)
        {
            // Call CryptAcquireContext from the LSA process.
            Status = LocalCryptAcquireContext(&hProv, pProvInfo, dwProtocol, &fEventLogged);
            if(Status != PCT_ERR_OK)
            {
                goto cleanup;
            }

            pCred->hProv = hProv;
        }

        // Obtain a matching CSP handle in the application process.
        Status = RemoteCryptAcquireContextW(
                                        &pCred->hRemoteProv,
                                        pProvInfo->pwszContainerName,
                                        pProvInfo->pwszProvName,
                                        pProvInfo->dwProvType,
                                        pProvInfo->dwFlags);
        if(!NT_SUCCESS(Status))
        {
            LogCredAcquireContextFailedEvent(dwProtocol, Status);
            fEventLogged = TRUE;

            Status = SP_LOG_RESULT(PCT_ERR_UNKNOWN_CREDENTIAL);
            goto cleanup;
        }
    }
    else
    {
        //
        // We weren't able to read the "key info" property, so attempt to
        // read the "iis private key" property, and build the private key
        // up from that.
        //

        DebugLog((SP_LOG_TRACE, "Attempt IIS 4.0 compatibility hack.\n"));

        Status = GetIisPrivateFromCert(pCred, pSubCred);

        if(Status != PCT_ERR_OK)
        {
            SP_LOG_RESULT(Status);
            goto cleanup;
        }
    }

    Status = PCT_ERR_OK;

cleanup:

    if(Status != PCT_ERR_OK && fEventLogged == FALSE)
    {
        if(pProvInfo == NULL)
        {
            LogNoPrivateKeyEvent(dwProtocol);
        }
        else
        {
            LogCreateCredFailedEvent(dwProtocol);
        }
    }

    if(pProvInfo)
    {
        SafeAllocaFree(pProvInfo);
    }

    return Status;
}

void
GlobalCheckForCertificateRenewal(void)
{
    PSPCredentialGroup pCredGroup;
    PLIST_ENTRY pList;
    DWORD Status;
    static LONG ReentryCount = 0;

    //
    // This routine gets called every 5 minutes or so. Don't allow resync 
    // operations to get queued up in the rare case where a resync takes
    // longer than that.
    //

    if(InterlockedIncrement(&ReentryCount) > 1)
    {
        goto cleanup;
    }


    //
    // Has the MY certificate store been updated recently?
    //

    if(g_hMyCertStoreEvent == NULL)
    {
        goto cleanup;
    }

    Status = WaitForSingleObjectEx(g_hMyCertStoreEvent, 0, FALSE);
    if(Status != WAIT_OBJECT_0)
    {
        goto cleanup;
    }

    DebugLog((DEB_WARN, "The MY store has been updated, so check for certificate renewal.\n"));


    //
    // Resync the MY certificate store, and reregister for event notification.
    //

    if(!CertControlStore(g_hMyCertStore,
                         0,              // dwFlags
                         CERT_STORE_CTRL_RESYNC,
                         &g_hMyCertStoreEvent)) 
    {
        DebugLog((DEB_ERROR, "Error 0x%x resyncing machine MY store.\n", GetLastError()));
        goto cleanup;
    }


    //
    // Enumerate through each credential, and see if any of the 
    // certificates in them have been renewed.
    //

    RtlEnterCriticalSection( &g_SslCredLock );

    pList = g_SslCredList.Flink ;

    while ( pList != &g_SslCredList )
    {
        pCredGroup = CONTAINING_RECORD( pList, SPCredentialGroup, GlobalCredList.Flink );
        pList = pList->Flink ;

        pCredGroup->dwFlags |= CRED_FLAG_CHECK_FOR_RENEWAL;
    }

    RtlLeaveCriticalSection( &g_SslCredLock );

cleanup:

    InterlockedDecrement(&ReentryCount);
}


void
CheckForCredentialRenewal(
    PSPCredentialGroup pCredGroup)
{
    PLIST_ENTRY pList;
    PSPCredential pCred;
    PSPCredential pNewCred;
    PCCERT_CONTEXT pNewCert = NULL;
    LSA_SCHANNEL_SUB_CRED SubCred;
    BOOL fEventLogged;
    SP_STATUS pctRet;

    //
    // Only dynamically check for the renewal of server certificates.
    // Reacquiring client certificates can involve UI and other 
    // messy stuff like that, so we'll punt on this for now.
    //

    if((pCredGroup->grbitProtocol & SP_PROT_SERVERS) == 0)
    {
        return;
    }


    LockCredentialExclusive(pCredGroup);


    //
    // Check to see if we've already checked out this credential.
    // It's common to get this routine called simultaneously on 
    // several threads when the MY store is updated.
    //

    if((pCredGroup->dwFlags & CRED_FLAG_CHECK_FOR_RENEWAL) == 0)
    {
        // We've already checked out this credential.
        UnlockCredential(pCredGroup);
        return;
    }

    pCredGroup->dwFlags &= ~CRED_FLAG_CHECK_FOR_RENEWAL;


    //
    // Enumerate through each certificate in the credential.
    //

    pList = pCredGroup->CredList.Flink ;

    while ( pList != &pCredGroup->CredList )
    {
        pCred = CONTAINING_RECORD( pList, SPCredential, ListEntry.Flink );
        pList = pList->Flink ;

        //
        // Has this certificate already been replaced?
        //

        if(pCred->dwCertFlags & CF_RENEWED)
        {
            continue;
        }


        //
        // Has this certificate been renewed?
        //

        if(!CheckForCertificateRenewal(pCredGroup->grbitProtocol,
                                       pCred->pCert,
                                       &pNewCert))
        {
            continue;
        }
        pCred->dwCertFlags |= CF_RENEWED;


        //
        // Attempt to build a credential around the new
        // certificate.
        //

        pNewCred = SPExternalAlloc(sizeof(SPCredential));
        if(pNewCred != NULL)
        {
            memset(&SubCred, 0, sizeof(SubCred));

            SubCred.pCert = pNewCert;

            pctRet = SPCreateCred(pCredGroup->grbitProtocol,
                                  &SubCred,
                                  pNewCred,
                                  &fEventLogged);

            CertFreeCertificateContext(pNewCert);

            if(pctRet == PCT_ERR_OK)
            {
                // Insert the new certificate at the head of the list,
                // so that it will be picked up in preference to the
                // old one.
                InsertHeadList( &pCredGroup->CredList, &pNewCred->ListEntry );
                pCredGroup->CredCount++;
                pNewCred = NULL;
            }

            if(pNewCred)
            {
                SPExternalFree(pNewCred);
            }
        }
    }

    UnlockCredential(pCredGroup);
}


BOOL
CheckForCertificateRenewal(
    DWORD dwProtocol,
    PCCERT_CONTEXT pCertContext,
    PCCERT_CONTEXT *ppNewCertificate)
{
    BYTE rgbThumbprint[CB_SHA_DIGEST_LEN];
    DWORD cbThumbprint = sizeof(rgbThumbprint);
    CRYPT_HASH_BLOB HashBlob;
    PCCERT_CONTEXT pNewCert;
    BOOL fMachineCert;
    PCRYPT_KEY_PROV_INFO pProvInfo = NULL;
    DWORD cbSize;
    HCERTSTORE hMyCertStore = 0;
    BOOL fImpersonating = FALSE;
    BOOL fRenewed = FALSE;

    if(dwProtocol & SP_PROT_SERVERS)
    {
        fMachineCert = TRUE;
    }
    else
    {
        fMachineCert = FALSE;
    }


    //
    // Loop through the linked list of renewed certificates, looking
    // for the last one.
    //
    
    while(TRUE)
    {
        //
        // Check for renewal property.
        //

        if(!CertGetCertificateContextProperty(pCertContext,
                                              CERT_RENEWAL_PROP_ID,
                                              rgbThumbprint,
                                              &cbThumbprint))
        {
            // Certificate has not been renewed.
            break;
        }
        DebugLog((DEB_TRACE, "Certificate has renewal property\n"));


        //
        // Determine whether to look in the local machine MY store
        // or the current user MY store.
        //

        if(!hMyCertStore)
        {
            if(CertGetCertificateContextProperty(pCertContext,
                                                 CERT_KEY_PROV_INFO_PROP_ID,
                                                 NULL,
                                                 &cbSize))
            {
                SafeAllocaAllocate(pProvInfo, cbSize);
                if(pProvInfo == NULL)
                {
                    break;
                }

                if(CertGetCertificateContextProperty(pCertContext,
                                                     CERT_KEY_PROV_INFO_PROP_ID,
                                                     pProvInfo,
                                                     &cbSize))
                {
                    if(pProvInfo->dwFlags & CRYPT_MACHINE_KEYSET)
                    {
                        fMachineCert = TRUE;
                    }
                    else
                    {
                        fMachineCert = FALSE;
                    }
                }

                SafeAllocaFree(pProvInfo);
            }
        }


        //
        // Open up the appropriate MY store, and attempt to find
        // the new certificate.
        //

        if(!hMyCertStore)
        {
            if(fMachineCert)
            {
                hMyCertStore = g_hMyCertStore;
            }
            else
            {
                fImpersonating = SslImpersonateClient();

                hMyCertStore = CertOpenSystemStore(0, "MY");
            }

            if(!hMyCertStore)
            {
                DebugLog((DEB_ERROR, "Error 0x%x opening %s MY certificate store!\n", 
                    GetLastError(),
                    (fMachineCert ? "local machine" : "current user") ));
                break;
            }
        }

        HashBlob.cbData = cbThumbprint;
        HashBlob.pbData = rgbThumbprint;

        pNewCert = CertFindCertificateInStore(hMyCertStore, 
                                              X509_ASN_ENCODING, 
                                              0, 
                                              CERT_FIND_HASH, 
                                              &HashBlob, 
                                              NULL);
        if(pNewCert == NULL)
        {
            // Certificate has been renewed, but the new certificate
            // cannot be found.
            DebugLog((DEB_ERROR, "New certificate cannot be found: 0x%x\n", GetLastError()));
            break;
        }


        //
        // Return the new certificate, but first loop back and see if it's been
        // renewed itself.
        //

        pCertContext = pNewCert;
        *ppNewCertificate = pNewCert;


        DebugLog((DEB_TRACE, "Certificate has been renewed\n"));
        fRenewed = TRUE;
    }


    //
    // Cleanup.
    //

    if(hMyCertStore && hMyCertStore != g_hMyCertStore)
    {
        CertCloseStore(hMyCertStore, 0);
    }

    if(fImpersonating)
    {
        RevertToSelf();
        fImpersonating = FALSE;
    }

    return fRenewed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\debug.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       debug.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <alloca.h>

HANDLE g_hfLogFile = NULL;

#if DBG         /* NOTE:  This file not compiled for retail builds */

#include <stdio.h>
#include <stdarg.h>

#define WINDEBUG

#ifndef min
#define min(x,y) ((x)<(y)?(x):(y))
#endif

DWORD   g_dwInfoLevel  = 0;
DWORD   g_dwDebugBreak = 0;
DWORD   PctTraceIndent = 0;


#define MAX_DEBUG_BUFFER 2048

void
BuildDebugHeader(
    DWORD   Mask,
    PSTR    pszHeader,
    PDWORD  pcbHeader);

void
SPDebugOutput(char *szOutString)
{
    DWORD dwWritten;

    if (NULL != g_hfLogFile)
    {
        WriteFile(
            g_hfLogFile,
            szOutString,
            lstrlen(szOutString),
            &dwWritten,
            NULL);
    }
    OutputDebugStringA(szOutString);
}


void
DbgDumpHexString(const unsigned char *String, DWORD cbString)
{
    DWORD i,count;
    CHAR digits[]="0123456789abcdef";
    CHAR pbLine[MAX_PATH];
    DWORD cbLine, cbHeader;
    DWORD_PTR address;

    BuildDebugHeader(DEB_BUFFERS, pbLine, &cbHeader);

    if(String == NULL && cbString != 0)
    {
        strcat(pbLine, "<null> buffer!!!\n"); 
        SPDebugOutput(pbLine);
        return;
    }

    for(; cbString ; cbString -= count, String += count)
    {
        count = (cbString > 16) ? 16:cbString;

        cbLine = cbHeader;

        address = (DWORD_PTR)String;

#if defined(_WIN64)

        pbLine[cbLine++] = digits[(address >> 0x3c) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x38) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x34) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x30) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x2c) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x28) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x24) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x20) & 0x0f];

#endif

        pbLine[cbLine++] = digits[(address >> 0x1c) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x18) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x14) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x10) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x0c) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x08) & 0x0f];
        pbLine[cbLine++] = digits[(address >> 0x04) & 0x0f];
        pbLine[cbLine++] = digits[(address        ) & 0x0f];
        pbLine[cbLine++] = ' ';
        pbLine[cbLine++] = ' ';

        for(i = 0; i < count; i++)
        {
            pbLine[cbLine++] = digits[String[i]>>4];
            pbLine[cbLine++] = digits[String[i]&0x0f];
            if(i == 7)
            {
                pbLine[cbLine++] = ':';
            }
            else
            {
                pbLine[cbLine++] = ' ';
            }
        }

        #if 1
        for(; i < 16; i++)
        {
            pbLine[cbLine++] = ' ';
            pbLine[cbLine++] = ' ';
            pbLine[cbLine++] = ' ';
        }

        pbLine[cbLine++] = ' ';

        for(i = 0; i < count; i++)
        {
            if(String[i] < 32 || String[i] > 126)
            {
                pbLine[cbLine++] = '.';
            }
            else
            {
                pbLine[cbLine++] = String[i];
            }
        }
        #endif

        pbLine[cbLine++] = '\n';
        pbLine[cbLine++] = 0;

        SPDebugOutput(pbLine);
    }
}


char *aszSPDebugLevel[] = {
    "Error  ",
    "Warning",
    "Trace  ",
    "Mem    ",
    "Result "
};

void
BuildDebugHeader(
    DWORD   Mask,
    PSTR    pszHeader,
    PDWORD  pcbHeader)
{
    SYSTEMTIME  stTime;
    DWORD       Level = 0;
    ULONG       ClientProcess;
    ULONG       ClientThread;

    GetLocalTime(&stTime);

    Level = 0;
    while (!(Mask & 1))
    {
        Level++;
        Mask >>= 1;
    }
    if (Level >= sizeof(aszSPDebugLevel) / sizeof(char *))
    {
        Level = sizeof(aszSPDebugLevel) / sizeof(char *) - 1;
    }

    SslGetClientProcess(&ClientProcess);
    SslGetClientThread(&ClientThread);

    *pcbHeader = 0;

    if(g_dwInfoLevel & SP_LOG_TIMESTAMP)
    {
        *pcbHeader = wsprintf(
                        pszHeader,
                        "[%2d/%2d %02d:%02d:%02d.%03d] %d.%d> %s: ",
                        stTime.wMonth, stTime.wDay,
                        stTime.wHour, stTime.wMinute, stTime.wSecond, 
                        stTime.wMilliseconds,
                        ClientProcess, ClientThread,
                        aszSPDebugLevel[Level]);
    }
    else
    {
        *pcbHeader = wsprintf(
                        pszHeader,
                        "%d.%d> %s: ",
                        ClientProcess, ClientThread,
                        aszSPDebugLevel[Level]);
    }
}

void
SPDebugLog(long Mask, const char *Format, ...)
{
    va_list ArgList;
    int     PrefixSize = 0;
    DWORD   iOut;
    char    szOutString[MAX_DEBUG_BUFFER];

    if (Mask & g_dwInfoLevel)
    {
        BuildDebugHeader(Mask, szOutString, &iOut);

        PrefixSize = min(60, PctTraceIndent * 3);
        FillMemory(szOutString+iOut, PrefixSize, ' ');
        PrefixSize += iOut;
        szOutString[PrefixSize] = '\0';

        va_start(ArgList, Format);

        if (wvsprintf(&szOutString[PrefixSize], Format, ArgList) < 0)
        {
            static char szOverFlow[] = "\n<256 byte OVERFLOW!>\n";

            // Less than zero indicates that the string would not fit into the
            // buffer.  Output a special message indicating overflow.

            lstrcpy(
            &szOutString[sizeof(szOutString) - sizeof(szOverFlow)],
            szOverFlow);
        }
        va_end(ArgList);
        SPDebugOutput(szOutString);
    }
}

void
SPLogDistinguishedName(
    DWORD LogLevel,
    LPSTR pszLabel,
    PBYTE pbName,
    DWORD cbName)
{
    CERT_NAME_BLOB Name;
    LPSTR pszName;
    DWORD cchName;

    Name.pbData = pbName;
    Name.cbData = cbName;
    
    cchName = CertNameToStr(CRYPT_ASN_ENCODING,
                            &Name,
                            CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                            NULL,
                            0);
    if(cchName == 0)
    {
        return;
    }

    SafeAllocaAllocate(pszName, cchName);

    if(pszName == NULL)
    {
        return;
    }

    cchName = CertNameToStr(CRYPT_ASN_ENCODING,
                            &Name,
                            CERT_X500_NAME_STR | CERT_NAME_STR_NO_PLUS_FLAG,
                            pszName,
                            cchName);

    if(cchName == 0)
    {
        SafeAllocaFree(pszName);
        return;
    }

    DebugLog((LogLevel, pszLabel, pszName));

    SafeAllocaFree(pszName);
}

long
SPLogErrorCode(
    long err,
    const char *szFile,
    long lLine)
{
    char *szName = "Unknown";

    switch(err)
    {
    case PCT_ERR_OK:                     szName = "PCT_ERR_OK";                     break;
    case PCT_ERR_BAD_CERTIFICATE:        szName = "PCT_ERR_BAD_CERTIFICATE";        break;
    case PCT_ERR_CLIENT_AUTH_FAILED:     szName = "PCT_ERR_CLIENT_AUTH_FAILED";     break;
    case PCT_ERR_ILLEGAL_MESSAGE:        szName = "PCT_ERR_ILLEGAL_MESSAGE";        break;
    case PCT_ERR_INTEGRITY_CHECK_FAILED: szName = "PCT_ERR_INTEGRITY_CHECK_FAILED"; break;
    case PCT_ERR_SERVER_AUTH_FAILED:     szName = "PCT_ERR_SERVER_AUTH_FAILED";     break;
    case PCT_ERR_SPECS_MISMATCH:         szName = "PCT_ERR_SPECS_MISMATCH";         break;
    case PCT_ERR_SSL_STYLE_MSG:          szName = "PCT_ERR_SSL_STYLE_MSG";          break;
    case PCT_ERR_RENEGOTIATE:            szName = "PCT_ERR_RENEGOTIATE";            break;
    case PCT_ERR_UNKNOWN_CREDENTIAL:     szName = "PCT_ERR_UNKNOWN_CREDENTIAL";     break;

    case PCT_INT_BUFF_TOO_SMALL:         szName = "PCT_INT_BUFF_TOO_SMALL";         break;
    case PCT_INT_INCOMPLETE_MSG:         szName = "PCT_INT_INCOMPLETE_MSG";         break;
    case PCT_INT_DROP_CONNECTION:        szName = "PCT_INT_DROP_CONNECTION";        break;
    case PCT_INT_BAD_CERT:               szName = "PCT_INT_BAD_CERT";               break;
    case PCT_INT_CLI_AUTH:               szName = "PCT_INT_CLI_AUTH";               break;
    case PCT_INT_ILLEGAL_MSG:            szName = "PCT_INT_ILLEGAL_MSG";            break;
    case PCT_INT_MSG_ALTERED:            szName = "PCT_INT_MSG_ALTERED";            break;
    case PCT_INT_INTERNAL_ERROR:         szName = "PCT_INT_INTERNAL_ERROR";         break;
    case PCT_INT_DATA_OVERFLOW:          szName = "PCT_INT_DATA_OVERFLOW";          break;
    case PCT_INT_SPECS_MISMATCH:         szName = "PCT_INT_SPECS_MISMATCH";         break;
    case PCT_INT_RENEGOTIATE:            szName = "PCT_INT_RENEGOTIATE";            break;
    case PCT_INT_UNKNOWN_CREDENTIAL:     szName = "PCT_INT_UNKNOWN_CREDENTIAL";     break;

    case SEC_E_INSUFFICIENT_MEMORY:         szName = "SEC_E_INSUFFICIENT_MEMORY";       break;
    case SEC_E_INVALID_HANDLE:              szName = "SEC_E_INVALID_HANDLE";            break;
    case SEC_E_UNSUPPORTED_FUNCTION:        szName = "SEC_E_UNSUPPORTED_FUNCTION";      break;
    case SEC_E_TARGET_UNKNOWN:              szName = "SEC_E_TARGET_UNKNOWN";            break;
    case SEC_E_INTERNAL_ERROR:              szName = "SEC_E_INTERNAL_ERROR";            break;
    case SEC_E_SECPKG_NOT_FOUND:            szName = "SEC_E_SECPKG_NOT_FOUND";          break;
    case SEC_E_NOT_OWNER:                   szName = "SEC_E_NOT_OWNER";                 break;
    case SEC_E_CANNOT_INSTALL:              szName = "SEC_E_CANNOT_INSTALL";            break;
    case SEC_E_INVALID_TOKEN:               szName = "SEC_E_INVALID_TOKEN";             break;
    case SEC_E_CANNOT_PACK:                 szName = "SEC_E_CANNOT_PACK";               break;
    case SEC_E_QOP_NOT_SUPPORTED:           szName = "SEC_E_QOP_NOT_SUPPORTED";         break;
    case SEC_E_NO_IMPERSONATION:            szName = "SEC_E_NO_IMPERSONATION";          break;
    case SEC_E_LOGON_DENIED:                szName = "SEC_E_LOGON_DENIED";              break;
    case SEC_E_UNKNOWN_CREDENTIALS:         szName = "SEC_E_UNKNOWN_CREDENTIALS";       break;
    case SEC_E_NO_CREDENTIALS:              szName = "SEC_E_NO_CREDENTIALS";            break;
    case SEC_E_MESSAGE_ALTERED:             szName = "SEC_E_MESSAGE_ALTERED";           break;
    case SEC_E_OUT_OF_SEQUENCE:             szName = "SEC_E_OUT_OF_SEQUENCE";           break;
    case SEC_E_NO_AUTHENTICATING_AUTHORITY: szName = "SEC_E_NO_AUTHENTICATING_AUTHORITY";  break;
    case SEC_I_CONTINUE_NEEDED:             szName = "SEC_I_CONTINUE_NEEDED";           break;
    case SEC_I_COMPLETE_NEEDED:             szName = "SEC_I_COMPLETE_NEEDED";           break;
    case SEC_I_COMPLETE_AND_CONTINUE:       szName = "SEC_I_COMPLETE_AND_CONTINUE";     break;
    case SEC_I_LOCAL_LOGON:                 szName = "SEC_I_LOCAL_LOGON";               break;
    case SEC_E_BAD_PKGID:                   szName = "SEC_E_BAD_PKGID";                 break;
    case SEC_E_CONTEXT_EXPIRED:             szName = "SEC_E_CONTEXT_EXPIRED";           break;
    case SEC_E_INCOMPLETE_MESSAGE:          szName = "SEC_E_INCOMPLETE_MESSAGE";        break;
    case SEC_E_INCOMPLETE_CREDENTIALS:      szName = "SEC_E_INCOMPLETE_CREDENTIALS";    break;
    case SEC_E_BUFFER_TOO_SMALL:            szName = "SEC_E_BUFFER_TOO_SMALL";          break;
    case SEC_I_INCOMPLETE_CREDENTIALS:      szName = "SEC_I_INCOMPLETE_CREDENTIALS";    break;
    case SEC_I_RENEGOTIATE:                 szName = "SEC_I_RENEGOTIATE";               break;
    case SEC_E_WRONG_PRINCIPAL:             szName = "SEC_E_WRONG_PRINCIPAL";           break;
    case SEC_I_NO_LSA_CONTEXT:              szName = "SEC_I_NO_LSA_CONTEXT";            break;

    case CERT_E_EXPIRED:                    szName = "CERT_E_EXPIRED";                  break;
    case CERT_E_UNTRUSTEDROOT:              szName = "CERT_E_UNTRUSTEDROOT";            break;
    case CRYPT_E_REVOKED:                   szName = "CRYPT_E_REVOKED";                 break;
    case CRYPT_E_NO_REVOCATION_CHECK:       szName = "CRYPT_E_NO_REVOCATION_CHECK";     break;
    case CRYPT_E_REVOCATION_OFFLINE:        szName = "CRYPT_E_REVOCATION_OFFLINE";      break;

    }

    SPDebugLog(SP_LOG_RES, "Result: %s (0x%lx) - %s, Line %d\n", szName, err, szFile, lLine);

    return err;
}

#pragma warning(disable:4206)   /* Disable the empty translation unit */
                /* warning/error */

void
SPAssert(
    void * FailedAssertion,
    void * FileName,
    unsigned long LineNumber,
    char * Message)
{
    UNREFERENCED_PARAMETER(Message);

    SPDebugLog(SP_LOG_ERROR,
               "Assertion FAILED, %s, %s : %d\n",
               FailedAssertion,
               FileName,
               LineNumber);
    DebugBreak();
}


#endif /* DBG */ /* NOTE:  This file not compiled for retail builds */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\cliprot.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cliprot.c
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <pct1msg.h>
#include <pct1prot.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <ssl2prot.h>

UNICipherMap UniAvailableCiphers[] = {
    // NULL cipher suite
    {
        // 0
        SSL3_NULL_WITH_NULL_NULL
    },

    // PCT ciphers
    { 
        // 1
        UNI_CK_PCT, 
            SP_PROT_PCT1,
            0,
            0, 0,
            SP_EXCH_UNKNOWN
    },
    { 
        // 2
        SSL_MKFAST(PCT_SSL_CERT_TYPE, MSBOF(PCT1_CERT_X509_CHAIN), LSBOF(PCT1_CERT_X509_CHAIN)), 
            SP_PROT_PCT1,
            0,
            0, 0,
            SP_EXCH_UNKNOWN
    },
    { 
        // 3
        SSL_MKFAST(PCT_SSL_CERT_TYPE, MSBOF(PCT1_CERT_X509), LSBOF(PCT1_CERT_X509)), 
            SP_PROT_PCT1,
            0,
            0, 0,
            SP_EXCH_UNKNOWN
    },
    { 
        // 4
        SSL_MKFAST(PCT_SSL_HASH_TYPE, MSBOF(PCT1_HASH_MD5), LSBOF(PCT1_HASH_MD5)), 
            SP_PROT_PCT1,
            CALG_MD5,
            0, 0,
            SP_EXCH_UNKNOWN
    },
    { 
        // 5
        SSL_MKFAST(PCT_SSL_HASH_TYPE, MSBOF(PCT1_HASH_SHA), LSBOF(PCT1_HASH_SHA)), 
            SP_PROT_PCT1,
            CALG_SHA,
            0, 0,
            SP_EXCH_UNKNOWN
    },
    { 
        // 6
        SSL_MKFAST(PCT_SSL_EXCH_TYPE, MSBOF(SP_EXCH_RSA_PKCS1),  LSBOF(SP_EXCH_RSA_PKCS1)), 
            SP_PROT_PCT1,
            0,
            0, 0,
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX
    },

    // SSL3 Domestic ciphers
    { 
        // 7
        SSL3_RSA_WITH_RC4_128_MD5, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_MD5 , 
            CALG_RC4 ,128 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX,
            DOMESTIC_CIPHER_SUITE
    },
    { 
        // 8
        SSL3_RSA_WITH_RC4_128_SHA, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_SHA , 
            CALG_RC4 ,128 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    },
    {
        // 9
        SSL3_RSA_WITH_3DES_EDE_CBC_SHA,
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_SHA,
            CALG_3DES ,168 ,
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    },
    {
        // 10
        SSL3_DHE_DSS_WITH_3DES_EDE_CBC_SHA,
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_SHA,
            CALG_3DES ,168 ,
            SP_EXCH_DH_PKCS3, CALG_DH_EPHEM,
            DOMESTIC_CIPHER_SUITE
    },

    // PCT Domestic ciphers
    { 
        // 12
        SSL_MKFAST(PCT_SSL_CIPHER_TYPE_1ST_HALF, MSBOF(PCT1_CIPHER_RC4>>16), LSBOF(PCT1_CIPHER_RC4>>16)),
            SP_PROT_PCT1,
            0,
            CALG_RC4 ,128 ,
            SP_EXCH_UNKNOWN, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    },
    { 
        // 13
        SSL_MKFAST(PCT_SSL_CIPHER_TYPE_2ND_HALF, MSBOF(PCT1_ENC_BITS_128), LSBOF(PCT1_MAC_BITS_128)), 
            SP_PROT_PCT1,
            0,
            CALG_RC4 ,128 ,
            SP_EXCH_UNKNOWN, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    }, 
    
    // SSL2 Domestic ciphers
    { 
        // 14
        SSL_CK_RC4_128_WITH_MD5, 
            SP_PROT_SSL2 , 
            CALG_MD5 , 
            CALG_RC4 ,128 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    },
    { 
        // 15
        SSL_CK_DES_192_EDE3_CBC_WITH_MD5, 
            SP_PROT_SSL2 , 
            CALG_MD5 , 
            CALG_3DES ,168 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    },
    { 
        // 16
        SSL_CK_RC2_128_CBC_WITH_MD5, 
            SP_PROT_SSL2 , 
            CALG_MD5 , 
            CALG_RC2 ,128 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    },

    // SSL3 domestic DES ciphers
    { 
        // 22
        SSL3_RSA_WITH_DES_CBC_SHA, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_SHA , 
            CALG_DES , 56, 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    },
    { 
        // 23
        SSL3_DHE_DSS_WITH_DES_CBC_SHA, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_SHA , 
            CALG_DES , 56 ,
            SP_EXCH_DH_PKCS3, CALG_DH_EPHEM, 
            DOMESTIC_CIPHER_SUITE
    },

    // SSL2 domestic DES ciphers
    { 
        // 24
        SSL_CK_DES_64_CBC_WITH_MD5, 
            SP_PROT_SSL2,
            CALG_MD5 , 
            CALG_DES , 56 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    },

    // SSL3 56-bit export ciphers
    { 
        // 25
        TLS_RSA_EXPORT1024_WITH_RC4_56_SHA, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_SHA , 
            CALG_RC4 ,56 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            EXPORT56_CIPHER_SUITE
    },
    { 
        // 26
        TLS_RSA_EXPORT1024_WITH_DES_CBC_SHA, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_SHA , 
            CALG_DES , 56, 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            EXPORT56_CIPHER_SUITE
    },
    { 
        // 27
        TLS_DHE_DSS_EXPORT1024_WITH_DES_CBC_SHA, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_SHA , 
            CALG_DES , 56 ,
            SP_EXCH_DH_PKCS3, CALG_DH_EPHEM, 
            EXPORT56_CIPHER_SUITE
    },

    // SSL3 Export ciphers
    { 
        // 28
        SSL3_RSA_EXPORT_WITH_RC4_40_MD5, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_MD5 , 
            CALG_RC4 ,40 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            EXPORT40_CIPHER_SUITE
    },
    { 
        // 29
        SSL3_RSA_EXPORT_WITH_RC2_CBC_40_MD5, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_MD5 , 
            CALG_RC2 ,40 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            EXPORT40_CIPHER_SUITE
    },

    // PCT Export ciphers
    { 
        // 30
        SSL_MKFAST(PCT_SSL_CIPHER_TYPE_1ST_HALF, MSBOF(PCT1_CIPHER_RC4>>16), LSBOF(PCT1_CIPHER_RC4>>16)),  
            SP_PROT_PCT1,
            0,
            CALG_RC4 ,40 ,
            SP_EXCH_UNKNOWN, CALG_RSA_KEYX, 
            EXPORT40_CIPHER_SUITE
    },
    { 
        // 31
        SSL_MKFAST(PCT_SSL_CIPHER_TYPE_2ND_HALF, MSBOF(PCT1_ENC_BITS_40), LSBOF(PCT1_MAC_BITS_128)),  
            SP_PROT_PCT1,
            0,
            CALG_RC4 ,40 ,
            SP_EXCH_UNKNOWN, CALG_RSA_KEYX, 
            EXPORT40_CIPHER_SUITE
    },

    // SSL2 Export ciphers
    { 
        // 32
        SSL_CK_RC4_128_EXPORT40_WITH_MD5, 
            SP_PROT_SSL2 ,
            CALG_MD5 , 
            CALG_RC4 ,40 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            EXPORT40_CIPHER_SUITE
    }, 
    { 
        // 33
        SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5, 
            SP_PROT_SSL2 ,
            CALG_MD5 , 
            CALG_RC2 ,40 , 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            EXPORT40_CIPHER_SUITE
    }, 

    // SSL3 Zero privacy ciphers
    { 
        // 34
        SSL3_RSA_WITH_NULL_MD5, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_MD5 , 
            CALG_NULLCIPHER, 0, 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    },
    { 
        // 35
        SSL3_RSA_WITH_NULL_SHA, 
            SP_PROT_SSL3 | SP_PROT_TLS1,
            CALG_SHA , 
            CALG_NULLCIPHER, 0, 
            SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX, 
            DOMESTIC_CIPHER_SUITE
    }
};

DWORD UniNumCiphers = sizeof(UniAvailableCiphers)/sizeof(UNICipherMap);



SP_STATUS WINAPI
GenerateSsl2StyleHello(
    PSPContext              pContext,
    PSPBuffer               pOutput,
    WORD                    fProtocol);


SP_STATUS
GetSupportedCapiAlgs(
    HCRYPTPROV          hProv,
    PROV_ENUMALGS_EX ** ppAlgInfo,
    DWORD *             pcAlgInfo)
{
    PROV_ENUMALGS_EX AlgInfo;
    DWORD   dwFlags;
    DWORD   cbData;
    DWORD   cAlgs;
    DWORD   i;

    *ppAlgInfo = NULL;
    *pcAlgInfo = 0;

    // Count the algorithms.
    dwFlags = CRYPT_FIRST;
    for(cAlgs = 0; ; cAlgs++)
    {
        cbData = sizeof(PROV_ENUMALGS_EX);
        if(!CryptGetProvParam(hProv, 
                              PP_ENUMALGS_EX,
                              (PBYTE)&AlgInfo,
                              &cbData,
                              dwFlags))
        {
            if(GetLastError() != ERROR_NO_MORE_ITEMS)
            {
                SP_LOG_RESULT(GetLastError());
            }
            break;
        }
        dwFlags = 0;
    }
    if(cAlgs == 0)
    {
        return SP_LOG_RESULT(SEC_E_ALGORITHM_MISMATCH);
    }

    // Allocate memory.
    *ppAlgInfo = SPExternalAlloc(sizeof(PROV_ENUMALGS_EX) * cAlgs);
    if(*ppAlgInfo == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    // Read the algorithms.
    dwFlags = CRYPT_FIRST;
    for(i = 0; i < cAlgs; i++)
    {
        cbData = sizeof(PROV_ENUMALGS_EX);
        if(!CryptGetProvParam(hProv, 
                              PP_ENUMALGS_EX,
                              (PBYTE)(*ppAlgInfo + i),
                              &cbData,
                              dwFlags))
        {
            if(GetLastError() != ERROR_NO_MORE_ITEMS)
            {
                SP_LOG_RESULT(GetLastError());
            }
            break;
        }
        dwFlags = 0;
    }
    if(i == 0)
    {
        SPExternalFree(*ppAlgInfo);
        *ppAlgInfo = NULL;

        LogNoCiphersSupportedEvent();
        return SP_LOG_RESULT(SEC_E_ALGORITHM_MISMATCH);
    }

    *pcAlgInfo = i;

    return PCT_ERR_OK;
}


SP_STATUS WINAPI
GenerateHello(
    PSPContext              pContext,
    PSPBuffer               pOutput,
    BOOL                    fCache)
{
    PSessCacheItem      pZombie;
    PSPCredentialGroup  pCred;
    BOOL                fFound;
    DWORD               fProt;

    if (!pOutput)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    if(fCache)
    {
        // Look this id up in the cache
        fFound = SPCacheRetrieveByName(pContext->pszTarget, 
                                       pContext->pCredGroup,
                                       &pContext->RipeZombie);
    }
    else
    {
        fFound = FALSE;
    }

    if(!fFound)
    {
        // We're doing a full handshake, so allocate a cache entry.
        if(!SPCacheRetrieveNew(FALSE,
                               pContext->pszTarget, 
                               &pContext->RipeZombie))
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }
        pContext->RipeZombie->dwCF = pContext->dwRequestedCF;
    }

    if(pContext->RipeZombie == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }
    pZombie = pContext->RipeZombie;

    pCred = pContext->pCredGroup;
    if(!pCred)   
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // Use protocol from cache unless it's a new cache element, 
    // in which case use the protocol from credential.
    if(fFound)
    {
        fProt = pZombie->fProtocol;
    }
    else
    {
        fProt = pCred->grbitEnabledProtocols;
    }
    pContext->dwProtocol = fProt;
    pContext->dwClientEnabledProtocols = fProt;
    
    if(SP_PROT_UNI_CLIENT & fProt)
    {
        pContext->State             = UNI_STATE_CLIENT_HELLO;
        pContext->ProtocolHandler   = ClientProtocolHandler;

        return GenerateUniHello(pContext, pOutput, pCred->grbitEnabledProtocols);
    }

    else 
    if(SP_PROT_TLS1_CLIENT & fProt)
    {
        DWORD dwProtocol = SP_PROT_TLS1_CLIENT;

        pContext->State             = SSL3_STATE_CLIENT_HELLO;
        pContext->ProtocolHandler   = Ssl3ProtocolHandler;
        if(!fFound)
        {
            pZombie->fProtocol = SP_PROT_TLS1_CLIENT;
        }

        if(SP_PROT_SSL3_CLIENT & fProt)
        {
            // Both TLS and SSL3 are enabled.
            dwProtocol |= SP_PROT_SSL3_CLIENT;
        }

        return GenerateTls1ClientHello(pContext,  pOutput, dwProtocol);
    }

    else 
    if(SP_PROT_SSL3_CLIENT & fProt)
    {
        pContext->State             = SSL3_STATE_CLIENT_HELLO;
        pContext->ProtocolHandler   = Ssl3ProtocolHandler;
        if(!fFound)
        {
            pZombie->fProtocol = SP_PROT_SSL3_CLIENT;
        }

        return GenerateSsl3ClientHello(pContext,  pOutput);
    }

    else 
    if(SP_PROT_PCT1_CLIENT & fProt)
    {
        pContext->State             = PCT1_STATE_CLIENT_HELLO;
        pContext->ProtocolHandler   = Pct1ClientProtocolHandler;

        return GeneratePct1StyleHello(pContext, pOutput);
    }

    else 
    if(SP_PROT_SSL2_CLIENT & fProt)
    {
        pContext->State             = SSL2_STATE_CLIENT_HELLO;
        pContext->ProtocolHandler   = Ssl2ClientProtocolHandler;

        return GenerateUniHello(pContext, pOutput, SP_PROT_SSL2_CLIENT);
    } 
    else
    {
        return SP_LOG_RESULT(SEC_E_ALGORITHM_MISMATCH);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ClientVetAlg
//
//  Synopsis:   Examine the cipher suite input, and decide if it is currently
//              enabled. Take into account the enabled protocols and ciphers
//              enabled in the schannel registry as well as the protocols and
//              ciphers enabled by the application in the V3 credential. 
//              Return TRUE if the cipher suite is enabled.
//
//  Arguments:  [pContext]      --  Schannel context.
//
//              [dwProtocol]    --  Client protocols to be included in the
//                                  ClientHello message.
//
//              [pCipherMap]    --  Cipher suite to be examined.
//
//  History:    10-29-97   jbanes   Created
//
//  Notes:      This routine is called by the client-side only.
//
//----------------------------------------------------------------------------
BOOL
ClientVetAlg(
    PSPContext      pContext, 
    DWORD           dwProtocol, 
    UNICipherMap *  pCipherMap)
{
    PCipherInfo         pCipherInfo = NULL;
    PHashInfo           pHashInfo   = NULL;
    PKeyExchangeInfo    pExchInfo   = NULL;

    if((pCipherMap->fProt & dwProtocol) == 0)
    {
        return FALSE;
    }


    // Is cipher supported?
    if(pCipherMap->aiCipher != 0)
    {
        pCipherInfo = GetCipherInfo(pCipherMap->aiCipher, 
                                    pCipherMap->dwStrength);

        if(!IsCipherSuiteAllowed(pContext, 
                                 pCipherInfo, 
                                 dwProtocol,
                                 pContext->RipeZombie->dwCF,
                                 pCipherMap->dwFlags))
        {
            return FALSE;
        }
    }

    // Is hash supported?
    if(pCipherMap->aiHash != 0)
    {
        pHashInfo = GetHashInfo(pCipherMap->aiHash);

        if(!IsHashAllowed(pContext, pHashInfo, dwProtocol))
        {
            return FALSE;
        }
    }

    // Is exchange alg supported?
    if(pCipherMap->KeyExch != SP_EXCH_UNKNOWN)
    {
        pExchInfo = GetKeyExchangeInfo(pCipherMap->KeyExch);

        if(!IsExchAllowed(pContext, pExchInfo, dwProtocol))
        {
            return FALSE;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   ClientBuildAlgList
//
//  Synopsis:   Build a list of ciphers to be included in the ClientHello
//              message. This routine is used by all protocols.
//
//  Arguments:  [pContext]      --  Schannel context.
//
//              [fProtocol]     --  Protocol(s) to be included in the
//                                  ClientHello message.
//
//              [pCipherSpecs]  --  (out) Array where cipher specs are
//                                  placed.
//
//              [pcCipherSpecs] --  (out) Size of cipher specs array.
//
//  History:    10-29-97   jbanes   Created
//
//  Notes:      This routine is called by the client-side only.
//
//----------------------------------------------------------------------------
SP_STATUS
ClientBuildAlgList(
    PSPContext          pContext,
    DWORD               dwProtocol,
    Ssl2_Cipher_Kind *  pCipherSpecs,
    PDWORD              pcCipherSpecs)
{
    DWORD i;
    DWORD cCipherSpecs = 0;

    // Consider only the client protocols.
    dwProtocol &= SP_PROT_CLIENTS;


    //
    // Handle the RSA case.
    //

    if(g_hRsaSchannel && g_pRsaSchannelAlgs)
    {
        for(i = 0; i < UniNumCiphers; i++)
        {
            if(UniAvailableCiphers[i].KeyExch != SP_EXCH_RSA_PKCS1 &&
               UniAvailableCiphers[i].KeyExch != SP_EXCH_UNKNOWN) 
            {
                continue;
            }

            if(!ClientVetAlg(pContext, dwProtocol, UniAvailableCiphers + i))
            {
                continue;
            }

            if(!IsAlgSupportedCapi(dwProtocol, 
                                   UniAvailableCiphers + i,
                                   g_pRsaSchannelAlgs,
                                   g_cRsaSchannelAlgs))
            {
                continue;
            }

            // this cipher is good to request
            pCipherSpecs[cCipherSpecs++] = UniAvailableCiphers[i].CipherKind;
        }
    }


    //
    // Handle the DH case. 
    //

    if(g_hDhSchannelProv)
    {
        for(i = 0; i < UniNumCiphers; i++)
        {
            if(UniAvailableCiphers[i].KeyExch != SP_EXCH_DH_PKCS3) 
            {
                continue;
            }

            if(!ClientVetAlg(pContext, dwProtocol, UniAvailableCiphers + i))
            {
                continue;
            }

            if(!IsAlgSupportedCapi(dwProtocol, 
                                   UniAvailableCiphers + i,
                                   g_pDhSchannelAlgs,
                                   g_cDhSchannelAlgs))
            {
                continue;
            }

            // this cipher is good to request
            pCipherSpecs[cCipherSpecs++] = UniAvailableCiphers[i].CipherKind;
        }
    }


    if(cCipherSpecs == 0)
    {
        return SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH);
    }

    *pcCipherSpecs = cCipherSpecs;

    return PCT_ERR_OK;
}



SP_STATUS WINAPI
GenerateUniHelloMessage(
    PSPContext              pContext,
    Ssl2_Client_Hello *     pHelloMessage,
    DWORD                   fProtocol
    )
{
    SP_STATUS   pctRet;

    SP_BEGIN("GenerateUniHelloMessage");


    if(!pHelloMessage)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }


    pContext->Flags |= CONTEXT_FLAG_CLIENT;


    // Generate the cipher list
    pHelloMessage->cCipherSpecs = MAX_UNI_CIPHERS;
    pctRet =  ClientBuildAlgList(pContext,
                                 fProtocol,
                                 pHelloMessage->CipherSpecs,
                                 &pHelloMessage->cCipherSpecs);
    if(pctRet != PCT_ERR_OK)
    {
        SP_RETURN(SP_LOG_RESULT(pctRet));
    }


    // We're minimally version 2
    pHelloMessage->dwVer = SSL2_CLIENT_VERSION;


    if(fProtocol & SP_PROT_TLS1_CLIENT)
    {
        pHelloMessage->dwVer = TLS1_CLIENT_VERSION;
    } 
    else if(fProtocol & SP_PROT_SSL3_CLIENT)
    {
        pHelloMessage->dwVer = SSL3_CLIENT_VERSION;
    } 

   /* Build the hello message. */
    pHelloMessage->cbSessionID = 0;

    if (pContext->RipeZombie && pContext->RipeZombie->cbSessionID)
    {
        KeyExchangeSystem *pKeyExchSys = NULL;

        // Get pointer to key exchange system.
        pKeyExchSys = KeyExchangeFromSpec(pContext->RipeZombie->SessExchSpec, 
                                          pContext->RipeZombie->fProtocol);
        if(pKeyExchSys)
        {
            // Request a reconnect.
            CopyMemory(pHelloMessage->SessionID, 
                       pContext->RipeZombie->SessionID,  
                       pContext->RipeZombie->cbSessionID);

            pHelloMessage->cbSessionID =  pContext->RipeZombie->cbSessionID;
        }
        else
        {
            DebugLog((DEB_WARN, "Abstaining from requesting reconnect\n"));
        }
    }

    CopyMemory(  pHelloMessage->Challenge,
                pContext->pChallenge,
                pContext->cbChallenge);
    pHelloMessage->cbChallenge = pContext->cbChallenge;

    SP_RETURN(PCT_ERR_OK);
}


SP_STATUS WINAPI
GenerateUniHello(
    PSPContext             pContext,
    PSPBuffer               pOutput,
    DWORD                   fProtocol
    )

{
    SP_STATUS pctRet;
    Ssl2_Client_Hello    HelloMessage;

    SP_BEGIN("GenerateUniHello");

    pctRet = GenerateRandomBits(pContext->pChallenge, SSL2_CHALLENGE_SIZE);
    if(pctRet != STATUS_SUCCESS)
    {
        SP_RETURN(pctRet);
    }

    pContext->cbChallenge = SSL2_CHALLENGE_SIZE;

    pctRet = GenerateUniHelloMessage(pContext, &HelloMessage, fProtocol);
    
    pContext->ReadCounter = 0;

    if(PCT_ERR_OK != pctRet)
    {
        SP_RETURN(pctRet);
    }
    if(PCT_ERR_OK != (pctRet = Ssl2PackClientHello(&HelloMessage,  pOutput))) 
    {
        SP_RETURN(pctRet);
    }

    // Save the ClientHello message so we can hash it later, once
    // we know what algorithm and CSP we're using.
    if(pContext->pClientHello)
    {
        SPExternalFree(pContext->pClientHello);
    }
    pContext->pClientHello = SPExternalAlloc(pOutput->cbData);
    if(pContext->pClientHello == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
    }
    CopyMemory(pContext->pClientHello, pOutput->pvBuffer, pOutput->cbData);
    pContext->cbClientHello = pOutput->cbData;
    pContext->dwClientHelloProtocol = SP_PROT_SSL2_CLIENT;

    /* We set this here to tell the protocol engine that we just send a client
     * hello, and we're expecting a pct server hello */
    pContext->WriteCounter = 1;
    pContext->ReadCounter = 0;

    SP_RETURN(PCT_ERR_OK);
}

SP_STATUS WINAPI
ClientProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput)
{
    PUCHAR pb;
    DWORD dwVersion;
    PSPCredentialGroup  pCred;

    pCred = pContext->pCredGroup;
    if(!pCred)   
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    /* PCTv1.0 Server Hello starts with
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * PCT1_SERVER_HELLO  (must be equal)
     * SH_PAD
     * PCT1_CLIENT_VERSION_MSB (must be pct1)
     * PCT1_CLIENT_VERSION_LSB (must be pct1) 
     *
     * ... PCT hello ...
     */


    /* SSLv2 Hello starts with
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * SSL2_SERVER_HELLO  (must be equal)
     * SESSION_ID_HIT
     * CERTIFICATE_TYPE
     * SSL2_CLIENT_VERSION_MSB (Must be ssl2)
     * SSL2_CLIENT_VERSION_LSB (Must be ssl2)
     *
     * ... SSLv2 Hello ...
     */


    /* SSLv3 Type 3 Server Hello starts with
     * 0x15 Hex (HANDSHAKE MESSAGE)
     * VERSION MSB
     * VERSION LSB
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * HS TYPE (SERVER_HELLO)
     * 3 bytes HS record length
     * HS Version
     * HS Version
     */

    // We need at least 12 bytes to determine what we have.
    if (pCommInput->cbData < 12)
    {
        return(PCT_INT_INCOMPLETE_MSG);
    }

    pb = pCommInput->pvBuffer;

    if(pb[0] == SSL3_CT_HANDSHAKE && pb[5] == SSL3_HS_SERVER_HELLO)
    {
        dwVersion = COMBINEBYTES(pb[9], pb[10]);

        if((dwVersion == SSL3_CLIENT_VERSION) && 
           (pCred->grbitEnabledProtocols & SP_PROT_SSL3_CLIENT))
        {
            // This appears to be an SSL3 server_hello.
            pContext->dwProtocol = SP_PROT_SSL3_CLIENT;
        }
        else if((dwVersion == TLS1_CLIENT_VERSION) && 
           (pCred->grbitEnabledProtocols & SP_PROT_TLS1_CLIENT))
        {
            // This appears to be a TLS server_hello.
            pContext->dwProtocol = SP_PROT_TLS1_CLIENT;
        }
        else
        {
            return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        }

        pContext->ProtocolHandler = Ssl3ProtocolHandler;
        pContext->DecryptHandler  = Ssl3DecryptHandler;
        return(Ssl3ProtocolHandler(pContext, pCommInput, pCommOutput));
    }

    if(pb[2] == SSL2_MT_SERVER_HELLO)
    {
        dwVersion = COMBINEBYTES(pb[5], pb[6]);
        if(dwVersion == SSL2_CLIENT_VERSION) 
        {
            if(!(SP_PROT_SSL2_CLIENT & pCred->grbitEnabledProtocols))
            {
                return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
            }

            // This appears to be an SSL2 server_hello.
            pContext->dwProtocol      = SP_PROT_SSL2_CLIENT;
            pContext->ProtocolHandler = Ssl2ClientProtocolHandler;
            pContext->DecryptHandler  = Ssl2DecryptHandler;
            return(Ssl2ClientProtocolHandler(pContext, pCommInput, pCommOutput));
        }
    }
    if(pb[2] == PCT1_MSG_SERVER_HELLO)
    {
        DWORD i;
        dwVersion = COMBINEBYTES(pb[4], pb[5]);
        if(dwVersion ==PCT_VERSION_1) 
        {
            if(!(SP_PROT_PCT1_CLIENT & pCred->grbitEnabledProtocols))
            {
                return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
            }

            // Convert challenge from 16 byte to 32 byte
            for(i=0; i < pContext->cbChallenge; i++)
            {
                pContext->pChallenge[i + pContext->cbChallenge] = ~pContext->pChallenge[i];
            }
            pContext->cbChallenge = 2*pContext->cbChallenge;

            // This appears to be a PCT server_hello.
            pContext->dwProtocol      = SP_PROT_PCT1_CLIENT;
            pContext->ProtocolHandler = Pct1ClientProtocolHandler;
            pContext->DecryptHandler  = Pct1DecryptHandler;
            return(Pct1ClientProtocolHandler(pContext, pCommInput, pCommOutput));
        }
    }

    return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\defcreds.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Widows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       defcreds.c
//
//  Contents:   Routines for acquiring default credentials.
//
//  Classes:
//
//  Functions:
//
//  History:    12-05-97   jbanes   Created.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <softpub.h>

void
GetImplementationType(
    PCCERT_CONTEXT pCertContext,
    PDWORD pdwImpType);


NTSTATUS
AssignNewClientCredential(
    PSPContext      pContext,
    PCCERT_CONTEXT  pCertContext,
    BOOL            fPromptNow)
{
    PSPCredential   pCred = NULL;
    NTSTATUS        Status;
    BOOL            fEventLogged;
    LSA_SCHANNEL_SUB_CRED SubCred;

    //
    // Does this certificate have an acceptable public key type?
    //

    {
        BOOL    fFound;
        DWORD   dwKeyType;
        DWORD   i;

        fFound    = FALSE;
        dwKeyType = MapOidToCertType(pCertContext->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId);

        for(i = 0; i < pContext->cSsl3ClientCertTypes; i++)
        {
            if(pContext->Ssl3ClientCertTypes[i] == dwKeyType)
            {
                fFound = TRUE;
                break;
            }
        }
        if(!fFound)
        {
            // Don't use this certificate.
            Status = SP_LOG_RESULT(PCT_INT_UNKNOWN_CREDENTIAL);
            goto cleanup;
        }
    }


    //
    // Build a credential structure for the certificate.
    //

    pCred = SPExternalAlloc(sizeof(SPCredential));
    if(pCred == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }

    memset(&SubCred, 0, sizeof(SubCred));

    SubCred.pCert  = pCertContext;

    Status = SPCreateCred(pContext->dwProtocol,
                          &SubCred,
                          pCred,
                          &fEventLogged);
    if(Status != PCT_ERR_OK)
    {
        goto cleanup;
    }


    //
    // Release the existing credential, if one exists.
    //

    if(pContext->RipeZombie->pClientCred)
    {
        SPDeleteCred(pContext->RipeZombie->pClientCred, TRUE);
        pContext->RipeZombie->pClientCred = NULL;
    }


    //
    // Assign the credential to the cache element.
    //

    pContext->RipeZombie->pClientCred = pCred;
    pContext->pActiveClientCred       = pCred;

    if(fPromptNow == FALSE)
    {
        pContext->RipeZombie->dwFlags |= SP_CACHE_FLAG_USE_VALIDATED;
    }

    Status = PCT_ERR_OK;


cleanup:

    if(pCred && Status != PCT_ERR_OK)
    {
        SPDeleteCred(pCred, TRUE);
    }

    return Status;
}

NTSTATUS
QueryCredentialManagerForCert(
    PSPContext          pContext,
    LPWSTR              pszTarget)
{
    PCCERT_CONTEXT      pCertContext = NULL;
    LUID                LogonId;
    PENCRYPTED_CREDENTIALW pCredential = NULL;
    BOOL                fImpersonating = FALSE;
    CRYPT_HASH_BLOB     HashBlob;
    NTSTATUS            Status;
    HCERTSTORE          hStore = 0;
    PCERT_CREDENTIAL_INFO pCertInfo = NULL;
    CRED_MARSHAL_TYPE   CredType;

    //
    // Obtain client logon id.
    //

    Status = SslGetClientLogonId(&LogonId);

    if(!NT_SUCCESS(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }

    fImpersonating = SslImpersonateClient();


    //
    // Query the credential manager for a certificate.
    //

    Status = LsaTable->CrediRead(&LogonId,
                                 CREDP_FLAGS_IN_PROCESS,
                                 pszTarget,
                                 CRED_TYPE_DOMAIN_CERTIFICATE,
                                 0,
                                 &pCredential);
    if(!NT_SUCCESS(Status))
    {
        if(Status == STATUS_NOT_FOUND)
        {
            DebugLog((DEB_WARN, "No certificate found in credential manager.\n"));
        }
        else
        {
            SP_LOG_RESULT(Status);
        }
        goto cleanup;
    }


    //
    // Extract the certificate thumbprint and (optional) PIN.
    //

    if(!CredIsMarshaledCredentialW(pCredential->Cred.UserName))
    {
        Status = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        goto cleanup;
    }

    if(!CredUnmarshalCredentialW(pCredential->Cred.UserName,
                                 &CredType,
                                 &pCertInfo))
    {
        Status = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        goto cleanup;
    }
    if(CredType != CertCredential)
    {
        Status = SP_LOG_RESULT(SEC_E_UNKNOWN_CREDENTIALS);
        goto cleanup;
    }


    //
    // Look up the certificate in the MY certificate store.
    //

    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                           X509_ASN_ENCODING, 0,
                           CERT_SYSTEM_STORE_CURRENT_USER |
                           CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG,
                           L"MY");
    if(!hStore)
    {
        SP_LOG_RESULT(GetLastError());
        Status = SEC_E_NO_CREDENTIALS;
        goto cleanup;
    }


    HashBlob.cbData = sizeof(pCertInfo->rgbHashOfCert);
    HashBlob.pbData = pCertInfo->rgbHashOfCert;

    pCertContext = CertFindCertificateInStore(hStore,
                                              X509_ASN_ENCODING,
                                              0,
                                              CERT_FIND_HASH,
                                              &HashBlob,
                                              NULL);
    if(pCertContext == NULL)
    {
        DebugLog((DEB_ERROR, "Certificate designated by credential manager was not found in certificate store (0x%x).\n", GetLastError()));
        Status = SEC_E_NO_CREDENTIALS;
        goto cleanup;
    }


    //
    // Attempt to add this certificate context to the current credential.
    //

    Status = AssignNewClientCredential(pContext,
                                       pCertContext,
                                       pCredential->Cred.Flags & CRED_FLAGS_PROMPT_NOW);
    if(!NT_SUCCESS(Status))
    {
        SP_LOG_RESULT(Status);
        goto cleanup;
    }


    Status = STATUS_SUCCESS;

cleanup:

    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if(hStore)
    {
        CertCloseStore(hStore, 0);
    }

    if(pCredential)
    {
        LsaTable->FreeLsaHeap(pCredential);
    }

    if(pCertInfo)
    {
        CredFree(pCertInfo);
    }

    if(fImpersonating)
    {
        RevertToSelf();
    }

    return Status;
}


DWORD
IsThreadLocalSystem(
    BOOL *pfIsLocalSystem)
{
    DWORD Status;
    HANDLE hToken = 0;
    UCHAR InfoBuffer[1024];
    DWORD dwInfoBufferSize = sizeof(InfoBuffer);
    PTOKEN_USER SlowBuffer = NULL;
    PTOKEN_USER pTokenUser = (PTOKEN_USER)InfoBuffer;
    PSID psidLocalSystem = NULL;
    PSID psidNetworkService = NULL;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;

    *pfIsLocalSystem = FALSE;

    //
    // Get SID of calling thread.
    //

    if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken))
    {
        Status = GetLastError();
        goto cleanup;
    }

    if(!GetTokenInformation(hToken, TokenUser, pTokenUser,
                            dwInfoBufferSize, &dwInfoBufferSize))
    {
        //
        // if fast buffer wasn't big enough, allocate enough storage
        // and try again.
        //

        Status = GetLastError();
        if(Status != ERROR_INSUFFICIENT_BUFFER)
        {
            goto cleanup;
        }

        SlowBuffer = (PTOKEN_USER)LocalAlloc(LPTR, dwInfoBufferSize);
        if(NULL == SlowBuffer)
        {
            Status = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        pTokenUser = SlowBuffer;
        if(!GetTokenInformation(hToken, TokenUser, pTokenUser,
                                dwInfoBufferSize, &dwInfoBufferSize))
        {
            Status = GetLastError();
            goto cleanup;
        }
    }


    //
    // Check for local system.
    //

    if(!AllocateAndInitializeSid(&siaNtAuthority,
                                 1,
                                 SECURITY_LOCAL_SYSTEM_RID,
                                 0, 0, 0, 0, 0, 0, 0,
                                 &psidLocalSystem))
    {
        Status = GetLastError();
        goto cleanup;
    }

    if (EqualSid(psidLocalSystem, pTokenUser->User.Sid))
    {
        DebugLog((DEB_TRACE, "Client is using the LOCAL SYSTEM account.\n"));
        *pfIsLocalSystem = TRUE;
        Status = ERROR_SUCCESS;
        goto cleanup;
    }


    //
    // Check for network service.
    //

    if(!AllocateAndInitializeSid(&siaNtAuthority,
                                 1,
                                 SECURITY_NETWORK_SERVICE_RID,
                                 0, 0, 0, 0, 0, 0, 0,
                                 &psidNetworkService))
    {
        Status = GetLastError();
        goto cleanup;
    }

    if (EqualSid(psidNetworkService, pTokenUser->User.Sid))
    {
        DebugLog((DEB_TRACE, "Client is using the NETWORK SERVICE account.\n"));
        *pfIsLocalSystem = TRUE;
        Status = ERROR_SUCCESS;
        goto cleanup;
    }

    Status = ERROR_SUCCESS;

cleanup:

    if(NULL != SlowBuffer)
    {
        LocalFree(SlowBuffer);
    }

    if(NULL != psidLocalSystem)
    {
        FreeSid(psidLocalSystem);
    }
    if(NULL != psidNetworkService)
    {
        FreeSid(psidNetworkService);
    }

    if(NULL != hToken)
    {
        CloseHandle(hToken);
    }

    return Status;
}


NTSTATUS
FindClientCertificate(
    PSPContext pContext,
    HCERTSTORE hMyStore,
    CERT_CHAIN_FIND_BY_ISSUER_PARA *pFindByIssuerPara,
    BOOL fSkipExpiredCerts,
    BOOL fSoftwareCspOnly)
{
    PCCERT_CHAIN_CONTEXT        pChainContext = NULL;
    HTTPSPolicyCallbackData     polHttps;
    CERT_CHAIN_POLICY_PARA      PolicyPara;
    CERT_CHAIN_POLICY_STATUS    PolicyStatus;
    PCCERT_CONTEXT              pCertContext;
    NTSTATUS Status;
    ULONG j;

    pChainContext = NULL;

    while(TRUE)
    {
        // Find a certificate chain.
        pChainContext = CertFindChainInStore(hMyStore,
                                             X509_ASN_ENCODING,
                                             0,
                                             CERT_CHAIN_FIND_BY_ISSUER,
                                             pFindByIssuerPara,
                                             pChainContext);
        if(pChainContext == NULL)
        {
            break;
        }

        // Make sure that every certificate in the chain either has the
        // client auth EKU or it has no EKUs at all.
        {
            PCERT_SIMPLE_CHAIN  pSimpleChain;
            PCCERT_CONTEXT      pCurrentCert;
            BOOL                fIsAllowed = FALSE;

            pSimpleChain = pChainContext->rgpChain[0];

            for(j = 0; j < pSimpleChain->cElement; j++)
            {
                pCurrentCert = pSimpleChain->rgpElement[j]->pCertContext;

                Status = SPCheckKeyUsage(pCurrentCert,
                                        szOID_PKIX_KP_CLIENT_AUTH,
                                        TRUE,
                                        &fIsAllowed);
                if(Status != SEC_E_OK || !fIsAllowed)
                {
                    fIsAllowed = FALSE;
                    break;
                }
            }
            if(!fIsAllowed)
            {
                // skip this certificate chain.
                continue;
            }
        }


        // Set up validate chain structures.
        ZeroMemory(&polHttps, sizeof(HTTPSPolicyCallbackData));
        polHttps.cbStruct           = sizeof(HTTPSPolicyCallbackData);
        polHttps.dwAuthType         = AUTHTYPE_CLIENT;
        polHttps.fdwChecks          = 0;
        polHttps.pwszServerName     = NULL;

        ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
        PolicyStatus.cbSize         = sizeof(PolicyStatus);

        ZeroMemory(&PolicyPara, sizeof(PolicyPara));
        PolicyPara.cbSize           = sizeof(PolicyPara);
        PolicyPara.pvExtraPolicyPara= &polHttps;

        PolicyPara.dwFlags          = CERT_CHAIN_POLICY_IGNORE_WRONG_USAGE_FLAG |
                                      CERT_CHAIN_POLICY_ALLOW_UNKNOWN_CA_FLAG;
        if(!fSkipExpiredCerts)
        {
            PolicyPara.dwFlags |= CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS;
        }

        // Validate chain
        if(!CertVerifyCertificateChainPolicy(
                                CERT_CHAIN_POLICY_SSL,
                                pChainContext,
                                &PolicyPara,
                                &PolicyStatus))
        {
            DebugLog((DEB_WARN,"Error 0x%x returned by CertVerifyCertificateChainPolicy!\n", GetLastError()));
            continue;
        }
        Status = MapWinTrustError(PolicyStatus.dwError, 0, 0);
        if(Status)
        {
            // Certificate did not validate, move on to the next one.
            DebugLog((DEB_WARN, "Client certificate failed validation with 0x%x\n", Status));
            continue;
        }

        // Get pointer to leaf certificate context.
        if(pChainContext->cChain == 0 || pChainContext->rgpChain[0] == NULL)
        {
            Status = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
            goto cleanup;
        }
        if(pChainContext->rgpChain[0]->cElement == 0 ||
           pChainContext->rgpChain[0]->rgpElement == NULL)
        {
            Status = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
            goto cleanup;
        }
        pCertContext = pChainContext->rgpChain[0]->rgpElement[0]->pCertContext;


        //
        // Is the private key stored in a software CSP?
        //

        if(fSoftwareCspOnly)
        {
            DWORD dwImpType;

            GetImplementationType(pCertContext, &dwImpType);

            if(dwImpType != CRYPT_IMPL_SOFTWARE)
            {
                // Skip this certificate
                continue;
            }
        }


        //
        // Assign the certificate to the current context.
        //

        Status = AssignNewClientCredential(pContext,
                                           pCertContext,
                                           FALSE);
        if(NT_SUCCESS(Status))
        {
            // Success! Our work here is done.
            goto cleanup;
        }
    }

    // No suitable client credential was found.
    Status = SP_LOG_RESULT(SEC_E_INCOMPLETE_CREDENTIALS);

cleanup:

    if(pChainContext)
    {
        CertFreeCertificateChain(pChainContext);
    }

    return Status;
}


NTSTATUS
AcquireDefaultClientCredential(
    PSPContext  pContext,
    BOOL        fCredManagerOnly)
{
    CERT_CHAIN_FIND_BY_ISSUER_PARA  FindByIssuerPara;
    CERT_NAME_BLOB *    prgIssuers = NULL;
    DWORD               cIssuers = 0;
    HCERTSTORE          hStore = 0;
    NTSTATUS            Status;
    BOOL                fImpersonating = FALSE;
    BOOL                fLocalSystem = FALSE;
    ULONG               i;

    DebugLog((DEB_TRACE,"AcquireDefaultClientCredential\n"));

    //
    // Is the application running under local system?
    //

    fImpersonating = SslImpersonateClient();

    if(fImpersonating)
    {
        Status = IsThreadLocalSystem(&fLocalSystem);
        if(Status)
        {
            DebugLog((DEB_WARN, "IsThreadLocalSystem returned error 0x%x.\n", Status));
        }

        RevertToSelf();
        fImpersonating = FALSE;
    }


    //
    // Ask the credential manager to select a certificate for us.
    //

    Status = QueryCredentialManagerForCert(
                                pContext,
                                pContext->pszTarget);

    if(NT_SUCCESS(Status))
    {
        DebugLog((DEB_TRACE, "Credential manager found a certificate for us.\n"));
        goto cleanup;
    }

    if(fCredManagerOnly)
    {
        // No suitable client credential was found.
        Status = SP_LOG_RESULT(SEC_I_INCOMPLETE_CREDENTIALS);
        goto cleanup;
    }


    //
    // Get list of trusted issuers as a list of CERT_NAME_BLOBs.
    //

    if(pContext->pbIssuerList && pContext->cbIssuerList > 2)
    {
        PBYTE pbIssuerList = pContext->pbIssuerList + 2;
        DWORD cbIssuerList = pContext->cbIssuerList - 2;
        PBYTE pbIssuer;

        // Count issuers.
        cIssuers = 0;
        pbIssuer = pbIssuerList;
        while(pbIssuer + 1 < pbIssuerList + cbIssuerList)
        {
            pbIssuer += 2 + COMBINEBYTES(pbIssuer[0], pbIssuer[1]);
            cIssuers++;
        }

        // Allocate memory for list of blobs.
        prgIssuers = SPExternalAlloc(cIssuers * sizeof(CERT_NAME_BLOB));
        if(prgIssuers == NULL)
        {
            Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        // Build the issuer blob list.
        pbIssuer = pbIssuerList;
        for(i = 0; i < cIssuers; i++)
        {
            prgIssuers[i].pbData = pbIssuer + 2;
            prgIssuers[i].cbData = COMBINEBYTES(pbIssuer[0], pbIssuer[1]);

            pbIssuer += 2 + prgIssuers[i].cbData;
        }
    }


    //
    // Enumerate the certificates in the MY store, looking for a suitable
    // client certificate. 
    //

    fImpersonating = SslImpersonateClient();

    if(fLocalSystem)
    {
        hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                               X509_ASN_ENCODING, 0,
                               CERT_SYSTEM_STORE_LOCAL_MACHINE  |
                               CERT_STORE_READONLY_FLAG         |
                               CERT_STORE_OPEN_EXISTING_FLAG,
                               L"MY");
    }
    else
    {
        hStore = CertOpenSystemStore(0, "MY");
    }

    if(!hStore)
    {
        SP_LOG_RESULT(GetLastError());
        Status = SEC_E_INTERNAL_ERROR;
        goto cleanup;
    }


    ZeroMemory(&FindByIssuerPara, sizeof(FindByIssuerPara));
    FindByIssuerPara.cbSize             = sizeof(FindByIssuerPara);
    FindByIssuerPara.pszUsageIdentifier = szOID_PKIX_KP_CLIENT_AUTH;
    FindByIssuerPara.dwKeySpec          = 0;
    FindByIssuerPara.cIssuer            = cIssuers;
    FindByIssuerPara.rgIssuer           = prgIssuers;


    //
    // Attempt to find a suitable certificate.
    //

    Status = FindClientCertificate(pContext,
                                   hStore,
                                   &FindByIssuerPara,
                                   TRUE,    // skip expired certs
                                   TRUE);   // software CSPs only

    if(NT_SUCCESS(Status))
    {
        // Success! Our work here is done.
        goto cleanup;
    }

    Status = FindClientCertificate(pContext,
                                   hStore,
                                   &FindByIssuerPara,
                                   TRUE,    // skip expired certs
                                   FALSE);  // software CSPs only

    if(NT_SUCCESS(Status))
    {
        // Success! Our work here is done.
        goto cleanup;
    }

    Status = FindClientCertificate(pContext,
                                   hStore,
                                   &FindByIssuerPara,
                                   FALSE,   // skip expired certs
                                   TRUE);   // software CSPs only

    if(NT_SUCCESS(Status))
    {
        // Success! Our work here is done.
        goto cleanup;
    }

    Status = FindClientCertificate(pContext,
                                   hStore,
                                   &FindByIssuerPara,
                                   FALSE,   // skip expired certs
                                   FALSE);  // software CSPs only

    if(NT_SUCCESS(Status))
    {
        // Success! Our work here is done.
        goto cleanup;
    }


    // No suitable client credential was found.
    Status = SP_LOG_RESULT(SEC_I_INCOMPLETE_CREDENTIALS);


cleanup:


    if(hStore)
    {
        CertCloseStore(hStore, 0);
    }

    if(fImpersonating)
    {
        RevertToSelf();
    }

    if(prgIssuers)
    {
        SPExternalFree(prgIssuers);
    }

    DebugLog((DEB_TRACE,"AcquireDefaultClientCredential returned 0x%x\n", Status));

    return Status;
}


NTSTATUS
FindDefaultMachineCred(
    PSPCredentialGroup *ppCred,
    DWORD dwProtocol)
{
    HTTPSPolicyCallbackData  polHttps;
    CERT_CHAIN_POLICY_PARA   PolicyPara;
    CERT_CHAIN_POLICY_STATUS PolicyStatus;
    CERT_CHAIN_PARA          ChainPara;
    PCCERT_CHAIN_CONTEXT     pChainContext = NULL;
    PCCERT_CONTEXT           pCertContext  = NULL;
    LSA_SCHANNEL_CRED        SchannelCred;
    LSA_SCHANNEL_SUB_CRED    SubCred;
    HCERTSTORE               hStore = 0;

    #define SERVER_USAGE_COUNT 3
    LPSTR               rgszUsages[SERVER_USAGE_COUNT] = {
                            szOID_PKIX_KP_SERVER_AUTH,
                            szOID_SERVER_GATED_CRYPTO,
                            szOID_SGC_NETSCAPE };

    LPWSTR  pwszMachineName = NULL;
    DWORD   cchMachineName;
    SP_STATUS Status;
    DWORD   i;

    // Get the machine name
    cchMachineName = 0;
    if(!GetComputerNameExW(ComputerNameDnsFullyQualified, NULL, &cchMachineName))
    {
        if(GetLastError() != ERROR_MORE_DATA)
        {
            DebugLog((DEB_ERROR,"Failed to get computer name size: 0x%x\n",GetLastError()));
            Status = SP_LOG_RESULT(SEC_E_WRONG_PRINCIPAL);
            goto cleanup;
        }
    }
    pwszMachineName = SPExternalAlloc(cchMachineName * sizeof(WCHAR));
    if(pwszMachineName == NULL)
    {
        Status = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }
    if(!GetComputerNameExW(ComputerNameDnsFullyQualified, pwszMachineName, &cchMachineName))
    {
        DebugLog((DEB_ERROR,"Failed to get computer name: 0x%x\n",GetLastError()));
        Status = SP_LOG_RESULT(SEC_E_WRONG_PRINCIPAL);
        goto cleanup;
    }

    // Remove the trailing "." if any. This can happen in the stand-alone
    // server case.
    cchMachineName = lstrlenW(pwszMachineName);
    if(cchMachineName > 0 && pwszMachineName[cchMachineName - 1] == L'.')
    {
        pwszMachineName[cchMachineName - 1] = L'\0';
    }


    DebugLog((DEB_TRACE,"Computer name: %ls\n",pwszMachineName));


    // Open the system MY store.
    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_W,
                           X509_ASN_ENCODING, 0,
                           CERT_SYSTEM_STORE_LOCAL_MACHINE  |
                           CERT_STORE_READONLY_FLAG         |
                           CERT_STORE_OPEN_EXISTING_FLAG,
                           L"MY");
    if(hStore == NULL)
    {
        SP_LOG_RESULT(GetLastError());
        Status = SEC_E_NO_CREDENTIALS;
        goto cleanup;
    }


    //
    // Enumerate the certificates in the MY store, looking for a suitable
    // server certificate. Do this twice, the first time looking for the
    // perfect certificate, and if this fails then look again, this time
    // being a little less picky.
    //

    for(i = 0; i < 2; i++)
    {
        pCertContext = NULL;

        while(TRUE)
        {
            // Get leaf certificate in the MY store.
            pCertContext = CertEnumCertificatesInStore(hStore, pCertContext);
            if(pCertContext == NULL)
            {
                // No more certificates.
                break;
            }

            //
            // Build a certificate chain from the leaf certificate.
            //

            ZeroMemory(&ChainPara, sizeof(ChainPara));
            ChainPara.cbSize = sizeof(ChainPara);
            ChainPara.RequestedUsage.dwType = USAGE_MATCH_TYPE_OR;
            ChainPara.RequestedUsage.Usage.cUsageIdentifier     = SERVER_USAGE_COUNT;
            ChainPara.RequestedUsage.Usage.rgpszUsageIdentifier = rgszUsages;

            if(!CertGetCertificateChain(
                                    NULL,
                                    pCertContext,
                                    NULL,
                                    0,
                                    &ChainPara,
                                    CERT_CHAIN_REVOCATION_CHECK_END_CERT,
                                    NULL,
                                    &pChainContext))
            {
                DebugLog((DEB_WARN, "Error 0x%x returned by CertGetCertificateChain!\n", GetLastError()));
                continue;
            }

            // Set up validate chain structures.
            ZeroMemory(&polHttps, sizeof(HTTPSPolicyCallbackData));
            polHttps.cbStruct           = sizeof(HTTPSPolicyCallbackData);
            polHttps.dwAuthType         = AUTHTYPE_SERVER;
            polHttps.fdwChecks          = 0;
            polHttps.pwszServerName     = pwszMachineName;

            ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
            PolicyStatus.cbSize         = sizeof(PolicyStatus);

            ZeroMemory(&PolicyPara, sizeof(PolicyPara));
            PolicyPara.cbSize           = sizeof(PolicyPara);
            PolicyPara.pvExtraPolicyPara= &polHttps;
            if(i == 0)
            {
                // Look for the perfect certificate.
                PolicyPara.dwFlags = 0;
            }
            else
            {
                // Ignore expiration.
                PolicyPara.dwFlags = CERT_CHAIN_POLICY_IGNORE_ALL_NOT_TIME_VALID_FLAGS;
            }

            // Validate chain
            if(!CertVerifyCertificateChainPolicy(
                                    CERT_CHAIN_POLICY_SSL,
                                    pChainContext,
                                    &PolicyPara,
                                    &PolicyStatus))
            {
                SP_LOG_RESULT(GetLastError());
                CertFreeCertificateChain(pChainContext);
                continue;
            }
            Status = MapWinTrustError(PolicyStatus.dwError,
                                      0,
                                      CRED_FLAG_IGNORE_NO_REVOCATION_CHECK | CRED_FLAG_IGNORE_REVOCATION_OFFLINE);
            if(Status)
            {
                // Certificate did not validate, move on to the next one.
                DebugLog((DEB_WARN, "Machine certificate failed validation with 0x%x\n", Status));
                CertFreeCertificateChain(pChainContext);
                continue;
            }

            CertFreeCertificateChain(pChainContext);


            // Build an schannel credential.
            ZeroMemory(&SchannelCred, sizeof(SchannelCred));

            SchannelCred.dwVersion = SCHANNEL_CRED_VERSION;
            SchannelCred.cSubCreds = 1;
            SchannelCred.paSubCred = &SubCred;

            ZeroMemory(&SubCred, sizeof(SubCred));

            SubCred.pCert = pCertContext;

            Status = SPCreateCredential(ppCred,
                                        dwProtocol,
                                        &SchannelCred);
            if(Status != PCT_ERR_OK)
            {
                // Don't use this certificate.
                continue;
            }

            // We have a winner!
            DebugLog((DEB_TRACE, "Machine certificate automatically acquired\n"));
            Status = PCT_ERR_OK;
            goto cleanup;
        }
    }

    // No suitable machine credential was found.
    Status = SP_LOG_RESULT(SEC_E_NO_CREDENTIALS);

cleanup:

    if(Status != PCT_ERR_OK)
    {
        LogNoDefaultServerCredEvent();
    }

    if(pwszMachineName)
    {
        SPExternalFree(pwszMachineName);
    }

    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }

    if(hStore)
    {
        CertCloseStore(hStore, 0);
    }

    return Status;
}


void
GetImplementationType(
    PCCERT_CONTEXT pCertContext,
    PDWORD pdwImpType)
{
    PCRYPT_KEY_PROV_INFO pProvInfo = NULL;
    HCRYPTPROV  hProv = 0;
    DWORD       cbSize;
    DWORD       dwImpType;

    *pdwImpType = CRYPT_IMPL_UNKNOWN;

    if(!CertGetCertificateContextProperty(pCertContext,
                                          CERT_KEY_PROV_INFO_PROP_ID,
                                          NULL,
                                          &cbSize))
    {
        goto cleanup;
    }

    pProvInfo = SPExternalAlloc(cbSize);
    if(pProvInfo == NULL)
    {
        goto cleanup;
    }

    if(!CertGetCertificateContextProperty(pCertContext,
                                          CERT_KEY_PROV_INFO_PROP_ID,
                                          pProvInfo,
                                          &cbSize))
    {
        goto cleanup;
    }

    // HACKHACK - clear the smart-card specific flag.
    pProvInfo->dwFlags &= ~CERT_SET_KEY_CONTEXT_PROP_ID;

    if(!CryptAcquireContextW(&hProv,
                             pProvInfo->pwszContainerName,
                             pProvInfo->pwszProvName,
                             pProvInfo->dwProvType,
                             pProvInfo->dwFlags | CRYPT_SILENT))
    {
        goto cleanup;
    }

    cbSize = sizeof(dwImpType);
    if(!CryptGetProvParam(hProv, 
                          PP_IMPTYPE,
                          (PBYTE)&dwImpType,
                          &cbSize,
                          0))
    {
        goto cleanup;
    }

    *pdwImpType = dwImpType;

cleanup:

    if(pProvInfo)
    {
        SPExternalFree(pProvInfo);
    }

    if(hProv)
    {
        CryptReleaseContext(hProv, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\keyxmspk.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       keyxmspk.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#include <spbase.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __cplusplus
}
#endif


// PROV_RSA_SCHANNEL handle used when building ClientHello messages.
HCRYPTPROV          g_hRsaSchannel      = 0;
PROV_ENUMALGS_EX *  g_pRsaSchannelAlgs  = NULL;
DWORD               g_cRsaSchannelAlgs  = 0;

SP_STATUS
Ssl3ParseServerKeyExchange(
    PSPContext  pContext,
    PBYTE       pbMessage,
    DWORD       cbMessage,
    HCRYPTKEY   hServerPublic,
    HCRYPTKEY  *phNewServerPublic);

SP_STATUS
PkcsFinishMasterKey(
    PSPContext  pContext,
    HCRYPTKEY   hMasterKey);

SP_STATUS
WINAPI
PkcsGenerateServerExchangeValue(
    SPContext     * pContext,               // in
    PUCHAR          pServerExchangeValue,   // out
    DWORD *         pcbServerExchangeValue  // in/out
);


SP_STATUS
WINAPI
PkcsGenerateClientExchangeValue(
    SPContext     * pContext,               // in
    PUCHAR          pServerExchangeValue,   // in
    DWORD           cbServerExchangeValue,  // in
    PUCHAR          pClientClearValue,      // out
    DWORD *         pcbClientClearValue,    // in/out
    PUCHAR          pClientExchangeValue,   // out
    DWORD *         pcbClientExchangeValue  // in/out
);

SP_STATUS
WINAPI
PkcsGenerateServerMasterKey(
    SPContext     * pContext,               // in
    PUCHAR          pClientClearValue,      // in
    DWORD           cbClientClearValue,     // in
    PUCHAR          pClientExchangeValue,   // in
    DWORD           cbClientExchangeValue   // in
);


KeyExchangeSystem keyexchPKCS = {
    SP_EXCH_RSA_PKCS1,
    "RSA",
//    PkcsPrivateFromBlob,
    PkcsGenerateServerExchangeValue,
    PkcsGenerateClientExchangeValue,
    PkcsGenerateServerMasterKey,
};



VOID
ReverseMemCopy(
    PUCHAR      Dest,
    PUCHAR      Source,
    ULONG       Size)
{
    PUCHAR  p;

    p = Dest + Size - 1;
    while(p >= Dest)
    {
        *p-- = *Source++;
    }
}

SP_STATUS
GenerateSsl3KeyPair(
    PSPContext  pContext,           // in
    DWORD       dwKeySize,          // in
    HCRYPTPROV *phEphemeralProv,    // out
    HCRYPTKEY * phEphemeralKey)     // out
{
    HCRYPTPROV *         phEphemProv;
    PCRYPT_KEY_PROV_INFO pProvInfo = NULL;
    PSPCredentialGroup   pCredGroup;
    PSPCredential        pCred;
    DWORD                cbSize;
    SP_STATUS            pctRet;

    pCredGroup = pContext->RipeZombie->pServerCred;
    if(pCredGroup == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    LockCredentialExclusive(pCredGroup);

    pCred = pContext->RipeZombie->pActiveServerCred;
    if(pCred == NULL)
    {
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto cleanup;
    }

    if(dwKeySize == 512)
    {
        phEphemProv = &pCred->hEphem512Prov;
    } 
    else if(dwKeySize == 1024)
    {
        phEphemProv = &pCred->hEphem1024Prov;
    }
    else
    {
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto cleanup;
    }


    //
    // Obtain CSP context.
    //

    if(*phEphemProv == 0)
    {
        // Read the certificate context's "key info" property.
        if(CertGetCertificateContextProperty(pCred->pCert,
                                             CERT_KEY_PROV_INFO_PROP_ID,
                                             NULL,
                                             &cbSize))
        {
            SafeAllocaAllocate(pProvInfo, cbSize);
            if(pProvInfo == NULL)
            {
                pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                goto cleanup;
            }

            if(!CertGetCertificateContextProperty(pCred->pCert,
                                                  CERT_KEY_PROV_INFO_PROP_ID,
                                                  pProvInfo,
                                                  &cbSize))
            {
                DebugLog((SP_LOG_ERROR, "Error 0x%x reading CERT_KEY_PROV_INFO_PROP_ID\n",GetLastError()));
                SafeAllocaFree(pProvInfo);
                pProvInfo = NULL;
            }
        }

        // Obtain a "verify only" csp context.
        if(pProvInfo)
        {
            // If the private key belongs to one of the Microsoft PROV_RSA_FULL
            // CSPs, then manually divert it to the Microsoft PROV_RSA_SCHANNEL
            // CSP. This works because both CSP types use the same private key
            // storage scheme.
            if(pProvInfo->dwProvType == PROV_RSA_FULL)
            {
                if(lstrcmpW(pProvInfo->pwszProvName, MS_DEF_PROV_W) == 0 ||
                   lstrcmpW(pProvInfo->pwszProvName, MS_STRONG_PROV_W) == 0 ||
                   lstrcmpW(pProvInfo->pwszProvName, MS_ENHANCED_PROV_W) == 0)
                {
                    DebugLog((DEB_WARN, "Force CSP type to PROV_RSA_SCHANNEL.\n"));
                    pProvInfo->pwszProvName = MS_DEF_RSA_SCHANNEL_PROV_W;
                    pProvInfo->dwProvType   = PROV_RSA_SCHANNEL;
                }
            }

            if(!CryptAcquireContextW(phEphemProv,
                                     NULL,
                                     pProvInfo->pwszProvName,
                                     pProvInfo->dwProvType,
                                     CRYPT_VERIFYCONTEXT))
            {
                SP_LOG_RESULT(GetLastError());
                pctRet = SEC_E_NO_CREDENTIALS;
                goto cleanup;
            }

            SafeAllocaFree(pProvInfo);
            pProvInfo = NULL;
        }
        else
        {
            if(!CryptAcquireContextW(phEphemProv,
                                     NULL,
                                     NULL,
                                     PROV_RSA_SCHANNEL,
                                     CRYPT_VERIFYCONTEXT))
            {
                SP_LOG_RESULT(GetLastError());
                pctRet = SEC_E_NO_CREDENTIALS;
                goto cleanup;
            }
        }
    }

    
    // 
    // Obtain handle to private key.
    //

    if(!CryptGetUserKey(*phEphemProv,
                        AT_KEYEXCHANGE,
                        phEphemeralKey))
    {
        // Key does not exist, so attempt to create one.
        DebugLog((DEB_TRACE, "Creating %d-bit ephemeral key.\n", dwKeySize));
        if(!CryptGenKey(*phEphemProv,
                        AT_KEYEXCHANGE,
                        (dwKeySize << 16),
                        phEphemeralKey))
        {
            DebugLog((DEB_ERROR, "Error 0x%x generating ephemeral key\n", GetLastError()));
            pctRet = SEC_E_NO_CREDENTIALS;
            goto cleanup;
        }
        DebugLog((DEB_TRACE, "Ephemeral key created okay.\n"));
    }


    *phEphemeralProv = *phEphemProv;

    pctRet = PCT_ERR_OK;

cleanup:

    if(pProvInfo)
    {
        SafeAllocaFree(pProvInfo);
    }

    UnlockCredential(pCredGroup);

    return pctRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   PkcsGenerateServerExchangeValue
//
//  Synopsis:   Create a ServerKeyExchange message, containing an ephemeral
//              RSA key.
//
//  Arguments:  [pContext]                  --  Schannel context.
//              [pServerExchangeValue]      --
//              [pcbServerExchangeValue]    --
//
//  History:    10-09-97   jbanes   Added CAPI integration.
//
//  Notes:      This routine is called by the server-side only.
//
//              In the case of SSL3 or TLS, the ServerKeyExchange message
//              consists of the following structure, signed with the
//              server's private key.
//
//                  struct {
//                      opaque rsa_modulus<1..2^16-1>;
//                      opaque rsa_exponent<1..2^16-1>;
//                  } Server RSA Params;
//
//              This message is only sent when the server's private key
//              is greater then 512 bits and an export cipher suite is
//              being negotiated.
//
//----------------------------------------------------------------------------
SP_STATUS
WINAPI
PkcsGenerateServerExchangeValue(
    PSPContext  pContext,                   // in
    PBYTE       pServerExchangeValue,       // out
    DWORD *     pcbServerExchangeValue)     // in/out
{
    PSPCredential   pCred;
    HCRYPTKEY       hServerKey;
    HCRYPTPROV      hEphemeralProv;
    HCRYPTKEY       hEphemeralKey;
    DWORD           cbData;
    DWORD           cbServerModulus;
    PBYTE           pbBlob = NULL;
    DWORD           cbBlob;
    BLOBHEADER *    pBlobHeader = NULL;
    RSAPUBKEY *     pRsaPubKey = NULL;
    PBYTE           pbModulus = NULL;
    DWORD           cbModulus;
    DWORD           cbExp;
    PBYTE           pbMessage = NULL;
    DWORD           cbSignature;
    HCRYPTHASH      hHash;
    BYTE            rgbHashValue[CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN];
    UINT            i;
    SP_STATUS       pctRet;
    BOOL            fImpersonating = FALSE;
    UNICipherMap *  pCipherSuite;
    DWORD           cbAllowedKeySize;

    pCred = pContext->RipeZombie->pActiveServerCred;
    if(pCred == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    pContext->fExchKey = FALSE;

    if(pContext->RipeZombie->fProtocol == SP_PROT_SSL2_SERVER ||
       pContext->RipeZombie->fProtocol == SP_PROT_PCT1_SERVER)
    {
        // There is no ServerExchangeValue for SSL2 or PCT1
        *pcbServerExchangeValue = 0;
        return PCT_ERR_OK;
    }

    if(pContext->RipeZombie->fProtocol != SP_PROT_SSL3_SERVER &&
       pContext->RipeZombie->fProtocol != SP_PROT_TLS1_SERVER)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }


    //
    // Determine if ServerKeyExchange message is necessary.
    //

    pCipherSuite = &UniAvailableCiphers[pContext->dwPendingCipherSuiteIndex];

    if(pCipherSuite->dwFlags & DOMESTIC_CIPHER_SUITE)
    {
        // Message not necessary.
        *pcbServerExchangeValue = 0;
        return PCT_ERR_OK;
    }

    if(pCred->hProv == 0)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }


    fImpersonating = SslImpersonateClient();

    if(!CryptGetUserKey(pCred->hProv,
                        pCred->dwKeySpec,
                        &hServerKey))
    {
        DebugLog((DEB_ERROR, "Error 0x%x obtaining handle to server public key\n",
            GetLastError()));
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    cbData = sizeof(DWORD);
    if(!CryptGetKeyParam(hServerKey,
                         KP_BLOCKLEN,
                         (PBYTE)&cbServerModulus,
                         &cbData,
                         0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyKey(hServerKey);
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    CryptDestroyKey(hServerKey);

    if(pCipherSuite->dwFlags & EXPORT56_CIPHER_SUITE)
    {
        cbAllowedKeySize = 1024;
    } 
    else
    {
        cbAllowedKeySize = 512;
    }

    if(cbServerModulus <= cbAllowedKeySize)
    {
        // Message not necessary.
        *pcbServerExchangeValue = 0;
        pctRet = PCT_ERR_OK;
        goto cleanup;
    }

    // Convert size from bits to bytes.
    cbServerModulus /= 8;

    pContext->fExchKey = TRUE;

    if(fImpersonating)
    {
        RevertToSelf();
        fImpersonating = FALSE;
    }

    //
    // Compute approximate size of ServerKeyExchange message.
    //

    if(pServerExchangeValue == NULL)
    {
        *pcbServerExchangeValue = 
                    2 + cbAllowedKeySize / 8 +      // modulus
                    2 + sizeof(DWORD) +             // exponent
                    2 + cbServerModulus;            // signature

        pctRet = PCT_ERR_OK;
        goto cleanup;
    }


    //
    // Get handle to 512-bit ephemeral RSA key. Generate it if
    // we haven't already.
    //

    pctRet = GenerateSsl3KeyPair(pContext,
                                 cbAllowedKeySize,
                                 &hEphemeralProv,
                                 &hEphemeralKey);
    if(pctRet != PCT_ERR_OK)
    {
        SP_LOG_RESULT(pctRet);
        goto cleanup;
    }


    //
    // Export ephemeral key.
    //

    if(!CryptExportKey(hEphemeralKey,
                       0,
                       PUBLICKEYBLOB,
                       0,
                       NULL,
                       &cbBlob))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    SafeAllocaAllocate(pbBlob, cbBlob);
    if(pbBlob == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }
    if(!CryptExportKey(hEphemeralKey,
                       0,
                       PUBLICKEYBLOB,
                       0,
                       pbBlob,
                       &cbBlob))
    {
        SP_LOG_RESULT(GetLastError());
        SafeAllocaFree(pbBlob);
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    // 
    // Destroy handle to ephemeral key. Don't release the ephemeral hProv
    // though--that's owned by the credential.
    CryptDestroyKey(hEphemeralKey);


    //
    // Build message from key blob.
    //

    pBlobHeader = (BLOBHEADER *)pbBlob;
    pRsaPubKey  = (RSAPUBKEY *)(pBlobHeader + 1);
    pbModulus   = (BYTE *)(pRsaPubKey + 1);
    cbModulus   = pRsaPubKey->bitlen / 8;

    pbMessage   = pServerExchangeValue;

    pbMessage[0] = MSBOF(cbModulus);
    pbMessage[1] = LSBOF(cbModulus);
    pbMessage += 2;
    ReverseMemCopy(pbMessage, pbModulus, cbModulus);
    pbMessage += cbModulus;

    // Don't laugh, this works  - pete
    cbExp = ((pRsaPubKey->pubexp & 0xff000000) ? 4 :
            ((pRsaPubKey->pubexp & 0x00ff0000) ? 3 :
            ((pRsaPubKey->pubexp & 0x0000ff00) ? 2 : 1)));
    pbMessage[0] = MSBOF(cbExp);
    pbMessage[1] = LSBOF(cbExp);
    pbMessage += 2;
    ReverseMemCopy(pbMessage, (PBYTE)&pRsaPubKey->pubexp, cbExp);
    pbMessage += cbExp;

    SafeAllocaFree(pbBlob);
    pbBlob = NULL;

    fImpersonating = SslImpersonateClient();

    // Generate hash values
    ComputeServerExchangeHashes(
                pContext,
                pServerExchangeValue,
                (int)(pbMessage - pServerExchangeValue),
                rgbHashValue,
                rgbHashValue + CB_MD5_DIGEST_LEN);

    // Sign hash value.
    if(!CryptCreateHash(pCred->hProv,
                        CALG_SSL3_SHAMD5,
                        0,
                        0,
                        &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!CryptSetHashParam(hHash,
                          HP_HASHVAL,
                          rgbHashValue,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    DebugLog((DEB_TRACE, "Signing server_key_exchange message.\n"));
    cbSignature = cbServerModulus;
    if(!CryptSignHash(hHash,
                      pCred->dwKeySpec,
                      NULL,
                      0,
                      pbMessage + 2,
                      &cbSignature))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    DebugLog((DEB_TRACE, "Server_key_exchange message signed successfully.\n"));
    CryptDestroyHash(hHash);

    pbMessage[0] = MSBOF(cbSignature);
    pbMessage[1] = LSBOF(cbSignature);
    pbMessage += 2;

    // Reverse signature.
    for(i = 0; i < cbSignature / 2; i++)
    {
        BYTE n = pbMessage[i];
        pbMessage[i] = pbMessage[cbSignature - i -1];
        pbMessage[cbSignature - i -1] = n;
    }
    pbMessage += cbSignature;

    *pcbServerExchangeValue = (DWORD)(pbMessage - pServerExchangeValue);

    // Use ephemeral key for the new connection.
    pContext->RipeZombie->hMasterProv = hEphemeralProv;
    pContext->RipeZombie->dwFlags |= SP_CACHE_FLAG_MASTER_EPHEM;

    pctRet = PCT_ERR_OK;

cleanup:

    if(fImpersonating)
    {
        RevertToSelf();
    }

    return pctRet;
}


SP_STATUS
WINAPI
PkcsGenerateClientExchangeValue(
    SPContext     * pContext,               // in
    PUCHAR          pServerExchangeValue,   // in
    DWORD           cbServerExchangeValue,  // in
    PUCHAR          pClientClearValue,      // out
    DWORD *         pcbClientClearValue,    // in/out
    PUCHAR          pClientExchangeValue,   // out
    DWORD *         pcbClientExchangeValue) // in/out
{
    PSPCredentialGroup pCred;
    DWORD cbSecret;
    DWORD cbMasterKey;
    HCRYPTKEY hServerPublic = 0;
    DWORD dwGenFlags = 0;
    DWORD dwExportFlags = 0;
    SP_STATUS pctRet = PCT_ERR_OK;
    BLOBHEADER *pPublicBlob;
    DWORD cbPublicBlob;
    DWORD cbHeader;
    ALG_ID Algid = 0;
    DWORD cbData;
    DWORD cbEncryptedKey;
    DWORD dwEnabledProtocols;
    DWORD dwHighestProtocol;

    if(pContext->RipeZombie->hMasterProv == 0)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    pCred = pContext->pCredGroup;
    if(pCred == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // We're doing a full handshake.
    pContext->Flags |= CONTEXT_FLAG_FULL_HANDSHAKE;

    //
    // Determine highest supported protocol.
    //

    dwEnabledProtocols = pContext->dwClientEnabledProtocols;

    if(dwEnabledProtocols & SP_PROT_TLS1_CLIENT)
    {
        dwHighestProtocol = TLS1_CLIENT_VERSION;
    }
    else if(dwEnabledProtocols & SP_PROT_SSL3_CLIENT)
    {
        dwHighestProtocol = SSL3_CLIENT_VERSION;
    }
    else 
    {
        dwHighestProtocol = SSL2_CLIENT_VERSION;
    }

    // Get key length.
    cbSecret = pContext->pPendingCipherInfo->cbSecret;


    //
    // Import server's public key.
    //

    pPublicBlob  = pContext->RipeZombie->pRemotePublic->pPublic;
    cbPublicBlob = pContext->RipeZombie->pRemotePublic->cbPublic;

    cbEncryptedKey = sizeof(BLOBHEADER) + sizeof(ALG_ID) + cbPublicBlob;

    if(pClientExchangeValue == NULL)
    {
        *pcbClientExchangeValue = cbEncryptedKey;
        pctRet = PCT_ERR_OK;
        goto done;
    }

    if(*pcbClientExchangeValue < cbEncryptedKey)
    {
        *pcbClientExchangeValue = cbEncryptedKey;
        pctRet = SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        goto done;
    }

    if(!CryptImportKey(pContext->RipeZombie->hMasterProv,
                       (PBYTE)pPublicBlob,
                       cbPublicBlob,
                       0,
                       0,
                       &hServerPublic))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto done;
    }


    //
    // Do protocol specific stuff.
    //

    switch(pContext->RipeZombie->fProtocol)
    {
        case SP_PROT_PCT1_CLIENT:
            Algid       = CALG_PCT1_MASTER;
            dwGenFlags  = CRYPT_EXPORTABLE;

            // Generate the clear key value.
            if(cbSecret < PCT1_MASTER_KEY_SIZE)
            {
                pContext->RipeZombie->cbClearKey = PCT1_MASTER_KEY_SIZE - cbSecret;
                pctRet = GenerateRandomBits(pContext->RipeZombie->pClearKey,
                                            pContext->RipeZombie->cbClearKey);
                if(!NT_SUCCESS(pctRet))
                {
                    goto done;
                }

                *pcbClientClearValue = pContext->RipeZombie->cbClearKey;
                CopyMemory( pClientClearValue,
                            pContext->RipeZombie->pClearKey,
                            pContext->RipeZombie->cbClearKey);
            }
            else
            {
                *pcbClientClearValue = pContext->RipeZombie->cbClearKey = 0;
            }

            break;

        case SP_PROT_SSL2_CLIENT:
            Algid       = CALG_SSL2_MASTER;
            dwGenFlags  = CRYPT_EXPORTABLE;

            cbMasterKey = pContext->pPendingCipherInfo->cbKey;

            dwGenFlags |= ((cbSecret << 3) << 16);

            // Generate the clear key value.
            pContext->RipeZombie->cbClearKey = cbMasterKey - cbSecret;

            if(pContext->RipeZombie->cbClearKey > 0)
            {
                pctRet = GenerateRandomBits(pContext->RipeZombie->pClearKey,
                                            pContext->RipeZombie->cbClearKey);
                if(!NT_SUCCESS(pctRet))
                {
                    goto done;
                }

                CopyMemory(pClientClearValue,
                           pContext->RipeZombie->pClearKey,
                           pContext->RipeZombie->cbClearKey);
            }
            *pcbClientClearValue = pContext->RipeZombie->cbClearKey;

            if(dwEnabledProtocols & (SP_PROT_SSL3 | SP_PROT_TLS1))
            {
                // If we're a client doing SSL2, and
                // SSL3 is enabled, then for some reason
                // the server requested SSL2.  Maybe
                // A man in the middle changed the server
                // version in the server hello to roll
                // back.  Pad with 8 0x03's so the server
                // can detect this.
                dwExportFlags = CRYPT_SSL2_FALLBACK;
            }

            break;

        case SP_PROT_TLS1_CLIENT:
            Algid = CALG_TLS1_MASTER;

            // drop through to SSL3

        case SP_PROT_SSL3_CLIENT:

            dwGenFlags  = CRYPT_EXPORTABLE;
            if(0 == Algid)
            {
                Algid = CALG_SSL3_MASTER;
            }

            // Generate the clear key value (always empty).
            pContext->RipeZombie->cbClearKey = 0;
            if(pcbClientClearValue) *pcbClientClearValue = 0;

            if(cbServerExchangeValue && pServerExchangeValue)
            {
                // In ssl3, we look at the server exchange value.
                // It may be a 512-bit public key, signed
                // by the server public key. In this case, we need to
                // use that as our master_secret encryption key.
                HCRYPTKEY hNewServerPublic;

                pctRet = Ssl3ParseServerKeyExchange(pContext,
                                                    pServerExchangeValue,
                                                    cbServerExchangeValue,
                                                    hServerPublic,
                                                    &hNewServerPublic);
                if(pctRet != PCT_ERR_OK)
                {
                    goto done;
                }

                // Destroy public key from certificate.
                CryptDestroyKey(hServerPublic);

                // Use public key from ServerKeyExchange instead.
                hServerPublic = hNewServerPublic;
            }

            break;

        default:
            return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // Generate the master_secret.
    if(!CryptGenKey(pContext->RipeZombie->hMasterProv,
                    Algid,
                    dwGenFlags,
                    &pContext->RipeZombie->hMasterKey))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto done;
    }

#if 1 
    // This is currently commented out because when connecting to a server running
    // an old version of schannel (NT4 SP3 or so), then we will connect using SSL3,
    // but the highest supported protocol is 0x0301. This confuses the server and
    // it drops the connection. 
    
    // Set highest supported protocol. The CSP will place this version number
    // in the pre_master_secret.
    if(!CryptSetKeyParam(pContext->RipeZombie->hMasterKey, 
                         KP_HIGHEST_VERSION, 
                         (PBYTE)&dwHighestProtocol, 
                         0))
    {
        SP_LOG_RESULT(GetLastError());
    }
#endif


    // Encrypt the master_secret.
    DebugLog((DEB_TRACE, "Encrypt the master secret.\n"));
    if(!CryptExportKey(pContext->RipeZombie->hMasterKey,
                       hServerPublic,
                       SIMPLEBLOB,
                       dwExportFlags,
                       pClientExchangeValue,
                       &cbEncryptedKey))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto done;
    }
    DebugLog((DEB_TRACE, "Master secret encrypted successfully.\n"));

    // Determine size of key exchange key.
    cbData = sizeof(DWORD);
    if(!CryptGetKeyParam(hServerPublic,
                         KP_BLOCKLEN,
                         (PBYTE)&pContext->RipeZombie->dwExchStrength,
                         &cbData,
                         0))
    {
        SP_LOG_RESULT(GetLastError());
        pContext->RipeZombie->dwExchStrength = 0;
    }


    // Strip off the blob header and copy the encrypted master_secret
    // to the output buffer. Note that it is also converted to big endian.
    cbHeader = sizeof(BLOBHEADER) + sizeof(ALG_ID);
    cbEncryptedKey -= cbHeader;
    if(pContext->RipeZombie->fProtocol == SP_PROT_TLS1_CLIENT)
    {
        MoveMemory(pClientExchangeValue + 2, pClientExchangeValue + cbHeader, cbEncryptedKey);
        ReverseInPlace(pClientExchangeValue + 2, cbEncryptedKey);

        pClientExchangeValue[0] = MSBOF(cbEncryptedKey);
        pClientExchangeValue[1] = LSBOF(cbEncryptedKey);

        *pcbClientExchangeValue = 2 + cbEncryptedKey;
    }
    else
    {
        MoveMemory(pClientExchangeValue, pClientExchangeValue + cbHeader, cbEncryptedKey);
        ReverseInPlace(pClientExchangeValue, cbEncryptedKey);

        *pcbClientExchangeValue = cbEncryptedKey;
    }

    // Build the session keys.
    pctRet = MakeSessionKeys(pContext,
                             pContext->RipeZombie->hMasterProv,
                             pContext->RipeZombie->hMasterKey);
    if(pctRet != PCT_ERR_OK)
    {
        goto done;
    }

    // Update perf counter.
    InterlockedIncrement(&g_cClientHandshakes);

    pctRet = PCT_ERR_OK;

done:
    if(hServerPublic) CryptDestroyKey(hServerPublic);

    return pctRet;
}


SP_STATUS
GenerateRandomMasterKey(
    PSPContext      pContext,
    HCRYPTKEY *     phMasterKey)
{
    DWORD dwGenFlags = 0;
    ALG_ID Algid = 0;
    DWORD cbSecret;

    cbSecret = pContext->pPendingCipherInfo->cbSecret;

    switch(pContext->RipeZombie->fProtocol)
    {
        case SP_PROT_PCT1_SERVER:
            Algid       = CALG_PCT1_MASTER;
            dwGenFlags  = CRYPT_EXPORTABLE;
            break;

        case SP_PROT_SSL2_SERVER:
            Algid       = CALG_SSL2_MASTER;
            dwGenFlags  = CRYPT_EXPORTABLE;
            dwGenFlags |= ((cbSecret << 3) << 16);
            break;

        case SP_PROT_TLS1_SERVER:
            Algid = CALG_TLS1_MASTER;
            dwGenFlags  = CRYPT_EXPORTABLE;
            break;

        case SP_PROT_SSL3_SERVER:
            Algid = CALG_SSL3_MASTER;
            dwGenFlags  = CRYPT_EXPORTABLE;
            break;

        default:
            return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // Generate the master_secret.
    if(!CryptGenKey(pContext->RipeZombie->hMasterProv,
                    Algid,
                    dwGenFlags,
                    phMasterKey))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }

    return PCT_ERR_OK;
}



//+---------------------------------------------------------------------------
//
//  Function:   PkcsGenerateServerMasterKey
//
//  Synopsis:   Decrypt the master secret (from the ClientKeyExchange message)
//              and derive the session keys from it.
//
//  Arguments:  [pContext]              --  Schannel context.
//              [pClientClearValue]     --  Not used.
//              [cbClientClearValue]    --  Not used.
//              [pClientExchangeValue]  --  Pointer PKCS #2 block.
//              [cbClientExchangeValue] --  Length of block.
//
//  History:    10-02-97   jbanes   Created.
//
//  Notes:      This routine is called by the server-side only.
//
//----------------------------------------------------------------------------
SP_STATUS
WINAPI
PkcsGenerateServerMasterKey(
    PSPContext  pContext,               // in, out
    PUCHAR      pClientClearValue,      // in
    DWORD       cbClientClearValue,     // in
    PUCHAR      pClientExchangeValue,   // in
    DWORD       cbClientExchangeValue)  // in
{
    PSPCredentialGroup pCred;
    PBYTE       pbBlob = NULL;
    DWORD       cbBlob;
    ALG_ID      Algid;
    HCRYPTKEY   hMasterKey;
    HCRYPTKEY   hExchKey = 0;
    DWORD       dwFlags = 0;
    SP_STATUS   pctRet;
    DWORD       cbData;
    DWORD       dwEnabledProtocols;
    DWORD       dwHighestProtocol;
    BOOL        fImpersonating = FALSE;
    DWORD       cbExpectedLength;

    pCred = pContext->RipeZombie->pServerCred;
    if(pCred == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    dwEnabledProtocols = (g_ProtEnabled & pCred->grbitEnabledProtocols);

    if(dwEnabledProtocols & SP_PROT_TLS1_SERVER)
    {
        dwHighestProtocol = TLS1_CLIENT_VERSION;
    }
    else if(dwEnabledProtocols & SP_PROT_SSL3_SERVER)
    {
        dwHighestProtocol = SSL3_CLIENT_VERSION;
    }
    else 
    {
        dwHighestProtocol = SSL2_CLIENT_VERSION;
    }

    // We're doing a full handshake.
    pContext->Flags |= CONTEXT_FLAG_FULL_HANDSHAKE;

    // Determine encryption algid
    switch(pContext->RipeZombie->fProtocol)
    {
        case SP_PROT_PCT1_SERVER:
            Algid = CALG_PCT1_MASTER;

            if(cbClientClearValue > sizeof(pContext->RipeZombie->pClearKey))
            {
                return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
            }
            CopyMemory(pContext->RipeZombie->pClearKey,
                   pClientClearValue,
                   cbClientClearValue);
            pContext->RipeZombie->cbClearKey = cbClientClearValue;

            break;

        case SP_PROT_SSL2_SERVER:
            Algid = CALG_SSL2_MASTER;

            if(dwEnabledProtocols & (SP_PROT_SSL3 | SP_PROT_TLS1))
            {
                // We're a server doing SSL2, and we also support SSL3.
                // If the encryption block contains the 8 0x03 padding
                // bytes, then abort the connection.
                dwFlags = CRYPT_SSL2_FALLBACK;
            }

            if(cbClientClearValue > sizeof(pContext->RipeZombie->pClearKey))
            {
                return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
            }
            CopyMemory(pContext->RipeZombie->pClearKey,
                   pClientClearValue,
                   cbClientClearValue);
            pContext->RipeZombie->cbClearKey = cbClientClearValue;

            break;

        case SP_PROT_SSL3_SERVER:
            Algid = CALG_SSL3_MASTER;
            break;

        case SP_PROT_TLS1_SERVER:
            Algid = CALG_TLS1_MASTER;
            break;

        default:
            return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // Get handle to key exchange key.
    if(!CryptGetUserKey(pContext->RipeZombie->hMasterProv,
                        AT_KEYEXCHANGE,
                        &hExchKey))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    // Determine size of key exchange key.
    cbData = sizeof(DWORD);
    if(!CryptGetKeyParam(hExchKey,
                         KP_BLOCKLEN,
                         (PBYTE)&pContext->RipeZombie->dwExchStrength,
                         &cbData,
                         0))
    {
        SP_LOG_RESULT(GetLastError());
        pContext->RipeZombie->dwExchStrength = 0;
    }
    cbExpectedLength = (pContext->RipeZombie->dwExchStrength + 7) / 8;

    if(cbClientExchangeValue < 2)
    {
        pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        goto cleanup;
    }

    // Remove (pseudo-optional) vector in front of the encrypted master key.
    if(pContext->RipeZombie->fProtocol == SP_PROT_SSL3_SERVER ||
       pContext->RipeZombie->fProtocol == SP_PROT_TLS1_SERVER)
    {
        DWORD cbMsg = MAKEWORD(pClientExchangeValue[1], pClientExchangeValue[0]);

        if((cbMsg == cbExpectedLength) && (cbMsg + 2 == cbClientExchangeValue))
        {
            pClientExchangeValue += 2;
            cbClientExchangeValue -= 2;
        }
    }

    if(cbClientExchangeValue < cbExpectedLength)
    {
        pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        goto cleanup;
    }

    // Allocate memory for blob.
    cbBlob = sizeof(BLOBHEADER) + sizeof(ALG_ID) + cbClientExchangeValue;
    SafeAllocaAllocate(pbBlob, cbBlob);
    if(pbBlob == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }


    // Build SIMPLEBLOB.
    {
        BLOBHEADER *pBlobHeader = (BLOBHEADER *)pbBlob;
        ALG_ID     *pAlgid      = (ALG_ID *)(pBlobHeader + 1);
        BYTE       *pData       = (BYTE *)(pAlgid + 1);

        pBlobHeader->bType      = SIMPLEBLOB;
        pBlobHeader->bVersion   = CUR_BLOB_VERSION;
        pBlobHeader->reserved   = 0;
        pBlobHeader->aiKeyAlg   = Algid;

        *pAlgid = CALG_RSA_KEYX;
        ReverseMemCopy(pData, pClientExchangeValue, cbClientExchangeValue);
    }

    DebugLog((DEB_TRACE, "Decrypt the master secret.\n"));

    if(!(pContext->RipeZombie->dwFlags & SP_CACHE_FLAG_MASTER_EPHEM))
    {
        fImpersonating = SslImpersonateClient();
    }

    // Decrypt the master_secret.
    if(!CryptImportKey(pContext->RipeZombie->hMasterProv,
                       pbBlob,
                       cbBlob,
                       hExchKey,
                       dwFlags,
                       &hMasterKey))
    {
        SP_LOG_RESULT(GetLastError());
        DebugLog((DEB_TRACE, "Master secret did not decrypt correctly.\n"));

        // Guard against the PKCS#1 attack by generating a 
        // random master key.
        pctRet = GenerateRandomMasterKey(pContext, &hMasterKey);
        if(pctRet != PCT_ERR_OK)
        {
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
    }
    else
    {
        DebugLog((DEB_TRACE, "Master secret decrypted successfully.\n"));

        // Set highest supported protocol. The CSP will use this to check for
        // version fallback attacks.
        if(!CryptSetKeyParam(hMasterKey, 
                             KP_HIGHEST_VERSION, 
                             (PBYTE)&dwHighestProtocol, 
                             CRYPT_SERVER))
        {
            SP_LOG_RESULT(GetLastError());

            if(GetLastError() == NTE_BAD_VER)
            {
                pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
                CryptDestroyKey(hMasterKey);
                goto cleanup;
            }
        }
    }

    pContext->RipeZombie->hMasterKey = hMasterKey;

    CryptDestroyKey(hExchKey);
    hExchKey = 0;

    // Build the session keys.
    pctRet = MakeSessionKeys(pContext,
                             pContext->RipeZombie->hMasterProv,
                             hMasterKey);
    if(pctRet != PCT_ERR_OK)
    {
        SP_LOG_RESULT(pctRet);
        goto cleanup;
    }

    // Update perf counter.
    InterlockedIncrement(&g_cServerHandshakes);

    pctRet = PCT_ERR_OK;

cleanup:

    if(fImpersonating)
    {
        RevertToSelf();
    }

    if(pbBlob != NULL)
    {
        SafeAllocaFree(pbBlob);
    }

    if(hExchKey)
    {
        CryptDestroyKey(hExchKey);
    }

    return pctRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   PkcsFinishMasterKey
//
//  Synopsis:   Complete the derivation of the master key by programming the
//              CSP with the (protocol dependent) auxilary plaintext
//              information.
//
//  Arguments:  [pContext]              --  Schannel context.
//              [hMasterKey]            --  Handle to master key.
//
//  History:    10-03-97   jbanes   Created.
//
//  Notes:      This routine is called by the server-side only.
//
//----------------------------------------------------------------------------
SP_STATUS
PkcsFinishMasterKey(
    PSPContext  pContext,       // in, out
    HCRYPTKEY   hMasterKey)     // in
{
    PCipherInfo  pCipherInfo = NULL;
    PHashInfo    pHashInfo   = NULL;
    SCHANNEL_ALG Algorithm;
    BOOL         fExportable = TRUE;
    DWORD        dwCipherFlags;

    if(pContext->RipeZombie->hMasterProv == 0)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // Get pointer to pending cipher system.
    pCipherInfo = pContext->pPendingCipherInfo;

    // Get pointer to pending hash system.
    pHashInfo = pContext->pPendingHashInfo;

    // Determine whether this is an "exportable" cipher.
    if(pContext->dwPendingCipherSuiteIndex)
    {
        // Use cipher suite flags (SSL3 & TLS).
        dwCipherFlags = UniAvailableCiphers[pContext->dwPendingCipherSuiteIndex].dwFlags;

        if(dwCipherFlags & DOMESTIC_CIPHER_SUITE)
        {
            fExportable = FALSE;
        }
    }
    else
    {
        // Use key length (PCT & SSL2).
        if(pCipherInfo->dwStrength > 40)
        {
            fExportable = FALSE;
        }
    }


    // Specify encryption algorithm.
    if(pCipherInfo->aiCipher != CALG_NULLCIPHER)
    {
        ZeroMemory(&Algorithm, sizeof(Algorithm));
        Algorithm.dwUse = SCHANNEL_ENC_KEY;
        Algorithm.Algid = pCipherInfo->aiCipher;
        Algorithm.cBits = pCipherInfo->cbSecret * 8;
        if(fExportable)
        {
            Algorithm.dwFlags = INTERNATIONAL_USAGE;
        }
        if(!CryptSetKeyParam(hMasterKey,
                             KP_SCHANNEL_ALG,
                             (PBYTE)&Algorithm,
                             0))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_INT_INTERNAL_ERROR;
        }
    }

    // Specify hash algorithm.
    Algorithm.dwUse = SCHANNEL_MAC_KEY;
    Algorithm.Algid = pHashInfo->aiHash;
    Algorithm.cBits = pHashInfo->cbCheckSum * 8;
    if(!CryptSetKeyParam(hMasterKey,
                         KP_SCHANNEL_ALG,
                         (PBYTE)&Algorithm,
                         0))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }

    // Finish creating the master_secret.
    switch(pContext->RipeZombie->fProtocol)
    {
        case SP_PROT_PCT1_CLIENT:
        case SP_PROT_PCT1_SERVER:
        {
            CRYPT_DATA_BLOB Data;

            // Specify clear key value.
            if(pContext->RipeZombie->cbClearKey)
            {
                Data.pbData = pContext->RipeZombie->pClearKey;
                Data.cbData = pContext->RipeZombie->cbClearKey;
                if(!CryptSetKeyParam(hMasterKey,
                                     KP_CLEAR_KEY,
                                     (BYTE*)&Data,
                                     0))
                {
                    SP_LOG_RESULT(GetLastError());
                    return PCT_INT_INTERNAL_ERROR;
                }
            }

            // Specify the CH_CHALLENGE_DATA.
            Data.pbData = pContext->pChallenge;
            Data.cbData = pContext->cbChallenge;
            if(!CryptSetKeyParam(hMasterKey,
                                 KP_CLIENT_RANDOM,
                                 (BYTE*)&Data,
                                 0))
            {
                SP_LOG_RESULT(GetLastError());
                return PCT_INT_INTERNAL_ERROR;
            }

            // Specify the SH_CONNECTION_ID_DATA.
            Data.pbData = pContext->pConnectionID;
            Data.cbData = pContext->cbConnectionID;
            if(!CryptSetKeyParam(hMasterKey,
                                 KP_SERVER_RANDOM,
                                 (BYTE*)&Data,
                                 0))
            {
                SP_LOG_RESULT(GetLastError());
                return PCT_INT_INTERNAL_ERROR;
            }

            // Specify the SH_CERTIFICATE_DATA.
            Data.pbData = pContext->RipeZombie->pbServerCertificate;
            Data.cbData = pContext->RipeZombie->cbServerCertificate;
            if(!CryptSetKeyParam(hMasterKey,
                                 KP_CERTIFICATE,
                                 (BYTE*)&Data,
                                 0))
            {
                SP_LOG_RESULT(GetLastError());
                return PCT_INT_INTERNAL_ERROR;
            }

            break;
        }

        case SP_PROT_SSL2_CLIENT:
        case SP_PROT_SSL2_SERVER:
        {
            CRYPT_DATA_BLOB Data;

            // Specify clear key value.
            if(pContext->RipeZombie->cbClearKey)
            {
                Data.pbData = pContext->RipeZombie->pClearKey;
                Data.cbData = pContext->RipeZombie->cbClearKey;
                if(!CryptSetKeyParam(hMasterKey,
                                     KP_CLEAR_KEY,
                                     (BYTE*)&Data,
                                     0))
                {
                    SP_LOG_RESULT(GetLastError());
                    return PCT_INT_INTERNAL_ERROR;
                }
            }

            // Specify the CH_CHALLENGE_DATA.
            Data.pbData = pContext->pChallenge;
            Data.cbData = pContext->cbChallenge;
            if(!CryptSetKeyParam(hMasterKey,
                                 KP_CLIENT_RANDOM,
                                 (BYTE*)&Data,
                                 0))
            {
                SP_LOG_RESULT(GetLastError());
                return PCT_INT_INTERNAL_ERROR;
            }

            // Specify the SH_CONNECTION_ID_DATA.
            Data.pbData = pContext->pConnectionID;
            Data.cbData = pContext->cbConnectionID;
            if(!CryptSetKeyParam(hMasterKey,
                                 KP_SERVER_RANDOM,
                                 (BYTE*)&Data,
                                 0))
            {
                SP_LOG_RESULT(GetLastError());
                return PCT_INT_INTERNAL_ERROR;
            }

            break;
        }

        case SP_PROT_SSL3_CLIENT:
        case SP_PROT_SSL3_SERVER:
        case SP_PROT_TLS1_CLIENT:
        case SP_PROT_TLS1_SERVER:
        {
            CRYPT_DATA_BLOB Data;

            // Specify client_random.
            Data.pbData = pContext->rgbS3CRandom;
            Data.cbData = CB_SSL3_RANDOM;
            if(!CryptSetKeyParam(hMasterKey,
                                 KP_CLIENT_RANDOM,
                                 (BYTE*)&Data,
                                 0))
            {
                SP_LOG_RESULT(GetLastError());
                return PCT_INT_INTERNAL_ERROR;
            }

            // Specify server_random.
            Data.pbData = pContext->rgbS3SRandom;
            Data.cbData = CB_SSL3_RANDOM;
            if(!CryptSetKeyParam(hMasterKey,
                                 KP_SERVER_RANDOM,
                                 (BYTE*)&Data,
                                 0))
            {
                SP_LOG_RESULT(GetLastError());
                return PCT_INT_INTERNAL_ERROR;
            }

            break;
        }

        default:
            return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   MakeSessionKeys
//
//  Synopsis:   Derive the session keys from the completed master key.
//
//  Arguments:  [pContext]              --  Schannel context.
//              [hProv]                 --
//              [hMasterKey]            --  Handle to master key.
//
//  History:    10-03-97   jbanes   Created.
//
//  Notes:      This routine is called by the server-side only.
//
//----------------------------------------------------------------------------
SP_STATUS
MakeSessionKeys(
    PSPContext  pContext,     // in
    HCRYPTPROV  hProv,        // in
    HCRYPTKEY   hMasterKey)   // in
{
    HCRYPTHASH hMasterHash = 0;
    HCRYPTKEY  hLocalMasterKey = 0;
    BOOL       fClient;
    SP_STATUS  pctRet;

    //
    // Duplicate the master key if we're doing a reconnect handshake. This 
    // will allow us to set the client_random and server_random properties 
    // on the key without having to worry about different threads 
    // interferring with each other.
    //

    if((pContext->Flags & CONTEXT_FLAG_FULL_HANDSHAKE) == 0)
    {
        if(!CryptDuplicateKey(hMasterKey, NULL, 0, &hLocalMasterKey))
        {
            pctRet = SP_LOG_RESULT(GetLastError());
            goto cleanup;
        }

        hMasterKey = hLocalMasterKey;
    }


    // Finish the master_secret.
    pctRet = PkcsFinishMasterKey(pContext, hMasterKey);
    if(pctRet != PCT_ERR_OK)
    {
        SP_LOG_RESULT(pctRet);
        goto cleanup;
    }

    fClient = !(pContext->RipeZombie->fProtocol & SP_PROT_SERVERS);

    // Create the master hash object from the master_secret key.
    if(!CryptCreateHash(hProv,
                        CALG_SCHANNEL_MASTER_HASH,
                        hMasterKey,
                        0,
                        &hMasterHash))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }


    // Derive read key from the master hash object.
    if(pContext->hPendingReadKey)
    {
        CryptDestroyKey(pContext->hPendingReadKey);
        pContext->hPendingReadKey = 0;
    }
    if(pContext->pPendingCipherInfo->aiCipher != CALG_NULLCIPHER)
    {
        if(!CryptDeriveKey(hProv,
                           CALG_SCHANNEL_ENC_KEY,
                           hMasterHash,
                           CRYPT_EXPORTABLE | (fClient ? CRYPT_SERVER : 0),
                           &pContext->hPendingReadKey))
        {
            pctRet = SP_LOG_RESULT(GetLastError());
            goto cleanup;
        }
    }

    // Derive write key from the master hash object.
    if(pContext->hPendingWriteKey)
    {
        CryptDestroyKey(pContext->hPendingWriteKey);
        pContext->hPendingWriteKey = 0;
    }
    if(pContext->pPendingCipherInfo->aiCipher != CALG_NULLCIPHER)
    {
        if(!CryptDeriveKey(hProv,
                           CALG_SCHANNEL_ENC_KEY,
                           hMasterHash,
                           CRYPT_EXPORTABLE | (fClient ? 0 : CRYPT_SERVER),
                           &pContext->hPendingWriteKey))
        {
            pctRet = SP_LOG_RESULT(GetLastError());
            goto cleanup;
        }
    }

    if((pContext->RipeZombie->fProtocol & SP_PROT_SSL2) ||
       (pContext->RipeZombie->fProtocol & SP_PROT_PCT1))
    {
        // Set the IV on the client and server encryption keys
        if(!CryptSetKeyParam(pContext->hPendingReadKey,
                             KP_IV,
                             pContext->RipeZombie->pKeyArgs,
                             0))
        {
            pctRet = SP_LOG_RESULT(GetLastError());
            goto cleanup;
        }

        if(!CryptSetKeyParam(pContext->hPendingWriteKey,
                             KP_IV,
                             pContext->RipeZombie->pKeyArgs,
                             0))
        {
            pctRet = SP_LOG_RESULT(GetLastError());
            goto cleanup;
        }
    }

    if(pContext->RipeZombie->fProtocol & SP_PROT_SSL2)
    {
        // SSL 2.0 uses same set of keys for both encryption and MAC.
        pContext->hPendingReadMAC  = 0;
        pContext->hPendingWriteMAC = 0;
    }
    else
    {
        // Derive read MAC from the master hash object.
        if(pContext->hPendingReadMAC)
        {
            CryptDestroyKey(pContext->hPendingReadMAC);
        }
        if(!CryptDeriveKey(hProv,
                           CALG_SCHANNEL_MAC_KEY,
                           hMasterHash,
                           CRYPT_EXPORTABLE | (fClient ? CRYPT_SERVER : 0),
                           &pContext->hPendingReadMAC))
        {
            pctRet = SP_LOG_RESULT(GetLastError());
            goto cleanup;
        }

        // Derive write MAC from the master hash object.
        if(pContext->hPendingWriteMAC)
        {
            CryptDestroyKey(pContext->hPendingWriteMAC);
        }
        if(!CryptDeriveKey(hProv,
                           CALG_SCHANNEL_MAC_KEY,
                           hMasterHash,
                           CRYPT_EXPORTABLE | (fClient ? 0 : CRYPT_SERVER),
                           &pContext->hPendingWriteMAC))
        {
            pctRet = SP_LOG_RESULT(GetLastError());
            goto cleanup;
        }
    }

    pctRet = PCT_ERR_OK;

cleanup:

    if(hMasterHash)
    {
        CryptDestroyHash(hMasterHash);
    }

    if(hLocalMasterKey)
    {
        CryptDestroyKey(hLocalMasterKey);
    }

    return pctRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   Ssl3ParseServerKeyExchange
//
//  Synopsis:   Parse the ServerKeyExchange message and import modulus and
//              exponent into a CryptoAPI public key.
//
//  Arguments:  [pContext]          --  Schannel context.
//
//              [pbMessage]         --  Pointer to message.
//
//              [cbMessage]         --  Message length.
//
//              [hServerPublic]     --  Handle to public key from server's
//                                      certificate. This is used to verify
//                                      the message's signature.
//
//              [phNewServerPublic] --  (output) Handle to new public key.
//
//
//  History:    10-23-97   jbanes   Created.
//
//  Notes:      This routine is called by the client-side only.
//
//              The format of the ServerKeyExchange message is:
//
//                  struct {
//                    select (KeyExchangeAlgorithm) {
//                        case diffie_hellman:
//                              ServerDHParams params;
//                              Signature signed_params;
//                        case rsa:
//                              ServerRSAParams params;
//                              Signature signed_params;
//                        case fortezza_dms:
//                              ServerFortezzaParams params;
//                    };
//                  } ServerKeyExchange;
//
//                  struct {
//                    opaque rsa_modulus<1..2^16-1>;
//                    opaque rsa_exponent<1..2^16-1>;
//                  } ServerRSAParams;
//
//----------------------------------------------------------------------------
SP_STATUS
Ssl3ParseServerKeyExchange(
    PSPContext  pContext,           // in
    PBYTE       pbMessage,          // in
    DWORD       cbMessage,          // in
    HCRYPTKEY   hServerPublic,      // in
    HCRYPTKEY  *phNewServerPublic)  // out
{
    PBYTE pbModulus = NULL;
    DWORD cbModulus;
    PBYTE pbExponent = NULL;
    DWORD cbExponent;
    PBYTE pbServerParams = NULL;
    DWORD cbServerParams;
    DWORD dwExponent;
    DWORD i;

    if(pbMessage == NULL || cbMessage == 0)
    {
        *phNewServerPublic = 0;
        return PCT_ERR_OK;
    }

    // Mark start of ServerRSAParams structure.
    // This is used to build hash values.
    pbServerParams = pbMessage;

    if(cbMessage < 3)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }

    // Modulus length
    cbModulus = MAKEWORD(pbMessage[1], pbMessage[0]);
    pbMessage += 2;

    // Since the modulus is encoded as an INTEGER, it is padded with a leading
    // zero if its most significant bit is one. Remove this padding, if
    // present.
    if(pbMessage[0] == 0)
    {
        cbModulus -= 1;
        pbMessage += 1;
    }

    if(cbModulus < 512/8 || cbModulus > 1024/8)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }

    // Modulus
    pbModulus = pbMessage;
    pbMessage += cbModulus;

    // Exponent length
    cbExponent = MAKEWORD(pbMessage[1], pbMessage[0]);
    if(cbExponent < 1 || cbExponent > 4)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }
    pbMessage += 2;

    // Exponent
    pbExponent = pbMessage;
    pbMessage += cbExponent;

    // form a (little endian) DWORD from exponent data
    dwExponent =  0;
    for(i = 0; i < cbExponent; i++)
    {
        dwExponent <<= 8;
        dwExponent |=  pbExponent[i];
    }

    // Compute length of ServerRSAParams structure.
    cbServerParams = (DWORD)(pbMessage - pbServerParams);

    //
    // digitally-signed struct {
    //   select(SignatureAlgorithm) {
    //        case anonymous: struct { };
    //        case rsa:
    //             opaque md5_hash[16];
    //             opaque sha_hash[20];
    //        case dsa:
    //             opaque sha_hash[20];
    //   };
    // } Signature;
    //

    {
        BYTE rgbHashValue[CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN];
        PBYTE pbSignature;
        DWORD cbSignature;
        HCRYPTHASH hHash;
        PBYTE pbLocalBuffer;
        DWORD cbLocalBuffer;

        // Signature block length
        cbSignature = ((INT)pbMessage[0] << 8) + pbMessage[1];
        pbMessage += 2;
        pbSignature = pbMessage;

        // Allocate buffer for RSA operation.
        cbLocalBuffer = cbSignature;
        SafeAllocaAllocate(pbLocalBuffer, cbLocalBuffer);
        if(pbLocalBuffer == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }

        // Reverse the signature.
        ReverseMemCopy(pbLocalBuffer, pbSignature, cbSignature);

        // Compute MD5 and SHA hash values.
        ComputeServerExchangeHashes(pContext,
                                    pbServerParams,
                                    cbServerParams,
                                    rgbHashValue,
                                    rgbHashValue + CB_MD5_DIGEST_LEN);


        if(!CryptCreateHash(pContext->RipeZombie->hMasterProv,
                            CALG_SSL3_SHAMD5,
                            0,
                            0,
                            &hHash))
        {
            SP_LOG_RESULT(GetLastError());
            SafeAllocaFree(pbLocalBuffer);
            return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        }

        // set hash value
        if(!CryptSetHashParam(hHash,
                              HP_HASHVAL,
                              rgbHashValue,
                              0))
        {
            SP_LOG_RESULT(GetLastError());
            CryptDestroyHash(hHash);
            SafeAllocaFree(pbLocalBuffer);
            return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        }

        DebugLog((DEB_TRACE, "Verify server_key_exchange message signature.\n"));
        if(!CryptVerifySignature(hHash,
                                 pbLocalBuffer,
                                 cbSignature,
                                 hServerPublic,
                                 NULL,
                                 0))
        {
            DebugLog((DEB_WARN, "Signature Verify Failed: %x\n", GetLastError()));
            CryptDestroyHash(hHash);
            SafeAllocaFree(pbLocalBuffer);
            return SP_LOG_RESULT(PCT_ERR_INTEGRITY_CHECK_FAILED);
        }
        DebugLog((DEB_TRACE, "Server_key_exchange message signature verified okay.\n"));

        CryptDestroyHash(hHash);
        SafeAllocaFree(pbLocalBuffer);
    }

    //
    // Import ephemeral public key into CSP.
    //

    {
        BLOBHEADER *pBlobHeader;
        RSAPUBKEY *pRsaPubKey;
        PBYTE pbBlob;
        DWORD cbBlob;

        // Allocate memory for PUBLICKEYBLOB.
        cbBlob = sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) + cbModulus;
        SafeAllocaAllocate(pbBlob, cbBlob);
        if(pbBlob == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }

        // Build PUBLICKEYBLOB from modulus and exponent.
        pBlobHeader = (BLOBHEADER *)pbBlob;
        pRsaPubKey  = (RSAPUBKEY *)(pBlobHeader + 1);

        pBlobHeader->bType    = PUBLICKEYBLOB;
        pBlobHeader->bVersion = CUR_BLOB_VERSION;
        pBlobHeader->reserved = 0;
        pBlobHeader->aiKeyAlg = CALG_RSA_KEYX;
        pRsaPubKey->magic     = 0x31415352; // RSA1
        pRsaPubKey->bitlen    = cbModulus * 8;
        pRsaPubKey->pubexp    = dwExponent;
        ReverseMemCopy((PBYTE)(pRsaPubKey + 1), pbModulus, cbModulus);

        if(!CryptImportKey(pContext->RipeZombie->hMasterProv,
                           pbBlob,
                           cbBlob,
                           0,
                           0,
                           phNewServerPublic))
        {
            SP_LOG_RESULT(GetLastError());
            SafeAllocaFree(pbBlob);
            return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        }

        SafeAllocaFree(pbBlob);
    }

    return PCT_ERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\keyxmsdh.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       keyxmsdh.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-21-97   jbanes   CAPI integration stuff.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <align.h>


// PROV_DH_SCHANNEL handle used for client and server operations. This is
// where the schannel ephemeral DH key lives.
HCRYPTPROV          g_hDhSchannelProv = 0;
PROV_ENUMALGS_EX *  g_pDhSchannelAlgs = NULL;
DWORD               g_cDhSchannelAlgs = 0;


SP_STATUS
WINAPI
DHGenerateServerExchangeValue(
    SPContext     * pContext,               // in
    PUCHAR          pServerExchangeValue,   // out
    DWORD *         pcbServerExchangeValue  // in/out
);

SP_STATUS
WINAPI
DHGenerateClientExchangeValue(
    SPContext     * pContext,               // in
    PUCHAR          pServerExchangeValue,   // in
    DWORD           cbServerExchangeValue,  // in
    PUCHAR          pClientClearValue,      // out
    DWORD *         pcbClientClearValue,    // in/out
    PUCHAR          pClientExchangeValue,   // out
    DWORD *         pcbClientExchangeValue  // in/out
);

SP_STATUS
WINAPI
DHGenerateServerMasterKey(
    SPContext     * pContext,               // in
    PUCHAR          pClientClearValue,      // in
    DWORD           cbClientClearValue,     // in
    PUCHAR          pClientExchangeValue,   // in
    DWORD           cbClientExchangeValue   // in
);


KeyExchangeSystem keyexchDH = {
    SP_EXCH_DH_PKCS3,
    "Diffie Hellman",
    DHGenerateServerExchangeValue,
    DHGenerateClientExchangeValue,
    DHGenerateServerMasterKey,
};


SP_STATUS
SPSignDssParams(
    PSPContext      pContext,
    PSPCredential   pCred,
    PBYTE           pbParams,
    DWORD           cbParams,
    PBYTE           pbEncodedSignature,
    PDWORD          pcbEncodedSignature)
{
    HCRYPTHASH  hHash;
    BYTE        rgbSignature[DSA_SIGNATURE_SIZE];
    DWORD       cbSignature;

    if(pCred == NULL)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    if(!CryptCreateHash(pCred->hProv,
                        CALG_SHA,
                        0,
                        0,
                        &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    if(!CryptHashData(hHash, pContext->rgbS3CRandom, 32, 0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    if(!CryptHashData(hHash, pContext->rgbS3SRandom, 32, 0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    if(!CryptHashData(hHash, pbParams, cbParams, 0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    cbSignature = sizeof(rgbSignature);
    if(!CryptSignHash(hHash,
                      pCred->dwKeySpec,
                      NULL,
                      0,
                      rgbSignature,
                      &cbSignature))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    CryptDestroyHash(hHash);

    if(!CryptEncodeObject(X509_ASN_ENCODING,
                          X509_DSS_SIGNATURE,
                          rgbSignature,
                          pbEncodedSignature,
                          pcbEncodedSignature))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    // Return success.
    return PCT_ERR_OK;
}

SP_STATUS
SPVerifyDssParams(
    PSPContext  pContext,
    HCRYPTPROV  hProv,
    HCRYPTKEY   hPublicKey,
    PBYTE       pbParams,
    DWORD       cbParams,
    PBYTE       pbEncodedSignature,
    DWORD       cbEncodedSignature)
{
    HCRYPTHASH  hHash;
    BYTE        rgbSignature[DSA_SIGNATURE_SIZE];
    DWORD       cbSignature;

    // Decode the signature.
    cbSignature = sizeof(rgbSignature);
    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          X509_DSS_SIGNATURE,
                          pbEncodedSignature,
                          cbEncodedSignature,
                          0,
                          rgbSignature,
                          &cbSignature))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    if(!CryptCreateHash(hProv,
                           CALG_SHA,
                           0,
                           0,
                           &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    if(!CryptHashData(hHash, pContext->rgbS3CRandom, 32, 0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    if(!CryptHashData(hHash, pContext->rgbS3SRandom, 32, 0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    if(!CryptHashData(hHash, pbParams, cbParams, 0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    if(!CryptVerifySignature(hHash,
                             rgbSignature,
                             cbSignature,
                             hPublicKey,
                             NULL,
                             0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_INT_MSG_ALTERED;
    }

    CryptDestroyHash(hHash);

    return PCT_ERR_OK;
}

SP_STATUS
GetDHEphemKey(
    PSPContext      pContext,
    HCRYPTPROV *    phProv,
    HCRYPTKEY *     phTek)
{
    PSPCredentialGroup pCredGroup;
    PSPCredential pCred;
    DWORD dwKeySize;
    DWORD cbData;
    DWORD Status;

    pCredGroup = pContext->RipeZombie->pServerCred;
    if(pCredGroup == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    pCred = pContext->RipeZombie->pActiveServerCred;
    if(pCredGroup == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    LockCredentialExclusive(pCredGroup);

    if(phProv)
    {
        *phProv = pCred->hProv;
    }

    dwKeySize = 1024;

    // Determine if we've already created an ephemeral key.
    if(pCred->hTek)
    {
        *phTek = pCred->hTek;
        Status = PCT_ERR_OK;
        goto cleanup;
    }

    // Generate the ephemeral key.
    if(!CryptGenKey(pCred->hProv,
                    CALG_DH_EPHEM,
                    dwKeySize << 16,
                    phTek))
    {
        SP_LOG_RESULT(GetLastError());
        Status = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    pCred->hTek = *phTek;

    Status = PCT_ERR_OK;

cleanup:

    if(Status == PCT_ERR_OK)
    {
        // Determine size of key exchange key.
        cbData = sizeof(DWORD);
        if(!CryptGetKeyParam(*phTek,
                             KP_BLOCKLEN,
                             (PBYTE)&pContext->RipeZombie->dwExchStrength,
                             &cbData,
                             0))
        {
            SP_LOG_RESULT(GetLastError());
            pContext->RipeZombie->dwExchStrength = 0;
        }
    }

    UnlockCredential(pCredGroup);

    return Status;
}


//+---------------------------------------------------------------------------
//
//  Function:   DHGenerateServerExchangeValue
//
//  Synopsis:   Create a ServerKeyExchange message, containing an ephemeral
//              DH key.
//
//  Arguments:  [pContext]                  --  Schannel context.
//              [pServerExchangeValue]      --
//              [pcbServerExchangeValue]    --
//
//  History:    03-24-98   jbanes   Added CAPI integration.
//
//  Notes:      The following data is placed in the output buffer by
//              this routine:
//
//              struct {
//                 opaque dh_p<1..2^16-1>;
//                 opaque dh_g<1..2^16-1>;
//                 opaque dh_Ys<1..2^16-1>;
//              } ServerDHParams;
//
//              struct {
//                 ServerDHParams params;
//                 Signature signed_params;
//              } ServerKeyExchange;
//
//----------------------------------------------------------------------------
SP_STATUS
WINAPI
DHGenerateServerExchangeValue(
    PSPContext  pContext,               // in
    PBYTE       pServerExchangeValue,   // out
    DWORD *     pcbServerExchangeValue) // in/out
{
    PSPCredential   pCred;
    HCRYPTPROV      hProv = 0;
    HCRYPTKEY       hServerDhKey = 0;

    PBYTE           pbMessage;
    DWORD           cbMessage;
    DWORD           cbBytesLeft;
    DWORD           cbData;
    DWORD           cbP;
    DWORD           cbG;
    DWORD           cbY;
    DWORD           cbSignature;
    SP_STATUS       pctRet;
    BOOL            fImpersonating = FALSE;

    pCred = pContext->RipeZombie->pActiveServerCred;
    if(pCred == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pContext->RipeZombie->fProtocol != SP_PROT_SSL3_SERVER &&
       pContext->RipeZombie->fProtocol != SP_PROT_TLS1_SERVER)
    {
        // SSL2 and PCT do not support DH.
        return SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH);
    }

    // Always send a ServerKeyExchange message.
    pContext->fExchKey = TRUE;

    fImpersonating = SslImpersonateClient();


    //
    // Generate ephemeral DH key.
    //

    pctRet = GetDHEphemKey(pContext, 
                           &hProv,
                           &hServerDhKey);
    if(pctRet != PCT_ERR_OK)
    {
        SP_LOG_RESULT(pctRet);
        goto cleanup;
    }


    //
    // Estimate sizes of P, G, and Y.
    //

    if(!CryptGetKeyParam(hServerDhKey, KP_P, NULL, &cbP, 0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    if(!CryptGetKeyParam(hServerDhKey, KP_G, NULL, &cbG, 0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    if(!CryptExportKey(hServerDhKey,
                          0,
                          PUBLICKEYBLOB,
                          0,
                          NULL,
                          &cbY))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }


    //
    // Compute approximate size of ServerKeyExchange message.
    //

    cbMessage = 2 + cbP +
                2 + cbG +
                2 + cbY + sizeof(DWORD) +
                2 + MAX_DSA_ENCODED_SIGNATURE_SIZE;

    if(pServerExchangeValue == NULL)
    {
        *pcbServerExchangeValue = cbMessage;
        pctRet = PCT_ERR_OK;
        goto cleanup;
    }
    if(*pcbServerExchangeValue < cbMessage)
    {
        *pcbServerExchangeValue = cbMessage;
        pctRet = SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        goto cleanup;
    }


    //
    // Build the ServerDHParams structure.
    //

    pbMessage   = pServerExchangeValue;
    cbBytesLeft = cbMessage;

    // Get P.
    if(!CryptGetKeyParam(hServerDhKey, KP_P, pbMessage + 2, &cbP, 0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    ReverseInPlace(pbMessage + 2, cbP);

    pbMessage[0] = MSBOF(cbP);
    pbMessage[1] = LSBOF(cbP);
    pbMessage   += 2 + cbP;
    cbBytesLeft -= 2 + cbP;

    // Get G.
    if(!CryptGetKeyParam(hServerDhKey, KP_G, pbMessage + 2, &cbG, 0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    ReverseInPlace(pbMessage + 2, cbG);

    pbMessage[0] = MSBOF(cbG);
    pbMessage[1] = LSBOF(cbG);
    pbMessage   += 2 + cbG;
    cbBytesLeft -= 2 + cbG;

    // Get Ys.
    {
        BLOBHEADER *pBlobHeader;
        DHPUBKEY *  pDHPubKey;
        PBYTE       pbKey;
        DWORD       cbKey;

        pBlobHeader = (BLOBHEADER *)ROUND_UP_POINTER(pbMessage, ALIGN_DWORD);
        cbData = cbBytesLeft - sizeof(DWORD);

        if(!CryptExportKey(hServerDhKey,
                              0,
                              PUBLICKEYBLOB,
                              0,
                              (PBYTE)pBlobHeader,
                              &cbData))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        pDHPubKey   = (DHPUBKEY *)(pBlobHeader + 1);
        pbKey       = (BYTE *)(pDHPubKey + 1);

        cbKey = pDHPubKey->bitlen / 8;
        if(pDHPubKey->bitlen % 8) cbKey++;

        MoveMemory(pbMessage + 2, pbKey, cbKey);
        ReverseInPlace(pbMessage + 2, cbKey);

        pbMessage[0] = MSBOF(cbKey);
        pbMessage[1] = LSBOF(cbKey);
        pbMessage   += 2 + cbKey;
        cbBytesLeft -= 2 + cbKey;
    }


    //
    // Sign the ServerDHParams structure.
    //

    cbSignature = cbBytesLeft - 2;
    pctRet = SPSignDssParams(pContext,
                             pCred, 
                             pServerExchangeValue,
                             (DWORD)(pbMessage - pServerExchangeValue),
                             pbMessage + 2,
                             &cbSignature);
    if(pctRet != PCT_ERR_OK)
    {
        SP_LOG_RESULT(pctRet);
        goto cleanup;
    }
    pbMessage[0] = MSBOF(cbSignature);
    pbMessage[1] = LSBOF(cbSignature);
    pbMessage += 2 + cbSignature;
    cbBytesLeft -= 2 + cbSignature;


    //
    // Update function outputs.
    //

    SP_ASSERT(cbBytesLeft < cbMessage);

    *pcbServerExchangeValue = (DWORD)(pbMessage - pServerExchangeValue);

    // Use ephemeral key for the new connection.
    pContext->RipeZombie->hMasterProv = hProv;

    pctRet = PCT_ERR_OK;

cleanup:

    if(fImpersonating)
    {
        RevertToSelf();
    }

    return pctRet;
}


SP_STATUS
ParseServerKeyExchange(
    PSPContext  pContext,       // in
    PBYTE       pbMessage,      // in
    DWORD       cbMessage,      // in
    PBYTE *     ppbServerP,     // out
    PDWORD      pcbServerP,     // out
    PBYTE *     ppbServerG,     // out
    PDWORD      pcbServerG,     // out
    PBYTE *     ppbServerY,     // out
    PDWORD      pcbServerY,     // out
    BOOL        fValidateSig)   // in
{
    PBYTE       pbData;
    BLOBHEADER *pPublicBlob;
    DWORD       cbPublicBlob;
    HCRYPTKEY   hServerPublic = 0;
    PBYTE       pbSignature;
    DWORD       cbSignature;
    DWORD       cbSignedData;
    SP_STATUS   pctRet;

    //
    // Parse out ServerKeyExchange message fields
    //

    pbData = pbMessage;

    if(pbData + 2 > pbMessage + cbMessage)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }

    *pcbServerP = MAKEWORD(pbData[1], pbData[0]);
    *ppbServerP = pbData + 2;
    pbData += 2 + *pcbServerP;

    if(pbData + 2 > pbMessage + cbMessage)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }

    *pcbServerG = MAKEWORD(pbData[1], pbData[0]);
    *ppbServerG = pbData + 2;
    pbData += 2 + *pcbServerG;

    if(pbData + 2 > pbMessage + cbMessage)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }

    *pcbServerY = MAKEWORD(pbData[1], pbData[0]);
    *ppbServerY = pbData + 2;
    pbData += 2 + *pcbServerY;

    if(pbData + 2 > pbMessage + cbMessage)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }

    cbSignedData = (DWORD)(pbData - pbMessage);

    cbSignature = MAKEWORD(pbData[1], pbData[0]);
    pbSignature = pbData + 2;
    pbData += 2 + cbSignature;

    if(pbData != pbMessage + cbMessage)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }

    if(fValidateSig == FALSE)
    {
        return PCT_ERR_OK;
    }


    //
    // Validate signature.
    //

    pPublicBlob  = pContext->RipeZombie->pRemotePublic->pPublic;
    cbPublicBlob = pContext->RipeZombie->pRemotePublic->cbPublic;

    if(!CryptImportKey(pContext->RipeZombie->hMasterProv,
                       (PBYTE)pPublicBlob,
                       cbPublicBlob,
                       0,
                       0,
                       &hServerPublic))
    {
        return SP_LOG_RESULT(GetLastError());
    }

    pctRet = SPVerifyDssParams(
                        pContext,
                        pContext->RipeZombie->hMasterProv,
                        hServerPublic,
                        pbMessage,
                        cbSignedData,
                        pbSignature,
                        cbSignature);
    if(pctRet != PCT_ERR_OK)
    {
        CryptDestroyKey(hServerPublic);
        return SP_LOG_RESULT(pctRet);
    }

    CryptDestroyKey(hServerPublic);

    return PCT_ERR_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   DHGenerateClientExchangeValue
//
//  Synopsis:   Create a ClientKeyExchange message, containing an ephemeral
//              DH key.
//
//  Arguments:
//
//  History:    03-24-98   jbanes   Added CAPI integration.
//
//  Notes:      The following data is placed in the output buffer by
//              this routine:
//
//              struct {
//                 opaque dh_Yc<1..2^16-1>;
//              } ClientDiffieHellmanPublic;
//
//----------------------------------------------------------------------------
SP_STATUS
WINAPI
DHGenerateClientExchangeValue(
    SPContext     * pContext,               // in
    PUCHAR          pServerExchangeValue,   // in
    DWORD           cbServerExchangeValue,  // in
    PUCHAR          pClientClearValue,      // out
    DWORD *         pcbClientClearValue,    // in/out
    PUCHAR          pClientExchangeValue,   // out
    DWORD *         pcbClientExchangeValue) // in/out
{
    HCRYPTKEY       hClientDHKey = 0;
    PSessCacheItem  pZombie;
    CRYPT_DATA_BLOB Data;
    ALG_ID          Algid;
    DWORD           cbHeader;
    SP_STATUS       pctRet;

    PBYTE pbServerP = NULL;
    DWORD cbServerP;
    PBYTE pbServerG = NULL;
    DWORD cbServerG;
    PBYTE pbServerY = NULL;
    DWORD cbServerY;
    PBYTE pbClientY = NULL;
    DWORD cbClientY;

    PBYTE pbBlob = NULL;
    DWORD cbBlob;
    DWORD cbData;
    DWORD dwKeySize;

    UNREFERENCED_PARAMETER(pClientClearValue);
    UNREFERENCED_PARAMETER(pcbClientClearValue);

    pZombie = pContext->RipeZombie;
    if(pZombie == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pZombie->hMasterProv == 0)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // We're doing a full handshake.
    pContext->Flags |= CONTEXT_FLAG_FULL_HANDSHAKE;

    if(pZombie->fProtocol == SP_PROT_SSL3_CLIENT)
    {
        Algid = CALG_SSL3_MASTER;
    }
    else if(pZombie->fProtocol == SP_PROT_TLS1_CLIENT)
    {
        Algid = CALG_TLS1_MASTER;
    }
    else
    {
        return SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH);
    }

    if(pServerExchangeValue == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }


    //
    // Is the output buffer large enough?
    //

    pctRet = ParseServerKeyExchange(pContext,
                                    pServerExchangeValue,
                                    cbServerExchangeValue,
                                    &pbServerP,
                                    &cbServerP,
                                    &pbServerG,
                                    &cbServerG,
                                    &pbServerY,
                                    &cbServerY,
                                    FALSE);
    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }

    cbBlob = sizeof(BLOBHEADER) + sizeof(DHPUBKEY) + cbServerY + 20;

    if(pClientExchangeValue == NULL)
    {
        *pcbClientExchangeValue = cbBlob;
        return PCT_ERR_OK;
    }

    if(*pcbClientExchangeValue < cbBlob)
    {
        *pcbClientExchangeValue = cbBlob;
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }


    //
    // Parse the ServerKeyExchange message.
    //

    pctRet = ParseServerKeyExchange(pContext,
                                    pServerExchangeValue,
                                    cbServerExchangeValue,
                                    &pbServerP,
                                    &cbServerP,
                                    &pbServerG,
                                    &cbServerG,
                                    &pbServerY,
                                    &cbServerY,
                                    TRUE);
    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }


    //
    // Create buffer to use for endian-izing data.
    //

    cbBlob = sizeof(BLOBHEADER) + sizeof(DHPUBKEY) + cbServerY;
    cbBlob = max(cbBlob, cbServerP);
    cbBlob = max(cbBlob, cbServerG);

    SafeAllocaAllocate(pbBlob, cbBlob);
    if(pbBlob == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }


    //
    // Generate and set the parameters on the client DH key.
    //

    dwKeySize = cbServerP * 8;

    if(!CryptGenKey(pZombie->hMasterProv,
                    CALG_DH_EPHEM,
                    (dwKeySize << 16) | CRYPT_PREGEN,
                    &hClientDHKey))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }

    ReverseMemCopy(pbBlob, pbServerP, cbServerP);
    Data.pbData = pbBlob;
    Data.cbData = cbServerP;
    if(!CryptSetKeyParam(hClientDHKey,
                         KP_P,
                         (PBYTE)&Data,
                         0))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }

    ReverseMemCopy(pbBlob, pbServerG, cbServerG);
    Data.pbData = pbBlob;
    Data.cbData = cbServerG;
    if(cbServerG < cbServerP)
    {
        // Expand G so that it's the same size as P.
        ZeroMemory(pbBlob + cbServerG, cbServerP - cbServerG);
        Data.cbData = cbServerP;
    }
    if(!CryptSetKeyParam(hClientDHKey,
                         KP_G,
                         (PBYTE)&Data,
                         0))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }

    // actually create the client private DH key
    if(!CryptSetKeyParam(hClientDHKey,
                         KP_X,
                         NULL,
                         0))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }


    //
    // Import the server's public key and generate the master secret.
    //

    {
        BLOBHEADER *   pBlobHeader;
        DHPUBKEY *     pDHPubKey;
        PBYTE          pbKey;

        // Build PUBLICKEYBLOB around the server's public key.
        pBlobHeader = (BLOBHEADER *)pbBlob;
        pDHPubKey   = (DHPUBKEY *)(pBlobHeader + 1);
        pbKey       = (PBYTE)(pDHPubKey + 1);

        pBlobHeader->bType    = PUBLICKEYBLOB;
        pBlobHeader->bVersion = CUR_BLOB_VERSION;
        pBlobHeader->reserved = 0;
        pBlobHeader->aiKeyAlg = CALG_DH_EPHEM;

        pDHPubKey->magic      = MAGIC_DH1;
        pDHPubKey->bitlen     = cbServerY * 8;

        ReverseMemCopy(pbKey, pbServerY, cbServerY);

        if(!CryptImportKey(pZombie->hMasterProv,
                           pbBlob,
                           cbBlob,
                           hClientDHKey,
                           0,
                           &pZombie->hMasterKey))
        {
            pctRet = GetLastError();
            goto cleanup;
        }
    }

    // Determine size of key exchange key.
    cbData = sizeof(DWORD);
    if(!CryptGetKeyParam(hClientDHKey,
                         KP_BLOCKLEN,
                         (PBYTE)&pZombie->dwExchStrength,
                         &cbData,
                         0))
    {
        SP_LOG_RESULT(GetLastError());
        pContext->RipeZombie->dwExchStrength = 0;
    }


    //
    // Convert the agreed key to the appropriate master key type.
    //

    if(!CryptSetKeyParam(pZombie->hMasterKey,
                         KP_ALGID,
                         (PBYTE)&Algid,
                         0))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }


    //
    // Export the client public key, strip off the blob header
    // goo and attach a two byte length field. This will make up our
    // ClientKeyExchange message.
    //

    if(!CryptExportKey(hClientDHKey,
                       0,
                       PUBLICKEYBLOB,
                       0,
                       pClientExchangeValue,
                       pcbClientExchangeValue))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }

    cbHeader  = sizeof(BLOBHEADER) + sizeof(DHPUBKEY);

    cbClientY = *pcbClientExchangeValue - cbHeader;
    pbClientY = pClientExchangeValue + cbHeader;

    pClientExchangeValue[0] = MSBOF(cbClientY);
    pClientExchangeValue[1] = LSBOF(cbClientY);

    ReverseInPlace(pbClientY, cbClientY);
    MoveMemory(pClientExchangeValue + 2, pbClientY, cbClientY);

    *pcbClientExchangeValue = 2 + cbClientY;


    //
    // Build the session keys.
    //

    pctRet = MakeSessionKeys(pContext,
                             pZombie->hMasterProv,
                             pZombie->hMasterKey);
    if(pctRet != PCT_ERR_OK)
    {
        goto cleanup;
    }

    // Update perf counter.
    InterlockedIncrement(&g_cClientHandshakes);

    pctRet = PCT_ERR_OK;


cleanup:

    if(pbBlob)
    {
        SafeAllocaFree(pbBlob);
    }

    if(hClientDHKey)
    {
        CryptDestroyKey(hClientDHKey);
    }

    return pctRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   PkcsGenerateServerMasterKey
//
//  Synopsis:   Decrypt the master secret (from the ClientKeyExchange message)
//              and derive the session keys from it.
//
//  Arguments:  [pContext]              --  Schannel context.
//              [pClientClearValue]     --  Not used.
//              [cbClientClearValue]    --  Not used.
//              [pClientExchangeValue]  --
//              [cbClientExchangeValue] --
//
//  History:    03-25-98   jbanes   Created.
//
//  Notes:      The following data is supposed to be in the input buffer:
//
//              struct {
//                 opaque dh_Yc<1..2^16-1>;
//              } ClientDiffieHellmanPublic;
//
//----------------------------------------------------------------------------
SP_STATUS
WINAPI
DHGenerateServerMasterKey(
    SPContext     * pContext,               // in
    PUCHAR          pClientClearValue,      // in
    DWORD           cbClientClearValue,     // in
    PUCHAR          pClientExchangeValue,   // in
    DWORD           cbClientExchangeValue)  // in
{
    PSessCacheItem  pZombie;
    ALG_ID          Algid;
    SP_STATUS       pctRet;
    PBYTE           pbClientY;
    DWORD           cbClientY;
    HCRYPTKEY       hTek;
    BOOL            fImpersonating = FALSE;

    UNREFERENCED_PARAMETER(pClientClearValue);
    UNREFERENCED_PARAMETER(cbClientClearValue);

    pZombie = pContext->RipeZombie;
    if(pZombie == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pZombie->hMasterProv == 0)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // We're doing a full handshake.
    pContext->Flags |= CONTEXT_FLAG_FULL_HANDSHAKE;

    fImpersonating = SslImpersonateClient();

    pctRet = GetDHEphemKey(pContext, 
                           NULL,
                           &hTek);
    if(pctRet != PCT_ERR_OK)
    {
        SP_LOG_RESULT(pctRet);
        goto cleanup;
    }

    if(pZombie->fProtocol == SP_PROT_SSL3_SERVER)
    {
        Algid = CALG_SSL3_MASTER;
    }
    else if(pZombie->fProtocol == SP_PROT_TLS1_SERVER)
    {
        Algid = CALG_TLS1_MASTER;
    }
    else
    {
        pctRet = SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH);
        goto cleanup;
    }

    //
    // Parse ClientKeyExchange message.
    //

    if(pClientExchangeValue == NULL || cbClientExchangeValue <= 2)
    {
        pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        goto cleanup;
    }

    cbClientY = MAKEWORD(pClientExchangeValue[1], pClientExchangeValue[0]);
    pbClientY = pClientExchangeValue + 2;

    if(2 + cbClientY != cbClientExchangeValue)
    {
        pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        goto cleanup;
    }

    if(cbClientY == 0)
    {
        pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        goto cleanup;
    }


    //
    // Import the client's public key and generate the master secret.
    //

    {
        BLOBHEADER *   pBlobHeader;
        DHPUBKEY *     pDHPubKey;
        PBYTE          pbKey;
        PBYTE          pbBlob;
        DWORD          cbBlob;

        // Build PUBLICKEYBLOB around the server's public key.
        cbBlob = sizeof(BLOBHEADER) + sizeof(DHPUBKEY) + cbClientY;
        SafeAllocaAllocate(pbBlob, cbBlob);
        if(pbBlob == NULL)
        {
            pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        pBlobHeader = (BLOBHEADER *)pbBlob;
        pDHPubKey   = (DHPUBKEY *)(pBlobHeader + 1);
        pbKey       = (PBYTE)(pDHPubKey + 1);

        pBlobHeader->bType    = PUBLICKEYBLOB;
        pBlobHeader->bVersion = CUR_BLOB_VERSION;
        pBlobHeader->reserved = 0;
        pBlobHeader->aiKeyAlg = CALG_DH_EPHEM;

        pDHPubKey->magic  = MAGIC_DH1;
        pDHPubKey->bitlen = cbClientY * 8;

        ReverseMemCopy(pbKey, pbClientY, cbClientY);

        if(!CryptImportKey(pZombie->hMasterProv,
                           pbBlob,
                           cbBlob,
                           hTek,
                           0,
                           &pZombie->hMasterKey))
        {
            pctRet = GetLastError();
            SafeAllocaFree(pbBlob);
            goto cleanup;
        }

        SafeAllocaFree(pbBlob);
    }


    //
    // Convert the agreed key to the appropriate master key type.
    //

    if(!CryptSetKeyParam(pZombie->hMasterKey,
                         KP_ALGID, (PBYTE)&Algid,
                         0))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }


    //
    // Build the session keys.
    //

    pctRet = MakeSessionKeys(pContext,
                             pZombie->hMasterProv,
                             pZombie->hMasterKey);
    if(pctRet != PCT_ERR_OK)
    {
        goto cleanup;
    }

    // Update perf counter.
    InterlockedIncrement(&g_cServerHandshakes);

    pctRet = PCT_ERR_OK;


cleanup:

    if(fImpersonating)
    {
        RevertToSelf();
    }

    return pctRet;
}


void
ReverseInPlace(PUCHAR pByte, DWORD cbByte)
{
    DWORD i;
    BYTE bSave;

    for(i=0; i< cbByte/2; i++)
    {
        bSave = pByte[i];
        pByte[i] = pByte[cbByte-i-1];
        pByte[cbByte-i-1] = bSave;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\mapcache.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001.
//
//  File:       mapcache.c
//
//  Contents:   Routines to manage a cache that holds issuer names we've 
//              recently processed via many-to-one certificate mapping.
//              This is a negative cache, so only issuers that have failed
//              mapping are stored in the cache.
//
//              The purpose of this cache is to avoid attempting to map
//              the same issuers over and over again. This is especially
//              important now that the many-to-one mapper walks up the 
//              certificate chain, attempting to map each CA as it goes.
//
//              This code is active on DC machines only.
//
//  Functions:
//
//  History:    04-12-2001   jbanes     Created
//
//----------------------------------------------------------------------------
#include "spbase.h"
#include <mapper.h>

ISSUER_CACHE IssuerCache;

SP_STATUS
SPInitIssuerCache(void)
{
    DWORD i;
    NTSTATUS Status;

    memset(&IssuerCache, 0, sizeof(IssuerCache));
    IssuerCache.dwLifespan       = ISSUER_CACHE_LIFESPAN;
    IssuerCache.dwCacheSize      = ISSUER_CACHE_SIZE;
    IssuerCache.dwMaximumEntries = ISSUER_CACHE_SIZE;

    InitializeListHead(&IssuerCache.EntryList);

    __try {
        RtlInitializeResource(&IssuerCache.Lock);
    } __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }
    IssuerCache.LockInitialized = TRUE;

    IssuerCache.Cache = (PLIST_ENTRY)SPExternalAlloc(IssuerCache.dwCacheSize * sizeof(LIST_ENTRY));
    if(IssuerCache.Cache == NULL)
    {
        Status = SP_LOG_RESULT(STATUS_NO_MEMORY);
        goto cleanup;
    }

    for(i = 0; i < IssuerCache.dwCacheSize; i++)
    {
        InitializeListHead(&IssuerCache.Cache[i]);
    }

    Status = STATUS_SUCCESS;

cleanup:

    if(!NT_SUCCESS(Status))
    {
        SPShutdownIssuerCache();
    }

    return Status;
}


void
SPShutdownIssuerCache(void)
{
    ISSUER_CACHE_ENTRY *pItem;
    PLIST_ENTRY pList;

    if(IssuerCache.LockInitialized)
    {
        RtlAcquireResourceExclusive(&IssuerCache.Lock, TRUE);
    }

    if(IssuerCache.Cache != NULL)
    {
        pList = IssuerCache.EntryList.Flink;

        while(pList != &IssuerCache.EntryList)
        {
            pItem  = CONTAINING_RECORD(pList, ISSUER_CACHE_ENTRY, EntryList.Flink);
            pList  = pList->Flink;

            SPDeleteIssuerEntry(pItem);
        }

        SPExternalFree(IssuerCache.Cache);
    }

    if(IssuerCache.LockInitialized)
    {
        RtlDeleteResource(&IssuerCache.Lock);
        IssuerCache.LockInitialized = FALSE;
    }
}

void
SPPurgeIssuerCache(void)
{
    ISSUER_CACHE_ENTRY *pItem;
    PLIST_ENTRY pList;

    if(!IssuerCache.LockInitialized)
    {
        return;
    }

    if(IssuerCache.dwUsedEntries == 0)
    {
        return;
    }

    RtlAcquireResourceExclusive(&IssuerCache.Lock, TRUE);

    pList = IssuerCache.EntryList.Flink;

    while(pList != &IssuerCache.EntryList)
    {
        pItem = CONTAINING_RECORD(pList, ISSUER_CACHE_ENTRY, EntryList.Flink);
        pList = pList->Flink;

        RemoveEntryList(&pItem->IndexEntryList);
        RemoveEntryList(&pItem->EntryList);
        IssuerCache.dwUsedEntries--;

        SPDeleteIssuerEntry(pItem);
    }

    RtlReleaseResource(&IssuerCache.Lock);
}

void
SPDeleteIssuerEntry(
    ISSUER_CACHE_ENTRY *pItem)
{
    if(pItem == NULL)
    {
        return;
    }

    if(pItem->pbIssuer)
    {
        LogDistinguishedName(DEB_TRACE, "Delete from cache: %s\n", pItem->pbIssuer, pItem->cbIssuer);
        SPExternalFree(pItem->pbIssuer);
    }

    SPExternalFree(pItem);
}

DWORD
ComputeIssuerCacheIndex(
    PBYTE pbIssuer,
    DWORD cbIssuer)
{
    ULONG Index = 0;
    ULONG i;

    if(pbIssuer == NULL)
    {
        Index = 0;
    }
    else
    {
        for(i = 0; i < cbIssuer; i++)
        {
            Index += (pbIssuer[i] ^ 0x55);
        }

        Index %= IssuerCache.dwCacheSize;
    }

    return Index;
}

BOOL
SPFindIssuerInCache(
    PBYTE pbIssuer,
    DWORD cbIssuer)
{
    DWORD Index;
    DWORD timeNow;
    ISSUER_CACHE_ENTRY *pItem;
    PLIST_ENTRY pList;
    BOOL fFound = FALSE;

    if(pbIssuer == NULL || cbIssuer == 0)
    {
        return FALSE;
    }

    if(!IssuerCache.LockInitialized)
    {
        return FALSE;
    }


    // 
    // Compute the cache index.
    //

    Index = ComputeIssuerCacheIndex(pbIssuer, cbIssuer);

    Index %= IssuerCache.dwCacheSize;


    // 
    // Search through the cache entries at the computed index.
    // 

    timeNow = GetTickCount();

    RtlAcquireResourceShared(&IssuerCache.Lock, TRUE);

    pList = IssuerCache.Cache[Index].Flink;

    while(pList != &IssuerCache.Cache[Index])
    {
        pItem = CONTAINING_RECORD(pList, ISSUER_CACHE_ENTRY, IndexEntryList.Flink);
        pList = pList->Flink ;

        // Has this item expired?
        if(HasTimeElapsed(pItem->CreationTime, timeNow, IssuerCache.dwLifespan))
        {
            continue;
        }

        // Does the issuer name match?
        if(cbIssuer != pItem->cbIssuer)
        {
            continue;
        }
        if(memcmp(pbIssuer, pItem->pbIssuer, cbIssuer) != 0)
        {
            continue;
        }

        // Found item in cache!!
        fFound = TRUE;
        break;
    }

    RtlReleaseResource(&IssuerCache.Lock);

    return fFound;
}

void
SPExpireIssuerCacheElements(void)
{
    ISSUER_CACHE_ENTRY *pItem;
    PLIST_ENTRY pList;
    BOOL fDeleteEntry;
    DWORD timeNow;

    if(!IssuerCache.LockInitialized)
    {
        return;
    }

    if(IssuerCache.dwUsedEntries == 0)
    {
        return;
    }

    timeNow = GetTickCount();

    RtlAcquireResourceExclusive(&IssuerCache.Lock, TRUE);

    pList = IssuerCache.EntryList.Flink;

    while(pList != &IssuerCache.EntryList)
    {
        pItem = CONTAINING_RECORD(pList, ISSUER_CACHE_ENTRY, EntryList.Flink);
        pList = pList->Flink;

        fDeleteEntry = FALSE;

        // Mark all expired cache entries as non-resumable.
        if(HasTimeElapsed(pItem->CreationTime, timeNow, IssuerCache.dwLifespan))
        {
            fDeleteEntry = TRUE;
        }

        // If the cache has gotten too large, then expire elements early. The 
        // cache elements are sorted by creation time, so the oldest
        // entries will be expired first.
        if(IssuerCache.dwUsedEntries > IssuerCache.dwMaximumEntries)
        {
            fDeleteEntry = TRUE;
        }

        // Remove this entry from the cache.
        if(fDeleteEntry)
        {
            RemoveEntryList(&pItem->IndexEntryList);
            RemoveEntryList(&pItem->EntryList);
            IssuerCache.dwUsedEntries--;

            SPDeleteIssuerEntry(pItem);
        }
    }

    RtlReleaseResource(&IssuerCache.Lock);
}


void
SPAddIssuerToCache(
    PBYTE pbIssuer,
    DWORD cbIssuer)
{
    DWORD Index;
    DWORD timeNow;
    ISSUER_CACHE_ENTRY *pItem = NULL;

    if(pbIssuer == NULL || cbIssuer == 0)
    {
        return;
    }

    if(!IssuerCache.LockInitialized)
    {
        return;
    }

    //
    // Determine if the issuer is already in the cache. This isn't particularly
    // thread-safe, so it's possible that the same issuer might sneak into
    // the cache multiple times, but that's harmless.
    //

    if(SPFindIssuerInCache(pbIssuer, cbIssuer))
    {
        return;
    }


    // 
    // Compute the cache index.
    //

    Index = ComputeIssuerCacheIndex(pbIssuer, cbIssuer);

    Index %= IssuerCache.dwCacheSize;

    timeNow = GetTickCount();


    //
    // Allocate a new cache entry.
    //

    pItem = SPExternalAlloc(sizeof(ISSUER_CACHE_ENTRY));
    if(pItem == NULL)
    {
        SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        return;
    }

    //
    // Fill in the cache internal fields.
    //

    pItem->pbIssuer = SPExternalAlloc(cbIssuer);
    if(pItem->pbIssuer == NULL)
    {
        SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        SPExternalFree(pItem);
        return;
    }

    pItem->cbIssuer = cbIssuer;
    memcpy(pItem->pbIssuer, pbIssuer, cbIssuer);

    pItem->CreationTime    = timeNow;


    // 
    // Add the new entry to the cache.
    //

    LogDistinguishedName(DEB_TRACE, "Add to cache: %s\n", pbIssuer, cbIssuer);

    RtlAcquireResourceExclusive(&IssuerCache.Lock, TRUE);

    InsertTailList(&IssuerCache.Cache[Index], &pItem->IndexEntryList);
    InsertTailList(&IssuerCache.EntryList, &pItem->EntryList);
    IssuerCache.dwUsedEntries++;

    RtlReleaseResource(&IssuerCache.Lock);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\pct1cli.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       pct1cli.c
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <pct1msg.h>
#include <pct1prot.h>


VOID
Pct1ActivateSessionKeys(PSPContext pContext)
{
    if(pContext->hReadKey)
    {
        if(!CryptDestroyKey(pContext->hReadKey))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hReadKey = pContext->hPendingReadKey;

    if(pContext->hReadMAC)
    {
        if(!CryptDestroyKey(pContext->hReadMAC))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hReadMAC = pContext->hPendingReadMAC;

    if(pContext->hWriteKey)
    {
        if(!CryptDestroyKey(pContext->hWriteKey))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hWriteKey = pContext->hPendingWriteKey;

    if(pContext->hWriteMAC)
    {
        if(!CryptDestroyKey(pContext->hWriteMAC))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hWriteMAC = pContext->hPendingWriteMAC;

    pContext->hPendingReadKey   = 0;
    pContext->hPendingReadMAC   = 0;
    pContext->hPendingWriteKey  = 0;
    pContext->hPendingWriteMAC  = 0;
}

SP_STATUS WINAPI 
Pct1ClientProtocolHandler(PSPContext pContext,
    PSPBuffer  pCommInput,
    PSPBuffer  pCommOutput)
{
    SP_STATUS      pctRet= PCT_ERR_OK;
    DWORD           dwStateTransition;

    SP_BEGIN("Pct1ClientProtocolHandler");

    if(pCommOutput) pCommOutput->cbData = 0;

    /* Protocol handling steps should be listed in most common
     * to least common in order to improve performance 
     */

    /* We are not connected, so we're doing
     * protocol negotiation of some sort.  All protocol
     * negotiation messages are sent in the clear */
    /* There are no branches in the connecting protocol
     * state transition diagram, besides connection and error,
     * which means that a simple case statement will do */

    /* Do we have enough data to determine what kind of message we have */
    /* Do we have enough data to determine what kind of message we have, or how much data we need*/

    dwStateTransition = (pContext->State & 0xffff);

    if(pCommInput->cbData < 3) 
    {
        if(!(dwStateTransition == PCT1_STATE_RENEGOTIATE ||
             dwStateTransition == SP_STATE_SHUTDOWN      ||
             dwStateTransition == SP_STATE_SHUTDOWN_PENDING))
        {
            pctRet = PCT_INT_INCOMPLETE_MSG;
        }
    }
    else
    {

        dwStateTransition = (((PUCHAR)pCommInput->pvBuffer)[2]<<16) |
                          (pContext->State & 0xffff);
    }

    if(pctRet == PCT_ERR_OK)
    {
        switch(dwStateTransition)
        {
            case SP_STATE_SHUTDOWN_PENDING:
                // There's no CloseNotify in PCT, so just transition to
                // the shutdown state and leave the output buffer empty.
                pContext->State = SP_STATE_SHUTDOWN;
                break;    

            case SP_STATE_SHUTDOWN:
                return PCT_INT_EXPIRED;
    
            case PCT1_STATE_RENEGOTIATE:
            {
                SPBuffer    In;
                SPBuffer    Out;
                DWORD       cbMessage;
                BOOL        fAllocated = FALSE;

                cbMessage    =  pContext->pHashInfo->cbCheckSum +
                                pContext->pCipherInfo->dwBlockSize +
                                sizeof(PCT1_MESSAGE_HEADER_EX) +
                                PCT1_MAX_CLIENT_HELLO;

 
                /* are we allocating our own memory? */
                if(pCommOutput->pvBuffer == NULL) 
                {
                    pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
                    if (NULL == pCommOutput->pvBuffer)
                    {
                        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
                    }
                    fAllocated = TRUE;
                    pCommOutput->cbBuffer = cbMessage;
                }


                if(cbMessage > pCommOutput->cbBuffer)
                {
                    if(fAllocated)
                    {
                        SPExternalFree(pCommOutput->pvBuffer);
                        pCommOutput->pvBuffer = NULL;
                        SP_RETURN(PCT_INT_INTERNAL_ERROR);
                    }
                    pCommOutput->cbData = cbMessage;
                    SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
                }

                In.pvBuffer = ((char *)pCommOutput->pvBuffer)+3;
                In.cbBuffer = pCommOutput->cbBuffer-3;
                In.cbData = 1;
                
                ((char *)In.pvBuffer)[0] = PCT1_ET_REDO_CONN;

                // Build a Redo Request
                pctRet = Pct1EncryptRaw(pContext, &In, pCommOutput, PCT1_ENCRYPT_ESCAPE);
                if(pctRet != PCT_ERR_OK)
                {
                    if(fAllocated)
                    {
                        SPExternalFree(pCommOutput->pvBuffer);
                        pCommOutput->pvBuffer = NULL;
                    }
                    break;
                }
                Out.pvBuffer = (char *)pCommOutput->pvBuffer + pCommOutput->cbData;
                Out.cbBuffer = pCommOutput->cbBuffer - pCommOutput->cbData;

                // Mark context as "unmapped" so that the new keys will get
                // passed to the application process once the handshake is
                // completed.
                pContext->Flags &= ~CONTEXT_FLAG_MAPPED;

                if(!SPCacheClone(&pContext->RipeZombie))
                {
                    if(fAllocated)
                    {
                        SPExternalFree(pCommOutput->pvBuffer);
                        pCommOutput->pvBuffer = NULL;
                    }
                    SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
                }

                pctRet = GeneratePct1StyleHello(pContext, &Out);
                pCommOutput->cbData += Out.cbData;
                break;
            }

            /* Client receives Server hello */
            case (PCT1_MSG_SERVER_HELLO << 16) | UNI_STATE_CLIENT_HELLO:
            case (PCT1_MSG_SERVER_HELLO << 16) | PCT1_STATE_CLIENT_HELLO:
            {
                PPct1_Server_Hello pHello;
                /* Attempt to recognize and handle various versions
                 * of Server hello, start by trying to unpickle the
                 * oldest, and the next version, until
                 * one unpickles.  Then run the handle code.  We can also put
                 * unpickling and handling code in here for SSL messages */
                if(PCT_ERR_OK == (pctRet = Pct1UnpackServerHello(
                                                    pCommInput,
                                                    &pHello))) 
                {
                    /* let's resurrect the zombie session */
                    if (pHello->RestartOk) 
                    {
                        pctRet = Pct1CliRestart(pContext, pHello, pCommOutput);
                        if(PCT_ERR_OK == pctRet) 
                        {
                            pContext->State = SP_STATE_CONNECTED;
                            pContext->DecryptHandler = Pct1DecryptHandler;
                            pContext->Encrypt = Pct1EncryptMessage;
                            pContext->Decrypt = Pct1DecryptMessage;
                            pContext->GetHeaderSize = Pct1GetHeaderSize;

                        } 
                    } 
                    else 
                    {   
                        pContext->RipeZombie->fProtocol = SP_PROT_PCT1_CLIENT;

                        if(pContext->RipeZombie->hMasterKey != 0)
                        {
                            // We've attempted to do a reconnect and the server has
                            // blown us off. In this case we must use a new and different
                            // cache entry.
                            pContext->RipeZombie->ZombieJuju = FALSE;
                            if(!SPCacheClone(&pContext->RipeZombie))
                            {
                                pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
                            }
                        }

                        if(pctRet == PCT_ERR_OK)
                        {
                            pctRet = Pct1CliHandleServerHello(pContext,
                                                            pCommInput,
                                                            pHello,
                                                            pCommOutput);
                        }
                        if(PCT_ERR_OK == pctRet) 
                        {
                            pContext->State = PCT1_STATE_CLIENT_MASTER_KEY;
                            pContext->DecryptHandler = Pct1DecryptHandler;
                            pContext->Encrypt = Pct1EncryptMessage;     /* ?DCB? */
                            pContext->Decrypt = Pct1DecryptMessage;     /* ?DCB? */
                            pContext->GetHeaderSize = Pct1GetHeaderSize;

                        } 

                    }
                    SPExternalFree(pHello);

                }
                else if(pctRet != PCT_INT_INCOMPLETE_MSG)
                {
                    pctRet |= PCT_INT_DROP_CONNECTION;
                }

                if(SP_FATAL(pctRet)) 
                {
                    pContext->State = PCT1_STATE_ERROR;
                }

                break;
            }

            case (PCT1_MSG_SERVER_VERIFY << 16) | PCT1_STATE_CLIENT_MASTER_KEY:
                pctRet = Pct1CliHandleServerVerify(pContext,
                                                    pCommInput,
                                                    pCommOutput);
                if(SP_FATAL(pctRet)) 
                {
                    pContext->State = PCT1_STATE_ERROR;
                } 
                else 
                {
                    if(PCT_ERR_OK == pctRet) 
                    {
                        pContext->State = SP_STATE_CONNECTED;
                        pContext->DecryptHandler = Pct1DecryptHandler;
                        pContext->Encrypt = Pct1EncryptMessage;
                        pContext->Decrypt = Pct1DecryptMessage;
                        pContext->GetHeaderSize = Pct1GetHeaderSize;

                    } 
                    /* We received a non-fatal error, so the state doesn't
                     * change, giving the app time to deal with this */
                }
                break;

            default:
                pContext->State = PCT1_STATE_ERROR;
                {
                    pctRet = PCT_INT_ILLEGAL_MSG;
                    if(((PUCHAR)pCommInput->pvBuffer)[2] == PCT1_MSG_ERROR) 
                    {
                        /* we received an error message, process it */
                        pctRet = Pct1HandleError(pContext,
                                                 pCommInput,
                                                 pCommOutput);

                    } 
                    else 
                    {
                        /* we received an unknown error, generate a 
                         * PCT_ERR_ILLEGAL_MESSAGE */
                        pctRet = Pct1GenerateError(pContext, 
                                                    pCommOutput, 
                                                    PCT_ERR_ILLEGAL_MESSAGE, 
                                                    NULL);
                    }
                }

        }
    }
    if(pctRet & PCT_INT_DROP_CONNECTION) 
    {
        pContext->State &= ~SP_STATE_CONNECTED;
    }
    SP_RETURN(pctRet);
}



//+---------------------------------------------------------------------------
//
//  Function:   Pct1CheckForExistingCred
//
//  Synopsis:   Choose client certificate. Use one of the certificates
//              attached to the credential handle if possible. If the 
//              credential handle is anonymous, then attempt to create
//              a default credential.
//
//  Notes:      This routine is called by the client-side only.
//              
//  Returns:    PCT_ERR_OK      
//                  The function completed successfully. The
//                  pContext->pActiveClientCred field has been updated to
//                  point at a suitable client credential.
//
//              SEC_E_INCOMPLETE_CREDENTIALS
//                  No suitable certificate has been found. Notify the
//                  application.
//
//              SEC_I_INCOMPLETE_CREDENTIALS
//                  No suitable certificate has been found. Attempt an
//                  anonymous connection. 
//
//              <other>
//                  Fatal error.
//
//----------------------------------------------------------------------------
SP_STATUS
Pct1CheckForExistingCred(
    PSPContext pContext)
{
    SP_STATUS pctRet;

    //
    // Examine the certificates attached to the credential group and see
    // if any of them are suitable.
    //

    if(pContext->pCredGroup->CredCount != 0)
    {
        pctRet = SPPickClientCertificate(pContext, SP_EXCH_RSA_PKCS1);

        if(pctRet == PCT_ERR_OK)
        {
            // We found one.
            DebugLog((DEB_TRACE, "Application provided suitable client certificate.\n"));

            return PCT_ERR_OK;
        }

        // The credential group contained one or more certificates,
        // but none were suitable. Don't even try to find a default
        // certificate in this situation.
        goto error;
    }


    //
    // Attempt to acquire a default credential.
    //

    if(pContext->pCredGroup->dwFlags & CRED_FLAG_NO_DEFAULT_CREDS)
    {
        // Look in credential manager only.
        pctRet = AcquireDefaultClientCredential(pContext, TRUE);
    }
    else
    {
        // Look in both credential manager and MY certificate store.
        pctRet = AcquireDefaultClientCredential(pContext, FALSE);
    }

    if(pctRet == PCT_ERR_OK)
    {
        DebugLog((DEB_TRACE, "Default client certificate acquired.\n"));

        return PCT_ERR_OK;
    }


error:

    if(pContext->Flags & CONTEXT_FLAG_NO_INCOMPLETE_CRED_MSG)
    {
        return SP_LOG_RESULT(SEC_I_INCOMPLETE_CREDENTIALS);
    }
    else
    {
        return SP_LOG_RESULT(SEC_E_INCOMPLETE_CREDENTIALS);
    }
}


SP_STATUS Pct1CliHandleServerHello(PSPContext pContext,
                                   PSPBuffer  pCommInput,
                                   PPct1_Server_Hello pHello,
                                   PSPBuffer  pCommOutput)
{
    /* error to return to peer */
    SP_STATUS          pctRet=PCT_ERR_ILLEGAL_MESSAGE;

    PSessCacheItem     pZombie;
    PPct1_Client_Master_Key   pCMKey = NULL;
    SPBuffer           ErrData;

    DWORD               i, j;
    DWORD               fMismatch = 0;
    DWORD               cbClientCert = 0;   
    PBYTE               pbClientCert = NULL;
    BYTE                MisData[PCT_NUM_MISMATCHES];
    CertTypeMap LocalCertEncodingPref[5] ;
    DWORD cLocalCertEncodingPref = 0;

    BOOL                fClientAuth;
    PSigInfo            pSigInfo = NULL;

    DWORD               ClientCertSpec = 0;

    SP_BEGIN("Pct1CliHandleServerHello");

    pCommOutput->cbData = 0;

    /* validate the buffer configuration */
    ErrData.cbData = 0;
    ErrData.pvBuffer = NULL;
    ErrData.cbBuffer = 0;

    pZombie = pContext->RipeZombie;

#if DBG
    DebugLog((DEB_TRACE, "Hello = %x\n", pHello));
    DebugLog((DEB_TRACE, "   Restart\t%s\n", pHello->RestartOk ? "Yes":"No"));
    DebugLog((DEB_TRACE, "   ClientAuth\t%s\n",
              pHello->ClientAuthReq ? "Yes":"No"));
    DebugLog((DEB_TRACE, "   Certificate Type\t%x\n", pHello->SrvCertSpec));
    DebugLog((DEB_TRACE, "   Hash Type\t%x\n", pHello->SrvHashSpec));
    DebugLog((DEB_TRACE, "   Cipher Type\t%x (%s)\n", pHello->SrvCipherSpec,
    DbgGetNameOfCrypto(pHello->SrvCipherSpec)));
    DebugLog((DEB_TRACE, "   Certificate Len\t%ld\n", pHello->CertificateLen));
#endif


    CopyMemory(pContext->pConnectionID,
               pHello->ConnectionID,
               pHello->cbConnectionID);

    pContext->cbConnectionID = pHello->cbConnectionID;

    fClientAuth = pHello->ClientAuthReq;


    if(fClientAuth)
    {
        // If we're doing client auth, check to see if we have
        // proper credentials.

        /* Build a list of cert specs */
        for(i=0; i < cPct1CertEncodingPref; i++)
        {
            for(j=0; j< pHello->cCertSpecs; j++)
            {
                // Does the client want this cipher type
                if(aPct1CertEncodingPref[i].Spec == pHello->pClientCertSpecs[j])
                {
                    LocalCertEncodingPref[cLocalCertEncodingPref].Spec = aPct1CertEncodingPref[i].Spec;
                    LocalCertEncodingPref[cLocalCertEncodingPref++].dwCertEncodingType = aPct1CertEncodingPref[i].dwCertEncodingType;
                    break;
                }
            }
        }

        // Decide on a signature algorithm.
        for(i = 0; i < cPct1LocalSigKeyPref; i++)
        {
            for(j = 0; j < pHello->cSigSpecs; j++)
            {
                if(pHello->pClientSigSpecs[j] != aPct1LocalSigKeyPref[i].Spec)
                {
                    continue;
                }

                pSigInfo = GetSigInfo(pHello->pClientSigSpecs[j]);
                if(pSigInfo == NULL) continue;
                if((pSigInfo->fProtocol & SP_PROT_PCT1_CLIENT) == 0)
                {
                    continue;
                }
                break;
            }
            if(pSigInfo)
            {
                break;
            }
        }

        // Our PCT implementation only supports RSA client authentication.
        pContext->Ssl3ClientCertTypes[0] = SSL3_CERTTYPE_RSA_SIGN;
        pContext->cSsl3ClientCertTypes = 1;


        pctRet = Pct1CheckForExistingCred(pContext);

        if(pctRet == SEC_E_INCOMPLETE_CREDENTIALS)
        {
            // It's okay to return here as we haven't done anything 
            // yet.  We just need to return this error as a warning.
            SP_RETURN(SEC_I_INCOMPLETE_CREDENTIALS);
        }
        else if(pctRet != PCT_ERR_OK)
        {
            // Attempt to carry on without a certificate, and hope 
            // the server doesn't shut us down.
            fClientAuth = FALSE;
            pSigInfo = NULL;
            LogNoClientCertFoundEvent();
        }
        else
        {
            // We are doing client auth with a certificate. 
            // Check to see if we're doing CHAIN based certificates
            // by finding the first shared encoding type that matches
            // our certificate type. 

            for(i=0; i < cLocalCertEncodingPref; i++)
            {
           
                if(LocalCertEncodingPref[i].dwCertEncodingType == pContext->pActiveClientCred->pCert->dwCertEncodingType)
                {
                    ClientCertSpec = LocalCertEncodingPref[i].Spec;
                    if(LocalCertEncodingPref[i].Spec == PCT1_CERT_X509_CHAIN)
                    {
                        pContext->fCertChainsAllowed = TRUE;
                    }
                    break;
                }
            }

            // Get the client certificate chain.
            pctRet = SPSerializeCertificate(SP_PROT_PCT1, 
                                            pContext->fCertChainsAllowed,
                                            &pbClientCert, 
                                            &cbClientCert, 
                                            pContext->pActiveClientCred->pCert,
                                            CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL);
            if(pctRet != PCT_ERR_OK)
            {
                SP_RETURN(pctRet);
            }
        }
    }


    for(i=0; i < Pct1NumCipher; i++)
    {
        if(Pct1CipherRank[i].Spec == pHello->SrvCipherSpec)
        {
            // Store this cipher identifier in the cache
            pZombie->aiCipher   = Pct1CipherRank[i].aiCipher;
            pZombie->dwStrength = Pct1CipherRank[i].dwStrength;

            // Load the pending cipher structure.
            pContext->pPendingCipherInfo = GetCipherInfo(pZombie->aiCipher,
                                                         pZombie->dwStrength);

            if(!IsCipherAllowed(pContext, 
                                pContext->pPendingCipherInfo, 
                                pZombie->fProtocol,
                                pZombie->dwCF))
            {
                pContext->pPendingCipherInfo = NULL;
                continue;
            }
            break;

        }
    }

    for(i=0; i < Pct1NumHash; i++)
    {
        if(Pct1HashRank[i].Spec == pHello->SrvHashSpec)
        {
            // Store this hash id in the cache
            pZombie->aiHash = Pct1HashRank[i].aiHash;

            // Load the pending hash sturcture
            pContext->pPendingHashInfo = GetHashInfo(pZombie->aiHash);
            if(!IsHashAllowed(pContext, 
                              pContext->pPendingHashInfo,
                              pZombie->fProtocol))
            {
                pContext->pPendingHashInfo = NULL;
                continue;
            }
            break;

        }
    }
 
    for(i=0; i < cPct1LocalExchKeyPref; i++)
    {
        if(aPct1LocalExchKeyPref[i].Spec == pHello->SrvExchSpec)
        {
            // Store the exch id in the cache.
            pZombie->SessExchSpec = aPct1LocalExchKeyPref[i].Spec;

            // load the exch info structure
            pContext->pKeyExchInfo = GetKeyExchangeInfo(pZombie->SessExchSpec);

            if(!IsExchAllowed(pContext, 
                              pContext->pKeyExchInfo,
                              pZombie->fProtocol))
            {
                pContext->pKeyExchInfo = NULL;
                continue;
            }
            break;

        }
    }


    if (pContext->pPendingCipherInfo == NULL)
    {
        fMismatch |= PCT_IMIS_CIPHER;
        pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
        goto cleanup;
    }

    if (pContext->pPendingHashInfo == NULL)
    {
        fMismatch |= PCT_IMIS_HASH;
        pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
        goto cleanup;
    }

    if (pContext->pKeyExchInfo == NULL)
    {
        fMismatch |= PCT_IMIS_EXCH;
        pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
        goto cleanup;
    }
       

    // Determine the CSP to use, based on the key exchange algorithm.
    if(pContext->pKeyExchInfo->Spec != SP_EXCH_RSA_PKCS1)
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
        goto cleanup;
    }
    pContext->RipeZombie->hMasterProv = g_hRsaSchannel;

        
    // Go ahead and move the pending ciphers to active, and init them.
    pctRet = ContextInitCiphers(pContext, TRUE, TRUE);

    if(PCT_ERR_OK != pctRet)
    {
        goto cleanup;
    }


    /* we aren't restarting, so let's continue with the protocol. */

    /* Crack the server certificate */
    pctRet = SPLoadCertificate(pZombie->fProtocol, 
                             X509_ASN_ENCODING, 
                             pHello->pCertificate, 
                             pHello->CertificateLen,
                             &pZombie->pRemoteCert);
    if(pctRet != PCT_ERR_OK)
    {
        goto cleanup;
    }

    if(pContext->RipeZombie->pRemotePublic != NULL)
    {
        SPExternalFree(pContext->RipeZombie->pRemotePublic);
        pContext->RipeZombie->pRemotePublic = NULL;
    }

    pctRet = SPPublicKeyFromCert(pZombie->pRemoteCert,
                                 &pZombie->pRemotePublic,
                                 NULL);

    if(pctRet != PCT_ERR_OK)
    {
        goto cleanup;
    }


    // Automatically validate server certificate if appropriate 
    // context flag is set.
    pctRet = AutoVerifyServerCertificate(pContext);
    if(pctRet != PCT_ERR_OK)
    {
        SP_LOG_RESULT(pctRet);
        goto cleanup;
    }


    pZombie->pbServerCertificate = SPExternalAlloc(pHello->CertificateLen);
    pZombie->cbServerCertificate = pHello->CertificateLen;
    if(pZombie->pbServerCertificate == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }
    CopyMemory(pZombie->pbServerCertificate, pHello->pCertificate, pHello->CertificateLen);


    /* Create the verify prelude hashes */
    /* Which should look like  */
    /* Hash(CLIENT_MAC_KEY, Hash( "cvp", CLIENT_HELLO, SERVER_HELLO)) */
    /* Here we just do the inner hash */


    if(pContext->pClientHello == NULL) 
    {
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto cleanup;
    }

    pCMKey = (PPct1_Client_Master_Key)SPExternalAlloc(sizeof(Pct1_Client_Master_Key) + cbClientCert);

    if (NULL == pCMKey)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }


    // Generate Key Args
    if(pContext->pCipherInfo->dwBlockSize > 1)
    {
        pctRet = GenerateRandomBits(pZombie->pKeyArgs, pContext->pCipherInfo->dwBlockSize);
        if(!NT_SUCCESS(pctRet))
        {
            goto cleanup;
        }

        pZombie->cbKeyArgs = pCMKey->KeyArgLen = pContext->pCipherInfo->dwBlockSize;

        /* Copy over the key args */
        CopyMemory(pCMKey->KeyArg,
                    pZombie->pKeyArgs,
                    pZombie->cbKeyArgs );
    }
    else
    {    
        pCMKey->KeyArgLen = 0;
    }


    pctRet = pContext->pKeyExchInfo->System->GenerateClientExchangeValue(
                        pContext,
                        pHello->Response,
                        pHello->ResponseLen,
                        pCMKey->ClearKey,
                        &pCMKey->ClearKeyLen,
                        NULL,
                        &pCMKey->EncryptedKeyLen);
    if(PCT_ERR_OK != pctRet)
    {
        goto cleanup;
    }

    pCMKey->pbEncryptedKey = SPExternalAlloc(pCMKey->EncryptedKeyLen);
    if(pCMKey->pbEncryptedKey == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }

    pctRet = pContext->pKeyExchInfo->System->GenerateClientExchangeValue(
                        pContext,
                        pHello->Response,
                        pHello->ResponseLen,
                        pCMKey->ClearKey,
                        &pCMKey->ClearKeyLen,
                        pCMKey->pbEncryptedKey,
                        &pCMKey->EncryptedKeyLen);
    if(PCT_ERR_OK != pctRet)
    {
        goto cleanup;
    }

    pctRet = Pct1BeginVerifyPrelude(pContext, 
                           pContext->pClientHello,
                           pContext->cbClientHello,
                           pCommInput->pvBuffer,
                           pCommInput->cbData);
    if(PCT_ERR_OK != pctRet)
    {
        goto cleanup;
    }

    // Activate session keys.
    Pct1ActivateSessionKeys(pContext);

        
    pCMKey->VerifyPreludeLen = sizeof(pCMKey->VerifyPrelude);
    pctRet = Pct1EndVerifyPrelude(pContext, 
                                  pCMKey->VerifyPrelude, 
                                  &pCMKey->VerifyPreludeLen);

    if(PCT_ERR_OK != pctRet)
    {
        goto cleanup;
    }



    /* Choose a client cert */
    /* For each Cert the server understands, check to see if we */
    /* have that type of cert */

    pCMKey->ClientCertLen = 0;
    pCMKey->ClientCertSpec = 0;
    pCMKey->ClientSigSpec = 0;
    pCMKey->ResponseLen = 0;


    if(fClientAuth && pSigInfo != NULL)
    {

        // The client cert spec was already chosen
        // Also, pContext->fCertChainsAllowed will be
        // previously set if we're doing chains.
        pCMKey->ClientCertSpec = ClientCertSpec;
        pCMKey->ClientSigSpec = pSigInfo->Spec;

        pCMKey->pClientCert = (PUCHAR)(pCMKey+1);
        pCMKey->ClientCertLen = cbClientCert;
        memcpy(pCMKey->pClientCert, pbClientCert, cbClientCert);

        // Allocate memory for signature.
        pCMKey->ResponseLen = pContext->pActiveClientCred->pPublicKey->cbPublic;
        pCMKey->pbResponse  = SPExternalAlloc(pCMKey->ResponseLen);
        if(pCMKey->pbResponse == NULL)
        {
            pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }

        DebugLog((DEB_TRACE, "Sign client response.\n"));

        // Sign hash via a call to the application process.
        pctRet = SignHashUsingCallback(pContext->pActiveClientCred->hRemoteProv,
                                       pContext->pActiveClientCred->dwKeySpec,
                                       pSigInfo->aiHash,
                                       pCMKey->VerifyPrelude,
                                       pCMKey->VerifyPreludeLen,
                                       pCMKey->pbResponse,
                                       &pCMKey->ResponseLen,
                                       TRUE);
        if(pctRet != PCT_ERR_OK)
        {
            goto cleanup;
        }

        DebugLog((DEB_TRACE, "Client response signed successfully.\n"));

        // Convert signature to big endian.
        ReverseInPlace(pCMKey->pbResponse, pCMKey->ResponseLen);
    }

    pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    if(PCT_ERR_OK != (pctRet = Pct1PackClientMasterKey(pCMKey,
                                                       pCommOutput)))
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        goto cleanup;
    }

    pContext->WriteCounter++;


    pctRet = PCT_ERR_OK;

cleanup:

    if(pCMKey)
    {
        if(pCMKey->pbEncryptedKey)
        {
            SPExternalFree(pCMKey->pbEncryptedKey);
        }
        if(pCMKey->pbResponse)
        {
            SPExternalFree(pCMKey->pbResponse);
        }
        SPExternalFree(pCMKey);
    }

    if(pbClientCert)
    {
        SPExternalFree(pbClientCert);
    }

    if(pctRet != PCT_ERR_OK)
    {
        if(pctRet == PCT_ERR_SPECS_MISMATCH)
        {
            for(i=0;i<PCT_NUM_MISMATCHES;i++)
            {
                MisData[i] = (BYTE)(fMismatch & 1);
                fMismatch = fMismatch >> 1;
            }

            ErrData.cbData = ErrData.cbBuffer = PCT_NUM_MISMATCHES;
            ErrData.pvBuffer = MisData;
        }

        pctRet = Pct1GenerateError(pContext,
                                   pCommOutput,
                                   pctRet,
                                   &ErrData);

        pctRet |= PCT_INT_DROP_CONNECTION;
    }

    SP_RETURN(pctRet);
}



SP_STATUS
Pct1CliRestart(PSPContext  pContext,
              PPct1_Server_Hello pHello,
              PSPBuffer pCommOutput)
{
    SP_STATUS           pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    UCHAR               Response[RESPONSE_SIZE];
    DWORD               cbResponse;
    PPct1_Server_Hello  pLocalHello = pHello;
    PSessCacheItem      pZombie;

    SP_BEGIN("Pct1CliRestart");
    pZombie = pContext->RipeZombie;

    /* if there's no zombie, the message is wrong.  We can't restart. */
    
    if(pZombie == NULL)
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        goto error;
    }

    if(!pZombie->hMasterKey)
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        goto error;
    }

    if(!pZombie->ZombieJuju)
    {
        DebugLog((DEB_WARN, "Session expired on client machine, but not on server.\n"));
    }
    

    CopyMemory(pContext->pConnectionID,
               pHello->ConnectionID,
               pHello->cbConnectionID);

    pContext->cbConnectionID = pHello->cbConnectionID;

    //Init pending ciphers
    pctRet = ContextInitCiphersFromCache(pContext);

    if(PCT_ERR_OK != pctRet)
    {
        goto error;
    }

    // We know what our ciphers are, so init the cipher system
    pctRet = ContextInitCiphers(pContext, TRUE, TRUE);

    if(PCT_ERR_OK != pctRet)
    {
        goto error;
    }

    // Make a new set of session keys.
    pctRet = MakeSessionKeys(pContext,
                             pContext->RipeZombie->hMasterProv,
                             pContext->RipeZombie->hMasterKey);
    if(PCT_ERR_OK != pctRet)
    {
        goto error;
    }

    // Activate session keys.
    Pct1ActivateSessionKeys(pContext);

    pctRet = PCT_ERR_ILLEGAL_MESSAGE;

    DebugLog((DEB_TRACE, "Session Keys Made\n"));
    /* let's check the response in the message */

    /* check the length */
    if (pLocalHello->ResponseLen != pContext->pHashInfo->cbCheckSum) 
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        goto error;
    }

    /* calculate the correct response */
    cbResponse = sizeof(Response);
    pctRet = Pct1ComputeResponse(pContext, 
                                 pContext->pChallenge,
                                 pContext->cbChallenge,
                                 pContext->pConnectionID,
                                 pContext->cbConnectionID,
                                 pZombie->SessionID,
                                 pZombie->cbSessionID,
                                 Response,
                                 &cbResponse);
    if(pctRet != PCT_ERR_OK)
    {
        goto error;
    }

    /* check it against the response in the message */
    if (memcmp(Response, pLocalHello->Response, pLocalHello->ResponseLen)) 
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_SERVER_AUTH_FAILED);
        goto error;
    }

    /* ok, we're done, so let's jettison the auth data */
    pContext->ReadCounter = 1;
    pContext->WriteCounter = 1;

    /* fini. */
    SP_RETURN(PCT_ERR_OK);


error:

    pctRet = Pct1GenerateError(pContext,
                              pCommOutput,
                              pctRet,
                              NULL);

    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);
}




SP_STATUS 
Pct1CliHandleServerVerify(
    PSPContext pContext,
    PSPBuffer  pCommInput,
    PSPBuffer  pCommOutput)
{
    SP_STATUS           pctRet;
    PPct1_Server_Verify pVerify = NULL;
    SPBuffer            ErrData;
    PSessCacheItem      pZombie;
    UCHAR               Response[RESPONSE_SIZE];
    DWORD               cbResponse;


    SP_BEGIN("Pct1CliHandleServerVerify");

    pZombie = pContext->RipeZombie;
    pContext->ReadCounter = 2;
    pContext->WriteCounter = 2;

    pCommOutput->cbData = 0;

    ErrData.cbData = 0;
    ErrData.pvBuffer = NULL;
    ErrData.cbBuffer = 0;

    /* unpack the message */
    pctRet = Pct1UnpackServerVerify(pCommInput, &pVerify);
    if (PCT_ERR_OK != pctRet)
    {
        // If it's an incomplete message or something, just return;
        if(!SP_FATAL(pctRet))
        {
            SP_RETURN(pctRet);
        }
        goto error;
    }

    // compute the correct response
    cbResponse = sizeof(Response);
    pctRet = Pct1ComputeResponse(pContext,
                                 pContext->pChallenge,
                                 pContext->cbChallenge,
                                 pContext->pConnectionID,
                                 pContext->cbConnectionID,
                                 pVerify->SessionIdData,
                                 PCT_SESSION_ID_SIZE,
                                 Response,
                                 &cbResponse);
    if(pctRet != PCT_ERR_OK)
    {
        SP_LOG_RESULT(pctRet);
        goto error;
    }

    if(pVerify->ResponseLen != cbResponse ||
       memcmp(pVerify->Response, Response, pVerify->ResponseLen))
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        goto error;
    }

    CopyMemory(pZombie->SessionID, 
               pVerify->SessionIdData,
               PCT_SESSION_ID_SIZE);

    pZombie->cbSessionID = PCT_SESSION_ID_SIZE;

    /* done with the verify data */
    SPExternalFree(pVerify);
    pVerify = NULL;

    /* set up the session in cache */
    SPCacheAdd(pContext);

    SP_RETURN( PCT_ERR_OK );


error:

    if(pVerify) SPExternalFree(pVerify);

    pctRet = Pct1GenerateError(pContext,
                              pCommOutput,
                              pctRet,
                              NULL);

    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);
}

SP_STATUS 
WINAPI
GeneratePct1StyleHello(
    PSPContext             pContext,
    PSPBuffer              pOutput)
{
    Pct1_Client_Hello   HelloMessage;
    PSessCacheItem      pZombie;
    CipherSpec          aCipherSpecs[10];
    HashSpec            aHashSpecs[10];
    CertSpec            aCertSpecs[10];
    ExchSpec            aExchSpecs[10];
    DWORD i;

    SP_STATUS pctRet = PCT_INT_INTERNAL_ERROR;

    SP_BEGIN("Pct1CliInstigateHello");

    HelloMessage.pCipherSpecs = aCipherSpecs;
    HelloMessage.pHashSpecs = aHashSpecs;
    HelloMessage.pCertSpecs = aCertSpecs;
    HelloMessage.pExchSpecs = aExchSpecs;

    if(pContext == NULL) 
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    if (!pOutput)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pZombie = pContext->RipeZombie;


    pContext->Flags |= CONTEXT_FLAG_CLIENT;

    pctRet = GenerateRandomBits(pContext->pChallenge, PCT1_CHALLENGE_SIZE);
    if(!NT_SUCCESS(pctRet))
    {
        SP_RETURN(SP_LOG_RESULT(pctRet));
    }

    pContext->cbChallenge = PCT1_CHALLENGE_SIZE;
    /* Build the hello message. */

    HelloMessage.cbChallenge = PCT1_CHALLENGE_SIZE;
    HelloMessage.pKeyArg = NULL;
    HelloMessage.cbKeyArgSize = 0;


    HelloMessage.cCipherSpecs = 0;
    for(i=0; i < Pct1NumCipher; i++)
    {
        PCipherInfo pCipherInfo;
        pCipherInfo = GetCipherInfo(Pct1CipherRank[i].aiCipher, Pct1CipherRank[i].dwStrength);
        if(IsCipherAllowed(pContext, 
                           pCipherInfo, 
                           pContext->dwProtocol,
                           pContext->dwRequestedCF))
        {
            HelloMessage.pCipherSpecs[HelloMessage.cCipherSpecs++] = Pct1CipherRank[i].Spec;
        }
    }

    HelloMessage.cHashSpecs = 0;
    for(i=0; i < Pct1NumHash; i++)
    {
        PHashInfo pHashInfo;
        pHashInfo = GetHashInfo(Pct1HashRank[i].aiHash);
        if(IsHashAllowed(pContext, 
                         pHashInfo,
                         pContext->dwProtocol))
        {
            HelloMessage.pHashSpecs[HelloMessage.cHashSpecs++] = Pct1HashRank[i].Spec;
        }

    }

    HelloMessage.cCertSpecs = 0;
    for(i=0; i < cPct1CertEncodingPref; i++)
    { 
        PCertSysInfo pCertInfo = GetCertSysInfo(aPct1CertEncodingPref[i].dwCertEncodingType);

        if(pCertInfo == NULL)
        {
            continue;
        }
        // Is this cert type enabled?
        if(0 == (pCertInfo->fProtocol & SP_PROT_PCT1_CLIENT))
        {
            continue;
        }

        HelloMessage.pCertSpecs[HelloMessage.cCertSpecs++] = aPct1CertEncodingPref[i].Spec;

    }

    HelloMessage.cExchSpecs = 0;
    for(i=0; i < cPct1LocalExchKeyPref; i++)
    {
        PKeyExchangeInfo pExchInfo;
        pExchInfo = GetKeyExchangeInfo(aPct1LocalExchKeyPref[i].Spec);
        if(IsExchAllowed(pContext, 
                         pExchInfo,
                         pContext->dwProtocol))
        {
            HelloMessage.pExchSpecs[HelloMessage.cExchSpecs++] = aPct1LocalExchKeyPref[i].Spec;
        }
    }


    if (pZombie->cbSessionID)
    {
        CopyMemory(HelloMessage.SessionID, pZombie->SessionID, pZombie->cbSessionID);
        HelloMessage.cbSessionID = pZombie->cbSessionID;
    }
    else
    {
        FillMemory(HelloMessage.SessionID, PCT_SESSION_ID_SIZE, 0);
        HelloMessage.cbSessionID = PCT_SESSION_ID_SIZE;
    }

    CopyMemory(  HelloMessage.Challenge,
                pContext->pChallenge,
                HelloMessage.cbChallenge );
    HelloMessage.cbChallenge = pContext->cbChallenge;

    pctRet = Pct1PackClientHello(&HelloMessage,  pOutput);

    if(PCT_ERR_OK != pctRet)
    {
        SP_RETURN(pctRet);
    }


    // Save the ClientHello message so we can hash it later, once
    // we know what algorithm and CSP we're using.
    if(pContext->pClientHello)
    {
        SPExternalFree(pContext->pClientHello);
    }
    pContext->pClientHello = SPExternalAlloc(pOutput->cbData);
    if(pContext->pClientHello == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
    }
    CopyMemory(pContext->pClientHello, pOutput->pvBuffer, pOutput->cbData);
    pContext->cbClientHello = pOutput->cbData;
    pContext->dwClientHelloProtocol = SP_PROT_PCT1_CLIENT;


    /* We set this here to tell the protocol engine that we just send a client
     * hello, and we're expecting a pct server hello */
    pContext->State = PCT1_STATE_CLIENT_HELLO;
    SP_RETURN(PCT_ERR_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\oidenc.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1996
//
//  File:	    oidenc.c
//
//  Contents:   SCHANNEL encode/decode functions
//
//              ASN.1 implementation uses the Asn1 compiler.
//
//  Functions:  InitSchannelAsn1
//              ShutdownSchannelAsn1
//
//  History:	03-Dec-98	philh   changed to use msasn1
//
//--------------------------------------------------------------------------


#include <spbase.h>
#include <pkiasn1.h>
#include <crypttls.h>
#include <oidenc.h>
#include "asn1enc.h"

// Nonstandard extension, function/data pointer conversion in expression
#pragma warning (disable: 4152)

VOID
ReverseMemCopy(
    PUCHAR      Dest,
    PUCHAR      Source,
    ULONG       Size) ;

#define PRIVATE_KEY_TAG "private-key"


// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

static HCRYPTASN1MODULE hAsn1Module;

//+-------------------------------------------------------------------------
//  Function:  GetEncoder/GetDecoder
//
//  Synopsis:  Initialize thread local storage for the asn libs
//
//  Returns:   pointer to an initialized Asn1 encoder/decoder data
//             structures
//--------------------------------------------------------------------------
static ASN1encoding_t GetEncoder(void)
{
    return I_CryptGetAsn1Encoder(hAsn1Module);
}
static ASN1decoding_t GetDecoder(void)
{
    return I_CryptGetAsn1Decoder(hAsn1Module);
}

//+-------------------------------------------------------------------------
//  Asn1 SCHANNEL Private Encode/Decode functions
//--------------------------------------------------------------------------

BOOL
WINAPI
Asn1RSAPublicEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PUBLICKEYSTRUC *pbKeyStruc,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

BOOL
WINAPI
Asn1PrivateKeyFileEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PPRIVATE_KEY_FILE_ENCODE pKey,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

BOOL
WINAPI
Asn1PrivateKeyFileDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PPRIVATE_KEY_FILE_ENCODE pKey,
        IN OUT DWORD *pcbKey
        );


BOOL
WINAPI
Asn1PrivateKeyInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BLOBHEADER * pKey,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );

BOOL
WINAPI
Asn1PrivateKeyInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BLOBHEADER * pKey,
        IN OUT DWORD *pcbKey
        );

static BOOL WINAPI Asn1X509CtlUsageDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pInfo,
        IN OUT DWORD *pcbInfo
        );


static const CRYPT_OID_FUNC_ENTRY SchannelEncodeFuncTable[] = {
    szPrivateKeyFileEncode, Asn1PrivateKeyFileEncode,
    szPrivateKeyInfoEncode, Asn1PrivateKeyInfoEncode,
    szOID_RSA_RSA_Public,   Asn1RSAPublicEncode
};

#define SCHANNEL_ENCODE_FUNC_COUNT (sizeof(SchannelEncodeFuncTable) / \
                                    sizeof(SchannelEncodeFuncTable[0]))


static const CRYPT_OID_FUNC_ENTRY SchannelDecodeFuncTable[] = {
    szPrivateKeyFileEncode,                 Asn1PrivateKeyFileDecode,
    szPrivateKeyInfoEncode,                 Asn1PrivateKeyInfoDecode,
    X509_ENHANCED_KEY_USAGE,                Asn1X509CtlUsageDecode
};

#define SCHANNEL_DECODE_FUNC_COUNT (sizeof(SchannelDecodeFuncTable) / \
                                    sizeof(SchannelDecodeFuncTable[0]))


//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
InitSchannelAsn1(
        HMODULE hModule)
{
    ASN1ENC_Module_Startup();
    if (0 == (hAsn1Module = I_CryptInstallAsn1Module(ASN1ENC_Module, 0, NULL)))
    {
        return FALSE;
    }

    if (!CryptInstallOIDFunctionAddress(
            hModule,
            X509_ASN_ENCODING,
            CRYPT_OID_DECODE_OBJECT_FUNC,
            SCHANNEL_DECODE_FUNC_COUNT,
            SchannelDecodeFuncTable,
            0))
    {
        return FALSE;
    }

    if (!CryptInstallOIDFunctionAddress(
            hModule,
            X509_ASN_ENCODING,
            CRYPT_OID_ENCODE_OBJECT_FUNC,
            SCHANNEL_ENCODE_FUNC_COUNT,
            SchannelEncodeFuncTable,
            0))
    {
        return FALSE;
    }
    return TRUE;
}

BOOL
WINAPI
ShutdownSchannelAsn1()
{
    if (hAsn1Module)
    {
        I_CryptUninstallAsn1Module(hAsn1Module);
        ASN1ENC_Module_Cleanup();
        hAsn1Module = 0;
    }

    return TRUE;
}


//+-------------------------------------------------------------------------
//  Encode an Asn1 formatted info structure
//
//  Called by the Asn1X509*Encode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoEncode(
        IN int pdunum,
        IN void *pAsn1Info,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    ASN1encoding_t Encoder;
    
    if((Encoder = GetEncoder()) == NULL) 
    {
        return FALSE;
    }

    return PkiAsn1EncodeInfo(
        Encoder,
        pdunum,
        pAsn1Info,
        pbEncoded,
        pcbEncoded);
}

//+-------------------------------------------------------------------------
//  Encode an Asn1 formatted info structure
//
//  Called by the Asn1X509*Encode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoEncodeAndAlloc(
        IN int pdunum,
        IN void *pAsn1Info,
        OUT BYTE **ppEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    ASN1encoding_t Encoder;
    
    if((Encoder = GetEncoder()) == NULL) 
    {
        return FALSE;
    }

    if(!PkiAsn1EncodeInfo(
        Encoder,
        pdunum,
        pAsn1Info,
        NULL,
        pcbEncoded))
    {
        return FALSE;
    }
    *ppEncoded = SPExternalAlloc(*pcbEncoded);
    if(*ppEncoded == NULL)
    {
        return FALSE;
    }
    if(!PkiAsn1EncodeInfo(
        Encoder,
        pdunum,
        pAsn1Info,
        *ppEncoded,
        pcbEncoded))
    {
        SPExternalFree(*ppEncoded);
        return FALSE;
    }
    return TRUE;

}

//+-------------------------------------------------------------------------
//  Decode into an allocated, Asn1 formatted info structure
//
//  Called by the Asn1X509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL Asn1InfoDecodeAndAlloc(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppAsn1Info
        )
{
    ASN1decoding_t Decoder;
    
    if((Decoder = GetDecoder()) == NULL) 
    {
        return FALSE;
    }

    return PkiAsn1DecodeAndAllocInfo(
        Decoder,
        pdunum,
        pbEncoded,
        cbEncoded,
        ppAsn1Info);
}

//+-------------------------------------------------------------------------
//  Free an allocated, Asn1 formatted info structure
//
//  Called by the Asn1X509*Decode() functions.
//--------------------------------------------------------------------------
static void Asn1InfoFree(
        IN int pdunum,
        IN void *pAsn1Info
        )
{
    ASN1decoding_t Decoder;
    
    if((Decoder = GetDecoder()) == NULL) 
    {
        return;
    }

    if (pAsn1Info) 
    {
        DWORD dwErr = GetLastError();

        // TlsGetValue globbers LastError
        PkiAsn1FreeInfo(Decoder, pdunum, pAsn1Info);

        SetLastError(dwErr);
    }
}

SP_STATUS
RsaPublicKeyFromCert(
    PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
    BLOBHEADER *pBlob,
    PDWORD      pcbBlob)
{
    SP_STATUS pctRet;

    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          RSA_CSP_PUBLICKEYBLOB,
                          pPublicKeyInfo->PublicKey.pbData,
                          pPublicKeyInfo->PublicKey.cbData,
                          0,
                          pBlob,
                          pcbBlob))
    {
        pctRet = GetLastError();
        return SP_LOG_RESULT(pctRet);
    }

    return PCT_ERR_OK;
}


/*****************************************************************************/
SP_STATUS
DssPublicKeyFromCert(
    PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
    BLOBHEADER *pBlob,
    PDWORD      pcbBlob)
{
    CRYPT_UINT_BLOB *pPublic = NULL;
    DWORD cbPublic;
    CERT_DSS_PARAMETERS *pParams = NULL;
    DWORD cbParams;
    DSSPUBKEY *pDssPubKey = NULL;
    DSSSEED *pSeed = NULL;
    PBYTE pbData = NULL;
    DWORD cbBlob;
    DWORD cbRequired;
    DWORD cbPadding;
    SP_STATUS pctRet;

    //
    // Estimate size of DSS public key blob.
    //

    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          X509_DSS_PUBLICKEY,
                          pPublicKeyInfo->PublicKey.pbData,
                          pPublicKeyInfo->PublicKey.cbData,
                          0,
                          NULL,
                          &cbPublic))
    {
        pctRet = GetLastError();
        return SP_LOG_RESULT(pctRet);
    }

    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          X509_DSS_PARAMETERS,
                          pPublicKeyInfo->Algorithm.Parameters.pbData,
                          pPublicKeyInfo->Algorithm.Parameters.cbData,
                          0,
                          NULL,
                          &cbParams))
    {
        pctRet = GetLastError();
        return SP_LOG_RESULT(pctRet);
    }

    cbBlob = sizeof(BLOBHEADER) + 
             sizeof(DSSPUBKEY) + 
             cbPublic + 
             cbParams +
             sizeof(DSSSEED);

    if(pBlob == NULL)
    {
        *pcbBlob = cbBlob;
        return PCT_ERR_OK;
    }
    if(*pcbBlob < cbBlob)
    {
        *pcbBlob = cbBlob;
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }


    // 
    // Decode public key info.
    //

    pPublic = SPExternalAlloc(cbPublic + cbParams);
    if(pPublic == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }
    pParams = (CERT_DSS_PARAMETERS *)((PBYTE)pPublic + cbPublic);


    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          X509_DSS_PUBLICKEY,
                          pPublicKeyInfo->PublicKey.pbData,
                          pPublicKeyInfo->PublicKey.cbData,
                          0,
                          pPublic,
                          &cbPublic))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }

    if(!CryptDecodeObject(X509_ASN_ENCODING,
                          X509_DSS_PARAMETERS,
                          pPublicKeyInfo->Algorithm.Parameters.pbData,
                          pPublicKeyInfo->Algorithm.Parameters.cbData,
                          0,
                          pParams,
                          &cbParams))
    {
        pctRet = SP_LOG_RESULT(GetLastError());
        goto cleanup;
    }


    //
    // Double check size of memory allocated for blob. The G and Y 
    // components may need to be padded out a little bit, but this
    // should always be less than the overhead in the params structure.
    // It doesn't hurt to make sure, though.
    //

    cbRequired = sizeof(BLOBHEADER) + 
                 sizeof(DSSPUBKEY) + 
                 pParams->p.cbData + 
                 pParams->q.cbData + 
                 max(pParams->p.cbData, pParams->g.cbData) +
                 max(pParams->p.cbData, pPublic->cbData) +
                 sizeof(DSSSEED);

    if(cbBlob < cbRequired)
    {
        *pcbBlob = cbRequired;
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }


    // 
    // Build PUBLICKEYBLOB
    //

    pBlob->bType    = PUBLICKEYBLOB;
    pBlob->bVersion = CUR_BLOB_VERSION;
    pBlob->reserved = 0;
    pBlob->aiKeyAlg = CALG_DSS_SIGN;

    pDssPubKey = (DSSPUBKEY *)(pBlob + 1);
    pDssPubKey->magic  = MAGIC_DSS1;
    pDssPubKey->bitlen = pPublic->cbData * 8;

    pbData = (PBYTE)(pDssPubKey + 1);

    CopyMemory(pbData, pParams->p.pbData, pParams->p.cbData);
    pbData += pParams->p.cbData;

    CopyMemory(pbData, pParams->q.pbData, pParams->q.cbData);
    pbData += pParams->q.cbData;

    CopyMemory(pbData, pParams->g.pbData, pParams->g.cbData);
    pbData += pParams->g.cbData;

    if(pParams->g.cbData < pParams->p.cbData)
    {
        cbPadding = pParams->p.cbData - pParams->g.cbData;
        ZeroMemory(pbData, cbPadding);
        pbData += cbPadding;
    }

    CopyMemory(pbData, pPublic->pbData, pPublic->cbData);
    pbData += pPublic->cbData;

    if(pPublic->cbData < pParams->p.cbData)
    {
        cbPadding = pParams->p.cbData - pPublic->cbData;
        ZeroMemory(pbData, cbPadding);
        pbData += cbPadding;
    }

    pSeed = (DSSSEED *)pbData;
    pSeed->counter = 0xffffffff;
    ZeroMemory(pSeed->seed, sizeof(pSeed->seed));
    pbData += sizeof(DSSSEED);


    *pcbBlob = (DWORD)((PBYTE)pbData - (PBYTE)pBlob);


    pctRet = PCT_ERR_OK;

cleanup:

    if(pPublic) SPExternalFree(pPublic);

    return pctRet;
}


#define  my_isdigit(ch) ((ch >= '0') && (ch <= '9'))

//+-------------------------------------------------------------------------
//  Convert the ascii string ("1.2.9999") to Asn1's Object Identifier
//  represented as an array of unsigned longs.
//
//  Returns TRUE for a successful conversion.
//--------------------------------------------------------------------------
BOOL
WINAPI
OIDFromString(
    IN LPCSTR pszObjId,
    IN OUT unsigned short *pCount,
    OUT unsigned long rgulValue[]
    )
{
    BOOL fResult = TRUE;
    unsigned short c = 0;
    LPSTR psz = (LPSTR) pszObjId;
    if (psz) {
        unsigned short cMax = *pCount;
        unsigned long *pul = rgulValue;
        while (*psz != '\0' && c++ < cMax) {
            *pul = 0;
            while (my_isdigit(*psz))
            {
                *pul = ((*pul) * 10) + (*psz++) - '0';
            }
            pul++;
            if (*psz != '.')
                break;
            psz++;
        }
        if (*psz != '\0')
            fResult = FALSE;
    }
    *pCount = c;
    return fResult;
}

BOOL
WINAPI
Asn1PrivateKeyInfoEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BLOBHEADER * pKey,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    PrivateKeyInfo KeyInfo;
    BOOL fRet;

    UNREFERENCED_PARAMETER(dwCertEncodingType);
    UNREFERENCED_PARAMETER(lpszStructType);

    // First encode the private key data, depending on
    // the algorithm.
    switch(pKey->aiKeyAlg)
    {
    case CALG_RSA_SIGN:
    case CALG_RSA_KEYX:
        {
            RSAPUBKEY *pRsaPub = (RSAPUBKEY *)(pKey+1);
            RSAPrivateKey RsaPrivate;
            PBYTE   pbRsaBlob, pbRsaBlobSav;
            PBYTE   pbDataBlob = NULL, pbDataBlobSav;
            DWORD   dwDataBlob = 0;

            // Covert the RSA key into the RSAPrivateKey structure
            RsaPrivate.version = 0;
            dwDataBlob = (9 * (pRsaPub->bitlen/16)) + 7 ;
            pbDataBlobSav = pbDataBlob = SPExternalAlloc(dwDataBlob);
            if(pbDataBlob == NULL)
            {
                return FALSE;
            }

            //Copy Modulus
            *pbDataBlob = 0;
            pbRsaBlobSav = pbRsaBlob = (PBYTE)(pRsaPub+1);
            CopyMemory(pbDataBlob+1, pbRsaBlob, pRsaPub->bitlen/8);
            PkiAsn1ReverseBytes(pbDataBlob + 1, pRsaPub->bitlen/8);

            RsaPrivate.modulus.value = pbDataBlob;
            RsaPrivate.modulus.length = (pRsaPub->bitlen/8) + 1;
            pbDataBlob += (pRsaPub->bitlen/8) + 1;
            pbRsaBlob += (pRsaPub->bitlen/8);

            RsaPrivate.publicExponent = pRsaPub->pubexp;

            //Copy Prime1
            *pbDataBlob = 0;
            CopyMemory(pbDataBlob+1, pbRsaBlob, pRsaPub->bitlen/16);
            PkiAsn1ReverseBytes(pbDataBlob + 1, pRsaPub->bitlen/16);

            RsaPrivate.prime1.value = pbDataBlob;
            RsaPrivate.prime1.length = (pRsaPub->bitlen/16) + 1;
            pbDataBlob += (pRsaPub->bitlen/16) + 1;
            pbRsaBlob += (pRsaPub->bitlen/16);

            //Copy Prime2
            *pbDataBlob = 0;
            CopyMemory(pbDataBlob+1, pbRsaBlob, pRsaPub->bitlen/16);
            PkiAsn1ReverseBytes(pbDataBlob + 1, pRsaPub->bitlen/16);

            RsaPrivate.prime2.value = pbDataBlob;
            RsaPrivate.prime2.length = (pRsaPub->bitlen/16) + 1;
            pbDataBlob += (pRsaPub->bitlen/16) + 1;
            pbRsaBlob += (pRsaPub->bitlen/16);


            //Copy exponent1
            *pbDataBlob = 0;
            CopyMemory(pbDataBlob+1, pbRsaBlob, pRsaPub->bitlen/16);
            PkiAsn1ReverseBytes(pbDataBlob + 1, pRsaPub->bitlen/16);

            RsaPrivate.exponent1.value = pbDataBlob;
            RsaPrivate.exponent1.length = (pRsaPub->bitlen/16) + 1;
            pbDataBlob += (pRsaPub->bitlen/16) + 1;
            pbRsaBlob += (pRsaPub->bitlen/16);

            //Copy exponent2
            *pbDataBlob = 0;
            CopyMemory(pbDataBlob+1, pbRsaBlob, pRsaPub->bitlen/16);
            PkiAsn1ReverseBytes(pbDataBlob + 1, pRsaPub->bitlen/16);

            RsaPrivate.exponent2.value = pbDataBlob;
            RsaPrivate.exponent2.length = (pRsaPub->bitlen/16) + 1;
            pbDataBlob += (pRsaPub->bitlen/16) + 1;
            pbRsaBlob += (pRsaPub->bitlen/16);

            //Copy coefficient
            *pbDataBlob = 0;
            CopyMemory(pbDataBlob+1, pbRsaBlob, pRsaPub->bitlen/16);
            PkiAsn1ReverseBytes(pbDataBlob + 1, pRsaPub->bitlen/16);

            RsaPrivate.coefficient.value = pbDataBlob;
            RsaPrivate.coefficient.length = (pRsaPub->bitlen/16) + 1;
            pbDataBlob += (pRsaPub->bitlen/16) + 1;
            pbRsaBlob += (pRsaPub->bitlen/16);

            //Copy privateExponent
            *pbDataBlob = 0;
            CopyMemory(pbDataBlob+1, pbRsaBlob, pRsaPub->bitlen/8);
            PkiAsn1ReverseBytes(pbDataBlob + 1, pRsaPub->bitlen/8);

            RsaPrivate.privateExponent.value = pbDataBlob;
            RsaPrivate.privateExponent.length = (pRsaPub->bitlen/8) + 1;
            pbDataBlob += (pRsaPub->bitlen/8) + 1;
            pbRsaBlob += (pRsaPub->bitlen/8);


            fRet = Asn1InfoEncodeAndAlloc(RSAPrivateKey_PDU,
                                 &RsaPrivate,
                                 &KeyInfo.privateKey.value,
                                 &KeyInfo.privateKey.length);
            SPExternalFree(pbDataBlobSav);
            if(!fRet)
            {
                return FALSE;
            }
            KeyInfo.privateKeyAlgorithm.bit_mask = 0;
            KeyInfo.privateKeyAlgorithm.algorithm.count =sizeof(KeyInfo.privateKeyAlgorithm.algorithm.value)/sizeof(KeyInfo.privateKeyAlgorithm.algorithm.value[0]);


            fRet = OIDFromString(  szOID_RSA_RSA,
                                        &KeyInfo.privateKeyAlgorithm.algorithm.count,
                                        KeyInfo.privateKeyAlgorithm.algorithm.value);
            if(!fRet)
            {
                SPExternalFree(KeyInfo.privateKey.value);
                return FALSE;
            }

            break;
      }

    default:
        return FALSE;
    }

    // Set up the KeyInfo struct
    KeyInfo.bit_mask = 0;
    KeyInfo.version = 0;

    fRet =  Asn1InfoEncode(
        PrivateKeyInfo_PDU,
        &KeyInfo,
        pbEncoded,
        pcbEncoded
        );

    SPExternalFree(KeyInfo.privateKey.value);
    return fRet;
}

BOOL
WINAPI
Asn1PrivateKeyFileEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PPRIVATE_KEY_FILE_ENCODE pKey,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{

    PrivateKeyFile File;
    BOOL fRet;

    UNREFERENCED_PARAMETER(dwCertEncodingType);
    UNREFERENCED_PARAMETER(lpszStructType);

    File.privateKey.privateKey.value = pKey->EncryptedBlob.pbData;
    File.privateKey.privateKey.length = pKey->EncryptedBlob.cbData;

    File.privateKey.privateKeyAlgorithm.bit_mask = 0;
    File.privateKey.privateKeyAlgorithm.algorithm.count = sizeof(File.privateKey.privateKeyAlgorithm.algorithm.value)/sizeof(File.privateKey.privateKeyAlgorithm.algorithm.value[0]);

    OIDFromString(  pKey->Alg.pszObjId,
                    &File.privateKey.privateKeyAlgorithm.algorithm.count,
                    File.privateKey.privateKeyAlgorithm.algorithm.value);

    File.name.value = (ASN1octet_t *)PRIVATE_KEY_TAG;
    File.name.length = lstrlen(PRIVATE_KEY_TAG);

    fRet =  Asn1InfoEncode(
        PrivateKeyFile_PDU,
        &File,
        pbEncoded,
        pcbEncoded
        );

    return fRet;

}


BOOL
WINAPI
Asn1PrivateKeyInfoDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BLOBHEADER *pKey,
        IN OUT DWORD *pcbKey
        )

{
    PrivateKeyInfo *pKeyInfo = NULL;
    DWORD cbKey;
    DWORD cbMod;

    BOOL fResult = FALSE;

    UNREFERENCED_PARAMETER(dwCertEncodingType);
    UNREFERENCED_PARAMETER(lpszStructType);
    UNREFERENCED_PARAMETER(dwFlags);

    // Now crack the key info
    fResult = Asn1InfoDecodeAndAlloc(PrivateKeyInfo_PDU,
                                        pbEncoded,
                                        cbEncoded,
                                        (void **)&pKeyInfo);
    if(!fResult)
    {
        return FALSE;
    }



    fResult = FALSE;
    do
    {
        USHORT cbOID;
        DWORD psOID[16];

        cbOID = sizeof(psOID)/sizeof(psOID[0]);

        OIDFromString(  szOID_RSA_RSA,
                        &cbOID,
                        psOID);

        if((cbOID == pKeyInfo->privateKeyAlgorithm.algorithm.count) &&
            (memcmp(pKeyInfo->privateKeyAlgorithm.algorithm.value, psOID, cbOID*sizeof(psOID[0]))==0))
        {
            RSAPUBKEY *     pRsaPub;
            RSAPrivateKey * pRsaPrivate = NULL;
            PBYTE           pbCurrent;
            RSAPrivateKey   RsaPrivate;

            fResult = Asn1InfoDecodeAndAlloc(RSAPrivateKey_PDU,
                                            pKeyInfo->privateKey.value,
                                            pKeyInfo->privateKey.length,
                                            (void **)&pRsaPrivate);
            if(!fResult)
            {
                break;
            }

            RsaPrivate = *pRsaPrivate;

            // We successfully decrypted an RSA Private Key,
            // so now turn it into a pRsaPub;

            // Make some adjustmenst to the lengths of things if we have leading zeros
            if(RsaPrivate.modulus.length && (0 == *(PBYTE)RsaPrivate.modulus.value))
            {
                RsaPrivate.modulus.value++;
                RsaPrivate.modulus.length--;
            }
            if(RsaPrivate.prime1.length && (0 == *(PBYTE)RsaPrivate.prime1.value))
            {
                RsaPrivate.prime1.value++;
                RsaPrivate.prime1.length--;
            }
            if(RsaPrivate.prime2.length && (0 == *(PBYTE)RsaPrivate.prime2.value))
            {
                RsaPrivate.prime2.value++;
                RsaPrivate.prime2.length--;
            }

            if(RsaPrivate.exponent1.length && (0 == *(PBYTE)RsaPrivate.exponent1.value))
            {
                RsaPrivate.exponent1.value++;
                RsaPrivate.exponent1.length--;
            }
            if(RsaPrivate.exponent2.length && (0 == *(PBYTE)RsaPrivate.exponent2.value))
            {
                RsaPrivate.exponent2.value++;
                RsaPrivate.exponent2.length--;
            }

            if(RsaPrivate.coefficient.length && (0 == *(PBYTE)RsaPrivate.coefficient.value))
            {
                RsaPrivate.coefficient.value++;
                RsaPrivate.coefficient.length--;
            }
            if(RsaPrivate.privateExponent.length && (0 == *(PBYTE)RsaPrivate.privateExponent.value))
            {
                RsaPrivate.privateExponent.value++;
                RsaPrivate.privateExponent.length--;
            }

            cbMod = (RsaPrivate.modulus.length + sizeof(DWORD) - 1) & ~(sizeof(DWORD)-1);
            cbKey = sizeof(BLOBHEADER) + sizeof(RSAPUBKEY) + (cbMod*9)/2;
            if(pKey == NULL)
            {
                *pcbKey = cbKey;
                fResult = TRUE;
                Asn1InfoFree(RSAPrivateKey_PDU, pRsaPrivate);
                break;
            }

            // we're actually unpacking this key.
            if(*pcbKey < cbKey)
            {
                fResult = FALSE;
                Asn1InfoFree(RSAPrivateKey_PDU, pRsaPrivate);
                break;
            }

            pKey->bType = PRIVATEKEYBLOB;
            pKey->bVersion = 2;
            pKey->reserved = 0;
            pKey->aiKeyAlg = CALG_RSA_KEYX;

            pRsaPub = (RSAPUBKEY *)(pKey+1);
            pRsaPub->magic = ((DWORD)'R'+((DWORD)'S'<<8)+((DWORD)'A'<<16)+((DWORD)'2'<<24));
            pRsaPub->bitlen = cbMod*8;
            pRsaPub->pubexp = RsaPrivate.publicExponent;
            pbCurrent = (PBYTE)(pRsaPub + 1);
            ReverseMemCopy(pbCurrent, RsaPrivate.modulus.value, RsaPrivate.modulus.length);
            pbCurrent += cbMod;

            ReverseMemCopy(pbCurrent, RsaPrivate.prime1.value, RsaPrivate.prime1.length);
            pbCurrent += cbMod/2;

            ReverseMemCopy(pbCurrent, RsaPrivate.prime2.value, RsaPrivate.prime2.length);
            pbCurrent += cbMod/2;

            ReverseMemCopy(pbCurrent, RsaPrivate.exponent1.value, RsaPrivate.exponent1.length);
            pbCurrent += cbMod/2;

            ReverseMemCopy(pbCurrent, RsaPrivate.exponent2.value, RsaPrivate.exponent2.length);
            pbCurrent += cbMod/2;

            ReverseMemCopy(pbCurrent, RsaPrivate.coefficient.value, RsaPrivate.coefficient.length);
            pbCurrent += cbMod/2;

            ReverseMemCopy(pbCurrent, RsaPrivate.privateExponent.value, RsaPrivate.privateExponent.length);
            pbCurrent += cbMod;
            *pcbKey = cbKey;
            Asn1InfoFree(RSAPrivateKey_PDU, pRsaPrivate);

        }

    }while(FALSE);

    Asn1InfoFree(PrivateKeyInfo_PDU, pKeyInfo);
    return fResult;
}

BOOL
WINAPI
Asn1PrivateKeyFileDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PPRIVATE_KEY_FILE_ENCODE pKey,
        IN OUT DWORD *pcbKey
        )

{
    PrivateKeyFile *pFile = NULL;
    DWORD           cbPrivateKeyStruct;

    BOOL fResult = FALSE;

    UNREFERENCED_PARAMETER(dwCertEncodingType);
    UNREFERENCED_PARAMETER(lpszStructType);
    UNREFERENCED_PARAMETER(dwFlags);

    // Decode the file

    if(!Asn1InfoDecodeAndAlloc(PrivateKeyFile_PDU,
                                        pbEncoded,
                                        cbEncoded,
                                        (void **)&pFile))
    {
        return FALSE;
    }

    cbPrivateKeyStruct = pFile->privateKey.privateKey.length + sizeof(PRIVATE_KEY_FILE_ENCODE);
    if(pKey == NULL)
    {
        *pcbKey = cbPrivateKeyStruct;
        fResult = TRUE;
    }
    else
    {
        if(*pcbKey < cbPrivateKeyStruct)
        {
            fResult = FALSE;
        }
        else
        {
            pKey->EncryptedBlob.cbData = pFile->privateKey.privateKey.length;
            pKey->EncryptedBlob.pbData = (PBYTE)(pKey + 1);
            pKey->EncryptedBlob.cUnusedBits = 0;
            CopyMemory(pKey->EncryptedBlob.pbData, pFile->privateKey.privateKey.value, pKey->EncryptedBlob.cbData);
            fResult = TRUE;
        }
    }

    Asn1InfoFree(PrivateKeyFile_PDU, pFile);
    return fResult;

}


BOOL
WINAPI
Asn1RSAPublicEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PUBLICKEYSTRUC *pbKeyStruc,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    UNREFERENCED_PARAMETER(lpszStructType);

    return CryptEncodeObject(dwCertEncodingType,
                      RSA_CSP_PUBLICKEYBLOB,
                      pbKeyStruc,
                      pbEncoded,
                      pcbEncoded);
}


static void Asn1X509GetObjId(
        IN ObjectID *pAsn1,
        IN DWORD dwFlags,
        OUT LPSTR *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    DWORD cbObjId;

    UNREFERENCED_PARAMETER(dwFlags);

    cbObjId = lRemainExtra > 0 ? lRemainExtra : 0;
    PkiAsn1FromObjectIdentifier(
        pAsn1->count,
        pAsn1->value,
        (LPSTR) pbExtra,
        &cbObjId
        );

    lAlignExtra = INFO_LEN_ALIGN(cbObjId);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if(cbObjId) {
            *ppszObjId = (LPSTR) pbExtra;
        } else
            *ppszObjId = NULL;
        pbExtra += lAlignExtra;
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}

static void Asn1X509GetCtlUsage(
        IN EnhancedKeyUsage *pAsn1,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pUsage,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;

    DWORD cId;
    UsageIdentifier *pAsn1Id;
    LPSTR *ppszId;

    cId = pAsn1->count;
    lAlignExtra = INFO_LEN_ALIGN(cId * sizeof(LPSTR));
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        pUsage->cUsageIdentifier = cId;
        ppszId = (LPSTR *) pbExtra;
        pUsage->rgpszUsageIdentifier = ppszId;
        pbExtra += lAlignExtra;
    } else
        ppszId = NULL;

    pAsn1Id = pAsn1->value;
    for ( ; cId > 0; cId--, pAsn1Id++, ppszId++)
        Asn1X509GetObjId(pAsn1Id, dwFlags, ppszId, &pbExtra, &lRemainExtra);

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
}


//+-------------------------------------------------------------------------
//  CTL Usage (Enhanced Key Usage) Decode (Asn1 X509)
//--------------------------------------------------------------------------
static BOOL WINAPI Asn1X509CtlUsageDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCTL_USAGE pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    EnhancedKeyUsage *pAsn1Info = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    UNREFERENCED_PARAMETER(dwCertEncodingType);
    UNREFERENCED_PARAMETER(lpszStructType);

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!Asn1InfoDecodeAndAlloc(
            EnhancedKeyUsage_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pAsn1Info))
        goto ErrorReturn;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(CTL_USAGE);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CTL_USAGE);

    Asn1X509GetCtlUsage(pAsn1Info, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    Asn1InfoFree(EnhancedKeyUsage_PDU, pAsn1Info);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\pct1pckl.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       pct1pckl.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <pct1msg.h>
#include <pct1prot.h>

#define PCT_OFFSET_OF(t, v) ((DWORD)(ULONG_PTR)&(((t)NULL)->v))

#define SIZEOF(pMessage)    (Pct1RecordSize((PPCT1_MESSAGE_HEADER) pMessage ) )

DWORD MapCipherToExternal(CipherSpec Internal, ExtCipherSpec UNALIGNED *External)
{
    *External = htonl(Internal);
    return TRUE;
}

DWORD MapHashToExternal(HashSpec Internal, ExtHashSpec UNALIGNED *External)
{
    *External = htons((ExtHashSpec)Internal);
    return TRUE;
}

DWORD MapCertToExternal(CertSpec Internal, ExtCertSpec UNALIGNED *External)
{
    *External = htons((ExtCertSpec)Internal);
    return TRUE;
}

DWORD MapExchToExternal(ExchSpec Internal, ExtExchSpec UNALIGNED *External)
{
    *External = htons((ExtExchSpec)Internal);
    return TRUE;
}

DWORD MapSigToExternal(SigSpec Internal, ExtSigSpec UNALIGNED *External)
{
    *External = htons((ExtSigSpec)Internal);
    return TRUE;
}

CipherSpec MapCipherFromExternal(ExtCipherSpec External)
{
    return (CipherSpec)ntohl(External);
}

HashSpec MapHashFromExternal(ExtHashSpec External)
{
    return (HashSpec)ntohs(External);
}

CertSpec MapCertFromExternal(ExtCertSpec External)
{
    return (CertSpec)ntohs(External);
}

ExchSpec MapExchFromExternal(ExtExchSpec External)
{
    return (ExchSpec)ntohs(External);
}

SigSpec MapSigFromExternal(ExtSigSpec External)
{
    return (SigSpec)ntohs(External);
}


DWORD
Pct1RecordSize(
    PPCT1_MESSAGE_HEADER  pHeader)
{
    DWORD   Size;

    if (pHeader->Byte0 & 0x80)
    {
        Size = COMBINEBYTES(pHeader->Byte0, pHeader->Byte1) & 0x7FFF;
    }
    else
    {
        Size = COMBINEBYTES(pHeader->Byte0, pHeader->Byte1) & 0x3FFF;
    }
    return(Size);
}


SP_STATUS
Pct1PackClientHello(
    PPct1_Client_Hello       pCanonical,
    PSPBuffer          pCommOutput)
{
    DWORD               cbMessage;
    PPCT1_CLIENT_HELLO   pMessage;
    DWORD               Size;
    PUCHAR              pBuffer;
    DWORD               i, iBuff;

    SP_BEGIN("Pct1PackClientHello");

    if(pCanonical == NULL || pCommOutput == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pCommOutput->cbData = 0;

    if(pCanonical->cbSessionID != PCT_SESSION_ID_SIZE ||
       pCanonical->cbChallenge != PCT_CHALLENGE_SIZE)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }


    pCommOutput->cbData = PCT_OFFSET_OF(PPCT1_CLIENT_HELLO, VariantData) +
                    pCanonical->cCipherSpecs * sizeof(ExtCipherSpec) +
                    pCanonical->cHashSpecs * sizeof(ExtHashSpec) +
                    pCanonical->cCertSpecs * sizeof(ExtCertSpec) +
                    pCanonical->cExchSpecs * sizeof(ExtExchSpec) +
                    pCanonical->cbKeyArgSize;


    cbMessage = pCommOutput->cbData - sizeof(PCT1_MESSAGE_HEADER);
    if (cbMessage > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW));
    }
    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }

        pCommOutput->cbBuffer = pCommOutput->cbData;
    }

    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        // Required size returned in pCommOutput->cbData.
        SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;

    pMessage->MessageId = PCT1_MSG_CLIENT_HELLO;

    pMessage->VersionMsb = MSBOF(PCT_VERSION_1);
    pMessage->VersionLsb = LSBOF(PCT_VERSION_1);

    pMessage->OffsetMsb = MSBOF(PCT_CH_OFFSET_V1);
    pMessage->OffsetLsb = LSBOF(PCT_CH_OFFSET_V1);

    pMessage->KeyArgLenMsb = MSBOF(pCanonical->cbKeyArgSize);
    pMessage->KeyArgLenLsb = LSBOF(pCanonical->cbKeyArgSize);

    CopyMemory( pMessage->SessionIdData,
                pCanonical->SessionID,
                pCanonical->cbSessionID);

    CopyMemory( pMessage->ChallengeData,
                pCanonical->Challenge,
                pCanonical->cbChallenge);

    pBuffer = pMessage->VariantData;

    iBuff = 0;
    for (i = 0; i < pCanonical->cCipherSpecs ; i++ )
    {
        if (MapCipherToExternal(pCanonical->pCipherSpecs[i],
                                &((ExtCipherSpec UNALIGNED *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtCipherSpec);

    pMessage->CipherSpecsLenMsb = MSBOF(Size);
    pMessage->CipherSpecsLenLsb = LSBOF(Size);
    pBuffer += Size;

    cbMessage -= (pCanonical->cCipherSpecs - iBuff)*sizeof(ExtCipherSpec);


    iBuff = 0;
    for (i = 0; i < pCanonical->cHashSpecs ; i++ )
    {
        if (MapHashToExternal(pCanonical->pHashSpecs[i],
                              &((ExtHashSpec UNALIGNED *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtHashSpec);
    pBuffer += Size;

    pMessage->HashSpecsLenMsb = MSBOF(Size);
    pMessage->HashSpecsLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cHashSpecs - iBuff)*sizeof(ExtHashSpec);


    iBuff = 0;
    for (i = 0; i < pCanonical->cCertSpecs ; i++ )
    {
        if (MapCertToExternal(pCanonical->pCertSpecs[i],
                                &((ExtCertSpec UNALIGNED *) pBuffer)[iBuff]))
        {
            iBuff ++;
        }
    }
    Size = iBuff*sizeof(ExtCertSpec);
    pBuffer += Size;

    pMessage->CertSpecsLenMsb = MSBOF(Size);
    pMessage->CertSpecsLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cCertSpecs - iBuff)*sizeof(ExtCertSpec);


    iBuff = 0;
    for (i = 0; i < pCanonical->cExchSpecs ; i++ )
    {
        if (MapExchToExternal(pCanonical->pExchSpecs[i],
                                &((ExtExchSpec UNALIGNED *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtExchSpec);
    pBuffer += Size;


    pMessage->ExchSpecsLenMsb = MSBOF(Size);
    pMessage->ExchSpecsLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cExchSpecs - iBuff)*sizeof(ExtExchSpec);

    if(pCanonical->pKeyArg)
    {
        CopyMemory(pBuffer, pCanonical->pKeyArg, pCanonical->cbKeyArgSize);
        pBuffer += pCanonical->cbKeyArgSize;
    }

    pCommOutput->cbData = cbMessage + 2;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    SP_RETURN(PCT_ERR_OK);
}

SP_STATUS
Pct1UnpackClientHello(
    PSPBuffer          pInput,
    PPct1_Client_Hello *     ppClient)
{

    PPCT1_CLIENT_HELLO   pMessage;

    DWORD               ReportedSize;
    DWORD               CipherSpecsSize, HashSpecsSize, CertSpecsSize;
    DWORD               ExchSpecsSize;
    DWORD               cCipherSpecs, cHashSpecs, cCertSpecs, cExchSpecs;
    DWORD               cOffsetBytes, KeyArgSize;
    PPct1_Client_Hello       pCanonical;
    PUCHAR              pBuffer;
    DWORD               i;

    SP_BEGIN("Pct1UnpackClientHello");

    if(pInput   == NULL ||
       ppClient == NULL ||
       pInput->pvBuffer == NULL)
    {
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    pMessage = pInput->pvBuffer;

    if(pInput->cbData < 2)
    {
        pInput->cbData = 2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    ReportedSize = SIZEOF(pMessage);

    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    if(ReportedSize < PCT_OFFSET_OF(PPCT1_CLIENT_HELLO, VariantData))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if(ReportedSize > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if ((pMessage->VersionMsb & 0x80) == 0)
    {
        SP_RETURN (PCT_ERR_SSL_STYLE_MSG);
    }

    /* We don't recognize hello messages of less version than ourselves,
     * those will be handled by a previous version of the code */
    if ((pMessage->MessageId != PCT1_MSG_CLIENT_HELLO) ||
        ((pMessage->VersionMsb << 8 | pMessage->VersionLsb)  < PCT_VERSION_1))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    cOffsetBytes = COMBINEBYTES( pMessage->OffsetMsb,
                                  pMessage->OffsetLsb );

    if(cOffsetBytes < PCT_CH_OFFSET_V1)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    *ppClient = NULL;

    CipherSpecsSize = COMBINEBYTES( pMessage->CipherSpecsLenMsb,
                                    pMessage->CipherSpecsLenLsb );

    HashSpecsSize = COMBINEBYTES( pMessage->HashSpecsLenMsb,
                                  pMessage->HashSpecsLenLsb );

    CertSpecsSize = COMBINEBYTES( pMessage->CertSpecsLenMsb,
                                  pMessage->CertSpecsLenLsb );

    ExchSpecsSize = COMBINEBYTES( pMessage->ExchSpecsLenMsb,
                                  pMessage->ExchSpecsLenLsb );

    KeyArgSize = COMBINEBYTES( pMessage->KeyArgLenMsb,
                                          pMessage->KeyArgLenLsb );

    /* check that this all fits into the message */
    if (PCT_OFFSET_OF(PPCT1_CLIENT_HELLO, VariantData)
          - sizeof(PCT1_MESSAGE_HEADER)       /* don't count the header */
         + cOffsetBytes - PCT_CH_OFFSET_V1
         + CipherSpecsSize
         + HashSpecsSize
         + CertSpecsSize
         + ExchSpecsSize
         + KeyArgSize != ReportedSize)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    cCipherSpecs = CipherSpecsSize / sizeof(ExtCipherSpec);
    cHashSpecs = HashSpecsSize / sizeof(ExtHashSpec);
    cExchSpecs = ExchSpecsSize / sizeof(ExtExchSpec);
    cCertSpecs = CertSpecsSize / sizeof(ExtCertSpec);

    if(KeyArgSize > SP_MAX_KEY_ARGS)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }


    /* Allocate a buffer for the canonical client hello */
    pCanonical = (PPct1_Client_Hello)SPExternalAlloc(
                            sizeof(Pct1_Client_Hello) +
                            cCipherSpecs * sizeof(CipherSpec) +
                            cHashSpecs * sizeof(HashSpec) +
                            cCertSpecs * sizeof(CertSpec) +
                            cExchSpecs * sizeof(ExchSpec) +
                            KeyArgSize);

    if (!pCanonical)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
    }

    pCanonical->cbKeyArgSize = KeyArgSize;

    pCanonical->pCipherSpecs = (PCipherSpec) (pCanonical + 1);
    pCanonical->pHashSpecs = (PHashSpec) (pCanonical->pCipherSpecs +
                                          cCipherSpecs);
    pCanonical->pCertSpecs = (PCertSpec) (pCanonical->pHashSpecs +
                                          cHashSpecs);
    pCanonical->pExchSpecs = (PExchSpec) (pCanonical->pCertSpecs +
                                          cCertSpecs);

    pCanonical->pKeyArg = (PUCHAR)(pCanonical->pExchSpecs + cExchSpecs);

    CopyMemory( pCanonical->SessionID,
                pMessage->SessionIdData,
                PCT_SESSION_ID_SIZE);
    pCanonical->cbSessionID = PCT_SESSION_ID_SIZE;

    CopyMemory( pCanonical->Challenge,
                pMessage->ChallengeData,
                PCT_CHALLENGE_SIZE );
    pCanonical->cbChallenge = PCT_CHALLENGE_SIZE;


    pBuffer = &pMessage->OffsetLsb + 1 + cOffsetBytes;

    pCanonical->cCipherSpecs = cCipherSpecs;

    for (i = 0 ; i < cCipherSpecs ; i++ )
    {
        pCanonical->pCipherSpecs[i] = MapCipherFromExternal(*(ExtCipherSpec UNALIGNED *)
                                                    pBuffer);

        pBuffer += sizeof(ExtCipherSpec);
    }

    pCanonical->cHashSpecs = cHashSpecs;

    for (i = 0 ; i < cHashSpecs ; i++ )
    {
        pCanonical->pHashSpecs[i] = MapHashFromExternal(*(ExtHashSpec UNALIGNED *)
                                                    pBuffer);

        pBuffer += sizeof(ExtHashSpec);
    }

    pCanonical->cCertSpecs = cCertSpecs;

    for (i = 0 ; i < cCertSpecs ; i++ )
    {
        pCanonical->pCertSpecs[i] = MapCertFromExternal(*(ExtCertSpec UNALIGNED *)
                                                    pBuffer);

        pBuffer += sizeof(ExtCertSpec);
    }

    pCanonical->cExchSpecs = cExchSpecs;

    for (i = 0 ; i < cExchSpecs ; i++ )
    {
        pCanonical->pExchSpecs[i] = MapExchFromExternal(*(ExtExchSpec UNALIGNED *)
                                                    pBuffer);

        pBuffer += sizeof(ExtExchSpec);
    }


    CopyMemory(pCanonical->pKeyArg, pBuffer, KeyArgSize);

    *ppClient = pCanonical;
    pInput->cbData = ReportedSize + sizeof(PCT1_MESSAGE_HEADER);

    SP_RETURN(PCT_ERR_OK);
}

SP_STATUS
Pct1PackServerHello(
    PPct1_Server_Hello       pCanonical,
    PSPBuffer          pCommOutput)
{
    DWORD               cbMessage;
    PPCT1_SERVER_HELLO   pMessage;
    DWORD               Size;
    PUCHAR              pBuffer;
    DWORD               i, iBuff;


    SP_BEGIN("Pct1PackServerHello");

    if(pCanonical == NULL || pCommOutput == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pCommOutput->cbData = 0;
    if(pCanonical->cbConnectionID != PCT_SESSION_ID_SIZE)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    cbMessage = pCanonical->CertificateLen +
                    pCanonical->cCertSpecs * sizeof(ExtCertSpec) +
                    pCanonical->cSigSpecs * sizeof(ExtSigSpec) +
                    pCanonical->ResponseLen +
                    PCT_OFFSET_OF(PPCT1_SERVER_HELLO, VariantData) -
                    sizeof(PCT1_MESSAGE_HEADER);

    if (cbMessage > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW));
    }

    pCommOutput->cbData = cbMessage + 2;

    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }

        pCommOutput->cbBuffer = pCommOutput->cbData;
    }

    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        // Required size returned in pCommOutput->cbData.
        SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;


    pMessage->MessageId = PCT1_MSG_SERVER_HELLO;
    pMessage->ServerVersionMsb = MSBOF(PCT_VERSION_1);
    pMessage->ServerVersionLsb = LSBOF(PCT_VERSION_1);
    pMessage->RestartSessionOK = (UCHAR) pCanonical->RestartOk;
    pMessage->ClientAuthReq = (UCHAR)pCanonical->ClientAuthReq;

    MapCipherToExternal(pCanonical->SrvCipherSpec, &pMessage->CipherSpecData);
    MapHashToExternal(pCanonical->SrvHashSpec, &pMessage->HashSpecData);
    MapCertToExternal(pCanonical->SrvCertSpec, &pMessage->CertSpecData);
    MapExchToExternal(pCanonical->SrvExchSpec, &pMessage->ExchSpecData);

    CopyMemory(pMessage->ConnectionIdData, pCanonical->ConnectionID,
               pCanonical->cbConnectionID);

    pBuffer = pMessage->VariantData;


    /* Pack certificate if present */


    pMessage->CertificateLenMsb = MSBOF(pCanonical->CertificateLen);
    pMessage->CertificateLenLsb = LSBOF(pCanonical->CertificateLen);

    if (pCanonical->CertificateLen)
    {
        CopyMemory( pBuffer,
                    pCanonical->pCertificate,
                    pCanonical->CertificateLen);

        pBuffer += pCanonical->CertificateLen ;
    }

    iBuff = 0;
    for (i = 0; i < pCanonical->cCertSpecs ; i++ )
    {
        if (MapCertToExternal(pCanonical->pClientCertSpecs[i],
                                &((ExtCertSpec UNALIGNED *) pBuffer)[iBuff]))
        {
            iBuff ++;
        }
    }
    Size = iBuff*sizeof(ExtCertSpec);
    pBuffer += Size;

    pMessage->CertSpecsLenMsb = MSBOF(Size);
    pMessage->CertSpecsLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cCertSpecs - iBuff)*sizeof(ExtCertSpec);

    iBuff = 0;
    for (i = 0; i < pCanonical->cSigSpecs ; i++ )
    {
        if (MapSigToExternal(pCanonical->pClientSigSpecs[i],
                              &((ExtSigSpec UNALIGNED *) pBuffer)[iBuff]) )
        {
            iBuff++;
        }
    }
    Size = iBuff*sizeof(ExtSigSpec);
    pBuffer += Size;

    pMessage->ClientSigSpecsLenMsb = MSBOF(Size);
    pMessage->ClientSigSpecsLenLsb = LSBOF(Size);
    cbMessage -= (pCanonical->cSigSpecs - iBuff)*sizeof(ExtSigSpec);

    pMessage->ResponseLenMsb = MSBOF(pCanonical->ResponseLen);
    pMessage->ResponseLenLsb = LSBOF(pCanonical->ResponseLen);

    CopyMemory( pBuffer,
                pCanonical->Response,
                pCanonical->ResponseLen);

    pBuffer += pCanonical->ResponseLen;

    pCommOutput->cbData = cbMessage + 2;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);


    SP_RETURN(PCT_ERR_OK);

}

SP_STATUS
Pct1UnpackServerHello(
    PSPBuffer          pInput,
    PPct1_Server_Hello *     ppServer)
{
    PPct1_Server_Hello       pCanonical;
    PPCT1_SERVER_HELLO   pMessage;
    PUCHAR              pBuffer;
    DWORD               cbCertificate, cbResponse;
    DWORD               cCertSpecs, cSigSpecs;
    DWORD               i;
    DWORD               ReportedSize;

    SP_BEGIN("Pct1UnpackServerHello");

    if(pInput   == NULL ||
       ppServer == NULL ||
       pInput->pvBuffer == NULL)
    {
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    pMessage = pInput->pvBuffer;

    if(pInput->cbData < 2)
    {
        pInput->cbData = 2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    ReportedSize = SIZEOF(pMessage);
    if(ReportedSize > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    if(ReportedSize <  PCT_OFFSET_OF(PPCT1_SERVER_HELLO, VariantData) )
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    /* Verify Header: */

    /* we don't handle server hello messages of latter version than ourselves,
     * those will be handled by latter verisions of the protocol */
    if ((pMessage->MessageId != PCT1_MSG_SERVER_HELLO) ||
        ((pMessage->ServerVersionMsb << 8 | pMessage->ServerVersionLsb) != PCT_VERSION_1))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    *ppServer = NULL;

    cbCertificate = COMBINEBYTES(pMessage->CertificateLenMsb,
                                 pMessage->CertificateLenLsb);

    cCertSpecs = COMBINEBYTES(pMessage->CertSpecsLenMsb,
                              pMessage->CertSpecsLenLsb);

    cCertSpecs /= sizeof(ExtCertSpec);


    cSigSpecs = COMBINEBYTES(pMessage->ClientSigSpecsLenMsb,
                             pMessage->ClientSigSpecsLenLsb);

    cSigSpecs /= sizeof(ExtSigSpec);

    cbResponse = COMBINEBYTES(pMessage->ResponseLenMsb,
                              pMessage->ResponseLenLsb);

    if(cbResponse > PCT1_RESPONSE_SIZE)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    /* check that this all fits into the message */
    if (PCT_OFFSET_OF(PPCT1_SERVER_HELLO, VariantData)
          - sizeof(PCT1_MESSAGE_HEADER)       /* don't count the header */
         + cbCertificate
         + cCertSpecs*sizeof(ExtCertSpec)
         + cSigSpecs*sizeof(ExtSigSpec)
         + cbResponse != ReportedSize)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    pCanonical = (PPct1_Server_Hello)SPExternalAlloc(
                            sizeof(Pct1_Server_Hello) +
                            cCertSpecs * sizeof(CertSpec) +
                            cSigSpecs * sizeof(SigSpec) +
                            cbCertificate);

    if (!pCanonical)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
    }


    /* Set up pointers to be in this memory allocation. */


    pCanonical->pClientCertSpecs = (PCertSpec) (pCanonical + 1);
    pCanonical->pClientSigSpecs = (PSigSpec)(pCanonical->pClientCertSpecs +
                                    cCertSpecs);

    pCanonical->pCertificate = (PUCHAR) (pCanonical->pClientSigSpecs +
                                    cSigSpecs);

    /* Expand out: */

    pCanonical->RestartOk = (DWORD) pMessage->RestartSessionOK;
    pCanonical->ClientAuthReq = (DWORD)pMessage->ClientAuthReq;
    pCanonical->SrvCertSpec = MapCertFromExternal(pMessage->CertSpecData);
    pCanonical->SrvCipherSpec =MapCipherFromExternal(pMessage->CipherSpecData);
    pCanonical->SrvHashSpec = MapHashFromExternal(pMessage->HashSpecData);
    pCanonical->SrvExchSpec = MapExchFromExternal(pMessage->ExchSpecData);
    pCanonical->CertificateLen = cbCertificate;
    pCanonical->ResponseLen = cbResponse;
    pCanonical->cCertSpecs = cCertSpecs;
    pCanonical->cSigSpecs = cSigSpecs;

    CopyMemory(pCanonical->ConnectionID,
               pMessage->ConnectionIdData,
               PCT_SESSION_ID_SIZE);

    pCanonical->cbConnectionID= PCT_SESSION_ID_SIZE;

    pBuffer = pMessage->VariantData;

    CopyMemory(pCanonical->pCertificate, pBuffer, cbCertificate);
    pBuffer += cbCertificate;

    for (i = 0 ; i < cCertSpecs ; i++ )
    {
        pCanonical->pClientCertSpecs[i] = MapCertFromExternal(
                                            *(ExtCertSpec UNALIGNED *)pBuffer);
        pBuffer += sizeof(ExtCertSpec);
    }

    for (i = 0 ; i < cSigSpecs ; i++ )
    {
        pCanonical->pClientSigSpecs[i] = MapSigFromExternal(
                                            *(ExtSigSpec UNALIGNED *)pBuffer);
        pBuffer += sizeof(ExtSigSpec);
    }

    CopyMemory(pCanonical->Response, pBuffer, cbResponse);


    *ppServer = pCanonical;
    pInput->cbData = ReportedSize + sizeof(PCT1_MESSAGE_HEADER);

    SP_RETURN(PCT_ERR_OK);

}

SP_STATUS
Pct1PackClientMasterKey(
    PPct1_Client_Master_Key      pCanonical,
    PSPBuffer                    pCommOutput)
{
    DWORD                   cbMessage;
    PPCT1_CLIENT_MASTER_KEY  pMessage;
    PUCHAR                  pBuffer;

    SP_BEGIN("Pct1PackClientMasterKey");

    if(pCanonical == NULL || pCommOutput == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pCommOutput->cbData = 0;

    cbMessage = pCanonical->ClearKeyLen +
                    pCanonical->EncryptedKeyLen +
                    pCanonical->KeyArgLen +
                    pCanonical->VerifyPreludeLen +
                    pCanonical->ClientCertLen +
                    pCanonical->ResponseLen +
                    PCT_OFFSET_OF(PPCT1_CLIENT_MASTER_KEY, VariantData) -
                    sizeof(PCT1_MESSAGE_HEADER);

    if (cbMessage > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW));
    }

    pCommOutput->cbData = cbMessage + 2;

        /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }

        pCommOutput->cbBuffer = pCommOutput->cbData;
    }


    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        // Required size returned in pCommOutput->cbData.
        SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;




    pBuffer = pMessage->VariantData;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    pMessage->MessageId = PCT1_MSG_CLIENT_MASTER_KEY;

    pMessage->ClearKeyLenMsb = MSBOF(pCanonical->ClearKeyLen);
    pMessage->ClearKeyLenLsb = LSBOF(pCanonical->ClearKeyLen);

    MapSigToExternal(pCanonical->ClientSigSpec, &pMessage->ClientSigSpecData);
    MapCertToExternal(pCanonical->ClientCertSpec, &pMessage->ClientCertSpecData);

    CopyMemory(pBuffer, pCanonical->ClearKey, pCanonical->ClearKeyLen);

    pBuffer += pCanonical->ClearKeyLen;

    pMessage->EncryptedKeyLenMsb = MSBOF(pCanonical->EncryptedKeyLen);
    pMessage->EncryptedKeyLenLsb = LSBOF(pCanonical->EncryptedKeyLen);

    CopyMemory(pBuffer, pCanonical->pbEncryptedKey, pCanonical->EncryptedKeyLen);
    pBuffer += pCanonical->EncryptedKeyLen;

    pMessage->KeyArgLenMsb = MSBOF(pCanonical->KeyArgLen);
    pMessage->KeyArgLenLsb = LSBOF(pCanonical->KeyArgLen);

    CopyMemory(pBuffer, pCanonical->KeyArg, pCanonical->KeyArgLen);
    pBuffer += pCanonical->KeyArgLen;

    pMessage->VerifyPreludeLenMsb = MSBOF(pCanonical->VerifyPreludeLen);
    pMessage->VerifyPreludeLenLsb = LSBOF(pCanonical->VerifyPreludeLen);

    CopyMemory(pBuffer, pCanonical->VerifyPrelude,
               pCanonical->VerifyPreludeLen);
    pBuffer += pCanonical->VerifyPreludeLen;

    pMessage->ClientCertLenMsb = MSBOF(pCanonical->ClientCertLen);
    pMessage->ClientCertLenLsb = LSBOF(pCanonical->ClientCertLen);

    CopyMemory(pBuffer, pCanonical->pClientCert, pCanonical->ClientCertLen);
    pBuffer += pCanonical->ClientCertLen;

    pMessage->ResponseLenMsb = MSBOF(pCanonical->ResponseLen);
    pMessage->ResponseLenLsb = LSBOF(pCanonical->ResponseLen);

    CopyMemory(pBuffer, pCanonical->pbResponse, pCanonical->ResponseLen);


    SP_RETURN(PCT_ERR_OK);

}

SP_STATUS
Pct1UnpackClientMasterKey(
    PSPBuffer              pInput,
    PPct1_Client_Master_Key *    ppClient)
{
    PPct1_Client_Master_Key  pCanonical;

    PUCHAR              pBuffer;
    DWORD               ReportedSize;
    PPCT1_CLIENT_MASTER_KEY  pMessage;
    DWORD cbClearKey, cbEncryptedKey, cbKeyArg, cbVerifyPrelude, cbClientCert, cbResponse;

    SP_BEGIN("Pct1UnpackClientMasterKey");

    if(pInput   == NULL ||
       ppClient == NULL ||
       pInput->pvBuffer == NULL)
    {
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    pMessage = pInput->pvBuffer;

    if(pInput->cbData < 2)
    {
        pInput->cbData = 2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    ReportedSize = SIZEOF(pMessage);
    if(ReportedSize > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    if(ReportedSize < PCT_OFFSET_OF(PPCT1_CLIENT_MASTER_KEY, VariantData))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    /* Verify Header: */


    if (pMessage->MessageId != PCT1_MSG_CLIENT_MASTER_KEY )
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }
    cbClearKey = COMBINEBYTES( pMessage->ClearKeyLenMsb,
                                            pMessage->ClearKeyLenLsb );

    cbEncryptedKey = COMBINEBYTES( pMessage->EncryptedKeyLenMsb,
                                                pMessage->EncryptedKeyLenLsb );

    cbKeyArg = COMBINEBYTES( pMessage->KeyArgLenMsb,
                                          pMessage->KeyArgLenLsb );

    cbVerifyPrelude = COMBINEBYTES( pMessage->VerifyPreludeLenMsb,
                                            pMessage->VerifyPreludeLenLsb );

    cbClientCert = COMBINEBYTES( pMessage->ClientCertLenMsb,
                                              pMessage->ClientCertLenLsb );

    cbResponse = COMBINEBYTES( pMessage->ResponseLenMsb,
                                            pMessage->ResponseLenLsb );

    /* defensive checks..... */

    if ((cbClearKey > SP_MAX_MASTER_KEY) ||
        (cbKeyArg > PCT1_MAX_KEY_ARGS) ||
        (cbVerifyPrelude > RESPONSE_SIZE))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }


    if ((PCT_OFFSET_OF(PPCT1_CLIENT_MASTER_KEY, VariantData) -
         sizeof(PCT1_MESSAGE_HEADER) +
         cbClearKey +
         cbEncryptedKey +
         cbKeyArg +
         cbVerifyPrelude +
         cbClientCert +
         cbResponse) !=
         ReportedSize)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }


    *ppClient = NULL;


    pCanonical = (PPct1_Client_Master_Key)SPExternalAlloc(
                            sizeof(Pct1_Client_Master_Key) + 
                            cbClientCert +
                            cbEncryptedKey +
                            cbResponse);

    if (!pCanonical)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));

    }

    pCanonical->ClearKeyLen = cbClearKey;

    pCanonical->EncryptedKeyLen = cbEncryptedKey;

    pCanonical->KeyArgLen = cbKeyArg;

    pCanonical->VerifyPreludeLen = cbVerifyPrelude;
    pCanonical->ClientCertLen = cbClientCert;

    pCanonical->ResponseLen = cbResponse;
    /* defensive checks..... */


    pCanonical->ClientCertSpec = MapCertFromExternal(pMessage->ClientCertSpecData);

    pCanonical->pClientCert = (PUCHAR)(pCanonical+1);

    pCanonical->ClientSigSpec = MapSigFromExternal(pMessage->ClientSigSpecData);
    /* ok, we're pretty sure we aren't going to fault. */

    pBuffer = pMessage->VariantData;

    CopyMemory(pCanonical->ClearKey, pBuffer, pCanonical->ClearKeyLen );

    pBuffer += pCanonical->ClearKeyLen;

    pCanonical->pbEncryptedKey = pCanonical->pClientCert + cbClientCert;
    CopyMemory(pCanonical->pbEncryptedKey, pBuffer, pCanonical->EncryptedKeyLen);

    pBuffer += pCanonical->EncryptedKeyLen;

    CopyMemory( pCanonical->KeyArg, pBuffer, pCanonical->KeyArgLen );

    pBuffer += pCanonical->KeyArgLen;

    CopyMemory( pCanonical->VerifyPrelude, pBuffer,
                pCanonical->VerifyPreludeLen );

    pBuffer += pCanonical->VerifyPreludeLen;

    CopyMemory( pCanonical->pClientCert, pBuffer, pCanonical->ClientCertLen );

    pBuffer += pCanonical->ClientCertLen;

    pCanonical->pbResponse = pCanonical->pbEncryptedKey + cbEncryptedKey;
    CopyMemory( pCanonical->pbResponse, pBuffer, pCanonical->ResponseLen );

    *ppClient = pCanonical;
    pInput->cbData = ReportedSize + sizeof(PCT1_MESSAGE_HEADER);
    SP_RETURN( PCT_ERR_OK );
}


SP_STATUS
Pct1PackServerVerify(
    PPct1_Server_Verify          pCanonical,
    PSPBuffer              pCommOutput)
{
    DWORD               cbMessage;
    PPCT1_SERVER_VERIFY  pMessage;
    PUCHAR              pBuffer;


    SP_BEGIN("Pct1PackServerVerify");

    if(pCanonical == NULL || pCommOutput == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pCommOutput->cbData = 0;

    cbMessage    = pCanonical->ResponseLen +
                    PCT_OFFSET_OF(PPCT1_SERVER_VERIFY, VariantData) -
                    sizeof(PCT1_MESSAGE_HEADER);

    if (cbMessage > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(PCT_INT_DATA_OVERFLOW);
    }

    pCommOutput->cbData = cbMessage + 2;

    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }


    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        // Required size returned in pCommOutput->cbData.
        SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;

    pMessage->MessageId = PCT1_MSG_SERVER_VERIFY;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    CopyMemory(pMessage->SessionIdData, pCanonical->SessionIdData,
               PCT_SESSION_ID_SIZE);

    pBuffer = pMessage->VariantData;


    /* Pack certificate if present */


    pMessage->ResponseLenMsb = MSBOF(pCanonical->ResponseLen);
    pMessage->ResponseLenLsb = LSBOF(pCanonical->ResponseLen);

    if (pCanonical->ResponseLen)
    {
        CopyMemory( pBuffer,
                    pCanonical->Response,
                    pCanonical->ResponseLen);
    }

    SP_RETURN( PCT_ERR_OK );

}

SP_STATUS
Pct1UnpackServerVerify(
    PSPBuffer              pInput,
    PPct1_Server_Verify *        ppServer)
{
    PPct1_Server_Verify      pCanonical;
    PPCT1_SERVER_VERIFY  pMessage;
    PUCHAR              pBuffer;
    DWORD               cbResponse;
    DWORD               ReportedSize;

    SP_BEGIN("Pct1UnpackServerVerify");

    if(pInput   == NULL ||
       ppServer == NULL ||
       pInput->pvBuffer == NULL)
    {
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    pMessage = pInput->pvBuffer;

    if(pInput->cbData < 2)
    {
        pInput->cbData = 2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    ReportedSize = SIZEOF(pMessage);
    if(ReportedSize > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2;
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    if(ReportedSize < PCT_OFFSET_OF(PPCT1_SERVER_VERIFY, VariantData))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    /* Verify Header: */


    if (pMessage->MessageId != PCT1_MSG_SERVER_VERIFY )
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }


    *ppServer = NULL;

    /* Verify Header: */


    cbResponse = COMBINEBYTES(pMessage->ResponseLenMsb,
                              pMessage->ResponseLenLsb);

    if (cbResponse > PCT_SESSION_ID_SIZE)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if ((PCT_OFFSET_OF(PPCT1_SERVER_VERIFY, VariantData) -
         sizeof(PCT1_MESSAGE_HEADER) +
         cbResponse ) !=
         ReportedSize)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    pCanonical = (PPct1_Server_Verify)SPExternalAlloc( sizeof(Pct1_Server_Verify));

    if (!pCanonical)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
    }


    /* Expand out: */


    pCanonical->ResponseLen = cbResponse;

    CopyMemory((PUCHAR)pCanonical->SessionIdData, pMessage->SessionIdData,
               PCT_SESSION_ID_SIZE);

    pBuffer = pMessage->VariantData;

    CopyMemory(pCanonical->Response, pBuffer, cbResponse);

    *ppServer = pCanonical;
    pInput->cbData = ReportedSize + sizeof(PCT1_MESSAGE_HEADER);
    SP_RETURN(PCT_ERR_OK);
}


SP_STATUS
Pct1PackError(
    PPct1_Error            pCanonical,
    PSPBuffer              pCommOutput)
{
    DWORD               cbMessage;
    PPCT1_ERROR          pMessage;


    SP_BEGIN("Pct1PackError");

    if(pCanonical == NULL || pCommOutput == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }
    pCommOutput->cbData = 0;

    cbMessage = pCanonical->ErrInfoLen +
                    PCT_OFFSET_OF(PPCT1_ERROR, VariantData) -
                    sizeof(PCT1_MESSAGE_HEADER);

    if (cbMessage > PCT_MAX_SHAKE_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW));
    }

    pCommOutput->cbData = cbMessage+2;

    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }


    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        // Required size returned in pCommOutput->cbData.
        SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    pMessage->MessageId = PCT1_MSG_ERROR;

    pMessage->ErrorMsb = MSBOF(pCanonical->Error);
    pMessage->ErrorLsb = LSBOF(pCanonical->Error);

    pMessage->ErrorInfoMsb = MSBOF(pCanonical->ErrInfoLen);
    pMessage->ErrorInfoLsb = LSBOF(pCanonical->ErrInfoLen);

    if(pCanonical->ErrInfoLen) {
        CopyMemory(pMessage->VariantData, pCanonical->ErrInfo, pCanonical->ErrInfoLen);
    }

    SP_RETURN( PCT_ERR_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\pct1msg.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       pct1msg.c
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <pct1msg.h>
#include <pct1prot.h>


static SP_STATUS
Pct1ComputeMac(
    PSPContext pContext,  
    BOOL       fWriteMAC,  
    PSPBuffer  pData,     
    DWORD      dwSequence,
    PBYTE      pbMac,     
    PDWORD     pcbMac);


Pct1CipherMap Pct1CipherRank[] = {
    {CALG_RC4,  128, PCT1_CIPHER_RC4  | PCT1_ENC_BITS_128 | PCT1_MAC_BITS_128},
    {CALG_RC4,   64, PCT1_CIPHER_RC4  | PCT1_ENC_BITS_64  | PCT1_MAC_BITS_128},
    {CALG_RC4,   40, PCT1_CIPHER_RC4  | PCT1_ENC_BITS_40  | PCT1_MAC_BITS_128},
};

DWORD Pct1NumCipher = sizeof(Pct1CipherRank)/sizeof(Pct1CipherMap);

/* available hashes, in order of preference */
Pct1HashMap Pct1HashRank[] = {
    {CALG_MD5, PCT1_HASH_MD5},
    {CALG_SHA, PCT1_HASH_SHA}
};
DWORD Pct1NumHash = sizeof(Pct1HashRank)/sizeof(Pct1HashMap);


CertTypeMap aPct1CertEncodingPref[] =
{
    { X509_ASN_ENCODING , PCT1_CERT_X509_CHAIN },
    { X509_ASN_ENCODING , PCT1_CERT_X509 }
};
DWORD cPct1CertEncodingPref = sizeof(aPct1CertEncodingPref)/sizeof(CertTypeMap);


KeyTypeMap aPct1LocalExchKeyPref[] =   // CAPI Key type, SCHANNEL ALGID
{
    { CALG_RSA_KEYX, SP_EXCH_RSA_PKCS1 }
};

DWORD cPct1LocalExchKeyPref = sizeof(aPct1LocalExchKeyPref)/sizeof(KeyTypeMap);


KeyTypeMap aPct1LocalSigKeyPref[] =   // CAPI Key type, SCHANNEL ALGID
{
    { CALG_RSA_KEYX,      SP_SIG_RSA_MD5 },
    { CALG_RSA_KEYX,      SP_SIG_RSA_SHA }
};

DWORD cPct1LocalSigKeyPref = sizeof(aPct1LocalSigKeyPref)/sizeof(KeyTypeMap);

SP_STATUS WINAPI
Pct1EncryptRaw( PSPContext          pContext,
                    PSPBuffer       pAppInput,
                    PSPBuffer       pCommOutput,
                    DWORD           dwFlags)
{
    SP_STATUS   pctRet;
    DWORD       cPadding;
    SPBuffer    Encrypted;

    BOOL        fEscape;
    DWORD       cbHeader;
    DWORD       cbBlockSize;

    BYTE        rgbMac[SP_MAX_DIGEST_LEN];
    DWORD       cbMac;

    fEscape = (0 != (dwFlags & PCT1_ENCRYPT_ESCAPE));

    cbBlockSize = pContext->pCipherInfo->dwBlockSize;

    cPadding = pAppInput->cbData & (cbBlockSize - 1);
    if(cPadding)
    {
        cPadding = cbBlockSize - cPadding;
    }

    if(fEscape || (cbBlockSize > 1)) 
    {
        cbHeader = sizeof(PCT1_MESSAGE_HEADER_EX);
    }
    else
    {
        cbHeader = sizeof(PCT1_MESSAGE_HEADER);
    }

    if(pCommOutput->cbBuffer < (cbHeader + cPadding + pAppInput->cbData))
    {
        return PCT_INT_BUFF_TOO_SMALL;
    }

    Encrypted.pvBuffer = (PUCHAR)pCommOutput->pvBuffer + cbHeader;
    Encrypted.cbBuffer = pCommOutput->cbBuffer - cbHeader;
    Encrypted.cbData   = pAppInput->cbData;

    // Copy input data to output buffer (we're encrypting in place).
    if(pAppInput->pvBuffer != Encrypted.pvBuffer)
    {
        DebugLog((DEB_WARN, "Pct1EncryptRaw: Unnecessary Move, performance hog\n"));
        MoveMemory(Encrypted.pvBuffer,
                   pAppInput->pvBuffer,
                   pAppInput->cbData);
    }

    /* Generate Padding */
    pctRet = GenerateRandomBits((PUCHAR)Encrypted.pvBuffer + Encrypted.cbData, cPadding);
    if(!NT_SUCCESS(pctRet))
    {
        return SP_LOG_RESULT(pctRet);
    }
    Encrypted.cbData += cPadding;

    DebugLog((DEB_TRACE, "Sealing message %x\n", pContext->WriteCounter));

     // Transfer the write key over from the application process.
    if(pContext->hWriteKey == 0)
    {
        DebugLog((DEB_TRACE, "Transfer write key from user process.\n"));
        pctRet = SPGetUserKeys(pContext, SCH_FLAG_WRITE_KEY);
        if(pctRet != PCT_ERR_OK)
        {
            return SP_LOG_RESULT(pctRet);
        }
    }

    // Compute the MAC.
    cbMac = sizeof(rgbMac);
    pctRet = Pct1ComputeMac(pContext,
                            TRUE,
                            &Encrypted,
                            pContext->WriteCounter,
                            rgbMac,
                            &cbMac);
    if(pctRet != PCT_ERR_OK)
    {
        return SP_LOG_RESULT(pctRet);
    }

    pContext->WriteCounter ++ ;

   // Encrypt data.
    if(!CryptEncrypt(pContext->hWriteKey,
                     0, FALSE, 0,
                     Encrypted.pvBuffer,
                     &Encrypted.cbData,
                     Encrypted.cbBuffer))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }

    // Add MAC to encrypted buffer.
    if(Encrypted.cbData + cbMac > Encrypted.cbBuffer)
    {
        return PCT_INT_BUFF_TOO_SMALL;
    }
    CopyMemory((PUCHAR)Encrypted.pvBuffer + Encrypted.cbData,
               rgbMac,
               cbMac);
    Encrypted.cbData += cbMac;

    /* set sizes */
    if(fEscape || (cbBlockSize > 1)) 
    {
        if(Encrypted.cbData > 0x3fff)
        {
            return PCT_INT_DATA_OVERFLOW;
        }

        ((PUCHAR)pCommOutput->pvBuffer)[0]= (UCHAR)(0x3f & (Encrypted.cbData>>8));
        if(fEscape)
        {
            ((PUCHAR)pCommOutput->pvBuffer)[0] |= 0x40;
        }

        ((PUCHAR)pCommOutput->pvBuffer)[1]= (UCHAR)(0xff & Encrypted.cbData);
        ((PUCHAR)pCommOutput->pvBuffer)[2]= (UCHAR)cPadding;

    } 
    else 
    {
        if(Encrypted.cbData > 0x7fff)
        {
            return PCT_INT_DATA_OVERFLOW;
        }
        ((PUCHAR)pCommOutput->pvBuffer)[0]= (UCHAR)(0x7f & (Encrypted.cbData>>8)) | 0x80;
        ((PUCHAR)pCommOutput->pvBuffer)[1]= (UCHAR)(0xff & Encrypted.cbData);
    }

    pCommOutput->cbData = Encrypted.cbData + cbHeader;

#if DBG
    {
        DWORD di;
        CHAR  KeyDispBuf[SP_MAX_DIGEST_LEN*2+1];

        for(di=0;di<cbMac;di++)
            wsprintf(KeyDispBuf+(di*2), "%2.2x", rgbMac[di]);
        DebugLog((DEB_TRACE, "  Computed MAC\t%s\n", KeyDispBuf));
    }
#endif
    
    return PCT_ERR_OK;
}

SP_STATUS WINAPI
Pct1EncryptMessage( PSPContext      pContext,
                    PSPBuffer       pAppInput,
                    PSPBuffer       pCommOutput)
{
    return Pct1EncryptRaw(pContext, pAppInput, pCommOutput,0);
}

SP_STATUS WINAPI
Pct1GetHeaderSize(
    PSPContext pContext,
    PSPBuffer pCommInput,
    DWORD * pcbHeaderSize)
{
    UNREFERENCED_PARAMETER(pContext);

    if(pcbHeaderSize == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }
    if(pCommInput->cbData < 1)
    {
        return (PCT_INT_INCOMPLETE_MSG);
    }
    if(  ((PUCHAR)pCommInput->pvBuffer)[0]&0x80 )
    {
        *pcbHeaderSize = 2;
    }
    else
    {
        *pcbHeaderSize = 3;
    }
    return PCT_ERR_OK;
}


SP_STATUS WINAPI
Pct1DecryptMessage(PSPContext pContext,
                   PSPBuffer  pMessage,
                   PSPBuffer  pAppOutput)
{
    SP_STATUS   pctRet;
    DWORD       cbHeader;
    DWORD       cbPadding;
    DWORD       cbPayload;
    DWORD       cbActualData;

    SPBuffer    Encrypted;

    PUCHAR      pbMAC;
    BYTE        rgbMac[SP_MAX_DIGEST_LEN];
    DWORD       cbMac;

    cbActualData = pMessage->cbData;

    // Do we have a complete header?
    pMessage->cbData = 2;
    if(cbActualData < 2)
    {
        return PCT_INT_INCOMPLETE_MSG;
    }

    if(((PUCHAR)pMessage->pvBuffer)[0] & 0x80)
    {
        cbHeader = 2;
        cbPadding = 0;
        cbPayload = MAKEWORD(((PUCHAR)pMessage->pvBuffer)[1],
                             ((PUCHAR)pMessage->pvBuffer)[0] & 0x7f);
    }
    else
    {
        // Do we still have a complete header?
        cbHeader = 3;
        pMessage->cbData++;
        if(cbActualData < cbHeader)
        {
            return PCT_INT_INCOMPLETE_MSG;
        }
        cbPadding = ((PUCHAR)pMessage->pvBuffer)[2];
        cbPayload = MAKEWORD(((PUCHAR)pMessage->pvBuffer)[1],
                            ((PUCHAR)pMessage->pvBuffer)[0] & 0x3f);
    }

    // Do we have the complete message?
    pMessage->cbData += cbPayload;
    if(cbActualData < cbHeader + cbPayload)
    {
        return PCT_INT_INCOMPLETE_MSG;
    }

    /* do we have enough data for our checksum */
    if(cbPayload < pContext->pHashInfo->cbCheckSum)
    {
        return SP_LOG_RESULT(PCT_INT_MSG_ALTERED);
    }

    Encrypted.pvBuffer = (PUCHAR)pMessage->pvBuffer + cbHeader;
    Encrypted.cbBuffer = cbPayload - pContext->pHashInfo->cbCheckSum;
    Encrypted.cbData   = Encrypted.cbBuffer;

    pbMAC = (PUCHAR)Encrypted.pvBuffer + Encrypted.cbData;

    /* check to see if we have a block size violation */
    if(Encrypted.cbData % pContext->pCipherInfo->dwBlockSize)
    {
        return SP_LOG_RESULT(PCT_INT_MSG_ALTERED);
    }

    Encrypted.cbBuffer = Encrypted.cbData;
    
    // Decrypt message.
    if(Encrypted.cbData > pAppOutput->cbBuffer)
    {
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }
    if(Encrypted.pvBuffer != pAppOutput->pvBuffer)
    {
        DebugLog((DEB_WARN, "Pct1DecryptMessage: Unnecessary MoveMemory, performance hog\n"));

        MoveMemory(pAppOutput->pvBuffer, 
                   Encrypted.pvBuffer,
                   Encrypted.cbData);
    }
    pAppOutput->cbData = Encrypted.cbData;

    // Transfer the read key over from the application process.
    if(pContext->hReadKey == 0)
    {
        DebugLog((DEB_TRACE, "Transfer read key from user process.\n"));
        pctRet = SPGetUserKeys(pContext, SCH_FLAG_READ_KEY);
        if(pctRet != PCT_ERR_OK)
        {
            return SP_LOG_RESULT(pctRet);
        }
    }

    if(!CryptDecrypt(pContext->hReadKey,
                     0, FALSE, 0,
                     pAppOutput->pvBuffer,
                     &pAppOutput->cbData))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }
    
    // Compute MAC
    cbMac = sizeof(rgbMac);
    pctRet = Pct1ComputeMac(pContext,
                            FALSE,
                            pAppOutput,
                            pContext->ReadCounter,
                            rgbMac,
                            &cbMac);
    if(pctRet != PCT_ERR_OK)
    {
        return SP_LOG_RESULT(pctRet);
    }

    pContext->ReadCounter++;

#if DBG
    {
        DWORD di;
        CHAR  KeyDispBuf[SP_MAX_DIGEST_LEN*2+1];

        for(di=0;di<pContext->pHashInfo->cbCheckSum;di++)
            wsprintf(KeyDispBuf+(di*2), "%2.2x", pbMAC[di]);
        DebugLog((DEB_TRACE, "  Incoming MAC\t%s\n", KeyDispBuf));

        for(di=0;di<cbMac;di++)
            wsprintf(KeyDispBuf+(di*2), "%2.2x", rgbMac[di]);
        DebugLog((DEB_TRACE, "  Computed MAC\t%s\n", KeyDispBuf));
    }
#endif

    // Validate MAC
    if (memcmp( rgbMac, pbMAC, cbMac ) )
    {
        return SP_LOG_RESULT(PCT_INT_MSG_ALTERED);
    }

    // Strip off the block cipher padding.
    if(cbPadding > pAppOutput->cbData)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }
    pAppOutput->cbData -= cbPadding;

    return( PCT_ERR_OK );
}

#if 0
SP_STATUS
PctComputeKey(PSPContext    pContext,
              PBYTE         pKey,
              DWORD         cbKey,
              PUCHAR        pConst,
              DWORD         dwCLen,
              DWORD         fFlags)
{
    DWORD               pctRet;
    HashBuf             HBHash;
    PCheckSumBuffer     pHash;
    PSessCacheItem      pZombie=NULL;
    PSPCredentialGroup  pCred=NULL;

    BYTE                i,j;

    DWORD                iMax;

    BYTE                Buffer[MAX_CHECKSUM];


    pZombie = pContext->RipeZombie;
    pCred = pZombie ->pCred;

    SP_BEGIN("PctComputeKey");
    pHash = (PCheckSumBuffer)HBHash;



    iMax = (cbKey + pContext->pHashInfo->cbCheckSum - 1)/pContext->pHashInfo->cbCheckSum;
    
    if(iMax > 4)
    {
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    for(i=1; i <= iMax; i++)
    {
        InitHashBuf(HBHash, pContext);
        pContext->pHashInfo->System->Sum( pHash, 1, &i );


        if (!(fFlags & PCT_MAKE_MAC))
        {
            // constant^i
            pContext->pHashInfo->System->Sum( pHash, dwCLen*i, pConst);
        }

        // MASTER KEY
        pContext->pHashInfo->System->Sum( pHash, pContext->RipeZombie->cbMasterKey, pContext->RipeZombie->pMasterKey);

        // constant^i
        pContext->pHashInfo->System->Sum( pHash, dwCLen*i, pConst);

        // ConnectionID
        pContext->pHashInfo->System->Sum( pHash, pContext->cbConnectionID, pContext->pConnectionID);

        // constant^i
        pContext->pHashInfo->System->Sum( pHash, dwCLen*i, pConst);




        if (fFlags & PCT_USE_CERT)
        {

            /* add in the certificate */

            pContext->pHashInfo->System->Sum( pHash, pZombie->cbServerCertificate, pZombie->pbServerCertificate );

            // constant^i
            pContext->pHashInfo->System->Sum( pHash, dwCLen*i, pConst);
        }
        // ConnectionID
        pContext->pHashInfo->System->Sum( pHash, pContext->cbChallenge, pContext->pChallenge);

        // constant^i
        pContext->pHashInfo->System->Sum( pHash, dwCLen*i, pConst);
        if(pContext->pHashInfo->cbCheckSum*i <= cbKey)
        {
            pContext->pHashInfo->System->Finalize( pHash, pKey + pContext->pHashInfo->cbCheckSum*(i-1) );
        }
        else
        {
            pContext->pHashInfo->System->Finalize( pHash, Buffer );
            CopyMemory(pKey + pContext->pHashInfo->cbCheckSum*(i-1), 
                       Buffer,
                       cbKey - pContext->pHashInfo->cbCheckSum*(i-1));
        }

    }

    SP_RETURN(PCT_ERR_OK);
}
#endif

#if 0
SP_STATUS
PctComputeExportKey(PSPContext    pContext,
                    PBYTE         pKey,
                    DWORD         cbWriteKey,
                    DWORD         cbCipherKey)
{
    DWORD               pctRet;
    HashBuf             HBHash;
    PCheckSumBuffer     pHash;
    PSessCacheItem      pZombie=NULL;
    PSPCredentialGroup  pCred=NULL;

    BYTE                i,j;

    DWORD               d;
    DWORD               cbClearChunk;
    BYTE                pWriteKey[SP_MAX_MASTER_KEY];

    BYTE                Buffer[MAX_CHECKSUM];


    pZombie = pContext->RipeZombie;
    pCred = pZombie ->pCred;

    SP_BEGIN("PctComputeKey");
    pHash = (PCheckSumBuffer)HBHash;


    CopyMemory(pWriteKey, pKey, cbWriteKey);

    d = (cbCipherKey + pContext->pHashInfo->cbCheckSum - 1)/pContext->pHashInfo->cbCheckSum;
    
    if(d > 4)
    {
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    cbClearChunk = pContext->RipeZombie->cbClearKey/d;

    for(i=1; i <= d; i++)
    {
        InitHashBuf(HBHash, pContext);
        pContext->pHashInfo->System->Sum( pHash, 1, &i );


        // constant^i
        pContext->pHashInfo->System->Sum( pHash, PCT_CONST_SLK_LEN*i, PCT_CONST_SLK);

        // WRITE_KEY
        pContext->pHashInfo->System->Sum( pHash, cbWriteKey, pWriteKey);

        // constant^i
        pContext->pHashInfo->System->Sum( pHash, PCT_CONST_SLK_LEN*i, PCT_CONST_SLK);

        // Clear Key
        pContext->pHashInfo->System->Sum( pHash, 
                               cbClearChunk, 
                               (PBYTE)pContext->RipeZombie->pClearKey + (i-1)*cbClearChunk);

        if(pContext->pHashInfo->cbCheckSum*i <= cbCipherKey)
        {
            pContext->pHashInfo->System->Finalize( pHash, pKey + pContext->pHashInfo->cbCheckSum*(i-1) );
        }
        else
        {
            pContext->pHashInfo->System->Finalize( pHash, Buffer );
            CopyMemory(pKey + pContext->pHashInfo->cbCheckSum*(i-1), 
                       Buffer,
                       cbCipherKey - pContext->pHashInfo->cbCheckSum*(i-1));
        }

    }

    SP_RETURN(PCT_ERR_OK);
}
#endif

#if 0
SP_STATUS
Pct1MakeSessionKeys(
    PSPContext  pContext)
{
    SP_STATUS           pctRet;
    BOOL                fClient;
    UCHAR               pWriteKey[SP_MAX_MASTER_KEY], pReadKey[SP_MAX_MASTER_KEY];
#if DBG
    DWORD       i;
    CHAR        KeyDispBuf[SP_MAX_MASTER_KEY*2+1];
#endif
    PSessCacheItem      pZombie=NULL;
    PSPCredentialGroup  pCred=NULL;


    SP_BEGIN("PctMakeSessionKeys");
    pZombie = pContext->RipeZombie;
    pCred = pZombie ->pCred;

    if (!pContext->InitMACState) 
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }
    
    

#if DBG
    DebugLog((DEB_TRACE, "Making session keys\n", KeyDispBuf));

    for(i=0;i<PCT_SESSION_ID_SIZE;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x",
                pContext->pConnectionID[i]);
    DebugLog((DEB_TRACE, "  ConnId\t%s\n", KeyDispBuf));


    for(i=0;i<PCT_CHALLENGE_SIZE;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", (UCHAR)pContext->pChallenge[i]);
    DebugLog((DEB_TRACE, "  Challenge \t%s\n", KeyDispBuf));

    for(i=0;i<pContext->RipeZombie->cbClearKey;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", (UCHAR)pContext->RipeZombie->pClearKey[i]);
    DebugLog((DEB_TRACE, "  ClearKey \t%s\n", KeyDispBuf));

#endif



    fClient = ((pContext->Flags & CONTEXT_FLAG_CLIENT) != 0);

    pctRet = PctComputeKey( pContext, fClient?pWriteKey:pReadKey, pContext->pCipherInfo->cbSecret, PCT_CONST_CWK,
                            PCT_CONST_CWK_LEN, PCT_USE_CERT);

    if(PCT_ERR_OK != pctRet)
    {
        goto quit;
    }

    pctRet = PctComputeKey( pContext, fClient?pReadKey:pWriteKey, pContext->pCipherInfo->cbSecret, PCT_CONST_SWK,
                   PCT_CONST_SWK_LEN, 0);
    if(PCT_ERR_OK != pctRet)
    {
        goto quit;
    }
    


    /* compute the ClientMacKey */

    pctRet = PctComputeKey(pContext, 
                           (fClient?pContext->WriteMACKey:pContext->ReadMACKey), 
                           pContext->pHashInfo->cbCheckSum, 
                           PCT_CONST_CMK,
                           PCT_CONST_CMK_LEN, 
                           PCT_USE_CERT | PCT_MAKE_MAC);

    if(PCT_ERR_OK != pctRet)
    {
        goto quit;
    }

    /* compute the ServerMacKey */

    pctRet = PctComputeKey(pContext, 
                           (fClient?pContext->ReadMACKey:pContext->WriteMACKey), 
                            pContext->pHashInfo->cbCheckSum, 
                            PCT_CONST_SMK,
                            PCT_CONST_SMK_LEN, 
                            PCT_MAKE_MAC);

    if(PCT_ERR_OK != pctRet)
    {
        goto quit;
    }

    // Initialize the hash states

    InitHashBuf(pContext->RdMACBuf, pContext);
    InitHashBuf(pContext->WrMACBuf, pContext);

    // Note, we truncuate the MACing keys down to the negotiated key size
    pContext->ReadMACState = (PCheckSumBuffer)pContext->RdMACBuf;

    pContext->pHashInfo->System->Sum( pContext->ReadMACState, 
                           pContext->pHashInfo->cbCheckSum,
                           pContext->ReadMACKey);
    
    pContext->WriteMACState = (PCheckSumBuffer)pContext->WrMACBuf;

    pContext->pHashInfo->System->Sum( pContext->WriteMACState, 
                           pContext->pHashInfo->cbCheckSum,
                           pContext->WriteMACKey);

    if (pContext->pCipherInfo->cbSecret < pContext->pCipherInfo->cbKey)
    {
        pctRet = PctComputeExportKey(pContext,
                            pWriteKey,
                            pContext->pCipherInfo->cbSecret,
                            pContext->pCipherInfo->cbKey);

        if(PCT_ERR_OK != pctRet)
        {
            goto quit;
        }

        pctRet = PctComputeExportKey(pContext,
                            pReadKey,
                            pContext->pCipherInfo->cbSecret,
                            pContext->pCipherInfo->cbKey);

        if(PCT_ERR_OK != pctRet)
        {
            goto quit;
        }
       /* chop the encryption keys down to selected length */


    }



#if DBG

    for(i=0;i<pContext->RipeZombie->cbMasterKey;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", pContext->RipeZombie->pMasterKey[i]);
    DebugLog((DEB_TRACE, "  MasterKey \t%s\n", KeyDispBuf));

    for(i=0;i<pContext->pCipherInfo->cbKey;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", pReadKey[i]);
    DebugLog((DEB_TRACE, "    ReadKey\t%s\n", KeyDispBuf));

    for(i=0;i<pContext->pHashInfo->cbCheckSum;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", pContext->ReadMACKey[i]);
    DebugLog((DEB_TRACE, "     MACKey\t%s\n", KeyDispBuf));

    for(i=0;i<pContext->pCipherInfo->cbKey;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", pWriteKey[i]);
    DebugLog((DEB_TRACE, "    WriteKey\t%s\n", KeyDispBuf));

    for(i=0;i<pContext->pHashInfo->cbCheckSum;i++)
        wsprintf(KeyDispBuf+(i*2), "%2.2x", pContext->WriteMACKey[i]);
    DebugLog((DEB_TRACE, "     MACKey\t%s\n", KeyDispBuf));

#endif

    if (pContext->pCipherInfo->System->Initialize(  pReadKey,
                                        pContext->pCipherInfo->cbKey,
                                        pZombie->pKeyArgs,       // IV
                                        pZombie->cbKeyArgs,      // IV length
                                        &pContext->pReadState ) )
    {
        if (pContext->pCipherInfo->System->Initialize(  pWriteKey,
                                            pContext->pCipherInfo->cbKey,
                                            pZombie->pKeyArgs,       // IV
                                            pZombie->cbKeyArgs,      // IV length
                                            &pContext->pWriteState) )
        {
            pctRet = PCT_ERR_OK;
            goto quit;
        }
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        pContext->pCipherInfo->System->Discard( &pContext->pReadState );
    }

    pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);

quit:
    SP_RETURN(pctRet);
}
#endif

SP_STATUS WINAPI Pct1DecryptHandler(PSPContext  pContext,
                              PSPBuffer  pCommInput,
                              PSPBuffer  pAppOutput)
{
    SP_STATUS      pctRet= 0;
    BOOL           fEscape;
    PPCT1_CLIENT_HELLO pHello;
    if(pCommInput->cbData > 0) {        
        /* first, we'll handle incoming data packets */
        if((pContext->State == SP_STATE_CONNECTED) && (pContext->Decrypt)) 
        {
            fEscape = (((*(PUCHAR)pCommInput->pvBuffer) & 0xc0) == 0x40);
            /* BUGFIX:  IE 3.0 and 3.0a incorrectly respond to a REDO request
             * by just sending a PCT1 client hello, instead of another REDO.
             * We therefore look at the incomming message and see if it
             * looks like a PCT1 client hello.
             */
            pHello = (PPCT1_CLIENT_HELLO)pCommInput->pvBuffer;

            if((pCommInput->cbData >= 5) &&
               (pHello->MessageId == PCT1_MSG_CLIENT_HELLO) &&
               (pHello->VersionMsb == MSBOF(PCT_VERSION_1)) &&
               (pHello->VersionLsb == LSBOF(PCT_VERSION_1)) &&
               (pHello->OffsetMsb  == MSBOF(PCT_CH_OFFSET_V1)) &&
               (pHello->OffsetLsb  == LSBOF(PCT_CH_OFFSET_V1)))
            {
                // This looks a lot like a client hello
                 /* InitiateRedo */
                pAppOutput->cbData = 0;
                pCommInput->cbData = 0;

                pContext->State = PCT1_STATE_RENEGOTIATE;
;
                return SP_LOG_RESULT(PCT_INT_RENEGOTIATE);
           }

            if(PCT_ERR_OK == 
               (pctRet = pContext->Decrypt(pContext, 
                                           pCommInput,   /* message */ 
                                           pAppOutput /* Unpacked Message */
                                ))) 
            {  
                /* look for escapes */
                if(fEscape) 
                {
                    if(pAppOutput->cbData < 1)
                    {
                        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
                    }
                    /* The first byte of the decrypt buffer is the escape code */
                    switch(*(PUCHAR)pAppOutput->pvBuffer) 
                    {
                        case PCT1_ET_REDO_CONN:
                        {
                            /* InitiateRedo */
                            if(pAppOutput->cbData != 1)
                            {
                                return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
                            }
                            pContext->State = PCT1_STATE_RENEGOTIATE;
                            pAppOutput->cbData = 0;
                            return SP_LOG_RESULT(PCT_INT_RENEGOTIATE);
                        }
                        case PCT1_ET_OOB_DATA:
                            /* HandleOOB */
                        default:
                            /* Unknown escape, generate error */
                            pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
                            /* Disconnect */
                            break;
                    }

                }
            }
            return (pctRet);

        } 
        else 
        {
            return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        }
    }
    return PCT_INT_INCOMPLETE_MSG;
}

SP_STATUS Pct1GenerateError(PSPContext  pContext,
                              PSPBuffer  pCommOutput,
                              SP_STATUS  pError,
                              PSPBuffer  pErrData)
{
    Pct1Error            XmitError;
    
    /* Only pack up an error if we are allowed to return errors */
    if(!(pContext->Flags & CONTEXT_FLAG_EXT_ERR)) return pError;

    XmitError.Error = pError;
    XmitError.ErrInfoLen = 0;
    XmitError.ErrInfo = NULL;

    if(pErrData) {
        XmitError.ErrInfoLen = pErrData->cbData;
        XmitError.ErrInfo = pErrData->pvBuffer;
    }
    Pct1PackError(&XmitError,
                 pCommOutput);
    return pError;
}

/* session key computation */


SP_STATUS Pct1HandleError(PSPContext  pContext,
                          PSPBuffer  pCommInput,
                          PSPBuffer  pCommOutput)
{
    UNREFERENCED_PARAMETER(pContext);

    pCommOutput->cbData = 0;
    return(((PPCT1_ERROR)pCommInput->pvBuffer)->ErrorMsb << 8 )|  ((PPCT1_ERROR)pCommInput->pvBuffer)->ErrorLsb;
}

//+---------------------------------------------------------------------------
//
//  Function:   Pct1BeginVerifyPrelude
//
//  Synopsis:   Initiate the "verify prelude" computation.
//
//  Arguments:  [pContext]      --  Schannel context.
//              [pClientHello]  -- 
//              [cbClientHello] --
//              [pServerHello]  -- 
//              [cServerHello]  --
//
//  History:    10-10-97   jbanes   Added CAPI integration.
//
//  Notes:      Hash(CLIENT_MAC_KEY, Hash("cvp", CLIENT_HELLO, SERVER_HELLO));
//
//----------------------------------------------------------------------------
SP_STATUS Pct1BeginVerifyPrelude(PSPContext pContext,
                                 PUCHAR     pClientHello,
                                 DWORD      cbClientHello,
                                 PUCHAR     pServerHello,
                                 DWORD      cbServerHello)
{
    HCRYPTHASH hHash;

    if(!CryptCreateHash(pContext->RipeZombie->hMasterProv,
                        pContext->pHashInfo->aiHash,
                        0,
                        0,
                        &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!CryptHashData(hHash, 
                      (PBYTE)PCT_CONST_VP, 
                      PCT_CONST_VP_LEN, 
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!CryptHashData(hHash, 
                      pClientHello, 
                      cbClientHello, 
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!CryptHashData(hHash, 
                      pServerHello, 
                      cbServerHello, 
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_INT_INTERNAL_ERROR;
    }

    pContext->hMd5Handshake = hHash;

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   Pct1EndVerifyPrelude
//
//  Synopsis:   Finish the "verify prelude" computation.
//
//  Arguments:  [pContext]          --  Schannel context.
//              [VerifyPrelude]     -- 
//              [pcbVerifyPrelude]  --
//
//  History:    10-10-97   jbanes   Added CAPI integration.
//
//  Notes:      
//
//----------------------------------------------------------------------------
SP_STATUS Pct1EndVerifyPrelude(PSPContext pContext,
                               PUCHAR     VerifyPrelude,
                               DWORD *    pcbVerifyPrelude)
{
    BOOL fClient;
    HCRYPTHASH hHash;

    fClient = !(pContext->RipeZombie->fProtocol & SP_PROT_SERVERS);

    if(!CryptGetHashParam(pContext->hMd5Handshake,
                          HP_HASHVAL,
                          VerifyPrelude,
                          pcbVerifyPrelude,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(pContext->hMd5Handshake);
        pContext->hMd5Handshake = 0;
        return PCT_INT_INTERNAL_ERROR;
    }
    CryptDestroyHash(pContext->hMd5Handshake);
    pContext->hMd5Handshake = 0;

    if(!CryptCreateHash(pContext->RipeZombie->hMasterProv,
                        pContext->pHashInfo->aiHash,
                        0,
                        0,
                        &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }

    if(!CryptHashSessionKey(hHash,
                            fClient ? pContext->hWriteMAC : pContext->hReadMAC,
                            CRYPT_LITTLE_ENDIAN))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_INT_INTERNAL_ERROR;
    }

    if(!CryptHashData(hHash, 
                      VerifyPrelude, 
                      *pcbVerifyPrelude, 
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_INT_INTERNAL_ERROR;
    }

    if(!CryptGetHashParam(hHash,
                          HP_HASHVAL,
                          VerifyPrelude,
                          pcbVerifyPrelude,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_INT_INTERNAL_ERROR;
    }
    CryptDestroyHash(hHash);

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   Pct1ComputeMac
//
//  Synopsis:   Compute the 
//
//  Arguments:  [pContext]          --  Schannel context.
//
//  History:    10-10-97   jbanes   Created.
//
//  Notes:      MAC_DATA := Hash(MAC_KEY, Hash(RECORD_HEADER_DATA, 
//                          ACTUAL_DATA, PADDING_DATA, SEQUENCE_NUMBER))
//
//----------------------------------------------------------------------------
static SP_STATUS
Pct1ComputeMac(
    PSPContext pContext,    // in
    BOOL       fWriteMAC,   // in
    PSPBuffer  pData,       // in
    DWORD      dwSequence,  // in
    PBYTE      pbMac,       // out
    PDWORD     pcbMac)      // in, out
{
    HCRYPTHASH hHash;
    DWORD dwReverseSequence;

    dwReverseSequence = htonl(dwSequence);

    // Compute inner hash
    if(!CryptCreateHash(pContext->RipeZombie->hMasterProv,
                        pContext->pHashInfo->aiHash,
                        0,
                        0,
                        &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!CryptHashData(hHash, 
                      pData->pvBuffer, 
                      pData->cbData, 
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!CryptHashData(hHash, 
                      (PUCHAR)&dwReverseSequence, 
                      sizeof(DWORD), 
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!CryptGetHashParam(hHash, 
                          HP_HASHVAL, 
                          pbMac, 
                          pcbMac, 
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_INT_INTERNAL_ERROR;
    }
    SP_ASSERT(*pcbMac == pContext->pHashInfo->cbCheckSum);
    CryptDestroyHash(hHash);

    // Compute outer hash.
    if(!CryptCreateHash(pContext->RipeZombie->hMasterProv,
                        pContext->pHashInfo->aiHash,
                        0,
                        0,
                        &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!CryptHashSessionKey(hHash,
                            fWriteMAC ? pContext->hWriteMAC : pContext->hReadMAC,
                            CRYPT_LITTLE_ENDIAN))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!CryptHashData(hHash, pbMac, *pcbMac, 0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!CryptGetHashParam(hHash, 
                          HP_HASHVAL, 
                          pbMac, 
                          pcbMac, 
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_INT_INTERNAL_ERROR;
    }
    SP_ASSERT(*pcbMac == pContext->pHashInfo->cbCheckSum);
    CryptDestroyHash(hHash);

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   Pct1ComputeResponse
//
//  Synopsis:   Compute the "response" field of the ServerVerify message.
//
//  Arguments:  [pContext]          --  Schannel context.
//              [pbChallenge]       -- 
//              [cbChallenge]       --
//              [pbConnectionID]    -- 
//              [cbConnectionID]    --
//              [pbSessionID]       -- 
//              [cbSessionID]       -- 
//              [pbResponse]        --
//              [pcbResponse]       -- 
//
//  History:    10-10-97   jbanes   Created.
//
//  Notes:      Hash(SERVER_MAC_KEY, Hash ("sr", CH_CHALLENGE_DATA, 
//              SH_CONNECTION_ID_DATA, SV_SESSION_ID_DATA))
//
//----------------------------------------------------------------------------
SP_STATUS
Pct1ComputeResponse(
    PSPContext pContext,        // in
    PBYTE      pbChallenge,     // in
    DWORD      cbChallenge,     // in
    PBYTE      pbConnectionID,  // in
    DWORD      cbConnectionID,  // in
    PBYTE      pbSessionID,     // in
    DWORD      cbSessionID,     // in
    PBYTE      pbResponse,      // out
    PDWORD     pcbResponse)     // in, out
{
    BOOL fClient;
    HCRYPTHASH hHash = 0;
    SP_STATUS pctRet;

    fClient = !(pContext->RipeZombie->fProtocol & SP_PROT_SERVERS);

    //
    // Hash ("sr", CH_CHALLENGE_DATA, SH_CONNECTION_ID_DATA,
    // SV_SESSION_ID_DATA). Place the result in pbResponse.
    //

    if(!CryptCreateHash(pContext->RipeZombie->hMasterProv,
                        pContext->pHashInfo->aiHash,
                        0,
                        0,
                        &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!CryptHashData(hHash, 
                      (PBYTE)PCT_CONST_RESP, 
                      PCT_CONST_RESP_LEN, 
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!CryptHashData(hHash,
                      pbChallenge,
                      cbChallenge,
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!CryptHashData(hHash,
                      pbConnectionID,
                      cbConnectionID,
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!CryptHashData(hHash,
                      pbSessionID,
                      cbSessionID,
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!CryptGetHashParam(hHash,
                          HP_HASHVAL,
                          pbResponse,
                          pcbResponse,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    CryptDestroyHash(hHash);
    hHash = 0;

    //
    // Hash (SERVER_MAC_KEY, pbResponse). Place the result back in pbResponse.
    //

    if(!CryptCreateHash(pContext->RipeZombie->hMasterProv,
                        pContext->pHashInfo->aiHash,
                        0,
                        0,
                        &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!CryptHashSessionKey(hHash,
                            fClient ? pContext->hReadMAC : pContext->hWriteMAC,
                            CRYPT_LITTLE_ENDIAN))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!CryptHashData(hHash, 
                      pbResponse, 
                      *pcbResponse, 
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!CryptGetHashParam(hHash,
                          HP_HASHVAL,
                          pbResponse,
                          pcbResponse,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    CryptDestroyHash(hHash);
    hHash = 0;

    pctRet = PCT_ERR_OK;

cleanup:

    if(hHash)
    {
        CryptDestroyHash(hHash);
    }

    return pctRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\serial.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       serial.c
//
//  Contents:   Schannel context serialization routines.
//
//  Functions:  SPContextSerialize
//              SPContextDeserialize
//
//  History:    02-15-00   jbanes   Created.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <certmap.h>
#include <mapper.h>
#include <align.h>

typedef enum _SERIALIZED_ITEM_TYPE
{
    SslEndOfBuffer = 0,
    SslContext,
    SslReadKey,
    SslReadMac,
    SslWriteKey,
    SslWriteMac,
    SslMapper,
    SslRemoteCertificate
} SERIALIZED_ITEM_TYPE;

typedef struct _SERIALIZED_ITEM_TAG
{
    DWORD Type;
    DWORD Length;
    DWORD DataLength;
    DWORD reserved;
} SERIALIZED_ITEM_TAG;

#define TAG_LENGTH sizeof(SERIALIZED_ITEM_TAG)


DWORD
GetSerializedKeyLength(
    HCRYPTKEY hKey)
{
    DWORD cbKey;

    if(!CryptExportKey(hKey, 0, OPAQUEKEYBLOB, 0, NULL, &cbKey))
    {
        SP_LOG_RESULT(GetLastError());
        return 0;
    }

    return ROUND_UP_COUNT(TAG_LENGTH + cbKey, ALIGN_LPVOID);
}


SP_STATUS
SerializeKey(
    HCRYPTKEY               hKey,
    SERIALIZED_ITEM_TYPE    Type,
    PBYTE                   pbBuffer,
    PDWORD                  pcbBuffer)
{
    SERIALIZED_ITEM_TAG *pTag;
    PBYTE pbKey;
    DWORD cbKey;

    if(*pcbBuffer <= TAG_LENGTH)
    {
        return SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW);
    }

    pTag = (SERIALIZED_ITEM_TAG *)pbBuffer;

    pbKey = pbBuffer   + TAG_LENGTH;
    cbKey = *pcbBuffer - TAG_LENGTH;

    if(!CryptExportKey(hKey, 0, OPAQUEKEYBLOB, 0, pbKey, &cbKey))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }

    pTag->Type   = Type;
    pTag->Length = ROUND_UP_COUNT(cbKey, ALIGN_LPVOID);
    pTag->DataLength = cbKey;

    if(*pcbBuffer <= TAG_LENGTH + pTag->Length)
    {
        return SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW);
    }

    *pcbBuffer = TAG_LENGTH + pTag->Length;

    return PCT_ERR_OK;
}


SP_STATUS
SerializeContext(
    PSPContext pContext,
    SERIALIZE_LOCATOR_FN LocatorMove,
    PBYTE pbBuffer,
    PDWORD pcbBuffer,
    BOOL fDestroyKeys)
{
    DWORD cbData;
    DWORD cbBuffer;
    DWORD cbBytesNeeded;
    SERIALIZED_ITEM_TAG *pTag;
    PSessCacheItem pZombie;
    SP_STATUS pctRet;

    //
    // Initialize buffer pointers.
    //

    if(pbBuffer == NULL)
    {
        cbBuffer = 0;
    }
    else
    {
        cbBuffer = *pcbBuffer;
    }

    pZombie = pContext->RipeZombie;


    //
    // Context structure.
    //

    cbBytesNeeded = ROUND_UP_COUNT(TAG_LENGTH + sizeof(SPPackedContext),
                                   ALIGN_LPVOID);

    if(pbBuffer == NULL)
    {
        cbBuffer += cbBytesNeeded;
    }
    else
    {
        PSPPackedContext pSerialContext;
        HLOCATOR hLocator;

        if(cbBuffer < cbBytesNeeded)
        {
            return SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW);
        }

        pContext->Flags |= CONTEXT_FLAG_SERIALIZED;

        pTag = (SERIALIZED_ITEM_TAG *)pbBuffer;
        pSerialContext = (PSPPackedContext)(pbBuffer + TAG_LENGTH);

        pTag->Type   = SslContext;
        pTag->Length = cbBytesNeeded - TAG_LENGTH;

        pSerialContext->Magic           = pContext->Magic;
        pSerialContext->State           = pContext->State;
        pSerialContext->Flags           = pContext->Flags;
        pSerialContext->dwProtocol      = pContext->dwProtocol;

        pSerialContext->ContextThumbprint = pContext->ContextThumbprint;

        pSerialContext->dwCipherInfo    = (DWORD)(pContext->pCipherInfo  - g_AvailableCiphers);
        pSerialContext->dwHashInfo      = (DWORD)(pContext->pHashInfo    - g_AvailableHashes);
        pSerialContext->dwKeyExchInfo   = (DWORD)(pContext->pKeyExchInfo - g_AvailableExch);

        pSerialContext->dwExchStrength  = pContext->RipeZombie->dwExchStrength;

        pSerialContext->ReadCounter     = pContext->ReadCounter;
        pSerialContext->WriteCounter    = pContext->WriteCounter;

        if(pZombie->fProtocol & SP_PROT_SERVERS)
        {
            if(pZombie->pActiveServerCred)
            {
                #ifdef _WIN64
                    pSerialContext->hMasterProv.QuadPart = (ULONGLONG)pZombie->pActiveServerCred->hRemoteProv;
                #else
                    pSerialContext->hMasterProv.LowPart  = (DWORD)pZombie->pActiveServerCred->hRemoteProv;
                #endif
            }

            // Copy the locator.
            if(pZombie->phMapper && pZombie->hLocator && LocatorMove)
            {
                LocatorMove(pZombie->hLocator, &hLocator);

                #ifdef _WIN64
                    pSerialContext->hLocator.QuadPart = (ULONGLONG)hLocator;
                #else
                    pSerialContext->hLocator.LowPart  = (DWORD)hLocator;
                #endif
            }

            pSerialContext->LocatorStatus = pZombie->LocatorStatus;
        }

        pSerialContext->cbSessionID = pZombie->cbSessionID;
        memcpy(pSerialContext->SessionID, pZombie->SessionID, pZombie->cbSessionID);

        pbBuffer += cbBytesNeeded;
        cbBuffer -= cbBytesNeeded;
    }


    //
    // Certificate mapper structure.
    //

    if(pContext->RipeZombie->phMapper)
    {
        cbBytesNeeded = ROUND_UP_COUNT(TAG_LENGTH + sizeof(PVOID),
                                       ALIGN_LPVOID);

        if(pbBuffer == NULL)
        {
            cbBuffer += cbBytesNeeded;
        }
        else
        {
            if(cbBuffer < cbBytesNeeded)
            {
                return SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW);
            }

            pTag = (SERIALIZED_ITEM_TAG *)pbBuffer;

            pTag->Type   = SslMapper;
            pTag->Length = cbBytesNeeded - TAG_LENGTH;

            CopyMemory(pbBuffer + TAG_LENGTH,
                       &pZombie->phMapper->m_Reserved1,
                       sizeof(PVOID));

            pbBuffer += cbBytesNeeded;
            cbBuffer -= cbBytesNeeded;
        }
    }


    //
    // Data encryption and MAC keys.
    //

    if(pContext->pCipherInfo->aiCipher != CALG_NULLCIPHER)
    {
        // Read key.
        if(pbBuffer == NULL)
        {
            cbBuffer += GetSerializedKeyLength(pContext->hReadKey);
        }
        else
        {
            cbData = cbBuffer;
            pctRet = SerializeKey(pContext->hReadKey,
                                  SslReadKey,
                                  pbBuffer,
                                  &cbData);
            if(pctRet != PCT_ERR_OK)
            {
                return pctRet;
            }
            if(fDestroyKeys)
            {
                if(!CryptDestroyKey(pContext->hReadKey))
                {
                    SP_LOG_RESULT(GetLastError());
                }
                pContext->hReadKey = 0;
            }

            pbBuffer += cbData;
            cbBuffer -= cbData;
        }

        // Write key.
        if(pbBuffer == NULL)
        {
            cbBuffer += GetSerializedKeyLength(pContext->hWriteKey);
        }
        else
        {
            cbData = cbBuffer;
            pctRet = SerializeKey(pContext->hWriteKey,
                                  SslWriteKey,
                                  pbBuffer,
                                  &cbData);
            if(pctRet != PCT_ERR_OK)
            {
                return pctRet;
            }
            if(fDestroyKeys)
            {
                if(!CryptDestroyKey(pContext->hWriteKey))
                {
                    SP_LOG_RESULT(GetLastError());
                }
                pContext->hWriteKey = 0;
            }

            pbBuffer += cbData;
            cbBuffer -= cbData;
        }
    }

    // Read MAC.
    if(pContext->hReadMAC)
    {
        if(pbBuffer == NULL)
        {
            cbBuffer += GetSerializedKeyLength(pContext->hReadMAC);
        }
        else
        {
            cbData = cbBuffer;
            pctRet = SerializeKey(pContext->hReadMAC,
                                  SslReadMac,
                                  pbBuffer,
                                  &cbData);
            if(pctRet != PCT_ERR_OK)
            {
                return pctRet;
            }

            pbBuffer += cbData;
            cbBuffer -= cbData;
        }
    }

    // Write MAC.
    if(pContext->hWriteMAC)
    {
        if(pbBuffer == NULL)
        {
            cbBuffer += GetSerializedKeyLength(pContext->hWriteMAC);
        }
        else
        {
            cbData = cbBuffer;
            pctRet = SerializeKey(pContext->hWriteMAC,
                                  SslWriteMac,
                                  pbBuffer,
                                  &cbData);
            if(pctRet != PCT_ERR_OK)
            {
                return pctRet;
            }

            pbBuffer += cbData;
            cbBuffer -= cbData;
        }
    }


    //
    // Remote certificate.
    //

    if(pContext->RipeZombie->pRemoteCert)
    {
        if(pbBuffer == NULL)
        {
            pctRet = SerializeCertContext(pContext->RipeZombie->pRemoteCert,
                                          NULL,
                                          &cbData);
            if(pctRet != PCT_ERR_OK)
            {
                return SP_LOG_RESULT(pctRet);
            }

            cbBytesNeeded = ROUND_UP_COUNT(TAG_LENGTH + cbData, ALIGN_LPVOID);

            cbBuffer += cbBytesNeeded;
        }
        else
        {
            if(cbBuffer < TAG_LENGTH)
            {
                return SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW);
            }
            cbData = cbBuffer - TAG_LENGTH;

            pctRet = SerializeCertContext(pContext->RipeZombie->pRemoteCert,
                                          pbBuffer + TAG_LENGTH,
                                          &cbData);
            if(pctRet != PCT_ERR_OK)
            {
                return SP_LOG_RESULT(pctRet);
            }

            cbBytesNeeded = ROUND_UP_COUNT(TAG_LENGTH + cbData, ALIGN_LPVOID);

            pTag = (SERIALIZED_ITEM_TAG *)pbBuffer;

            pTag->Type   = SslRemoteCertificate;
            pTag->Length = cbBytesNeeded - TAG_LENGTH;

            pbBuffer += cbBytesNeeded;
            cbBuffer -= cbBytesNeeded;
        }
    }


    //
    // End of buffer marker.
    //

    if(pbBuffer == NULL)
    {
        cbBuffer += TAG_LENGTH;
    }
    else
    {
        if(cbBuffer < TAG_LENGTH)
        {
            return SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW);
        }

        pTag = (SERIALIZED_ITEM_TAG *)pbBuffer;

        pTag->Type   = SslEndOfBuffer;
        pTag->Length = 0;

        pbBuffer += TAG_LENGTH;
        cbBuffer -= TAG_LENGTH;
    }

    if(pbBuffer == NULL)
    {
        *pcbBuffer = cbBuffer;
    }
    else
    {
        #if DBG
        if(cbBuffer)
        {
            DebugLog((DEB_WARN, "%d bytes left over when serializing context.\n", cbBuffer));
        }
        #endif
    }

    return PCT_ERR_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   SPContextSerialize
//
//  Synopsis:   Extract out everything necessary for bulk data encryption
//              from an Schannel context, and place it in a linear buffer.
//
//  Arguments:  [pCred]         --  Context to be serialized.
//              [ppBuffer]      --  Destination buffer.
//              [pcbBuffer]     --  Destination buffer length.
//
//  History:    09-25-96   jbanes   Hacked for LSA integration.
//
//  Notes:      This routine is called by the LSA process when transitioning
//              from the handshaking phase to the bulk encryption phase.
//
//              This function is also called by the application process as
//              part of ExportSecurityContext.
//
//----------------------------------------------------------------------------
SP_STATUS
SPContextSerialize(
    PSPContext  pContext,
    SERIALIZE_LOCATOR_FN LocatorMove,
    PBYTE *     ppBuffer,
    PDWORD      pcbBuffer,
    BOOL        fDestroyKeys)
{
    PBYTE       pbBuffer;
    DWORD       cbBuffer;
    SP_STATUS   pctRet;

    // Determine size of serialized buffer.
    pctRet = SerializeContext(pContext, LocatorMove, NULL, &cbBuffer, fDestroyKeys);
    if(pctRet != PCT_ERR_OK)
    {
        return SP_LOG_RESULT(pctRet);
    }

    // Allocate memory for serialized buffer.
    pbBuffer = SPExternalAlloc(cbBuffer);
    if(pbBuffer == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    // Generate serialized context.
    pctRet = SerializeContext(pContext, LocatorMove, pbBuffer, &cbBuffer, fDestroyKeys);
    if(pctRet != PCT_ERR_OK)
    {
        SPExternalFree(pbBuffer);
        return SP_LOG_RESULT(pctRet);
    }

    // Set outputs
    *ppBuffer  = pbBuffer;
    *pcbBuffer = cbBuffer;

    return PCT_ERR_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   SPContextDeserialize
//
//  Synopsis:   Build an Schannel context structure from a linear buffer,
//              which was created via SPContextSerialize by the other
//              process.
//
//  Arguments:  [pBuffer]       --  Buffer containing serialized context.
//                                  The new context structure is built over
//                                  the top of this buffer.
//
//  History:    09-25-96   jbanes   Hacked for LSA integration.
//
//  Notes:      This routine is called by the application process when
//              transitioning from the handshaking phase to the bulk
//              encryption phase.
//
//----------------------------------------------------------------------------
SP_STATUS
SPContextDeserialize(
    PBYTE pbBuffer,
    PSPContext *ppContext)
{
    PSPContext  pContext = NULL;
    DWORD       Status = PCT_INT_INTERNAL_ERROR;
    BOOL        fDone;
    PSPPackedContext pSerialContext;
    PSessCacheItem pZombie;
    SERIALIZED_ITEM_TAG *pTag;
    DWORD       cbContext;

    DebugLog((DEB_TRACE, "Deserialize context\n"));

    //
    // Extract serialized context.
    //

    pTag = (SERIALIZED_ITEM_TAG *)pbBuffer;

    if(pTag->Type != SslContext)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }
    if(pTag->Length < sizeof(PSPPackedContext))
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    pSerialContext = (PSPPackedContext)(pbBuffer + TAG_LENGTH);

    cbContext = ROUND_UP_COUNT(sizeof(SPContext), ALIGN_LPVOID);

    pContext = SPExternalAlloc(cbContext + sizeof(SessCacheItem));
    if(pContext == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    pContext->RipeZombie = (PSessCacheItem)((PBYTE)pContext + cbContext);
    pZombie = pContext->RipeZombie;

    pContext->Magic             = pSerialContext->Magic;
    pContext->State             = pSerialContext->State;
    pContext->Flags             = pSerialContext->Flags;
    pContext->dwProtocol        = pSerialContext->dwProtocol;

    pContext->ContextThumbprint = pSerialContext->ContextThumbprint;

    pContext->pCipherInfo       = g_AvailableCiphers + pSerialContext->dwCipherInfo;
    pContext->pHashInfo         = g_AvailableHashes  + pSerialContext->dwHashInfo;
    pContext->pKeyExchInfo      = g_AvailableExch    + pSerialContext->dwKeyExchInfo;

    pContext->pReadCipherInfo   = pContext->pCipherInfo;
    pContext->pWriteCipherInfo  = pContext->pCipherInfo;
    pContext->pReadHashInfo     = pContext->pHashInfo;
    pContext->pWriteHashInfo    = pContext->pHashInfo;

    pContext->ReadCounter       = pSerialContext->ReadCounter;
    pContext->WriteCounter      = pSerialContext->WriteCounter;

    pContext->InitiateHello     = GenerateHello;

    switch(pContext->dwProtocol)
    {
        case SP_PROT_PCT1_CLIENT:
            pContext->Decrypt           = Pct1DecryptMessage;
            pContext->Encrypt           = Pct1EncryptMessage;
            pContext->ProtocolHandler   = Pct1ClientProtocolHandler;
            pContext->DecryptHandler    = Pct1DecryptHandler;
            pContext->GetHeaderSize     = Pct1GetHeaderSize;
            break;

        case SP_PROT_PCT1_SERVER:
            pContext->Decrypt           = Pct1DecryptMessage;
            pContext->Encrypt           = Pct1EncryptMessage;
            pContext->ProtocolHandler   = Pct1ServerProtocolHandler;
            pContext->DecryptHandler    = Pct1DecryptHandler;
            pContext->GetHeaderSize     = Pct1GetHeaderSize;
            break;

        case SP_PROT_SSL2_CLIENT:
            pContext->Decrypt           = Ssl2DecryptMessage;
            pContext->Encrypt           = Ssl2EncryptMessage;
            pContext->ProtocolHandler   = Ssl2ClientProtocolHandler;
            pContext->DecryptHandler    = Ssl2DecryptHandler;
            pContext->GetHeaderSize     = Ssl2GetHeaderSize;
            break;

        case SP_PROT_SSL2_SERVER:
            pContext->Decrypt           = Ssl2DecryptMessage;
            pContext->Encrypt           = Ssl2EncryptMessage;
            pContext->ProtocolHandler   = Ssl2ServerProtocolHandler;
            pContext->DecryptHandler    = Ssl2DecryptHandler;
            pContext->GetHeaderSize     = Ssl2GetHeaderSize;
            break;

        case SP_PROT_SSL3_CLIENT:
        case SP_PROT_SSL3_SERVER:
        case SP_PROT_TLS1_CLIENT:
        case SP_PROT_TLS1_SERVER:
            pContext->Decrypt           = Ssl3DecryptMessage;
            pContext->Encrypt           = Ssl3EncryptMessage;
            pContext->ProtocolHandler   = Ssl3ProtocolHandler;
            pContext->DecryptHandler    = Ssl3DecryptHandler;
            pContext->GetHeaderSize     = Ssl3GetHeaderSize;
            break;

        default:
            pContext->Decrypt           = NULL;
            pContext->Encrypt           = NULL;
            pContext->ProtocolHandler   = NULL;
            pContext->DecryptHandler    = NULL;
            pContext->GetHeaderSize     = NULL;
    }


    //
    // Extract serialized cache entry.
    //

    pZombie->fProtocol      = pSerialContext->dwProtocol;
    pZombie->dwExchStrength = pSerialContext->dwExchStrength;

    #ifdef _WIN64
        pZombie->hLocator       = (HLOCATOR)pSerialContext->hLocator.QuadPart;
        pZombie->hMasterProv    = (HCRYPTPROV)pSerialContext->hMasterProv.QuadPart;
    #else
        pZombie->hLocator       = (HLOCATOR)pSerialContext->hLocator.LowPart;
        pZombie->hMasterProv    = (HCRYPTPROV)pSerialContext->hMasterProv.LowPart;
    #endif
    pZombie->LocatorStatus  = pSerialContext->LocatorStatus;

    pZombie->cbSessionID = pSerialContext->cbSessionID;
    memcpy(pZombie->SessionID, pSerialContext->SessionID, pSerialContext->cbSessionID);

    switch(pContext->pKeyExchInfo->Spec)
    {
        case SP_EXCH_RSA_PKCS1:
            if((pZombie->fProtocol & SP_PROT_CLIENTS) || !pZombie->hMasterProv)
            {
                pZombie->hMasterProv = g_hRsaSchannel;
            }
            break;

        case SP_EXCH_DH_PKCS3:
            if((pZombie->fProtocol & SP_PROT_CLIENTS) || !pZombie->hMasterProv)
            {
                pZombie->hMasterProv = g_hDhSchannelProv;
            }
            break;

        default:
            Status = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            goto cleanup;
    }
    pContext->hReadProv  = pZombie->hMasterProv;
    pContext->hWriteProv = pZombie->hMasterProv;

    pbBuffer += TAG_LENGTH + pTag->Length;


    //
    // Extract optional serialized data.
    //

    fDone = FALSE;

    while(!fDone)
    {
        DWORD Type   = ((SERIALIZED_ITEM_TAG UNALIGNED *)pbBuffer)->Type;
        DWORD Length = ((SERIALIZED_ITEM_TAG UNALIGNED *)pbBuffer)->Length;
        DWORD DataLength = ((SERIALIZED_ITEM_TAG UNALIGNED *)pbBuffer)->DataLength;

        pbBuffer += TAG_LENGTH;

        switch(Type)
        {
        case SslEndOfBuffer:
            DebugLog((DEB_TRACE, "SslEndOfBuffer\n"));
            fDone = TRUE;
            break;

        case SslReadKey:
            DebugLog((DEB_TRACE, "SslReadKey\n"));
            if(!CryptImportKey(pZombie->hMasterProv,
                               pbBuffer,
                               DataLength,
                               0, 0,
                               &pContext->hReadKey))
            {
                SP_LOG_RESULT(GetLastError());
                Status = PCT_INT_INTERNAL_ERROR;
                goto cleanup;
            }
            DebugLog((DEB_TRACE, "Key:0x%p\n", pContext->hReadKey));
            break;

        case SslReadMac:
            DebugLog((DEB_TRACE, "SslReadMac\n"));
            if(!CryptImportKey(pZombie->hMasterProv,
                               pbBuffer,
                               DataLength,
                               0, 0,
                               &pContext->hReadMAC))
            {
                SP_LOG_RESULT(GetLastError());
                Status = PCT_INT_INTERNAL_ERROR;
                goto cleanup;
            }
            break;

        case SslWriteKey:
            DebugLog((DEB_TRACE, "SslWriteKey\n"));
            if(!CryptImportKey(pZombie->hMasterProv,
                               pbBuffer,
                               DataLength,
                               0, 0,
                               &pContext->hWriteKey))
            {
                SP_LOG_RESULT(GetLastError());
                Status = PCT_INT_INTERNAL_ERROR;
                goto cleanup;
            }
            DebugLog((DEB_TRACE, "Key:0x%p\n", pContext->hWriteKey));
            break;

        case SslWriteMac:
            DebugLog((DEB_TRACE, "SslWriteMac\n"));
            if(!CryptImportKey(pZombie->hMasterProv,
                               pbBuffer,
                               DataLength,
                               0, 0,
                               &pContext->hWriteMAC))
            {
                SP_LOG_RESULT(GetLastError());
                Status = PCT_INT_INTERNAL_ERROR;
                goto cleanup;
            }
            break;

        case SslMapper:
            DebugLog((DEB_TRACE, "SslMapper\n"));
            pZombie->phMapper = *(HMAPPER **)pbBuffer;
            break;

        case SslRemoteCertificate:
            DebugLog((DEB_TRACE, "SslRemoteCertificate\n"));
            // Save a pointer to the serialized certificate context
            // of the remote certificate. This will be deserialized
            // by the QueryContextAttribute function when the
            // application asks for it.
            pZombie->pbServerCertificate = SPExternalAlloc(Length);
            if(pZombie->pbServerCertificate)
            {
                memcpy(pZombie->pbServerCertificate, pbBuffer, Length);
                pZombie->cbServerCertificate = Length;
            }
            break;

        default:
            DebugLog((DEB_WARN, "Invalid tag %d found when deserializing context buffer\n"));
            Status = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }

        pbBuffer += Length;
    }

    *ppContext = pContext;
    pContext = NULL;

    Status = PCT_ERR_OK;

cleanup:

    if(pContext != NULL)
    {
        LsaContextDelete(pContext);
        SPExternalFree(pContext);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\rng.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       rng.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    11-05-97   jbanes   Modified to use static rsaenh.dll.
//
//----------------------------------------------------------------------------

#include <spbase.h>

NTSTATUS
GenerateRandomBits(PUCHAR pbBuffer,
                   ULONG  dwLength)
{
    if(!CryptGenRandom(g_hRsaSchannel, dwLength, pbBuffer))
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\srvprot.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       srvprot.c
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-26-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <pct1msg.h>
#include <pct1prot.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <ssl2prot.h>


/* The main purpose of this handler is to determine what kind of protocol
 * the client hello is
 */

SP_STATUS WINAPI
ServerProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput)
{
    SP_STATUS pctRet = PCT_INT_ILLEGAL_MSG;
    PBYTE pb;
    PBYTE pbClientHello;
    DWORD dwVersion;
    DWORD dwEnabledProtocols;


    /* PCTv1.0 Hello starts with
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * PCT1_CLIENT_HELLO  (must be equal)
     * PCT1_CLIENT_VERSION_MSB (if version greater than PCTv1)
     * PCT1_CLIENT_VERSION_LSB (if version greater than PCTv1) 
     *
     * ... PCT hello ...
     */

    /* Microsft Unihello starts with
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * SSL2_CLIENT_HELLO  (must be equal)
     * SSL2_CLIENT_VERSION_MSB (if version greater than SSLv2) ( or v3)
     * SSL2_CLIENT_VERSION_LSB (if version greater than SSLv2) ( or v3)
     *
     * ... SSLv2 Compatable Hello ...
     */

    /* SSLv2 Hello starts with
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * SSL2_CLIENT_HELLO  (must be equal)
     * SSL2_CLIENT_VERSION_MSB (if version greater than SSLv2) ( or v3)
     * SSL2_CLIENT_VERSION_LSB (if version greater than SSLv2) ( or v3)
     *
     * ... SSLv2 Hello ...
     */

    /* SSLv3 Type 2 Hello starts with
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * SSL2_CLIENT_HELLO  (must be equal)
     * SSL2_CLIENT_VERSION_MSB (if version greater than SSLv3)
     * SSL2_CLIENT_VERSION_LSB (if version greater than SSLv3)
     *
     * ... SSLv2 Compatable Hello ...
     */

    /* SSLv3 Type 3 Hello starts with
     * 0x15 Hex (HANDSHAKE MESSAGE)
     * VERSION MSB
     * VERSION LSB
     * RECORD_LENGTH_MSB  (ignore)
     * RECORD_LENGTH_LSB  (ignore)
     * HS TYPE (CLIENT_HELLO)
     * 3 bytes HS record length
     * HS Version
     * HS Version
     */

    dwEnabledProtocols = pContext->pCredGroup->grbitEnabledProtocols;

    // We need at least 5 bytes to determine what we have.
    if (pCommInput->cbData < 5)
    {
        return(PCT_INT_INCOMPLETE_MSG);
    }

    pb = pCommInput->pvBuffer;

    // If the first byte is 0x15, then check if we have a
    // SSLv3 Type3 client hello
    if(pb[0] == SSL3_CT_HANDSHAKE)
    {
        //
        // This is an SSL3 ClientHello.
        //

        // We need at least foo bytes to determine what we have.
        if (pCommInput->cbData < sizeof(SWRAP) + sizeof(SHSH) + 2)
        {
            return(PCT_INT_INCOMPLETE_MSG);
        }
        pbClientHello = pb + sizeof(SWRAP) + sizeof(SHSH);

        dwVersion = COMBINEBYTES(pbClientHello[0], pbClientHello[1]);
        if(dwVersion > 0x300 && (0 != (SP_PROT_TLS1_SERVER & dwEnabledProtocols)))
        {
            DebugLog((DEB_TRACE, "SSL3 ClientHello received, selected TLS\n"));
            pContext->dwProtocol = SP_PROT_TLS1_SERVER;
        }
        else if(0 != (SP_PROT_SSL3_SERVER & dwEnabledProtocols))
        {
            DebugLog((DEB_TRACE, "SSL3 ClientHello received, selected SSL3\n"));
            pContext->dwProtocol = SP_PROT_SSL3_SERVER;
        }
        else
        {
            return SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH);
        }
        
        pContext->ProtocolHandler = Ssl3ProtocolHandler;
        pContext->DecryptHandler  = Ssl3DecryptHandler;
        pctRet = Ssl3ProtocolHandler(pContext, pCommInput, pCommOutput);
        return(pctRet);
    }
    else
    {
        // 
        // Assuming SSL2 (or compatible) ClientHello
        //

        dwVersion = COMBINEBYTES(pb[3], pb[4]);
    }

    if(dwVersion >= PCT_VERSION_1)
    {
        //
        // This is a PCT ClientHello.
        //

        if(!(SP_PROT_PCT1_SERVER & dwEnabledProtocols))
        {
            return SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
        }

        // We're running PCT, so set up the PCT handlers
        DebugLog((DEB_TRACE, "PCT ClientHello received, selected PCT\n"));
        pContext->dwProtocol        = SP_PROT_PCT1_SERVER;
        pContext->ProtocolHandler   = Pct1ServerProtocolHandler;
        pContext->DecryptHandler    = Pct1DecryptHandler;
        return(Pct1ServerProtocolHandler(pContext, pCommInput, pCommOutput));
    }

    if(dwVersion >= SSL2_CLIENT_VERSION)
    {
        // we're either receiving ssl2, ssl3, or pct1 compat

        PSSL2_CLIENT_HELLO pRawHello = pCommInput->pvBuffer;

        // Do we have one client hello message with at least one
        // cipher spec.
        if (pCommInput->cbData < (sizeof(SSL2_CLIENT_HELLO)+2))
        {
            return(PCT_INT_INCOMPLETE_MSG);
        }

        // We must have at least one cipher spec
        if(COMBINEBYTES(pRawHello->CipherSpecsLenMsb, pRawHello->CipherSpecsLenLsb) < 1)
        {
            return(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
        }

        // Does client support TLS?
        if((dwVersion >= TLS1_CLIENT_VERSION) &&
            (0 != (SP_PROT_TLS1_SERVER & dwEnabledProtocols)))
        {
            DebugLog((DEB_TRACE, "SSL2 ClientHello received, selected TLS\n"));
            pContext->State             = UNI_STATE_RECVD_UNIHELLO;
            pContext->dwProtocol        = SP_PROT_TLS1_SERVER;
            pContext->ProtocolHandler   = Ssl3ProtocolHandler;
            pContext->DecryptHandler    = Ssl3DecryptHandler;
            return(Ssl3ProtocolHandler(pContext, pCommInput, pCommOutput));
        }  
        
        // Does client support SSL3?
        if((dwVersion >= SSL3_CLIENT_VERSION) &&
           (0 != (SP_PROT_SSL3TLS1_SERVERS & dwEnabledProtocols)))
        {
            DebugLog((DEB_TRACE, "SSL2 ClientHello received, selected SSL3\n"));
            pContext->State             = UNI_STATE_RECVD_UNIHELLO;
            pContext->dwProtocol        = SP_PROT_SSL3_SERVER;
            pContext->ProtocolHandler   = Ssl3ProtocolHandler;
            pContext->DecryptHandler    = Ssl3DecryptHandler;
            return(Ssl3ProtocolHandler(pContext, pCommInput, pCommOutput));
        }

        // Is the PCT compatability flag set?
        if(pRawHello->VariantData[0] == PCT_SSL_COMPAT)
        {
            // Get the pct version.
            dwVersion = COMBINEBYTES(pRawHello->VariantData[1], pRawHello->VariantData[2]);
        }

        // Does client support PCT?
        if((dwVersion >= PCT_VERSION_1) &&
           (0 != (SP_PROT_PCT1_SERVER & dwEnabledProtocols)))
        {
            DebugLog((DEB_TRACE, "SSL2 ClientHello received, selected PCT\n"));
            pContext->State             = UNI_STATE_RECVD_UNIHELLO;
            pContext->dwProtocol        = SP_PROT_PCT1_SERVER;
            pContext->ProtocolHandler   = Pct1ServerProtocolHandler;
            pContext->DecryptHandler    = Pct1DecryptHandler;
            return(Pct1ServerProtocolHandler(pContext, pCommInput, pCommOutput));
        }

        // Does client support SSL2?
        if((dwVersion >= SSL2_CLIENT_VERSION) &&
           (0 != (SP_PROT_SSL2_SERVER & dwEnabledProtocols)))
        {
            DebugLog((DEB_TRACE, "SSL2 ClientHello received, selected SSL2\n"));
            pContext->dwProtocol        = SP_PROT_SSL2_SERVER;
            pContext->ProtocolHandler   = Ssl2ServerProtocolHandler;
            pContext->DecryptHandler    = Ssl2DecryptHandler;
            return(Ssl2ServerProtocolHandler(pContext, pCommInput, pCommOutput));
        }

        return(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }

    return (pctRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\sigsys.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       sigsys.c
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <wincrypt.h>
#include <ssl2msg.h>
#include <ssl3msg.h>


SP_STATUS 
SPVerifySignature(
    HCRYPTPROV  hProv,
    PPUBLICKEY  pPublic,
    ALG_ID      aiHash,
    PBYTE       pbData, 
    DWORD       cbData, 
    PBYTE       pbSig, 
    DWORD       cbSig,
    BOOL        fHashData)
{
    HCRYPTKEY  hPublicKey = 0;
    HCRYPTHASH hHash = 0;
    PBYTE      pbSigBuff = NULL;
    SP_STATUS  pctRet;

    if(hProv == 0 || pPublic == NULL)
    {
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto cleanup;
    }
    
    pbSigBuff = SPExternalAlloc(cbSig);
    if(pbSigBuff == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }


    // 
    // Create public key.
    //

    if(!CryptImportKey(hProv,
                       (PBYTE)pPublic->pPublic,
                       pPublic->cbPublic,
                       0, 0,
                       &hPublicKey))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_ERR_ILLEGAL_MESSAGE;
        goto cleanup;
    }

    // 
    // Hash data.
    //

    if(!CryptCreateHash(hProv, aiHash, 0, 0, &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_ERR_ILLEGAL_MESSAGE;
        goto cleanup;
    }

    if(!fHashData)
    {
        // set hash value
        if(!CryptSetHashParam(hHash, HP_HASHVAL, pbData, 0))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_ERR_ILLEGAL_MESSAGE;
            goto cleanup;
        }
    }
    else
    {
        if(!CryptHashData(hHash, pbData, cbData, 0))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_ERR_ILLEGAL_MESSAGE;
            goto cleanup;
        }
    }

    if(pPublic->pPublic->aiKeyAlg == CALG_DSS_SIGN)
    {
        BYTE  rgbTempSig[DSA_SIGNATURE_SIZE];
        DWORD cbTempSig;

        // Remove DSS ASN1 goo around signature and convert it to 
        // little endian.
        cbTempSig = sizeof(rgbTempSig);
        if(!CryptDecodeObject(X509_ASN_ENCODING,
                              X509_DSS_SIGNATURE,
                              pbSig,
                              cbSig,
                              0,
                              rgbTempSig,
                              &cbTempSig))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_ERR_ILLEGAL_MESSAGE;
            goto cleanup;
        }

        memcpy(pbSigBuff, rgbTempSig, cbTempSig);
        cbSig = cbTempSig;
    }
    else
    {
        // Convert signature to little endian.
        ReverseMemCopy(pbSigBuff, pbSig, cbSig);
    }

    if(!CryptVerifySignature(hHash,  
                             pbSigBuff,
                             cbSig, 
                             hPublicKey, 
                             NULL, 
                             0))
    {
        DebugLog((DEB_WARN, "Signature Verify Failed: %x\n", GetLastError()));
        pctRet = SP_LOG_RESULT(PCT_INT_MSG_ALTERED);
        goto cleanup;
    }

    pctRet = PCT_ERR_OK;


cleanup:

    if(hPublicKey) 
    {
        CryptDestroyKey(hPublicKey);
    }

    if(hHash) 
    {
        CryptDestroyHash(hHash);
    }

    if(pbSigBuff != NULL)
    {
        SPExternalFree(pbSigBuff);
    }

    return pctRet;
}


SP_STATUS
SignHashUsingCred(
    PSPCredential pCred,
    ALG_ID        aiHash,
    PBYTE         pbHash,
    DWORD         cbHash,
    PBYTE         pbSignature,
    PDWORD        pcbSignature)
{
    HCRYPTHASH  hHash;
    DWORD       cbSignatureBuffer;
    SP_STATUS   pctRet;

    if(pCred == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    cbSignatureBuffer = *pcbSignature;

    if(pCred->hProv)
    {
        // Sign hash using local CSP handle.
        if(!CryptCreateHash(pCred->hProv, aiHash, 0, 0, &hHash))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_ERR_ILLEGAL_MESSAGE;
        }
        if(!CryptSetHashParam(hHash, HP_HASHVAL, pbHash, 0))
        {
            SP_LOG_RESULT(GetLastError());
            CryptDestroyHash(hHash);
            return PCT_ERR_ILLEGAL_MESSAGE;
        }
        if(!CryptSignHash(hHash, pCred->dwKeySpec, NULL, 0, pbSignature, pcbSignature))
        {
            SP_LOG_RESULT(GetLastError());
            CryptDestroyHash(hHash);
            return PCT_ERR_ILLEGAL_MESSAGE;
        }
        CryptDestroyHash(hHash);
    }
    else if(pCred->hRemoteProv)
    {
        // Sign hash via a call to the application process.
        pctRet = SignHashUsingCallback(pCred->hRemoteProv,
                                       pCred->dwKeySpec,
                                       aiHash,
                                       pbHash,
                                       cbHash,
                                       pbSignature,
                                       pcbSignature,
                                       FALSE);
        if(pctRet != PCT_ERR_OK)
        {
            return SP_LOG_RESULT(pctRet);
        }
    }
    else
    {
        DebugLog((DEB_ERROR, "We have no key with which to sign!\n"));
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pCred->dwExchSpec == SP_EXCH_DH_PKCS3)
    {
        BYTE rgbTempSig[DSA_SIGNATURE_SIZE];

        // Add DSS ASN1 goo around signature.
        if(*pcbSignature != DSA_SIGNATURE_SIZE)
        {
            return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        }

        memcpy(rgbTempSig, pbSignature, DSA_SIGNATURE_SIZE);
        *pcbSignature = cbSignatureBuffer;

        if(!CryptEncodeObject(X509_ASN_ENCODING,
                              X509_DSS_SIGNATURE,
                              rgbTempSig,
                              pbSignature,
                              pcbSignature))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_ERR_ILLEGAL_MESSAGE;
        }
    }
    else
    {
        // Convert signature to big endian.
        ReverseInPlace(pbSignature, *pcbSignature);
    }

    return PCT_ERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\spbase.h ===
#include "spbasei.h"
#include <rsa.h>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\pct1srv.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       pct1srv.c
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------

#include <spbase.h>

#include <pct1msg.h>
#include <pct1prot.h>
#include <ssl2msg.h>

// Unreachable code
#pragma warning (disable: 4702)


SP_STATUS
Pct1SrvHandleUniHello(
    PSPContext          pContext,
    PSPBuffer           pCommInput,
    PSsl2_Client_Hello  pHello,
    PSPBuffer           pCommOutput);



SP_STATUS WINAPI
Pct1ServerProtocolHandler(PSPContext pContext,
                    PSPBuffer  pCommInput,
                    PSPBuffer  pCommOutput)
{
    SP_STATUS      pctRet= 0;
    DWORD          dwStateTransition;

    SP_BEGIN("Pct1ServerProtocolHandler");

    if(pCommOutput) pCommOutput->cbData = 0;


    /* Protocol handling steps should be listed in most common
     * to least common in order to improve performance
     */

    /* We are not connected, so we're doing
     * protocol negotiation of some sort.  All protocol
     * negotiation messages are sent in the clear */
    /* There are no branches in the connecting protocol
     * state transition diagram, besides connection and error,
     * which means that a simple case statement will do */

    /* Do we have enough data to determine what kind of message we have */
    /* Do we have enough data to determine what kind of message we have, or how much data we need*/

    dwStateTransition = (pContext->State & 0xffff);

    if(((pContext->State & 0xffff) != SP_STATE_CONNECTED) &&
       ((pContext->State & 0xffff) != PCT1_STATE_RENEGOTIATE) &&
       ((pContext->State & 0xffff) != SP_STATE_SHUTDOWN) &&
       ((pContext->State & 0xffff) != SP_STATE_SHUTDOWN_PENDING))
    {
        if(pCommInput->cbData < 3)
        {
            pctRet = PCT_INT_INCOMPLETE_MSG;
        }
    }
    if(pCommInput->cbData >= 3)
    {
        dwStateTransition |= (((PUCHAR)pCommInput->pvBuffer)[2]<<16);
    }


    if(pctRet == PCT_ERR_OK)
    {
        switch(dwStateTransition)
        {
            case SP_STATE_SHUTDOWN_PENDING:
                // There's no CloseNotify in PCT, so just transition to
                // the shutdown state and leave the output buffer empty.
                pContext->State = SP_STATE_SHUTDOWN;
                break;    

            case SP_STATE_SHUTDOWN:
                return PCT_INT_EXPIRED;


            case SP_STATE_CONNECTED:
            {
                //We're connected, and we got called, so we must be doing a REDO
                SPBuffer    In;
                DWORD       cbMessage;

                // Transfer the write key over from the application process.
                if(pContext->hWriteKey == 0)
                {
                    pctRet = SPGetUserKeys(pContext, SCH_FLAG_WRITE_KEY);
                    if(pctRet != PCT_ERR_OK)
                    {
                        SP_RETURN(SP_LOG_RESULT(pctRet));
                    }
                }

                // Calculate size of buffer

                pCommOutput->cbData = 0;

                cbMessage    =  pContext->pHashInfo->cbCheckSum +
                                pContext->pCipherInfo->dwBlockSize +
                                sizeof(PCT1_MESSAGE_HEADER_EX);


                /* are we allocating our own memory? */
                if(pCommOutput->pvBuffer == NULL)
                {
                    pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
                    if (NULL == pCommOutput->pvBuffer)
                    {
                        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
                    }
                    pCommOutput->cbBuffer = cbMessage;
                }


                if(cbMessage > pCommOutput->cbBuffer)
                {
                    pCommOutput->cbData = cbMessage;
                    SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
                }

                In.pvBuffer = ((char *)pCommOutput->pvBuffer)+3;
                In.cbBuffer = pCommOutput->cbBuffer-3;
                In.cbData = 1;

                ((char *)In.pvBuffer)[0] = PCT1_ET_REDO_CONN;

                // Build a Redo Request
                pctRet = Pct1EncryptRaw(pContext, &In, pCommOutput, PCT1_ENCRYPT_ESCAPE);
                break;
            }

            /* Server receives client hello */
            case (SSL2_MT_CLIENT_HELLO << 16) | UNI_STATE_RECVD_UNIHELLO:
            {
                PSsl2_Client_Hello pSsl2Hello;

                // Attempt to recognize and handle various versions of client
                // hello, start by trying to unpickle the most recent version, and
                // then next most recent, until one unpickles.  Then run the handle
                // code.  We can also put unpickling and handling code in here for
                // SSL messages.

                pctRet = Ssl2UnpackClientHello(pCommInput, &pSsl2Hello);
                if(PCT_ERR_OK == pctRet)
                {
                    // We know we're doing a full handshake, so allocate a cache entry.

                    if(!SPCacheRetrieveNew(TRUE,
                                           pContext->pszTarget, 
                                           &pContext->RipeZombie))
                    {
                        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                    }
                    else
                    {
                        pContext->RipeZombie->fProtocol = pContext->dwProtocol;
                        pContext->RipeZombie->dwCF      = pContext->dwRequestedCF;

                        SPCacheAssignNewServerCredential(pContext->RipeZombie,
                                                         pContext->pCredGroup);

                        pctRet = Pct1SrvHandleUniHello(
                                     pContext,
                                     pCommInput,
                                     pSsl2Hello,
                                     pCommOutput);
                        if (PCT_ERR_OK == pctRet)
                        {
                            pContext->State = PCT1_STATE_SERVER_HELLO;
                        }
                    }

                    SPExternalFree(pSsl2Hello);
                }

                if (SP_FATAL(pctRet))
                {
                    pContext->State = PCT1_STATE_ERROR;
                }
                break;
            }
            /* Server receives client hello */

            case (PCT1_MSG_CLIENT_HELLO << 16) | PCT1_STATE_RENEGOTIATE:
            {
                PPct1_Client_Hello pPct1Hello;

                // This is a renegotiate hello, so we do not restart

                pctRet = Pct1UnpackClientHello(
                                pCommInput,
                                &pPct1Hello);

                if(PCT_ERR_OK == pctRet)
                {
                    // Mark context as "unmapped" so that the new keys will get
                    // passed to the application process once the handshake is
                    // completed.
                    pContext->Flags &= ~CONTEXT_FLAG_MAPPED;

                    // We need to do a full handshake, so lose the cache entry.
                    SPCacheDereference(pContext->RipeZombie);
                    pContext->RipeZombie = NULL;

                    // Get a new cache item, as restarts are not allowed in
                    // REDO
                    if(!SPCacheRetrieveNew(TRUE,
                                           pContext->pszTarget, 
                                           &pContext->RipeZombie))
                    {
                        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                    }
                    else
                    {
                        pContext->RipeZombie->fProtocol = SP_PROT_PCT1_SERVER;
                        pContext->RipeZombie->dwCF      = pContext->dwRequestedCF;

                        SPCacheAssignNewServerCredential(pContext->RipeZombie,
                                                         pContext->pCredGroup);

                        pctRet = Pct1SrvHandleClientHello(pContext,
                                                     pCommInput,
                                                     pPct1Hello,
                                                     pCommOutput);
                        if(PCT_ERR_OK == pctRet)
                        {
                            pContext->State = PCT1_STATE_SERVER_HELLO;
                        }
                    }
                    SPExternalFree(pPct1Hello);

                }
                else if(pctRet != PCT_INT_INCOMPLETE_MSG)
                {
                    pctRet |= PCT_INT_DROP_CONNECTION;
                }

                if(SP_FATAL(pctRet)) 
                {
                    pContext->State = PCT1_STATE_ERROR;
                }
                break;
            }

            case (PCT1_MSG_CLIENT_HELLO << 16) | SP_STATE_NONE:
            {
                PPct1_Client_Hello pPct1Hello;
                UCHAR fRealSessId = 0;
                int i;

                /* Attempt to recognize and handle various versions
                 * of client hello, start by trying to unpickle the
                 * most recent version, and then next most recent, until
                 * one unpickles.  Then run the handle code.  We can also put
                 * unpickling and handling code in here for SSL messages */
                pctRet = Pct1UnpackClientHello(
                                pCommInput,
                                &pPct1Hello);

                if(PCT_ERR_OK == pctRet)
                {


                    for(i=0;i<(int)pPct1Hello->cbSessionID;i++)
                    {
                        fRealSessId |= pPct1Hello->SessionID[i];
                    }

                    if (((pContext->Flags & CONTEXT_FLAG_NOCACHE) == 0) &&
                        (fRealSessId) &&
                        (SPCacheRetrieveBySession(pContext,
                                                  pPct1Hello->SessionID,
                                                  pPct1Hello->cbSessionID,
                                                  &pContext->RipeZombie)))
                    {
                        // We have a good zombie
                        DebugLog((DEB_TRACE, "Accept client's reconnect request.\n"));

                        pctRet = Pct1SrvRestart(pContext,
                                                pPct1Hello,
                                                pCommOutput);

                        if(PCT_ERR_OK == pctRet)
                        {
                            pContext->State = SP_STATE_CONNECTED;
                            pContext->DecryptHandler = Pct1DecryptHandler;
                            pContext->Encrypt = Pct1EncryptMessage;
                            pContext->Decrypt = Pct1DecryptMessage;
                            pContext->GetHeaderSize = Pct1GetHeaderSize;
                        }
                    }
                    else
                    {
                        // We're doing a full handshake, so allocate a cache entry.

                        if(!SPCacheRetrieveNew(TRUE,
                                               pContext->pszTarget, 
                                               &pContext->RipeZombie))
                        {
                            pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                        }
                        else
                        {
                            pContext->RipeZombie->fProtocol = pContext->dwProtocol;
                            pContext->RipeZombie->dwCF      = pContext->dwRequestedCF;

                            SPCacheAssignNewServerCredential(pContext->RipeZombie,
                                                             pContext->pCredGroup);

                            pctRet = Pct1SrvHandleClientHello(pContext,
                                                         pCommInput,
                                                         pPct1Hello,
                                                         pCommOutput);
                            if (PCT_ERR_OK == pctRet)
                            {
                                pContext->State = PCT1_STATE_SERVER_HELLO;
                            }
                        }
                    }
                    SPExternalFree(pPct1Hello);

                }
                else if(pctRet != PCT_INT_INCOMPLETE_MSG)
                {
                    pctRet |= PCT_INT_DROP_CONNECTION;
                }

                if(SP_FATAL(pctRet)) {
                    pContext->State = PCT1_STATE_ERROR;
                }
                break;
            }
            case (PCT1_MSG_CLIENT_MASTER_KEY << 16) | PCT1_STATE_SERVER_HELLO:
                pctRet = Pct1SrvHandleCMKey(pContext,
                                            pCommInput,
                                            pCommOutput);
                if(SP_FATAL(pctRet)) {
                    pContext->State = PCT1_STATE_ERROR;
                } else {
                    if(PCT_ERR_OK == pctRet) {
                        pContext->State = SP_STATE_CONNECTED;
                        pContext->DecryptHandler = Pct1DecryptHandler;
                        pContext->Encrypt = Pct1EncryptMessage;
                        pContext->Decrypt = Pct1DecryptMessage;
                        pContext->GetHeaderSize = Pct1GetHeaderSize;

                    }
                    /* We received a non-fatal error, so the state doesn't
                     * change, giving the app time to deal with this */
                }
                break;


            default:
                pContext->State = PCT1_STATE_ERROR;
                {
                    pctRet = PCT_INT_ILLEGAL_MSG;
                    if(((PUCHAR)pCommInput->pvBuffer)[2] == PCT1_MSG_ERROR)
                    {
                        /* we received an error message, process it */
                        pctRet = Pct1HandleError(pContext,
                                                 pCommInput,
                                                 pCommOutput);

                    } else {
                        /* we received an unknown error, generate a
                         * PCT_ERR_ILLEGAL_MESSAGE */
                        pctRet = Pct1GenerateError(pContext,
                                                    pCommOutput,
                                                    PCT_ERR_ILLEGAL_MESSAGE,
                                                    NULL);
                    }
                }

        }
    }

    if(pctRet & PCT_INT_DROP_CONNECTION) 
    {
        pContext->State &= ~SP_STATE_CONNECTED;
    }

    SP_RETURN(pctRet);
}

SP_STATUS
Pct1SrvHandleUniHello(
    PSPContext         pContext,
    PSPBuffer           pCommInput,
    PSsl2_Client_Hello  pHello,
    PSPBuffer           pCommOutput)
{
    SP_STATUS pctRet = PCT_ERR_ILLEGAL_MESSAGE;

    Pct1_Client_Hello  ClientHello;
    DWORD              iCipher;
    DWORD              dwSpec;
    DWORD              i;

    CipherSpec      aCipherSpecs[PCT1_MAX_CIPH_SPECS];
    HashSpec        aHashSpecs[PCT1_MAX_HASH_SPECS];
    CertSpec        aCertSpecs[PCT1_MAX_CERT_SPECS];
    ExchSpec        aExchSpecs[PCT1_MAX_EXCH_SPECS];


    SP_BEGIN("Pct1SrvHandlUniHello");
    if(NULL == pContext)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    ClientHello.pCipherSpecs =aCipherSpecs;
    ClientHello.pHashSpecs =aHashSpecs;
    ClientHello.pCertSpecs =aCertSpecs;
    ClientHello.pExchSpecs =aExchSpecs;

    ClientHello.cCipherSpecs =0;
    ClientHello.cHashSpecs =0;
    ClientHello.cCertSpecs =0;
    ClientHello.cExchSpecs =0;


    /* validate the buffer configuration */



    for (iCipher = 0;
         (iCipher < pHello->cCipherSpecs) && (iCipher < PCT1_MAX_CIPH_SPECS) ;
         iCipher++ )
    {
        dwSpec = pHello->CipherSpecs[iCipher] & 0xffff;

        switch(pHello->CipherSpecs[iCipher] >> 16)
        {
            case PCT_SSL_HASH_TYPE:
                ClientHello.pHashSpecs[ClientHello.cHashSpecs++] = dwSpec;
                break;

            case PCT_SSL_EXCH_TYPE:
                ClientHello.pExchSpecs[ClientHello.cExchSpecs++] = dwSpec;
                break;
            case PCT_SSL_CERT_TYPE:
                ClientHello.pCertSpecs[ClientHello.cCertSpecs++] = dwSpec;
                break;

            case PCT_SSL_CIPHER_TYPE_1ST_HALF:
                // Do we have enough room for a 2nd half.
                if(iCipher+1 >= pHello->cCipherSpecs)
                {
                    break;
                }
                if((pHello->CipherSpecs[iCipher+1] >> 16) != PCT_SSL_CIPHER_TYPE_2ND_HALF)
                {
                    break;
                }

                dwSpec = (pHello->CipherSpecs[iCipher+1] & 0xffff) |
                             (dwSpec<< 16);

                ClientHello.pCipherSpecs[ClientHello.cCipherSpecs++] = dwSpec;
                break;
        }
    }

    // Restarts are not allowed with Uni Hello's, so we don't need
    // The session ID.
    ClientHello.cbSessionID = 0;


    /* Make the SSL2 challenge into a PCT1 challenge as per the
     * compatability doc. */

    CopyMemory( ClientHello.Challenge,
                pHello->Challenge,
                pHello->cbChallenge);


    for(i=0; i < pHello->cbChallenge; i++)
    {
        ClientHello.Challenge[i + pHello->cbChallenge] = ~ClientHello.Challenge[i];
    }
    ClientHello.cbChallenge = 2*pHello->cbChallenge;

    ClientHello.cbKeyArgSize = 0;

    pctRet = Pct1SrvHandleClientHello(pContext, pCommInput, &ClientHello, pCommOutput);


    SP_RETURN(pctRet);
}



/* Otherwise known as Handle Client Hello */
SP_STATUS
Pct1SrvHandleClientHello(
    PSPContext          pContext,
    PSPBuffer           pCommInput,
    PPct1_Client_Hello  pHello,
    PSPBuffer           pCommOutput
    )
{
    SP_STATUS           pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PSPCredentialGroup  pCred;
    Pct1_Server_Hello   Reply;
    DWORD               i, j, k , fMismatch;
    BYTE                MisData[PCT_NUM_MISMATCHES];
    SPBuffer            ErrData;
    PSessCacheItem      pZombie;

    DWORD               aCertSpecs[PCT1_MAX_CERT_SPECS];
    DWORD               aSigSpecs[PCT1_MAX_SIG_SPECS];
    DWORD               cCertSpecs;
    DWORD               cSigSpecs;
    BOOL fAllocatedOutput = FALSE;

    CertTypeMap LocalCertEncodingPref[5] ;
    DWORD cLocalCertEncodingPref = 0;

    BOOL                fFound;

#if DBG
    DWORD               di;
#endif

    SP_BEGIN("Pct1SrvHandleClientHello");

    pCommOutput->cbData = 0;

    /* validate the buffer configuration */
    ErrData.cbData = 0;
    ErrData.pvBuffer = NULL;
    ErrData.cbBuffer = 0;

    pZombie = pContext->RipeZombie;


    pCred = pZombie->pServerCred;
    if (!pCred)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    do {

#if DBG
        DebugLog((DEB_TRACE, "Client Hello at %x\n", pHello));
        DebugLog((DEB_TRACE, "  CipherSpecs  %d\n", pHello->cCipherSpecs));
        for (di = 0 ; di < pHello->cCipherSpecs ; di++ )
        {
            DebugLog((DEB_TRACE, "    Cipher[%d] = %06x (%s)\n", di,
                      pHello->pCipherSpecs[di],
                      DbgGetNameOfCrypto(pHello->pCipherSpecs[di]) ));
        }
#endif


        /* store the challenge in the auth block */
        CopyMemory( pContext->pChallenge,
                    pHello->Challenge,
                    pHello->cbChallenge );
        pContext->cbChallenge = pHello->cbChallenge;


        // The session id was computed when the cache entry
        // was created. We do need to fill in the length, though.
        pZombie->cbSessionID = PCT1_SESSION_ID_SIZE;


        /* Begin to build the server hello */
        FillMemory( &Reply, sizeof( Reply ), 0 );

        /* no matter what, we need to make a new connection id */

        pctRet = GenerateRandomBits(Reply.ConnectionID,
                                    PCT1_SESSION_ID_SIZE);
        if(!NT_SUCCESS(pctRet))
        {
            SP_RETURN(SP_LOG_RESULT(pctRet));
        }
        Reply.cbConnectionID = PCT1_SESSION_ID_SIZE;

        CopyMemory( pContext->pConnectionID,
                    Reply.ConnectionID,
                    PCT1_SESSION_ID_SIZE );

        pContext->cbConnectionID = PCT_SESSION_ID_SIZE;

        /* no restart case */
        /* fill in from properties here... */

        Reply.RestartOk = FALSE;
        Reply.ClientAuthReq = ((pContext->Flags & CONTEXT_FLAG_MUTUAL_AUTH) != 0);

        fMismatch = 0;
        pContext->pPendingCipherInfo = NULL;



        /* Build a list of cert specs */
        /* Hash order of preference:
         * Server Preference
         *    Client Preference
         */
        for(i=0; i < cPct1CertEncodingPref; i++)
        {
  
            for(j=0; j< pHello->cCertSpecs; j++)
            {
                // Does the client want this cipher type
                if(aPct1CertEncodingPref[i].Spec == pHello->pCertSpecs[j])
                {
                    LocalCertEncodingPref[cLocalCertEncodingPref].Spec = aPct1CertEncodingPref[i].Spec;
                    LocalCertEncodingPref[cLocalCertEncodingPref++].dwCertEncodingType = aPct1CertEncodingPref[i].dwCertEncodingType;
                    break;
                }
            }
        }


        /* Determine Key Exchange to use */
        /* Key Exchange order of preference:
         * Server Preference
         *    Client Preference
         */

        // NOTE:  Yes, the following line does do away with any error
        // information if we had a previous mismatch.  However, the
        // setting of pctRet to mismatch in previous lines is for
        // logging purposes only.  The actual error report occurs later.
        pctRet = PCT_ERR_OK;
        for(i=0; i < cPct1LocalExchKeyPref; i++)
        {
            // Do we enable this cipher
            if(NULL == KeyExchangeFromSpec(aPct1LocalExchKeyPref[i].Spec, SP_PROT_PCT1_SERVER))
            {
                continue;
            }

            for(j=0; j< pHello->cExchSpecs; j++)
            {
                // Does the client want this cipher type
                if(aPct1LocalExchKeyPref[i].Spec != pHello->pExchSpecs[j])
                {
                    continue;
                }
                // See if we have a cert for this type of
                // key exchange.

                pctRet = SPPickServerCertificate(pContext, 
                                                 aPct1LocalExchKeyPref[i].Spec);
                if(pctRet != PCT_ERR_OK)
                {
                    continue;
                }

                // Store the exch id in the cache.
                pZombie->SessExchSpec = aPct1LocalExchKeyPref[i].Spec;
                pContext->pKeyExchInfo = GetKeyExchangeInfo(pZombie->SessExchSpec);

                // load the exch info structure
                if(!IsExchAllowed(pContext, 
                                  pContext->pKeyExchInfo,
                                  pZombie->fProtocol))
                {
                    pContext->pKeyExchInfo = NULL;
                    continue;
                }
                Reply.SrvExchSpec = aPct1LocalExchKeyPref[i].Spec;
                break;
            }
            if(pContext->pKeyExchInfo)
            {
                break;
            }
        }

        if(PCT_ERR_OK != pctRet)
        {
            fMismatch |= PCT_IMIS_CERT;
        }

        if (NULL == pContext->pKeyExchInfo)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            fMismatch |= PCT_IMIS_EXCH;
        }

        if (fMismatch) 
        {
            pctRet = PCT_ERR_SPECS_MISMATCH;
            break;
        }


        /* Determine Cipher to use */
        /* Cipher order of preference:
         * Server Preference
         *    Client Preference
         */

        fFound = FALSE;

        for(i=0; i < Pct1NumCipher; i++)
        {

            for(j=0; j< pHello->cCipherSpecs; j++)
            {
                // Does the client want this cipher type
                if(Pct1CipherRank[i].Spec == pHello->pCipherSpecs[j])
                {
                    // Store this cipher identifier in the cache
                    pZombie->aiCipher = Pct1CipherRank[i].aiCipher;
                    pZombie->dwStrength = Pct1CipherRank[i].dwStrength;

                    // Load the pending cipher structure.
                    pContext->pPendingCipherInfo = GetCipherInfo(pZombie->aiCipher, 
                                                                 pZombie->dwStrength);

                    if(!IsCipherAllowed(pContext, 
                                        pContext->pPendingCipherInfo, 
                                        pZombie->fProtocol,
                                        pZombie->dwCF))
                    {
                        pContext->pPendingCipherInfo = NULL;
                        continue;
                    }

                    // Is cipher supported by CSP?
                    for(k = 0; k < pZombie->pActiveServerCred->cCapiAlgs; k++)
                    {
                        PROV_ENUMALGS_EX *pAlgInfo = &pZombie->pActiveServerCred->pCapiAlgs[k];

                        if(pAlgInfo->aiAlgid != Pct1CipherRank[i].aiCipher)
                        {
                            continue;
                        }

                        if(Pct1CipherRank[i].dwStrength > pAlgInfo->dwMaxLen ||
                           Pct1CipherRank[i].dwStrength < pAlgInfo->dwMinLen)
                        {
                            continue;
                        }

                        if(!(pAlgInfo->dwProtocols & CRYPT_FLAG_PCT1))
                        {
                            continue;
                        }

                        fFound = TRUE;
                        break;
                    }
                    if(fFound)
                    {
                        break;
                    }
                }
            }
            if(fFound)
            {
                break;
            }
        }

        if(fFound)
        {
            Reply.SrvCipherSpec = Pct1CipherRank[i].Spec;
        }
        else
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            fMismatch |= PCT_IMIS_CIPHER;
        }


        /* Determine Hash to use */
        /* Hash order of preference:
         * Server Preference
         *    Client Preference
         */
        for(i=0; i < Pct1NumHash; i++)
        {

            for(j=0; j< pHello->cHashSpecs; j++)
            {
                // Does the client want this cipher type
                if(Pct1HashRank[i].Spec == pHello->pHashSpecs[j])
                {
                    // Store this hash id in the cache
                    pZombie->aiHash = Pct1HashRank[i].aiHash;
                    pContext->pPendingHashInfo = GetHashInfo(pZombie->aiHash);

                    if(!IsHashAllowed(pContext, 
                                      pContext->pPendingHashInfo,
                                      pZombie->fProtocol))
                    {
                        pContext->pPendingHashInfo = NULL;
                        continue;
                    }

                    Reply.SrvHashSpec = Pct1HashRank[i].Spec;
                    break;


                }
            }
            if(pContext->pPendingHashInfo)
            {
                break;
            }
        }

        if (pContext->pPendingHashInfo==NULL)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            fMismatch |= PCT_IMIS_HASH;
        }


        if (fMismatch) 
        {
            LogCipherMismatchEvent();
            pctRet = PCT_ERR_SPECS_MISMATCH;
            break;
        }


        // Pick a certificate to use based on
        // the key exchange mechanism selected.

        for(i=0; i < cLocalCertEncodingPref; i++)
        {
            if(LocalCertEncodingPref[i].dwCertEncodingType == pZombie->pActiveServerCred->pCert->dwCertEncodingType)
            {
                Reply.SrvCertSpec =    LocalCertEncodingPref[i].Spec;
                break;
            }

        }

        if(Reply.SrvCertSpec == PCT1_CERT_X509_CHAIN)
        {
            pContext->fCertChainsAllowed = TRUE;
        }

        Reply.pCertificate = NULL;
        Reply.CertificateLen = 0;
        // NOTE: SPSerializeCertificate will allocate memory
        // for the certificate, which we save in pZombie->pbServerCertificate.
        // This must be freed when the zombie dies (can the undead die?)
        pctRet = SPSerializeCertificate(SP_PROT_PCT1,
                                        pContext->fCertChainsAllowed,
                                        &pZombie->pbServerCertificate,
                                        &pZombie->cbServerCertificate,
                                        pZombie->pActiveServerCred->pCert,
                                        CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL);

        if(pctRet == PCT_ERR_OK)
        {
            Reply.pCertificate = pZombie->pbServerCertificate;
            Reply.CertificateLen = pZombie->cbServerCertificate;
        }
        else
        {
            break;
        }


        pctRet = ContextInitCiphers(pContext, TRUE, TRUE);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        /* sig and cert specs are pre-zeroed when Reply is initialized */

        if(Reply.ClientAuthReq)
        {
            PCertSysInfo pCertInfo;
            PSigInfo pSigInfo;

            cCertSpecs=0;
            cSigSpecs = 0;

            for(i=0; i < cPct1LocalSigKeyPref; i++)
            {
                pSigInfo = GetSigInfo(aPct1LocalSigKeyPref[i].Spec);
                if(pSigInfo != NULL)
                {
                    if(pSigInfo->fProtocol & SP_PROT_PCT1_SERVER)
                    {
                        aSigSpecs[cSigSpecs++] = aPct1LocalSigKeyPref[i].Spec;
                    }
                }
            }

            Reply.pClientSigSpecs = aSigSpecs;
            Reply.cSigSpecs = cSigSpecs;

            for(i=0; i < cPct1CertEncodingPref; i++)
            {
                pCertInfo = GetCertSysInfo(aPct1CertEncodingPref[i].dwCertEncodingType);
                if(pCertInfo == NULL)
                {
                    continue;
                }
                if(0 == (pCertInfo->fProtocol & SP_PROT_PCT1_SERVER))
                {
                    continue;
                }
                aCertSpecs[cCertSpecs++] = aPct1CertEncodingPref[i].Spec;
            }
            Reply.pClientCertSpecs = aCertSpecs;
            Reply.cCertSpecs = cCertSpecs;
        }



#if DBG
        DebugLog((DEB_TRACE, "Server picks cipher %06x (%s)\n",
                  Reply.SrvCipherSpec,
                  DbgGetNameOfCrypto(Reply.SrvCipherSpec) ));
#endif


        Reply.ResponseLen = 0;
        if(pCommOutput->pvBuffer == NULL)
        {
            fAllocatedOutput=TRUE;
        }

        pctRet = Pct1PackServerHello(&Reply, pCommOutput);
        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        /* Regenerate the internal pVerifyPrelude, so we */
        /* can match it against the client when we get the */
        /* client master key */

        pctRet = Pct1BeginVerifyPrelude(pContext,
                               pCommInput->pvBuffer,
                               pCommInput->cbData,
                               pCommOutput->pvBuffer,
                               pCommOutput->cbData);



        if(PCT_ERR_OK != pctRet)
        {
            if(fAllocatedOutput)
            {
                SPExternalFree(pCommOutput->pvBuffer);
            }

            break;
        }

        SP_RETURN(PCT_ERR_OK);

    } while (TRUE); /* end Polish Loop */


    if(pctRet == PCT_ERR_SPECS_MISMATCH) {
            for(i=0;i<PCT_NUM_MISMATCHES;i++)
            {
                MisData[i] = (BYTE)(fMismatch & 1);
                fMismatch = fMismatch >> 1;
            }

            ErrData.cbData = ErrData.cbBuffer = PCT_NUM_MISMATCHES;
            ErrData.pvBuffer = MisData;
    }

    pctRet = Pct1GenerateError(pContext,
                              pCommOutput,
                              pctRet,
                              &ErrData);


    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);

}



//+---------------------------------------------------------------------------
//
//  Function:   Pct1SrvHandleCMKey
//
//  Synopsis:   Process the ClientKeyExchange message group.
//
//  Arguments:  [pContext]      --  Schannel context.
//              [pCommInput]    -- 
//              [pCommOutput]   --
//
//  History:    10-10-97   jbanes   Added CAPI integration.
//
//  Notes:      This routine is called by the server-side only.
//
//----------------------------------------------------------------------------
SP_STATUS
Pct1SrvHandleCMKey(
    PSPContext     pContext,
    PSPBuffer       pCommInput,
    PSPBuffer       pCommOutput)
{
    SP_STATUS          pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PPct1_Client_Master_Key  pMasterKey = NULL;
    Pct1_Server_Verify       Verify;
    UCHAR               VerifyPrelude[RESPONSE_SIZE];
    DWORD               cbVerifyPrelude;
    SPBuffer           ErrData;
    DWORD k;
    PSessCacheItem     pZombie;
    PSigInfo pSigInfo;

    SP_BEGIN("Pct1SrvHandleCMKey");

    pCommOutput->cbData = 0;

    ErrData.cbData = 0;
    ErrData.pvBuffer = NULL;
    ErrData.cbBuffer = 0;
    pZombie = pContext->RipeZombie;

    do {


        pctRet = Pct1UnpackClientMasterKey(pCommInput, &pMasterKey);
        if (PCT_ERR_OK != pctRet)
        {
            // If it's an incomplete message or something, just return;
            if(pctRet == PCT_INT_INCOMPLETE_MSG)
            {
                SP_RETURN(pctRet);
            }
            break;
        }




        /* Validate that the client properly authed */

        /* The server requested client auth */
        /* NOTE: this deviates from the first pct 1.0 spec,
         * Now, we continue with the protocol if client
         * auth fails.  By the first spec, we should
         * drop the connection */

        if (pContext->Flags & CONTEXT_FLAG_MUTUAL_AUTH)
        {



            /* Client auth polish loop */
            pctRet = PCT_ERR_OK;
            do
            {


                /* check to see if the client sent no cert */
                if(pMasterKey->ClientCertLen == 0)
                {
                    /* No client auth */
                    break;
                }

                pctRet = SPLoadCertificate(SP_PROT_PCT1_SERVER,
                                           X509_ASN_ENCODING,
                                           pMasterKey->pClientCert,
                                           pMasterKey->ClientCertLen,
                                           &pZombie->pRemoteCert);

                if(PCT_ERR_OK != pctRet)
                {
                    break;
                }
                if(pContext->RipeZombie->pRemotePublic != NULL)
                {
                    SPExternalFree(pContext->RipeZombie->pRemotePublic);
                    pContext->RipeZombie->pRemotePublic = NULL;
                }

                pctRet = SPPublicKeyFromCert(pZombie->pRemoteCert,
                                             &pZombie->pRemotePublic,
                                             NULL);

                if(PCT_ERR_OK != pctRet)
                {
                    break;
                }
                if(pZombie->pRemoteCert == NULL)
                {
                    break;
                }



                /* verify that we got a sig type that meets PCT spec */
                for(k=0; k < cPct1LocalSigKeyPref; k++)
                {
                    if(aPct1LocalSigKeyPref[k].Spec == pMasterKey->ClientSigSpec)
                    {
                        break;
                    }
                }

                if(k == cPct1LocalSigKeyPref)
                {
                    break;
                }


                // Get pointer to signature algorithm info and make sure 
                // we support it.
                pSigInfo = GetSigInfo(pMasterKey->ClientSigSpec);
                if(pSigInfo == NULL)
                {
                    pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
                    break;
                }
                if(!(pSigInfo->fProtocol & SP_PROT_PCT1_SERVER))
                {
                    pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
                    break;
                }

                // Verify client authentication signature.
                DebugLog((DEB_TRACE, "Verify client response signature.\n"));
                pctRet = SPVerifySignature(pZombie->hMasterProv,
                                           pZombie->pRemotePublic,
                                           pSigInfo->aiHash,
                                           pMasterKey->VerifyPrelude,
                                           pMasterKey->VerifyPreludeLen,
                                           pMasterKey->pbResponse,
                                           pMasterKey->ResponseLen,
                                           TRUE);
                if(pctRet != PCT_ERR_OK)
                {
                    // client auth signature failed to verify, so client auth
                    // does not happen.
                    SP_LOG_RESULT(pctRet); 
                    break;
                }
                DebugLog((DEB_TRACE, "Client response verified successfully.\n"));

                pctRet = SPContextDoMapping(pContext);


            } while(FALSE); /* end polish loop */

            if(PCT_ERR_OK != pctRet)
            {
                break;
            }

        }

        /* Client auth was successful */
        pctRet = PCT_ERR_ILLEGAL_MESSAGE;

        /* Copy over the key args */
        CopyMemory( pZombie->pKeyArgs,
                    pMasterKey->KeyArg,
                    pMasterKey->KeyArgLen );
        pZombie->cbKeyArgs = pMasterKey->KeyArgLen;


        // Decrypt the encrypted portion of the master key. Because
        // we're CAPI integrated, the keys get derived as well.
        pctRet = pContext->pKeyExchInfo->System->GenerateServerMasterKey(
                    pContext,
                    pMasterKey->ClearKey,
                    pMasterKey->ClearKeyLen,
                    pMasterKey->pbEncryptedKey,
                    pMasterKey->EncryptedKeyLen);
        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        // Activate session keys.
        Pct1ActivateSessionKeys(pContext);


        if (pMasterKey->VerifyPreludeLen != pContext->pHashInfo->cbCheckSum)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_INTEGRITY_CHECK_FAILED);
            break;
        }

        /* Check the verify prelude hashes */
        /* Hash(CLIENT_MAC_KEY, Hash( "cvp", CLIENT_HELLO, SERVER_HELLO)) */
        /* The internal hash should already be in the verify prelude buffer */
        /* from the handle client master key. */

        cbVerifyPrelude = sizeof(VerifyPrelude);
        pctRet = Pct1EndVerifyPrelude(pContext, VerifyPrelude, &cbVerifyPrelude);
        if(PCT_ERR_OK != pctRet)
        {
            break;
        }


        /* Did the verify prelude hash successfully? */
        if(memcmp(VerifyPrelude, pMasterKey->VerifyPrelude, pContext->pHashInfo->cbCheckSum))
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_INTEGRITY_CHECK_FAILED);
            break;
        }

        /* don't need master key info anymore */
        SPExternalFree(pMasterKey);
        pMasterKey = NULL;


        pContext->WriteCounter = 2;
        pContext->ReadCounter = 2;

        pZombie->cbSessionID = PCT1_SESSION_ID_SIZE;

        CopyMemory( Verify.SessionIdData,
                    pZombie->SessionID,
                    pZombie->cbSessionID);

        /* compute the response */
        Verify.ResponseLen = sizeof(Verify.Response);
        pctRet = Pct1ComputeResponse(pContext, 
                                     pContext->pChallenge,
                                     pContext->cbChallenge,
                                     pContext->pConnectionID,
                                     pContext->cbConnectionID,
                                     pZombie->SessionID,
                                     pZombie->cbSessionID,
                                     Verify.Response,
                                     &Verify.ResponseLen);
        if(pctRet != PCT_ERR_OK)
        {
            SP_RETURN(SP_LOG_RESULT(pctRet));
        }

        pctRet = Pct1PackServerVerify(&Verify, pCommOutput);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        /* set up the session in cache */
        SPCacheAdd(pContext);

        SP_RETURN(PCT_ERR_OK);
    } while(TRUE); /* End of polish loop */

    if(pMasterKey) SPExternalFree(pMasterKey);

    pctRet = Pct1GenerateError(pContext,
                              pCommOutput,
                              pctRet,
                              NULL);

    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);

}


SP_STATUS
Pct1SrvRestart(
    PSPContext          pContext,
    PPct1_Client_Hello  pHello,
    PSPBuffer           pCommOutput)
{
    Pct1_Server_Hello   Reply;
    SPBuffer            ErrData;
    SP_STATUS           pctRet = PCT_INT_ILLEGAL_MSG;
    PSessCacheItem      pZombie;
    DWORD               i;

    SP_BEGIN("Pct1SrvRestart");

    pCommOutput->cbData = 0;

    /* validate the buffer configuration */
    ErrData.cbData = 0;
    ErrData.pvBuffer = NULL;
    ErrData.cbBuffer = 0;

    pZombie = pContext->RipeZombie;



     do {

        /* store the challenge in the auth block */
        CopyMemory( pContext->pChallenge,
                    pHello->Challenge,
                    pHello->cbChallenge );
        pContext->cbChallenge = pHello->cbChallenge;


        /* Begin to build the server hello */
        FillMemory( &Reply, sizeof( Reply ), 0 );


        /* Generate new connection id */
        pctRet =  GenerateRandomBits(Reply.ConnectionID,
                                     PCT1_SESSION_ID_SIZE);
        if(!NT_SUCCESS(pctRet))
        {
            break;
        }
        Reply.cbConnectionID = PCT1_SESSION_ID_SIZE;

        CopyMemory( pContext->pConnectionID,
                    Reply.ConnectionID,
                    Reply.cbConnectionID );
        pContext->cbConnectionID = Reply.cbConnectionID;

        Reply.RestartOk = TRUE;


        /* We don't pass a server cert back during a restart */
        Reply.pCertificate = NULL;
        Reply.CertificateLen = 0;
        /* setup the context */


        for(i=0; i < Pct1NumCipher; i++)
        {
            if((Pct1CipherRank[i].aiCipher == pZombie->aiCipher) &&
               (Pct1CipherRank[i].dwStrength == pZombie->dwStrength))
            {
                Reply.SrvCipherSpec = Pct1CipherRank[i].Spec;
            }
        }

        for(i=0; i < Pct1NumHash; i++)
        {
            if(Pct1HashRank[i].aiHash == pZombie->aiHash)
            {
                Reply.SrvHashSpec = Pct1HashRank[i].Spec;
            }
        }

        Reply.SrvCertSpec =   pZombie->pActiveServerCred->pCert->dwCertEncodingType;
        Reply.SrvExchSpec =   pZombie->SessExchSpec;

        // We know what our ciphers are, so init the cipher system
        pctRet = ContextInitCiphersFromCache(pContext);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        // We know what our ciphers are, so init the cipher system
        pctRet = ContextInitCiphers(pContext, TRUE, TRUE);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        // Make a new set of session keys.
        pctRet = MakeSessionKeys(pContext,
                                 pContext->RipeZombie->hMasterProv,
                                 pContext->RipeZombie->hMasterKey);
        if(PCT_ERR_OK != pctRet)
        {
            break;
        }


        // Activate session keys.
        Pct1ActivateSessionKeys(pContext);


        /* compute the response */
        Reply.ResponseLen = sizeof(Reply.Response);
        pctRet = Pct1ComputeResponse(pContext, 
                                     pContext->pChallenge,
                                     pContext->cbChallenge,
                                     pContext->pConnectionID,
                                     pContext->cbConnectionID,
                                     pZombie->SessionID,
                                     pZombie->cbSessionID,
                                     Reply.Response,
                                     &Reply.ResponseLen);
        if(pctRet != PCT_ERR_OK)
        {
            break;
        }

        pctRet = Pct1PackServerHello(&Reply, pCommOutput);

        if(PCT_ERR_OK != pctRet)
        {
            break;
        }

        pContext->ReadCounter = 1;
        pContext->WriteCounter = 1;

        SP_RETURN(PCT_ERR_OK);
    } while (TRUE);
    pctRet = Pct1GenerateError(pContext,
                              pCommOutput,
                              pctRet,
                              &ErrData);


    SP_RETURN(pctRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\ssl2cli.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ssl2cli.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-08-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <ssl2prot.h>



SP_STATUS WINAPI
Ssl2ClientProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput)
{
    SP_STATUS pctRet = 0;
    DWORD cMessageType;

    DWORD dwStateTransition;
    BOOL fRaw = TRUE;
    SPBuffer MsgInput;

    if (NULL != pCommOutput)
    {
        pCommOutput->cbData = 0;
    }

    MsgInput.pvBuffer = pCommInput->pvBuffer;
    MsgInput.cbBuffer = pCommInput->cbBuffer;
    MsgInput.cbData   = pCommInput->cbData;

    // In the following states, we should decrypt the message:
    switch(pContext->State)
    {
        case SSL2_STATE_CLIENT_MASTER_KEY:
        case SSL2_STATE_CLIENT_FINISH:
        case SSL2_STATE_CLIENT_RESTART:
            {
                DWORD cbHeader;
                DWORD cbPadding;

                if (MsgInput.cbData < 3)
                {
                    return PCT_INT_INCOMPLETE_MSG;
                }

                if(((PCHAR)pCommInput->pvBuffer)[0] & 0x80)
                {
                    cbHeader = 2 + pContext->pHashInfo->cbCheckSum;
                    cbPadding = 0;
                }
                else
                {
                    cbHeader = 3 + pContext->pHashInfo->cbCheckSum;

                    cbPadding = ((PCHAR)pCommInput->pvBuffer)[2];
                }

                MsgInput.pvBuffer = (PUCHAR)MsgInput.pvBuffer + cbHeader;
                MsgInput.cbBuffer -= cbHeader;
                MsgInput.cbData -= (cbHeader+cbPadding);

                pctRet = Ssl2DecryptMessage(pContext, pCommInput, &MsgInput);

                if (pctRet != PCT_ERR_OK)
                {
                    // to handle incomplete message errors
                    return(pctRet);
                }

                cMessageType = ((PUCHAR) MsgInput.pvBuffer)[0];
                fRaw = FALSE;
                break;
            }

        case SP_STATE_SHUTDOWN:
        case SP_STATE_SHUTDOWN_PENDING:
            cMessageType = 0;
            break;

        default:
            if(pCommInput->cbData < 3) 
            {
                return PCT_INT_INCOMPLETE_MSG;
            }
            cMessageType = ((PUCHAR) MsgInput.pvBuffer)[2];
            break;
            
    }

    dwStateTransition = pContext->State | (cMessageType<<16);


    switch(dwStateTransition)
    {
        case SP_STATE_SHUTDOWN_PENDING:
            // There's no CloseNotify in SSL2, so just transition to
            // the shutdown state and leave the output buffer empty.
            pContext->State = SP_STATE_SHUTDOWN;
            break;    

        case SP_STATE_SHUTDOWN:
            return PCT_INT_EXPIRED;

        case (SSL2_MT_SERVER_HELLO << 16) | UNI_STATE_CLIENT_HELLO:
        case (SSL2_MT_SERVER_HELLO << 16) | SSL2_STATE_CLIENT_HELLO:
        {
            PSsl2_Server_Hello pHello;

            // Attempt to recognize and handle various versions of Server
            // hello, start by trying to unpickle the oldest, and the next
            // version, until one unpickles.  Then run the handle code.
            // We can also put unpickling and handling code in here for SSL
            // messages.

            pctRet = Ssl2UnpackServerHello(pCommInput, &pHello);
            if (PCT_ERR_OK == pctRet)
            {
                if (pHello->SessionIdHit)
                {
                    pctRet = Ssl2CliHandleServerRestart(
                                    pContext,
                                    pCommInput,
                                    pHello,
                                    pCommOutput);
                    if (PCT_ERR_OK == pctRet)
                    {
                        pContext->State = SSL2_STATE_CLIENT_RESTART;
                    }
                }
                else
                {
                    if(pContext->RipeZombie->hMasterKey != 0)
                    {
                        // We've attempted to do a reconnect and the server has
                        // blown us off. In this case we must use a new and different
                        // cache entry.
                        pContext->RipeZombie->ZombieJuju = FALSE;

                        if(!SPCacheClone(&pContext->RipeZombie))
                        {
                            pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                        }
                    }
                
                    if (pctRet == PCT_ERR_OK)
                    {
                        pctRet = Ssl2CliHandleServerHello(
                                        pContext,
                                        pCommInput,
                                        pHello,
                                        pCommOutput);
                    }
                    if (PCT_ERR_OK == pctRet)
                    {
                        pContext->State = SSL2_STATE_CLIENT_MASTER_KEY;
                    }
                }
                SPExternalFree(pHello);
            }
            else if(pctRet != PCT_INT_INCOMPLETE_MSG)
            {
                pctRet |= PCT_INT_DROP_CONNECTION;
            }

            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }
            break;
        }

        case (SSL2_MT_SERVER_VERIFY << 16) | SSL2_STATE_CLIENT_MASTER_KEY:
            pctRet = Ssl2CliHandleServerVerify(
                    pContext,
                    &MsgInput,
                    pCommOutput);
            if (PCT_ERR_OK == pctRet)
            {
                pContext->State =SSL2_STATE_CLIENT_FINISH;
            }
            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }
            break;

        case (SSL2_MT_SERVER_VERIFY << 16) | SSL2_STATE_CLIENT_RESTART:
            pctRet = Ssl2CliFinishRestart(pContext, &MsgInput, pCommOutput);
            if (PCT_ERR_OK == pctRet)
            {
                pContext->State =SSL2_STATE_CLIENT_FINISH;
            }
            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }

            // Note, we will transmit no data, but we expect a server finished message.
            // If the SSPI EXTRA DATA message is not processed by wininet
            // then we may be in trouble.

            break;

        case (SSL2_MT_SERVER_FINISHED_V2 << 16) | SSL2_STATE_CLIENT_FINISH:
            pctRet = Ssl2CliHandleServerFinish(
                                                pContext,
                                                &MsgInput,
                                                pCommOutput);
            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }
            else
            {
                if (PCT_ERR_OK == pctRet)
                {
                    pContext->State = SP_STATE_CONNECTED;
                    pContext->DecryptHandler = Ssl2DecryptHandler;
                    pContext->Encrypt = Ssl2EncryptMessage;
                    pContext->Decrypt = Ssl2DecryptMessage;
                    pContext->GetHeaderSize = Ssl2GetHeaderSize;
                }
                // We received a non-fatal error, so the state doesn't
                // change, giving the app time to deal with this.
            }
            break;

        default:
            DebugLog((DEB_WARN, "Error in protocol, dwStateTransition is %lx\n", dwStateTransition));
            pContext->State = PCT1_STATE_ERROR;
            pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
            break;
    }
    if (pctRet & PCT_INT_DROP_CONNECTION)
    {
        pContext->State &= ~SP_STATE_CONNECTED;
    }
    // To handle incomplete message errors:
    return(pctRet);
}




SP_STATUS
Ssl2CliHandleServerHello(
    PSPContext pContext,
    PSPBuffer  pCommInput,
    PSsl2_Server_Hello pHello,
    PSPBuffer  pCommOutput)
{
    /* error to return to peer */
    SP_STATUS          pctRet=PCT_ERR_ILLEGAL_MESSAGE;

    Ssl2_Client_Master_Key   Key;
    DWORD               i,j;
    PSessCacheItem      pZombie;

    UNREFERENCED_PARAMETER(pCommInput);

    pCommOutput->cbData = 0;


    SP_BEGIN("Ssl2CliHandleServerHello");


    pZombie = pContext->RipeZombie;


        pContext->ReadCounter++;

        #if DBG
        DebugLog((DEB_TRACE, "Hello = %x\n", pHello));
        DebugLog((DEB_TRACE, "   Session ID hit \t%s\n", pHello->SessionIdHit ? "Yes" : "No"));
        DebugLog((DEB_TRACE, "   Certificate Type\t%d\n", pHello->CertificateType));
        DebugLog((DEB_TRACE, "   Certificate Len\t%d\n", pHello->cbCertificate));
        DebugLog((DEB_TRACE, "   cCipherSpecs   \t%d\n", pHello->cCipherSpecs));
        DebugLog((DEB_TRACE, "   ConnectionId   \t%d\n", pHello->cbConnectionID));
        for (i = 0 ; i < pHello->cCipherSpecs ; i++ )
        {
            DebugLog((DEB_TRACE, "    Cipher[%i] = %06x (%s)\n", i, pHello->pCipherSpecs[i],
                                    DbgGetNameOfCrypto(pHello->pCipherSpecs[i]) ));
        }
        #endif

        /* Cycle throug the array of cipher tuples to spec mappings
         * to find one that we support */

        pContext->pCipherInfo  = NULL;
        pContext->pHashInfo    = NULL;
        pContext->pKeyExchInfo = NULL;

        for(j=0;j<pHello->cCipherSpecs;j++) 
        {
            for(i = 0; i < UniNumCiphers; i++)
            {
                if(UniAvailableCiphers[i].CipherKind == pHello->pCipherSpecs[j])
                {
                    break;
                }
            }
            if(i >= UniNumCiphers)
            {
                continue;
            }
            if(UniAvailableCiphers[i].CipherKind != pHello->pCipherSpecs[j])
            {
                continue;
            }

            // Some servers send SSL3 cipher suites in the ServerHello 
            // message. Skip over these.
            if((UniAvailableCiphers[i].fProt & SP_PROT_SSL2_CLIENT) == 0)
            {
                continue;
            }

            // Copy all of the spec's to the cache
            pZombie->fProtocol    = SP_PROT_SSL2_CLIENT;
            pZombie->aiCipher     = UniAvailableCiphers[i].aiCipher;
            pZombie->dwStrength   = UniAvailableCiphers[i].dwStrength;
            pZombie->aiHash       = UniAvailableCiphers[i].aiHash;
            pZombie->SessExchSpec = UniAvailableCiphers[i].KeyExch;

            pctRet = ContextInitCiphersFromCache(pContext);

            if(pctRet != PCT_ERR_OK)
            {
                continue;
            }
            
            Key.CipherKind = pHello->pCipherSpecs[j];
            break;
        }

        // Go ahead and initialize the ciphers
        pctRet = ContextInitCiphers(pContext, TRUE, TRUE);
        if(pctRet != PCT_ERR_OK)
        {
            goto error;
        }


        pctRet = SPLoadCertificate(pZombie->fProtocol, 
                                   pHello->CertificateType, 
                                   pHello->pCertificate, 
                                   pHello->cbCertificate,
                                   &pZombie->pRemoteCert);

                                 
                                 

        if(pctRet != PCT_ERR_OK)
        {
            goto error;
        }
        if(pContext->RipeZombie->pRemotePublic != NULL)
        {
            SPExternalFree(pContext->RipeZombie->pRemotePublic);
            pContext->RipeZombie->pRemotePublic = NULL;
        }

        pctRet = SPPublicKeyFromCert(pZombie->pRemoteCert,
                                     &pZombie->pRemotePublic,
                                     NULL);

        if(PCT_ERR_OK != pctRet)
        {
            goto error;
        }

        // Automatically validate server certificate if appropriate 
        // context flag is set.
        pctRet = AutoVerifyServerCertificate(pContext);
        if(pctRet != PCT_ERR_OK)
        {
            SP_LOG_RESULT(pctRet);
            goto error;
        }

        // Generate Key Args
        if(pContext->pCipherInfo->dwBlockSize > 1)
        {
            pctRet = GenerateRandomBits(pZombie->pKeyArgs, pContext->pCipherInfo->dwBlockSize);
            if(!NT_SUCCESS(pctRet))
            {
                goto error;
            }
            pZombie->cbKeyArgs = Key.KeyArgLen = pContext->pCipherInfo->dwBlockSize;

            /* Copy over the key args */
            CopyMemory(Key.KeyArg,
                        pZombie->pKeyArgs,
                        pZombie->cbKeyArgs );
        }
        else
        {    
            Key.KeyArgLen = 0;
        }

        CopyMemory(pContext->pConnectionID, pHello->ConnectionID, pHello->cbConnectionID);
        pContext->cbConnectionID = pHello->cbConnectionID;


        pctRet = pContext->pKeyExchInfo->System->GenerateClientExchangeValue(
                            pContext,
                            NULL,
                            0, 
                            Key.ClearKey,
                            &Key.ClearKeyLen,
                            NULL,
                            &Key.EncryptedKeyLen);
        if(PCT_ERR_OK != pctRet)
        {
            goto error;
        }

        Key.pbEncryptedKey = SPExternalAlloc(Key.EncryptedKeyLen);
        if(Key.pbEncryptedKey == NULL)
        {
            pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto error;
        }

        pctRet = pContext->pKeyExchInfo->System->GenerateClientExchangeValue(
                            pContext,
                            NULL,
                            0, 
                            Key.ClearKey,
                            &Key.ClearKeyLen,
                            Key.pbEncryptedKey,
                            &Key.EncryptedKeyLen);
        if(PCT_ERR_OK != pctRet)
        {
            SPExternalFree(Key.pbEncryptedKey);
            goto error;
        }

        // Activate session keys.
        pContext->hReadKey          = pContext->hPendingReadKey;
        pContext->hWriteKey         = pContext->hPendingWriteKey;
        pContext->hPendingReadKey   = 0;
        pContext->hPendingWriteKey  = 0;


        pctRet = Ssl2PackClientMasterKey(&Key, pCommOutput);

        SPExternalFree(Key.pbEncryptedKey);

        if(PCT_ERR_OK != pctRet)
        {
            goto error;
        }

        pContext->WriteCounter++;
        SP_RETURN(PCT_ERR_OK);

error:

    if((pContext->Flags & CONTEXT_FLAG_EXT_ERR) &&
        (pctRet == PCT_ERR_SPECS_MISMATCH))
    {
        // Our SSL2 implementation does not do client auth,
        // so there is only one error message, cipher error.
        pCommOutput->cbData = 3; // MSG-ERROR + ERROR-CODE-MSB + ERROR-CODE-LSB

        if(pCommOutput->pvBuffer == NULL) 
        {
            pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
            if (NULL == pCommOutput->pvBuffer)
            {
                SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
            }
            pCommOutput->cbBuffer = pCommOutput->cbData;
        }
        if(pCommOutput->cbData > pCommOutput->cbBuffer)
        {
            // Required buffer size returned in pCommOutput->cbData.
            SP_RETURN(SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL));
        }
        ((PUCHAR)pCommOutput->pvBuffer)[0] = SSL2_MT_ERROR;
        ((PUCHAR)pCommOutput->pvBuffer)[1] = MSBOF(SSL_PE_NO_CIPHER);
        ((PUCHAR)pCommOutput->pvBuffer)[2] = LSBOF(SSL_PE_NO_CIPHER);
    }
    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);

}

SP_STATUS
Ssl2CliHandleServerRestart(
    PSPContext         pContext,
    PSPBuffer           pCommInput,
    PSsl2_Server_Hello  pHello,
    PSPBuffer           pCommOutput)
{
    /* error to return to peer */
    SP_STATUS          pctRet=PCT_ERR_ILLEGAL_MESSAGE;
    PSessCacheItem     pZombie;

    UNREFERENCED_PARAMETER(pCommInput);

    pCommOutput->cbData = 0;


    SP_BEGIN("Ssl2CliHandleServerRestart");

    pZombie = pContext->RipeZombie;

    pContext->ReadCounter++;


    /* if there's no zombie, the message is wrong.  We can't restart. */
    
    if(pZombie == NULL)
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        goto error;
    }

    if(!pZombie->hMasterKey)
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        goto error;
    }

    if(!pZombie->ZombieJuju)
    {
        DebugLog((DEB_WARN, "Session expired on client machine, but not on server.\n"));
    }
    
    CopyMemory(pContext->pConnectionID,
               pHello->ConnectionID,
               pHello->cbConnectionID);

    pContext->cbConnectionID = pHello->cbConnectionID;


    /* Cert length, Cipher Specs, and Cert Type should be zero */

    // We know what our ciphers are, so init the cipher system
    pctRet = ContextInitCiphersFromCache(pContext);

    if(PCT_ERR_OK != pctRet)
    {
        goto error;
    }

    pctRet = ContextInitCiphers(pContext, TRUE, TRUE);

    if(PCT_ERR_OK != pctRet)
    {
        goto error;
    }

    // Make a new set of session keys.
    pctRet = MakeSessionKeys(pContext,
                             pContext->RipeZombie->hMasterProv,
                             pContext->RipeZombie->hMasterKey);
    if(PCT_ERR_OK != pctRet)
    {
        goto error;
    }

    // Activate session keys.
    pContext->hReadKey          = pContext->hPendingReadKey;
    pContext->hWriteKey         = pContext->hPendingWriteKey;
    pContext->hPendingReadKey   = 0;
    pContext->hPendingWriteKey  = 0;

    /* okay, now send the client finish */
    pctRet = Ssl2GenCliFinished(pContext, pCommOutput);

    SP_RETURN(pctRet);

error:

    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);
}


SP_STATUS
Ssl2GenCliFinished(
    PSPContext pContext,
    PSPBuffer  pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;

    PSSL2_CLIENT_FINISHED   pFinish;
    DWORD                   HeaderSize;
    SPBuffer                MsgOutput;
    DWORD                   cPadding;
    BOOL                    fAlloced=FALSE;

    SP_BEGIN("Ssl2GenCliFinished");



    pCommOutput->cbData = 0;

    MsgOutput.cbData = sizeof(UCHAR) + pContext->cbConnectionID;
    cPadding = ((MsgOutput.cbData+pContext->pHashInfo->cbCheckSum) % pContext->pCipherInfo->dwBlockSize);
    if(cPadding)
    {
        cPadding = pContext->pCipherInfo->dwBlockSize - cPadding;
    }

    HeaderSize = (cPadding?3:2);

    pCommOutput->cbData = MsgOutput.cbData +
                          pContext->pHashInfo->cbCheckSum +
                          cPadding +
                          HeaderSize;

    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);

        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }
        fAlloced = TRUE;
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }

    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        // Required buffer size returned in pCommOutput->cbData.
        SP_RETURN(SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL));
    }
    MsgOutput.pvBuffer= (PUCHAR)pCommOutput->pvBuffer +
                        HeaderSize +
                        pContext->pHashInfo->cbCheckSum;

    MsgOutput.cbBuffer = pCommOutput->cbBuffer -
                         (pContext->pHashInfo->cbCheckSum + HeaderSize);


    pFinish = (PSSL2_CLIENT_FINISHED) MsgOutput.pvBuffer;
    pFinish->MessageId = SSL2_MT_CLIENT_FINISHED_V2;

    CopyMemory( pFinish->ConnectionID,
                pContext->pConnectionID,
                pContext->cbConnectionID );

    pctRet = Ssl2EncryptMessage( pContext, &MsgOutput, pCommOutput);
    if(PCT_ERR_OK != pctRet)
    {
        SPExternalFree(pCommOutput->pvBuffer);
        pCommOutput->pvBuffer = NULL;
        pctRet |= PCT_INT_DROP_CONNECTION;
        pCommOutput->cbBuffer = 0;
    }

    SP_RETURN(pctRet);

}


SP_STATUS
Ssl2CliHandleServerVerify(
    PSPContext pContext,
    PSPBuffer   pCommInput,
    PSPBuffer   pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;

    PSSL2_SERVER_VERIFY     pVerify = NULL;

    /* Read and Write Counters are incremented by the encrypt and decrypt */
    SP_BEGIN("Ssl2CliHandleServerVerify");



    pCommOutput->cbData = 0;

    /* Note, there is no header in this message, as it has been pre-decrypted */
    if(pCommInput->cbData != sizeof(UCHAR) + pContext->cbChallenge)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    pVerify = pCommInput->pvBuffer;

    if (pVerify->MessageId != SSL2_MT_SERVER_VERIFY)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if (memcmp( pVerify->ChallengeData,
                pContext->pChallenge,
                pContext->cbChallenge) )
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }


    pctRet = Ssl2GenCliFinished( pContext, pCommOutput);
    SP_RETURN(pctRet);
}

SP_STATUS
Ssl2CliFinishRestart(
    PSPContext pContext,
    PSPBuffer   pCommInput,
    PSPBuffer   pCommOutput)
{
    PSSL2_SERVER_VERIFY     pVerify = NULL;

    /* Read and Write Counters are incremented by the encrypt and decrypt */
    SP_BEGIN("Ssl2CliFinishRestart");



    pCommOutput->cbData = 0;

    /* Note, there is no header in this message, as it has been pre-decrypted */
    if(pCommInput->cbData != sizeof(UCHAR) + pContext->cbChallenge)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    pVerify = pCommInput->pvBuffer;

    if (pVerify->MessageId != SSL2_MT_SERVER_VERIFY)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if (memcmp( pVerify->ChallengeData,
                pContext->pChallenge,
                pContext->cbChallenge) )
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }
    SP_RETURN(PCT_ERR_OK);
}

SP_STATUS
Ssl2CliHandleServerFinish(
    PSPContext pContext,
    PSPBuffer  pCommInput,
    PSPBuffer  pCommOutput)
{
    PSSL2_SERVER_FINISHED     pFinished = NULL;

    SP_BEGIN("Ssl2CliHandleServerFinish");



    pCommOutput->cbData = 0;


    /* Note, there is no header in this message, as it has been pre-decrypted */
    if(pCommInput->cbData < sizeof(UCHAR))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    pFinished = pCommInput->pvBuffer;

    if (pFinished->MessageId != SSL2_MT_SERVER_FINISHED_V2)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }

    if((pCommInput->cbData-1) != SSL2_SESSION_ID_LEN)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
    }
    CopyMemory( pContext->RipeZombie->SessionID,
                pFinished->SessionID,
                pCommInput->cbData - 1);
    pContext->RipeZombie->cbSessionID = pCommInput->cbData - 1;

    SPCacheAdd(pContext);

    SP_RETURN(PCT_ERR_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\specmap.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       specmap.c
//
//  Contents:   
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   LSA integration stuff.
//
//----------------------------------------------------------------------------
 
#include <spbase.h>
#include <des.h>
#include <des3.h>
#include <rc2.h>


/* supported cipher type arrays */

CipherInfo g_AvailableCiphers[] = {
    { 
        // 128 bit RC4
        SP_PROT_ALL,
        SP_PROT_ALL,
        TEXT("RC4 128/128"),
        CALG_RC4,
        1,
        128,
        16,
        16,
        CF_DOMESTIC | CF_SGC,
    },
    { 
        // 168 bit Triple DES
        SP_PROT_ALL,
        SP_PROT_ALL,
        TEXT("Triple DES 168/168"),
        CALG_3DES,
        DES_BLOCKLEN,
        168,
        DES3_KEYSIZE,
        DES3_KEYSIZE,
        CF_DOMESTIC | CF_SGC,
    },
    { 
        // 128 bit RC2
        SP_PROT_ALL,
        SP_PROT_ALL, 
        TEXT("RC2 128/128"),
        CALG_RC2,
        RC2_BLOCKLEN,
        128,
        16,
        16,
        CF_DOMESTIC | CF_SGC,
    },
    { 
        // 56 bit RC4
        SP_PROT_SSL3 | SP_PROT_TLS1, 
        SP_PROT_SSL3 | SP_PROT_TLS1, 
        TEXT("RC4 56/128"),
        CALG_RC4,
        1,
        56,
        16,
        7,
        CF_EXPORT,
    },

    { 
        // 56 bit DES
        SP_PROT_ALL,
        SP_PROT_ALL,
        TEXT("DES 56/56"),
        CALG_DES,
        DES_BLOCKLEN,
        56,
        DES_KEYSIZE,
        DES_KEYSIZE,
        CF_EXPORT,
    },

    { 
        // 40 bit RC4
        SP_PROT_ALL, 
        SP_PROT_ALL, 
        TEXT("RC4 40/128"),
        CALG_RC4,
        1,
        40,
        16,
        5,
        CF_EXPORT,
    },

    { 
        // 40 bit RC2
        SP_PROT_ALL, 
        SP_PROT_ALL, 
        TEXT("RC2 40/128"),
        CALG_RC2,
        RC2_BLOCKLEN,
        40,
        16,
        5,
        CF_EXPORT,
    },

    { 
        // No encryption.
        SP_PROT_SSL3TLS1, 
        SP_PROT_SSL3TLS1, 
        TEXT("NULL"),
        CALG_NULLCIPHER,
        1,
        0,
        0,
        1,
        CF_EXPORT,
    },
};

DWORD g_cAvailableCiphers = sizeof(g_AvailableCiphers)/sizeof(CipherInfo);

HashInfo g_AvailableHashes[] = 
{
    { 
        SP_PROT_ALL, 
        SP_PROT_ALL, 
        TEXT("MD5"),
        CALG_MD5,
        CB_MD5_DIGEST_LEN,
    },
    { 
        SP_PROT_ALL, 
        SP_PROT_ALL,
        TEXT("SHA"),
        CALG_SHA,
        CB_SHA_DIGEST_LEN,
    }
};

DWORD g_cAvailableHashes = sizeof(g_AvailableHashes)/sizeof(HashInfo);


CertSysInfo g_AvailableCerts[] = 
{
    {
        SP_PROT_ALL, 
        SP_PROT_ALL, 
        X509_ASN_ENCODING, 
        TEXT("X.509")
    }
};

DWORD g_cAvailableCerts = sizeof(g_AvailableCerts)/sizeof(CertSysInfo);

SigInfo g_AvailableSigs[] = 
{
    { 
        SP_PROT_ALL, 
        SP_PROT_ALL, 
        SP_SIG_RSA_MD2, 
        TEXT("RSA Signed MD2"),
        CALG_MD2,
        CALG_RSA_SIGN,
    },
    { 
        SP_PROT_ALL,
        SP_PROT_ALL,
        SP_SIG_RSA_MD5, 
        TEXT("RSA Signed MD5"),
        CALG_MD5,
        CALG_RSA_SIGN,
    },
    { 
        SP_PROT_SSL3TLS1,
        SP_PROT_SSL3TLS1,
        SP_SIG_RSA_SHAMD5,
        TEXT("RSA Signed MD5/SHA combination"),
        (ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SSL3SHAMD5),  // CALG_SSL3_SHAMD5
        CALG_RSA_SIGN,
    }
};

DWORD g_cAvailableSigs = sizeof(g_AvailableSigs)/sizeof(SigInfo);


KeyExchangeInfo g_AvailableExch[] = 
{
    { 
        CALG_RSA_SIGN,
        SP_PROT_ALL,
        SP_PROT_ALL,
        SP_EXCH_RSA_PKCS1,
        TEXT("PKCS"),
        &keyexchPKCS 
    },
    { 
        CALG_RSA_KEYX,
        SP_PROT_ALL,
        SP_PROT_ALL,
        SP_EXCH_RSA_PKCS1,
        TEXT("PKCS"),
        &keyexchPKCS 
    },
    { 
        CALG_DH_EPHEM,
        SP_PROT_SSL3 | SP_PROT_TLS1,
        SP_PROT_SSL3 | SP_PROT_TLS1,
        SP_EXCH_DH_PKCS3,
        TEXT("Diffie-Hellman"),
        &keyexchDH 
    },
};

DWORD g_cAvailableExch = sizeof(g_AvailableExch)/sizeof(KeyExchangeInfo);



PCipherInfo GetCipherInfo(ALG_ID aiCipher, DWORD dwStrength)
{
    DWORD i;
    for (i = 0; i < g_cAvailableCiphers; i++ )
    {
        if(g_AvailableCiphers[i].aiCipher == aiCipher &&
           g_AvailableCiphers[i].dwStrength == dwStrength) 
        { 
            return &g_AvailableCiphers[i]; 
        }       
    }
    return NULL;
}

PHashInfo GetHashInfo(ALG_ID aiHash)
{
    DWORD i;
    for (i = 0; i < g_cAvailableHashes; i++ )
    {
        if(g_AvailableHashes[i].aiHash == aiHash) 
        { 
            return &g_AvailableHashes[i]; 
        }       
    }
    return NULL;
}

PKeyExchangeInfo GetKeyExchangeInfo(ExchSpec Spec)
{
    DWORD i;
    for (i = 0; i < g_cAvailableExch; i++ )
    {
        if(g_AvailableExch[i].Spec == Spec) 
        { 
            return &g_AvailableExch[i]; 
        }       
    }
    return NULL;
}

PKeyExchangeInfo GetKeyExchangeInfoByAlg(ALG_ID aiExch)
{
    DWORD i;
    for (i = 0; i < g_cAvailableExch; i++ )
    {
        if(g_AvailableExch[i].aiExch == aiExch) 
        { 
            return &g_AvailableExch[i]; 
        }       
    }
    return NULL;
}

PCertSysInfo GetCertSysInfo(CertSpec Spec)
{
    DWORD i;
    for (i = 0; i < g_cAvailableCerts; i++ )
    {
        if(g_AvailableCerts[i].Spec == Spec) 
        { 
            return &g_AvailableCerts[i]; 
        }       
    }
    return NULL;
}


PSigInfo GetSigInfo(SigSpec Spec)
{
    DWORD i;
    for (i = 0; i < g_cAvailableSigs; i++ )
    {
        if(g_AvailableSigs[i].Spec == Spec) 
        { 
            return &g_AvailableSigs[i]; 
        }       
    }
    return NULL;
}


KeyExchangeSystem * 
KeyExchangeFromSpec(ExchSpec Spec, DWORD fProtocol)
{
    PKeyExchangeInfo pInfo;
    pInfo = GetKeyExchangeInfo(Spec);
    if(pInfo == NULL)
    {
        return NULL;
    }
    if(pInfo->fProtocol & fProtocol)
    {
        return pInfo->System;
    }
    return NULL;
}

BOOL GetBaseCipherSizes(DWORD *dwMin, DWORD *dwMax)
{
    DWORD i;
    DWORD dwFlags = CF_EXPORT | CF_FASTSGC | CF_SGC;
    *dwMin = 1000;
    *dwMax = 0;

    dwFlags |= CF_DOMESTIC;

    for (i = 0; i < g_cAvailableCiphers; i++ )
    {
        if(g_AvailableCiphers[i].fProtocol)
        {
            if(g_AvailableCiphers[i].dwFlags & dwFlags)
            {
                *dwMin = min(g_AvailableCiphers[i].dwStrength, *dwMin);
                *dwMax = max(g_AvailableCiphers[i].dwStrength, *dwMax);
            }
        }

    }
    return TRUE;
}

void 
GetDisplayCipherSizes(
    PSPCredentialGroup pCredGroup,
    DWORD *dwMin, 
    DWORD *dwMax)
{
    DWORD i;
    DWORD dwFlags = CF_EXPORT;

    *dwMin = 1000;
    *dwMax = 0;

    dwFlags |= CF_DOMESTIC;

    for (i = 0; i < g_cAvailableCiphers; i++ )
    {
        if(g_AvailableCiphers[i].fProtocol)
        {
            if((g_AvailableCiphers[i].dwFlags & dwFlags) && 
               (g_AvailableCiphers[i].dwStrength > 0))
            {
                *dwMin = min(g_AvailableCiphers[i].dwStrength, *dwMin);
                *dwMax = max(g_AvailableCiphers[i].dwStrength, *dwMax);
            }
        }
    }

    if(pCredGroup)
    {
        *dwMin = max(pCredGroup->dwMinStrength, *dwMin);
        *dwMax = min(pCredGroup->dwMaxStrength, *dwMax);
    }
}

BOOL IsCipherAllowed(
    PSPContext  pContext, 
    PCipherInfo pCipher, 
    DWORD       dwProtocol,
    DWORD       dwFlags)
{
    PSPCredentialGroup pCred;

    pCred = pContext->pCredGroup;
    if(!pCred) return FALSE;

    if(!pCipher) return FALSE;

    if(pCipher->dwStrength < pCred->dwMinStrength)
    {
        return FALSE;
    }

    if(pCipher->dwStrength > pCred->dwMaxStrength)
    {
        return FALSE;
    }
    if((pCipher->fProtocol & dwProtocol) == 0)
    {
        return FALSE;
    }
    if((pCipher->dwFlags & dwFlags) == 0)
    {
        return FALSE;
    }

    return IsAlgAllowed(pCred, pCipher->aiCipher);

}

BOOL 
IsCipherSuiteAllowed(
    PSPContext  pContext, 
    PCipherInfo pCipher, 
    DWORD       dwProtocol,
    DWORD       dwFlags,
    DWORD       dwSuiteFlags)
{
    UNREFERENCED_PARAMETER( dwSuiteFlags );

    if(!IsCipherAllowed(pContext, pCipher, dwProtocol, dwFlags))
    {
        return FALSE;
    }

    return TRUE;
}

BOOL IsHashAllowed(
    PSPContext  pContext, 
    PHashInfo   pHash,
    DWORD       dwProtocol)
{
    PSPCredentialGroup pCred;

    pCred = pContext->pCredGroup;
    if(!pCred) return FALSE;

    if(!pHash) return FALSE;

    if((pHash->fProtocol & dwProtocol) == 0)
    {
        return FALSE;
    }

    return IsAlgAllowed(pCred, pHash->aiHash);
}

BOOL IsExchAllowed(
    PSPContext       pContext, 
    PKeyExchangeInfo pExch,
    DWORD            dwProtocol)
{
    PSPCredentialGroup  pCred;

    pCred = pContext->pCredGroup;
    if(!pCred) return FALSE;

    if(!pExch) return FALSE;

    if((pExch->fProtocol & dwProtocol) == 0)
    {
        return FALSE;
    }

    return IsAlgAllowed(pCred, pExch->aiExch);
}


BOOL IsAlgAllowed(
    PSPCredentialGroup pCred, 
    ALG_ID aiAlg)
{
    DWORD i;

    if(!pCred) return FALSE;

    if(pCred->palgSupportedAlgs == NULL)
    {
        return FALSE;
    }

    for(i = 0; i < pCred->cSupportedAlgs; i++)
    {   
        if(pCred->palgSupportedAlgs[i] == CALG_RSA_KEYX || 
           pCred->palgSupportedAlgs[i] == CALG_RSA_SIGN)
        {
            // accept either algid
            if(CALG_RSA_KEYX == aiAlg || CALG_RSA_SIGN == aiAlg)
            {
                return TRUE;
            }
        }
        else
        {
            if(pCred->palgSupportedAlgs[i] == aiAlg)
            {
                return TRUE;
            }
        }
    }

    return FALSE;
}

BOOL BuildAlgList(
    PSPCredentialGroup  pCred, 
    ALG_ID *            aalgRequestedAlgs, 
    DWORD               cRequestedAlgs)
{
    DWORD i,j;
    DWORD dwAlgClass;

    BOOL                fCipher=FALSE;
    BOOL                fHash=FALSE;
    BOOL                fExch=FALSE;


    if(!pCred) return FALSE;

    dwAlgClass = 0;

    // Get a buffer to hold the algs.
    pCred->palgSupportedAlgs = (ALG_ID *)SPExternalAlloc(sizeof(ALG_ID) * 
                                                          (g_cAvailableCiphers + 
                                                           g_cAvailableHashes + 
                                                           g_cAvailableExch));
    pCred->cSupportedAlgs = 0;

    if(pCred->palgSupportedAlgs == NULL)
    {
        return FALSE;
    }

    // Get a list of Alg Classes not specified
    if(aalgRequestedAlgs != NULL)
    {
        for(i=0; i < cRequestedAlgs; i++)
        {
            BOOL fAddAlg = FALSE;
            if(GET_ALG_CLASS(aalgRequestedAlgs[i]) == ALG_CLASS_DATA_ENCRYPT) 
            {
                fCipher=TRUE;
                for (j = 0; j < g_cAvailableCiphers; j++ )
                {

                    if((g_AvailableCiphers[j].aiCipher == aalgRequestedAlgs[i]) &&
                       (g_AvailableCiphers[j].dwStrength >= pCred->dwMinStrength) &&
                       (g_AvailableCiphers[j].dwStrength <= pCred->dwMaxStrength) &&
                       (g_AvailableCiphers[j].fProtocol & pCred->grbitEnabledProtocols))
                    {
                        fAddAlg = TRUE;
                        break;
                    }       
                }             
            } 
            else if(GET_ALG_CLASS(aalgRequestedAlgs[i]) == ALG_CLASS_HASH)
            {
                PHashInfo pHash;
                fHash = TRUE;
                pHash = GetHashInfo(aalgRequestedAlgs[i]);
                if((NULL != pHash) && (pHash->fProtocol & pCred->grbitEnabledProtocols))
                {
                    fAddAlg = TRUE;
                }

            }
            else if(GET_ALG_CLASS(aalgRequestedAlgs[i]) == ALG_CLASS_KEY_EXCHANGE)
            {
                PKeyExchangeInfo pExch;
                fExch = TRUE;
                pExch = GetKeyExchangeInfoByAlg(aalgRequestedAlgs[i]);
                if((NULL != pExch) && (pExch->fProtocol & pCred->grbitEnabledProtocols))
                {
                    fAddAlg = TRUE;
                }                
            }

            if(fAddAlg & !IsAlgAllowed(pCred, aalgRequestedAlgs[i]))
            {
                pCred->palgSupportedAlgs[pCred->cSupportedAlgs++] = aalgRequestedAlgs[i];
            }
        }
    }

    if(!fCipher)
    {
        // No ciphers were included in our list, so supply the default ones

        for (j = 0; j < g_cAvailableCiphers; j++ )
        {

            if((g_AvailableCiphers[j].dwStrength >= pCred->dwMinStrength) &&
               (g_AvailableCiphers[j].dwStrength <= pCred->dwMaxStrength) &&
               (g_AvailableCiphers[j].fProtocol & pCred->grbitEnabledProtocols))
            { 
                if(!IsAlgAllowed(pCred, g_AvailableCiphers[j].aiCipher))
                {
                    pCred->palgSupportedAlgs[pCred->cSupportedAlgs++] = g_AvailableCiphers[j].aiCipher;
                }
            }       
        }
    }
    if(!fHash)
    {
        // No hashes were included in our list, so supply the default ones

        for (j = 0; j < g_cAvailableHashes; j++ )
        {

            if(g_AvailableHashes[j].fProtocol & pCred->grbitEnabledProtocols)
            { 
                if(!IsAlgAllowed(pCred, g_AvailableHashes[j].aiHash))
                {
                    pCred->palgSupportedAlgs[pCred->cSupportedAlgs++] = g_AvailableHashes[j].aiHash;
                }
            }       
        }
    }
    if(!fExch)
    {
        // No key exchange algs were included in our list, so supply the default ones

        for(j = 0; j < g_cAvailableExch; j++ )
        {

            if(g_AvailableExch[j].fProtocol & pCred->grbitEnabledProtocols)
            { 
                if(!IsAlgAllowed(pCred, g_AvailableExch[j].aiExch))
                {
                    pCred->palgSupportedAlgs[pCred->cSupportedAlgs++] = g_AvailableExch[j].aiExch;
                }
            }       
        }
    }

    return TRUE;
}


static DWORD
ConvertCapiProtocol(DWORD dwCapiProtocol)
{
    DWORD dwProtocol = 0;

    if(dwCapiProtocol & CRYPT_FLAG_PCT1)
    {
        dwProtocol |= SP_PROT_PCT1;
    }
    if(dwCapiProtocol & CRYPT_FLAG_SSL2)
    {
        dwProtocol |= SP_PROT_SSL2;
    }
    if(dwCapiProtocol & CRYPT_FLAG_SSL3)
    {
        dwProtocol |= SP_PROT_SSL3;
    }
    if(dwCapiProtocol & CRYPT_FLAG_TLS1)
    {
        dwProtocol |= SP_PROT_TLS1;
    }

    return dwProtocol;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsAlgSupportedCapi
//
//  Synopsis:   Examine the cipher suite input, and determine if this is
//              supported by the schannel CSP. Return TRUE if the 
//              cipher suite is supported.
//
//  Arguments:  [dwProtocol]    --  Protocols to be included in the
//                                  ClientHello message.
//
//              [pCipherMap]    --  Cipher suite to be examined.
//
//              [pCapiAlgs]     --  Array of algorithms supported by the
//                                  schannel CSP.
//
//              [cCapiAlgs]     --  Number of elements in the pCapiAlgs
//                                  array.
//
//  History:    10-29-97   jbanes   Created
//
//  Notes:      
//
//----------------------------------------------------------------------------
BOOL
IsAlgSupportedCapi(
    DWORD               dwProtocol, 
    UNICipherMap *      pCipherMap,
    PROV_ENUMALGS_EX *  pCapiAlgs,
    DWORD               cCapiAlgs)
{
    BOOL    fFound;
    DWORD   dwCapiProtocol;
    DWORD   i;

    // Is cipher supported?
    if(pCipherMap->aiCipher != 0 && pCipherMap->aiCipher != CALG_NULLCIPHER)
    {
        for(fFound = FALSE, i = 0; i < cCapiAlgs; i++)
        {
            if(pCipherMap->aiCipher != pCapiAlgs[i].aiAlgid)
            {
                continue;
            }

            if(pCipherMap->dwStrength > pCapiAlgs[i].dwMaxLen ||
               pCipherMap->dwStrength < pCapiAlgs[i].dwMinLen)
            {
                continue;
            }

            dwCapiProtocol = ConvertCapiProtocol(pCapiAlgs[i].dwProtocols);
            if((dwCapiProtocol & dwProtocol) == 0)
            {
                continue;
            }
            if((dwCapiProtocol & pCipherMap->fProt) == 0)
            {
                continue;
            }

            fFound = TRUE;
            break;
        }
        if(!fFound)
        {
            return FALSE;
        }
    }


    // Is hash supported?
    if(pCipherMap->aiHash != 0)
    {
        for(fFound = FALSE, i = 0; i < cCapiAlgs; i++)
        {
            if(pCipherMap->aiHash != pCapiAlgs[i].aiAlgid)
            {
                continue;
            }

            dwCapiProtocol = ConvertCapiProtocol(pCapiAlgs[i].dwProtocols);
            if((dwCapiProtocol & dwProtocol) == 0)
            {
                continue;
            }
            if((dwCapiProtocol & pCipherMap->fProt) == 0)
            {
                continue;
            }

            fFound = TRUE;
            break;
        }
        if(!fFound)
        {
            return FALSE;
        }
    }

    // Is exchange alg supported?
    if(pCipherMap->KeyExch != SP_EXCH_UNKNOWN)
    {
        for(fFound = FALSE, i = 0; i < cCapiAlgs; i++)
        {

            // RSA
            if(pCipherMap->KeyExch == SP_EXCH_RSA_PKCS1)
            {
                if(pCapiAlgs[i].aiAlgid != CALG_RSA_KEYX)
                {
                    continue;
                }
            }

            // DH
            else if(pCipherMap->KeyExch == SP_EXCH_DH_PKCS3)
            {
                if(pCapiAlgs[i].aiAlgid != CALG_DH_EPHEM)
                {
                    continue;
                }
            }

            // Any other key exchange algorithm
            else
            {
                // Not supported.
                continue;
            }


            dwCapiProtocol = ConvertCapiProtocol(pCapiAlgs[i].dwProtocols);
            if((dwCapiProtocol & dwProtocol) == 0)
            {
                continue;
            }
            if((dwCapiProtocol & pCipherMap->fProt) == 0)
            {
                continue;
            }

            fFound = TRUE;
            break;
        }
        if(!fFound)
        {
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\ssl2pkl.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       pickle.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-02-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <ssl2msg.h>

#define SSL_OFFSET_OF(t, v) ((DWORD)(ULONG_PTR)&(((t)NULL)->v))



#define SIZEOF(pMessage)    (SslRecordSize((PSSL2_MESSAGE_HEADER) pMessage ) )

DWORD
SslRecordSize(
    PSSL2_MESSAGE_HEADER  pHeader)
{
    DWORD   Size;

    if (pHeader->Byte0 & 0x80)
    {
        Size = COMBINEBYTES(pHeader->Byte0, pHeader->Byte1) & 0x7FFF;
    }
    else
    {
        Size = COMBINEBYTES(pHeader->Byte0, pHeader->Byte1) & 0x3FFF;
    }
    return(Size);
}



BOOL
Ssl2MapCipherToExternal(
    Ssl2_Cipher_Kind     FastForm,
    PSsl2_Cipher_Tuple   pTuple)
{
    pTuple->C1 = (UCHAR)((FastForm >> 16) & 0xff);
    pTuple->C2 = (UCHAR)((FastForm >> 8) & 0xff);
    pTuple->C3 = (UCHAR)(FastForm & 0xff);


    return(TRUE);
}

Ssl2_Cipher_Kind
Ssl2MapCipherFromExternal(
    PSsl2_Cipher_Tuple   pTuple)
{

    return SSL_MKFAST(pTuple->C1, pTuple->C2, pTuple->C3);
}



SP_STATUS
Ssl2PackClientHello(
    PSsl2_Client_Hello       pCanonical,
    PSPBuffer                pCommOutput)
{
    DWORD               cbMessage;
    PSSL2_CLIENT_HELLO  pMessage;
    DWORD               Size;
    PUCHAR              pBuffer;
    DWORD               i;

    if(pCanonical == NULL || pCommOutput == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    pCommOutput->cbData = 0;

    pCommOutput->cbData = pCanonical->cbSessionID +
                            pCanonical->cbChallenge +
                            pCanonical->cCipherSpecs * sizeof(Ssl2_Cipher_Tuple) +
                            SSL_OFFSET_OF(PSSL2_CLIENT_HELLO, VariantData);

    cbMessage = pCommOutput->cbData - sizeof(SSL2_MESSAGE_HEADER);

    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }
    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        // Required buffer size returned in pCommOutput->cbData.
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;

    pMessage->MessageId = SSL2_MT_CLIENT_HELLO;

    pMessage->VersionMsb = MSBOF(pCanonical->dwVer);
    pMessage->VersionLsb = LSBOF(pCanonical->dwVer);

    pBuffer = pMessage->VariantData;

    cbMessage -= pCanonical->cCipherSpecs * sizeof(Ssl2_Cipher_Tuple);
    pCommOutput->cbData -= pCanonical->cCipherSpecs * sizeof(Ssl2_Cipher_Tuple);

    Size = 0;

    for (i = 0; i < pCanonical->cCipherSpecs ; i++ )
    {
        if (!Ssl2MapCipherToExternal(pCanonical->CipherSpecs[i],
                                (PSsl2_Cipher_Tuple) pBuffer) )
        {
            continue;
        }

        pBuffer += sizeof(Ssl2_Cipher_Tuple);
        Size += sizeof(Ssl2_Cipher_Tuple);
    }

    cbMessage += Size;
    pCommOutput->cbData += Size;

    pCommOutput->cbData = cbMessage + 2;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    pMessage->CipherSpecsLenMsb = MSBOF(Size);
    pMessage->CipherSpecsLenLsb = LSBOF(Size);

    pMessage->SessionIdLenMsb = MSBOF(pCanonical->cbSessionID);
    pMessage->SessionIdLenLsb = LSBOF(pCanonical->cbSessionID);
    if (pCanonical->cbSessionID)
    {
        CopyMemory( pBuffer,
                    pCanonical->SessionID,
                    pCanonical->cbSessionID);

        pBuffer += pCanonical->cbSessionID;
    }

    pMessage->ChallengeLenMsb = MSBOF(pCanonical->cbChallenge);
    pMessage->ChallengeLenLsb = LSBOF(pCanonical->cbChallenge);
    if (pCanonical->cbChallenge)
    {
        CopyMemory( pBuffer,
                    pCanonical->Challenge,
                    pCanonical->cbChallenge);
    }

    return(PCT_ERR_OK);
}


SP_STATUS
Ssl2UnpackClientHello(
    PSPBuffer              pInput,
    PSsl2_Client_Hello *   ppClient)
{

    PSSL2_CLIENT_HELLO   pMessage;
    DWORD               ReportedSize;
    DWORD               CipherSpecsSize;
    DWORD               cCipherSpecs;
    PSsl2_Client_Hello       pCanonical;
    PUCHAR              pBuffer;
    DWORD               Size;
    DWORD               i, dwVer;

    pMessage = pInput->pvBuffer;

    if(pInput->cbData < 2)
    {
        pInput->cbData = 2;
        return PCT_INT_INCOMPLETE_MSG;
    }

    ReportedSize = SIZEOF(pMessage);
    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2;
        return PCT_INT_INCOMPLETE_MSG;
    }
    if(ReportedSize < SSL_OFFSET_OF(PSSL2_CLIENT_HELLO, VariantData))
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    if (pMessage->MessageId != SSL2_MT_CLIENT_HELLO) {
        return  SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    dwVer = COMBINEBYTES(pMessage->VersionMsb, pMessage->VersionLsb);

    if (dwVer  < 2) //VERSION 2 WILL COMPUTE TO 2 (00:02)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    CipherSpecsSize = COMBINEBYTES( pMessage->CipherSpecsLenMsb,
                                    pMessage->CipherSpecsLenLsb );


    *ppClient = NULL;
    /* check that this all fits into the message */
    if (SSL_OFFSET_OF(PSSL2_CLIENT_HELLO, VariantData)
        - sizeof(SSL2_MESSAGE_HEADER)       /* don't count the header */
        + CipherSpecsSize
        > ReportedSize)
    {
        return  SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

        cCipherSpecs = CipherSpecsSize / sizeof(Ssl2_Cipher_Tuple);


    /* Allocate a buffer for the canonical client hello */
    pCanonical = (PSsl2_Client_Hello)SPExternalAlloc(
                                    sizeof(Ssl2_Client_Hello) +
                                    cCipherSpecs * sizeof(UNICipherMap));

    if (!pCanonical)
    {
        return(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    pCanonical->dwVer = COMBINEBYTES(    pMessage->VersionMsb,
                            pMessage->VersionLsb );

    pBuffer = pMessage->VariantData;


    pCanonical->cCipherSpecs = cCipherSpecs;

    for (i = 0 ; i < cCipherSpecs ; i++ )
    {
        pCanonical->CipherSpecs[i] = Ssl2MapCipherFromExternal((PSsl2_Cipher_Tuple)
                                                    pBuffer);

        pBuffer += sizeof(Ssl2_Cipher_Tuple);
    }

    Size = COMBINEBYTES(    pMessage->SessionIdLenMsb,
                            pMessage->SessionIdLenLsb );

    if (Size <= SSL2_SESSION_ID_LEN)
    {
        CopyMemory( pCanonical->SessionID, pBuffer, Size);
        pBuffer += Size;

    }
    else
    {
        SPExternalFree( pCanonical );
        return PCT_ERR_ILLEGAL_MESSAGE;
    }

    pCanonical->cbSessionID = Size;

    Size = COMBINEBYTES(    pMessage->ChallengeLenMsb,
                            pMessage->ChallengeLenLsb );

    if ((Size > 0) && (Size <= SSL2_MAX_CHALLENGE_LEN))
    {
        CopyMemory( pCanonical->Challenge, pBuffer, Size );

        pBuffer += Size;
    }
    else
    {
        SPExternalFree( pCanonical );
        return  SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    pCanonical->cbChallenge = Size;

    *ppClient = pCanonical;
    pInput->cbData = ReportedSize + sizeof(SSL2_MESSAGE_HEADER);
    return( PCT_ERR_OK );

}

SP_STATUS
Ssl2PackServerHello(
    PSsl2_Server_Hello       pCanonical,
    PSPBuffer          pCommOutput)
{
    DWORD               cbMessage;
    PSSL2_SERVER_HELLO  pMessage;
    DWORD               Size;
    PUCHAR              pBuffer;
    DWORD               i;

    if(pCanonical == NULL || pCommOutput == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }
    pCommOutput->cbData = 0;

    cbMessage = pCanonical->cbConnectionID +
                    pCanonical->cbCertificate +
                    pCanonical->cCipherSpecs * sizeof(Ssl2_Cipher_Tuple) +
                    SSL_OFFSET_OF(PSSL2_SERVER_HELLO, VariantData) -
                    sizeof(SSL2_MESSAGE_HEADER);

    pCommOutput->cbData = cbMessage + 2;


    /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }
    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        // Required buffer size returned in pCommOutput->cbData.
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }

    pMessage = pCommOutput->pvBuffer;


    pMessage->MessageId = SSL2_MT_SERVER_HELLO;
    pMessage->ServerVersionMsb = SSL2_SERVER_VERSION_MSB;
    pMessage->ServerVersionLsb = SSL2_SERVER_VERSION_LSB;
    pMessage->SessionIdHit = (UCHAR) pCanonical->SessionIdHit;
    pMessage->CertificateType = (UCHAR) pCanonical->CertificateType;

    pBuffer = pMessage->VariantData;

    //
    // Pack certificate if present
    //

    pMessage->CertificateLenMsb = MSBOF(pCanonical->cbCertificate);
    pMessage->CertificateLenLsb = LSBOF(pCanonical->cbCertificate);

    if (pCanonical->cbCertificate)
    {
        CopyMemory( pBuffer,
                    pCanonical->pCertificate,
                    pCanonical->cbCertificate);

        pBuffer += pCanonical->cbCertificate ;
    }

    Size = pCanonical->cCipherSpecs * sizeof(Ssl2_Cipher_Tuple);

    for (i = 0; i < pCanonical->cCipherSpecs ; i++ )
    {
        if (Ssl2MapCipherToExternal(pCanonical->pCipherSpecs[i],
                                (PSsl2_Cipher_Tuple) pBuffer) )
        {
            pBuffer += sizeof(Ssl2_Cipher_Tuple);
        }
        else
        {
            Size -= sizeof(Ssl2_Cipher_Tuple);
            cbMessage -= sizeof(Ssl2_Cipher_Tuple);
        }
    }

    pCommOutput->cbData = cbMessage + 2;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    pMessage->CipherSpecsLenMsb = MSBOF(Size);
    pMessage->CipherSpecsLenLsb = LSBOF(Size);

    pMessage->ConnectionIdLenMsb = MSBOF(pCanonical->cbConnectionID);
    pMessage->ConnectionIdLenLsb = LSBOF(pCanonical->cbConnectionID);
    if (pCanonical->cbConnectionID)
    {
        CopyMemory( pBuffer,
                    pCanonical->ConnectionID,
                    pCanonical->cbConnectionID);

        pBuffer += pCanonical->cbConnectionID;
    }


    return( PCT_ERR_OK );

}


SP_STATUS
Ssl2UnpackServerHello(
    PSPBuffer          pInput,
    PSsl2_Server_Hello *     ppServer)
{
    PSsl2_Server_Hello       pCanonical;
    PSSL2_SERVER_HELLO   pMessage;
    PUCHAR              pBuffer;
    DWORD               cbCertificate;
    DWORD               cCipherSpecs;
    DWORD               cbConnId;
    DWORD               i;
    DWORD               ReportedSize;

    pMessage = pInput->pvBuffer;
    if(pInput->cbData < 2)
    {
        pInput->cbData = 2;
        return PCT_INT_INCOMPLETE_MSG;
    }

    ReportedSize = SIZEOF(pMessage);
    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2;
        return PCT_INT_INCOMPLETE_MSG;
    }


    if(ReportedSize + 2 <  SSL_OFFSET_OF(PSSL2_SERVER_HELLO, VariantData) )
    {
        return  SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }
    *ppServer = NULL;

    //
    // Verify Header:
    //

    if ((pMessage->MessageId != SSL2_MT_SERVER_HELLO) ||
        (pMessage->ServerVersionMsb != SSL2_SERVER_VERSION_MSB) ||
        (pMessage->ServerVersionLsb != SSL2_SERVER_VERSION_LSB) )
    {
        return  SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    cbCertificate = COMBINEBYTES(   pMessage->CertificateLenMsb,
                                    pMessage->CertificateLenLsb);

    cCipherSpecs = COMBINEBYTES(pMessage->CipherSpecsLenMsb,
                                pMessage->CipherSpecsLenLsb);

    if(cCipherSpecs % sizeof(Ssl2_Cipher_Tuple))
    {
        return  SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }
    
    cCipherSpecs /= sizeof(Ssl2_Cipher_Tuple);

    cbConnId = COMBINEBYTES(pMessage->ConnectionIdLenMsb,
                            pMessage->ConnectionIdLenLsb);

    if(ReportedSize + 2 < SSL_OFFSET_OF(PSSL2_SERVER_HELLO, VariantData) +
                          cbCertificate +
                          cCipherSpecs * sizeof(Ssl2_Cipher_Tuple) +
                          cbConnId)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }
                          
    pCanonical = (PSsl2_Server_Hello)SPExternalAlloc(
                        sizeof(Ssl2_Server_Hello) +
                        cCipherSpecs * sizeof(Ssl2_Cipher_Kind)  +
                        cbCertificate );


    if (!pCanonical)
    {
        return(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
    }

    pCanonical->pCertificate = (PUCHAR) (pCanonical + 1);
    pCanonical->pCipherSpecs = (PCipherSpec) (pCanonical + 1);
    pCanonical->pCertificate = (PUCHAR) (pCanonical->pCipherSpecs + cCipherSpecs);



    //
    // Expand out:
    //

    pCanonical->SessionIdHit = (DWORD) pMessage->SessionIdHit;
    pCanonical->CertificateType = (DWORD) pMessage->CertificateType;
    pCanonical->cbCertificate = cbCertificate;
    pCanonical->cCipherSpecs = cCipherSpecs;
    pCanonical->cbConnectionID = cbConnId;

    pBuffer = pMessage->VariantData;

    CopyMemory(pCanonical->pCertificate, pBuffer, cbCertificate);
    pBuffer += cbCertificate;

    for (i = 0 ; i < cCipherSpecs ; i++ )
    {
        pCanonical->pCipherSpecs[i] = Ssl2MapCipherFromExternal((PSsl2_Cipher_Tuple)
                                                                pBuffer);

        pBuffer += sizeof(Ssl2_Cipher_Tuple);
    }

    if ((cbConnId) && (cbConnId <= SSL2_MAX_CONNECTION_ID_LEN))
    {
        CopyMemory(pCanonical->ConnectionID, pBuffer, cbConnId);
    }
    else
    {
        SPExternalFree(pCanonical);
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    *ppServer = pCanonical;
    pInput->cbData = ReportedSize + sizeof(SSL2_MESSAGE_HEADER);
    return( PCT_ERR_OK);

}

SP_STATUS
Ssl2PackClientMasterKey(
    PSsl2_Client_Master_Key      pCanonical,
    PSPBuffer              pCommOutput)
{
    DWORD                   cbMessage;
    PSSL2_CLIENT_MASTER_KEY pMessage;
    PUCHAR                  pBuffer;

    cbMessage = pCanonical->ClearKeyLen +
                    pCanonical->EncryptedKeyLen +
                    pCanonical->KeyArgLen +
                    SSL_OFFSET_OF(PSSL2_CLIENT_MASTER_KEY, VariantData) -
                    sizeof(SSL2_MESSAGE_HEADER);

    pCommOutput->cbData = cbMessage + 2;

        /* are we allocating our own memory? */
    if(pCommOutput->pvBuffer == NULL)
    {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }
    if(pCommOutput->cbData > pCommOutput->cbBuffer)
    {
        // Required buffer size returned in pCommOutput->cbData.
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }
    pMessage = pCommOutput->pvBuffer;

    pBuffer = pMessage->VariantData;

    pMessage->Header.Byte0 = MSBOF(cbMessage) | 0x80;
    pMessage->Header.Byte1 = LSBOF(cbMessage);

    pMessage->MessageId = SSL2_MT_CLIENT_MASTER_KEY;
    Ssl2MapCipherToExternal(pCanonical->CipherKind, &pMessage->CipherKind);

    pMessage->ClearKeyLenMsb = MSBOF(pCanonical->ClearKeyLen);
    pMessage->ClearKeyLenLsb = LSBOF(pCanonical->ClearKeyLen);

    CopyMemory(pBuffer, pCanonical->ClearKey, pCanonical->ClearKeyLen);
    pBuffer += pCanonical->ClearKeyLen;

    pMessage->EncryptedKeyLenMsb = MSBOF(pCanonical->EncryptedKeyLen);
    pMessage->EncryptedKeyLenLsb = LSBOF(pCanonical->EncryptedKeyLen);

    CopyMemory(pBuffer, pCanonical->pbEncryptedKey, pCanonical->EncryptedKeyLen);
    pBuffer += pCanonical->EncryptedKeyLen;

    pMessage->KeyArgLenMsb = MSBOF(pCanonical->KeyArgLen);
    pMessage->KeyArgLenLsb = LSBOF(pCanonical->KeyArgLen);

    CopyMemory(pBuffer, pCanonical->KeyArg, pCanonical->KeyArgLen);

    return(PCT_ERR_OK);

}


SP_STATUS
Ssl2UnpackClientMasterKey(
    PSPBuffer              pInput,
    PSsl2_Client_Master_Key *    ppClient)
{
    PSsl2_Client_Master_Key  pCanonical;
    PSSL2_CLIENT_MASTER_KEY  pMessage;
    PUCHAR              pBuffer;
    DWORD               ReportedSize;
    DWORD               EncryptedKeyLen;

    pMessage = pInput->pvBuffer;

    if(pInput->cbData < 2)
    {
        pInput->cbData = 2;
        return PCT_INT_INCOMPLETE_MSG;
    }
    ReportedSize = SIZEOF(pMessage);

    if ((ReportedSize+2) > pInput->cbData)
    {
        pInput->cbData = ReportedSize+2;
        return PCT_INT_INCOMPLETE_MSG;
    }

    if(ReportedSize + 2 < SSL_OFFSET_OF(PSSL2_CLIENT_MASTER_KEY, VariantData))
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    *ppClient = NULL;

    if ((pMessage->MessageId != SSL2_MT_CLIENT_MASTER_KEY))
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    EncryptedKeyLen = COMBINEBYTES( pMessage->EncryptedKeyLenMsb,
                                    pMessage->EncryptedKeyLenLsb );


    if(ReportedSize + 2 < SSL_OFFSET_OF(PSSL2_CLIENT_MASTER_KEY, VariantData) + 
                          EncryptedKeyLen)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    pCanonical = (PSsl2_Client_Master_Key)SPExternalAlloc(
                            sizeof(Ssl2_Client_Master_Key) +
                            EncryptedKeyLen);

    if (!pCanonical)
    {
        return SP_LOG_RESULT( PCT_INT_INTERNAL_ERROR );
    }

    pCanonical->CipherKind = Ssl2MapCipherFromExternal( &pMessage->CipherKind );
    pCanonical->ClearKeyLen = COMBINEBYTES( pMessage->ClearKeyLenMsb,
                                            pMessage->ClearKeyLenLsb );

    pCanonical->EncryptedKeyLen = EncryptedKeyLen;

    pCanonical->KeyArgLen = COMBINEBYTES(   pMessage->KeyArgLenMsb,
                                            pMessage->KeyArgLenLsb );


    //
    // Validate
    //
    if ((pCanonical->ClearKeyLen > SSL2_MASTER_KEY_SIZE) ||
        (pCanonical->KeyArgLen > SSL2_MAX_KEY_ARGS))
    {
        SPExternalFree(pCanonical);
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }


    if ((SSL_OFFSET_OF(PSSL2_CLIENT_MASTER_KEY, VariantData) -
         sizeof(SSL2_MESSAGE_HEADER) +
         pCanonical->ClearKeyLen +
         pCanonical->EncryptedKeyLen +
         pCanonical->KeyArgLen ) !=
         ReportedSize)
    {
        SPExternalFree(pCanonical);
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    pBuffer = pMessage->VariantData;

    CopyMemory(pCanonical->ClearKey, pBuffer, pCanonical->ClearKeyLen );

    pBuffer += pCanonical->ClearKeyLen;

    pCanonical->pbEncryptedKey = (PBYTE)(pCanonical + 1);
    CopyMemory(pCanonical->pbEncryptedKey, pBuffer, pCanonical->EncryptedKeyLen );

    pBuffer += pCanonical->EncryptedKeyLen;

    CopyMemory( pCanonical->KeyArg, pBuffer, pCanonical->KeyArgLen );

    *ppClient = pCanonical;

    return( PCT_ERR_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\ssl3key.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
*   Owner       : ramas
*   Date        : 4/16/96
*   description : Main Crypto functions for SSL3
*----------------------------------------------------------------------------*/

#include <spbase.h>
#include <ssl3key.h>
#include <ssl2msg.h>
#include <ssl3msg.h>
#include <ssl2prot.h>


//+---------------------------------------------------------------------------
//
//  Function:   Ssl3MakeWriteSessionKeys
//
//  Synopsis:   
//
//  Arguments:  [pContext]      --  Schannel context.
//
//  History:    10-08-97   jbanes   Added server-side CAPI integration.
//
//  Notes:      
//
//----------------------------------------------------------------------------
SP_STATUS
Ssl3MakeWriteSessionKeys(PSPContext pContext)
{
    BOOL fClient;

    // Determine if we're a client or a server.
    fClient = (0 != (pContext->RipeZombie->fProtocol & SP_PROT_SSL3_CLIENT));

    //
    // Derive write key.
    //

    if(pContext->hWriteKey)
    {
        if(!CryptDestroyKey(pContext->hWriteKey))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hWriteProv       = pContext->RipeZombie->hMasterProv;
    pContext->hWriteKey        = pContext->hPendingWriteKey;
    pContext->hPendingWriteKey = 0;

    //
    // Derive the write MAC key.
    //

    if(pContext->hWriteMAC)
    {
        if(!CryptDestroyKey(pContext->hWriteMAC))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hWriteMAC = pContext->hPendingWriteMAC;
    pContext->hPendingWriteMAC = 0;

    DebugLog((DEB_TRACE, "Write Keys are Computed\n"));

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   Ssl3MakeReadSessionKeys
//
//  Synopsis:   
//
//  Arguments:  [pContext]      --  Schannel context.
//
//  History:    10-03-97   jbanes   Added server-side CAPI integration.
//
//  Notes:      
//
//----------------------------------------------------------------------------
SP_STATUS
Ssl3MakeReadSessionKeys(PSPContext pContext)
{
    BOOL fClient;

    // Determine if we're a client or a server.
    fClient = (pContext->RipeZombie->fProtocol & SP_PROT_SSL3_CLIENT);


    //
    // Derive the read key.
    //

    if(pContext->hReadKey)
    {
        if(!CryptDestroyKey(pContext->hReadKey))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hReadProv       = pContext->RipeZombie->hMasterProv;
    pContext->hReadKey        = pContext->hPendingReadKey;
    pContext->hPendingReadKey = 0;

    //
    // Derive the read MAC key.
    //

    if(pContext->hReadMAC)
    {
        if(!CryptDestroyKey(pContext->hReadMAC))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hReadMAC = pContext->hPendingReadMAC;
    pContext->hPendingReadMAC = 0;

    DebugLog((DEB_TRACE, "Read Keys are Computed\n"));

    return PCT_ERR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\ssl2msg.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ssl2msg.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    10-21-97   jbanes   Added CAPI integration
//
//----------------------------------------------------------------------------

#include <spbase.h>

#if 0
Ssl2CipherMap Ssl2CipherRank[] = 
{
    {SSL_CK_RC4_128_WITH_MD5,              CALG_MD5, CALG_RC4,  128, SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX},
    {SSL_CK_DES_192_EDE3_CBC_WITH_MD5,     CALG_MD5, CALG_3DES, 168, SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX},
    {SSL_CK_RC2_128_CBC_WITH_MD5,          CALG_MD5, CALG_RC2,  128, SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX},
    {SSL_CK_RC4_128_FINANCE64_WITH_MD5,    CALG_MD5, CALG_RC4,   64, SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX},
    {SSL_CK_DES_64_CBC_WITH_MD5,           CALG_MD5, CALG_DES,   56, SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX},
    {SSL_CK_RC4_128_EXPORT40_WITH_MD5,     CALG_MD5, CALG_RC4,   40, SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX},
    {SSL_CK_RC2_128_CBC_EXPORT40_WITH_MD5, CALG_MD5, CALG_RC2,   40, SP_EXCH_RSA_PKCS1, CALG_RSA_KEYX}
};
DWORD Ssl2NumCipherRanks = sizeof(Ssl2CipherRank)/sizeof(Ssl2CipherMap);
#endif

#if 0
CertTypeMap aSsl2CertEncodingPref[] =
{
    { X509_ASN_ENCODING, 0}
};

DWORD cSsl2CertEncodingPref = sizeof(aSsl2CertEncodingPref)/sizeof(CertTypeMap);
#endif

SP_STATUS WINAPI
Ssl2DecryptHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pAppOutput)
{
    SP_STATUS pctRet = PCT_ERR_OK;

    if (pCommInput->cbData > 0)
    {
        // First, we'll handle incoming data packets:

        if ((pContext->State & SP_STATE_CONNECTED) && pContext->Decrypt)
        {
            pctRet = pContext->Decrypt(
                            pContext,
                            pCommInput,  // message
                            pAppOutput);    // Unpacked Message
            if (PCT_ERR_OK == pctRet)
            {
                /* look for escapes */
            }
            return(pctRet);
        }
        else
        {
            return(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
        }
    }
    return (PCT_INT_INCOMPLETE_MSG);
}

//+---------------------------------------------------------------------------
//
//  Function:   Ssl2ComputeMac
//
//  Synopsis:   Compute an SSL2 message MAC.
//
//  Arguments:  [pContext]          --  Schannel context.
//
//  History:    10-22-97   jbanes   Created.
//
//  Notes:      MAC_DATA := Hash(key + data + sequence_number)
//
//----------------------------------------------------------------------------
static SP_STATUS
Ssl2ComputeMac(
    PSPContext pContext,    // in
    BOOL       fWriteMAC,   // in
    DWORD      dwSequence,  // in
    PSPBuffer  pData,       // in
    PBYTE      pbMac,       // out
    DWORD      cbMac)       // in
{
    DWORD       dwReverseSequence;
    BYTE        rgbSalt[SP_MAX_MASTER_KEY];
    DWORD       cbSalt;
    HCRYPTHASH  hHash;
    HCRYPTKEY   hKey;

    // Make sure output buffer is big enough.
    if(cbMac < pContext->pHashInfo->cbCheckSum)
    {
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }

    dwReverseSequence = htonl(dwSequence);

    hKey = fWriteMAC ? pContext->hWriteKey : pContext->hReadKey;

    if(!CryptCreateHash(pContext->RipeZombie->hMasterProv,
                        pContext->pHashInfo->aiHash,
                        0,
                        0,
                        &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    if(!CryptHashSessionKey(hHash, 
                            hKey, 
                            CRYPT_LITTLE_ENDIAN))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }
    cbSalt = sizeof(rgbSalt);
    if(!CryptGetKeyParam(hKey, 
                         KP_SALT, 
                         rgbSalt, 
                         &cbSalt, 
                         0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }
    if(!CryptHashData(hHash, rgbSalt, cbSalt, 0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    if(!CryptHashData(hHash, 
                      pData->pvBuffer, 
                      pData->cbData, 
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    if(!CryptHashData(hHash, 
                      (PBYTE)&dwReverseSequence, 
                      sizeof(DWORD), 
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    if(!CryptGetHashParam(hHash, 
                          HP_HASHVAL, 
                          pbMac, 
                          &cbMac, 
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    CryptDestroyHash(hHash);

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   Ssl2EncryptMessage
//
//  Synopsis:   Encode a block of data as an SSL2 record.
//
//  Arguments:  [pContext]      --  Schannel context.
//              [pAppInput]     --  Data to be encrypted.
//              [pCommOutput]   --  (output) Completed SSL2 record.
//
//  History:    10-22-97   jbanes   CAPI integrated.
//
//  Notes:      An SSL2 record is usually formatted as:
//
//                  BYTE header[2];
//                  BYTE mac[mac_size];
//                  BYTE data[pAppInput->cbData];
//
//              If a block cipher is used, and the data to be encrypted
//              consists of a partial number of blocks, then the following
//              format is used:
//
//                  BYTE header[3];
//                  BYTE mac[mac_size];
//                  BYTE data[pAppInput->cbData];
//                  BYTE padding[padding_size];
//
//----------------------------------------------------------------------------
SP_STATUS WINAPI
Ssl2EncryptMessage( 
    PSPContext     pContext,
    PSPBuffer      pAppInput,
    PSPBuffer      pCommOutput)
{
    SP_STATUS                  pctRet;
    DWORD                      cPadding;
    SPBuffer                   Clean;    
    SPBuffer                   Encrypted;

   
    SP_BEGIN("Ssl2EncryptMessage");

    /* Estimate if we have padding or not */
    Encrypted.cbData = pAppInput->cbData + pContext->pHashInfo->cbCheckSum;
    cPadding = (Encrypted.cbData % pContext->pCipherInfo->dwBlockSize);
    if(cPadding)
    {
        cPadding = pContext->pCipherInfo->dwBlockSize - cPadding;
    }

    Encrypted.cbData += cPadding;

    if(cPadding) 
    {
        if(pCommOutput->cbBuffer + Encrypted.cbData + cPadding < 3)
        {
            SP_RETURN(SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL));
        }
        Encrypted.pvBuffer = (PUCHAR)pCommOutput->pvBuffer + 3;
        Encrypted.cbBuffer = pCommOutput->cbBuffer - 3;
    } 
    else 
    {
        if(pCommOutput->cbBuffer + Encrypted.cbData + cPadding < 2)
        {
            SP_RETURN(SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL));
        }
        Encrypted.pvBuffer = (PUCHAR)pCommOutput->pvBuffer + 2;
        Encrypted.cbBuffer = pCommOutput->cbBuffer - 2;
    }
    
    DebugLog((DEB_TRACE, "Sealing message %x\n", pContext->WriteCounter));


    /* Move data out of the way if necessary */
    if((PUCHAR)Encrypted.pvBuffer + pContext->pHashInfo->cbCheckSum != pAppInput->pvBuffer) 
    {
        DebugLog((DEB_WARN, "SSL2EncryptMessage: Unnecessary Move, performance hog\n"));
        /* if caller wasn't being smart, then we must copy memory here */
        MoveMemory((PUCHAR)Encrypted.pvBuffer + pContext->pHashInfo->cbCheckSum, 
                   pAppInput->pvBuffer,
                   pAppInput->cbData); 
    }

    // Initialize pad
    if(cPadding)
    {
        FillMemory((PUCHAR)Encrypted.pvBuffer + pContext->pHashInfo->cbCheckSum + pAppInput->cbData, cPadding, 0);
    }

    // Compute MAC.
    Clean.pvBuffer = (PBYTE)Encrypted.pvBuffer + pContext->pHashInfo->cbCheckSum;
    Clean.cbData   = Encrypted.cbData - pContext->pHashInfo->cbCheckSum;
    Clean.cbBuffer = Clean.cbData;

    pctRet = Ssl2ComputeMac(pContext,
                            TRUE,
                            pContext->WriteCounter,
                            &Clean,
                            Encrypted.pvBuffer,
                            pContext->pHashInfo->cbCheckSum);
    if(pctRet != PCT_ERR_OK)
    {
        SP_RETURN(pctRet);
    }

    // Encrypt buffer.
    if(!CryptEncrypt(pContext->hWriteKey,
                        0, FALSE, 0,
                        Encrypted.pvBuffer,
                        &Encrypted.cbData,
                        Encrypted.cbBuffer))
    {
        SP_LOG_RESULT(GetLastError());
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    /* set sizes */
    if(cPadding) 
    {
        if(Encrypted.cbData > 0x3fff)
        {
            SP_RETURN(SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW));
        }

        ((PUCHAR)pCommOutput->pvBuffer)[0]= (UCHAR)(0x3f & (Encrypted.cbData>>8));
        ((PUCHAR)pCommOutput->pvBuffer)[1]= (UCHAR)(0xff & Encrypted.cbData);
        ((PUCHAR)pCommOutput->pvBuffer)[2]= (UCHAR)cPadding;

    } 
    else 
    {
        if(Encrypted.cbData > 0x7fff) 
        {
            SP_RETURN(SP_LOG_RESULT(PCT_INT_DATA_OVERFLOW));
        }
        ((PUCHAR)pCommOutput->pvBuffer)[0]= (UCHAR)(0x7f & (Encrypted.cbData>>8)) | 0x80;
        ((PUCHAR)pCommOutput->pvBuffer)[1]= (UCHAR)(0xff & Encrypted.cbData);
    }

    pCommOutput->cbData = Encrypted.cbData + (cPadding?3:2);

    pContext->WriteCounter ++ ;

    SP_RETURN( PCT_ERR_OK );
}

SP_STATUS WINAPI
Ssl2GetHeaderSize(
    PSPContext pContext,
    PSPBuffer pCommInput,
    DWORD * pcbHeaderSize)
{
    if(pcbHeaderSize == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }
    if(pCommInput->cbData < 1)
    {
        return (PCT_INT_INCOMPLETE_MSG);
    }
    if(  ((PUCHAR)pCommInput->pvBuffer)[0]&0x80 )
    {
        *pcbHeaderSize = 2 + pContext->pHashInfo->cbCheckSum;
    }
    else
    {
        *pcbHeaderSize = 3 + pContext->pHashInfo->cbCheckSum;
    }
    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   Ssl2DecryptMessage
//
//  Synopsis:   Decode an SSL2 record.
//
//  Arguments:  [pContext]      --  Schannel context.
//              [pMessage]      --  Data from the remote party.
//              [pAppOutput]    --  (output) Decrypted data.
//
//  History:    10-22-97   jbanes   CAPI integrated.
//
//  Notes:      An SSL2 record is usually formatted as:
//
//                  BYTE header[2];
//                  BYTE mac[mac_size];
//                  BYTE data[pAppInput->cbData];
//
//              If a block cipher is used, and the data to be encrypted
//              consists of a partial number of blocks, then the following
//              format is used:
//
//                  BYTE header[3];
//                  BYTE mac[mac_size];
//                  BYTE data[pAppInput->cbData];
//                  BYTE padding[padding_size];
//
//              The number of input data bytes consumed by this function
//              is returned in pMessage->cbData.
//              
//----------------------------------------------------------------------------
SP_STATUS WINAPI
Ssl2DecryptMessage( 
    PSPContext         pContext,
    PSPBuffer          pMessage,
    PSPBuffer          pAppOutput)
{
    SP_STATUS   pctRet;
    DWORD       cPadding;
    DWORD       dwLength;
    SPBuffer    Encrypted;
    SPBuffer    Clean;
    DWORD       cbActualData;
    UCHAR       Digest[SP_MAX_DIGEST_LEN];

    SP_BEGIN("Ssl2DecryptMessage");

    /* First determine the length of data, the length of padding,
     * and the location of data, and the location of MAC */
    cbActualData = pMessage->cbData;
    pMessage->cbData = 2; /* minimum amount of data we need */
    
    if(pMessage->cbData > cbActualData) 
    {
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }
    DebugLog((DEB_TRACE, "  Incomming Buffer: %lx, size %ld (%lx)\n", pMessage->pvBuffer, cbActualData, cbActualData));

    if(((PUCHAR)pMessage->pvBuffer)[0] & 0x80)
    {
        /* 2 byte header */
        cPadding = 0;
        dwLength = ((((PUCHAR)pMessage->pvBuffer)[0] & 0x7f) << 8) | 
                   ((PUCHAR)pMessage->pvBuffer)[1];

        Encrypted.pvBuffer = (PUCHAR)pMessage->pvBuffer + 2;
        Encrypted.cbBuffer = pMessage->cbBuffer - 2;
    } 
    else 
    {
        pMessage->cbData++;
        if(pMessage->cbData > cbActualData) 
        {
            SP_RETURN(PCT_INT_INCOMPLETE_MSG);
        }

        /* 3 byte header */
        cPadding = ((PUCHAR)pMessage->pvBuffer)[2];
        dwLength = ((((PUCHAR)pMessage->pvBuffer)[0] & 0x3f) << 8) | 
                   ((PUCHAR)pMessage->pvBuffer)[1];

        Encrypted.pvBuffer = (PUCHAR)pMessage->pvBuffer + 3;
        Encrypted.cbBuffer = pMessage->cbBuffer - 3;
    }

    /* Now we know how mutch data we will eat, so set cbData on the Input to be that size */
    pMessage->cbData += dwLength;

    /* do we have enough bytes for the reported data */
    if(pMessage->cbData > cbActualData) 
    {
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    /* do we have enough data for our checksum */
    if(dwLength < pContext->pHashInfo->cbCheckSum + cPadding) 
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_MSG_ALTERED));
    }

    Encrypted.cbData   = dwLength;    /* encrypted data size */
    Encrypted.cbBuffer = Encrypted.cbData;

    /* check to see if we have a block size violation */
    if(Encrypted.cbData % pContext->pCipherInfo->dwBlockSize) 
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_MSG_ALTERED));
    }

    /* Decrypt */
    if(!CryptDecrypt(pContext->hReadKey,
                        0, FALSE, 0,
                        Encrypted.pvBuffer,
                        &Encrypted.cbData))
    {
        SP_LOG_RESULT(GetLastError());
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    // Compute MAC.
    Clean.pvBuffer = (PBYTE)Encrypted.pvBuffer + pContext->pHashInfo->cbCheckSum;
    Clean.cbData   = Encrypted.cbData - pContext->pHashInfo->cbCheckSum;
    Clean.cbBuffer = Clean.cbData;

    pctRet = Ssl2ComputeMac(pContext,
                            FALSE,
                            pContext->ReadCounter,
                            &Clean,
                            Digest,
                            sizeof(Digest));
    if(pctRet != PCT_ERR_OK)
    {
        SP_RETURN(pctRet);
    }

    // the padding is computed in the hash but is not needed after this
    Clean.cbData  -= cPadding;

    DebugLog((DEB_TRACE, "Unsealing message %x\n", pContext->ReadCounter));

    pContext->ReadCounter++;

    if(memcmp(Digest, Encrypted.pvBuffer, pContext->pHashInfo->cbCheckSum ) )
    {
       SP_RETURN(SP_LOG_RESULT(PCT_INT_MSG_ALTERED));
    }

    if(pAppOutput->pvBuffer != Clean.pvBuffer) 
    {
        DebugLog((DEB_WARN, "SSL2DecryptMessage: Unnecessary Move, performance hog\n"));
        MoveMemory(pAppOutput->pvBuffer, 
                   Clean.pvBuffer, 
                   Clean.cbData); 
    }
    pAppOutput->cbData = Clean.cbData;
    DebugLog((DEB_TRACE, "  TotalData: size %ld (%lx)\n", pMessage->cbData, pMessage->cbData));

    SP_RETURN( PCT_ERR_OK );
}

#if 0
SP_STATUS
Ssl2MakeMasterKeyBlock(PSPContext pContext)
{

    MD5_CTX     Md5Hash;
    UCHAR       cSalt;
    UCHAR       ib;


    //pContext->RipeZombe->pMasterKey containst the master secret.

#if DBG
    DebugLog((DEB_TRACE, "  Master Secret\n"));
    DBG_HEX_STRING(DEB_TRACE,pContext->RipeZombie->pMasterKey, pContext->RipeZombie->cbMasterKey);

#endif

    for(ib=0 ; ib<3 ; ib++)
    {
        // MD5(master_secret + SHA-hash)
        MD5Init  (&Md5Hash);
        MD5Update(&Md5Hash, pContext->RipeZombie->pMasterKey, pContext->RipeZombie->cbMasterKey);

        // We're going to be bug-for-bug compatable with netscape, so
        // we always add the digit into the hash, instead of following
        // the spec which says don't add the digit for DES
        //if(pContext->RipeZombie->aiCipher != CALG_DES)
        {
            cSalt = ib+'0';
            MD5Update(&Md5Hash, &cSalt, 1);
        }
        MD5Update(&Md5Hash, pContext->pChallenge, pContext->cbChallenge);
        MD5Update(&Md5Hash, pContext->pConnectionID, pContext->cbConnectionID);
        MD5Final (&Md5Hash);
        CopyMemory(pContext->Ssl3MasterKeyBlock + ib * MD5DIGESTLEN, Md5Hash.digest, MD5DIGESTLEN);
    }
 #if DBG
    DebugLog((DEB_TRACE, "  Master Key Block\n"));
    DBG_HEX_STRING(DEB_TRACE,pContext->Ssl3MasterKeyBlock, MD5DIGESTLEN*3);

#endif
   return( PCT_ERR_OK );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\ssl2srv.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ssl2srv.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-08-95   RichardW   Created
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <ssl2msg.h>
#include <ssl2prot.h>



SP_STATUS Ssl2SrvGenerateServerFinish(PSPContext pContext,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2SrvGenerateServerVerify(PSPContext pContext,
                              PSPBuffer  pCommOutput);

SP_STATUS Ssl2SrvVerifyClientFinishMsg(PSPContext pContext,
                              PSPBuffer  pCommInput);

#define SSL_OFFSET_OF(t, v) ((DWORD)(ULONG_PTR)&(((t)NULL)->v))


#define SSL2_CERT_TYPE_FROM_CAPI(s) X509_ASN_ENCODING


SP_STATUS WINAPI
Ssl2ServerProtocolHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pCommOutput)
{
    SP_STATUS pctRet = 0;
    DWORD cMessageType;

    DWORD dwStateTransition;
    BOOL fRaw = TRUE;
    SPBuffer MsgInput;

    if (NULL != pCommOutput)
    {
        pCommOutput->cbData = 0;
    }

    MsgInput.pvBuffer = pCommInput->pvBuffer;
    MsgInput.cbBuffer = pCommInput->cbBuffer;
    MsgInput.cbData   = pCommInput->cbData;

    // In the following states, we should decrypt the message:


    switch(pContext->State)
    {
        case SSL2_STATE_SERVER_VERIFY:
        case SSL2_STATE_SERVER_RESTART:
            pctRet = Ssl2DecryptMessage(pContext, pCommInput, &MsgInput);
            cMessageType = ((PUCHAR) MsgInput.pvBuffer)[0];
            fRaw = FALSE;
            break;

        case SP_STATE_SHUTDOWN:
        case SP_STATE_SHUTDOWN_PENDING:
            cMessageType = 0;
            break;

        case SP_STATE_CONNECTED:
            // The server has attempted to initiate a reconnect.
            return SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);

        default:
            if(pCommInput->cbData < 3)
            {
                return SP_LOG_RESULT(PCT_INT_INCOMPLETE_MSG);
            }
            cMessageType = ((PUCHAR) MsgInput.pvBuffer)[2];
            break;

    }


    if (pctRet != PCT_ERR_OK)
    {
        // to handle incomplete message errors
        return(pctRet);
    }

    dwStateTransition = pContext->State | (cMessageType<<16);




    switch(dwStateTransition)
    {
        case SP_STATE_SHUTDOWN_PENDING:
            // There's no CloseNotify in SSL2, so just transition to
            // the shutdown state and leave the output buffer empty.
            pContext->State = SP_STATE_SHUTDOWN;
            break;

        case SP_STATE_SHUTDOWN:
            return PCT_INT_EXPIRED;

        /* Server receives client hello */
        case (SSL2_MT_CLIENT_HELLO << 16) | SP_STATE_NONE:
        {
            PSsl2_Client_Hello pSsl2Hello;

            // Attempt to recognize and handle various versions of client
            // hello, start by trying to unpickle the most recent version, and
            // then next most recent, until one unpickles.  Then run the handle
            // code.  We can also put unpickling and handling code in here for
            // SSL messages.

            pctRet = Ssl2UnpackClientHello(pCommInput, &pSsl2Hello);

            if (PCT_ERR_OK == pctRet)
            {

                if (((pContext->Flags & CONTEXT_FLAG_NOCACHE) == 0) &&
                    (pSsl2Hello->cbSessionID) &&
                    (SPCacheRetrieveBySession(pContext,
                                              pSsl2Hello->SessionID,
                                              pSsl2Hello->cbSessionID,
                                              &pContext->RipeZombie)))

                {
                    DebugLog((DEB_TRACE, "Accept client's reconnect request.\n"));

                    pctRet = Ssl2SrvGenRestart(pContext,
                                               pSsl2Hello,
                                               pCommOutput);
                    if (PCT_ERR_OK == pctRet)
                    {
                        pContext->State = SSL2_STATE_SERVER_VERIFY;
                    }
                }
                else
                {
                    // We're doing a full handshake, so allocate a cache entry.

                    if(!SPCacheRetrieveNew(TRUE,
                                           pContext->pszTarget, 
                                           &pContext->RipeZombie))
                    {
                        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
                    }
                    else
                    {
                        pContext->RipeZombie->fProtocol = pContext->dwProtocol;
                        pContext->RipeZombie->dwCF      = pContext->dwRequestedCF;

                        SPCacheAssignNewServerCredential(pContext->RipeZombie,
                                                         pContext->pCredGroup);

                        pctRet = Ssl2SrvHandleClientHello(pContext,
                                                          pCommInput,
                                                          pSsl2Hello,
                                                          pCommOutput);
                        if (PCT_ERR_OK == pctRet)
                        {
                            pContext->State = SSL2_STATE_SERVER_HELLO;
                        }
                    }
                }
                SPExternalFree(pSsl2Hello);

            }
            else if(pctRet != PCT_INT_INCOMPLETE_MSG)
            {
                pctRet |= PCT_INT_DROP_CONNECTION;
            }


            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }
            break;
        }

        case (SSL2_MT_CLIENT_MASTER_KEY << 16) | SSL2_STATE_SERVER_HELLO:

            pctRet = Ssl2SrvHandleCMKey(pContext, pCommInput, pCommOutput);
            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }
            else
            {
                if (PCT_ERR_OK == pctRet)
                {
                    pContext->State = SSL2_STATE_SERVER_VERIFY;
                }
                // We received a non-fatal error, so the state doesn't change,
                // giving the app time to deal with this.
            }
            break;

        case (SSL2_MT_CLIENT_FINISHED_V2 << 16) | SSL2_STATE_SERVER_VERIFY:
            pctRet = Ssl2SrvHandleClientFinish(
                                                pContext,
                                                &MsgInput,
                                                pCommOutput);
            if (SP_FATAL(pctRet))
            {
                pContext->State = PCT1_STATE_ERROR;
            }
            else
            {
            if (PCT_ERR_OK == pctRet)
            {
                pContext->State = SP_STATE_CONNECTED;
                pContext->DecryptHandler = Ssl2DecryptHandler;
                pContext->Encrypt = Ssl2EncryptMessage;
                pContext->Decrypt = Ssl2DecryptMessage;
                pContext->GetHeaderSize = Ssl2GetHeaderSize;

            }
            // We received a non-fatal error, so the state doesn't change,
            // giving the app time to deal with this.
            }
            break;

        default:
            DebugLog((DEB_WARN, "Error in protocol, dwStateTransition is %lx\n", dwStateTransition));
            pContext->State = PCT1_STATE_ERROR;
            pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
            break;
    }

    if (pctRet & PCT_INT_DROP_CONNECTION)
    {
        pContext->State &= ~SP_STATE_CONNECTED;
    }

    return(pctRet);
}



SP_STATUS
Ssl2SrvHandleClientHello(
    PSPContext         pContext,
    PSPBuffer           pCommInput,
    PSsl2_Client_Hello  pHello,
    PSPBuffer           pCommOutput)
{
    SP_STATUS pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PSPCredential  pCred;
    Ssl2_Server_Hello    Reply;
    DWORD           cCommonCiphers;
    DWORD           CommonCiphers[MAX_UNI_CIPHERS];
    PSessCacheItem  pZombie;
    BOOL            fFound;
    DWORD           i,j;

    UNREFERENCED_PARAMETER(pCommInput);

    SP_BEGIN("Ssl2SrvHandleClientHello");

    pCommOutput->cbData = 0;

    /* validate the buffer configuration */

    if(NULL == pContext)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }
    pZombie = pContext->RipeZombie;

    // See if we have a cert that supports ssl2
    pctRet = SPPickServerCertificate(pContext, SP_EXCH_RSA_PKCS1);
    if(PCT_ERR_OK != pctRet)
    {
        SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);
    }

    pCred   = pZombie->pActiveServerCred;
    if (!pCred)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

        ZeroMemory(&Reply, sizeof(Reply));

        //
        // Calculate common ciphers:
        //

        cCommonCiphers = 0;

        for(i = 0; i < UniNumCiphers; i++)
        {
            PCipherInfo      pCipherInfo;
            PHashInfo        pHashInfo;
            PKeyExchangeInfo pExchInfo;

            // Is this an SSL2 cipher suite?
            if(!(UniAvailableCiphers[i].fProt & pContext->RipeZombie->fProtocol))
            {
                continue;
            }

            pCipherInfo = GetCipherInfo(UniAvailableCiphers[i].aiCipher,
                                        UniAvailableCiphers[i].dwStrength);
            if(NULL == pCipherInfo)
            {
                continue;
            }

            if(!IsCipherSuiteAllowed(pContext,
                                     pCipherInfo,
                                     pZombie->fProtocol,
                                     pZombie->dwCF,
                                     UniAvailableCiphers[i].dwFlags))
            {
                continue;
            }

            pHashInfo = GetHashInfo(UniAvailableCiphers[i].aiHash);
            if(NULL == pHashInfo)
            {
                continue;
            }

            if(!IsHashAllowed(pContext, pHashInfo, pZombie->fProtocol))
            {
                continue;
            }

            pExchInfo = GetKeyExchangeInfo(UniAvailableCiphers[i].KeyExch);
            if(NULL == pExchInfo)
            {
                continue;
            }
            if(!IsExchAllowed(pContext, pExchInfo, pZombie->fProtocol))
            {
                continue;
            }


            // Is this cipher suite supported by the client?
            for(fFound = FALSE, j = 0; j < pHello->cCipherSpecs; j++)
            {
                if(UniAvailableCiphers[i].CipherKind == pHello->CipherSpecs[j])
                {
                    fFound = TRUE;
                    break;
                }
            }
            if(!fFound)
            {
                continue;
            }

            // Does the CSP support this cipher suite?
            if(!IsAlgSupportedCapi(pContext->RipeZombie->fProtocol,
                                   UniAvailableCiphers + i,
                                   pCred->pCapiAlgs,
                                   pCred->cCapiAlgs))
            {
                continue;
            }

            // Add this cipher to list.
            CommonCiphers[cCommonCiphers++] = UniAvailableCiphers[i].CipherKind;
        }

        //
        // if cCommonCipers == 0, then we have none in common.  At this point, we
        // should generate an error response, but that is for later.  For now,
        // we will generate an invalid_token return, and bail out.
        //

        if (cCommonCiphers == 0)
        {
            pctRet = SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
            LogCipherMismatchEvent();
            goto error;
        }


        Reply.cCipherSpecs = cCommonCiphers;
        Reply.pCipherSpecs = CommonCiphers;
        Reply.SessionIdHit = 0;

        Reply.CertificateType =   SSL2_CERT_TYPE_FROM_CAPI(pCred->pCert->dwCertEncodingType);

        // Auto allocate the certificate.  !We must free them when we're done....
        Reply.pCertificate = NULL;
        Reply.cbCertificate = 0;
        pctRet = SPSerializeCertificate(SP_PROT_SSL2,
                                        FALSE,
                                        &Reply.pCertificate,
                                        &Reply.cbCertificate,
                                        pCred->pCert,
                                        0);

        if (PCT_ERR_OK != pctRet)
        {
            goto error;
        }



        /* Generate a conneciton id to use while establishing connection */

        Reply.cbConnectionID = SSL2_GEN_CONNECTION_ID_LEN;
        pctRet = GenerateRandomBits(Reply.ConnectionID,
                                    Reply.cbConnectionID);
        if(!NT_SUCCESS(pctRet))
        {
            goto error;
        }

        CopyMemory(pContext->pConnectionID,
                   Reply.ConnectionID,
                   Reply.cbConnectionID);
        pContext->cbConnectionID = Reply.cbConnectionID;


        /* keep challenge around for later */
        CopyMemory( pContext->pChallenge,
                    pHello->Challenge,
                    pHello->cbChallenge);
        pContext->cbChallenge = pHello->cbChallenge;



        pctRet = Ssl2PackServerHello(&Reply, pCommOutput);

        if(Reply.pCertificate)
        {
            SPExternalFree(Reply.pCertificate);
        }

        if (PCT_ERR_OK != pctRet)
        {
            goto error;
        }
        pContext->WriteCounter = 1;  /* received client hello */
        pContext->ReadCounter = 1;   /* Sending server hello */


        SP_RETURN(PCT_ERR_OK);

error:

    if((pContext->Flags & CONTEXT_FLAG_EXT_ERR) &&
        (pctRet == PCT_ERR_SPECS_MISMATCH))
    {
        // Our SSL2 implementation does not do client auth,
        // so there is only one error message, cipher error.
        pCommOutput->cbData = 3; // MSG-ERROR + ERROR-CODE-MSB + ERROR-CODE-LSB

        if(pCommOutput->pvBuffer == NULL)
        {
            pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
            if (NULL == pCommOutput->pvBuffer)
            {
                SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
            }
            pCommOutput->cbBuffer = pCommOutput->cbData;
        }
        if(pCommOutput->cbData > pCommOutput->cbBuffer)
        {
            // Required buffer size returned in pCommOutput->cbData.
            SP_RETURN(SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL));
        }

        ((PUCHAR)pCommOutput->pvBuffer)[0] = SSL2_MT_ERROR;
        ((PUCHAR)pCommOutput->pvBuffer)[1] = MSBOF(SSL_PE_NO_CIPHER);
        ((PUCHAR)pCommOutput->pvBuffer)[2] = LSBOF(SSL_PE_NO_CIPHER);

    }
    SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);
}



 SP_STATUS
 Ssl2SrvGenRestart(
    PSPContext         pContext,
    PSsl2_Client_Hello  pHello,
    PSPBuffer           pCommOutput)
{
    SP_STATUS pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    SPBuffer SecondOutput;
    Ssl2_Server_Hello    Reply;
    DWORD cbMessage, cbMsg, cPadding;
    PSessCacheItem  pZombie;

    SP_BEGIN("Ssl2SrvGenRestart");

    pCommOutput->cbData = 0;

    /* validate the buffer configuration */

    /* make sure we have the needed authentication data area */
    if (NULL == pContext)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }
    pZombie = pContext->RipeZombie;



        FillMemory( &Reply, sizeof( Reply ), 0 );

        Reply.SessionIdHit = (DWORD)1;
        Reply.cCipherSpecs = 0;
        Reply.pCipherSpecs = NULL;
        Reply.pCertificate = NULL;
        Reply.cbCertificate = 0;
        Reply.CertificateType = 0;

        /* Note, we generate both a server hello, and a server verify in
         * this handling routing.  This is because netscape will not send
         * us a client finish until the server verify is received
         */


        // Load pending ciphers from cache
        pctRet = ContextInitCiphersFromCache(pContext);

        if(PCT_ERR_OK != pctRet)
        {
            goto error;
        }

        pctRet = ContextInitCiphers(pContext, TRUE, TRUE);

        if(PCT_ERR_OK != pctRet)
        {
            goto error;
        }

        Reply.cbConnectionID = SSL2_GEN_CONNECTION_ID_LEN;
        pctRet = GenerateRandomBits(Reply.ConnectionID,
                                    Reply.cbConnectionID);
        if(!NT_SUCCESS(pctRet))
        {
            goto error;
        }

        CopyMemory(pContext->pConnectionID,
                   Reply.ConnectionID,
                   Reply.cbConnectionID);
        pContext->cbConnectionID = Reply.cbConnectionID;


        /* keep challenge around for later */
        CopyMemory( pContext->pChallenge,
                    pHello->Challenge,
                    pHello->cbChallenge);
        pContext->cbChallenge = pHello->cbChallenge;


        // Make a new set of session keys.
        pctRet = MakeSessionKeys(pContext,
                                 pContext->RipeZombie->hMasterProv,
                                 pContext->RipeZombie->hMasterKey);
        if(pctRet != PCT_ERR_OK)
        {
            goto error;
        }

        // Activate session keys.
        pContext->hReadKey          = pContext->hPendingReadKey;
        pContext->hWriteKey         = pContext->hPendingWriteKey;
        pContext->hPendingReadKey   = 0;
        pContext->hPendingWriteKey  = 0;


        /* calc size of the server hello (restart only) */
        cbMessage = Reply.cbConnectionID +
                        Reply.cbCertificate +
                        Reply.cCipherSpecs * sizeof(Ssl2_Cipher_Tuple) +
                        SSL_OFFSET_OF(PSSL2_SERVER_HELLO, VariantData) -
                        sizeof(SSL2_MESSAGE_HEADER);

        pCommOutput->cbData = cbMessage + 2;

        /* calc size of server verify */
        cbMsg  = sizeof(UCHAR) + pContext->cbChallenge;

        cPadding = ((cbMsg+pContext->pHashInfo->cbCheckSum) % pContext->pCipherInfo->dwBlockSize);
        if(cPadding)
        {
            cPadding = pContext->pCipherInfo->dwBlockSize - cPadding;
        }

        pCommOutput->cbData += cbMsg +
                              pContext->pHashInfo->cbCheckSum +
                              cPadding +
                              (cPadding?3:2);


        /* are we allocating our own memory? */
        if(pCommOutput->pvBuffer == NULL) {
            pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
            if (NULL == pCommOutput->pvBuffer)
                SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
            pCommOutput->cbBuffer = pCommOutput->cbData;
        }

        if(pCommOutput->cbData > pCommOutput->cbBuffer)
        {
            // Required buffer size returned in pCommOutput->cbData.
            SP_RETURN(PCT_INT_BUFF_TOO_SMALL);
        }


        pctRet = Ssl2PackServerHello(&Reply, pCommOutput);
        if (PCT_ERR_OK != pctRet)
        {
            goto error;
        }
        pContext->WriteCounter = 1;  /* received client hello */
        pContext->ReadCounter = 1;   /* Sending server hello */

        /* Now pack the server verify message and encrypt it */
        SecondOutput.pvBuffer = (PUCHAR)pCommOutput->pvBuffer+pCommOutput->cbData;
        SecondOutput.cbBuffer = pCommOutput->cbBuffer-pCommOutput->cbData;


        pctRet = Ssl2SrvGenerateServerVerify(pContext, &SecondOutput);
        if (PCT_ERR_OK != pctRet)
        {
            goto error;
        }
        pCommOutput->cbData += SecondOutput.cbData;

        SP_RETURN(PCT_ERR_OK);

        
error:
        SP_RETURN(pctRet | PCT_INT_DROP_CONNECTION);
}



SP_STATUS
Ssl2SrvHandleCMKey(
    PSPContext pContext,
    PSPBuffer   pCommInput,
    PSPBuffer   pCommOutput)
{
    SP_STATUS          pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PSsl2_Client_Master_Key  pMasterKey = NULL;
    DWORD               i;

    DWORD               cbData;
    PSessCacheItem      pZombie;

    SP_BEGIN("Ssl2SrvHandleCMKey");

    pCommOutput->cbData = 0;

    pZombie = pContext->RipeZombie;

        /* make sure we have the needed authentication data area */

        cbData = pCommInput->cbData;
        pctRet = Ssl2UnpackClientMasterKey(pCommInput, &pMasterKey);


        if (PCT_ERR_OK != pctRet)
        {
            // If it's an incomplete message or something, just return;
            if(!SP_FATAL(pctRet))
            {
                SP_RETURN(pctRet);
            }
            goto error;
        }

        pctRet = PCT_ERR_ILLEGAL_MESSAGE;


        /* CMK sent cleartext, so we must auto-inc the read counter */
        pContext->ReadCounter++;

        pContext->pCipherInfo = NULL;
        pContext->pHashInfo = NULL;
        pContext->pKeyExchInfo = NULL;

        // Pick a cipher suite

        pctRet = PCT_ERR_SPECS_MISMATCH;
        for(i = 0; i < UniNumCiphers; i++)
        {
            // Is this an SSL2 cipher suite?
            if(!(UniAvailableCiphers[i].fProt & pContext->RipeZombie->fProtocol))
            {
                continue;
            }

            if(UniAvailableCiphers[i].CipherKind != pMasterKey->CipherKind)
            {
                continue;
            }


            pZombie->aiCipher     = UniAvailableCiphers[i].aiCipher;
            pZombie->dwStrength   = UniAvailableCiphers[i].dwStrength;
            pZombie->aiHash       = UniAvailableCiphers[i].aiHash;
            pZombie->SessExchSpec = UniAvailableCiphers[i].KeyExch;

            pctRet = ContextInitCiphersFromCache(pContext);

            if(pctRet != PCT_ERR_OK)
            {
                continue;
            }
            break;
        }

        pctRet = ContextInitCiphers(pContext, TRUE, TRUE);
        if(pctRet != PCT_ERR_OK)
        {
            SP_LOG_RESULT(pctRet);
            goto error;
        }


        /* Copy over the key args */
        CopyMemory( pZombie->pKeyArgs,
                    pMasterKey->KeyArg,
                    pMasterKey->KeyArgLen );
        pZombie->cbKeyArgs = pMasterKey->KeyArgLen;


        // Store the clear key in the context structure.
        CopyMemory( pZombie->pClearKey,
                    pMasterKey->ClearKey,
                    pMasterKey->ClearKeyLen);
        pZombie->cbClearKey = pMasterKey->ClearKeyLen;


        /* Decrypt the encrypted portion of the master key */
        pctRet = pContext->pKeyExchInfo->System->GenerateServerMasterKey(
                    pContext,
                    pMasterKey->ClearKey,
                    pMasterKey->ClearKeyLen,
                    pMasterKey->pbEncryptedKey,
                    pMasterKey->EncryptedKeyLen);
        if(PCT_ERR_OK != pctRet)
        {
            goto error;
        }


        SPExternalFree( pMasterKey );
        pMasterKey = NULL;

        // Update keys.
        pContext->hReadKey  = pContext->hPendingReadKey;
        pContext->hWriteKey = pContext->hPendingWriteKey;
        pContext->hPendingReadKey   = 0;
        pContext->hPendingWriteKey  = 0;


        pctRet = Ssl2SrvGenerateServerVerify(pContext, pCommOutput);
        SP_RETURN(pctRet);


error:
    if (pMasterKey)
    {
        SPExternalFree( pMasterKey );
    }
    if((pContext->Flags & CONTEXT_FLAG_EXT_ERR) &&
        (pctRet == PCT_ERR_SPECS_MISMATCH))
    {
        // Our SSL2 implementation does not do client auth,
        // so there is only one error message, cipher error.
        pCommOutput->cbData = 3; // MSG-ERROR + ERROR-CODE-MSB + ERROR-CODE-LSB

        /* are we allocating our own memory? */
        if(pCommOutput->pvBuffer == NULL)
        {
            pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);

            if (NULL == pCommOutput->pvBuffer)
            {
                SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
            }
            pCommOutput->cbBuffer = pCommOutput->cbData;
        }
        if(pCommOutput->cbData <= pCommOutput->cbBuffer)
        {
            ((PUCHAR)pCommOutput->pvBuffer)[0] = SSL2_MT_ERROR;
            ((PUCHAR)pCommOutput->pvBuffer)[1] = MSBOF(SSL_PE_NO_CIPHER);
            ((PUCHAR)pCommOutput->pvBuffer)[2] = LSBOF(SSL_PE_NO_CIPHER);
        }
        else
        {
            pCommOutput->cbData = 0;
        }

    }
    SP_RETURN((PCT_INT_DROP_CONNECTION | pctRet));
}



SP_STATUS
Ssl2SrvVerifyClientFinishMsg(
    PSPContext pContext,
    PSPBuffer  pCommInput)
{
    PSSL2_CLIENT_FINISHED pFinished;

    SP_BEGIN("Ssl2SrvVerifyClientFinishMsg");


    /* Note, there is no header in this message, as it has been pre-decrypted */
    if (pCommInput->cbData != sizeof(UCHAR) + pContext->cbConnectionID)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }
    pFinished = pCommInput->pvBuffer;
    if (pFinished->MessageId != SSL2_MT_CLIENT_FINISHED_V2)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }

    if ( memcmp(pFinished->ConnectionID,
            pContext->pConnectionID,
            pContext->cbConnectionID))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }
    SP_RETURN(PCT_ERR_OK);

}

SP_STATUS
Ssl2SrvGenerateServerVerify(
    PSPContext pContext,
    PSPBuffer   pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PSSL2_SERVER_VERIFY     pVerify;
    DWORD                   HeaderSize;
    SPBuffer                MsgOutput;
    DWORD                   cPadding;
    BOOL                    fAlloced = FALSE;

    pCommOutput->cbData = 0;

    SP_BEGIN("Ssl2SrvGenerateServerVerify");

    MsgOutput.cbData = sizeof(UCHAR) + pContext->cbChallenge;
    cPadding = ((MsgOutput.cbData+pContext->pHashInfo->cbCheckSum) % pContext->pCipherInfo->dwBlockSize);
    if(cPadding)
    {
        cPadding = pContext->pCipherInfo->dwBlockSize - cPadding;
    }

    HeaderSize = (cPadding?3:2);

    pCommOutput->cbData = MsgOutput.cbData +
                          pContext->pHashInfo->cbCheckSum +
                          cPadding + HeaderSize;


    /* are we allocating our own memory? */
    if (pCommOutput->pvBuffer == NULL) {
        pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
        if (NULL == pCommOutput->pvBuffer)
        {
            SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }
        fAlloced = TRUE;
        pCommOutput->cbBuffer = pCommOutput->cbData;
    }

    MsgOutput.pvBuffer= (PUCHAR)pCommOutput->pvBuffer +
                         HeaderSize+pContext->pHashInfo->cbCheckSum;

    MsgOutput.cbBuffer=  pCommOutput->cbBuffer -
                         HeaderSize-pContext->pHashInfo->cbCheckSum;


    pVerify = (PSSL2_SERVER_VERIFY) MsgOutput.pvBuffer;
    pVerify->MessageId = SSL2_MT_SERVER_VERIFY;


    CopyMemory( pVerify->ChallengeData,
            pContext->pChallenge,
            pContext->cbChallenge );


    pctRet = Ssl2EncryptMessage( pContext, &MsgOutput, pCommOutput);
    if(PCT_ERR_OK != pctRet)
    {
        goto error;
    }
    SP_RETURN(PCT_ERR_OK);

error:

    if(fAlloced && (NULL != pCommOutput->pvBuffer))
    {
        SPExternalFree(pCommOutput->pvBuffer);
        pCommOutput->cbBuffer = 0;
        pCommOutput->cbData = 0;
        pCommOutput->pvBuffer = NULL;

    }
    SP_RETURN(PCT_INT_DROP_CONNECTION | pctRet);
}

SP_STATUS
Ssl2SrvGenerateServerFinish(
    PSPContext pContext,
    PSPBuffer   pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    PSSL2_SERVER_FINISHED pFinish;
    DWORD                   HeaderSize;
    SPBuffer                MsgOutput;
    DWORD                   cPadding;
    BOOL                    fAlloced = FALSE;
    pCommOutput->cbData = 0;
    SP_BEGIN("Ssl2SrvGenerateServerFinish");


        /* Generate a session id to use during the session */
        pContext->RipeZombie->cbSessionID = SSL2_SESSION_ID_LEN;

        /* store this context in the cache */
        /* note - we don't check error 'cause it's recoverable
         * if we don't cache */

        SPCacheAdd(pContext);

        MsgOutput.cbData = sizeof(UCHAR) + pContext->RipeZombie->cbSessionID;
        cPadding = ((MsgOutput.cbData+pContext->pHashInfo->cbCheckSum) % pContext->pCipherInfo->dwBlockSize);
        if(cPadding)
        {
            cPadding = pContext->pCipherInfo->dwBlockSize - cPadding;
        }

        HeaderSize = (cPadding?3:2);

        pCommOutput->cbData = MsgOutput.cbData +
                              pContext->pHashInfo->cbCheckSum +
                              cPadding +
                              HeaderSize;

        /* are we allocating our own memory? */
        if(pCommOutput->pvBuffer == NULL)
        {
            pCommOutput->pvBuffer = SPExternalAlloc(pCommOutput->cbData);
            if (NULL == pCommOutput->pvBuffer)
            {
                SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
            }
            fAlloced = TRUE;

            pCommOutput->cbBuffer = pCommOutput->cbData;
        }
        if(pCommOutput->cbData > pCommOutput->cbBuffer)
        {
            // Required buffer size returned in pCommOutput->cbData.
            SP_RETURN(SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL));
        }

        MsgOutput.pvBuffer= (PUCHAR)pCommOutput->pvBuffer + HeaderSize+pContext->pHashInfo->cbCheckSum;
        MsgOutput.cbBuffer=  pCommOutput->cbBuffer-HeaderSize-pContext->pHashInfo->cbCheckSum;


        pFinish = (PSSL2_SERVER_FINISHED) MsgOutput.pvBuffer;
        pFinish->MessageId = SSL2_MT_SERVER_FINISHED_V2;


        CopyMemory( pFinish->SessionID,
                pContext->RipeZombie->SessionID,
                pContext->RipeZombie->cbSessionID );

        /* Cache Context Here */

        pctRet = Ssl2EncryptMessage( pContext, &MsgOutput, pCommOutput);
        if(PCT_ERR_OK != pctRet)
        {
            goto error;
        }

        SP_RETURN(PCT_ERR_OK);


error:

    if(fAlloced && (NULL != pCommOutput->pvBuffer))
    {
        SPExternalFree(pCommOutput->pvBuffer);
        pCommOutput->cbBuffer = 0;
        pCommOutput->cbData = 0;
        pCommOutput->pvBuffer = NULL;

    }
    SP_RETURN(PCT_INT_DROP_CONNECTION | pctRet);

 }

SP_STATUS
Ssl2SrvHandleClientFinish(
    PSPContext pContext,
    PSPBuffer   pCommInput,
    PSPBuffer   pCommOutput)
{
    SP_STATUS     pctRet = PCT_ERR_ILLEGAL_MESSAGE;

    SP_BEGIN("Ssl2SrvHandleClientFinish");

    pCommOutput->cbData = 0;

    pctRet = Ssl2SrvVerifyClientFinishMsg(pContext, pCommInput);
    if (PCT_ERR_OK != pctRet)
    {
        SP_RETURN(pctRet);
    }
    pctRet = Ssl2SrvGenerateServerFinish(pContext, pCommOutput);

    SP_RETURN(pctRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\tls1key.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
*   Owner       : ramas
*   Date        : 5/03/97
*   description : Main Crypto functions for TLS1
*----------------------------------------------------------------------------*/

#include <spbase.h>

#define DEB_TLS1KEYS  0x01000000


//+---------------------------------------------------------------------------
//
//  Function:   Tls1MakeWriteSessionKeys
//
//  Synopsis:   
//
//  Arguments:  [pContext]      --  Schannel context.
//
//  History:    10-10-97   jbanes   Added server-side CAPI integration.
//
//  Notes:      
//
//----------------------------------------------------------------------------
SP_STATUS
Tls1MakeWriteSessionKeys(PSPContext pContext)
{
    BOOL fClient;

    // Determine if we're a client or a server.
    fClient = (0 != (pContext->RipeZombie->fProtocol & SP_PROT_TLS1_CLIENT));

    if(pContext->hWriteKey)
    {
        if(!CryptDestroyKey(pContext->hWriteKey))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hWriteProv       = pContext->RipeZombie->hMasterProv;
    pContext->hWriteKey        = pContext->hPendingWriteKey;
    pContext->hPendingWriteKey = 0;

    if(pContext->hWriteMAC)
    {
        if(!CryptDestroyKey(pContext->hWriteMAC))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hWriteMAC        = pContext->hPendingWriteMAC;
    pContext->hPendingWriteMAC = 0;

    return PCT_ERR_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   Tls1MakeReadSessionKeys
//
//  Synopsis:   
//
//  Arguments:  [pContext]      --  Schannel context.
//
//  History:    10-10-97   jbanes   Added server-side CAPI integration.
//
//  Notes:      
//
//----------------------------------------------------------------------------
SP_STATUS
Tls1MakeReadSessionKeys(PSPContext pContext)
{
    BOOL fClient;

    // Determine if we're a client or a server.
    fClient = (0 != (pContext->RipeZombie->fProtocol & SP_PROT_TLS1_CLIENT));

    if(pContext->hReadKey)
    {
        if(!CryptDestroyKey(pContext->hReadKey))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hReadProv       = pContext->RipeZombie->hMasterProv;
    pContext->hReadKey        = pContext->hPendingReadKey;
    pContext->hPendingReadKey = 0;

    if(pContext->hReadMAC)
    {
        if(!CryptDestroyKey(pContext->hReadMAC))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }
    pContext->hReadMAC        = pContext->hPendingReadMAC;
    pContext->hPendingReadMAC = 0;

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   Tls1ComputeMac
//
//  Synopsis:   
//
//  Arguments:  [pContext]      --  
//              [hSecret]       --
//              [dwSequence]    --  
//              [pClean]        --  
//              [cContentType]  --  
//              [pbMac]         --  
//              [cbMac]
//
//  History:    10-03-97   jbanes   Created.
//
//  Notes:      
//
//----------------------------------------------------------------------------
SP_STATUS
Tls1ComputeMac(
    PSPContext  pContext,
    BOOL        fReadMac,
    PSPBuffer   pClean,
    CHAR        cContentType,
    PBYTE       pbMac,
    DWORD       cbMac)
{
    HCRYPTHASH  hHash;
    HMAC_INFO   HmacInfo;
    PBYTE       pbData;
    DWORD       cbData;
    DWORD       cbDataReverse;
    DWORD       dwReverseSequence;
    UCHAR       rgbData1[15]; 
    PUCHAR      pbData1;
    DWORD       cbData1;
    HCRYPTPROV  hProv;
    HCRYPTKEY   hSecret;
    DWORD       dwSequence;
    PHashInfo   pHashInfo;

    pbData = pClean->pvBuffer;
    cbData = pClean->cbData; 
    if(cbData & 0xFFFF0000)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(fReadMac)
    {
        hProv      = pContext->hReadProv;
        hSecret    = pContext->hReadMAC;
        dwSequence = pContext->ReadCounter;
        pHashInfo  = pContext->pReadHashInfo;
    }
    else
    {
        hProv      = pContext->hWriteProv;
        hSecret    = pContext->hWriteMAC;
        dwSequence = pContext->WriteCounter;
        pHashInfo  = pContext->pWriteHashInfo;
    }

    if(!hProv)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // Create hash object.
    if(!CryptCreateHash(hProv,
                        CALG_HMAC,
                        hSecret,
                        0,
                        &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        return PCT_INT_INTERNAL_ERROR;
    }

    // Specify hash algorithm.
    ZeroMemory(&HmacInfo, sizeof(HMAC_INFO));
    HmacInfo.HashAlgid = pHashInfo->aiHash;
    if(!CryptSetHashParam(hHash,
                          HP_HMAC_INFO,
                          (PBYTE)&HmacInfo,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_INT_INTERNAL_ERROR;
    }

    // Build data to be hashed.
    cbData1 = 2 * sizeof(DWORD) +   // sequence number (64-bit)
              1 +                   // content type
              2 +                   // protocol version
              2;                    // message length 
    SP_ASSERT(cbData1 <= sizeof(rgbData1));

    pbData1 = rgbData1;

    ZeroMemory(pbData1, sizeof(DWORD));
    pbData1 += sizeof(DWORD);
    dwReverseSequence = htonl(dwSequence);
    CopyMemory(pbData1, &dwReverseSequence, sizeof(DWORD));
    pbData1 += sizeof(DWORD);

    *pbData1++ = cContentType;

    *pbData1++ = SSL3_CLIENT_VERSION_MSB;
    *pbData1++ = TLS1_CLIENT_VERSION_LSB;

    cbDataReverse = (cbData >> 8) | (cbData << 8);
    CopyMemory(pbData1, &cbDataReverse, 2);

    // Hash data.
    if(!CryptHashData(hHash, rgbData1, cbData1, 0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_INT_INTERNAL_ERROR;
    }
    if(!CryptHashData(hHash, pbData, cbData, 0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_INT_INTERNAL_ERROR;
    }

    // Get hash value.
    if(!CryptGetHashParam(hHash,
                          HP_HASHVAL,
                          pbMac,
                          &cbMac,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        CryptDestroyHash(hHash);
        return PCT_INT_INTERNAL_ERROR;
    }
    SP_ASSERT(cbMac == pHashInfo->cbCheckSum);

    #if DBG
        DebugLog((DEB_TLS1KEYS, "  TLS1 MAC Output"));
        DBG_HEX_STRING(DEB_TLS1KEYS, pbMac, cbMac);
    #endif

    CryptDestroyHash(hHash);

    return PCT_ERR_OK;
}

#define HMAC_K_PADSIZE              64

BOOL MyPrimitiveSHA(
			PBYTE       pbData, 
			DWORD       cbData,
            BYTE        rgbHash[A_SHA_DIGEST_LEN])
{
    BOOL fRet = FALSE;
    A_SHA_CTX   sSHAHash;

            
    A_SHAInit(&sSHAHash);
    A_SHAUpdate(&sSHAHash, (BYTE *) pbData, cbData);
    A_SHAFinal(&sSHAHash, rgbHash);

    fRet = TRUE;
//Ret:

    return fRet;
}                                

BOOL MyPrimitiveMD5(
			PBYTE       pbData, 
			DWORD       cbData,
            BYTE        rgbHash[MD5DIGESTLEN])
{
    BOOL fRet = FALSE;
    MD5_CTX   sMD5Hash;

            
    MD5Init(&sMD5Hash);
    MD5Update(&sMD5Hash, (BYTE *) pbData, cbData);
    MD5Final(&sMD5Hash);
    memcpy(rgbHash, sMD5Hash.digest, MD5DIGESTLEN);

    fRet = TRUE;
//Ret:

    return fRet;
}                                

BOOL MyPrimitiveHMACParam(
        PBYTE       pbKeyMaterial, 
        DWORD       cbKeyMaterial,
        PBYTE       pbData, 
        DWORD       cbData,
        ALG_ID      Algid,
        BYTE        rgbHMAC[A_SHA_DIGEST_LEN])
{
    BYTE    rgbHMACTmp[HMAC_K_PADSIZE+A_SHA_DIGEST_LEN];
    BOOL    fRet = FALSE;

    BYTE    rgbKipad[HMAC_K_PADSIZE];
    BYTE    rgbKopad[HMAC_K_PADSIZE];
    DWORD   dwBlock;

    // truncate
    if (cbKeyMaterial > HMAC_K_PADSIZE)
        cbKeyMaterial = HMAC_K_PADSIZE;

    
    ZeroMemory(rgbKipad, HMAC_K_PADSIZE);
    CopyMemory(rgbKipad, pbKeyMaterial, cbKeyMaterial);

    ZeroMemory(rgbKopad, HMAC_K_PADSIZE);
    CopyMemory(rgbKopad, pbKeyMaterial, cbKeyMaterial);

    // Kipad, Kopad are padded sMacKey. Now XOR across...
    for(dwBlock=0; dwBlock<HMAC_K_PADSIZE/sizeof(DWORD); dwBlock++)
    {
        ((DWORD*)rgbKipad)[dwBlock] ^= 0x36363636;
        ((DWORD*)rgbKopad)[dwBlock] ^= 0x5C5C5C5C;
    }

    // prepend Kipad to data, Hash to get H1
    if (CALG_SHA1 == Algid)
    {
        // do this inline since it would require data copy
        A_SHA_CTX   sSHAHash;
        BYTE        HashVal[A_SHA_DIGEST_LEN];

        A_SHAInit(&sSHAHash);
        A_SHAUpdate(&sSHAHash, rgbKipad, HMAC_K_PADSIZE);
        A_SHAUpdate(&sSHAHash, pbData, cbData);

        // Finish off the hash
        A_SHAFinal(&sSHAHash, HashVal);

        // prepend Kopad to H1, hash to get HMAC
        CopyMemory(rgbHMACTmp, rgbKopad, HMAC_K_PADSIZE);
        CopyMemory(rgbHMACTmp+HMAC_K_PADSIZE, HashVal, A_SHA_DIGEST_LEN);

        if (!MyPrimitiveSHA(
			    rgbHMACTmp, 
			    HMAC_K_PADSIZE + A_SHA_DIGEST_LEN,
                rgbHMAC))
            goto Ret;
    }
    else
    {
        // do this inline since it would require data copy
        MD5_CTX   sMD5Hash;
            
        MD5Init(&sMD5Hash);
        MD5Update(&sMD5Hash, rgbKipad, HMAC_K_PADSIZE);
        MD5Update(&sMD5Hash, pbData, cbData);
        MD5Final(&sMD5Hash);

        // prepend Kopad to H1, hash to get HMAC
        CopyMemory(rgbHMACTmp, rgbKopad, HMAC_K_PADSIZE);
        CopyMemory(rgbHMACTmp+HMAC_K_PADSIZE, sMD5Hash.digest, MD5DIGESTLEN);

        if (!MyPrimitiveMD5(
			    rgbHMACTmp, 
			    HMAC_K_PADSIZE + MD5DIGESTLEN,
                rgbHMAC))
            goto Ret;
    }

    fRet = TRUE;
Ret:

    return fRet;    
}

//+ ---------------------------------------------------------------------
// the P_Hash algorithm from TLS 
BOOL P_Hash
(
    PBYTE  pbSecret,
    DWORD  cbSecret, 

    PBYTE  pbSeed,  
    DWORD  cbSeed,  

    ALG_ID Algid,

    PBYTE  pbKeyOut, //Buffer to copy the result...
    DWORD  cbKeyOut  //# of bytes of key length they want as output.
)
{
    BOOL    fRet = FALSE;
    BYTE    rgbDigest[A_SHA_DIGEST_LEN];      
    DWORD   iKey;
    DWORD   cbHash;

    PBYTE   pbAofiDigest = NULL;

    SafeAllocaAllocate(pbAofiDigest, cbSeed + A_SHA_DIGEST_LEN);
    if (NULL == pbAofiDigest)
        goto Ret;

    if (CALG_SHA1 == Algid)
    {
        cbHash = A_SHA_DIGEST_LEN;
    }
    else
    {
        cbHash = MD5DIGESTLEN;
    }

//   First, we define a data expansion function, P_hash(secret, data)
//   which uses a single hash function to expand a secret and seed into
//   an arbitrary quantity of output:

//       P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
//                              HMAC_hash(secret, A(2) + seed) +
//                              HMAC_hash(secret, A(3) + seed) + ...

//   Where + indicates concatenation.

//   A() is defined as:
//       A(0) = seed
//       A(i) = HMAC_hash(secret, A(i-1))


    // build A(1)
    if (!MyPrimitiveHMACParam(pbSecret, cbSecret, pbSeed, cbSeed,
                              Algid, pbAofiDigest))
        goto Ret;

    // create Aofi: (  A(i) | seed )
    CopyMemory(&pbAofiDigest[cbHash], pbSeed, cbSeed);

    for (iKey=0; cbKeyOut; iKey++)
    {
        // build Digest = HMAC(key | A(i) | seed);
        if (!MyPrimitiveHMACParam(pbSecret, cbSecret, pbAofiDigest,
                                  cbSeed + cbHash, Algid, rgbDigest))
            goto Ret;

        // append to pbKeyOut
        if(cbKeyOut < cbHash)
        {
            CopyMemory(pbKeyOut, rgbDigest, cbKeyOut);
            break;
        }
        else
        {
            CopyMemory(pbKeyOut, rgbDigest, cbHash);
            pbKeyOut += cbHash;
        }

        cbKeyOut -= cbHash;

        // build A(i) = HMAC(key, A(i-1))
        if (!MyPrimitiveHMACParam(pbSecret, cbSecret, pbAofiDigest, cbHash,
                                  Algid, pbAofiDigest))
            goto Ret;
    }

    fRet = TRUE;
Ret:
    if (pbAofiDigest)
        SafeAllocaFree(pbAofiDigest);

    return fRet;
}

BOOL PRF(
    PBYTE  pbSecret,
    DWORD  cbSecret, 

    PBYTE  pbLabel,  
    DWORD  cbLabel,
    
    PBYTE  pbSeed,  
    DWORD  cbSeed,  

    PBYTE  pbKeyOut, //Buffer to copy the result...
    DWORD  cbKeyOut  //# of bytes of key length they want as output.
    )
{
    BYTE    *pbBuff = NULL;
    BYTE    *pbLabelAndSeed = NULL;
    DWORD   cbLabelAndSeed;
    DWORD   cbOdd;
    DWORD   cbHalfSecret;
    DWORD   i;
    BOOL    fRet = FALSE;

    cbOdd = cbSecret % 2;
    cbHalfSecret = cbSecret / 2;

    cbLabelAndSeed = cbLabel + cbSeed;
    SafeAllocaAllocate(pbLabelAndSeed, cbLabelAndSeed);
    if (NULL == pbLabelAndSeed)
        goto Ret;
    SafeAllocaAllocate(pbBuff, cbKeyOut);
    if (NULL == pbBuff)
        goto Ret;

    // copy label and seed into one buffer
    memcpy(pbLabelAndSeed, pbLabel, cbLabel);
    memcpy(pbLabelAndSeed + cbLabel, pbSeed, cbSeed);

    // Use P_hash to calculate MD5 half
    if (!P_Hash(pbSecret, cbHalfSecret + cbOdd, pbLabelAndSeed,  
                cbLabelAndSeed, CALG_MD5, pbKeyOut, cbKeyOut))
        goto Ret;

    // Use P_hash to calculate SHA half
    if (!P_Hash(pbSecret + cbHalfSecret, cbHalfSecret + cbOdd, pbLabelAndSeed,  
                cbLabelAndSeed, CALG_SHA1, pbBuff, cbKeyOut))
        goto Ret;

    // XOR the two halves
    for (i=0;i<cbKeyOut;i++)
    {
        pbKeyOut[i] = pbKeyOut[i] ^ pbBuff[i];
    }
    fRet = TRUE;
Ret:
    if (pbBuff)
        SafeAllocaFree(pbBuff);
    if (pbLabelAndSeed)
        SafeAllocaFree(pbLabelAndSeed);
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\ssl3msg.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ssl3msg.c
//
//  Contents:   Main crypto functions for SSL3.
//
//  Classes:
//
//  Functions:
//
//  History:    04-16-96   ramas    Created.
//
//----------------------------------------------------------------------------

#include <spbase.h>

//------------------------------------------------------------------------------------------

SP_STATUS WINAPI
Ssl3DecryptHandler(
    PSPContext pContext,
    PSPBuffer pCommInput,
    PSPBuffer pAppOutput)
{
    SP_STATUS pctRet = PCT_ERR_OK;

    if(pCommInput->cbData == 0)
    {
        return PCT_INT_INCOMPLETE_MSG;
    }

    if(!(pContext->State & SP_STATE_CONNECTED) || pContext->Decrypt == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }

    switch(*(PBYTE)pCommInput->pvBuffer)
    {
    case SSL3_CT_HANDSHAKE:
        if(pContext->RipeZombie->fProtocol & SP_PROT_CLIENTS)
        {
            // This should be either a HelloRequest message, which means that
            // the server is requesting a renegotiation, or a ServerHello
            // message, which means that the server is responding to a 
            // renegotiation request that we made.

            // The first thing we need to do is to figure out which it is.
            // We want to go ahead and decrypt the HelloRequest message, but 
            // if it's a server hello message we want to punt this back to the
            // application so that they can give it to the LSA process via 
            // a call to InitializeSecurityContext.

            // BUGBUG - We should change the context state when we request
            // renegotiation and then just check the state here, but that's 
            // hard to do so for now we'll just check the size of the packet.
            if(pCommInput->cbBuffer > sizeof(SWRAP) + 
                                      sizeof(SHSH) + 
                                      pContext->pCipherInfo->dwBlockSize + 
                                      pContext->pHashInfo->cbCheckSum)
            {
                // Must be a ServerHello message.
                pCommInput->cbData = 0;

                pContext->State = SSL3_STATE_CLIENT_HELLO;
            }
            else
            {
                // This should be a HelloRequest message. We should make sure, and
                // then completely consume the message.
                pctRet = pContext->Decrypt( pContext,
                                            pCommInput,  // message
                                            pAppOutput);    // Unpacked Message
                if(PCT_ERR_OK != pctRet)
                {
                    return pctRet;
                }
    
                if(*(PBYTE)pAppOutput->pvBuffer != SSL3_HS_HELLO_REQUEST ||
                   pAppOutput->cbData != sizeof(SHSH))
                {
                    // This ain't no HelloRequest!
                    return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
                }

                pContext->State = SSL3_STATE_GEN_HELLO_REQUEST;
            }
        }
        else
        {
            // This is probably a ClientHello message. In any case, let the
            // caller deal with it (by passing it to the LSA process).
            pCommInput->cbData = 0;
            pContext->State = SSL3_STATE_RENEGOTIATE;
        }

        pAppOutput->cbData = 0;

        return SP_LOG_RESULT(PCT_INT_RENEGOTIATE);


    case SSL3_CT_ALERT:
        pctRet = pContext->Decrypt( pContext,
                                    pCommInput,
                                    pAppOutput);
        if(PCT_ERR_OK != pctRet)
        {
            return pctRet;
        }

        pctRet = ParseAlertMessage(pContext,
                                   (PBYTE)pAppOutput->pvBuffer,
                                   pAppOutput->cbData);

        // make sure that APP doesn't see Alert messages...
        pAppOutput->cbData = 0;
        
        return pctRet;


    case SSL3_CT_APPLICATIONDATA:
        pctRet = pContext->Decrypt( pContext,
                                    pCommInput,
                                    pAppOutput);

        return pctRet;


    default:
        return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
    }
}

SP_STATUS WINAPI
Ssl3GetHeaderSize(
    PSPContext pContext,
    PSPBuffer pCommInput,
    DWORD * pcbHeaderSize)
{
    UNREFERENCED_PARAMETER(pContext);
    UNREFERENCED_PARAMETER(pCommInput);

    if(pcbHeaderSize == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    *pcbHeaderSize = sizeof(SWRAP);
    return PCT_ERR_OK;
}



#if VERIFYHASH
BYTE rgb3Mac[2048];
DWORD ibMac = 0;
#endif

//+---------------------------------------------------------------------------
//
//  Function:   Ssl3ComputeMac
//
//  Synopsis:
//
//  Arguments:  [pContext]      --
//              [fReadMac]      --
//              [pClean]        --
//              [cContentType]  --
//              [pbMac]         --
//              [cbMac]
//
//  History:    10-03-97   jbanes   Created.
//
//  Notes:
//
//----------------------------------------------------------------------------
SP_STATUS
Ssl3ComputeMac(
    PSPContext  pContext,
    BOOL        fReadMac,
    PSPBuffer   pClean,
    CHAR        cContentType,
    PBYTE       pbMac,
    DWORD       cbMac)
{
    HCRYPTHASH  hHash = 0;
    DWORD       dwReverseSequence;
    WORD        wReverseData;
    UCHAR       rgbDigest[SP_MAX_DIGEST_LEN];
    DWORD       cbDigest;
    BYTE        rgbPad[CB_SSL3_MAX_MAC_PAD];
    WORD        cbPad;
    HCRYPTPROV  hProv;
    HCRYPTKEY   hSecret;
    DWORD       dwSequence;
    PHashInfo   pHashInfo;
    SP_STATUS   pctRet;

    UNREFERENCED_PARAMETER(cbMac);

    if(fReadMac)
    {
        hProv      = pContext->hReadProv;
        hSecret    = pContext->hReadMAC;
        dwSequence = pContext->ReadCounter;
        pHashInfo  = pContext->pReadHashInfo;
    }
    else
    {
        hProv      = pContext->hWriteProv;
        hSecret    = pContext->hWriteMAC;
        dwSequence = pContext->WriteCounter;
        pHashInfo  = pContext->pWriteHashInfo;
    }

    if(!hProv)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // Determine size of pad_1 and pad_2.
    if(pHashInfo->aiHash == CALG_MD5)
    {
        cbPad = CB_SSL3_MD5_MAC_PAD;
    }
    else
    {
        cbPad = CB_SSL3_SHA_MAC_PAD;
    }

    //
    // hash(MAC_write_secret + pad_2 +
    //      hash(MAC_write_secret + pad_1 + seq_num +
    //           SSLCompressed.type + SSLCompressed.length +
    //           SSLCompressed.fragment));
    //

    // Create hash
    if(!CryptCreateHash(hProv,
                        pHashInfo->aiHash,
                        0,
                        0,
                        &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    // Hash secret
    if(!CryptHashSessionKey(hHash,
                            hSecret,
                            CRYPT_LITTLE_ENDIAN))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    // hash pad 1
    FillMemory(rgbPad, cbPad, PAD1_CONSTANT);
    if(!CryptHashData(hHash, rgbPad, cbPad, 0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    /* add count */
    dwReverseSequence = 0;
    if(!CryptHashData(hHash,
                      (PUCHAR)&dwReverseSequence,
                      sizeof(DWORD),
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    dwReverseSequence = htonl(dwSequence);
    if(!CryptHashData(hHash,
                      (PUCHAR)&dwReverseSequence,
                      sizeof(DWORD),
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    // Add content type.
    if(cContentType != 0)
    {
        if(!CryptHashData(hHash, (PBYTE)&cContentType, 1, 0))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
    }

    /* add length */
    wReverseData = (WORD)pClean->cbData >> 8 | (WORD)pClean->cbData << 8;
    if(!CryptHashData(hHash,
                      (PBYTE)&wReverseData,
                      sizeof(WORD),
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    /* add data */
    if(!CryptHashData(hHash,
                      pClean->pvBuffer,
                      pClean->cbData,
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    #if VERIFYHASH
        if(ibMac > 1800) ibMac = 0;
        CopyMemory(&rgb3Mac[ibMac], (BYTE *)&dw32High, sizeof(DWORD));
        ibMac += sizeof(DWORD);
        CopyMemory(&rgb3Mac[ibMac], (BYTE *)&dwReverseSeq, sizeof(DWORD));
        ibMac += sizeof(DWORD);
        CopyMemory(&rgb3Mac[ibMac], (BYTE *)&wDataReverse, sizeof(WORD));
        ibMac += sizeof(WORD);
        if(wData < 50)
        {
            CopyMemory(&rgb3Mac[ibMac], (PUCHAR)pClean->pvBuffer, wData);
            ibMac += wData;
        }
    #endif

    // Get inner hash value.
    cbDigest = sizeof(rgbDigest);
    if(!CryptGetHashParam(hHash,
                          HP_HASHVAL,
                          rgbDigest,
                          &cbDigest,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    SP_ASSERT(pHashInfo->cbCheckSum == cbDigest);

    CryptDestroyHash(hHash);
    hHash = 0;

    #if VERIFYHASH
        CopyMemory(&rgb3Mac[ibMac], rgbDigest, pHashInfo->cbCheckSum);
        ibMac += pHashInfo->cbCheckSum;
    #endif



    // Create hash
    if(!CryptCreateHash(hProv,
                        pHashInfo->aiHash,
                        0,
                        0,
                        &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    // Hash secret
    if(!CryptHashSessionKey(hHash,
                            hSecret,
                            CRYPT_LITTLE_ENDIAN))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    // hash pad 2
    FillMemory(rgbPad, cbPad, PAD2_CONSTANT);
    if(!CryptHashData(hHash, rgbPad, cbPad, 0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    if(!CryptHashData(hHash, rgbDigest, cbDigest, 0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    // Get outer hash value.
    cbDigest = sizeof(rgbDigest);
    if(!CryptGetHashParam(hHash,
                          HP_HASHVAL,
                          rgbDigest,
                          &cbDigest,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    SP_ASSERT(pHashInfo->cbCheckSum == cbDigest);

    CryptDestroyHash(hHash);
    hHash = 0;

    #if VERIFYHASH
        CopyMemory(&rgb3Mac[ibMac], rgbDigest, pHashInfo->cbCheckSum);
        ibMac += pHashInfo->cbCheckSum;
    #endif

    CopyMemory(pbMac, rgbDigest, cbDigest);

    pctRet = PCT_ERR_OK;

cleanup:

    if(hHash)
    {
        CryptDestroyHash(hHash);
    }

    return pctRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   Ssl3BuildFinishMessage
//
//  Synopsis:
//
//  Arguments:  [pContext]      --
//              [pbMd5Digest]   --
//              [pbSHADigest]   --
//              [fClient]       --
//
//  History:    10-03-97   jbanes   Added server-side CAPI integration.
//
//  Notes:
//
//----------------------------------------------------------------------------
SP_STATUS
Ssl3BuildFinishMessage(
    PSPContext pContext,
    BYTE *pbMd5Digest,
    BYTE *pbSHADigest,
    BOOL fClient)
{
    BYTE rgbPad1[CB_SSL3_MAX_MAC_PAD];
    BYTE rgbPad2[CB_SSL3_MAX_MAC_PAD];
    BYTE szClnt[] = "CLNT";
    BYTE szSrvr[] = "SRVR";
    HCRYPTHASH hHash = 0;
    DWORD cbDigest;
    SP_STATUS pctRet;

    //
    // Compute the two hash values as follows:
    //
    // enum { client(0x434c4e54), server(0x53525652) } Sender;
    // enum { client("CLNT"), server("SRVR") } Sender;
    //
    // struct {
    //     opaque md5_hash[16];
    //     opaque sha_hash[20];
    // } Finished;
    //
    // md5_hash  -  MD5(master_secret + pad2 + MD5(handshake_messages +
    //      Sender + master_secret + pad1))
    //
    // sha_hash  -  SHA(master_secret + pad2 + SHA(handshake_messages +
    //      Sender + master_secret + pad1))
    //
    // pad_1 - The character 0x36 repeated 48 times for MD5 or
    //         40 times for SHA.
    //
    // pad_2 - The character 0x5c repeated the same number of times.
    //

    FillMemory(rgbPad1, sizeof(rgbPad1), PAD1_CONSTANT);
    FillMemory(rgbPad2, sizeof(rgbPad2), PAD2_CONSTANT);


    // Make local copy of the handshake_messages MD5 hash object
    if(!CryptDuplicateHash(pContext->hMd5Handshake,
                           NULL,
                           0,
                           &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    // Add rest of stuff to local MD5 hash object.
    if(!CryptHashData(hHash,
                      fClient ? szClnt : szSrvr,
                      4,
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    if(!CryptHashSessionKey(hHash,
                            pContext->RipeZombie->hMasterKey,
                            CRYPT_LITTLE_ENDIAN))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!CryptHashData(hHash,
                      rgbPad1,
                      CB_SSL3_MD5_MAC_PAD,
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    cbDigest = CB_MD5_DIGEST_LEN;
    if(!CryptGetHashParam(hHash,
                          HP_HASHVAL,
                          pbMd5Digest,
                          &cbDigest,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    CryptDestroyHash(hHash);
    hHash = 0;

    // Compute "parent" MD5 hash
    if(!CryptCreateHash(pContext->RipeZombie->hMasterProv,
                        CALG_MD5,
                        0,
                        0,
                        &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!CryptHashSessionKey(hHash,
                            pContext->RipeZombie->hMasterKey,
                            CRYPT_LITTLE_ENDIAN))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!CryptHashData(hHash,
                      rgbPad2,
                      CB_SSL3_MD5_MAC_PAD,
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!CryptHashData(hHash,
                      pbMd5Digest,
                      CB_MD5_DIGEST_LEN,
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    cbDigest = CB_MD5_DIGEST_LEN;
    if(!CryptGetHashParam(hHash,
                          HP_HASHVAL,
                          pbMd5Digest,
                          &cbDigest,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    CryptDestroyHash(hHash);
    hHash = 0;

    // Build SHA Hash

    // Make local copy of the handshake_messages SHA hash object
    if(!CryptDuplicateHash(pContext->hShaHandshake,
                           NULL,
                           0,
                           &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }

    // SHA(handshake_messages + Sender + master_secret + pad1)
    if(!CryptHashData(hHash,
                      fClient ? szClnt : szSrvr,
                      4,
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!CryptHashSessionKey(hHash,
                            pContext->RipeZombie->hMasterKey,
                            CRYPT_LITTLE_ENDIAN))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!CryptHashData(hHash,
                      rgbPad1,
                      CB_SSL3_SHA_MAC_PAD,
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    cbDigest = A_SHA_DIGEST_LEN;
    if(!CryptGetHashParam(hHash,
                          HP_HASHVAL,
                          pbSHADigest,
                          &cbDigest,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    CryptDestroyHash(hHash);
    hHash = 0;

    // SHA(master_secret + pad2 + SHA-hash);
    if(!CryptCreateHash(pContext->RipeZombie->hMasterProv,
                        CALG_SHA,
                        0,
                        0,
                        &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!CryptHashSessionKey(hHash,
                            pContext->RipeZombie->hMasterKey,
                            CRYPT_LITTLE_ENDIAN))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!CryptHashData(hHash,
                      rgbPad2,
                      CB_SSL3_SHA_MAC_PAD,
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    if(!CryptHashData(hHash,
                      pbSHADigest,
                      A_SHA_DIGEST_LEN,
                      0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    cbDigest = A_SHA_DIGEST_LEN;
    if(!CryptGetHashParam(hHash,
                          HP_HASHVAL,
                          pbSHADigest,
                          &cbDigest,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto cleanup;
    }
    CryptDestroyHash(hHash);
    hHash = 0;

    pctRet = PCT_ERR_OK;

cleanup:

    if(hHash)
    {
        CryptDestroyHash(hHash);
    }

    return pctRet;
}


/*****************************************************************************/
DWORD Ssl3CiphertextLen(
    PSPContext pContext,
    DWORD cbMessage,
    BOOL fClientIsSender)
{
    DWORD cbBlock;

    UNREFERENCED_PARAMETER(fClientIsSender);

    // Abort early if we're not encrypting.
    if(pContext->pWriteCipherInfo == NULL)
    {
        // Add record header length.
        cbMessage += sizeof(SWRAP);

        return cbMessage;
    }

    // Add MAC length.
    cbMessage += pContext->pWriteHashInfo->cbCheckSum;

    // Add padding if we're using a block cipher.
    cbBlock = pContext->pWriteCipherInfo->dwBlockSize;
    if(cbBlock > 1)
    {
        cbMessage += cbBlock - cbMessage % cbBlock;
    }

    // Add record header length.
    cbMessage += sizeof(SWRAP);

    return cbMessage;
}

//+---------------------------------------------------------------------------
//
//  Function:   Ssl3EncryptRaw
//
//  Synopsis:   Perform the MAC and encryption steps on an SSL3 record.
//
//  Arguments:  [pContext]      --  Schannel context.
//              [pAppInput]     --  Data to be encrypted.
//              [pCommOutput]   --  (output) Encrypted SSL3 record.
//              [bContentType]  --  SSL3 context type.
//
//  History:    10-22-97   jbanes   CAPI integrated.
//
//  Notes:      This function doesn't touch the header portion of the SSL3
//              record. This is handle by the calling function.
//
//----------------------------------------------------------------------------
SP_STATUS WINAPI
Ssl3EncryptRaw(
    PSPContext pContext,
    PSPBuffer  pAppInput,
    PSPBuffer  pCommOutput,
    BYTE       bContentType)
{
    SP_STATUS pctRet;
    SPBuffer Clean;
    SPBuffer Encrypted;
    DWORD cbBlock;
    DWORD cbPadding;
    PUCHAR pbMAC = NULL;
    BOOL   fIsClient = FALSE;
    DWORD  cbBuffExpected;

    if((pContext == NULL) ||
        (pContext->RipeZombie == NULL) ||
        (pContext->pWriteHashInfo == NULL) ||
        (pContext->pWriteCipherInfo == NULL) ||
        (pAppInput == NULL) ||
        (pCommOutput == NULL) ||
        (pAppInput->pvBuffer == NULL) ||
        (pCommOutput->pvBuffer == NULL))
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pAppInput->cbData > pAppInput->cbBuffer)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }
    fIsClient = ( 0 != (pContext->RipeZombie->fProtocol & SP_PROT_SSL3TLS1_CLIENTS));

    cbBuffExpected = Ssl3CiphertextLen(pContext, pAppInput->cbData, fIsClient);
    if(cbBuffExpected == 0)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pCommOutput->cbBuffer < cbBuffExpected)
    {
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }

    Clean.cbData   = pAppInput->cbData;
    Clean.pvBuffer = (PUCHAR)pCommOutput->pvBuffer + sizeof(SWRAP);
    Clean.cbBuffer = pCommOutput->cbBuffer - sizeof(SWRAP);

    /* Move data out of the way if necessary */
    if(Clean.pvBuffer != pAppInput->pvBuffer)
    {
        DebugLog((DEB_WARN, "SSL3EncryptRaw: Unnecessary Move, performance hog\n"));
        MoveMemory(Clean.pvBuffer,
                   pAppInput->pvBuffer,
                   pAppInput->cbData);
    }

    // Transfer the write key over from the application process.
    if(pContext->hWriteKey == 0 &&
       pContext->pWriteCipherInfo->aiCipher != CALG_NULLCIPHER)
    {
        DebugLog((DEB_TRACE, "Transfer write key from user process.\n"));
        pctRet = SPGetUserKeys(pContext, SCH_FLAG_WRITE_KEY);
        if(pctRet != PCT_ERR_OK)
        {
            return SP_LOG_RESULT(pctRet);
        }
    }

    // Compute MAC and add it to end of message.
    pbMAC = (PUCHAR)Clean.pvBuffer + Clean.cbData;
    if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3)
    {
        pctRet = Ssl3ComputeMac(pContext,
                                FALSE,
                                &Clean,
                                bContentType,
                                pbMAC,
                                pContext->pWriteHashInfo->cbCheckSum);
        if(pctRet != PCT_ERR_OK)
        {
            return pctRet;
        }
    }
    else
    {
        pctRet = Tls1ComputeMac(pContext,
                                FALSE,
                                &Clean,
                                bContentType,
                                pbMAC,
                                pContext->pWriteHashInfo->cbCheckSum);
        if(pctRet != PCT_ERR_OK)
        {
            return pctRet;
        }
    }
    Clean.cbData += pContext->pWriteHashInfo->cbCheckSum;

    pContext->WriteCounter++;

    // Add block cipher padding to end of message.
    cbBlock = pContext->pWriteCipherInfo->dwBlockSize;
    if(cbBlock > 1)
    {
        // This is a block cipher.
        cbPadding = cbBlock - Clean.cbData % cbBlock;

        FillMemory((PUCHAR)Clean.pvBuffer + Clean.cbData,
                   cbPadding,
                   (UCHAR)(cbPadding - 1));
        Clean.cbData += cbPadding;
    }

    SP_ASSERT(Clean.cbData <= Clean.cbBuffer);

    Encrypted.cbData   = Clean.cbData;
    Encrypted.pvBuffer = Clean.pvBuffer;
    Encrypted.cbBuffer = Clean.cbBuffer;

    // Encrypt message.
    if(pContext->pWriteCipherInfo->aiCipher != CALG_NULLCIPHER)
    {
        if(!CryptEncrypt(pContext->hWriteKey,
                         0, FALSE, 0,
                         Encrypted.pvBuffer,
                         &Encrypted.cbData,
                         Encrypted.cbBuffer))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_INT_INTERNAL_ERROR;
        }
    }

    pCommOutput->cbData = Encrypted.cbData + sizeof(SWRAP);

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   Ssl3EncryptMessage
//
//  Synopsis:   Encode a block of data as an SSL3 record.
//
//  Arguments:  [pContext]      --  Schannel context.
//              [pAppInput]     --  Data to be encrypted.
//              [pCommOutput]   --  (output) Completed SSL3 record.
//
//  History:    10-22-97   jbanes   CAPI integrated.
//
//  Notes:      An SSL3 record is formatted as:
//
//                  BYTE header[5];
//                  BYTE data[pAppInput->cbData];
//                  BYTE mac[mac_size];
//                  BYTE padding[padding_size];
//
//----------------------------------------------------------------------------
SP_STATUS WINAPI
Ssl3EncryptMessage( PSPContext pContext,
                    PSPBuffer   pAppInput,
                    PSPBuffer   pCommOutput)
{
    DWORD cbMessage;
    SP_STATUS pctRet;

    SP_BEGIN("Ssl3EncryptMessage");

    if((pContext == NULL) ||
        (pContext->RipeZombie == NULL) ||
        (pAppInput == NULL) ||
        (pCommOutput == NULL) ||
        (pCommOutput->pvBuffer == NULL))
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    DebugLog((DEB_TRACE, "Input: cbData:0x%x, cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
        pAppInput->cbData,
        pAppInput->cbBuffer,
        pAppInput->pvBuffer));

    DebugLog((DEB_TRACE, "Output: cbData:0x%x, cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
        pCommOutput->cbData,
        pCommOutput->cbBuffer,
        pCommOutput->pvBuffer));

    // Compute encrypted message size.
    cbMessage = Ssl3CiphertextLen(pContext, pAppInput->cbData, TRUE);

    pctRet = Ssl3EncryptRaw(pContext, pAppInput, pCommOutput, SSL3_CT_APPLICATIONDATA);
    if(pctRet != PCT_ERR_OK)
    {
        SP_RETURN(SP_LOG_RESULT(pctRet));
    }

    SetWrapNoEncrypt(pCommOutput->pvBuffer,
                     SSL3_CT_APPLICATIONDATA,
                     cbMessage - sizeof(SWRAP));
    if(pContext->RipeZombie->fProtocol & SP_PROT_TLS1)
    {
        ((PUCHAR)pCommOutput->pvBuffer)[02] = TLS1_CLIENT_VERSION_LSB;
    }

    DebugLog((DEB_TRACE, "Output: cbData:0x%x, cbBuffer:0x%x, pvBuffer:0x%8.8x\n",
        pCommOutput->cbData,
        pCommOutput->cbBuffer,
        pCommOutput->pvBuffer));

    SP_RETURN(PCT_ERR_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   Ssl3DecryptMessage
//
//  Synopsis:   Decode an SSL3 record.
//
//  Arguments:  [pContext]      --  Schannel context.
//              [pMessage]      --  Data from the remote party.
//              [pAppOutput]    --  (output) Decrypted data.
//
//  History:    10-22-97   jbanes   CAPI integrated.
//
//  Notes:      The number of input data bytes consumed by this function
//              is returned in pMessage->cbData.
//
//----------------------------------------------------------------------------
SP_STATUS WINAPI
Ssl3DecryptMessage( PSPContext         pContext,
                    PSPBuffer          pMessage,
                    PSPBuffer          pAppOutput)
{
    SP_STATUS pctRet;
    SPBuffer  Clean;
    SPBuffer  Encrypted;
    UCHAR     rgbDigest[SP_MAX_DIGEST_LEN];
    PUCHAR    pbMAC;
    DWORD     dwLength, cbActualData;
    SWRAP     *pswrap = pMessage->pvBuffer;
    DWORD     dwVersion;

    DWORD cbBlock;
    DWORD cbPadding;
    BOOL  fBadPadding = FALSE;

    SP_BEGIN("Ssl3DecryptMessage");

    if((pContext == NULL) ||
        (pContext->pReadCipherInfo == NULL) ||
        (pContext->RipeZombie == NULL) ||
        (pAppOutput == NULL) ||
        (pMessage == NULL) ||
        (pMessage->pvBuffer == NULL))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    /* First determine the length of data, the length of padding,
     * and the location of data, and the location of MAC */
    cbActualData = pMessage->cbData;
    pMessage->cbData = sizeof(SWRAP); /* minimum amount of data we need */

    if(cbActualData < sizeof(SWRAP))
    {
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    dwVersion = COMBINEBYTES(pswrap->bMajor, pswrap->bMinor);
    if(dwVersion != SSL3_CLIENT_VERSION && dwVersion != TLS1_CLIENT_VERSION)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }

    dwLength = COMBINEBYTES(pswrap->bcbMSBSize, pswrap->bcbLSBSize);

    Encrypted.pvBuffer = (PUCHAR)pMessage->pvBuffer + sizeof(SWRAP);
    Encrypted.cbBuffer = pMessage->cbBuffer - sizeof(SWRAP);

    pMessage->cbData += dwLength ;

    if(pMessage->cbData > cbActualData)
    {
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    Encrypted.cbData = dwLength; /* encrypted data size */

    SP_ASSERT(Encrypted.cbData != 0);

    cbBlock = pContext->pReadCipherInfo->dwBlockSize;

    if(cbBlock > 1)
    {
        /* check to see if we have a block size violation */
        if((Encrypted.cbData % cbBlock) || (Encrypted.cbData < cbBlock))
        {
            SP_RETURN(SP_LOG_RESULT(PCT_INT_MSG_ALTERED));
        }
    }

    // Transfer the read key over from the application process.
    if(pContext->hReadKey == 0 && 
       pContext->pReadCipherInfo->aiCipher != CALG_NULLCIPHER)
    {
        DebugLog((DEB_TRACE, "Transfer read key from user process.\n"));
        pctRet = SPGetUserKeys(pContext, SCH_FLAG_READ_KEY);
        if(pctRet != PCT_ERR_OK)
        {
            return SP_LOG_RESULT(pctRet);
        }
    }

    // Decrypt message.
    if(pContext->pReadCipherInfo->aiCipher != CALG_NULLCIPHER)
    {
        if(!CryptDecrypt(pContext->hReadKey,
                         0, FALSE, 0,
                         Encrypted.pvBuffer,
                         &Encrypted.cbData))
        {
            SP_LOG_RESULT(GetLastError());
            SP_RETURN(PCT_INT_INTERNAL_ERROR);
        }
    }

    // Remove block cipher padding.
    if(cbBlock > 1)
    {
        // This is a block cipher.
        cbPadding = *((PUCHAR)Encrypted.pvBuffer + Encrypted.cbData - 1) + 1;

        if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3)
        {
            if(cbPadding > cbBlock || cbPadding >= Encrypted.cbData)
            {
                // Invalid pad size.
                DebugLog((DEB_WARN, "FINISHED Message: Padding Invalid\n"));
                fBadPadding = TRUE;
            }
        }
        else
        {
            if(cbPadding > 256 || cbPadding >= Encrypted.cbData)
            {
                // Invalid pad size.
                DebugLog((DEB_WARN, "FINISHED Message: Padding Invalid\n"));
                fBadPadding = TRUE;
            }
        }
        if(!fBadPadding)
        {
            Encrypted.cbData -= cbPadding;
        }
    }

    //
    // Note that if the padding is bogus we don't error out right 
    // away. This might give an attacker some timing information with
    // which he can attack the symmetric cipher (or CBC) independently
    // of the MAC. Instead, we'll perform the MAC operation and then 
    // error out.
    //

    // Build buffer over which to MAC.
    if(Encrypted.cbData < pContext->pReadHashInfo->cbCheckSum)
    {
        fBadPadding = TRUE;

        Clean.pvBuffer = Encrypted.pvBuffer;
        Clean.cbData   = Encrypted.cbData;
        Clean.cbBuffer = Clean.cbData;
    }
    else
    {
        Clean.pvBuffer = Encrypted.pvBuffer;
        Clean.cbData   = Encrypted.cbData - pContext->pReadHashInfo->cbCheckSum;
        Clean.cbBuffer = Clean.cbData;
    }

    // Validate MAC.
    if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3)
    {
        pctRet = Ssl3ComputeMac(pContext,
                                TRUE,
                                &Clean,
                                pswrap->bCType,
                                rgbDigest,
                                sizeof(rgbDigest));
        if(pctRet != PCT_ERR_OK)
        {
            return pctRet;
        }
    }
    else
    {
        pctRet = Tls1ComputeMac(pContext,
                                TRUE,
                                &Clean,
                                pswrap->bCType,
                                rgbDigest,
                                sizeof(rgbDigest));
        if(pctRet != PCT_ERR_OK)
        {
            return pctRet;
        }
    }

    if(fBadPadding)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_MESSAGE_ALTERED));
    }

    pContext->ReadCounter++;

    pbMAC = (PUCHAR)Clean.pvBuffer + Clean.cbData;

    if(memcmp(rgbDigest, pbMAC, pContext->pReadHashInfo->cbCheckSum))
    {
        DebugLog((DEB_WARN, "FINISHED Message: Checksum Invalid\n"));
        if(pContext->RipeZombie->fProtocol & SP_PROT_TLS1)
        {
            SetTls1Alert(pContext, TLS1_ALERT_FATAL, TLS1_ALERT_BAD_RECORD_MAC);
        }
        SP_RETURN(SP_LOG_RESULT(SEC_E_MESSAGE_ALTERED));
    }

    if(pAppOutput->pvBuffer != Clean.pvBuffer)
    {
        CopyMemory(pAppOutput->pvBuffer, Clean.pvBuffer, Clean.cbData);
    }

    pAppOutput->cbData = Clean.cbData;

    SP_RETURN(PCT_ERR_OK);
}


/*****************************************************************************/
// Create an encrypted Finish message, adding it to the end of the
// specified buffer object.
//
SP_STATUS SPBuildS3FinalFinish(PSPContext pContext, PSPBuffer pBuffer, BOOL fClient)
{
    PBYTE pbMessage = (PBYTE)pBuffer->pvBuffer + pBuffer->cbData;
    DWORD cbFinished;
    SP_STATUS pctRet;
    DWORD cbDataOut;

    BYTE rgbMd5Digest[CB_MD5_DIGEST_LEN];
    BYTE rgbSHADigest[CB_SHA_DIGEST_LEN];

    // Build Finished message body.
    pctRet = Ssl3BuildFinishMessage(pContext, rgbMd5Digest, rgbSHADigest, fClient);
    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }

    CopyMemory(pbMessage + sizeof(SWRAP) + sizeof(SHSH),
               rgbMd5Digest,
               CB_MD5_DIGEST_LEN);
    CopyMemory(pbMessage + sizeof(SWRAP) + sizeof(SHSH) + CB_MD5_DIGEST_LEN,
               rgbSHADigest,
               CB_SHA_DIGEST_LEN);

    // Build Finished handshake header.
    SetHandshake(pbMessage + sizeof(SWRAP),
                 SSL3_HS_FINISHED,
                 NULL,
                 CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN);
    cbFinished = sizeof(SHSH) + CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN;

    // Update handshake hash objects.
    pctRet = UpdateHandshakeHash(pContext,
                                 pbMessage + sizeof(SWRAP),
                                 cbFinished,
                                 FALSE);
    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }

    // Add record header and encrypt message.
    pctRet = SPSetWrap(pContext,
            pbMessage,
            SSL3_CT_HANDSHAKE,
            cbFinished,
            fClient,
            &cbDataOut);

    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }

    // Update buffer length.
    pBuffer->cbData += cbDataOut;

    SP_ASSERT(pBuffer->cbData <= pBuffer->cbBuffer);

    return PCT_ERR_OK;
}

SP_STATUS
SPSetWrap(
    PSPContext pContext,
    PUCHAR pbMessage,
    UCHAR bContentType,
    DWORD cbPayload,
    BOOL fClient,
    DWORD *pcbDataOut)
{
    SWRAP *pswrap = (SWRAP *)pbMessage;
    DWORD cbMessage;
    SP_STATUS pctRet = PCT_ERR_OK;

    // Compute size of encrypted message.
    cbMessage = Ssl3CiphertextLen(pContext, cbPayload, fClient);

    if(pContext->pWriteHashInfo)
    {
        SPBuffer Clean;
        SPBuffer Encrypted;

        Clean.pvBuffer = pbMessage + sizeof(SWRAP);
        Clean.cbBuffer = cbMessage;
        Clean.cbData   = cbPayload;

        Encrypted.pvBuffer  = pbMessage;
        Encrypted.cbBuffer  = cbMessage;
        Encrypted.cbData    = cbPayload + sizeof(SWRAP);

        pctRet = Ssl3EncryptRaw(pContext, &Clean, &Encrypted, bContentType);
        cbMessage = Encrypted.cbData;
    }

    ZeroMemory(pswrap, sizeof(SWRAP));
    pswrap->bCType      = bContentType;
    pswrap->bMajor      = SSL3_CLIENT_VERSION_MSB;
    if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3)
    {
        pswrap->bMinor = (UCHAR)SSL3_CLIENT_VERSION_LSB;
    }
    else
    {
        pswrap->bMinor = (UCHAR)TLS1_CLIENT_VERSION_LSB;
    }
    pswrap->bcbMSBSize  = MSBOF(cbMessage - sizeof(SWRAP));
    pswrap->bcbLSBSize  = LSBOF(cbMessage - sizeof(SWRAP));

    if(pcbDataOut != NULL)
    {
        *pcbDataOut = cbMessage;
    }

    return(pctRet);
}

void
SetWrapNoEncrypt(
    PUCHAR pbMessage,
    UCHAR bContentType,
    DWORD cbPayload)
{
    SWRAP *pswrap = (SWRAP *)pbMessage;

    ZeroMemory(pswrap, sizeof(SWRAP));
    pswrap->bCType      = bContentType;
    pswrap->bMajor      = SSL3_CLIENT_VERSION_MSB;
    pswrap->bMinor      = SSL3_CLIENT_VERSION_LSB;
    pswrap->bcbMSBSize  = MSBOF(cbPayload);
    pswrap->bcbLSBSize  = LSBOF(cbPayload);
}


void SetHandshake(PUCHAR pb, BYTE bHandshake, PUCHAR pbData, DWORD dwSize)
{
    SHSH *pshsh = (SHSH *) pb;

    FillMemory(pshsh, sizeof(SHSH), 0);
    pshsh->typHS = bHandshake;
    pshsh->bcbMSB = MSBOF(dwSize) ;
    pshsh->bcbLSB = LSBOF(dwSize) ;
    if(NULL != pbData)
    {
        CopyMemory( pb + sizeof(SHSH) , pbData, dwSize);
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   UpdateHandshakeHash
//
//  Synopsis:
//
//  Arguments:  [pContext]      --
//              [pb]            --
//              [dwcb]          --
//              [fInit]         --
//
//  History:    10-03-97   jbanes   Added server-side CAPI integration.
//
//  Notes:
//
//----------------------------------------------------------------------------
SP_STATUS
UpdateHandshakeHash(
    PSPContext  pContext,
    PUCHAR      pb,
    DWORD       dwcb,
    BOOL        fInit)
{
    if(pContext->RipeZombie->hMasterProv == 0)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(fInit)
    {
        DebugLog((DEB_TRACE, "UpdateHandshakeHash: initializing\n"));

        if(pContext->hMd5Handshake)
        {
            CryptDestroyHash(pContext->hMd5Handshake);
            pContext->hMd5Handshake = 0;
        }
        if(!CryptCreateHash(pContext->RipeZombie->hMasterProv,
                            CALG_MD5, 0, 0,
                            &pContext->hMd5Handshake))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_INT_INTERNAL_ERROR;
        }

        if(pContext->hShaHandshake)
        {
            CryptDestroyHash(pContext->hShaHandshake);
            pContext->hShaHandshake = 0;
        }
        if(!CryptCreateHash(pContext->RipeZombie->hMasterProv,
                            CALG_SHA, 0, 0,
                            &pContext->hShaHandshake))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_INT_INTERNAL_ERROR;
        }
    }

    if(pContext->hMd5Handshake == 0 || pContext->hShaHandshake == 0)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(dwcb && NULL != pb)
    {
        DebugLog((DEB_TRACE, "UpdateHandshakeHash: %d bytes\n", dwcb));

        if(!CryptHashData(pContext->hMd5Handshake,
                          pb, dwcb, 0))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_INT_INTERNAL_ERROR;
        }
        if(!CryptHashData(pContext->hShaHandshake,
                          pb, dwcb, 0))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_INT_INTERNAL_ERROR;
        }
    }

    return PCT_ERR_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   Tls1ComputeCertVerifyHashes
//
//  Synopsis:   Compute the hashes contained by a TLS
//              CertificateVerify message.
//
//  Arguments:  [pContext]  --  Schannel context.
//              [pbHash]    --
//              [cbHash]    --
//
//  History:    10-14-97   jbanes   Created.
//
//  Notes:      The data generated by this routine is always 36 bytes in
//              length, and consists of an MD5 hash followed by an SHA
//              hash.
//
//              The hash values are computed as:
//
//                  md5_hash = MD5(handshake_messages);
//
//                  sha_hash = SHA(handshake_messages);
//
//----------------------------------------------------------------------------
SP_STATUS
Tls1ComputeCertVerifyHashes(
    PSPContext  pContext,   // in
    PBYTE       pbMD5,      // out
    PBYTE       pbSHA)      // out
{
    HCRYPTHASH hHash = 0;
    DWORD cbData;

    if((pContext == NULL) ||
       (pContext->RipeZombie == NULL))
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pbMD5 != NULL)
    {
        // md5_hash = MD5(handshake_messages);
        if(!CryptDuplicateHash(pContext->hMd5Handshake,
                               NULL,
                               0,
                               &hHash))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_INT_INTERNAL_ERROR;
        }
        cbData = CB_MD5_DIGEST_LEN;
        if(!CryptGetHashParam(hHash,
                              HP_HASHVAL,
                              pbMD5,
                              &cbData,
                              0))
        {
            SP_LOG_RESULT(GetLastError());
            CryptDestroyHash(hHash);
            return PCT_INT_INTERNAL_ERROR;
        }
        SP_ASSERT(cbData == CB_MD5_DIGEST_LEN);
        if(!CryptDestroyHash(hHash))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }

    if(pbSHA != NULL)
    {
        // sha_hash = SHA(handshake_messages);
        if(!CryptDuplicateHash(pContext->hShaHandshake,
                               NULL,
                               0,
                               &hHash))
        {
            SP_LOG_RESULT(GetLastError());
            return PCT_INT_INTERNAL_ERROR;
        }
        cbData = CB_SHA_DIGEST_LEN;
        if(!CryptGetHashParam(hHash,
                              HP_HASHVAL, pbSHA,
                              &cbData,
                              0))
        {
            SP_LOG_RESULT(GetLastError());
            CryptDestroyHash(hHash);
            return PCT_INT_INTERNAL_ERROR;
        }
        SP_ASSERT(cbData == CB_SHA_DIGEST_LEN);
        if(!CryptDestroyHash(hHash))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }

    return PCT_ERR_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   Ssl3ComputeCertVerifyHashes
//
//  Synopsis:   Compute the hashes contained by an SSL3
//              CertificateVerify message.
//
//  Arguments:  [pContext]  --  Schannel context.
//              [pbHash]    --
//              [cbHash]    --
//
//  History:    10-14-97   jbanes   Added CAPI integration.
//
//  Notes:      The data generated by this routine is always 36 bytes in
//              length, and consists of an MD5 hash followed by an SHA
//              hash.
//
//              The hash values are computed as follows:
//
//                  md5_hash = MD5(master_secret + pad2 +
//                                 MD5(handshake_messages + master_secret +
//                                     pad1));
//
//                  sha_hash = SHA(master_secret + pad2 +
//                                 SHA(handshake_messages + master_secret +
//                                     pad1));
//
//----------------------------------------------------------------------------
SP_STATUS
Ssl3ComputeCertVerifyHashes(
    PSPContext  pContext,   // in
    PBYTE       pbMD5,      // out
    PBYTE       pbSHA)      // out
{
    BYTE rgbPad1[CB_SSL3_MAX_MAC_PAD];
    BYTE rgbPad2[CB_SSL3_MAX_MAC_PAD];
    HCRYPTHASH hHash = 0;
    DWORD cbData;
    SP_STATUS pctRet;

    FillMemory(rgbPad1, sizeof(rgbPad1), PAD1_CONSTANT);
    FillMemory(rgbPad2, sizeof(rgbPad2), PAD2_CONSTANT);

    if(pbMD5 != NULL)
    {
        //
        // CertificateVerify.signature.md5_hash = MD5(master_secret + pad2 +
        //    MD5(handshake_messages + master_secret + pad1));
        //

        // Compute inner hash.
        if(!CryptDuplicateHash(pContext->hMd5Handshake,
                               NULL,
                               0,
                               &hHash))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!CryptHashSessionKey(hHash,
                                pContext->RipeZombie->hMasterKey,
                                CRYPT_LITTLE_ENDIAN))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!CryptHashData(hHash,
                          rgbPad1,
                          CB_SSL3_MD5_MAC_PAD,
                          0))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        cbData = CB_MD5_DIGEST_LEN;
        if(!CryptGetHashParam(hHash,
                              HP_HASHVAL,
                              pbMD5,
                              &cbData,
                              0))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        SP_ASSERT(cbData == CB_MD5_DIGEST_LEN);
        if(!CryptDestroyHash(hHash))
        {
            SP_LOG_RESULT(GetLastError());
        }
        hHash = 0;

        // Compute outer hash.
        if(!CryptCreateHash(pContext->RipeZombie->hMasterProv,
                            CALG_MD5,
                            0,
                            0,
                            &hHash))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!CryptHashSessionKey(hHash,
                                pContext->RipeZombie->hMasterKey,
                                CRYPT_LITTLE_ENDIAN))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!CryptHashData(hHash,
                          rgbPad2,
                          CB_SSL3_MD5_MAC_PAD,
                          0))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!CryptHashData(hHash,
                          pbMD5,
                          CB_MD5_DIGEST_LEN,
                          0))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        cbData = CB_MD5_DIGEST_LEN;
        if(!CryptGetHashParam(hHash,
                              HP_HASHVAL,
                              pbMD5,
                              &cbData,
                              0))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        SP_ASSERT(cbData == CB_MD5_DIGEST_LEN);
        if(!CryptDestroyHash(hHash))
        {
            SP_LOG_RESULT(GetLastError());
        }
        hHash = 0;
    }

    if(pbSHA != NULL)
    {
        //
        // CertificateVerify.signature.sha_hash = SHA(master_secret + pad2 +
        //    SHA(handshake_messages + master_secret + pad1));
        //

        // Compute inner hash.
        if(!CryptDuplicateHash(pContext->hShaHandshake,
                               NULL,
                               0,
                               &hHash))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!CryptHashSessionKey(hHash,
                                pContext->RipeZombie->hMasterKey,
                                CRYPT_LITTLE_ENDIAN))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!CryptHashData(hHash,
                          rgbPad1,
                          CB_SSL3_SHA_MAC_PAD,
                          0))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        cbData = CB_SHA_DIGEST_LEN;
        if(!CryptGetHashParam(hHash,
                              HP_HASHVAL, 
                              pbSHA,
                              &cbData,
                              0))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        SP_ASSERT(cbData == CB_SHA_DIGEST_LEN);
        if(!CryptDestroyHash(hHash))
        {
            SP_LOG_RESULT(GetLastError());
        }
        hHash = 0;

        // Compute outer hash.
        if(!CryptCreateHash(pContext->RipeZombie->hMasterProv,
                            CALG_SHA, 0, 0,
                            &hHash))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!CryptHashSessionKey(hHash,
                                pContext->RipeZombie->hMasterKey,
                                CRYPT_LITTLE_ENDIAN))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!CryptHashData(hHash,
                          rgbPad2,
                          CB_SSL3_SHA_MAC_PAD,
                          0))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        if(!CryptHashData(hHash,
                          pbSHA,
                          CB_SHA_DIGEST_LEN,
                          0))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        cbData = CB_SHA_DIGEST_LEN;
        if(!CryptGetHashParam(hHash,
                              HP_HASHVAL,
                              pbSHA,
                              &cbData,
                              0))
        {
            SP_LOG_RESULT(GetLastError());
            pctRet = PCT_INT_INTERNAL_ERROR;
            goto cleanup;
        }
        SP_ASSERT(cbData == CB_SHA_DIGEST_LEN);
        if(!CryptDestroyHash(hHash))
        {
            SP_LOG_RESULT(GetLastError());
        }
        hHash = 0;
    }

    pctRet = PCT_ERR_OK;

cleanup:

    if(hHash)
    {
        CryptDestroyHash(hHash);
    }

    return pctRet;
}


SP_STATUS Ssl3HandleCCS(PSPContext pContext,
                   PUCHAR pb,
                   DWORD cbMessage)
{

    SP_STATUS pctRet = PCT_ERR_OK;
    BOOL fSender =
        (0 == (pContext->RipeZombie->fProtocol & SP_PROT_SSL3TLS1_CLIENTS)) ;


    SP_BEGIN("Ssl3HandleCCS");

    if(cbMessage != 1 || pb[0] != 0x1)
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        SP_RETURN(pctRet);
    }

    // We always zero out the read counter on receipt
    // of a change cipher spec message.
    pContext->ReadCounter = 0;


    // Move pending ciphers to real ciphers
    pctRet = ContextInitCiphers(pContext, TRUE, FALSE);

    if(pctRet != PCT_ERR_OK)
    {
        SP_RETURN(pctRet);
    }

    if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3)
    {
        pctRet = Ssl3MakeReadSessionKeys(pContext);
    }
    else
    {
        pctRet = Tls1MakeReadSessionKeys(pContext);
    }
    if(pctRet != PCT_ERR_OK)
    {
        SP_RETURN(pctRet);
    }

    if(fSender)
    {
        pContext->wS3CipherSuiteClient = (WORD)UniAvailableCiphers[pContext->dwPendingCipherSuiteIndex].CipherKind;
        pContext->State = SSL3_STATE_CHANGE_CIPHER_SPEC_SERVER;
    }
    else
    {
        pContext->wS3CipherSuiteServer = (WORD)UniAvailableCiphers[pContext->dwPendingCipherSuiteIndex].CipherKind;
        pContext->State = SSL3_STATE_CHANGE_CIPHER_SPEC_CLIENT;
    }
    SP_RETURN(PCT_ERR_OK);
}


/*****************************************************************************/
// Create a (possibly encrypted) ChangeCipherSpec and an encrypted
// Finish message, adding them to the end of the specified buffer object.
//
SP_STATUS
BuildCCSAndFinishMessage(
    PSPContext pContext,
    PSPBuffer pBuffer,
    BOOL fClient)
{
    SP_STATUS pctRet;
    PBYTE pbMessage = (PBYTE)pBuffer->pvBuffer + pBuffer->cbData;
    DWORD cbDataOut;

    // Build ChangeCipherSpec message body.
    *(pbMessage + sizeof(SWRAP)) = 0x1;

    // Add record header and encrypt message.
    pctRet = SPSetWrap(pContext,
            pbMessage,
            SSL3_CT_CHANGE_CIPHER_SPEC,
            1,
            fClient,
            &cbDataOut);

    if(pctRet != PCT_ERR_OK)
        return(pctRet);

    // Update buffer length.
    pBuffer->cbData += cbDataOut;

    SP_ASSERT(pBuffer->cbData <= pBuffer->cbBuffer);

    // Update cipher suites.
    pContext->WriteCounter = 0;

    pctRet = ContextInitCiphers(pContext, FALSE, TRUE);
    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }

    if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3)
    {
        pctRet = Ssl3MakeWriteSessionKeys(pContext);
    }
    else
    {
        pctRet = Tls1MakeWriteSessionKeys(pContext);
    }
    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }

    if(fClient)
    {
        pContext->wS3CipherSuiteClient = (WORD)UniAvailableCiphers[pContext->dwPendingCipherSuiteIndex].CipherKind;
    }
    else
    {
        pContext->wS3CipherSuiteServer = (WORD)UniAvailableCiphers[pContext->dwPendingCipherSuiteIndex].CipherKind;
    }

    // Build Finish message.
    if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3)
    {
        pctRet = SPBuildS3FinalFinish(pContext, pBuffer, fClient);
    }
    else
    {
        pctRet = SPBuildTls1FinalFinish(pContext, pBuffer, fClient);
    }

    return pctRet;
}



SP_STATUS
Ssl3SelectCipher
(
    PSPContext pContext,
    WORD       wCipher
)
{
    SP_STATUS          pctRet=PCT_ERR_ILLEGAL_MESSAGE;
    DWORD               i;
    PCipherInfo         pCipherInfo = NULL;
    PHashInfo           pHashInfo = NULL;
    PKeyExchangeInfo    pExchInfo = NULL;

    pContext->dwPendingCipherSuiteIndex = 0;

    for(i = 0; i < UniNumCiphers; i++)
    {
        // Is this an SSL3 cipher suite?
        if(!(UniAvailableCiphers[i].fProt & pContext->RipeZombie->fProtocol))
        {
            continue;
        }

        // Is this the right cipher suite?
        if(UniAvailableCiphers[i].CipherKind != wCipher)
        {
            continue;
        }

        pCipherInfo = GetCipherInfo(UniAvailableCiphers[i].aiCipher, UniAvailableCiphers[i].dwStrength);
        pHashInfo = GetHashInfo(UniAvailableCiphers[i].aiHash);
        pExchInfo = GetKeyExchangeInfo(UniAvailableCiphers[i].KeyExch);

        if(!IsCipherAllowed(pContext,
                            pCipherInfo,
                            pContext->RipeZombie->fProtocol,
                            pContext->RipeZombie->dwCF))
        {
            continue;
        }
        if(!IsHashAllowed(pContext, pHashInfo, pContext->RipeZombie->fProtocol))
        {
            continue;
        }
        if(!IsExchAllowed(pContext, pExchInfo, pContext->RipeZombie->fProtocol))
        {
            continue;
        }


        if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3TLS1_SERVERS)
        {
            // Determine the credentials (and CSP) to use, based on the
            // key exchange algorithm.
            pctRet = SPPickClientCertificate(pContext,
                                             UniAvailableCiphers[i].KeyExch);

            if(pctRet != PCT_ERR_OK)
            {
                continue;
            }
        }

        pContext->RipeZombie->dwCipherSuiteIndex = i;
        pContext->RipeZombie->aiCipher  = UniAvailableCiphers[i].aiCipher;
        pContext->RipeZombie->dwStrength  = UniAvailableCiphers[i].dwStrength;
        pContext->RipeZombie->aiHash  = UniAvailableCiphers[i].aiHash;
        pContext->RipeZombie->SessExchSpec  = UniAvailableCiphers[i].KeyExch;

        return ContextInitCiphersFromCache(pContext);
    }

    return(SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE));
}

// Server side cipher selection

SP_STATUS
Ssl3SelectCipherEx(
    PSPContext pContext,
    DWORD *pCipherSpecs,
    DWORD cCipherSpecs)
{
    DWORD i, j;
    SP_STATUS pctRet;
    PCipherInfo         pCipherInfo = NULL;
    PHashInfo           pHashInfo = NULL;
    PKeyExchangeInfo    pExchInfo = NULL;
    PSPCredential       pCred = NULL;
    BOOL                fFound;

    pContext->dwPendingCipherSuiteIndex = 0;

    // Loop through the supported SSL3 cipher suites.
    for(i = 0; i < UniNumCiphers; i++)
    {
        // Is this an SSL3 cipher suite?
        if(!(UniAvailableCiphers[i].fProt & pContext->RipeZombie->fProtocol))
        {
            continue;
        }

        pCipherInfo = GetCipherInfo(UniAvailableCiphers[i].aiCipher,
                                    UniAvailableCiphers[i].dwStrength);
        pHashInfo = GetHashInfo(UniAvailableCiphers[i].aiHash);
        pExchInfo = GetKeyExchangeInfo(UniAvailableCiphers[i].KeyExch);

        // Do we currently support this hash and key exchange algorithm?
        if(!IsHashAllowed(pContext, pHashInfo, pContext->RipeZombie->fProtocol))
        {
            DebugLog((DEB_TRACE, "Cipher %d - hash not supported\n", i));
            continue;
        }
        if(!IsExchAllowed(pContext, pExchInfo, pContext->RipeZombie->fProtocol))
        {
            DebugLog((DEB_TRACE, "Cipher %d - exch not supported\n", i));
            continue;
        }

        // Do we have an appropriate certificate?
        if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3TLS1_SERVERS)
        {
            pctRet = SPPickServerCertificate(pContext,
                                             UniAvailableCiphers[i].KeyExch);

            if(pctRet != PCT_ERR_OK)
            {
                DebugLog((DEB_TRACE, "Cipher %d - certificate %d not found\n",
                    i, UniAvailableCiphers[i].KeyExch));
                continue;
            }
        }
        pCred = pContext->RipeZombie->pActiveServerCred;


        // Do we support this encryption algorithm/key length?
        if(!IsCipherSuiteAllowed(pContext,
                            pCipherInfo,
                            pContext->RipeZombie->fProtocol,
                            pCred->dwCertFlags,
                            UniAvailableCiphers[i].dwFlags))
        {
            DebugLog((DEB_TRACE, "Cipher %d - cipher not supported\n", i));
            continue;
        }

        // Is this cipher suite supported by the client?
        for(fFound = FALSE, j = 0; j < cCipherSpecs; j++)
        {
            if(UniAvailableCiphers[i].CipherKind == pCipherSpecs[j])
            {
                fFound = TRUE;
                break;
            }
        }
        if(!fFound)
        {
            DebugLog((DEB_TRACE, "Cipher %d - not supported by client\n", i));
            continue;
        }


        if(UniAvailableCiphers[i].KeyExch == SP_EXCH_RSA_PKCS1)
        {
            // This is an RSA cipher suite, so make sure that the
            // CSP supports it.
            if(!IsAlgSupportedCapi(pContext->RipeZombie->fProtocol,
                                   UniAvailableCiphers + i,
                                   pCred->pCapiAlgs,
                                   pCred->cCapiAlgs))
            {
                DebugLog((DEB_TRACE, "Cipher %d - not supported by csp\n", i));
                continue;
            }
        }


        if(UniAvailableCiphers[i].KeyExch == SP_EXCH_DH_PKCS3)
        {
            // This is a DH cipher suite, so make sure that the
            // CSP supports it.
            if(!IsAlgSupportedCapi(pContext->RipeZombie->fProtocol,
                                   UniAvailableCiphers + i,
                                   pCred->pCapiAlgs,
                                   pCred->cCapiAlgs))
            {
                DebugLog((DEB_TRACE, "Cipher %d - not supported by csp\n", i));
                continue;
            }
        }


        // Use this cipher.
        pContext->RipeZombie->dwCipherSuiteIndex = i;
        pContext->RipeZombie->aiCipher      = UniAvailableCiphers[i].aiCipher;
        pContext->RipeZombie->dwStrength    = UniAvailableCiphers[i].dwStrength;
        pContext->RipeZombie->aiHash        = UniAvailableCiphers[i].aiHash;
        pContext->RipeZombie->SessExchSpec  = UniAvailableCiphers[i].KeyExch;
        pContext->RipeZombie->dwCF          = pCred->dwCertFlags;

        return ContextInitCiphersFromCache(pContext);
    }

    LogCipherMismatchEvent();

    return SP_LOG_RESULT(PCT_ERR_SPECS_MISMATCH);
}


/*****************************************************************************/
VOID ComputeServerExchangeHashes(
    PSPContext pContext,
    PBYTE pbServerParams,      // in
    INT   iServerParamsLen,    // in
    PBYTE pbMd5HashVal,        // out
    PBYTE pbShaHashVal)        // out
{
    MD5_CTX Md5Hash;
    A_SHA_CTX ShaHash;

    //
    // md5_hash = MD5(ClientHello.random + ServerHello.random + ServerParams);
    //
    // sha_hash = SHA(ClientHello.random + ServerHello.random + ServerParams);
    //

    MD5Init(&Md5Hash);
    MD5Update(&Md5Hash, pContext->rgbS3CRandom, 32);
    MD5Update(&Md5Hash, pContext->rgbS3SRandom, 32);
    MD5Update(&Md5Hash, pbServerParams, iServerParamsLen);
    MD5Final(&Md5Hash);
    CopyMemory(pbMd5HashVal, Md5Hash.digest, 16);

    A_SHAInit(&ShaHash);
    A_SHAUpdate(&ShaHash, pContext->rgbS3CRandom, 32);
    A_SHAUpdate(&ShaHash, pContext->rgbS3SRandom, 32);
    A_SHAUpdate(&ShaHash, pbServerParams, iServerParamsLen);
    A_SHAFinal(&ShaHash, pbShaHashVal);
}

SP_STATUS
UnwrapSsl3Message(
    PSPContext pContext,
    PSPBuffer pMsgInput)
{
    SPBuffer   Encrypted;
    SPBuffer   Clean;
    SP_STATUS pctRet;
    SWRAP *pswrap = (SWRAP *)pMsgInput->pvBuffer;
    PBYTE pbMsg = (PBYTE)pMsgInput->pvBuffer;

    //
    // Validate 5 byte header.
    //

    // ProtocolVersion version;
    if(COMBINEBYTES(pbMsg[1], pbMsg[2])  < SSL3_CLIENT_VERSION)
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    if(COMBINEBYTES(pswrap->bcbMSBSize, pswrap->bcbLSBSize) <
                        pContext->pReadHashInfo->cbCheckSum)
    {
        return(PCT_ERR_ILLEGAL_MESSAGE);
    }

    Encrypted.pvBuffer = pMsgInput->pvBuffer;
    Encrypted.cbBuffer = pMsgInput->cbBuffer;
    Encrypted.cbData = pMsgInput->cbData;
    Clean.pvBuffer = (PUCHAR)pMsgInput->pvBuffer + sizeof(SWRAP);
    pctRet = Ssl3DecryptMessage(pContext, &Encrypted, &Clean);
    if(pctRet == PCT_ERR_OK)
    {
        pswrap->bcbMSBSize = MSBOF(Clean.cbData);
        pswrap->bcbLSBSize = LSBOF(Clean.cbData);
    }
    return(pctRet);
}
      

SP_STATUS
ParseAlertMessage(
    PSPContext pContext,
    PUCHAR pbAlertMsg,
    DWORD cbMessage
    )
{
    SP_STATUS   pctRet=PCT_ERR_OK;
    if(cbMessage != 2)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    if(pbAlertMsg[0] != SSL3_ALERT_WARNING  &&  pbAlertMsg[0] != SSL3_ALERT_FATAL)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    DebugLog((DEB_WARN, "AlertMessage, Alert Level -  %lx\n", (DWORD)pbAlertMsg[0]));
    DebugLog((DEB_WARN, "AlertMessage, Alert Description -  %lx\n", (DWORD)pbAlertMsg[1]));

    if(pbAlertMsg[0] == SSL3_ALERT_WARNING)
    {
        switch(pbAlertMsg[1])
        {
        case SSL3_ALERT_NO_CERTIFICATE:
            DebugLog((DEB_TRACE, "no_certificate alert\n"));
            pContext->State = SSL3_STATE_NO_CERT_ALERT;
            pctRet = PCT_ERR_OK;
            break;

        case SSL3_ALERT_CLOSE_NOTIFY:
            DebugLog((DEB_TRACE, "close_notify alert\n"));
            pctRet = SEC_I_CONTEXT_EXPIRED;
            break;

        default:
            DebugLog((DEB_TRACE, "Ignoring warning alert\n"));
            pctRet = PCT_ERR_OK;
            break;
        }
    }
    else
    {
        switch(pbAlertMsg[1])
        {
        case SSL3_ALERT_UNEXPECTED_MESSAGE:
            DebugLog((DEB_TRACE, "unexpected_message alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_ILLEGAL_MESSAGE);
            break;

        case TLS1_ALERT_BAD_RECORD_MAC:
            DebugLog((DEB_TRACE, "bad_record_mac alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_MESSAGE_ALTERED);
            break;

        case TLS1_ALERT_DECRYPTION_FAILED:
            DebugLog((DEB_TRACE, "decryption_failed alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_DECRYPT_FAILURE);
            break;

        case TLS1_ALERT_RECORD_OVERFLOW:
            DebugLog((DEB_TRACE, "record_overflow alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_ILLEGAL_MESSAGE);
            break;

        case SSL3_ALERT_DECOMPRESSION_FAIL:
            DebugLog((DEB_TRACE, "decompression_fail alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_MESSAGE_ALTERED);
            break;

        case SSL3_ALERT_HANDSHAKE_FAILURE:
            DebugLog((DEB_TRACE, "handshake_failure alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_ILLEGAL_MESSAGE);
            break;

        case TLS1_ALERT_BAD_CERTIFICATE:
            DebugLog((DEB_TRACE, "bad_certificate alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_CERT_UNKNOWN);
            break;

        case TLS1_ALERT_UNSUPPORTED_CERT:
            DebugLog((DEB_TRACE, "unsupported_cert alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_CERT_UNKNOWN);
            break;

        case TLS1_ALERT_CERTIFICATE_REVOKED:
            DebugLog((DEB_TRACE, "certificate_revoked alert\n"));
            pctRet = SP_LOG_RESULT(CRYPT_E_REVOKED);
            break;

        case TLS1_ALERT_CERTIFICATE_EXPIRED:
            DebugLog((DEB_TRACE, "certificate_expired alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_CERT_EXPIRED);
            break;

        case TLS1_ALERT_CERTIFICATE_UNKNOWN:
            DebugLog((DEB_TRACE, "certificate_unknown alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_CERT_UNKNOWN);
            break;

        case SSL3_ALERT_ILLEGAL_PARAMETER:
            DebugLog((DEB_TRACE, "illegal_parameter alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_ILLEGAL_MESSAGE);
            break;

        case TLS1_ALERT_UNKNOWN_CA:
            DebugLog((DEB_TRACE, "unknown_ca alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_UNTRUSTED_ROOT);
            break;

        case TLS1_ALERT_ACCESS_DENIED:
            DebugLog((DEB_TRACE, "access_denied alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_LOGON_DENIED);
            break;

        case TLS1_ALERT_DECODE_ERROR:
            DebugLog((DEB_TRACE, "decode_error alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_ILLEGAL_MESSAGE);
            break;

        case TLS1_ALERT_DECRYPT_ERROR:
            DebugLog((DEB_TRACE, "decrypt_error alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_DECRYPT_FAILURE);
            break;

        case TLS1_ALERT_EXPORT_RESTRICTION:
            DebugLog((DEB_TRACE, "export_restriction alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_ILLEGAL_MESSAGE);
            break;

        case TLS1_ALERT_PROTOCOL_VERSION:
            DebugLog((DEB_TRACE, "protocol_version alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_UNSUPPORTED_FUNCTION);
            break;

        case TLS1_ALERT_INSUFFIENT_SECURITY:
            DebugLog((DEB_TRACE, "insuffient_security alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_ALGORITHM_MISMATCH);
            break;

        case TLS1_ALERT_INTERNAL_ERROR:
            DebugLog((DEB_TRACE, "internal_error alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_INTERNAL_ERROR);
            break;

        default:
            DebugLog((DEB_TRACE, "Unknown fatal alert\n"));
            pctRet = SP_LOG_RESULT(SEC_E_ILLEGAL_MESSAGE);
            break;
        }
    }

    return pctRet;
}


void BuildAlertMessage(PBYTE pbAlertMsg, UCHAR bAlertLevel, UCHAR bAlertDesc)
{
    ALRT *palrt = (ALRT *) pbAlertMsg;

    FillMemory(palrt, sizeof(ALRT), 0);

    palrt->bCType = SSL3_CT_ALERT;
    palrt->bMajor = SSL3_CLIENT_VERSION_MSB;
//  palrt->bMinor = SSL3_CLIENT_VERSION_LSB; DONE by FillMemory
//  palrt->bcbMSBSize = 0; Done by FillMemory
    palrt->bcbLSBSize = 2;
    palrt->bAlertLevel = bAlertLevel;
    palrt->bAlertDesc  = bAlertDesc ;
}


/*****************************************************************************/
// Create an encrypted Finish message, adding it to the end of the
// specified buffer object.
//
SP_STATUS SPBuildTls1FinalFinish(PSPContext pContext, PSPBuffer pBuffer, BOOL fClient)
{
    PBYTE pbMessage = (PBYTE)pBuffer->pvBuffer + pBuffer->cbData;
    DWORD cbFinished;
    SP_STATUS pctRet;
    DWORD cbDataOut;

    BYTE  rgbDigest[CB_TLS1_VERIFYDATA];

    // Build Finished message body.
    pctRet = Tls1BuildFinishMessage(pContext, rgbDigest, sizeof(rgbDigest), fClient);
    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }

    CopyMemory(pbMessage + sizeof(SWRAP) + sizeof(SHSH),
               rgbDigest,
               CB_TLS1_VERIFYDATA);

    // Build Finished handshake header.
    SetHandshake(pbMessage + sizeof(SWRAP),
                 SSL3_HS_FINISHED,
                 NULL,
                 CB_TLS1_VERIFYDATA);
    cbFinished = sizeof(SHSH) + CB_TLS1_VERIFYDATA;

    // Update handshake hash objects.
    pctRet = UpdateHandshakeHash(pContext,
                                 pbMessage + sizeof(SWRAP),
                                 cbFinished,
                                 FALSE);
    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }

    // Add record header and encrypt message.
    pctRet = SPSetWrap(pContext,
            pbMessage,
            SSL3_CT_HANDSHAKE,
            cbFinished,
            fClient,
            &cbDataOut);

    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }

    // Update buffer length .
    pBuffer->cbData += cbDataOut;

    SP_ASSERT(pBuffer->cbData <= pBuffer->cbBuffer);

    return pctRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   Tls1BuildFinishMessage
//
//  Synopsis:   Compute a TLS MAC for the specified message.
//
//  Arguments:  [pContext]      --  Schannel context.
//              [pbVerifyData]  --  Verify data buffer.
//              [cbVerifyData]  --  Length of verify data buffer.
//              [fClient]       --  Client-generated Finished?
//
//  History:    10-13-97   jbanes   Created.
//
//  Notes:      The Finished message is computed using the following formula:
//
//              verify_data = PRF(master_secret, finished_label,
//                                MD5(handshake_messages) +
//                                SHA-1(handshake_messages)) [0..11];
//
//----------------------------------------------------------------------------
SP_STATUS
Tls1BuildFinishMessage(
    PSPContext  pContext,       // in
    PBYTE       pbVerifyData,   // out
    DWORD       cbVerifyData,   // in
    BOOL        fClient)        // in
{
    PBYTE pbLabel;
    DWORD cbLabel;
    UCHAR rgbData[CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN];
    DWORD cbData;
    HCRYPTHASH hHash = 0;
    CRYPT_DATA_BLOB Data;
    SP_STATUS pctRet;

    if(cbVerifyData < CB_TLS1_VERIFYDATA)
    {
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }

    if(fClient)
    {
        pbLabel = (PBYTE)TLS1_LABEL_CLIENTFINISHED;
    }
    else
    {
        pbLabel = (PBYTE)TLS1_LABEL_SERVERFINISHED;
    }
    cbLabel = CB_TLS1_LABEL_FINISHED;


    // Get the MD5 hash of the handshake messages so far.
    if(!CryptDuplicateHash(pContext->hMd5Handshake,
                           NULL,
                           0,
                           &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto error;
    }

    cbData = CB_MD5_DIGEST_LEN;
    if(!CryptGetHashParam(hHash,
                          HP_HASHVAL,
                          rgbData,
                          &cbData,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto error;
    }

    if(!CryptDestroyHash(hHash))
    {
        SP_LOG_RESULT(GetLastError());
    }
    hHash = 0;

    // Get the SHA hash of the handshake messages so far.
    if(!CryptDuplicateHash(pContext->hShaHandshake,
                           NULL,
                           0,
                           &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto error;
    }

    cbData = A_SHA_DIGEST_LEN;
    if(!CryptGetHashParam(hHash,
                          HP_HASHVAL,
                          rgbData + CB_MD5_DIGEST_LEN,
                          &cbData,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto error;
    }

    cbData = CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN;

    if(!CryptDestroyHash(hHash))
    {
        SP_LOG_RESULT(GetLastError());
    }
    hHash = 0;

    // Compute the PRF
    if(!CryptCreateHash(pContext->RipeZombie->hMasterProv,
                        CALG_TLS1PRF,
                        pContext->RipeZombie->hMasterKey,
                        0,
                        &hHash))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto error;
    }

    Data.pbData = pbLabel;
    Data.cbData = cbLabel;
    if(!CryptSetHashParam(hHash,
                          HP_TLS1PRF_LABEL,
                          (PBYTE)&Data,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto error;
    }

    Data.pbData = rgbData;
    Data.cbData = cbData;
    if(!CryptSetHashParam(hHash,
                          HP_TLS1PRF_SEED,
                          (PBYTE)&Data,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto error;
    }

    if(!CryptGetHashParam(hHash,
                          HP_HASHVAL,
                          pbVerifyData,
                          &cbVerifyData,
                          0))
    {
        SP_LOG_RESULT(GetLastError());
        pctRet = PCT_INT_INTERNAL_ERROR;
        goto error;
    }

    pctRet = PCT_ERR_OK;


error:

    if(hHash)
    {
        if(!CryptDestroyHash(hHash))
        {
            SP_LOG_RESULT(GetLastError());
        }
    }

    return pctRet;
}

SP_STATUS
SPBuildTlsAlertMessage(
    PSPContext  pContext,       // in
    PSPBuffer pCommOutput)
{
    PBYTE pbMessage = NULL;
    DWORD cbMessage;
    BOOL  fAllocated = FALSE;
    SP_STATUS pctRet;
    DWORD cbDataOut;

    SP_BEGIN("SPBuildTlsAlertMessage");

    cbMessage =  sizeof(SWRAP) +
                         CB_SSL3_ALERT_ONLY +
                         SP_MAX_DIGEST_LEN +
                         SP_MAX_BLOCKCIPHER_SIZE;

    if(pContext->State != TLS1_STATE_ERROR)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    if(pCommOutput->pvBuffer)
    {
        // Application has allocated memory.
        if(pCommOutput->cbBuffer < cbMessage)
        {
            pCommOutput->cbData = cbMessage;
            return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        }
        fAllocated = TRUE;
    }
    else
    {
        // Schannel is to allocate memory.
        pCommOutput->cbBuffer = cbMessage;
        pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
        if(pCommOutput->pvBuffer == NULL)
        {
            SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }
    }
    pCommOutput->cbData = 0;


    pbMessage = (PBYTE)pCommOutput->pvBuffer;


     // Build alert message.
    BuildAlertMessage(pbMessage,
                      pContext->bAlertLevel,
                      pContext->bAlertNumber);

#if DBG
    DBG_HEX_STRING(DEB_TRACE, pbMessage, sizeof(ALRT));
#endif

    // Build record header and encrypt message.
    pctRet = SPSetWrap(pContext,
                pbMessage,
                SSL3_CT_ALERT,
                CB_SSL3_ALERT_ONLY,
                pContext->dwProtocol & SP_PROT_SSL3TLS1_CLIENTS,
                &cbDataOut);

    if(pctRet !=  PCT_ERR_OK)
    {
        if(!fAllocated)
        {
            SPExternalFree(pCommOutput->pvBuffer);
            pCommOutput->pvBuffer = NULL;
        }
        SP_RETURN(SP_LOG_RESULT(pctRet));
    }

    // Update buffer length.
    pCommOutput->cbData = cbDataOut;

    SP_ASSERT(pCommOutput->cbData <= pCommOutput->cbBuffer);

    SP_RETURN(PCT_ERR_OK);
}


void
SetTls1Alert(
    PSPContext  pContext,
    BYTE        bAlertLevel,
    BYTE        bAlertNumber)
{
    pContext->State        = TLS1_STATE_ERROR;
    pContext->bAlertLevel  = bAlertLevel;
    pContext->bAlertNumber = bAlertNumber;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\utest\sslcache\sslcache.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <windows.h> 
#include <wincrypt.h>

#define SECURITY_WIN32
#include <security.h>
#include <sspi.h>
#include <ntsecapi.h>
#include <ntrtl.h>
#include <schannel.h>
#include <sslcache.h>

#define LIST_CACHE_ENTRIES          1
#define LIST_ENTRIES_INTERACTIVE    2
#define PURGE_CACHE_ENTRIES         3

DWORD dwOperation           = LIST_CACHE_ENTRIES;
BOOL  fIncludeClient        = FALSE;
BOOL  fIncludeServer        = FALSE;
BOOL  fIncludeMappedEntries = FALSE;
LPSTR pszServerName         = NULL;

void
DisplayCacheInfo(
    HANDLE LsaHandle,
    DWORD PackageNumber,
    BOOL fClient, 
    BOOL fServer);

void
PurgeCacheEntries(
    HANDLE LsaHandle,
    DWORD PackageNumber);

void
DisplayCacheInfoInteractive(
    HANDLE LsaHandle,
    DWORD PackageNumber);

void Usage(void)
{
    printf("USAGE: sslcache [ operation ] [ flags ]\n");
    printf("\n");
    printf("    OPERATIONS:\n");
    printf("        -l      List cache entries (default)\n");
    printf("        -i      List cache entries interactively\n");
    printf("        -p      Purge cache entries\n");
    printf("\n");
    printf("    FLAGS:\n");
    printf("        -c      Include client entries (default)\n");
    printf("        -s      Include server entries\n");
    printf("        -S      Include IIS mapped server entries (purge only)\n");
}

void _cdecl main(int argc, char *argv[])
{
    DWORD Status;
    HANDLE LsaHandle;
    DWORD PackageNumber;
    LSA_STRING PackageName;
    BOOLEAN Trusted = TRUE;
    BOOLEAN WasEnabled;
    STRING Name;
    ULONG Dummy;

    INT i;
    INT iOption;
    PCHAR pszOption;

    //
    // Parse user-supplied parameters.
    //

    for(i = 1; i < argc; i++) 
    {
        if(argv[i][0] == '/') argv[i][0] = '-';

        if(argv[i][0] != '-') 
        {
            printf("**** Invalid argument \"%s\"\n", argv[i]);
            Usage();
            return;
        }

        iOption = argv[i][1];
        pszOption = &argv[i][2];

        switch(iOption) 
        {
        case 'l':
            dwOperation = LIST_CACHE_ENTRIES;
            break;

        case 'i':
            dwOperation = LIST_ENTRIES_INTERACTIVE;
            break;

        case 'p':
            dwOperation = PURGE_CACHE_ENTRIES;
            break;

        case 'c':
            fIncludeClient = TRUE;
            break;

        case 's':
            if(*pszOption == '\0')
            {
                fIncludeServer = TRUE;
            }
            else
            {
                pszServerName  = pszOption;
                fIncludeClient = TRUE;
            }
            break;

        case 'S':
            fIncludeMappedEntries = TRUE;
            fIncludeServer = TRUE;
            break;

        default:
            printf("**** Invalid option \"%s\"\n", argv[i]);
            Usage();
            return;
        }
    }


    //
    // If neither client nor server was specified by user set appropriate default.
    //

    if(!fIncludeClient && !fIncludeServer)
    {
        if(dwOperation == PURGE_CACHE_ENTRIES)
        {
            fIncludeClient = TRUE;
        }
        else
        {
            fIncludeClient = TRUE;
            fIncludeServer = TRUE;
        }
    }


    //
    // Get handle to schannel security package.
    //

    Status = RtlAdjustPrivilege(SE_TCB_PRIVILEGE, TRUE, FALSE, &WasEnabled);
    if (!NT_SUCCESS(Status))
    {
        Trusted = FALSE;
    }
    RtlInitString(
        &Name,
        "sslcache");

    if(Trusted)
    {
        Status = LsaRegisterLogonProcess(
                    &Name,
                    &LsaHandle,
                    &Dummy);

        if(FAILED(Status))
        {
            printf("**** Error 0x%x returned by LsaRegisterLogonProcess\n", Status);
            return;
        }
    }
    else
    {
        Status = LsaConnectUntrusted(&LsaHandle);

        if(FAILED(Status))
        {
            printf("**** Error 0x%x returned by LsaConnectUntrusted\n", Status);
            return;
        }
    }

    PackageName.Buffer          = UNISP_NAME_A;
    PackageName.Length          = (USHORT)strlen(PackageName.Buffer);
    PackageName.MaximumLength   = PackageName.Length + 1;

    Status = LsaLookupAuthenticationPackage(
                    LsaHandle,
                    &PackageName,
                    &PackageNumber);
    if(FAILED(Status))
    {
        printf("**** Error 0x%x returned by LsaLookupAuthenticationPackage\n", Status);
        CloseHandle(LsaHandle);
        return;
    }


    // 
    // Perform specified operation.
    //

    if(dwOperation == LIST_CACHE_ENTRIES)
    {
        printf("\nDISPLAY CACHE ENTRIES\n");
        printf("\n");

        if(fIncludeClient)
        {
            printf("--CLIENT--\n");
            DisplayCacheInfo(LsaHandle, PackageNumber, TRUE, FALSE);
        }

        if(fIncludeServer)
        {
            printf("--SERVER--\n");
            DisplayCacheInfo(LsaHandle, PackageNumber, FALSE, TRUE);
        }

        if(fIncludeClient && fIncludeServer)
        {
            printf("--TOTAL--\n");
            DisplayCacheInfo(LsaHandle, PackageNumber, TRUE, TRUE);
        }
    }
    else if(dwOperation == LIST_ENTRIES_INTERACTIVE)
    {
        DisplayCacheInfoInteractive(LsaHandle, PackageNumber);
    }
    else
    {
        PurgeCacheEntries(LsaHandle, PackageNumber);
    }


    CloseHandle(LsaHandle);
}


void
PurgeCacheEntries(
    HANDLE LsaHandle,
    DWORD PackageNumber)
{
    PSSL_PURGE_SESSION_CACHE_REQUEST pRequest;
    DWORD cchServerName;
    DWORD cbServerName;
    DWORD SubStatus;
    DWORD Status;

    printf("\nPURGE CACHE ENTRIES\n");
    printf("Client:%s\n", fIncludeClient ? "yes" : "no");
    printf("Server:%s\n", fIncludeServer ? "yes" : "no");

    if(pszServerName == NULL)
    {
        cbServerName = 0;

        pRequest = (PSSL_PURGE_SESSION_CACHE_REQUEST)LocalAlloc(LPTR, sizeof(SSL_PURGE_SESSION_CACHE_REQUEST));
        if(pRequest == NULL)
        {
            printf("**** Out of memory\n");
            return;
        }
    }
    else
    {
        cchServerName = MultiByteToWideChar(CP_ACP, 0, pszServerName, -1, NULL, 0);
        cbServerName  = (cchServerName + 1) * sizeof(WCHAR);

        pRequest = LocalAlloc(LPTR, sizeof(SSL_PURGE_SESSION_CACHE_REQUEST) + cbServerName);
        if(pRequest == NULL)
        {
            printf("**** Out of memory\n");
            return;
        }

        cchServerName = MultiByteToWideChar(CP_ACP, 0, pszServerName, -1, (LPWSTR)(pRequest + 1), cchServerName);
        if(cchServerName == 0)
        {
            printf("**** Error converting server name\n");
            return;
        }


        pRequest->ServerName.Buffer        = (LPWSTR)(pRequest + 1);
        pRequest->ServerName.Length        = (WORD)(cchServerName * sizeof(WCHAR));
        pRequest->ServerName.MaximumLength = (WORD)cbServerName;
    }

    pRequest->MessageType = SslPurgeSessionCacheMessage;

    if(fIncludeClient)
    {
        pRequest->Flags |= SSL_PURGE_CLIENT_ENTRIES;
    }
    if(fIncludeServer)
    {
        pRequest->Flags |= SSL_PURGE_SERVER_ENTRIES | SSL_PURGE_SERVER_ALL_ENTRIES;
    }
    if(fIncludeMappedEntries)
    {
        pRequest->Flags |= SSL_PURGE_SERVER_ENTRIES_DISCARD_LOCATORS;
    }


    Status = LsaCallAuthenticationPackage(
                    LsaHandle,
                    PackageNumber,
                    pRequest,
                    sizeof(SSL_PURGE_SESSION_CACHE_REQUEST) + cbServerName,
                    NULL,
                    NULL,
                    &SubStatus);
    if(FAILED(Status))
    {
        printf("**** Error 0x%x returned by LsaCallAuthenticationPackage\n", Status);
        return;
    }

    if(FAILED(SubStatus))
    {
        if(SubStatus == 0xC0000061)
        {
            printf("**** The TCB privilege is required to perform this operation.\n");
        }
        else
        {
            printf("**** Error 0x%x occurred while purging cache entries.\n", SubStatus);
        }
    }
}


void
DisplayCacheInfo(
    HANDLE LsaHandle,
    DWORD PackageNumber,
    BOOL fClient, 
    BOOL fServer)
{
    PSSL_SESSION_CACHE_INFO_REQUEST pRequest = NULL;
    PSSL_SESSION_CACHE_INFO_RESPONSE pResponse = NULL;
    DWORD cbResponse = 0;
    DWORD SubStatus;
    DWORD Status;

    pRequest = (PSSL_SESSION_CACHE_INFO_REQUEST)LocalAlloc(LPTR, sizeof(SSL_SESSION_CACHE_INFO_REQUEST));
    if(pRequest == NULL)
    {
        printf("**** Out of memory\n");
        goto cleanup;
    }

    pRequest->MessageType = SslSessionCacheInfoMessage;

    if(fClient)
    {
        pRequest->Flags |= SSL_RETRIEVE_CLIENT_ENTRIES;
    }
    if(fServer)
    {
        pRequest->Flags |= SSL_RETRIEVE_SERVER_ENTRIES;
    }


    Status = LsaCallAuthenticationPackage(
                    LsaHandle,
                    PackageNumber,
                    pRequest,
                    sizeof(SSL_SESSION_CACHE_INFO_REQUEST),
                    &pResponse,
                    &cbResponse,
                    &SubStatus);
    if(FAILED(Status))
    {
        printf("**** Error 0x%x returned by LsaCallAuthenticationPackage\n", Status);
        goto cleanup;
    }

    if(FAILED(SubStatus))
    {
        printf("**** Error 0x%x occurred while reading cache entries.\n", SubStatus);
    }

    printf("CacheSize:      %d    \n", pResponse->CacheSize);
    printf("Entries:        %d    \n", pResponse->Entries);
    printf("ActiveEntries:  %d    \n", pResponse->ActiveEntries);
    printf("Zombies:        %d    \n", pResponse->Zombies);
    printf("ExpiredZombies: %d    \n", pResponse->ExpiredZombies);
    printf("AbortedZombies: %d    \n", pResponse->AbortedZombies);
    printf("DeletedZombies: %d    \n", pResponse->DeletedZombies);
    printf("\n");

cleanup:

    if(pRequest)
    {
        LocalFree(pRequest);
    }

    if (pResponse != NULL)
    {
        LsaFreeReturnBuffer(pResponse);
    }
}

void cls(HANDLE hConsole)
{
    COORD coordScreen = { 0, 0 };    /* here's where we'll home the
                                        cursor */
    BOOL bSuccess;
    DWORD cCharsWritten;
    CONSOLE_SCREEN_BUFFER_INFO csbi; /* to get buffer info */
    DWORD dwConSize;                 /* number of character cells in
                                        the current buffer */

    /* get the number of character cells in the current buffer */

    bSuccess = GetConsoleScreenBufferInfo( hConsole, &csbi );
    dwConSize = csbi.dwSize.X * csbi.dwSize.Y;

    /* fill the entire screen with blanks */

    bSuccess = FillConsoleOutputCharacter( hConsole, (TCHAR) ' ',
       dwConSize, coordScreen, &cCharsWritten );

    /* get the current text attribute */

    bSuccess = GetConsoleScreenBufferInfo( hConsole, &csbi );

    /* now set the buffer's attributes accordingly */

    bSuccess = FillConsoleOutputAttribute( hConsole, csbi.wAttributes,
       dwConSize, coordScreen, &cCharsWritten );

    /* put the cursor at (0, 0) */

    bSuccess = SetConsoleCursorPosition( hConsole, coordScreen );
}

void home(HANDLE hConsole)
{
    COORD coordScreen = { 0, 0 };    /* here's where we'll home the
                                        cursor */
    BOOL bSuccess;

    /* put the cursor at (0, 0) */
    bSuccess = SetConsoleCursorPosition( hConsole, coordScreen );
}

void
DisplayCacheInfoInteractive(
    HANDLE LsaHandle,
    DWORD PackageNumber)
{
    HANDLE hConsoleOut;

    hConsoleOut = GetStdHandle( STD_OUTPUT_HANDLE );

    cls(hConsoleOut);

    while(TRUE)
    {
        home(hConsoleOut);

        if(fIncludeClient)
        {
            printf("--CLIENT--\n");
            DisplayCacheInfo(LsaHandle, PackageNumber, TRUE, FALSE);
        }

        if(fIncludeServer)
        {
            printf("--SERVER--\n");
            DisplayCacheInfo(LsaHandle, PackageNumber, FALSE, TRUE);
        }

        if(fIncludeClient && fIncludeServer)
        {
            printf("--TOTAL--\n");
            DisplayCacheInfo(LsaHandle, PackageNumber, TRUE, TRUE);
        }

        Sleep(2000);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\spbase\ssl3.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ssl3.c
//
//  Contents:   Ssl3 protocol handling functions
//
//  Classes:
//
//  Functions:
//
//  History:    8-08-95   Ramas     Created
//              1-14-97   Ramas     Rewritten
//
//----------------------------------------------------------------------------

#include <spbase.h>
#include <_ssl3cli.h>
#include <time.h>


DWORD g_Ssl3CertTypes[] = { SSL3_CERTTYPE_RSA_SIGN,
                            SSL3_CERTTYPE_DSS_SIGN};
DWORD g_cSsl3CertTypes = sizeof(g_Ssl3CertTypes) / sizeof(DWORD);

SP_STATUS WINAPI
Ssl3ClientProtocolHandler(
    PSPContext  pContext,
    PSPBuffer   pCommInput,
    PSPBuffer   pCommOutput);

SP_STATUS
UpdateAndDuplicateIssuerList(
    PSPCredentialGroup  pCredGroup,
    PBYTE *             ppbIssuerList,
    PDWORD              pcbIssuerList);


SP_STATUS WINAPI
Ssl3ProtocolHandler(
    PSPContext  pContext,
    PSPBuffer   pCommInput,
    PSPBuffer   pCommOutput)
{
    SPBuffer MsgInput;
    SP_STATUS pctRet;
    DWORD cbInputData = 0;

    if(pContext->Flags & CONTEXT_FLAG_CONNECTION_MODE)
    {
        do
        {
            MsgInput.pvBuffer = (PUCHAR) pCommInput->pvBuffer + cbInputData;
            MsgInput.cbData   = pCommInput->cbData - cbInputData;
            MsgInput.cbBuffer = pCommInput->cbBuffer - cbInputData;

            pctRet = Ssl3ClientProtocolHandler(pContext,
                                               &MsgInput,
                                               pCommOutput);
            cbInputData += MsgInput.cbData;

            if(SP_STATE_CONNECTED == pContext->State)
            {
                break;
            }
            if(PCT_ERR_OK != pctRet)
            {
                break;
            }

        } while(pCommInput->cbData - cbInputData);

        pCommInput->cbData = cbInputData;
    }
    else
    {
        pctRet = Ssl3ClientProtocolHandler(pContext,
                                           pCommInput,
                                           pCommOutput);
    }

    return(pctRet);
}


/*
***************************************************************************
* Ssl3ProtocolHandler
* Main Entry point for handling ssl3 type handshake messages...
****************************************************************************
*/
SP_STATUS WINAPI
Ssl3ClientProtocolHandler
(
    PSPContext  pContext,       // in; state changes and temp data stored
    PSPBuffer   pCommInput,     // in: decrypted in-place...
    PSPBuffer   pCommOutput)    // out
{
    SP_STATUS   pctRet = PCT_ERR_OK;
    DWORD       dwState;
    DWORD       cbMsg;
    BYTE        bContentType;
    BOOL        fServer = (pContext->dwProtocol & SP_PROT_SERVERS);
    BOOL        fProcessMultiple = FALSE;
    PBYTE       pbData;
    DWORD       cbData;
    DWORD       cbBytesProcessed = 0;
    DWORD       dwVersion;
    DWORD       cbDecryptedMsg;

    if(NULL != pCommOutput)
    {
        pCommOutput->cbData = 0;
    }

    dwState = (pContext->State & 0xffff);

    if(FNoInputState(dwState))
    {
        // Process no input cases...
        goto GenResponse;
    }

    if(pContext->State == UNI_STATE_RECVD_UNIHELLO)
    {
        // We've just received a unified client_hello message.
        // This always consists of a single SSL2-format handshake
        // message.

        if(pCommInput->cbData < 3)
        {
            return(PCT_INT_INCOMPLETE_MSG);
        }

        bContentType = UNI_STATE_RECVD_UNIHELLO;

        pbData = pCommInput->pvBuffer;
        cbData = pCommInput->cbData;
        cbDecryptedMsg = cbData;
        cbMsg = cbData;

        goto Process;
    }


    //
    // The input buffer should contain one or more SSL3-format
    // messages. 
    //

    if(pCommInput->cbData < CB_SSL3_HEADER_SIZE)
    {
        return (PCT_INT_INCOMPLETE_MSG);
    }


    //
    // If there are multiple messages in the input buffer, and 
    // these messages exactly fill the buffer, then we should
    // process all of the messages during this call. If there
    // are any fractions, then we should just process the first
    // message.
    //

    pbData = pCommInput->pvBuffer;
    cbData = pCommInput->cbData;

    while(TRUE)
    {
        if(cbData < CB_SSL3_HEADER_SIZE)
        {
            break;
        }

        bContentType = pbData[0];

        if(bContentType != SSL3_CT_CHANGE_CIPHER_SPEC &&
           bContentType != SSL3_CT_ALERT &&
           bContentType != SSL3_CT_HANDSHAKE &&
           bContentType != SSL3_CT_APPLICATIONDATA)
        {
            break;
        }

        dwVersion = COMBINEBYTES(pbData[1], pbData[2]);

        if(dwVersion != SSL3_CLIENT_VERSION &&
           dwVersion != TLS1_CLIENT_VERSION)
        {
            break;
        }

        cbMsg = COMBINEBYTES(pbData[3], pbData[4]);
        cbDecryptedMsg = cbMsg;

        if(CB_SSL3_HEADER_SIZE + cbMsg > cbData)
        {
            break;
        }

        pbData += CB_SSL3_HEADER_SIZE + cbMsg;
        cbData -= CB_SSL3_HEADER_SIZE + cbMsg;

        if(cbData == 0)
        {
            fProcessMultiple = TRUE;
            break;
        }
    }


    //
    // Step through the messages in the input buffer, processing
    // each one in turn.
    //

    pbData = pCommInput->pvBuffer;
    cbData = pCommInput->cbData;

    while(TRUE)
    {
        //
        // Validate the message.
        //

        if(cbData < CB_SSL3_HEADER_SIZE)
        {
            return (PCT_INT_INCOMPLETE_MSG);
        }

        
        bContentType = pbData[0];

        if(bContentType != SSL3_CT_CHANGE_CIPHER_SPEC &&
           bContentType != SSL3_CT_ALERT &&
           bContentType != SSL3_CT_HANDSHAKE &&
           bContentType != SSL3_CT_APPLICATIONDATA)
        {
            return SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        }


        cbMsg = COMBINEBYTES(pbData[3], pbData[4]);
        cbDecryptedMsg = cbMsg;

        if(CB_SSL3_HEADER_SIZE + cbMsg > cbData)
        {
            return (PCT_INT_INCOMPLETE_MSG);
        }

        cbBytesProcessed += CB_SSL3_HEADER_SIZE + cbMsg;

        pCommInput->cbData = cbBytesProcessed;


        //
        // Decrypt the message.
        //

        if(FSsl3Cipher(fServer))
        {
            SPBuffer Message;

            Message.cbBuffer = CB_SSL3_HEADER_SIZE + cbMsg;
            Message.cbData   = CB_SSL3_HEADER_SIZE + cbMsg;
            Message.pvBuffer = pbData;

            // Decrypt the message.
            pctRet = UnwrapSsl3Message(pContext, &Message);

            // if we have to send ALERT messages to the peer, build it!
            if(TLS1_STATE_ERROR == pContext->State)
            {
                goto GenResponse;
            }

            if(pctRet != PCT_ERR_OK)
            {
                return pctRet;
            }

            cbDecryptedMsg = COMBINEBYTES(pbData[3], pbData[4]);
        }


        pbData += CB_SSL3_HEADER_SIZE;
        cbData -= CB_SSL3_HEADER_SIZE;

Process:

        pctRet = SPProcessMessage(pContext, bContentType, pbData, cbDecryptedMsg) ;
        if(pctRet != PCT_ERR_OK)
        {
            return pctRet;
        }

        pbData += cbMsg;
        cbData -= cbMsg;

        // If a response is required at this state then break out of the 
        // message processing loop.
        if(F_RESPONSE(pContext->State))
        {

GenResponse:

            if(pContext->State > SSL3_STATE_GEN_START)
            {
                pctRet = SPGenerateResponse(pContext, pCommOutput);
            }

            return pctRet;
        }

        // If the handshake is complete then stop processing messages.
        // We don't want to accidentally process any application data
        // messages.
        if(pContext->State == SP_STATE_CONNECTED)
        {
            break;
        }

        if(fProcessMultiple && cbData > 0)
        {
            continue;
        }

        break;
    }

    return pctRet;
}

/*
***************************************************************************
* Ssl3HandleFinish
* Handle the handshake finished message..
****************************************************************************
*/

SP_STATUS
Ssl3HandleFinish(
    PSPContext  pContext,
    PBYTE       pbMsg,      // in
    DWORD       cbMsg,      // in
    BOOL        fClient)    // in
{
    BYTE rgbDigest[CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN];
    SP_STATUS pctRet = PCT_ERR_OK;
    PBYTE pb = pbMsg;
    DWORD dwSize;
    DWORD dwSizeExpect = CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN;

    SP_BEGIN("Ssl3HandleFinish");

    //is this the right message type
    if(*pb != SSL3_HS_FINISHED)
    {
        pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        goto error;
    }

    if(pContext->RipeZombie->fProtocol & SP_PROT_TLS1)
    {
        dwSizeExpect = CB_TLS1_VERIFYDATA;
    }

    dwSize = ((INT)pb[1] << 16) + ((INT)pb[2] << 8) + (INT)pb[3];
    pb += sizeof(SHSH);

    // Is the payload the size that we expect?
    if(dwSize != dwSizeExpect)
    {
        pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        goto error;
    }

    // Is the overall message size what we expect? Don't allow buffer overrun!
    if(sizeof(SHSH) + dwSize != cbMsg)
    {
        pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        goto error;
    }

    // Build our end finish message to compare
    if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3)
    {
        pctRet = Ssl3BuildFinishMessage(pContext,
                                        rgbDigest,
                                        &rgbDigest[CB_MD5_DIGEST_LEN],
                                        fClient);
    }
    else
    {
        pctRet = Tls1BuildFinishMessage(pContext,
                                        rgbDigest,
                                        sizeof(rgbDigest),
                                        fClient);
    }
    if(pctRet != PCT_ERR_OK)
    {
        goto error;
    }

    // compare the two...
    if (memcmp(rgbDigest, pb, dwSizeExpect))
    {
        DebugLog((DEB_WARN, "Finished MAC didn't matchChecksum Invalid\n"));
        pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
        goto error;
    }
    SP_RETURN(PCT_ERR_OK);

error:

    SP_RETURN(pctRet);
}


/*
***************************************************************************
* Ssl3PackClientHello
****************************************************************************
*/

SP_STATUS
Ssl3PackClientHello(
    PSPContext              pContext,
    PSsl2_Client_Hello       pCanonical,
    PSPBuffer          pCommOutput)
{
    DWORD cbHandshake;
    DWORD cbMessage;
    PBYTE pbMessage = NULL;
    DWORD dwCipherSize;
    DWORD i;
    BOOL  fAllocated = FALSE;

    //
    // opaque SessionID<0..32>;
    //
    // struct {
    //     ProtocolVersion client_version;
    //     Random random;
    //     SessionID session_id;
    //     CipherSuite cipher_suites<2..2^16-1>;
    //     CompressionMethod compression_methods<1..2^8-1>;
    // } ClientHello;
    //

    SP_BEGIN("Ssl3PackClientHello");

    if(pCanonical == NULL || pCommOutput == NULL)
    {
        SP_RETURN(PCT_INT_INTERNAL_ERROR);
    }

    // Compute size of the ClientHello message.
    cbHandshake = sizeof(SHSH) +
                  2 +
                  CB_SSL3_RANDOM +
                  1 + pCanonical->cbSessionID +
                  2 + pCanonical->cCipherSpecs * sizeof(short) +
                  2; // Size of compression algorithm 1 + null (0)

    // Compute size of encrypted ClientHello message.
    cbMessage = Ssl3CiphertextLen(pContext,
                                  cbHandshake,
                                  TRUE);

    if(pCommOutput->pvBuffer)
    {
        // Application has allocated memory.
        if(pCommOutput->cbBuffer < cbMessage)
        {
            pCommOutput->cbData = cbMessage;
            return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        }
        fAllocated = TRUE;
    }
    else
    {
        // Schannel is to allocate memory.
        pCommOutput->cbBuffer = cbMessage;
        pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
        if(pCommOutput->pvBuffer == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }
    }
    pCommOutput->cbData = cbMessage;

    // Initialize the member variables.
    pbMessage = (PBYTE)pCommOutput->pvBuffer + sizeof(SWRAP) + sizeof(SHSH);

    *pbMessage++ =  MSBOF(pCanonical->dwVer);
    *pbMessage++ =  LSBOF(pCanonical->dwVer);

    CopyMemory(pbMessage, pCanonical->Challenge, CB_SSL3_RANDOM);
    pbMessage += CB_SSL3_RANDOM;

    *pbMessage++ = (BYTE)pCanonical->cbSessionID;
    CopyMemory(pbMessage, pCanonical->SessionID, pCanonical->cbSessionID);
    pbMessage += pCanonical->cbSessionID;

    dwCipherSize = pCanonical->cCipherSpecs * sizeof(short);
    *pbMessage++ = MSBOF(dwCipherSize);
    *pbMessage++ = LSBOF(dwCipherSize);
    for(i = 0; i < pCanonical->cCipherSpecs; i++)
    {
        *pbMessage++ = MSBOF(pCanonical->CipherSpecs[i]);
        *pbMessage++ = LSBOF(pCanonical->CipherSpecs[i]);
    }

    *pbMessage++ = 1;    // One compression method;
    *pbMessage++ = 0x00; // NULL compression method.

    // Fill in Handshake structure.
    SetHandshake((PBYTE)pCommOutput->pvBuffer + sizeof(SWRAP),
                 SSL3_HS_CLIENT_HELLO,
                 NULL,
                 (WORD)(cbHandshake - sizeof(SHSH)));

    // Save the ClientHello message so we can hash it later, once
    // we know what algorithm and CSP we're using.
    if(pContext->pClientHello)
    {
        SPExternalFree(pContext->pClientHello);
    }
    pContext->cbClientHello = cbHandshake;
    pContext->pClientHello = SPExternalAlloc(pContext->cbClientHello);
    if(pContext->pClientHello == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
    }
    CopyMemory(pContext->pClientHello,
               (PBYTE)pCommOutput->pvBuffer + sizeof(SWRAP),
               pContext->cbClientHello);
    pContext->dwClientHelloProtocol = SP_PROT_SSL3_CLIENT;

    // Fill in record header and encrypt the message.
    SP_RETURN(SPSetWrap(pContext,
            pCommOutput->pvBuffer,
            SSL3_CT_HANDSHAKE,
            cbHandshake,
            TRUE,
            NULL));
}


//+---------------------------------------------------------------------------
//
//  Function:   Ssl3GenerateRandom
//
//  Synopsis:   Create a client_random or server_random value.
//
//  Arguments:  [pRandom]   --  Output buffer.
//
//  History:    04-03-2001  jbanes  Created.
//
//  Notes:      struct {
//                  uint32 gmt_unix_time;
//                  opaque random_bytes[28];
//              } Random;
//
//              gmt_unix_time
//                  The current time and date in standard UNIX 32-bit format
//                  (seconds since the midnight starting Jan 1, 1970, GMT) 
//                  according to the sender's internal clock. Clocks are not
//                  required to be set correctly by the basic TLS Protocol; 
//                  higher level or application protocols may define 
//                  additional requirements.
//
//              random_bytes
//                  28 bytes generated by a secure random number generator.
//
//----------------------------------------------------------------------------
NTSTATUS
Ssl3GenerateRandom(
    PBYTE pRandom)
{
    time_t UnixTime;

    time(&UnixTime);

    *(DWORD *)pRandom = htonl((DWORD)UnixTime);

    return GenerateRandomBits(pRandom + sizeof(DWORD), CB_SSL3_RANDOM - sizeof(DWORD));
}


/*
***************************************************************************
* GenerateSsl3ClientHello
*  v3 client hello build it on pOutpu
****************************************************************************
*/

SP_STATUS WINAPI
GenerateSsl3ClientHello(
    PSPContext              pContext,
    PSPBuffer               pOutput)
{
    Ssl2_Client_Hello    HelloMessage;
    SP_STATUS pctRet;

    SP_BEGIN("GenerateSsl3ClientHello");

    pctRet = Ssl3GenerateRandom(pContext->pChallenge);
    if(NT_SUCCESS(pctRet))
    {
        pContext->cbChallenge = CB_SSL3_RANDOM;
    
        pctRet = GenerateUniHelloMessage(pContext, &HelloMessage, SP_PROT_SSL3_CLIENT);
    
        if(PCT_ERR_OK == pctRet)
        {
            pctRet = Ssl3PackClientHello(pContext, &HelloMessage,  pOutput);
        }
    }

    SP_RETURN(pctRet);
}

SP_STATUS WINAPI
GenerateTls1ClientHello(
    PSPContext              pContext,
    PSPBuffer               pOutput,
    DWORD                   dwProtocol)
{
    Ssl2_Client_Hello    HelloMessage;
    SP_STATUS pctRet;

    SP_BEGIN("GenerateTls1ClientHello");

    pctRet = Ssl3GenerateRandom(pContext->pChallenge);

    if(NT_SUCCESS(pctRet))
    {
        pContext->cbChallenge = CB_SSL3_RANDOM;
    
        pctRet = GenerateUniHelloMessage(pContext, &HelloMessage, dwProtocol);
    
        if(PCT_ERR_OK == pctRet)
        {
            pctRet = Ssl3PackClientHello(pContext, &HelloMessage,  pOutput);
        }
    }

    SP_RETURN(pctRet);
}

/*
***************************************************************************
* ParseCertificateRequest
* if server is requesting client-auth, server will send this message.
* parse them and store it in pContext, for later use....
****************************************************************************
*/


SP_STATUS
ParseCertificateRequest(
    PSPContext  pContext,
    PBYTE       pb,
    DWORD       dwcb)
{
    SP_STATUS pctRet;
    UCHAR cbCertType;
    DWORD cbIssuerList;
    PBYTE pbNewIssuerList;
    DWORD cbNewIssuerList;

    UCHAR i, j;

    //
    // enum {
    //     rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
    //     rsa_ephemeral_dh(5), dss_ephemeral_dh(6), fortezza_dms(20), (255)
    // } ClientCertificateType;
    //
    // opaque DistinguishedName<1..2^16-1>;
    //
    // struct {
    //     ClientCertificateType certificate_types<1..2^8-1>;
    //     DistinguishedName certificate_authorities<3..2^16-1>;
    // } CertificateRequest;
    //

    //
    // Skip over handshake header.
    //

    if(dwcb < sizeof(SHSH))
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        goto cleanup;
    }
    pb   += sizeof(SHSH);
    dwcb -= sizeof(SHSH);


    //
    // Parse certificate type list.
    //

    if(dwcb < 1)
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        goto cleanup;
    }

    cbCertType = pb[0];

    pb   += 1;
    dwcb -= 1;

    if(cbCertType > dwcb)
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        goto cleanup;
    }

    pContext->cSsl3ClientCertTypes = 0;
    for(i = 0; i < cbCertType; i++)
    {
        for(j = 0; j < g_cSsl3CertTypes; j++)
        {
            if(g_Ssl3CertTypes[j] == pb[i])
            {
                pContext->Ssl3ClientCertTypes[pContext->cSsl3ClientCertTypes++] = g_Ssl3CertTypes[j];
            }
        }
    }

    pb   += cbCertType;
    dwcb -= cbCertType;


    //
    // Parse issuer list.
    //

    if(dwcb < 2)
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        goto cleanup;
    }

    cbIssuerList = COMBINEBYTES(pb[0], pb[1]);

    pb   += 2;
    dwcb -= 2;

    if(dwcb < cbIssuerList)
    {
        pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        goto cleanup;
    }

    pctRet = FormatIssuerList(pb, 
                              cbIssuerList, 
                              NULL,
                              &cbNewIssuerList);
    if(pctRet != PCT_ERR_OK)
    {
        goto cleanup;
    }

    pbNewIssuerList = SPExternalAlloc(2 + cbNewIssuerList);
    if(pbNewIssuerList == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto cleanup;
    }

    pbNewIssuerList[0] = MSBOF(cbNewIssuerList);
    pbNewIssuerList[1] = LSBOF(cbNewIssuerList);

    pctRet = FormatIssuerList(pb, 
                              cbIssuerList, 
                              pbNewIssuerList + 2,
                              &cbNewIssuerList);
    if(pctRet != PCT_ERR_OK)
    {
        SPExternalFree(pbNewIssuerList);
        goto cleanup;
    }


    //
    // Store issuer list in context structure.
    //

    if(pContext->pbIssuerList)
    {
        SPExternalFree(pContext->pbIssuerList);
    }
    pContext->pbIssuerList = pbNewIssuerList;
    pContext->cbIssuerList = cbNewIssuerList + 2;


cleanup:

    return (pctRet);
}


/*
***************************************************************************
* BuildCertVerify
* Build certificate Verify message. This is sent by client if sending
* client certificate.
****************************************************************************
*/

SP_STATUS
BuildCertVerify(
    PSPContext  pContext,
    PBYTE pbCertVerify,
    DWORD *pcbCertVerify)
{
    SP_STATUS pctRet;
    PBYTE pbSigned;
    DWORD cbSigned;
    BYTE  rgbHashValue[CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN];
    DWORD cbHashValue;
    ALG_ID aiHash;
    PBYTE pbMD5;
    PBYTE pbSHA;
    DWORD cbHeader;
    DWORD cbBytesRequired;

    PSPCredential pCred;

    if((pcbCertVerify == NULL) ||
       (pContext == NULL) ||
       (pContext->RipeZombie == NULL) ||
       (pContext->pActiveClientCred == NULL))
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    pCred = pContext->pActiveClientCred;

    //
    // digitally-signed struct {
    //     opaque md5_hash[16];
    //     opaque sha_hash[20];
    // } Signature;
    //
    // struct {
    //     Signature signature;
    // } CertificateVerify;
    //
    // CertificateVerify.signature.md5_hash = MD5(master_secret + pad2 +
    //    MD5(handshake_messages + master_secret + pad1));
    //
    // CertificateVerify.signature.sha_hash = SHA(master_secret + pad2 +
    //    SHA(handshake_messages + master_secret + pad1));
    //

    cbHeader = sizeof(SHSH);

    cbBytesRequired = cbHeader + 
                      2 +
                      pCred->pPublicKey->cbPublic;
    
    if(pbCertVerify == NULL)
    {
        *pcbCertVerify = cbBytesRequired;
        return PCT_ERR_OK;
    }

    if(*pcbCertVerify < sizeof(SHSH))
    {
        *pcbCertVerify = cbBytesRequired;
        return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
    }


    //
    // Generate hash values
    //

    switch(pCred->pPublicKey->pPublic->aiKeyAlg)
    {
    case CALG_RSA_SIGN:
    case CALG_RSA_KEYX:
        aiHash      = CALG_SSL3_SHAMD5;
        pbMD5       = rgbHashValue;
        pbSHA       = rgbHashValue + CB_MD5_DIGEST_LEN;
        cbHashValue = CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN;
        break;

    case CALG_DSS_SIGN:
        aiHash      = CALG_SHA;
        pbMD5       = NULL;
        pbSHA       = rgbHashValue;
        cbHashValue = CB_SHA_DIGEST_LEN;
        break;

    default:
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pContext->RipeZombie->fProtocol & SP_PROT_TLS1)
    {
        pctRet = Tls1ComputeCertVerifyHashes(pContext, pbMD5, pbSHA);
    }
    else
    {
        pctRet = Ssl3ComputeCertVerifyHashes(pContext, pbMD5, pbSHA);
    }
    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }


    //
    // Sign hash values.
    //

    pbSigned = pbCertVerify + sizeof(SHSH) + 2;
    cbSigned = cbBytesRequired - sizeof(SHSH) - 2;

    DebugLog((DEB_TRACE, "Sign certificate_verify message.\n"));

    pctRet = SignHashUsingCred(pCred,
                               aiHash,
                               rgbHashValue,
                               cbHashValue,
                               pbSigned,
                               &cbSigned);
    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }

    DebugLog((DEB_TRACE, "Certificate_verify message signed successfully.\n"));

    //
    // Fill in header.
    //

    pbCertVerify[cbHeader + 0] = MSBOF(cbSigned);
    pbCertVerify[cbHeader + 1] = LSBOF(cbSigned);

    SetHandshake(pbCertVerify, SSL3_HS_CERTIFICATE_VERIFY, NULL, (WORD)(cbSigned + 2));

    *pcbCertVerify =  cbHeader + 2 + cbSigned;

    return PCT_ERR_OK;
}


SP_STATUS
HandleCertVerify(
    PSPContext  pContext, 
    PBYTE       pbMessage, 
    DWORD       cbMessage)
{
    PBYTE pbSignature;
    DWORD cbSignature;
    BYTE  rgbHashValue[CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN];
    DWORD cbHashValue;
    HCRYPTPROV hProv;
    ALG_ID aiHash;
    PBYTE pbMD5;
    PBYTE pbSHA;
    SP_STATUS pctRet;

    if((pContext == NULL) ||
       (pContext->RipeZombie == NULL))
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pContext->RipeZombie->pRemotePublic == NULL)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    if(cbMessage < sizeof(SHSH) + 2)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    pbSignature = pbMessage + sizeof(SHSH);

    cbSignature = ((DWORD)pbSignature[0] << 8) + pbSignature[1];
    pbSignature += 2;

    if(sizeof(SHSH) + 2 + cbSignature > cbMessage)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    switch(pContext->RipeZombie->pRemotePublic->pPublic->aiKeyAlg)
    {
    case CALG_RSA_SIGN:
    case CALG_RSA_KEYX:
        hProv       = g_hRsaSchannel;
        aiHash      = CALG_SSL3_SHAMD5;
        pbMD5       = rgbHashValue;
        pbSHA       = rgbHashValue + CB_MD5_DIGEST_LEN;
        cbHashValue = CB_MD5_DIGEST_LEN + CB_SHA_DIGEST_LEN;
        break;

    case CALG_DSS_SIGN:
        hProv       = g_hDhSchannelProv;
        aiHash      = CALG_SHA;
        pbMD5       = NULL;
        pbSHA       = rgbHashValue;
        cbHashValue = CB_SHA_DIGEST_LEN;
        break;

    default:
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(pContext->RipeZombie->fProtocol & SP_PROT_TLS1)
    {
        pctRet = Tls1ComputeCertVerifyHashes(pContext, pbMD5, pbSHA);
    }
    else
    {
        pctRet = Ssl3ComputeCertVerifyHashes(pContext, pbMD5, pbSHA);
    }
    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }

    // Verify signature.
    DebugLog((DEB_TRACE, "Verify certificate_verify signature.\n"));
    pctRet = SPVerifySignature(hProv, 
                               pContext->RipeZombie->pRemotePublic,
                               aiHash,
                               rgbHashValue,
                               cbHashValue,
                               pbSignature,
                               cbSignature,
                               FALSE);
    if(pctRet != PCT_ERR_OK)
    {
        return SP_LOG_RESULT(pctRet);
    }
    DebugLog((DEB_TRACE, "Certificate_verify verified successfully.\n"));

    return PCT_ERR_OK;
}


SP_STATUS 
FormatIssuerList(
    PBYTE       pbInput,
    DWORD       cbInput,
    PBYTE       pbIssuerList,
    DWORD *     pcbIssuerList)
{
    DWORD cbIssuerList = 0;
    PBYTE pbList = pbInput;
    DWORD cbList = cbInput;
    DWORD cbIssuer;
    DWORD cbTag;

    while(cbList)
    {
        if(cbList < 2)
        {
            return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        }

        cbIssuer = COMBINEBYTES(pbList[0], pbList[1]);

        pbList += 2;
        cbList -= 2;

        if(cbList < cbIssuer)
        {
            return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        }

        if(pbIssuerList)
        {
            pbIssuerList[0] = MSBOF(cbIssuer);
            pbIssuerList[1] = LSBOF(cbIssuer);
            pbIssuerList += 2;
        }
        cbIssuerList += 2;

        if(pbList[0] != SEQUENCE_TAG) 
        {
            // An old version of Netscape Enterprise Server had a bug, in that 
            // the issuer names did not start off with a SEQUENCE tag. Patch
            // the name appropriately before storing it into pContext.
            cbTag = CbLenOfEncode(cbIssuer, pbIssuerList);

            if(pbIssuerList)
            {
                pbIssuerList += cbTag;
            }
            cbIssuerList += cbTag;
        }

        if(pbIssuerList)
        {
            memcpy(pbIssuerList, pbList, cbIssuer);
            pbIssuerList += cbIssuer;
        }
        cbIssuerList += cbIssuer;

        pbList += cbIssuer;
        cbList -= cbIssuer;
    }

    *pcbIssuerList = cbIssuerList;

    return(PCT_ERR_OK);
}

/*
***************************************************************************
* CbLenOfEncode
* Retunrs the length of the ASN encoding, for certificate
****************************************************************************
*/


DWORD  CbLenOfEncode(DWORD dw, PBYTE pbDst)
{
    BYTE   lenbuf[8];
    DWORD   length = sizeof(lenbuf) - 1;
    LONG    lth;

    if (0x80 > dw)
    {
        lenbuf[length] = (BYTE)dw;
        lth = 1;
    }
    else
    {
        while (0 < dw)
        {
            lenbuf[length] = (BYTE)(dw & 0xff);
            length -= 1;
            dw = (dw >> 8) & 0x00ffffff;
        }
        lth = sizeof(lenbuf) - length;
        lenbuf[length] = (BYTE)(0x80 | (lth - 1));
    }

    if(NULL != pbDst)
    {
        pbDst[0] = 0x30;
        memcpy(pbDst+1, &lenbuf[length], lth);

    }
    return ++lth; //for 0x30
}


/*
***************************************************************************
* SPDigestServerHello
* Parse the server hello from the server.
****************************************************************************
*/
SP_STATUS
SPDigestServerHello(
    PSPContext  pContext,
    PUCHAR      pbSrvHello,
    DWORD       cbSrvHello,
    PBOOL       pfRestart)
{
    SSH *pssh;
    SP_STATUS pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    SHORT wCipher, wCompression;
    BOOL fRestartServer = FALSE;
    PSessCacheItem      pZombie;
    PSPCredentialGroup  pCred;
    DWORD dwVersion;

    UNREFERENCED_PARAMETER(cbSrvHello);

    // We should have a zombie identity here
    if(pContext->RipeZombie == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }
    pZombie = pContext->RipeZombie;

    pCred = pContext->pCredGroup;
    if(!pCred)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    SP_BEGIN("SPDigestServerHello");

    // Pad the client random structure with zero's if the challenge is
    // smaller than the normal SSL3 size (SSL2 v3 hello, Unihello, PCT1 wierdness if
    // we add it)
    FillMemory(pContext->rgbS3CRandom, CB_SSL3_RANDOM - pContext->cbChallenge, 0);

    CopyMemory(  pContext->rgbS3CRandom + CB_SSL3_RANDOM - pContext->cbChallenge,
                 pContext->pChallenge,
                 pContext->cbChallenge);

    pssh = (SSH *)pbSrvHello;

    if(pssh->cbSessionId > CB_SSL3_SESSION_ID)
    {
        SP_RETURN(PCT_ERR_ILLEGAL_MESSAGE);
    }


    dwVersion = COMBINEBYTES(pssh->bMajor, pssh->bMinor);

    if((dwVersion == SSL3_CLIENT_VERSION) && 
       (pCred->grbitEnabledProtocols & SP_PROT_SSL3_CLIENT))
    {
        // This appears to be an SSL3 server_hello.
        pContext->dwProtocol = SP_PROT_SSL3_CLIENT;
    }
    else if((dwVersion == TLS1_CLIENT_VERSION) && 
       (pCred->grbitEnabledProtocols & SP_PROT_TLS1_CLIENT))
    {
        // This appears to be a TLS server_hello.
        pContext->dwProtocol = SP_PROT_TLS1_CLIENT;
    }
    else
    {
        return SP_LOG_RESULT(PCT_INT_SPECS_MISMATCH);
    }

    DebugLog((DEB_TRACE, "**********Protocol***** %x\n", pContext->dwProtocol));

    CopyMemory(pContext->rgbS3SRandom, pssh->rgbRandom, CB_SSL3_RANDOM);
    wCipher = (SHORT)COMBINEBYTES(pssh->rgbSessionId[pssh->cbSessionId],
                           pssh->rgbSessionId[pssh->cbSessionId+1]);
    wCompression = pssh->rgbSessionId[pssh->cbSessionId+2];

    if( wCompression != 0)
    {
        SP_RETURN(PCT_ERR_ILLEGAL_MESSAGE);
    }
    if(pZombie->hMasterKey  &&
       pZombie->cbSessionID && 
       memcmp(pZombie->SessionID, PbSessionid(pssh), pssh->cbSessionId) == 0)
    {
        fRestartServer = TRUE;

        if(!pZombie->ZombieJuju)
        {
            DebugLog((DEB_WARN, "Session expired on client machine, but not on server.\n"));
        }
    }

    if(!fRestartServer)
    {
        if(pZombie->hMasterKey != 0)
        {
            // We've attempted to do a reconnect and the server has
            // blown us off. In this case we must use a new and different
            // cache entry.
            pZombie->ZombieJuju = FALSE;

            if(!SPCacheClone(&pContext->RipeZombie))
            {
                SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
            }
            pZombie = pContext->RipeZombie;
        }

        pZombie->fProtocol = pContext->dwProtocol;

        #if DBG
        if(pssh->cbSessionId == 0)
        {
            DebugLog((DEB_WARN, "Server didn't give us a session id!\n"));
        }
        #endif

        if(pssh->cbSessionId)
        {
            CopyMemory(pZombie->SessionID, PbSessionid(pssh), pssh->cbSessionId);
            pZombie->cbSessionID = pssh->cbSessionId;
        }
    }

    pctRet = Ssl3SelectCipher(pContext, wCipher);
    if(pctRet != PCT_ERR_OK)
    {
        SP_RETURN(SP_LOG_RESULT(pctRet));
    }


    if(fRestartServer)
    {
        // Make a new set of session keys.
        pctRet = MakeSessionKeys(pContext,
                                 pZombie->hMasterProv,
                                 pZombie->hMasterKey);
        if(PCT_ERR_OK != pctRet)
        {
            SP_RETURN(SP_LOG_RESULT(pctRet));
        }
    }


    // Initialize handshake hashes and hash ClientHello message. This
    // must be done _after_ the ServerHello message is processed,
    // so that the correct CSP context is used.
    if(pContext->dwClientHelloProtocol == SP_PROT_PCT1_CLIENT ||
       pContext->dwClientHelloProtocol == SP_PROT_SSL2_CLIENT)
    {
        // Skip over the 2 byte header.
        pctRet = UpdateHandshakeHash(pContext,
                                     pContext->pClientHello  + 2,
                                     pContext->cbClientHello - 2,
                                     TRUE);
    }
    else
    {
        pctRet = UpdateHandshakeHash(pContext,
                                     pContext->pClientHello,
                                     pContext->cbClientHello,
                                     TRUE);
    }
    SPExternalFree(pContext->pClientHello);
    pContext->pClientHello  = NULL;
    pContext->cbClientHello = 0;


    *pfRestart = fRestartServer;

    SP_RETURN(pctRet);
}


/*
***************************************************************************
* SpDigestRemoteCertificate
* Process the Certificate message. This is common for server/client.
****************************************************************************
*/

SP_STATUS
SpDigestRemoteCertificate (
    PSPContext  pContext,
    PUCHAR      pb,
    DWORD       cb)
{
    SP_STATUS pctRet = PCT_ERR_OK;
    CERT *pcert;
    DWORD cbCert;
    DWORD dwSize;

    SP_BEGIN("SpDigestRemoteCertificate");

    if(pContext == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    if((pContext->RipeZombie->fProtocol & SP_PROT_SERVERS) && (pContext->fCertReq == FALSE))
    {
        // We're a server and the client just sent us an
        // unexpected certificate message.
        SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }

    pcert = (CERT *)pb;

    if(cb < CB_SSL3_CERT_VECTOR + sizeof(SHSH))
    {
         SP_RETURN(SP_LOG_RESULT(PCT_INT_INCOMPLETE_MSG));
    }
    dwSize = ((INT)pcert->bcb24 << 16) +
             ((INT)pcert->bcbMSB << 8) +
             (INT)pcert->bcbLSB;

    cbCert = COMBINEBYTES(pcert->bcbMSBClist, pcert->bcbLSBClist);
    cbCert |= (pcert->bcbClist24 << 16);

    if(dwSize != cbCert + CB_SSL3_CERT_VECTOR)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }

    if(dwSize + sizeof(SHSH) > cb)
    {
         SP_RETURN(SP_LOG_RESULT(PCT_INT_INCOMPLETE_MSG));
    }

    if(cbCert == 0)
    {
        if(pContext->RipeZombie->fProtocol & SP_PROT_CLIENTS)
        {
            // Error out if the server certificate is zero length
            SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
        }
        else
        {
            DebugLog((DEB_WARN, "Zero length client certificate received.\n"));
        }
    }

    if(cbCert != 0) //for tls1, it could be zero length.
    {
        // The certificate type is derived from the key exchange method
        // but most currently use X509_ASN_ENCODING
        pctRet = SPLoadCertificate( SP_PROT_SSL3_CLIENT,
                                X509_ASN_ENCODING,
                                (PUCHAR)&pcert->bcbCert24,
                                cbCert,
                                &pContext->RipeZombie->pRemoteCert);

        if(PCT_ERR_OK != pctRet)
        {
            SP_RETURN(pctRet);
        }
        if(pContext->RipeZombie->pRemotePublic != NULL)
        {
            SPExternalFree(pContext->RipeZombie->pRemotePublic);
            pContext->RipeZombie->pRemotePublic = NULL;
        }

        pctRet = SPPublicKeyFromCert(pContext->RipeZombie->pRemoteCert,
                                     &pContext->RipeZombie->pRemotePublic,
                                     NULL);

        if(PCT_ERR_OK != pctRet)
        {
            SP_RETURN(pctRet);
        }
    }

    SP_RETURN(pctRet);
}


/*
***************************************************************************
* SPDigestSrvKeyX
* Digest the Server key  exhcnage message.
* this function encrypts the Pre-master secret with the public-key from this
* message
****************************************************************************
*/

SP_STATUS SPDigestSrvKeyX(
    PSPContext  pContext,
    PUCHAR pbServerExchangeValue,
    DWORD cbServerExchangeValue)
{
    SP_STATUS pctRet;

    if((pContext->pKeyExchInfo == NULL) || ((pContext->pKeyExchInfo->fProtocol & SP_PROT_SSL3TLS1_CLIENTS) == 0))
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    SP_ASSERT(NULL == pContext->pbEncryptedKey);

    pctRet = pContext->pKeyExchInfo->System->GenerateClientExchangeValue(
                    pContext,
                    pbServerExchangeValue,
                    cbServerExchangeValue,
                    NULL,
                    NULL,
                    NULL,  
                    &pContext->cbEncryptedKey);

    if(pctRet != PCT_ERR_OK)
    {
        return pctRet;
    }

    pContext->pbEncryptedKey = SPExternalAlloc(pContext->cbEncryptedKey);
    if(pContext->pbEncryptedKey == NULL)
    {
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    pctRet = pContext->pKeyExchInfo->System->GenerateClientExchangeValue(
                    pContext,
                    pbServerExchangeValue,
                    cbServerExchangeValue,
                    NULL,
                    NULL,
                    pContext->pbEncryptedKey,
                    &pContext->cbEncryptedKey);

    return pctRet;
}


//+---------------------------------------------------------------------------
//
//  Function:   Ssl3CheckForExistingCred
//
//  Synopsis:   Choose client certificate. Use one of the certificates
//              attached to the credential handle if possible. If the 
//              credential handle is anonymous, then attempt to create
//              a default credential.
//
//  Notes:      This routine is called by the client-side only.
//              
//  Returns:    PCT_ERR_OK      
//                  The function completed successfully. The
//                  pContext->pActiveClientCred field has been updated to
//                  point at a suitable client credential.
//
//              SEC_E_INCOMPLETE_CREDENTIALS
//                  No suitable certificate has been found. Notify the
//                  application.
//
//              SEC_I_INCOMPLETE_CREDENTIALS
//                  No suitable certificate has been found. Attempt an
//                  anonymous connection. 
//
//              <other>
//                  Fatal error.
//
//----------------------------------------------------------------------------
SP_STATUS
Ssl3CheckForExistingCred(PSPContext pContext)
{
    SP_STATUS pctRet;

    //
    // Examine the certificates attached to the credential group and see
    // if any of them are suitable.
    //

    if(pContext->pCredGroup->CredCount != 0)
    {
        DWORD i, j;

        for(i = 0; i < pContext->cSsl3ClientCertTypes; i++)
        {
            for(j = 0; j < g_cCertTypes; j++)
            {
                if(pContext->Ssl3ClientCertTypes[i] != g_CertTypes[j].dwCertType)
                {
                    continue;
                }

                pctRet = SPPickClientCertificate(
                                pContext,
                                g_CertTypes[j].dwExchSpec);
                if(pctRet == PCT_ERR_OK)
                {
                    // We found one.
                    DebugLog((DEB_TRACE, "Application provided suitable client certificate.\n"));

                    return PCT_ERR_OK;
                }
            }
        }

        // The credential group contained one or more certificates,
        // but none were suitable. Don't even try to find a default
        // certificate in this situation.
        goto error;
    }


    //
    // Attempt to acquire a default credential.
    //

    if(pContext->pCredGroup->dwFlags & CRED_FLAG_NO_DEFAULT_CREDS)
    {
        // Look in credential manager only.
        pctRet = AcquireDefaultClientCredential(pContext, TRUE);
    }
    else
    {
        // Look in both credential manager and MY certificate store.
        pctRet = AcquireDefaultClientCredential(pContext, FALSE);
    }

    if(pctRet == PCT_ERR_OK)
    {
        DebugLog((DEB_TRACE, "Default client certificate acquired.\n"));

        return PCT_ERR_OK;
    }


error:

    if(pContext->Flags & CONTEXT_FLAG_NO_INCOMPLETE_CRED_MSG)
    {
        return SP_LOG_RESULT(SEC_I_INCOMPLETE_CREDENTIALS);
    }
    else
    {
        return SP_LOG_RESULT(SEC_E_INCOMPLETE_CREDENTIALS);
    }
}


/*
***************************************************************************
* SPGenerateSHResponse
* This is the main function which outgoing message to the wire
****************************************************************************
*/

SP_STATUS
SPGenerateSHResponse(PSPContext  pContext, PSPBuffer pCommOutput)
{
    PBYTE pbMessage = NULL;
    DWORD cbMessage;
    PBYTE pbHandshake = NULL;
    DWORD cbHandshake;
    PBYTE pbClientCert = NULL;
    DWORD cbClientCert = 0;
    DWORD cbDataOut;
    SP_STATUS pctRet;
    BOOL  fAllocated = FALSE;
    BOOL fClientAuth;
    PSessCacheItem pZombie;

    SP_BEGIN("SPGenerateSHResponse");

    if((pContext == NULL) ||
       (pCommOutput == NULL) ||
       (pContext->RipeZombie == NULL) ||
       (pContext->pKeyExchInfo == NULL))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    fClientAuth = pContext->fCertReq;
    pZombie = pContext->RipeZombie;


    //
    // Estimate size of the ClientKeyExchange message group.
    //

    cbMessage = 0;

    if(fClientAuth)
    {
        if(pContext->pActiveClientCred != NULL)
        {
            DWORD cbCertVerify;

            pbClientCert = pContext->pActiveClientCred->pbSsl3SerializedChain;
            cbClientCert = pContext->pActiveClientCred->cbSsl3SerializedChain;

            if(cbClientCert > 0x3fff) //Separate Wrappers after this
            {                          // is a BIG UNDONE...
                pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
                goto cleanup;
            }

            cbMessage += sizeof(SHSH) +             // ClientCertificate
                         CB_SSL3_CERT_VECTOR +
                         cbClientCert;


            pctRet = BuildCertVerify(pContext,
                                     NULL,
                                     &cbCertVerify);
            if(pctRet != PCT_ERR_OK)
            {
                goto cleanup;
            }

            cbMessage += cbCertVerify;              // CertificateVerify
        }
        else
        {
            LogNoClientCertFoundEvent();

            //for ssl3, it's no_certificate alert
            if((pContext->RipeZombie->fProtocol & SP_PROT_SSL3))
            {
                cbMessage += sizeof(SWRAP) +            // no_certificate Alert
                         CB_SSL3_ALERT_ONLY +
                         SP_MAX_DIGEST_LEN +
                         SP_MAX_BLOCKCIPHER_SIZE;
            }
            // for tls1, it's certificate of zero length.
            else
            {
                cbMessage += sizeof(SHSH) + CB_SSL3_CERT_VECTOR;
            }
        }
    }

    cbMessage += sizeof(SWRAP) +                    // ClientKeyExchange
                 sizeof(SHSH) +
                 pContext->cbEncryptedKey +
                 SP_MAX_DIGEST_LEN +
                 SP_MAX_BLOCKCIPHER_SIZE;

    cbMessage += sizeof(SWRAP) +                    // ChangeCipherSpec
                 CB_SSL3_CHANGE_CIPHER_SPEC_ONLY +
                 SP_MAX_DIGEST_LEN +
                 SP_MAX_BLOCKCIPHER_SIZE;

    cbMessage += sizeof(SWRAP) +                    // Finished
                 CB_SSL3_FINISHED_MSG_ONLY +
                 SP_MAX_DIGEST_LEN +
                 SP_MAX_BLOCKCIPHER_SIZE;

    //
    // Allocate memory for the ClientKeyExchange message group.
    //

    if(pCommOutput->pvBuffer)
    {
        // Application has allocated memory.
        if(pCommOutput->cbBuffer < cbMessage)
        {
            pCommOutput->cbData = cbMessage;
            pctRet = SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
            goto cleanup;
        }
        fAllocated = TRUE;
    }
    else
    {
        // Schannel is to allocate memory.
        pCommOutput->cbBuffer = cbMessage;
        pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
        if(pCommOutput->pvBuffer == NULL)
        {
            pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }
    }
    pCommOutput->cbData = 0;


    // Build no_certificate alert (at the end of the output buffer).
    if((pContext->RipeZombie->fProtocol & SP_PROT_SSL3) && fClientAuth && pbClientCert == NULL)
    {
        pbMessage = (PBYTE)pCommOutput->pvBuffer + pCommOutput->cbData;

        // Build alert message.
        BuildAlertMessage(pbMessage,
                          SSL3_ALERT_WARNING,
                          SSL3_ALERT_NO_CERTIFICATE);

        // Build record header and encrypt message.
        pctRet = SPSetWrap(pContext,
                pbMessage,
                SSL3_CT_ALERT,
                CB_SSL3_ALERT_ONLY,
                TRUE,
                &cbDataOut);

        if(pctRet != PCT_ERR_OK)
        {
            SP_LOG_RESULT(pctRet);
            goto cleanup;
        }

        // Update buffer length.
        pCommOutput->cbData += cbDataOut;

        SP_ASSERT(pCommOutput->cbData <= pCommOutput->cbBuffer);
    }


    // Keep pointer to record structure. This will represent the
    // ClientCertificate, ClientKeyExchange, and CertificateVerify messages.
    pbMessage = (PBYTE)pCommOutput->pvBuffer + pCommOutput->cbData;
    cbMessage = 0;

    pbHandshake = pbMessage + sizeof(SWRAP);


    // Build ClientCertificate message.
    if((pContext->RipeZombie->fProtocol & SP_PROT_TLS1) && fClientAuth && pbClientCert == NULL)
    {
        //Build a zero length certificate message for TLS1
        pbMessage = (PBYTE)pCommOutput->pvBuffer + pCommOutput->cbData;

        ((CERT *)pbHandshake)->bcbClist24  = 0;
        ((CERT *)pbHandshake)->bcbMSBClist = 0;
        ((CERT *)pbHandshake)->bcbLSBClist = 0;

        cbHandshake = sizeof(SHSH) + CB_SSL3_CERT_VECTOR;

        // Fill in Handshake structure.
        SetHandshake(pbHandshake,
                     SSL3_HS_CERTIFICATE,
                     NULL,
                     CB_SSL3_CERT_VECTOR);

        // Update handshake hash objects.
        pctRet = UpdateHandshakeHash(pContext,
                                     pbHandshake,
                                     cbHandshake,
                                     FALSE);
        if(pctRet != PCT_ERR_OK)
        {
            goto cleanup;
        }

        pbHandshake += cbHandshake;
        cbMessage += cbHandshake;
    }

    if(fClientAuth && pbClientCert != NULL)
    {
        memcpy(&((CERT *)pbHandshake)->bcbCert24,
               pbClientCert,
               cbClientCert);

        ((CERT *)pbHandshake)->bcbClist24  = MS24BOF(cbClientCert);
        ((CERT *)pbHandshake)->bcbMSBClist = MSBOF(cbClientCert);
        ((CERT *)pbHandshake)->bcbLSBClist = LSBOF(cbClientCert);

        cbHandshake = sizeof(SHSH) + CB_SSL3_CERT_VECTOR + cbClientCert;

        // Fill in Handshake structure.
        SetHandshake(pbHandshake,
                     SSL3_HS_CERTIFICATE,
                     NULL,
                     cbHandshake - sizeof(SHSH));

        // Update handshake hash objects.
        pctRet = UpdateHandshakeHash(pContext,
                                     pbHandshake,
                                     cbHandshake,
                                     FALSE);
        if(pctRet != PCT_ERR_OK)
        {
            goto cleanup;
        }

        pbHandshake += cbHandshake;
        cbMessage += cbHandshake;
    }

    // Build ClientKeyExchange message.
    {
        SetHandshake(pbHandshake,
                     SSL3_HS_CLIENT_KEY_EXCHANGE,
                     pContext->pbEncryptedKey,
                     pContext->cbEncryptedKey);

        cbHandshake = sizeof(SHSH) + pContext->cbEncryptedKey;

        SPExternalFree(pContext->pbEncryptedKey);
        pContext->pbEncryptedKey = NULL;
        pContext->cbEncryptedKey = 0;

        // Update handshake hash objects.
        pctRet = UpdateHandshakeHash(pContext,
                                     pbHandshake,
                                     cbHandshake,
                                     FALSE);
        if(pctRet != PCT_ERR_OK)
        {
            goto cleanup;
        }

        pbHandshake += cbHandshake;
        cbMessage += cbHandshake;
    }

    // Build CertificateVerify message.
    if(fClientAuth && pbClientCert != NULL)
    {
        pctRet = BuildCertVerify(pContext, pbHandshake, &cbHandshake);
        if(pctRet != PCT_ERR_OK)
        {
            SP_LOG_RESULT(pctRet);
            goto cleanup;
        }

        // Update handshake hash objects.
        pctRet = UpdateHandshakeHash(pContext,
                                     pbHandshake,
                                     cbHandshake,
                                     FALSE);
        if(pctRet != PCT_ERR_OK)
        {
            goto cleanup;
        }

        pbHandshake += cbHandshake;
        cbMessage += cbHandshake;
    }

    // Add record header and encrypt handshake messages.
    pctRet = SPSetWrap(pContext,
            pbMessage,
            SSL3_CT_HANDSHAKE,
            cbMessage,
            TRUE,
            &cbDataOut);

    if(pctRet != PCT_ERR_OK)
    {
        SP_LOG_RESULT(pctRet);
        goto cleanup;
    }

    // Update buffer length.
    pCommOutput->cbData += cbDataOut;

    SP_ASSERT(pCommOutput->cbData <= pCommOutput->cbBuffer);


    // Build the ChangeCipherSpec and Finished messages.
    {
        pctRet = BuildCCSAndFinishMessage(pContext, pCommOutput, TRUE);
        if(pctRet != PCT_ERR_OK)
        {
            SP_LOG_RESULT(pctRet);
            goto cleanup;
        }
    }

    // Advance state machine.
    pContext->State = SSL3_STATE_CLIENT_FINISH;

    pctRet = PCT_ERR_OK;

cleanup:

    SP_RETURN(pctRet);
}

SP_STATUS
SPGenerateCloseNotify(
    PSPContext  pContext,
    PSPBuffer   pCommOutput)
{
    PBYTE pbMessage = NULL;
    DWORD cbMessage;
    DWORD cbDataOut;
    SP_STATUS pctRet;

    SP_BEGIN("SPGenerateCloseNotify");

    if((pContext == NULL) ||
       (pCommOutput == NULL))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    //
    // Estimate size of the message.
    //

    cbMessage = sizeof(SWRAP) +
                CB_SSL3_ALERT_ONLY +
                SP_MAX_DIGEST_LEN +
                SP_MAX_BLOCKCIPHER_SIZE;


    //
    // Allocate memory for the message.
    //

    if(pCommOutput->pvBuffer)
    {
        // Application has allocated memory.
        if(pCommOutput->cbBuffer < cbMessage)
        {
            pCommOutput->cbData = cbMessage;
            return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        }
    }
    else
    {
        // Schannel is to allocate memory.
        pCommOutput->cbBuffer = cbMessage;
        pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
        if(pCommOutput->pvBuffer == NULL)
        {
            SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }
    }
    pCommOutput->cbData = 0;

    //
    // Build alert message.
    //

    pbMessage = pCommOutput->pvBuffer;

    // Build alert message.
    BuildAlertMessage(pbMessage,
                      SSL3_ALERT_WARNING,
                      SSL3_ALERT_CLOSE_NOTIFY);

    // Build record header and encrypt message.
    pctRet = SPSetWrap( pContext,
                        pbMessage,
                        SSL3_CT_ALERT,
                        CB_SSL3_ALERT_ONLY,
                        TRUE,
                        &cbDataOut);

    if(pctRet != PCT_ERR_OK)
    {
        SP_RETURN(SP_LOG_RESULT(pctRet));
    }

    // Update buffer length.
    pCommOutput->cbData += cbDataOut;

    SP_ASSERT(pCommOutput->cbData <= pCommOutput->cbBuffer);

    pContext->State = SP_STATE_SHUTDOWN;

    SP_RETURN(PCT_ERR_OK);
}


/*
***************************************************************************
* SPProcessMessage
* This is the main function which parses and stores the incoming messages
* from the wire.
****************************************************************************
*/

SP_STATUS 
SPProcessMessage(
    PSPContext pContext,
    BYTE bContentType,
    PBYTE pbMsg,
    DWORD cbMsg)
{
    SP_STATUS pctRet = PCT_ERR_ILLEGAL_MESSAGE;
    DWORD dwState = pContext->State;

//     enum {
//         change_cipher_spec(20), alert(21), handshake(22),
//         application_data(23), (255)
//     } ContentType;


    switch(bContentType)
    {
        case SSL3_CT_ALERT:
            DebugLog((DEB_TRACE, "Alert Message:\n"));

            pctRet = ParseAlertMessage(pContext,
                                        pbMsg,
                                        cbMsg);

            break;


        case SSL3_CT_CHANGE_CIPHER_SPEC:
            DebugLog((DEB_TRACE, "Change Cipher Spec:\n"));
            if(SSL3_STATE_RESTART_CCS == dwState ||
               SSL3_STATE_CLIENT_FINISH == dwState)
            {
                pctRet = Ssl3HandleCCS(
                                    pContext,
                                    pbMsg,
                                    cbMsg);

                if (PCT_ERR_OK == pctRet)
                {
                    if(SSL3_STATE_RESTART_CCS == dwState)
                        pContext->State = SSL3_STATE_RESTART_SERVER_FINISH;
                }
            }
            else if(SSL3_STATE_CLIENT_KEY_XCHANGE == dwState ||
                    SSL3_STATE_CERT_VERIFY == dwState ||
                    SSL3_STATE_RESTART_SER_HELLO == dwState)
            {
                pctRet = Ssl3HandleCCS(
                                    pContext,
                                    pbMsg,
                                    cbMsg);

                if (PCT_ERR_OK == pctRet)
                {
                    if(SSL3_STATE_RESTART_SER_HELLO == dwState)
                    {
                          pContext->State = SSL3_STATE_SER_RESTART_CHANGE_CIPHER_SPEC;
                    }
                }

            }

            else
            {
                pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
            }
            break;


        case UNI_STATE_RECVD_UNIHELLO:
            {
                DebugLog((DEB_TRACE, "Unified Hello:\n"));

                pctRet = Ssl3SrvHandleUniHello(pContext, pbMsg, cbMsg);
                if (SP_FATAL(pctRet))
                {
                    pContext->State = PCT1_STATE_ERROR;
                }
            }
            break;


        case SSL3_CT_HANDSHAKE:
            {
                DWORD dwcb;

                if(pContext->State == SP_STATE_CONNECTED)
                {
                    //We may be  getting a REDO message
                    DebugLog((DEB_WARN, "May be a ReDO"));
                    pContext->State = SSL3_STATE_CLIENT_HELLO;
                }


                //Since multiple handshake can be put into on Record
                //layer- we have to do this loop-here.
                do
                {
                    if(cbMsg < sizeof(SHSH))
                        break;
                    dwcb = ((INT)pbMsg[1] << 16) + ((INT)pbMsg[2] << 8) + (INT)pbMsg[3];
                    if(sizeof(SHSH) + dwcb > cbMsg)
                        break;
                    pctRet = SPProcessHandshake(pContext, pbMsg, dwcb + sizeof(SHSH));
                    CHECK_PCT_RET_BREAK(pctRet);
                    cbMsg -= dwcb + sizeof(SHSH);
                    pbMsg += dwcb + sizeof(SHSH);
                } while(cbMsg > 0);
            }

            break;

        default:
            DebugLog((DEB_WARN, "Error in protocol, dwState is %lx\n", dwState));
            pContext->State = PCT1_STATE_ERROR;
            break;
    }
    if (pctRet & PCT_INT_DROP_CONNECTION)
    {
        pContext->State &= ~ SP_STATE_CONNECTED;
    }

    return(pctRet);
}


/*
***************************************************************************
* Helper function to make connected state for ssl3
****************************************************************************
*/
void Ssl3StateConnected(PSPContext pContext)
{
    pContext->State = SP_STATE_CONNECTED;
    pContext->DecryptHandler = Ssl3DecryptHandler;
    pContext->Encrypt = Ssl3EncryptMessage;
    pContext->Decrypt = Ssl3DecryptMessage;
    pContext->GetHeaderSize = Ssl3GetHeaderSize;
    SPContextClean(pContext);
}

/*
***************************************************************************
* SPProcessHandshake, Process all the handshake messages.
****************************************************************************
*/

SP_STATUS SPProcessHandshake(
    PSPContext  pContext,
    PBYTE       pb,
    DWORD       dwcb)
{
    SP_STATUS   pctRet;
    SHSH *      pshsh;
    DWORD       cbHandshake;

    //
    // char HandshakeType;
    // char Length24
    // char Length16
    // char Length08
    // <actual handshake message>
    //

    SP_BEGIN("SPProcessHandshake");

    if(pContext == NULL || pb == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    if(dwcb < sizeof(SHSH))
    {
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    pshsh = (SHSH *)pb;

    DebugLog((DEB_TRACE, "Protocol:%x, Message:%x, State:%x\n",
              pContext->dwProtocol,
              pshsh->typHS,
              pContext->State));

    cbHandshake = ((DWORD)pshsh->bcb24 << 16) +
                  ((DWORD)pshsh->bcbMSB << 8) +
                   (DWORD)pshsh->bcbLSB;

    if(dwcb < sizeof(SHSH) + cbHandshake)
    {
        SP_RETURN(PCT_INT_INCOMPLETE_MSG);
    }

    if(pContext->dwProtocol & SP_PROT_CLIENTS)
    {
        //
        // Handle client-side handshake states.
        //

        switch((pshsh->typHS << 16) | (pContext->State & 0xffff) )
        {
            case  (SSL3_HS_SERVER_HELLO << 16) | SSL3_STATE_CLIENT_HELLO:
            case  (SSL3_HS_SERVER_HELLO << 16) | UNI_STATE_CLIENT_HELLO:
            {
                BOOL fRestart;

                DebugLog((DEB_TRACE, "Server Hello:\n"));

                pctRet = SPDigestServerHello(pContext, (PUCHAR) pb, dwcb, &fRestart);
                if(PCT_ERR_OK != pctRet)
                {
                    SP_LOG_RESULT(pctRet);
                    break;
                }

                if(fRestart)
                {
                    pContext->State = SSL3_STATE_RESTART_CCS;
                }
                else
                {
                    pContext->State = SSL3_STATE_SERVER_HELLO ;
                }
                pContext->fCertReq = FALSE;

                break;
            }

            case (SSL3_HS_CERTIFICATE << 16) | SSL3_STATE_SERVER_HELLO:
            {
                DebugLog((DEB_TRACE, "Server Certificate:\n"));

                // Process server Certificate message.
                pctRet = SpDigestRemoteCertificate(pContext, pb, dwcb);
                if(pctRet != PCT_ERR_OK)
                {
                    SP_LOG_RESULT(pctRet);
                    break;
                }

                // Automatically validate server certificate if appropriate
                // context flag is set.
                pctRet = AutoVerifyServerCertificate(pContext);
                if(pctRet != PCT_ERR_OK)
                {
                    SP_LOG_RESULT(pctRet);
                    break;
                }

                pContext->State = SSL3_STATE_SERVER_CERTIFICATE ;
                break;

            }

            case (SSL3_HS_SERVER_KEY_EXCHANGE <<  16) | SSL3_STATE_SERVER_CERTIFICATE:
            {
                DebugLog((DEB_TRACE, "Key Exchange:\n"));

                if((pContext->dwRequestedCF & pContext->RipeZombie->dwCF) != (pContext->dwRequestedCF))
                {
                    if((pContext->dwRequestedCF & CF_FASTSGC) != 0)
                    {
                        pContext->State = SSL3_HS_SERVER_KEY_EXCHANGE;
                        pctRet = PCT_ERR_OK;
                        break;
                    }
                }

                // Store the server key exchange value in the context. This
                // will be processed later when the ServerHelloDone message
                // is received. This is necessary because Fortezza needs to
                // process the CertificateRequest message before building the
                // ClientKeyExchange value.
                pContext->cbServerKeyExchange = dwcb - sizeof(SHSH);
                pContext->pbServerKeyExchange = SPExternalAlloc(pContext->cbServerKeyExchange);
                if(NULL == pContext->pbServerKeyExchange)
                {
                    SP_RETURN(SEC_E_INSUFFICIENT_MEMORY);
                }
                CopyMemory(pContext->pbServerKeyExchange,
                           pb + sizeof(SHSH),
                           pContext->cbServerKeyExchange);

                pContext->State = SSL3_HS_SERVER_KEY_EXCHANGE ;
                pctRet = PCT_ERR_OK;
                break;
            }

            case (SSL3_HS_CERTIFICATE_REQUEST << 16)| SSL3_HS_SERVER_KEY_EXCHANGE:
            case (SSL3_HS_CERTIFICATE_REQUEST << 16)| SSL3_STATE_SERVER_CERTIFICATE:
            {
                DebugLog((DEB_TRACE, "Certificate Request:\n"));

                if((pContext->dwRequestedCF & pContext->RipeZombie->dwCF) != (pContext->dwRequestedCF))
                {
                    if((pContext->dwRequestedCF & CF_FASTSGC) != 0)
                    {
                        pContext->State = SSL3_STATE_SERVER_CERTREQ;
                        pctRet = PCT_ERR_OK;
                        break;
                    }
                }

                pctRet = ParseCertificateRequest(pContext, pb, dwcb);
                CHECK_PCT_RET_BREAK(pctRet);

                pctRet = Ssl3CheckForExistingCred(pContext);

                if(pctRet == SEC_E_INCOMPLETE_CREDENTIALS)
                {
                    pContext->fInsufficientCred = TRUE;

                    // Process all the messages and then return the warning...
                    pctRet = PCT_ERR_OK;
                }
                if(pctRet == SEC_I_INCOMPLETE_CREDENTIALS)
                {
                    // we didn't have a cert, so we proceed, expecting
                    // to send a no cert alert
                    pctRet = PCT_ERR_OK;
                }
                CHECK_PCT_RET_BREAK(pctRet);

                pContext->fCertReq = TRUE;
                pContext->State = SSL3_STATE_SERVER_CERTREQ ;
                break;
            }

            case (SSL3_HS_SERVER_HELLO_DONE << 16) | SSL3_HS_SERVER_KEY_EXCHANGE:
            case (SSL3_HS_SERVER_HELLO_DONE << 16) | SSL3_STATE_SERVER_CERTIFICATE:
            case (SSL3_HS_SERVER_HELLO_DONE << 16) | SSL3_STATE_SERVER_CERTREQ:
            {
                DebugLog((DEB_TRACE, "Server Hello Done:\n"));

                if(dwcb > sizeof(SHSH))
                {
                    pctRet = SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG);
                    break;
                }

                if((pContext->dwRequestedCF & pContext->RipeZombie->dwCF) != (pContext->dwRequestedCF))
                {
                    if((pContext->dwRequestedCF & CF_FASTSGC) != 0)
                    {
                        pContext->State = SSL3_STATE_GEN_HELLO_REQUEST;
                        pContext->RipeZombie->dwCF = pContext->dwRequestedCF;
                        pctRet = PCT_ERR_OK;
                        SPContextClean(pContext);
                        break;
                    }
                }

                pctRet = SPDigestSrvKeyX(pContext,
                                         pContext->pbServerKeyExchange,
                                         pContext->cbServerKeyExchange);

                CHECK_PCT_RET_BREAK(pctRet);
                if(pContext->pbServerKeyExchange)
                {
                    SPExternalFree(pContext->pbServerKeyExchange);
                    pContext->pbServerKeyExchange = NULL;
                }

                pContext->State = SSL3_STATE_GEN_SERVER_HELLORESP;

                if(TRUE == pContext->fInsufficientCred)
                {
                    pctRet = SEC_I_INCOMPLETE_CREDENTIALS;
                }
                else
                {
                    pctRet = PCT_ERR_OK;
                }
                break;
            }

            case (SSL3_HS_FINISHED << 16) | SSL3_STATE_RESTART_SERVER_FINISH:
                DebugLog((DEB_TRACE, "ServerFinished (reconnect):\n"));

                pctRet = Ssl3HandleFinish(pContext, pb, dwcb, FALSE);
                if(PCT_ERR_OK != pctRet)
                {
                    break;
                }

                pContext->State = SSL3_STATE_GEN_CLIENT_FINISH;
                
                break;

            case (SSL3_HS_FINISHED << 16) | SSL3_STATE_CHANGE_CIPHER_SPEC_CLIENT:
                DebugLog((DEB_TRACE, "ServerFinished (full):\n"));

                pctRet = Ssl3HandleFinish(pContext, pb, dwcb, FALSE);
                if(PCT_ERR_OK != pctRet)
                {
                    break;
                }

                // Initiate SGC renegotiation if appropriate.
                if((pContext->dwRequestedCF & pContext->RipeZombie->dwCF) != (pContext->dwRequestedCF))
                {
                    if((pContext->dwRequestedCF & CF_FASTSGC) == 0)
                    {
                        SPContextClean(pContext);
                        pContext->State = SSL3_STATE_GEN_HELLO_REQUEST;
                        pContext->RipeZombie->dwCF = pContext->dwRequestedCF;
                        pctRet = PCT_ERR_OK;
                        break;
                    }
                }

                Ssl3StateConnected(pContext);

                // We add to cache because this is where we are finishing
                // a normal connect.
                SPCacheAdd(pContext);

                break;

            default:
                DebugLog((DEB_TRACE, "***********ILLEGAL ********\n"));
                if(pContext->RipeZombie->fProtocol & SP_PROT_TLS1)
                {
                    SetTls1Alert(pContext, TLS1_ALERT_FATAL, TLS1_ALERT_UNEXPECTED_MESSAGE);
                }
                pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
        }
    }
    else
    {

        //
        // Handle server-side handshake states.
        //

        switch((pshsh->typHS << 16) | (pContext->State & 0xffff) )
        {
            case (SSL3_HS_CLIENT_HELLO << 16) | SSL3_STATE_RENEGOTIATE:
                DebugLog((DEB_TRACE, "ClientHello After REDO:\n"));

#if 1
                // We need to do a full handshake, so lose the cache entry.
                SPCacheDereference(pContext->RipeZombie);
                pContext->RipeZombie = NULL;

                pctRet = SPSsl3SrvHandleClientHello(pContext, pb, FALSE);
                pContext->Flags &= ~CONTEXT_FLAG_MAPPED;
                if(PCT_ERR_OK == pctRet)
                {
                    pContext->State = SSL3_STATE_GEN_REDO;
                }
#else
                // Allow reconnects during redo, for testing purposes only
                pctRet = SPSsl3SrvHandleClientHello(pContext, pb, TRUE);
                pContext->Flags &= ~CONTEXT_FLAG_MAPPED;
#endif

                break;

            case (SSL3_HS_CLIENT_HELLO << 16) | SSL2_STATE_SERVER_HELLO:
                DebugLog((DEB_TRACE, "ClientHello after fast SGC accepted:\n"));

                // We need to do a full handshake, so lose the cache entry.
                SPCacheDereference(pContext->RipeZombie);
                pContext->RipeZombie = NULL;

                pctRet = SPSsl3SrvHandleClientHello(pContext, pb, FALSE);
                break;

            case (SSL3_HS_CLIENT_HELLO << 16):
                DebugLog((DEB_TRACE, "ClientHello:\n"));
                pctRet = SPSsl3SrvHandleClientHello(pContext, pb, TRUE);
                break;

            case (SSL3_HS_CLIENT_KEY_EXCHANGE << 16) | SSL2_STATE_SERVER_HELLO:
            case (SSL3_HS_CLIENT_KEY_EXCHANGE << 16) | SSL3_STATE_NO_CERT_ALERT:
            case (SSL3_HS_CLIENT_KEY_EXCHANGE << 16) | SSL2_STATE_CLIENT_CERTIFICATE:
                DebugLog((DEB_TRACE, "Client Key Exchange:\n"));
                pctRet = ParseKeyExchgMsg(pContext, pb) ;
                CHECK_PCT_RET_BREAK(pctRet);

                if(PCT_ERR_OK == pctRet)
                    pContext->State = SSL3_STATE_CLIENT_KEY_XCHANGE;
                if(!pContext->fCertReq)
                    pContext->State = SSL3_STATE_CLIENT_KEY_XCHANGE;

                break;

            case ( SSL3_HS_CERTIFICATE << 16) | SSL2_STATE_SERVER_HELLO:
                 DebugLog((DEB_TRACE, "Client Certificate:\n"));

                 pctRet = SpDigestRemoteCertificate(pContext, pb, dwcb);
                 CHECK_PCT_RET_BREAK(pctRet);
                 if(PCT_ERR_OK == pctRet)
                    pContext->State = SSL2_STATE_CLIENT_CERTIFICATE ;
                 break;

            case (SSL3_HS_CERTIFICATE_VERIFY << 16) | SSL3_STATE_CLIENT_KEY_XCHANGE:
                DebugLog((DEB_TRACE, "Certificate Verify :\n"));

                pctRet = HandleCertVerify(pContext, pb, dwcb);
                if(pctRet != PCT_ERR_OK)
                {
                    break;
                }

                pctRet = SPContextDoMapping(pContext);
                pContext->State = SSL3_STATE_CERT_VERIFY;
                break;

            case (SSL3_HS_FINISHED << 16) | SSL3_STATE_SER_RESTART_CHANGE_CIPHER_SPEC:
                DebugLog((DEB_TRACE, "Finished(client) Restart :\n"));

                pctRet = Ssl3HandleFinish(pContext, pb, dwcb, TRUE);
                if(pctRet != PCT_ERR_OK)
                {
                    break;
                }

                Ssl3StateConnected(pContext);

                break;

            case (SSL3_HS_FINISHED << 16) | SSL3_STATE_CHANGE_CIPHER_SPEC_SERVER:
                DebugLog((DEB_TRACE, "Finished(Client):\n"));
                pctRet = Ssl3HandleFinish(pContext, pb, dwcb, TRUE);
                if(PCT_ERR_OK == pctRet)
                {
                    pContext->State = SSL3_STATE_GEN_SERVER_FINISH;
                }
                break;

            default:
                DebugLog((DEB_TRACE, "***********ILLEGAL ********\n"));
                if(pContext->dwProtocol & SP_PROT_TLS1)
                {
                    SetTls1Alert(pContext, TLS1_ALERT_FATAL, TLS1_ALERT_UNEXPECTED_MESSAGE);
                }
                pctRet = SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);

                break;
        }
    }

    if(pctRet == PCT_ERR_OK || pctRet == SEC_I_INCOMPLETE_CREDENTIALS)
    {
        if(pContext->cbClientHello == 0)
        {
            if(UpdateHandshakeHash(pContext, pb, dwcb, FALSE) != PCT_ERR_OK)
            {
                pctRet = PCT_INT_INTERNAL_ERROR;
            }
        }
    }

    SP_RETURN(pctRet);
}




/*
***************************************************************************
* SPGenerateResponse, All the messages are built from this function.
****************************************************************************
*/
SP_STATUS SPGenerateResponse(
    PSPContext pContext,
    PSPBuffer pCommOutput) //Out
{
    SP_STATUS pctRet = PCT_ERR_OK;

    DebugLog((DEB_TRACE, "**********Protocol***** %x\n", pContext->RipeZombie->fProtocol));
    switch(pContext->State)
    {
    case TLS1_STATE_ERROR:
        // TLS1 Alert message
        DebugLog((DEB_TRACE, "GEN TLS1 Alert Message:\n"));
        pctRet = SPBuildTlsAlertMessage(pContext, pCommOutput);
        pContext->State = SP_STATE_SHUTDOWN;
        break;

    case SP_STATE_SHUTDOWN_PENDING:
        DebugLog((DEB_TRACE, "GEN Close Notify:\n"));
        pctRet = SPGenerateCloseNotify(pContext, pCommOutput);
        break;

    case SP_STATE_SHUTDOWN:
        return PCT_INT_EXPIRED;

    case  SSL3_STATE_GEN_SERVER_HELLORESP:
        DebugLog((DEB_TRACE, "GEN Server Hello Response:\n"));
        pctRet = SPGenerateSHResponse(pContext, pCommOutput);
        break;

    case  SSL3_STATE_GEN_HELLO_REQUEST:
        DebugLog((DEB_TRACE, "GEN Hello Request:\n"));
         //Temp Disabling Reconnect during REDO
        if(!SPCacheClone(&pContext->RipeZombie))
        {
            pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
            break;
        }
        if(pContext->RipeZombie->fProtocol == SP_PROT_SSL3_CLIENT)
        {
            pctRet =  GenerateSsl3ClientHello(pContext, pCommOutput);
        }
        else
        {
            pctRet =  GenerateTls1ClientHello(pContext, pCommOutput, SP_PROT_TLS1_CLIENT);
        }

        pContext->Flags &= ~CONTEXT_FLAG_MAPPED;

        pContext->State = SSL3_STATE_CLIENT_HELLO;

        break;

    case SSL3_STATE_GEN_CLIENT_FINISH:
        {
            DebugLog((DEB_TRACE, "GEN Client Finish:\n"));

            pctRet = SPBuildCCSAndFinish(pContext, pCommOutput);
            if(PCT_ERR_OK == pctRet)
            {
                Ssl3StateConnected(pContext);
            }
        }
        break;


    /*-------------------------------------SERVER SIDE------------------------------------*/


    case  SSL3_STATE_GEN_SERVER_FINISH:
        DebugLog((DEB_TRACE, "GEN Server Finish:\n"));
        pctRet = SPBuildCCSAndFinish(pContext, pCommOutput);
        /* Cache Session Here */
        if(pctRet == PCT_ERR_OK)
        {
            Ssl3StateConnected(pContext);
            SPCacheAdd(pContext);
        }
        break;

    case  SSL3_STATE_GEN_SERVER_HELLO:       // Generate the response
        DebugLog((DEB_TRACE, "GEN Server hello:\n"));
        pctRet = SPSsl3SrvGenServerHello(pContext, pCommOutput);
        break;

    case SSL3_STATE_GEN_SERVER_HELLO_RESTART:
        pctRet = SPSsl3SrvGenRestart(pContext, pCommOutput);
        break;


    case SP_STATE_CONNECTED:
        // We were called from a connected state, so the application
        // must be requesting a redo.
        if(pContext->RipeZombie->fProtocol & SP_PROT_SERVERS)
        {
            // Build a HelloRequest message.
            DebugLog((DEB_TRACE, "GEN Hello Request:\n"));
            pctRet = SPBuildHelloRequest(pContext, pCommOutput);
        }
        else
        {
            // Build a ClientHello message.
            DebugLog((DEB_TRACE, "GEN renegotiate Client Hello\n"));
            pctRet = GenerateHello(pContext, pCommOutput, TRUE);

            // Clear flag, so that the context gets re-transferred when
            // handshake completes.
            pContext->Flags &= ~CONTEXT_FLAG_MAPPED;
        }

        break;

    case SSL3_STATE_GEN_REDO:
        DebugLog((DEB_TRACE, "GEN Server hello ( REDO ):\n"));
        // We processed a client hello from the decrypt handler,
        // so generate a server hello.
        pctRet = SPSsl3SrvGenServerHello(pContext, pCommOutput);
        break;

    default:
        break;
    }
    if (pctRet & PCT_INT_DROP_CONNECTION)
    {
        pContext->State &= ~ SP_STATE_CONNECTED;
    }

    return(pctRet);
}



/*
***************************************************************************
* FNoInputState Are we in a state  that all the inputs are handled and
* waiting for Response generation RETURN TRUE if yes
****************************************************************************
*/
BOOL FNoInputState(DWORD dwState)
{
    switch(dwState)
    {
        default:
            return(FALSE);

        case SSL3_STATE_GEN_HELLO_REQUEST:
        case SSL3_STATE_GEN_SERVER_HELLORESP:
        case SSL3_STATE_GEN_SERVER_FINISH:
        case SSL3_STATE_GEN_REDO:
        case SP_STATE_CONNECTED:
        case TLS1_STATE_ERROR:
        case SP_STATE_SHUTDOWN_PENDING:

            return(TRUE);
    }
}

/*
***************************************************************************
* SPBuildHelloRequest
*
* Build hello-request message, this is done, when server sees a GET and the
* GET object needs client-authentication.
* this may be needed when the server thinks that the session is for a long
* time or lots of bytes gon down the wire, to RENEGOTIATE the keys
****************************************************************************
*/

SP_STATUS
SPBuildHelloRequest(
    PSPContext pContext,
    PSPBuffer  pCommOutput)
{
    PBYTE pbMessage = NULL;
    DWORD cbMessage;
    PBYTE pbHandshake = NULL;
    DWORD cbHandshake;
    BOOL  fAllocated = FALSE;
    SP_STATUS pctRet;
    DWORD cbDataOut;

    // Estimate size of HelloRequest message.
    cbMessage = sizeof(SWRAP) +
                sizeof(SHSH) +
                SP_MAX_DIGEST_LEN +
                SP_MAX_BLOCKCIPHER_SIZE;

    if(pCommOutput->pvBuffer)
    {
        // Application has allocated memory.
        if(pCommOutput->cbBuffer < cbMessage)
        {
            pCommOutput->cbData = cbMessage;
            return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        }
        fAllocated = TRUE;
    }
    else
    {
        // Schannel is to allocate memory.
        pCommOutput->cbBuffer = cbMessage;
        pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
        if(pCommOutput->pvBuffer == NULL)
        {
            return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        }
    }
    pCommOutput->cbData = 0;

    pbMessage = pCommOutput->pvBuffer;

    pbHandshake = pbMessage + sizeof(SWRAP);
    cbHandshake = sizeof(SHSH);

    // Fill in Handshake structure.
    SetHandshake(pbHandshake,
                 SSL3_HS_HELLO_REQUEST,
                 NULL,
                 0);

    // Update handshake hash objects.
    pctRet = UpdateHandshakeHash(pContext,
                                 pbHandshake,
                                 cbHandshake,
                                 FALSE);
    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }

    // Add record header and encrypt handshake messages.
    pctRet = SPSetWrap(pContext,
            pbMessage,
            SSL3_CT_HANDSHAKE,
            cbHandshake,
            FALSE,
            &cbDataOut);

    // Update buffer length.
    pCommOutput->cbData += cbDataOut;

    SP_ASSERT(pCommOutput->cbData <= pCommOutput->cbBuffer);

    return pctRet;
}


/*
***************************************************************************

****************************************************************************
*/

SP_STATUS
SPSsl3SrvGenServerHello(
    PSPContext pContext,
    PSPBuffer  pCommOutput)
{
    SP_STATUS pctRet;
    PSPCredentialGroup pCred;
    BOOL  fAllocated = FALSE;

    PBYTE pbServerCert = NULL;
    DWORD cbServerCert = 0;

    PBYTE pbIssuerList = NULL;
    DWORD cbIssuerList = 0;

    PBYTE pbMessage = NULL;
    DWORD cbMessage;
    PBYTE pbHandshake = NULL;
    DWORD cbHandshake;
    DWORD cbDataOut;

    DWORD cbServerExchange;

    BOOL fClientAuth = ((pContext->Flags & CONTEXT_FLAG_MUTUAL_AUTH) != 0);

    if(pCommOutput == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    // Get pointer to server certificate chain.
    pCred  = pContext->RipeZombie->pServerCred;
    pbServerCert = pContext->RipeZombie->pActiveServerCred->pbSsl3SerializedChain;
    cbServerCert = pContext->RipeZombie->pActiveServerCred->cbSsl3SerializedChain;

    if(pbServerCert == NULL)
    {
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto cleanup;
    }

    //
    // Estimate size of the ServerHello message group, which includes the
    // ServerHello, ServerCertificate, ServerKeyExchange, CertificateRequest,
    // and ServerHelloDone messages.
    //

    cbMessage =  sizeof(SWRAP) +        // ServerHello (plus encryption goo)
                 sizeof(SSH) +
                 SP_MAX_DIGEST_LEN +
                 SP_MAX_BLOCKCIPHER_SIZE;

    cbMessage += sizeof(SHSH) +         // ServerCertificate
                 CB_SSL3_CERT_VECTOR +
                 cbServerCert;

    cbMessage += sizeof(SHSH);          // ServerHelloDone

    // Get pointer to key exchange system.

    if((pContext->pKeyExchInfo == NULL) || ((pContext->pKeyExchInfo->fProtocol & SP_PROT_SSL3TLS1_CLIENTS) == 0))
    {
        pctRet = SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
        goto cleanup;
    }

    pctRet = pContext->pKeyExchInfo->System->GenerateServerExchangeValue(
                        pContext,
                        NULL,
                        &cbServerExchange);
    if(pctRet != PCT_ERR_OK)
    {
        goto cleanup;
    }
    if(pContext->fExchKey)
    {
        cbMessage += sizeof(SHSH) + cbServerExchange;
    }

    // Add in length of CertificateRequest message.
    if(fClientAuth)
    {
        if(g_fSendIssuerList)
        {
            UpdateAndDuplicateIssuerList(pCred, &pbIssuerList, &cbIssuerList);
        }

        cbMessage += sizeof(SHSH) + 
                     1 + SSL3_CERTTYPE_MAX_COUNT +
                     2 + cbIssuerList;
    }


    pContext->fCertReq = fClientAuth;

    DebugLog((DEB_TRACE, "Server hello message %x\n", cbMessage));


    //
    // Allocate memory for the ServerHello message group.
    //

    if(pCommOutput->pvBuffer)
    {
        // Application has allocated memory.
        if(pCommOutput->cbBuffer < cbMessage)
        {
            pCommOutput->cbData = cbMessage;
            pctRet = SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
            goto cleanup;
        }
        fAllocated = TRUE;
    }
    else
    {
        // Schannel is to allocate memory.
        pCommOutput->cbBuffer = cbMessage;
        pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
        if(pCommOutput->pvBuffer == NULL)
        {
            pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            goto cleanup;
        }
    }
    pCommOutput->cbData = 0;

    // Keep pointer to record structure. This will represent all of the
    // handshake messages.
    pbMessage = (PBYTE)pCommOutput->pvBuffer + pCommOutput->cbData;
    cbMessage = 0;

    pbHandshake = pbMessage + sizeof(SWRAP);


    // Generate the session ID (actually previously generated)
    pContext->RipeZombie->cbSessionID = CB_SSL3_SESSION_ID;

    // Generate internal values to make server hello
    pctRet = Ssl3GenerateRandom(pContext->rgbS3SRandom);
    if(!NT_SUCCESS(pctRet))
    {
        goto cleanup;
    }

    // Build ServerHello
    Ssl3BuildServerHello(pContext, pbHandshake);
    pbHandshake += sizeof(SSH);
    cbMessage   += sizeof(SSH);

    // Build ServerCertificate
    {
        memcpy(&((CERT *)pbHandshake)->bcbCert24,
               pbServerCert,
               cbServerCert);

        ((CERT *)pbHandshake)->bcbClist24  = MS24BOF(cbServerCert);
        ((CERT *)pbHandshake)->bcbMSBClist = MSBOF(cbServerCert);
        ((CERT *)pbHandshake)->bcbLSBClist = LSBOF(cbServerCert);

        cbHandshake = sizeof(SHSH) + CB_SSL3_CERT_VECTOR + cbServerCert;

        // Fill in Handshake structure.
        SetHandshake(pbHandshake,
                     SSL3_HS_CERTIFICATE,
                     NULL,
                     cbHandshake - sizeof(SHSH));

        pbHandshake += cbHandshake;
        cbMessage   += cbHandshake;
    }

    // Build ServerKeyExchange.
    if(pContext->fExchKey)
    {
        pctRet = pContext->pKeyExchInfo->System->GenerateServerExchangeValue(
                            pContext,
                            pbHandshake + sizeof(SHSH),
                            &cbServerExchange);
        if(pctRet != PCT_ERR_OK)
        {
            SP_LOG_RESULT(pctRet);
            goto cleanup;
        }
        SetHandshake(pbHandshake,  SSL3_HS_SERVER_KEY_EXCHANGE, NULL,  (WORD)cbServerExchange);

        pbHandshake += sizeof(SHSH) + cbServerExchange;
        cbMessage   += sizeof(SHSH) + cbServerExchange;
    }

    // Build CertificateRequest.
    if(fClientAuth)
    {
        pctRet = Ssl3BuildCertificateRequest(pbIssuerList,
                                             cbIssuerList,
                                             pbHandshake,
                                             &cbHandshake);
        if(pctRet != PCT_ERR_OK)
        {
            SP_LOG_RESULT(pctRet);
            goto cleanup;
        }

        pbHandshake += cbHandshake;
        cbMessage   += cbHandshake;
    }

    // Build ServerHelloDone.
    {
        BuildServerHelloDone(pbHandshake);

        pbHandshake += sizeof(SHSH);
        cbMessage   += sizeof(SHSH);
    }

    // Initialize handshake hashes and hash ClientHello message. This
    // must be done _after_ the ServerKeyExchange message is built,
    // so that the correct CSP context is used.
    pctRet = UpdateHandshakeHash(pContext,
                                 pContext->pClientHello,
                                 pContext->cbClientHello,
                                 TRUE);
    SPExternalFree(pContext->pClientHello);
    pContext->pClientHello  = NULL;
    pContext->cbClientHello = 0;
    if(pctRet != PCT_ERR_OK)
    {
        goto cleanup;
    }

    // Update handshake hash objects.
    pctRet = UpdateHandshakeHash(pContext,
                        pbMessage + sizeof(SWRAP),
                        cbMessage,
                        FALSE);
    if(pctRet != PCT_ERR_OK)
    {
        goto cleanup;
    }

    // Add record header and encrypt handshake messages.
    pctRet = SPSetWrap(pContext,
                       pbMessage,
                       SSL3_CT_HANDSHAKE,
                       cbMessage,
                       FALSE,
                       &cbDataOut);

    if(pctRet != PCT_ERR_OK)
    {
        SP_LOG_RESULT(pctRet);
        goto cleanup;
    }

    // Update buffer length.
    pCommOutput->cbData += cbDataOut;

    SP_ASSERT(pCommOutput->cbData <= pCommOutput->cbBuffer);

    // Advance state machine.
    pContext->State = SSL2_STATE_SERVER_HELLO;

    pctRet = PCT_ERR_OK;


cleanup:

    if(pctRet != PCT_ERR_OK && !fAllocated)
    {
        SPExternalFree(pCommOutput->pvBuffer);
        pCommOutput->pvBuffer =NULL;
    }

    if(pbIssuerList)
    {
        SPExternalFree(pbIssuerList);
    }

    return pctRet;
}


/*
***************************************************************************
****************************************************************************
*/

SP_STATUS
SPSsl3SrvGenRestart(
    PSPContext          pContext,
    PSPBuffer           pCommOutput)
{
    SP_STATUS   pctRet;
    PBYTE pbMessage = NULL;
    DWORD cbMessage;
    DWORD cbDataOut;
    BOOL  fAllocated = FALSE;

    if(pCommOutput == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    //
    // Estimate size of the restart ServerHello message group, which includes
    // the ServerHello, ChangeCipherSpec, and Finished messages.
    //

    cbMessage =  sizeof(SWRAP) +        // ServerHello (plus encryption goo)
                 sizeof(SSH) +
                 SP_MAX_DIGEST_LEN +
                 SP_MAX_BLOCKCIPHER_SIZE;

    cbMessage += sizeof(SWRAP) +                    // ChangeCipherSpec
                 CB_SSL3_CHANGE_CIPHER_SPEC_ONLY +
                 SP_MAX_DIGEST_LEN +
                 SP_MAX_BLOCKCIPHER_SIZE;

    cbMessage += sizeof(SWRAP) +                    // Finished
                 CB_SSL3_FINISHED_MSG_ONLY +
                 SP_MAX_DIGEST_LEN +
                 SP_MAX_BLOCKCIPHER_SIZE;

    DebugLog((DEB_TRACE, "Server hello message %x\n", cbMessage));

    if(pCommOutput->pvBuffer)
    {
        // Application has allocated memory.
        if(pCommOutput->cbBuffer < cbMessage)
        {
            pCommOutput->cbData = cbMessage;
            return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        }
        fAllocated = TRUE;
    }
    else
    {
        // Schannel is to allocate memory.
        pCommOutput->cbBuffer = cbMessage;
        pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
        if(pCommOutput->pvBuffer == NULL)
        {
            return (SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }
    }
    pCommOutput->cbData = 0;

    pbMessage = (PBYTE)pCommOutput->pvBuffer + pCommOutput->cbData;

    // Generate internal values to make server hello
    Ssl3GenerateRandom(pContext->rgbS3SRandom);

    // Make a new set of session keys.
    pctRet = MakeSessionKeys(pContext,
                             pContext->RipeZombie->hMasterProv,
                             pContext->RipeZombie->hMasterKey);
    if(pctRet != PCT_ERR_OK)
    {
        return SP_LOG_RESULT(pctRet);
    }

    // Initialize handshake hashes and hash ClientHello message.
    pctRet = UpdateHandshakeHash(pContext,
                                 pContext->pClientHello,
                                 pContext->cbClientHello,
                                 TRUE);
    SPExternalFree(pContext->pClientHello);
    pContext->pClientHello  = NULL;
    pContext->cbClientHello = 0;

    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }

    // Build ServerHello message body.
    Ssl3BuildServerHello(pContext, pbMessage + sizeof(SWRAP));

    // Update handshake hash objects.
    pctRet = UpdateHandshakeHash(pContext,
                                 pbMessage + sizeof(SWRAP),
                                 sizeof(SSH),
                                 FALSE);
    if(pctRet != PCT_ERR_OK)
    {
        return(pctRet);
    }

    // Build record header and encrypt message.
    pctRet = SPSetWrap(pContext,
            pbMessage,
            SSL3_CT_HANDSHAKE,
            sizeof(SSH),
            FALSE,
            &cbDataOut);

    if(pctRet != PCT_ERR_OK)
    {
        SPExternalFree(pCommOutput->pvBuffer);
        pCommOutput->pvBuffer = 0;
        return pctRet;
    }

    // Update buffer length.
    pCommOutput->cbData += cbDataOut;

    SP_ASSERT(pCommOutput->cbData <= pCommOutput->cbBuffer);


    pctRet = BuildCCSAndFinishMessage(pContext,
                                      pCommOutput,
                                      FALSE);
    if(pctRet != PCT_ERR_OK)
    {
        SPExternalFree(pCommOutput->pvBuffer);
        pCommOutput->pvBuffer = 0;
        return pctRet;
    }

    pContext->State =  SSL3_STATE_RESTART_SER_HELLO;

    return(PCT_ERR_OK);
}



/*
***************************************************************************
* SPSsl3SrvHandleClientHello
* Client-hello from ssl3 parsing the client hello
****************************************************************************
*/

SP_STATUS
SPSsl3SrvHandleClientHello(
    PSPContext pContext,
    PBYTE pb,
    BOOL fAttemptReconnect)
{
    BOOL  fRestart = FALSE;
    DWORD dwHandshakeLen;


    SP_BEGIN("SPSsl3SrvHandleClientHello");

    // Validate handshake type
    if(pb[0] != SSL3_HS_CLIENT_HELLO)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }

    dwHandshakeLen = ((INT)pb[1] << 16) +
                     ((INT)pb[2] << 8) +
                     (INT)pb[3];

    // Save the ClientHello message so we can hash it later, once
    // we know what algorithm and CSP we're using.
    if(pContext->pClientHello)
    {
        SPExternalFree(pContext->pClientHello);
    }
    pContext->cbClientHello = sizeof(SHSH) + dwHandshakeLen;
    pContext->pClientHello = SPExternalAlloc(pContext->cbClientHello);
    if(pContext->pClientHello == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
    }
    CopyMemory(pContext->pClientHello, pb, pContext->cbClientHello);
    pContext->dwClientHelloProtocol = SP_PROT_SSL3_CLIENT;

    pb += sizeof(SHSH);

    if(!Ssl3ParseClientHello(pContext, pb, dwHandshakeLen, fAttemptReconnect, &fRestart))
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_ILLEGAL_MSG));
    }

    if(fRestart)
    {
        pContext->State = SSL3_STATE_GEN_SERVER_HELLO_RESTART;
    }
    else
    {
        pContext->State = SSL3_STATE_GEN_SERVER_HELLO;
    }

    SP_RETURN(PCT_ERR_OK);
}



/*
***************************************************************************
* SPBuildCCSAndFinish
* This is a common nroutine for client/server. it builds the change cipher
* spec message and finished message.
****************************************************************************
*/

SP_STATUS
SPBuildCCSAndFinish(
    PSPContext pContext,        // in, out
    PSPBuffer  pCommOutput)     // out
{
    DWORD cbMessage;
    BOOL fClient;
    SP_STATUS pctRet;
    BOOL  fAllocated = FALSE;

    // Estimate size of the message group.
    cbMessage  = sizeof(SWRAP) +                    // ChangeCipherSpec
                 CB_SSL3_CHANGE_CIPHER_SPEC_ONLY +
                 SP_MAX_DIGEST_LEN +
                 SP_MAX_BLOCKCIPHER_SIZE;

    cbMessage += sizeof(SWRAP) +                    // Finished
                 CB_SSL3_FINISHED_MSG_ONLY +
                 SP_MAX_DIGEST_LEN +
                 SP_MAX_BLOCKCIPHER_SIZE;

    if(pCommOutput->pvBuffer)
    {
        // Application has allocated memory.
        if(pCommOutput->cbBuffer < cbMessage)
        {
            pCommOutput->cbData = cbMessage;
            return SP_LOG_RESULT(PCT_INT_BUFF_TOO_SMALL);
        }
        fAllocated = TRUE;
    }
    else
    {
        // Schannel is to allocate memory.
        pCommOutput->cbBuffer = cbMessage;
        pCommOutput->pvBuffer = SPExternalAlloc(cbMessage);
        if(pCommOutput->pvBuffer == NULL)
        {
            return (SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY));
        }
    }
    pCommOutput->cbData = 0;

    // Are we the client?
    if(pContext->RipeZombie->fProtocol & SP_PROT_SSL3TLS1_CLIENTS)
    {
        fClient = TRUE;
    }
    else
    {
        fClient = FALSE;
    }

    // Build messages.
    pctRet = BuildCCSAndFinishMessage(pContext,
                                    pCommOutput,
                                    fClient);
    if(pctRet != PCT_ERR_OK)
    {
        SPExternalFree(pCommOutput->pvBuffer);
        pCommOutput->pvBuffer = NULL;
    }
    return pctRet;

}


/*
***************************************************************************
* Ssl3SrvHandleUniHello:
*    we can get an UniHello from client-side, parse and digest the info
****************************************************************************
*/

SP_STATUS
Ssl3SrvHandleUniHello(
    PSPContext  pContext,
    PBYTE       pbMsg,
    DWORD       cbMsg)
{
    SP_STATUS           pctRet;
    PSsl2_Client_Hello  pHello = NULL;
    SPBuffer            Input;

    SP_BEGIN("Ssl3SrvHandleUniHello");

    if(pContext == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }

    if(pContext->pCredGroup == NULL)
    {
        SP_RETURN(SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR));
    }


    //
    // Decode the ClientHello message.
    //

    Input.pvBuffer = pbMsg;
    Input.cbData   = cbMsg;
    Input.cbBuffer = cbMsg;

    pctRet = Ssl2UnpackClientHello(&Input, &pHello);

    if(PCT_ERR_OK != pctRet)
    {
        goto Ret;
    }


    // Save the ClientHello message so we can hash it later, once
    // we know what algorithm and CSP we're using.
    if(pContext->pClientHello)
    {
        SPExternalFree(pContext->pClientHello);
    }
    pContext->cbClientHello = Input.cbData - sizeof(SSL2_MESSAGE_HEADER);
    pContext->pClientHello = SPExternalAlloc(pContext->cbClientHello);
    if(pContext->pClientHello == NULL)
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto Ret;
    }
    CopyMemory(pContext->pClientHello,
               (PUCHAR)Input.pvBuffer + sizeof(SSL2_MESSAGE_HEADER),
               pContext->cbClientHello);
    pContext->dwClientHelloProtocol = SP_PROT_SSL2_CLIENT;


    /* keep challenge around for later */
    CopyMemory( pContext->pChallenge,
                pHello->Challenge,
                pHello->cbChallenge);
    pContext->cbChallenge = pHello->cbChallenge;

    /* Initialize the "Client.random" from the challenge */
    FillMemory(pContext->rgbS3CRandom, CB_SSL3_RANDOM - pContext->cbChallenge, 0);

    CopyMemory(  pContext->rgbS3CRandom + CB_SSL3_RANDOM - pContext->cbChallenge,
                 pContext->pChallenge,
                 pContext->cbChallenge);


    //
    // We know that this isn't a reconnect, so allocate a new cache entry.
    //

    if(!SPCacheRetrieveNew(TRUE, 
                           pContext->pszTarget, 
                           &pContext->RipeZombie))
    {
        pctRet = SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
        goto Ret;
    }

    pContext->RipeZombie->fProtocol = pContext->dwProtocol;
    pContext->RipeZombie->dwCF      = pContext->dwRequestedCF;

    SPCacheAssignNewServerCredential(pContext->RipeZombie,
                                     pContext->pCredGroup);


    //
    // Determine cipher suite to use.
    //

    pctRet = Ssl3SelectCipherEx(pContext,
                                pHello->CipherSpecs,
                                pHello->cCipherSpecs);
    if (pctRet != PCT_ERR_OK)
    {
        goto Ret;
    }

    pContext->State = SSL3_STATE_GEN_SERVER_HELLO;

Ret:
    if(NULL != pHello)
    {
        SPExternalFree(pHello);
    }

    SP_RETURN( pctRet );
}


/*
***************************************************************************
Build Server hello onto pb... we need to check the boundary condition with cb
****************************************************************************
*/
void
Ssl3BuildServerHello(PSPContext pContext, PBYTE pb)
{
    SSH *pssh = (SSH *) pb;
    WORD wT = sizeof(SSH) - sizeof(SHSH);
    DWORD dwCipher = UniAvailableCiphers[pContext->dwPendingCipherSuiteIndex].CipherKind;

    FillMemory(pssh, sizeof(SSH), 0);
    pssh->typHS = SSL3_HS_SERVER_HELLO;
    pssh->bcbMSB = MSBOF(wT) ;
    pssh->bcbLSB = LSBOF(wT) ;
    pssh->bMajor = SSL3_CLIENT_VERSION_MSB;
    if(pContext->RipeZombie->fProtocol == SP_PROT_SSL3_SERVER)
    {
        pssh->bMinor = (UCHAR)SSL3_CLIENT_VERSION_LSB;
    }
    else
    {
        pssh->bMinor = (UCHAR)TLS1_CLIENT_VERSION_LSB;
    }
    pssh->wCipherSelectedMSB = MSBOF(dwCipher);
    pssh->wCipherSelectedLSB = LSBOF(dwCipher);
    pssh->cbSessionId = (char)pContext->RipeZombie->cbSessionID;
    CopyMemory(pssh->rgbSessionId, pContext->RipeZombie->SessionID, pContext->RipeZombie->cbSessionID) ;
    CopyMemory(pssh->rgbRandom, pContext->rgbS3SRandom, CB_SSL3_RANDOM);
}

/*
***************************************************************************
Build Server Hello Done message
****************************************************************************
*/
void 
BuildServerHelloDone(
   PBYTE pb)
{
    SHSH *pshsh = (SHSH *) pb ;

    //     struct { } ServerHelloDone;

    SP_BEGIN("BuildServerHelloDone");
    FillMemory(pshsh, sizeof(SHSH), 0);
    pshsh->typHS = SSL3_HS_SERVER_HELLO_DONE;
    SP_END();
}


//+---------------------------------------------------------------------------
//
//  Function:   ParseKeyExchgMsg
//
//  Synopsis:   Parse the ClientKeyExchange message.
//
//  Arguments:  [pContext]      --  Schannel context.
//              [pb]            --  Pointer to message's 4-byte handshake
//                                  header.
//
//  History:    10-03-97   jbanes   Server-side CAPI integration.
//
//  Notes:      This routine is called by the server-side only.
//
//----------------------------------------------------------------------------
SP_STATUS
ParseKeyExchgMsg(
    PSPContext pContext, 
    PBYTE pb)
{
    SP_STATUS pctRet;
    DWORD cbEncryptedKey;
    PBYTE pbEncryptedKey;

    // check for correct state
    if(SSL2_STATE_SERVER_HELLO == pContext->State && pContext->fCertReq)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    // make sure we're a server
    if(!(pContext->pKeyExchInfo->fProtocol & SP_PROT_SSL3TLS1_CLIENTS))
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    if(*pb != SSL3_HS_CLIENT_KEY_EXCHANGE)
    {
        return SP_LOG_RESULT(PCT_ERR_ILLEGAL_MESSAGE);
    }

    cbEncryptedKey = ((INT)pb[1] << 16) + ((INT)pb[2] << 8) + (INT)pb[3];
    pbEncryptedKey = pb + (sizeof(SHSH)) ;

    if(pContext->pKeyExchInfo == NULL)
    {
        return SP_LOG_RESULT(PCT_INT_INTERNAL_ERROR);
    }

    /* Decrypt the encrypted portion of the master key */
    pctRet = pContext->pKeyExchInfo->System->GenerateServerMasterKey(
                pContext,
                NULL,
                0,
                pbEncryptedKey,
                cbEncryptedKey);
    if(pctRet != PCT_ERR_OK)
    {
        return SP_LOG_RESULT(pctRet);
    }


    pContext->State = SSL3_STATE_SERVER_KEY_XCHANGE;

    return PCT_ERR_OK;
}


SP_STATUS
UpdateAndDuplicateIssuerList(
    PSPCredentialGroup  pCredGroup,
    PBYTE *             ppbIssuerList,
    PDWORD              pcbIssuerList)
{
    SP_STATUS pctRet;

    LockCredentialExclusive(pCredGroup);

    *ppbIssuerList = NULL;
    *pcbIssuerList = 0;

    // Check for GP update from the domain controller.
    SslCheckForGPEvent();

    // Build list of trusted issuers.
    if((pCredGroup->pbTrustedIssuers == NULL) ||
       (pCredGroup->dwFlags & CRED_FLAG_UPDATE_ISSUER_LIST))
    {
        pctRet = SPContextGetIssuers(pCredGroup);
        if(pctRet != PCT_ERR_OK)
        {
            UnlockCredential(pCredGroup);
            return SP_LOG_RESULT(pctRet);
        }
    }

    // Allocate memory.
    *ppbIssuerList = SPExternalAlloc(pCredGroup->cbTrustedIssuers);
    if(*ppbIssuerList == NULL)
    {
        UnlockCredential(pCredGroup);
        return SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
    }

    // Copy issuer list.
    memcpy(*ppbIssuerList, pCredGroup->pbTrustedIssuers, pCredGroup->cbTrustedIssuers);
    *pcbIssuerList = pCredGroup->cbTrustedIssuers;

    UnlockCredential(pCredGroup);

    return PCT_ERR_OK;
}

/*
* *****************************************************************************
* Ssl3BuildCertificateRequest
*
* Build the CERTIFICATE_REQUEST handshake message.
*/
SP_STATUS
Ssl3BuildCertificateRequest(
    PBYTE pbIssuerList,         // in
    DWORD cbIssuerList,         // in
    PBYTE pbMessage,            // out
    DWORD *pdwMessageLen)       // out
{
    PBYTE           pbMessageStart = pbMessage;
    DWORD           dwBodyLength;

    // HandshakeType
    pbMessage[0] = SSL3_HS_CERTIFICATE_REQUEST;
    pbMessage += 1;

    // Skip message body length field (3 bytes)
    pbMessage += 3;

    //
    // enum {
    //     rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),
    //     rsa_ephemeral_dh(5), dss_ephemeral_dh(6), fortezza_dms(20), (255)
    // } ClientCertificateType;
    //
    // opaque DistinguishedName<1..2^16-1>;
    //
    // struct {
    //     ClientCertificateType certificate_types<1..2^8-1>;
    //     DistinguishedName certificate_authorities<3..2^16-1>;
    // } CertificateRequest;
    //

    // Certificate type
    pbMessage[0] = 2;           // certificate type vector length
    pbMessage[1] = SSL3_CERTTYPE_RSA_SIGN;
    pbMessage[2] = SSL3_CERTTYPE_DSS_SIGN;
    pbMessage += 3;

    // Trusted issuer list length
    pbMessage[0] = MSBOF(cbIssuerList);
    pbMessage[1] = LSBOF(cbIssuerList);
    pbMessage += 2;

    // Trusted issuer list
    if(pbIssuerList != NULL)
    {
        CopyMemory(pbMessage, pbIssuerList, cbIssuerList);
        pbMessage += cbIssuerList;
    }


    // Compute message body length (subtract 4 byte header)
    dwBodyLength = (DWORD)(pbMessage - pbMessageStart) - 4;

    // Fill in message body length field (3 bytes)
    pbMessageStart[1] = (UCHAR) ((dwBodyLength & 0x00ff0000) >> 16);
    pbMessageStart[2] = MSBOF(dwBodyLength);
    pbMessageStart[3] = LSBOF(dwBodyLength);

    *pdwMessageLen = dwBodyLength + 4;

    return PCT_ERR_OK;
}


/*
* *****************************************************************************
* Ssl3ParseClientHello
*
* This routine parses just the CLIENT_HELLO message itself. The
* handshake crud has already been stripped off.
*/
BOOL Ssl3ParseClientHello(
    PSPContext  pContext,
    PBYTE       pbMessage,
    DWORD       cbMessage,
    BOOL        fAttemptReconnect,
    BOOL *      pfReconnect)
{
    DWORD dwVersion;
    PBYTE pbSessionId;
    DWORD cbSessionId;
    DWORD cbCipherSpecLen;
    DWORD cbCompMethodLen;
    INT   iCompMethod;
    DWORD i;
    SP_STATUS pctRet = PCT_ERR_OK;
    DWORD dwProtocol = SP_PROT_SSL3_SERVER;
    Ssl2_Cipher_Kind CipherSpecs[MAX_UNI_CIPHERS];
    DWORD cCipherSpecs;
    DWORD dwCacheCipher;
    BOOL fFound;
    BOOL fReconnect = FALSE;

    //
    // struct {
    //     ProtocolVersion client_version;
    //     Random random;
    //     SessinoID session_id;
    //     CipherSuite cipher_suites<2..2^16-1>
    //     CompressionMethod compression_methods<1..2^8-1>;
    // } ClientHello;
    //

    *pfReconnect = FALSE;


    //
    // Parse the ClientHello message.
    //

    
    // ProtocolVersion = client_version;
    if(cbMessage < 2)
    {
        return FALSE;
    }

    dwVersion = ((DWORD)pbMessage[0] << 8) + pbMessage[1];
    if(dwVersion < SSL3_CLIENT_VERSION)
    {
        return FALSE;
    }

    //see if it's a TLS 1 version !
    if(dwVersion >= TLS1_CLIENT_VERSION)
        dwProtocol = SP_PROT_TLS1_SERVER;
    pbMessage += 2;
    cbMessage -= 2;

    // Random random
    if(cbMessage < CB_SSL3_RANDOM)
    {
        return FALSE;
    }

    CopyMemory(pContext->rgbS3CRandom, pbMessage, CB_SSL3_RANDOM);
    pContext->cbChallenge = CB_SSL3_RANDOM;
    pbMessage += CB_SSL3_RANDOM;
    cbMessage -= CB_SSL3_RANDOM;

    // SessionID session_id; (length)
    if(cbMessage < 1)
    {
        return FALSE;
    }
    cbSessionId = pbMessage[0];
    if(cbSessionId > CB_SSL3_SESSION_ID)
    {
        return FALSE;
    }
    pbMessage += 1;
    cbMessage -= 1;

    // SessionID session_id;
    if(cbMessage < cbSessionId)
    {
        return FALSE;
    }
    pbSessionId = pbMessage;
    pbMessage += cbSessionId;
    cbMessage -= cbSessionId;

    // CipherSuite cipher_suites<2..2^16-1>; (length)
    if(cbMessage < 2)
    {
        return FALSE;
    }
    cbCipherSpecLen = ((INT)pbMessage[0] << 8) + pbMessage[1];
    if(cbCipherSpecLen % 2)
    {
        return FALSE;
    }
    pbMessage += 2;
    cbMessage -= 2;

    if(cbMessage < cbCipherSpecLen)
    {
        return FALSE;
    }

    if(cbCipherSpecLen %2)
    {
        return FALSE;
    }

    // CipherSuite cipher_suites<2..2^16-1>;
    if(cbCipherSpecLen / 2 > MAX_UNI_CIPHERS)
    {
        cCipherSpecs = MAX_UNI_CIPHERS;
    }
    else
    {
        cCipherSpecs = cbCipherSpecLen / 2;
    }

    // Build list of client cipher suites.
    for(i = 0; i < cCipherSpecs; i++)
    {
        CipherSpecs[i] = COMBINEBYTES(pbMessage[i*2], pbMessage[(i*2)+1]);
    }
    pbMessage += cbCipherSpecLen;
    cbMessage -= cbCipherSpecLen;

    // CompressionMethod compression_methods<1..2^8-1>; (length)
    if(cbMessage < 1)
    {
        return FALSE;
    }
    cbCompMethodLen = pbMessage[0];
    if(cbCompMethodLen < 1)
    {
        return FALSE;
    }
    pbMessage += 1;
    cbMessage -= 1;

    if(cbMessage < cbCompMethodLen)
    {
        return FALSE;
    }

    iCompMethod = -1;
    for(i = 0 ; i <cbCompMethodLen; i++)
    {
        if(pbMessage[i] == 0)
        {
            iCompMethod = 0;
            break;
        }

    }
    pbMessage += cbCompMethodLen;
    cbMessage -= cbCompMethodLen;

    if(iCompMethod != 0)
    {
        return FALSE;
    }


    // 
    // Check to see if this is a reconnect.
    //

    if(((pContext->Flags & CONTEXT_FLAG_NOCACHE) == 0) &&
       (cbSessionId > 0) &&
       fAttemptReconnect)
    {
        fReconnect = SPCacheRetrieveBySession(
                                    pContext,
                                    pbSessionId,
                                    cbSessionId,
                                    &pContext->RipeZombie);
        if(fReconnect)
        {
            // Make sure client's cipher suite list includes one from cache.
            fFound = FALSE;
            dwCacheCipher = UniAvailableCiphers[pContext->RipeZombie->dwCipherSuiteIndex].CipherKind;
            for(i = 0; i < cCipherSpecs; i++)
            {
                if(CipherSpecs[i] == dwCacheCipher)
                {
                    fFound = TRUE;
                    break;
                }
            }

            if(fFound)
            {
                // Transfer information from the cache entry to the context element.
                pctRet = ContextInitCiphersFromCache(pContext);
            }

            if(!fFound || pctRet != PCT_ERR_OK)
            {
                // This cache entry is not suitable for some reason. We need
                // to dump this cache entry and perform a full handshake.
                // This is typically caused by a client-side implementation 
                // problem.
                pContext->RipeZombie->ZombieJuju = FALSE;
                SPCacheDereference(pContext->RipeZombie);
                pContext->RipeZombie = NULL;
                fReconnect = FALSE;
            }
        }
    }

    if(fReconnect)
    {
        // We're doing a reconnect.
        DebugLog((DEB_TRACE, "Accept client's reconnect request.\n"));

        *pfReconnect = TRUE;

    }
    else
    {
        // We're doing a full handshake, so allocate a cache entry.

        if(!SPCacheRetrieveNew(TRUE,
                               pContext->pszTarget, 
                               &pContext->RipeZombie))
        {
            SP_LOG_RESULT(SEC_E_INSUFFICIENT_MEMORY);
            return FALSE;
        }

        pContext->RipeZombie->fProtocol = pContext->dwProtocol;
        pContext->RipeZombie->dwCF      = pContext->dwRequestedCF;

        SPCacheAssignNewServerCredential(pContext->RipeZombie,
                                         pContext->pCredGroup);


        //
        // Select cipher suite to use.
        //

        pctRet = Ssl3SelectCipherEx(pContext,
                                    CipherSpecs,
                                    cCipherSpecs);
        if (pctRet != PCT_ERR_OK)
        {
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\utillib\spbase.h ===
#include "spbasei.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\utillib\enc.c ===
/*-----------------------------------------------------------------------------
* Copyright (C) Microsoft Corporation, 1995 - 1996.
* All rights reserved.
*
* This file is part of the Microsoft Private Communication Technology
* reference implementation, version 1.0
*
* The Private Communication Technology reference implementation, version 1.0
* ("PCTRef"), is being provided by Microsoft to encourage the development and
* enhancement of an open standard for secure general-purpose business and
* personal communications on open networks.  Microsoft is distributing PCTRef
* at no charge irrespective of whether you use PCTRef for non-commercial or
* commercial use.
*
* Microsoft expressly disclaims any warranty for PCTRef and all derivatives of
* it.  PCTRef and any related documentation is provided "as is" without
* warranty of any kind, either express or implied, including, without
* limitation, the implied warranties or merchantability, fitness for a
* particular purpose, or noninfringement.  Microsoft shall have no obligation
* to provide maintenance, support, upgrades or new releases to you or to anyone
* receiving from you PCTRef or your modifications.  The entire risk arising out
* of use or performance of PCTRef remains with you.
*
* Please see the file LICENSE.txt,
* or http://pct.microsoft.com/pct/pctlicen.txt
* for more information on licensing.
*
* Please see http://pct.microsoft.com/pct/pct.htm for The Private
* Communication Technology Specification version 1.0 ("PCT Specification")
*
* 1/23/96
*----------------------------------------------------------------------------*/

#include <spbase.h>

#include <ber.h>


typedef struct __EncAlgs {
    DWORD       Id;
    UCHAR       Sequence[16];
    DWORD       SequenceLen;
} _EncAlgs;


#define iso_member          0x2a,               /* iso(1) memberbody(2) */
#define us                  0x86, 0x48,         /* us(840) */
#define rsadsi              0x86, 0xf7, 0x0d,   /* rsadsi(113549) */
#define pkcs                0x01,               /* pkcs(1) */

#define pkcs_1              iso_member us rsadsi pkcs
#define pkcs_len            7
#define rsa_dsi             iso_member us rsadsi
#define rsa_dsi_len         6

#define joint_iso_ccitt_ds  0x55,
#define attributetype       0x04,

#define attributeType       joint_iso_ccitt_ds attributetype
#define attrtype_len        2


_EncAlgs EncKnownAlgs[] =
{
    {ALGTYPE_SIG_RSA_MD5, {pkcs_1 1, 4}, pkcs_len + 2},
    {ALGTYPE_KEYEXCH_RSA_MD5, {pkcs_1 1, 1}, pkcs_len + 2},
    {ALGTYPE_CIPHER_RC4_MD5, {rsa_dsi 3, 4}, rsa_dsi_len + 2},
    {ALGTYPE_KEYEXCH_DH, {pkcs_1 3, 1}, pkcs_len + 2},
};



typedef struct _NameTypes {
    PSTR        Prefix;
    DWORD       PrefixLen;
    UCHAR       Sequence[8];
    DWORD       SequenceLen;
} NameTypes;

#define CNTYPE_INDEX        0

NameTypes EncKnownNameTypes[] =
{
    {"CN=", 3, {attributeType 3},  attrtype_len + 1},
    {"C=",  2, {attributeType 6},  attrtype_len + 1},
    {"L=",  2, {attributeType 7},  attrtype_len + 1},
    {"S=",  2, {attributeType 8},  attrtype_len + 1},
    {"O=",  2, {attributeType 10}, attrtype_len + 1},
    {"OU=", 3, {attributeType 11}, attrtype_len + 1}
};


/************************************************************/
/* EncodeLength ASN1 encodes a length field.  The parameter */
/* dwLen is the length to be encoded, it is a DWORD and     */
/* therefore may be no larger than 2^32.  The pbEncoded     */
/* parameter is the encoded result, and memory must be      */
/* allocated for it by the caller.  The Writeflag parameter */
/* indicates if the result is to be written to the pbEncoded*/
/* parameter.  The function cannot fail and returns the     */
/* number of total bytes in the encoded length.             */
/* encoded length.                                          */
/************************************************************/

// Notes:       Encodes 0x0000 to 0x007f as <lobyte>
//            Encodes 0x0080 to 0x00ff as <81>, <lobyte>
//            Encodes 0x0100 to 0xffff as <82>, <hibyte>, <lobyte>

long
EncodeLength(
    BYTE *  pbEncoded,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    // length is between 2^8 and 2^16 - 1

    if (dwLen > 0xFF)
    {
        if (Writeflag)
        {
            pbEncoded[0] = 0x82;
            pbEncoded[1] = (BYTE) (dwLen >> 8);
            pbEncoded[2] = (BYTE) dwLen;
        }
        return (3);
    }

    // length is between 2^7 and 2^8 - 1

    if (dwLen > 0x7F)
    {
        if (Writeflag)
        {
            pbEncoded[0] = 0x81;
            pbEncoded[1] = (BYTE) dwLen;
        }
        return (2);
    }

    // length is between 0 and 2^7 - 1

    if (Writeflag)
    {
        pbEncoded[0] = (BYTE) dwLen;
    }
    return (1);
}


/****************************************************************/
/* EncodeInteger ASN1 encodes an integer.  The pbInt parameter  */
/* is the integer as an array of bytes, and dwLen is the number */
/* of bytes in the array.  The least significant byte of the    */
/* integer is the zeroth byte of the array.  The encoded result */
/* is passed back in the pbEncoded parameter.  The Writeflag    */
/* indicates if the result is to be written to the pbEncoded    */
/* parameter. The function cannot fail and returns the number   */
/* of total bytes in the encoded integer.                       */
/* This implementation will only deal with positive integers.   */
/****************************************************************/

long
EncodeInteger(
    BYTE *pbEncoded,
    BYTE *pbInt,
    DWORD dwLen,
    BOOL Writeflag)
{
    DWORD i;
    long j;               // Must be signed!
    BYTE *pb = pbEncoded;

    if (Writeflag)
    {
        *pb = INTEGER_TAG;
    }
    pb++;

    /* find the most significant non-zero byte */

    for (i = dwLen - 1; pbInt[i] == 0; i--)
    {
        if (i == 0)     /* if the integer value is 0 */
        {
            if (Writeflag)
            {
                pb[0] = 0x01;
                pb[1] = 0x00;
            }
            return(3);
        }
    }

    /* if the most significant bit of the most sig byte is set */
    /* then need to add a 0 byte to the beginning. */

    if (pbInt[i] > 0x7F)
    {
        /* encode the length */
        pb += EncodeLength(pb, i + 2, Writeflag);

        if (Writeflag)
        {
            /* set the first byte of the integer to 0 and increment pointer */
            *pb = 0;
        }
        pb++;
    }
    else
    {
        /* encode the length */
        pb += EncodeLength(pb, i + 1, Writeflag);
    }

    /* copy the integer bytes into the encoded buffer */
    if (Writeflag)
    {
        /* copy the integer bytes into the encoded buffer */
        for (j = i; j >= 0; j--)
        {
            *pb++ = pbInt[j];
        }
    }
    else
    {
        pb += i;
    }
    return (long)(pb - pbEncoded);
}


/****************************************************************/
/* EncodeString ASN1 encodes a character string.  The pbStr     */
/* parameter is the string as an array of characters, and dwLen */
/* is the number of characters in the array.  The encoded result*/
/* is passed back in the pbEncoded parameter.  The Writeflag    */
/* indicates if the result is to be written to the pbEncoded    */
/* parameter. The function cannot fail and returns the number   */
/* of total bytes in the encoded string.                        */
/****************************************************************/

long
EncodeString(
    BYTE *  pbEncoded,
    BYTE *  pbStr,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    long lengthlen;

    if (Writeflag)
    {
        *pbEncoded++ = CHAR_STRING_TAG;
    }
    lengthlen = EncodeLength(pbEncoded, dwLen, Writeflag);

    if (Writeflag)
    {
        CopyMemory(pbEncoded + lengthlen, pbStr, dwLen);
    }
    return(1 + lengthlen + dwLen);
}


/****************************************************************/
/* EncodeOctetString ASN1 encodes a string of hex valued        */
/* characters. The pbStr parameter is an array of characters,   */
/* and dwLen is the number of characters in the array.  The     */
/* encoded result is passed back in the pbEncoded parameter. The*/
/* Writeflag parameter indicates if the result is to be written */
/* to the pbEncoded parameter. The function cannot fail and     */
/* returns the number of total bytes in the encoded octet string*/
/****************************************************************/

long
EncodeOctetString(
    BYTE *  pbEncoded,
    BYTE *  pbStr,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    long lengthlen;

    if (Writeflag)
    {
        *pbEncoded++ = OCTET_STRING_TAG;
    }
    lengthlen = EncodeLength(pbEncoded, dwLen, Writeflag);

    if (Writeflag)
    {
        CopyMemory(pbEncoded + lengthlen, pbStr, dwLen);
    }
    return(1 + lengthlen + dwLen);
}


/****************************************************************/
/* EncodeBitString ASN1 encodes a string of bit characters. The */
/* pbStr parameter is an array of characters (bits), and dwLen  */
/* is the number of characters in the array.  The encoded result*/
/* is passed back in the pbEncoded parameter.  The Writeflag    */
/* indicates if the result is to be written to the pbEncoded    */
/* parameter. The function cannot fail and returns the number   */
/* of total bytes in the encoded string.  This function uses    */
/* the DER.                                                     */
/****************************************************************/
long
EncodeBitString(
    BYTE *  pbEncoded,
    BYTE *  pbStr,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    long lengthlen;

    if (Writeflag)
    {
        *pbEncoded++ = BIT_STRING_TAG;
    }

    lengthlen = EncodeLength(pbEncoded, dwLen + 1, Writeflag);

    if (Writeflag)
    {
        pbEncoded += lengthlen;

        // the next byte tells how many unused bits there are in the last byte,
        // but this will always be zero in this implementation (DER)

        *pbEncoded++ = 0;
        CopyMemory(pbEncoded, pbStr, dwLen);
    }
    return(1 + lengthlen + 1 + (long) dwLen);
}


/****************************************************************/
/* EncodeHeader ASN1 encodes a header for a sequence type. The  */
/* dwLen is the length of the encoded information in the        */
/* sequence.  The Writeflag indicates if the result is to be    */
/* written to the pbEncoded parameter.  The function cannot     */
/* fail and returns the number of total bytes in the encoded    */
/* header.                                                      */
/****************************************************************/

// Notes:       Encodes header as <SEQUENCE_TAG>, <length>

long
EncodeHeader(
    BYTE *  pbEncoded,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    if (Writeflag)
    {
        *pbEncoded++ = SEQUENCE_TAG;
    }
    return(1 + EncodeLength(pbEncoded, dwLen, Writeflag));
}


/****************************************************************/
/* EncodeSetOfHeader ASN1 encodes a header for a set of type.   */
/* The dwLen is the length of the encoded information in the    */
/* set of.  The Writeflag indicates if the result is to be      */
/* written to the pbEncoded parameter.  The function cannot     */
/* fail and returns the number of total bytes in the encoded    */
/* header.                                                      */
/****************************************************************/

// Notes:       Encodes header as <SET_OF_TAG>, <length>

long
EncodeSetOfHeader(
    BYTE *  pbEncoded,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    if (Writeflag)
    {
        *pbEncoded++ = SET_OF_TAG;
    }
    return(1 + EncodeLength(pbEncoded, dwLen, Writeflag));
}


// Notes:       Encodes header as <ATTRIBUTE_TAG>, <length>

long
EncodeAttributeHeader(
    BYTE *  pbEncoded,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    if (Writeflag)
    {
        *pbEncoded++ = ATTRIBUTE_TAG;
    }
    return(1 + EncodeLength(pbEncoded, dwLen, Writeflag));
}


// Notes:       Encodes header as <BER_SET>, <length>

long
EncodeSetHeader(
    BYTE *  pbEncoded,
    DWORD   dwLen,
    BOOL    WriteFlag)
{
    if (WriteFlag)
    {
        *pbEncoded++ = BER_SET;
    }
    return(1 + EncodeLength(pbEncoded, dwLen, WriteFlag));
}



/****************************************************************/
/* EncodeName ASN1 encodes a Name type. The pbName parameter is */
/* the name and dwLen is the length of the name in bytes.       */
/* The Writeflag indicates if the result is to be written to    */
/* the pbEncoded parameter.  The function cannot fail and       */
/* returns the number of total bytes in the encoded name.       */
/****************************************************************/

long
EncodeName(
    BYTE *  pbEncoded,
    BYTE *  pbName,
    DWORD   dwLen,
    BOOL    Writeflag)
{
    BYTE        Type[MAXOBJIDLEN];
    long        TypeLen;
    BYTE        Value[MAXNAMEVALUELEN+MINHEADERLEN];
    long        ValueLen;
    BYTE        Attribute[MAXNAMELEN];
    long        AttributeLen;
    BYTE        SetHdr[MINHEADERLEN];
    long        HdrLen;
    long        NameLen;

    /* encode the name value */
    ValueLen = EncodeString(Value, pbName, dwLen, Writeflag);
    SP_ASSERT(ValueLen > 0 && ValueLen <= sizeof(Value));

    /* encode the attribute type, this is an object identifier and here it */
    /* is a fake encoding */
    Type[0] = 0x06;
    Type[1] = 0x01;
    Type[2] = 0x00;

    TypeLen = 3;

    /* enocde the header for the attribute */
    AttributeLen = EncodeHeader(
                            Attribute,
                            (DWORD) (ValueLen + TypeLen),
                            Writeflag);
    SP_ASSERT(AttributeLen > 0);
    SP_ASSERT(AttributeLen + TypeLen + ValueLen <= sizeof(Attribute));

    /* copy the attribute type and value into the attribute */
    CopyMemory(Attribute + AttributeLen, Type, (size_t) TypeLen);
    AttributeLen += TypeLen;
    CopyMemory(Attribute + AttributeLen, Value, (size_t) ValueLen);
    AttributeLen += ValueLen;

    /* encode set of header */
    HdrLen = EncodeSetOfHeader(SetHdr, (DWORD) AttributeLen, Writeflag);
    SP_ASSERT(HdrLen > 0 && HdrLen <= sizeof(SetHdr));

    /* encode Name header */
    NameLen = EncodeHeader(
                        pbEncoded,
                        (DWORD) (HdrLen + AttributeLen),
                        Writeflag);
    SP_ASSERT(NameLen > 0);

    CopyMemory(pbEncoded + NameLen, SetHdr, (size_t) HdrLen);
    NameLen += HdrLen;
    CopyMemory(pbEncoded + NameLen, Attribute, (size_t) AttributeLen);

    return(NameLen + AttributeLen);
}

long
EncodeRDN(
    BYTE *  pbEncoded,
    PSTR    pszRDN,
    BOOL    WriteFlag)
{
    LONG    Result;
    DWORD   RelLength;
    long    Length;
    NameTypes *pNameType;
    char ach[4];

    SP_ASSERT(pszRDN != NULL);
    if (pszRDN[0] == '\0' ||
        pszRDN[1] == '\0' ||
        pszRDN[2] == '\0' ||
        (pszRDN[1] != '=' && pszRDN[2] != '='))
    {
        return(-1);
    }
    ach[0] = pszRDN[0];
    ach[1] = pszRDN[1];
    if (ach[1] == '=')
    {
        ach[2] = '\0';
    }
    else
    {
        ach[2] = pszRDN[2];
        ach[3] = '\0';
    }

    for (pNameType = EncKnownNameTypes; ; pNameType++)
    {
        if (pNameType ==
            &EncKnownNameTypes[sizeof(EncKnownNameTypes) /
                               sizeof(EncKnownNameTypes[0])])
        {
            return(-1);
        }
        SP_ASSERT(lstrlen(pNameType->Prefix) < sizeof(ach));
        if (lstrcmpi(ach, pNameType->Prefix) == 0)
        {
            break;
        }
    }

    RelLength = lstrlen(&pszRDN[pNameType->PrefixLen]);

    // Prefix data takes up 9 bytes

    Length = EncodeSetHeader(pbEncoded, RelLength + 9, WriteFlag);
    pbEncoded += Length;

    Result = EncodeHeader(pbEncoded, RelLength + 7, WriteFlag);
    pbEncoded += Result;
    Length += Result + 2 + pNameType->SequenceLen;

    if (WriteFlag)
    {
        *pbEncoded++ = OBJECT_ID_TAG;
        *pbEncoded++ = (BYTE) pNameType->SequenceLen;

        CopyMemory(pbEncoded, pNameType->Sequence, pNameType->SequenceLen);
        pbEncoded += pNameType->SequenceLen;

        *pbEncoded++ =
            pNameType == &EncKnownNameTypes[CNTYPE_INDEX]?
                TELETEX_STRING_TAG : PRINTABLE_STRING_TAG;

    }
    Length++;

    Result = EncodeLength(pbEncoded, RelLength, WriteFlag);
    Length += Result;

    if (WriteFlag)
    {
        CopyMemory(
                pbEncoded + Result,
                &pszRDN[pNameType->PrefixLen],
                RelLength);
    }
    return(Length + RelLength);
}

long
EncodeDN(
    BYTE *  pbEncoded,
    PSTR    pszDN,
    BOOL    WriteFlag)
{
    PSTR pszRDN;
    long Result = 0;
    long Length;
    long SaveResult;

    SP_ASSERT(pszDN != NULL);

    SaveResult = 0;           // force one full iteration
    Length = 2 * lstrlen(pszDN); // your guess is as good as mine
    while (TRUE)
    {
        PSTR pszNext;
        BYTE *pb;

        pb = pbEncoded;

        Result = EncodeHeader(pb, Length, WriteFlag);
        if (SaveResult == Result)
        {
            break;
        }
        pb += Result;
        SaveResult = Result;

        Length = 0;
        pszRDN = pszDN;
        while (*pszRDN != '\0')
        {
            for (pszNext = pszRDN; ; pszNext++)
            {
                if (*pszNext == ',')
                {
                    *pszNext = '\0';
                    break;
                }
                if (*pszNext == '\0')
                {
                    pszNext = NULL;
                    break;
                }
            }

            Result = EncodeRDN(pb, pszRDN, WriteFlag);

            // Restore the comma before checking for error

            if (NULL != pszNext)
            {
                *pszNext = ',';
            }
            if (Result < 0)
            {
                DebugLog((DEB_TRACE, "EncodeDN: Error: %s\n", pszRDN));
                Length = 0;
                goto error;     // return(-1)
            }

            pb += Result;
            Length += Result;

            if (NULL == pszNext)
            {
                break;
            }

            pszRDN = pszNext + 1;
            while (*pszRDN == ' ')
            {
                pszRDN++;
            }
            DebugLog((DEB_TRACE, "EncodeDN: Length = %d\n", Length));
        }
    }
    SP_ASSERT(0 != SaveResult);
error:
    return(Result + Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\context.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       context.c
//
//  Contents:   Context manipulation functions
//
//  Classes:
//
//  Functions:
//
//  History:    2-26-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"

CRITICAL_SECTION XtcbContextLock ;


//+---------------------------------------------------------------------------
//
//  Function:   XtcbInitializeContexts
//
//  Synopsis:   Initialization function
//
//  Arguments:  (none)
//
//  History:    8-15-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
XtcbInitializeContexts(
    VOID
    )
{
    NTSTATUS Status ;

    Status = STATUS_SUCCESS ;

    try
    {
        InitializeCriticalSection( &XtcbContextLock );
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        Status = GetExceptionCode();
    }

    return Status ;
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbCreateContextRecord
//
//  Synopsis:   Create a context record for use during authentication
//
//  Arguments:  [Type]   -- Type of context
//              [Handle] -- Credential handle that this context is derived from
//
//  History:    2-26-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PXTCB_CONTEXT
XtcbCreateContextRecord(
    XTCB_CONTEXT_TYPE   Type,
    PXTCB_CRED_HANDLE   Handle
    )
{
    PXTCB_CONTEXT   Context ;

    Context = (PXTCB_CONTEXT) LocalAlloc( LMEM_FIXED, sizeof( XTCB_CONTEXT) );

    if ( Context )
    {
        Context->Core.Check = XTCB_CONTEXT_CHECK ;

        Context->Core.Type = Type ;

        Context->Core.State = ContextFirstCall ;

        Context->CredHandle = (LSA_SEC_HANDLE) Handle ;

        XtcbRefCredHandle( Handle );

        //
        // Set initial count to 2, one for the context handle
        // that will be returned, and one for the reference that
        // indicates that we are currently working on it.
        //

        Context->Core.RefCount = 2 ;

    }

    return Context ;
}
//+---------------------------------------------------------------------------
//
//  Function:   XtcbDeleteContextRecord
//
//  Synopsis:   Deletes a security context record
//
//  Arguments:  [Context] -- Context
//
//  History:    2-26-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
XtcbDeleteContextRecord(
    PXTCB_CONTEXT   Context
    )
{
#if DBG
    if ( Context->Core.Check != XTCB_CONTEXT_CHECK )
    {
        DebugLog(( DEB_ERROR, "DeleteContext: not a valid context record: %x\n",
                Context ));
        return;

    }
#endif

    XtcbDerefCredHandle( (PXTCB_CRED_HANDLE) Context->CredHandle );

    LocalFree( Context );
}



VOID
XtcbDerefContextRecordEx(
    PXTCB_CONTEXT Context,
    LONG RefBy
    )
{
    LONG RefCount ;

    EnterCriticalSection( &XtcbContextLock );

    Context->Core.RefCount -= RefBy ;

    RefCount = Context->Core.RefCount ;

    LeaveCriticalSection( &XtcbContextLock );

    if ( RefCount )
    {
        return ;
    }

#if DBG

    if ( RefCount < 0 )
    {
        DebugLog(( DEB_ERROR, "Refcount below 0\n" ));
    }
#endif

    XtcbDeleteContextRecord( Context );

}

BOOL
XtcbRefContextRecord(
    PXTCB_CONTEXT Context
    )
{
    BOOL Ret ;

    Ret = FALSE ;

    EnterCriticalSection( &XtcbContextLock );

    try
    {

        if ( Context->Core.Check == XTCB_CONTEXT_CHECK )
        {
            if ( Context->Core.RefCount > 0 )
            {
                Context->Core.RefCount++ ;
                Ret = TRUE ;
            }

        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Ret = FALSE ;
    }

    LeaveCriticalSection( &XtcbContextLock );

    return Ret ;
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbMapContextToUser
//
//  Synopsis:   Prepares a context to be mapped to usermode by the LSA
//
//  Arguments:  [Context]       --
//              [ContextBuffer] --
//
//  History:    3-28-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
XtcbMapContextToUser(
    PXTCB_CONTEXT    Context,
    PSecBuffer      ContextBuffer
    )
{
    PXTCB_CONTEXT_CORE  NewContext ;
    NTSTATUS            Status ;
    HANDLE DupHandle ;

    NewContext = LsaTable->AllocateLsaHeap( sizeof( XTCB_CONTEXT_CORE ) );

    if ( NewContext )
    {
        CopyMemory( NewContext, &Context->Core, sizeof( XTCB_CONTEXT_CORE ) );

        switch ( Context->Core.Type )
        {
            case XtcbContextClient:
                NewContext->Type = XtcbContextClientMapped ;
                Context->Core.Type = XtcbContextClientMapped ;
                break;

            case XtcbContextServer:
                NewContext->Type = XtcbContextServerMapped ;
                Context->Core.Type = XtcbContextClientMapped ;

                Status = LsaTable->DuplicateHandle( Context->Token,
                                                    &DupHandle );

                DebugLog(( DEB_TRACE, "New token = %x\n", DupHandle ));
                if ( !NT_SUCCESS( Status ) )
                {
                    DebugLog(( DEB_ERROR, "Failed to dup handle, %x\n",
                        Status ));
                    goto MapContext_Cleanup ;

                }
                NewContext->CoreTokenHandle = (ULONG) ((ULONG_PTR)DupHandle) ;

                CloseHandle( Context->Token );
                Context->Token = NULL ;
                break;

            default:
                Status = SEC_E_INVALID_TOKEN ;
                goto MapContext_Cleanup ;
                break;

        }

        ContextBuffer->pvBuffer = NewContext ;
        ContextBuffer->cbBuffer = sizeof( XTCB_CONTEXT_CORE );

        return SEC_E_OK ;

    }
    else
    {
        Status = SEC_E_INSUFFICIENT_MEMORY ;
    }

MapContext_Cleanup:

    if ( NewContext )
    {
        LsaTable->FreeLsaHeap( NewContext );
    }

    return Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\utillib\test.c ===
long
EncodeInteger(
    unsigned char *  pbEncoded,
    unsigned char *  pbInt,
    unsigned long   dwLen,
    int    Writeflag)
{
    long    count;
    unsigned long   i;
    long    j;

    if (Writeflag)
        pbEncoded[0] = 0x02;

    count = 1;

    i = dwLen - 1;

    // find the most significant non-zero unsigned char
    while ((pbInt[i] == 0) && (i > 0))
        i--;

    if ((i == 0) && (pbInt[i] == 0))
        // this means that the integer value is 0
    {
        if (Writeflag)
            {
            pbEncoded[1] = 0x01;
            pbEncoded[2] = 0x00;
            }
        count += 2;
    }
    else
    {
        // if the most significant bit of the most sig unsigned char is set
        // then need to add a 0 unsigned char to the beginning.
        if (pbInt[i] > 0x7F)
        {
            // encode the length
            count += EncodeLength (pbEncoded + count, i+2, Writeflag);

            if (Writeflag)
            {
                // set the first unsigned char of the integer to zero and increment count
                pbEncoded[count++] = 0x00;

                // copy the integer unsigned chars into the encoded buffer
                j = i;
                while (j >= 0)
                    pbEncoded[count++] = pbInt[j--];
                }
            }

        else
        {
            // encode the length
            count += EncodeLength (pbEncoded + count, i+1, Writeflag);

            // copy the integer unsigned chars into the encoded buffer
            if (Writeflag)
                {
                j = i;
                while (j >= 0)
                    pbEncoded[count++] = pbInt[j--];
                }

            }
    }

    return (count);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\context.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       context.h
//
//  Contents:   Security Context structures and manipulation
//
//  Classes:
//
//  Functions:
//
//  History:    2-24-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __CONTEXT_H__
#define __CONTEXT_H__


typedef enum _XTCB_CONTEXT_TYPE {
    XtcbContextClient,
    XtcbContextServer,
    XtcbContextClientMapped,
    XtcbContextServerMapped
} XTCB_CONTEXT_TYPE ;

typedef enum _XTCB_CONTEXT_STATE {
    ContextFirstCall,
    ContextSecondCall,
    ContextThirdCall
} XTCB_CONTEXT_STATE ;

#define XTCB_CONTEXT_CHECK  'txtC'

typedef struct _XTCB_CONTEXT_CORE {
    ULONG               Check ;
    XTCB_CONTEXT_TYPE   Type ;
    XTCB_CONTEXT_STATE  State ;
    LONG                RefCount ;
    ULONG               Attributes ;
    UCHAR               RootKey[ SEED_KEY_SIZE ];
    UCHAR               InboundKey[ SEED_KEY_SIZE ];
    UCHAR               OutboundKey[ SEED_KEY_SIZE ];
    ULONG               InboundNonce ;
    ULONG               OutboundNonce ;
    ULONG               CoreTokenHandle ;
} XTCB_CONTEXT_CORE, * PXTCB_CONTEXT_CORE ;

typedef struct _XTCB_CONTEXT {
    XTCB_CONTEXT_CORE   Core ;
    LSA_SEC_HANDLE      CredHandle ;
    HANDLE              Token ;
} XTCB_CONTEXT, * PXTCB_CONTEXT ;

NTSTATUS
XtcbInitializeContexts(
    VOID
    );

PXTCB_CONTEXT
XtcbCreateContextRecord(
    XTCB_CONTEXT_TYPE   Type,
    PXTCB_CRED_HANDLE   Handle
    );


VOID
XtcbDeleteContextRecord(
    PXTCB_CONTEXT   Context
    );

NTSTATUS
XtcbMapContextToUser(
    PXTCB_CONTEXT    Context,
    PSecBuffer      ContextBuffer
    );

BOOL
XtcbRefContextRecord(
    PXTCB_CONTEXT Context
    );

VOID
XtcbDerefContextRecordEx(
    PXTCB_CONTEXT Context,
    LONG RefBy
    );

#define XtcbDerefContextRecord( C )  XtcbDerefContextRecordEx( C, 1 );


#endif // __CONTEXT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\schannel\utillib\keys.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       keys.c
//
//  Contents:   Well known keys for certificate validation
//
//  Classes:
//
//  Functions:
//
//  History:    9-21-95   RichardW   Created
//
//----------------------------------------------------------------------------


#include "spbase.h"
#include <oidenc.h>

#include <rsa.h>

#define SCHANNEL_GENKEY_NAME "SchannelGenKey"

BOOL
GenerateKeyPair(
    PSSL_CREDENTIAL_CERTIFICATE pCerts,
    PSTR pszDN,
    PSTR pszPassword,
    DWORD Bits)
{

    BOOL            fRet = FALSE;
    DWORD           BitsCopy;
    DWORD           dwPrivateSize;
    DWORD           dwPublicSize;
    MD5_CTX         md5Ctx;
    struct RC4_KEYSTRUCT rc4Key;

    BLOBHEADER      *pCapiPrivate = NULL;
    BLOBHEADER      *pCapiPublic = NULL;

    PRIVATE_KEY_FILE_ENCODE PrivateEncode;
    CERT_REQUEST_INFO Req;

    CRYPT_ALGORITHM_IDENTIFIER SignAlg;

    HCRYPTPROV     hProv = 0;
    HCRYPTKEY      hKey = 0;

    if(!SchannelInit(TRUE))
    {
        return FALSE;
    }

    pCerts->pPrivateKey = NULL;
    Req.SubjectPublicKeyInfo.PublicKey.pbData = NULL;
    Req.Subject.pbData = NULL;
    pCerts->pCertificate = NULL;

    CryptAcquireContext(&hProv, SCHANNEL_GENKEY_NAME, NULL, PROV_RSA_FULL, CRYPT_DELETEKEYSET);

    if(!CryptAcquireContext(&hProv, SCHANNEL_GENKEY_NAME, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET))
    {
        goto error;
    }

    if(!CryptGenKey(hProv, CALG_RSA_SIGN,  (Bits << 16) | CRYPT_EXPORTABLE, &hKey))
    {
        goto error;
    }

    if(!CryptExportKey(hKey, 0, PRIVATEKEYBLOB, 0, NULL, &dwPrivateSize))
    {
        goto error;
    }

    pCapiPrivate = (BLOBHEADER *)SPExternalAlloc(dwPrivateSize);
    if(!CryptExportKey(hKey, 0, PRIVATEKEYBLOB, 0, (PBYTE)pCapiPrivate, &dwPrivateSize))
    {
        goto error;
    }


    if(!CryptExportKey(hKey, 0, PUBLICKEYBLOB, 0, NULL, &dwPublicSize))
    {
        goto error;
    }

    pCapiPublic = (BLOBHEADER *)SPExternalAlloc(dwPublicSize);
    if(!CryptExportKey(hKey, 0, PUBLICKEYBLOB, 0, (PBYTE)pCapiPublic, &dwPublicSize))
    {
        goto error;
    }

    // Encode the private key into a 
    // priavate key blob.
    if(!CryptEncodeObject(X509_ASN_ENCODING, 
                      szPrivateKeyInfoEncode,
                      pCapiPrivate,
                      NULL,
                      &PrivateEncode.EncryptedBlob.cbData))
    {
        goto error;
    }
    PrivateEncode.EncryptedBlob.pbData = SPExternalAlloc(PrivateEncode.EncryptedBlob.cbData);
    if(PrivateEncode.EncryptedBlob.pbData == NULL)
    {
        goto error;
    }
    if(!CryptEncodeObject(X509_ASN_ENCODING, 
                      szPrivateKeyInfoEncode,
                      pCapiPrivate,
                      PrivateEncode.EncryptedBlob.pbData,
                      &PrivateEncode.EncryptedBlob.cbData))
    {
        goto error;
    }

    // Okay, now encrypt this
    MD5Init(&md5Ctx);
    MD5Update(&md5Ctx, pszPassword, lstrlen(pszPassword));
    MD5Final(&md5Ctx);

    rc4_key(&rc4Key, 16, md5Ctx.digest);
    ZeroMemory(&md5Ctx, sizeof(md5Ctx));

    rc4(&rc4Key, 
        PrivateEncode.EncryptedBlob.cbData,
        PrivateEncode.EncryptedBlob.pbData);
    ZeroMemory(&rc4Key, sizeof(rc4Key));

    // 
    PrivateEncode.Alg.pszObjId = szOID_RSA_ENCRYPT_RC4_MD5;
    PrivateEncode.Alg.Parameters.pbData = NULL;
    PrivateEncode.Alg.Parameters.cbData = 0;


    // Ah yes, now to encode them...
    //
    // First, the private key.  Why?  Well, it's at least straight-forward
    // First, get the size of the private key encode...
    if(!CryptEncodeObject(X509_ASN_ENCODING, 
                      szPrivateKeyFileEncode,
                      &PrivateEncode,
                      NULL,
                      &pCerts->cbPrivateKey))
    {
        goto error;
    }
    pCerts->pPrivateKey = SPExternalAlloc(pCerts->cbPrivateKey);

    if(!CryptEncodeObject(X509_ASN_ENCODING, 
                      szPrivateKeyFileEncode,
                      &PrivateEncode,
                      pCerts->pPrivateKey,
                      &pCerts->cbPrivateKey))
    {
        goto error;
    }


    SPExternalFree(PrivateEncode.EncryptedBlob.pbData);

    // Create the Req structure so we can encode it.
    Req.dwVersion = CERT_REQUEST_V1;

    // Initialize the PublicKeyInfo
    Req.SubjectPublicKeyInfo.Algorithm.pszObjId = szOID_RSA_RSA;
    Req.SubjectPublicKeyInfo.Algorithm.Parameters.cbData = 0;
    Req.SubjectPublicKeyInfo.Algorithm.Parameters.pbData = NULL;

    Req.SubjectPublicKeyInfo.PublicKey.cbData;


    // Encode the public key info
    if(!CryptEncodeObject(X509_ASN_ENCODING, 
                      szOID_RSA_RSA_Public,
                      pCapiPublic,
                      NULL,
                      &Req.SubjectPublicKeyInfo.PublicKey.cbData))
    {
        goto error;
    }
    Req.SubjectPublicKeyInfo.PublicKey.pbData = 
        SPExternalAlloc(Req.SubjectPublicKeyInfo.PublicKey.cbData);

    if(Req.SubjectPublicKeyInfo.PublicKey.pbData == NULL)
    {
        goto error;
    }

    // Encode the public key info
    if(!CryptEncodeObject(X509_ASN_ENCODING, 
                      szOID_RSA_RSA_Public,
                      pCapiPublic,
                      Req.SubjectPublicKeyInfo.PublicKey.pbData,
                      &Req.SubjectPublicKeyInfo.PublicKey.cbData))
    {
        goto error;
    }

    Req.SubjectPublicKeyInfo.PublicKey.cUnusedBits = 0;

    // Encode the name
    Req.Subject.cbData =  EncodeDN(NULL, pszDN, FALSE);
    if((LONG)Req.Subject.cbData < 0)
    {
        goto error;
    }

    Req.Subject.pbData = SPExternalAlloc(Req.Subject.cbData);

    if(Req.Subject.pbData== NULL)
    {
        goto error;
    }

    Req.Subject.cbData = EncodeDN(Req.Subject.pbData, pszDN, TRUE);

    if((LONG)Req.Subject.cbData < 0)
    {
        goto error;
    }


    // Attributes
    Req.cAttribute = 0;
    Req.rgAttribute = NULL;

    SignAlg.pszObjId = szOID_RSA_MD5RSA;
    SignAlg.Parameters.cbData = 0;
    SignAlg.Parameters.pbData = NULL;

    // Encode the public key info
    if(!CryptSignAndEncodeCertificate(
                      hProv,
                      AT_SIGNATURE,
                      X509_ASN_ENCODING, 
                      X509_CERT_REQUEST_TO_BE_SIGNED,
                      &Req,
                      &SignAlg,
                      NULL,
                      NULL,
                      &pCerts->cbCertificate))
    {
        goto error;
    }

    pCerts->pCertificate = SPExternalAlloc(pCerts->cbCertificate);
    if(pCerts->pCertificate == NULL)
    {
        goto error;
    }

    // Encode the public key info
    if(!CryptSignAndEncodeCertificate(
                      hProv,
                      AT_SIGNATURE,
                      X509_ASN_ENCODING, 
                      X509_CERT_REQUEST_TO_BE_SIGNED,
                      &Req,
                      &SignAlg,
                      NULL,
                      pCerts->pCertificate,
                      &pCerts->cbCertificate))
    {
        goto error;
    }

    fRet = TRUE;

    goto cleanup;

error:
    if(pCerts->pPrivateKey)
    {
        SPExternalFree(pCerts->pPrivateKey);
    }

    if(pCerts->pCertificate)
    {
        SPExternalFree(pCerts->pCertificate);
    }


cleanup:
    if(pCapiPrivate)
    {
        SPExternalFree(pCapiPrivate);
    }

    if(pCapiPublic)
    {
        SPExternalFree(pCapiPublic);
    }


    if(Req.SubjectPublicKeyInfo.PublicKey.pbData)
    {
        SPExternalFree(Req.SubjectPublicKeyInfo.PublicKey.pbData);
    }

    if(Req.Subject.pbData)
    {
        SPExternalFree(Req.Subject.pbData);
    }


    if(hKey != 0)
    {
        CryptDestroyKey(hKey);
    }
    
    if(hProv != 0)
    {

        CryptReleaseContext(hProv,0);
        CryptAcquireContext(&hProv, SCHANNEL_GENKEY_NAME, NULL, PROV_RSA_FULL, CRYPT_DELETEKEYSET);
    }
    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\credapi.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       credapi.c
//
//  Contents:   Credential related API
//
//  Classes:
//
//  Functions:
//
//  History:    2-24-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"


//+---------------------------------------------------------------------------
//
//  Function:   XtcbAcceptCredentials
//
//  Synopsis:   Accept credentials stored during a prior logon session.
//
//  Arguments:  [LogonType]         -- Type of logon
//              [UserName]          -- name logged on with
//              [PrimaryCred]       -- Primary credential data
//              [SupplementalCreds] -- supplemental credential data
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
XtcbAcceptCredentials(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING UserName,
    IN PSECPKG_PRIMARY_CRED PrimaryCred,
    IN PSECPKG_SUPPLEMENTAL_CRED SupplementalCreds)
{
    PXTCB_CREDS Creds ;

    DebugLog(( DEB_TRACE_CALLS, "AcceptCredentials( %d, %ws, ...)\n",
                    LogonType, UserName->Buffer ));

    Creds = XtcbCreateCreds( &PrimaryCred->LogonId );

    if ( Creds )
    {
        return SEC_E_OK ;
    }

    return SEC_E_INSUFFICIENT_MEMORY ;
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbAcquireCredentialsHandle
//
//  Synopsis:   Acquire a handle representing the user.
//
//  Arguments:  [psPrincipal]      -- claimed name of user
//              [fCredentials]     -- credential use
//              [pLogonID]         -- logon id of the calling thread
//              [pvAuthData]       -- provided auth data pointer (unmapped)
//              [pvGetKeyFn]       -- function in calling process for key data
//              [pvGetKeyArgument] -- argument to be passed
//              [pdwHandle]        -- returned handle
//              [ptsExpiry]        -- expiration time
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS SEC_ENTRY
XtcbAcquireCredentialsHandle(
            PSECURITY_STRING    psPrincipal,
            ULONG               fCredentials,
            PLUID               pLogonId,
            PVOID               pvAuthData,
            PVOID               pvGetKeyFn,
            PVOID               pvGetKeyArgument,
            PLSA_SEC_HANDLE     pCredHandle,
            PTimeStamp          ptsExpiry)
{
    PXTCB_CREDS  Creds;
    PXTCB_CRED_HANDLE   Handle ;
    SECPKG_CLIENT_INFO  Info ;
    PSEC_WINNT_AUTH_IDENTITY AuthData ;

    DebugLog(( DEB_TRACE_CALLS, "AcquireCredentialsHandle(..., %x:%x, %x, ...)\n",
                                    pLogonId->HighPart, pLogonId->LowPart,
                                    pvAuthData ));

    Creds = NULL ;

    if ( pvAuthData == NULL )
    {

        if ( (pLogonId->LowPart == 0) && (pLogonId->HighPart == 0) )
        {
            LsaTable->GetClientInfo( &Info );

            *pLogonId = Info.LogonId ;

        }
        Creds = XtcbFindCreds( pLogonId, TRUE );

        if ( !Creds )
        {
            //
            // Time to create credentials for this user
            //

            Creds = XtcbCreateCreds( pLogonId );

            if ( !Creds )
            {
                return SEC_E_INSUFFICIENT_MEMORY ;
            }

            if ( Creds->Pac == NULL )
            {
                Creds->Pac = XtcbCreatePacForCaller();
            }
        }
    }
    else
    {
        return SEC_E_UNKNOWN_CREDENTIALS ;
    }

    Handle = XtcbAllocateCredHandle( Creds );

    XtcbDerefCreds( Creds );

    *pCredHandle = (LSA_SEC_HANDLE) Handle ;

    *ptsExpiry = XtcbNever ;

    if ( Handle )
    {
        Handle->Usage = fCredentials ;

        return SEC_E_OK ;
    }
    else
    {
        return SEC_E_INSUFFICIENT_MEMORY ;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   XtcbQueryCredentialsAttributes
//
//  Synopsis:   Return information about credentials
//
//  Arguments:  [dwCredHandle] -- Handle to check
//              [dwAttribute]  -- attribute to return
//              [Buffer]       -- Buffer to fill with attribute
//
//  History:    2-20-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbQueryCredentialsAttributes(
    LSA_SEC_HANDLE CredHandle,
    ULONG   dwAttribute,
    PVOID   Buffer)
{
    NTSTATUS Status ;
    PXTCB_CRED_HANDLE   Handle ;
    SecPkgCredentials_NamesW Names;

    DebugLog(( DEB_TRACE_CALLS, "QueryCredentialsAttribute( %p, %d, ... )\n",
                    CredHandle, dwAttribute ));

    Handle = (PXTCB_CRED_HANDLE) CredHandle ;

#if DBG
    if ( Handle->Check != XTCB_CRED_HANDLE_CHECK )
    {
        return SEC_E_INVALID_HANDLE ;
    }
#endif

    //
    // We only know about one credential attribute right now:
    //

    if ( dwAttribute != SECPKG_CRED_ATTR_NAMES )
    {
        return SEC_E_UNSUPPORTED_FUNCTION ;
    }

    Status = SEC_E_UNSUPPORTED_FUNCTION ;
    return Status ;

}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbFreeCredentialsHandle
//
//  Synopsis:   Dereferences a credential handle from AcquireCredHandle
//
//  Arguments:  [dwHandle] --
//
//  History:    2-20-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbFreeCredentialsHandle(
    LSA_SEC_HANDLE  CredHandle
    )
{
    PXTCB_CRED_HANDLE   Handle ;

    DebugLog(( DEB_TRACE_CALLS, "FreeCredentialsHandle( %p )\n", CredHandle ));

    Handle = (PXTCB_CRED_HANDLE) CredHandle ;

    if ( Handle->Check == XTCB_CRED_HANDLE_CHECK )
    {
        XtcbDerefCredHandle( Handle );

        return SEC_E_OK ;
    }

    return( SEC_E_INVALID_HANDLE );
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbLogonTerminated
//
//  Synopsis:   Called when the logon session has terminated (all tokens closed)
//
//  Arguments:  [pLogonId] -- Logon session that has terminated
//
//  History:    2-20-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SEC_ENTRY
XtcbLogonTerminated(PLUID  pLogonId)
{
    PXTCB_CREDS Creds ;

    DebugLog(( DEB_TRACE_CALLS, "LogonTerminated( %x:%x )\n",
                    pLogonId->HighPart, pLogonId->LowPart ));

    Creds = XtcbFindCreds( pLogonId, FALSE );

    if ( Creds )
    {
        Creds->Flags |= XTCB_CRED_TERMINATED ;

        XtcbDerefCreds( Creds );
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbGetUserInfo
//
//  Synopsis:   Return information about a user to the LSA
//
//  Arguments:  [pLogonId]   --
//              [fFlags]     --
//              [ppUserInfo] --
//
//  History:    2-20-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbGetUserInfo(  PLUID                   pLogonId,
                ULONG                   fFlags,
                PSecurityUserData *     ppUserInfo)
{
    PSecurityUserData   pInfo ;
    PXTCB_CREDS Creds ;
    SECURITY_STATUS Status ;

    DebugLog(( DEB_TRACE_CALLS, "GetUserInfo( %x:%x, %x, ...)\n",
                    pLogonId->HighPart, pLogonId->LowPart, fFlags ));


    return SEC_E_UNSUPPORTED_FUNCTION ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\creds.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       creds.c
//
//  Contents:   Cred Management for Xtcb Package
//
//  Classes:
//
//  Functions:
//
//  History:    2-19-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"

LIST_ENTRY  XtcbCredList ;
CRITICAL_SECTION    XtcbCredListLock ;

#define ReadLockCredList()  EnterCriticalSection( &XtcbCredListLock )
#define WriteLockCredList() EnterCriticalSection( &XtcbCredListLock )
#define WriteFromReadLockCredList()
#define UnlockCredList()    LeaveCriticalSection( &XtcbCredListLock )


//+---------------------------------------------------------------------------
//
//  Function:   XtcbInitCreds
//
//  Synopsis:   Initialize the credential management
//
//  Arguments:  (none)
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
XtcbInitCreds(
    VOID
    )
{
    InitializeCriticalSection( &XtcbCredListLock );

    InitializeListHead( &XtcbCredList );

    return TRUE ;
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbFindCreds
//
//  Synopsis:   Look for credentials of a particular logon id, optionally
//              referencing them
//
//  Arguments:  [LogonId] --
//              [Ref]     --
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PXTCB_CREDS
XtcbFindCreds(
    PLUID   LogonId,
    BOOL    Ref
    )
{
    PLIST_ENTRY Scan ;
    PXTCB_CREDS Cred ;

    Cred = NULL ;

    ReadLockCredList();

    Scan = XtcbCredList.Flink ;

    while ( Scan != &XtcbCredList )
    {
        Cred = CONTAINING_RECORD( Scan, XTCB_CREDS, List );

        DsysAssert( Cred->Check == XTCB_CRED_CHECK );

        if ( RtlEqualLuid( &Cred->LogonId, LogonId ) )
        {
            break;
        }

        Scan = Cred->List.Flink ;

        Cred = NULL ;
    }

    if ( Cred )
    {
        if ( Ref )
        {
            WriteFromReadLockCredList();

            Cred->RefCount++;
        }
    }

    UnlockCredList();

    return Cred ;

}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbCreateCreds
//
//  Synopsis:   Create and initialize a credential structure.  The reference
//              count is set to 1, so the pointer will remain valid.
//
//  Arguments:  [LogonId] --
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PXTCB_CREDS
XtcbCreateCreds(
    PLUID LogonId 
    )
{
    PXTCB_CREDS Creds ;

    Creds = (PXTCB_CREDS) LocalAlloc( LMEM_FIXED, sizeof( XTCB_CREDS ) );

    if ( Creds )
    {
        DebugLog(( DEB_TRACE_CREDS, "Creating new credential for (%x:%x)\n",
                   LogonId->HighPart, LogonId->LowPart ));

        ZeroMemory( Creds, sizeof( XTCB_CREDS ) );

        Creds->LogonId = *LogonId ;
        Creds->RefCount = 1 ;
        Creds->Check = XTCB_CRED_CHECK ;

        Creds->Pac = XtcbCreatePacForCaller();

        WriteLockCredList();

        InsertTailList( &XtcbCredList, &Creds->List );

        UnlockCredList();

    }

    return Creds ;
}


//+---------------------------------------------------------------------------
//
//  Function:   XtcbRefCreds
//
//  Synopsis:   Reference the credentials
//
//  Arguments:  [Creds] --
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
XtcbRefCreds(
    PXTCB_CREDS Creds
    )
{
    WriteLockCredList();

    Creds->RefCount++ ;

    UnlockCredList();

}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbDerefCreds
//
//  Synopsis:   Deref Credentials, freeing if the refcount goes to zero
//
//  Arguments:  [Creds] --
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
XtcbDerefCreds(
    PXTCB_CREDS Creds
    )
{
    WriteLockCredList();

    Creds->RefCount--;

    if ( Creds->RefCount )
    {
        UnlockCredList();

        return;
    }

    RemoveEntryList( &Creds->List );

    UnlockCredList();

    Creds->Check = 0 ;

    LocalFree( Creds );
}


//+---------------------------------------------------------------------------
//
//  Function:   XtcbAllocateCredHandle
//
//  Synopsis:   Allocates and returns a cred handle (reference to a credential)
//
//  Arguments:  [Creds] -- Creds this handle is for
//
//  History:    2-21-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PXTCB_CRED_HANDLE
XtcbAllocateCredHandle(
    PXTCB_CREDS Creds
    )
{
    PXTCB_CRED_HANDLE   Handle ;

    Handle = (PXTCB_CRED_HANDLE) LocalAlloc( LMEM_FIXED,
                            sizeof( XTCB_CRED_HANDLE ) );

    if ( Handle )
    {
        ZeroMemory( Handle, sizeof( XTCB_CRED_HANDLE )  );

        Handle->Check = XTCB_CRED_HANDLE_CHECK ;

        XtcbRefCreds( Creds );

        Handle->Creds = Creds ;

        Handle->RefCount = 1 ;

    }

    return Handle ;


}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbRefCredHandle
//
//  Synopsis:   Reference a credential handle
//
//  Arguments:  [Handle] -- Handle to ref
//
//  History:    2-24-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
XtcbRefCredHandle(
    PXTCB_CRED_HANDLE   Handle
    )
{
    WriteLockCredList();

    Handle->RefCount ++ ;

    UnlockCredList();

}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbDerefCredHandle
//
//  Synopsis:   Dereference a cred handle
//
//  Arguments:  [Handle] --
//
//  History:    2-24-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
XtcbDerefCredHandle(
    PXTCB_CRED_HANDLE   Handle
    )
{
    WriteLockCredList();

    Handle->RefCount -- ;

    if ( Handle->RefCount == 0 )
    {
        XtcbDerefCreds( Handle->Creds );

        LocalFree( Handle );
    }

    UnlockCredList();
}


//+---------------------------------------------------------------------------
//                           
//  Function:   XtcbCreatePacForCaller
//
//  Synopsis:   Creates an XTCB_PAC for the caller
//
//  Arguments:  none
//
//  History:    3-14-00   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
PXTCB_PAC
XtcbCreatePacForCaller(
    VOID
    )
{
    HANDLE Token ;
    NTSTATUS Status ;
    PXTCB_PAC Pac = NULL ;
    PTOKEN_USER User = NULL ;
    PTOKEN_GROUPS Groups = NULL ;
    PTOKEN_GROUPS Restrictions = NULL ;
    TOKEN_STATISTICS Stats ;
    ULONG UserSize ;
    ULONG GroupSize ;
    ULONG RestrictionSize ;
    ULONG PacGroupSize = 0 ;
    ULONG PacRestrictionSize = 0 ;
    ULONG PacUserName = 0 ;
    ULONG PacDomainName = 0 ;
    ULONG PacSize ;
    ULONG i ;
    PUCHAR CopyTo ;
    PUCHAR Base ;
    BOOL SpecialAccount = FALSE ;
    PSECURITY_LOGON_SESSION_DATA LogonSessionData = NULL ;



    Status = LsaTable->ImpersonateClient();

    if ( !NT_SUCCESS( Status ) )
    {
        return NULL ;
    }

    Status = NtOpenThreadToken(
                NtCurrentThread(),
                TOKEN_READ,
                TRUE,
                &Token );

    RevertToSelf();

    if ( !NT_SUCCESS( Status ) )
    {
        return NULL ;
    }

    //
    // Now that we have the token, capture all the information about this user,
    // and compute our own "PAC" structure.
    //

    Status = NtQueryInformationToken(
                Token,
                TokenStatistics,
                &Stats,
                sizeof( Stats ),
                &UserSize );

    if ( !NT_SUCCESS( Status ) )
    {
        goto CreatePac_Exit ;
    }

    //
    // If this is a special logon session (e.g. LocalSystem, LocalService, etc.),
    // then the LUID will be less than 1000.  Set the flag to copy all SIDs in the token.
    //

    if ( (Stats.AuthenticationId.HighPart == 0) &&
         (Stats.AuthenticationId.LowPart < 1000 ) )
    {
        SpecialAccount = TRUE ;
    }

    UserSize = 0 ;

    (void) NtQueryInformationToken(
                Token,
                TokenUser,
                NULL,
                0,
                &UserSize );

    if ( UserSize == 0 )
    {
        goto CreatePac_Exit ;
    }

    User = LocalAlloc( LMEM_FIXED, UserSize );

    if ( !User )
    {
        goto CreatePac_Exit ;
    }

    Status = NtQueryInformationToken(
                Token,
                TokenUser,
                User,
                UserSize,
                &UserSize );

    if ( !NT_SUCCESS( Status ) )
    {
        goto CreatePac_Exit ;
    }

    GroupSize = 0 ;
    
    (void) NtQueryInformationToken(
                Token,
                TokenGroups,
                NULL,
                0,
                &GroupSize );

    if ( GroupSize == 0 )
    {
        goto CreatePac_Exit ;
    }

    Groups = LocalAlloc( LMEM_FIXED, GroupSize );

    if ( !Groups )
    {
        goto CreatePac_Exit ;
    }

    Status = NtQueryInformationToken(
                Token,
                TokenGroups,
                Groups,
                GroupSize,
                &GroupSize );

    if ( !NT_SUCCESS( Status ) )
    {
        goto CreatePac_Exit;
    }

    RestrictionSize = 0 ;

    (void) NtQueryInformationToken(
                Token,
                TokenRestrictedSids,
                NULL,
                0,
                &RestrictionSize );

    if ( RestrictionSize != 0 )
    {
        Restrictions = LocalAlloc( LMEM_FIXED, RestrictionSize );

        if ( Restrictions )
        {
            Status = NtQueryInformationToken(
                        Token,
                        TokenRestrictedSids,
                        Restrictions,
                        RestrictionSize,
                        &RestrictionSize );

            if ( !NT_SUCCESS( Status ) )
            {
                goto CreatePac_Exit ;
            }
        }
        else 
        {
            goto CreatePac_Exit ;
        }
    }


    //
    // We now have all the users SIDs in the two (or three) pointers.  First, grovel the Groups
    // for non-local SIDs, and set all the rest to 0.  This will let us compute how much space
    // we need.
    //

    for ( i = 0 ; i < Groups->GroupCount ; i++ )
    {
        if ( (*RtlSubAuthorityCountSid( Groups->Groups[ i ].Sid ) > 2) ||
             (SpecialAccount) )
        {
            //
            // A "real" SID.  Check to make sure it is not from this machine
            //

            if ( ( XtcbMachineSid != NULL ) && 
                 RtlEqualPrefixSid( XtcbMachineSid, Groups->Groups[ i ].Sid ) )
            {
                //
                // Don't use this group
                //

                Groups->Groups[ i ].Attributes = 0 ;
            }
            else 
            {
                //
                // We like this SID (it is not from the local machine)
                //

                Groups->Groups[ i ].Attributes = SE_GROUP_MANDATORY ;
                PacGroupSize += RtlLengthSid( Groups->Groups[ i ].Sid );
            }
        }
        else 
        {
            Groups->Groups[ i ].Attributes = 0 ;
        }
    }

    //
    // Do the same for the restrictions, if any
    //

    if ( Restrictions )
    {
        for ( i = 0 ; i < Restrictions->GroupCount ; i++ )
        {
            PacRestrictionSize += RtlLengthSid( Restrictions->Groups[ i ].Sid );
        }
    }

    //
    // Get the user's name and domain:
    //

    Status = LsaGetLogonSessionData( 
                    &Stats.AuthenticationId, 
                    &LogonSessionData );

    if ( !NT_SUCCESS( Status ) )
    {
        goto CreatePac_Exit ;
    }

    PacUserName = LogonSessionData->UserName.Length ;
    PacDomainName = LogonSessionData->LogonDomain.Length ;

    //
    // In an advanced world, we'd query the other packages for
    // delegatable credentials, bundle them up and ship them
    // over.
    //


    //
    // Ok, we've got all the information we need
    //

    PacSize = sizeof( XTCB_PAC ) +
              RtlLengthSid( User->User.Sid ) +
              PacGroupSize +
              PacRestrictionSize +
              PacUserName +
              PacDomainName ;

    Pac = LocalAlloc( LMEM_FIXED, PacSize );

    if ( !Pac )
    {
        goto CreatePac_Exit ;
    }


    //
    // Create the PAC structure:
    //

    Pac->Tag = XTCB_PAC_TAG ;
    Pac->Length = PacSize ;

    CopyTo = (PUCHAR) (Pac + 1);
    Base = (PUCHAR) Pac ;
    
    //
    // Assemble the PAC:
    //
    // first, the user
    //

    Pac->UserOffset = (ULONG) (CopyTo - Base);
    Pac->UserLength = RtlLengthSid( User->User.Sid );

    RtlCopyMemory(
        CopyTo,
        User->User.Sid,
        Pac->UserLength );

    CopyTo += RtlLengthSid( User->User.Sid );

    //
    // Now the normal groups:
    //

    Pac->GroupCount = 0 ;
    Pac->GroupOffset = (ULONG) (CopyTo - Base);


    for ( i = 0 ; i < Groups->GroupCount ; i++ )
    {
        if ( Groups->Groups[ i ].Attributes & SE_GROUP_MANDATORY )
        {
            RtlCopyMemory(
                    CopyTo,
                    Groups->Groups[ i ].Sid,
                    RtlLengthSid( Groups->Groups[ i ].Sid ) );

            CopyTo += RtlLengthSid( Groups->Groups[ i ].Sid );

            Pac->GroupCount++ ;
        }
    }
    Pac->GroupLength = (ULONG) (CopyTo - Base) - Pac->GroupOffset;

    //
    // If there are restrictions, copy them in as well
    //

    if ( (Restrictions == NULL) ||
         (Restrictions->GroupCount == 0 ) )
    {
        Pac->RestrictionCount = 0 ;
        Pac->RestrictionOffset = 0 ;
        Pac->RestrictionLength = 0 ;
    }
    else 
    {
        Pac->RestrictionCount = Restrictions->GroupCount ;
        Pac->RestrictionOffset = (ULONG) ( CopyTo - Base );

        for ( i = 0 ; i < Restrictions->GroupCount ; i++ )
        {
            RtlCopyMemory(
                    CopyTo,
                    Restrictions->Groups[ i ].Sid,
                    RtlLengthSid( Restrictions->Groups[ i ].Sid ) );

            CopyTo += RtlLengthSid( Restrictions->Groups[ i ].Sid );

            Pac->RestrictionCount++ ;
        }
        Pac->RestrictionLength = (ULONG) (CopyTo - Base) - Pac->RestrictionOffset ;
    }

    Pac->NameOffset = (ULONG) ( CopyTo - Base );
    Pac->NameLength = LogonSessionData->UserName.Length ;
    RtlCopyMemory(
            CopyTo,
            LogonSessionData->UserName.Buffer,
            LogonSessionData->UserName.Length );

    CopyTo += LogonSessionData->UserName.Length ;

    Pac->DomainLength = LogonSessionData->LogonDomain.Length ;
    Pac->DomainOffset = (ULONG) ( CopyTo - Base );

    RtlCopyMemory(
            CopyTo,
            LogonSessionData->LogonDomain.Buffer,
            LogonSessionData->LogonDomain.Length );


    
    //
    // Someday, maybe, copy credential data here
    //

    Pac->CredentialLength = 0 ;
    Pac->CredentialOffset = 0 ;
    

CreatePac_Exit:

    if ( LogonSessionData )
    {
        LsaFreeReturnBuffer( LogonSessionData );
    }

    if ( User )
    {
        LocalFree( User );
    }

    if ( Groups )
    {
        LocalFree( Groups );
    }

    if ( Restrictions )
    {
        LocalFree( Restrictions );
    }

    NtClose( Token );

    return Pac ;
    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\debug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       debug.h
//
//  Contents:   Debug helpers
//
//  Classes:
//
//  Functions:
//
//  History:    2-20-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__


#include <dsysdbg.h>
DECLARE_DEBUG2( XtcbPkg );

#if DBG
#define DebugLog(x) XtcbPkgDebugPrint x
#else
#define DebugLog(x)
#endif

#define DEB_TRACE_CREDS     0x00000008          // Trace Credentials
#define DEB_TRACE_CTXT      0x00000010          // Trace contexts
#define DEB_TRACE_CALLS     0x00000020          // Trace Enters
#define DEB_TRACE_AUTH      0x00000040          // Trace Authentication

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\debug.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       debug.c
//
//  Contents:   Debug support
//
//  Classes:
//
//  Functions:
//
//  History:    2-19-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"

DEFINE_DEBUG2( XtcbPkg );
DEBUG_KEY   XtcbPkgDebugKeys[] = { {DEB_ERROR,            "Error"},
                                 {DEB_WARN,             "Warning"},
                                 {DEB_TRACE,            "Trace"},
                                 {DEB_TRACE_CREDS,      "Creds"},
                                 {DEB_TRACE_CTXT,       "Context"},
                                 {DEB_TRACE_CALLS,      "Calls"},
                                 {DEB_TRACE_AUTH,       "Auth"},
                                 {0, NULL},
                                 };

void
InitDebugSupport(void)
{
    XtcbPkgInitDebug( XtcbPkgDebugKeys );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\ctxtapi.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       ctxtapi.c
//
//  Contents:   LSA Mode Context API
//
//  Classes:
//
//  Functions:
//
//  History:    2-24-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"
#include "md5.h"

typedef struct _XTCB_ATTR_MAP {
    ULONG Request ; 
    ULONG Return ;
} XTCB_ATTR_MAP ;

XTCB_ATTR_MAP AcceptMap[] = {
    { ASC_REQ_DELEGATE, ASC_RET_DELEGATE },
    { ASC_REQ_MUTUAL_AUTH, ASC_RET_MUTUAL_AUTH },
    { ASC_REQ_REPLAY_DETECT, ASC_RET_REPLAY_DETECT },
    { ASC_REQ_SEQUENCE_DETECT, ASC_RET_SEQUENCE_DETECT },
    { ASC_REQ_CONFIDENTIALITY, ASC_RET_CONFIDENTIALITY },
    { ASC_REQ_ALLOCATE_MEMORY, ASC_RET_ALLOCATED_MEMORY },
    { ASC_REQ_CONNECTION, ASC_RET_CONNECTION },
    { ASC_REQ_INTEGRITY, ASC_RET_INTEGRITY }
};

XTCB_ATTR_MAP InitMap[] = {
    { ISC_REQ_DELEGATE, ISC_RET_DELEGATE },
    { ISC_REQ_MUTUAL_AUTH, ISC_RET_MUTUAL_AUTH },
    { ISC_REQ_SEQUENCE_DETECT, ISC_RET_MUTUAL_AUTH },
    { ISC_REQ_REPLAY_DETECT, ISC_RET_REPLAY_DETECT },
    { ISC_REQ_CONFIDENTIALITY, ISC_RET_CONFIDENTIALITY },
    { ISC_REQ_ALLOCATE_MEMORY, ISC_RET_ALLOCATED_MEMORY },
    { ISC_REQ_INTEGRITY, ISC_RET_INTEGRITY }
};


ULONG
XtcbMapAttributes(
    ULONG Input,
    BOOL Init
    )
{
    int i;
    ULONG Result = 0 ;

    if ( Init )
    {
        for ( i = 0 ; i < sizeof( InitMap ) / sizeof( XTCB_ATTR_MAP ) ; i++ )
        {
            if ( InitMap[i].Request & Input )
            {
                Result |= InitMap[i].Return ;
            }
        }
    }
    else
    {
        for ( i = 0 ; i < sizeof( AcceptMap ) / sizeof( XTCB_ATTR_MAP ) ; i++ )
        {
            if ( AcceptMap[i].Request & Input )
            {
                Result |= AcceptMap[i].Return ;
            }
        }
    }

    return Result ;
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbGetState
//
//  Synopsis:   Translates handles to their structures, and pulls out the
//              interesting bits of the input and output buffers
//
//  Arguments:  [dwCredHandle] --
//              [dwCtxtHandle] --
//              [pInput]       --
//              [pOutput]      --
//              [Client]       --
//              [pContext]     --
//              [pCredHandle]  --
//              [pInToken]     --
//              [pOutToken]    --
//
//  History:    3-05-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
XtcbGetState(
    LSA_SEC_HANDLE  dwCredHandle,
    LSA_SEC_HANDLE  dwCtxtHandle,
    PSecBufferDesc  pInput,
    PSecBufferDesc  pOutput,
    BOOL    Client,
    PXTCB_CONTEXT * pContext,
    PXTCB_CRED_HANDLE * pCredHandle,
    PSecBuffer * pInToken,
    PSecBuffer * pOutToken)
{
    SECURITY_STATUS scRet;
    PXTCB_CONTEXT   Context ;
    PXTCB_CRED_HANDLE CredHandle ;
    PSecBuffer  OutToken ;
    PSecBuffer  InToken ;
    ULONG   i;


    if ( dwCtxtHandle )
    {
        Context = (PXTCB_CONTEXT) dwCtxtHandle ;

        if ( !XtcbRefContextRecord( Context ) )
        {
            return SEC_E_INVALID_HANDLE ;
        }

        CredHandle = (PXTCB_CRED_HANDLE) Context->CredHandle ;
    }
    else
    {
        CredHandle = (PXTCB_CRED_HANDLE) dwCredHandle ;

        if ( !CredHandle )
        {
            return SEC_E_INVALID_HANDLE ;
        }

        Context = XtcbCreateContextRecord( (Client ?
                                                XtcbContextClient :
                                                XtcbContextServer),
                                           CredHandle );

        if ( !Context )
        {
            return SEC_E_INSUFFICIENT_MEMORY ;
        }
    }

    //
    // Find the output token buffer:
    //

    OutToken = NULL ;

    for ( i = 0 ; i < pOutput->cBuffers ; i++ )
    {
        if ( (pOutput->pBuffers[i].BufferType & (~SECBUFFER_ATTRMASK)) ==
                    SECBUFFER_TOKEN )
        {
            OutToken = &pOutput->pBuffers[i] ;
            LsaTable->MapBuffer( OutToken, OutToken );
            break;
        }
    }

    //
    // Find the input token buffer:
    //

    InToken = NULL ;

    for ( i = 0 ; i < pInput->cBuffers ; i++ )
    {
        if ( (pInput->pBuffers[i].BufferType & (~SECBUFFER_ATTRMASK)) ==
                    SECBUFFER_TOKEN )
        {
            InToken = &pInput->pBuffers[i] ;
            LsaTable->MapBuffer( InToken, InToken );
            break;
        }
    }

    *pContext = Context ;
    *pCredHandle = CredHandle ;
    *pInToken = InToken ;
    *pOutToken = OutToken ;

    return SEC_E_OK ;
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbInitLsaModeContext
//
//  Synopsis:   Creates a client side context and blob
//
//  Arguments:  [dwCredHandle]  --
//              [dwCtxtHandle]  --
//              [pszTargetName] --
//              [fContextReq]   --
//              [TargetDataRep] --
//              [pInput]        --
//              [pdwNewContext] --
//              [pOutput]       --
//              [pfContextAttr] --
//              [ptsExpiry]     --
//              [pfMapContext]  --
//              [pContextData]  --
//
//  History:    8-15-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbInitLsaModeContext(
    LSA_SEC_HANDLE      dwCredHandle,
    LSA_SEC_HANDLE      dwCtxtHandle,
    PSECURITY_STRING    TargetName,
    ULONG               fContextReq,
    ULONG               TargetDataRep,
    PSecBufferDesc      pInput,
    PLSA_SEC_HANDLE     pdwNewContext,
    PSecBufferDesc      pOutput,
    PULONG              pfContextAttr,
    PTimeStamp          ptsExpiry,
    PBYTE               pfMapContext,
    PSecBuffer          pContextData)
{
    SECURITY_STATUS scRet;
    PXTCB_CONTEXT   Context ;
    PXTCB_CRED_HANDLE CredHandle ;
    PSecBuffer  OutToken ;
    PSecBuffer  InToken ;
    UCHAR GroupKey[ SEED_KEY_SIZE ];
    UCHAR UniqueKey[ SEED_KEY_SIZE ];
    UCHAR MyKey[ SEED_KEY_SIZE ];
    PWSTR Target ;
    BOOL RealTarget = FALSE ;
    PUCHAR Buffer;
    ULONG BufferLen ;
    PUNICODE_STRING Group ;


    DebugLog(( DEB_TRACE_CALLS, "InitLsaModeContext( %p, %p, %ws, ... )\n",
                dwCredHandle, dwCtxtHandle,
                (TargetName->Buffer ? TargetName->Buffer : L"<none>") ));

    if ( fContextReq & 
         ( ISC_REQ_PROMPT_FOR_CREDS |
           ISC_REQ_USE_SUPPLIED_CREDS |
           ISC_REQ_DATAGRAM |
           ISC_REQ_STREAM |
           ISC_REQ_NULL_SESSION |
           ISC_REQ_MANUAL_CRED_VALIDATION ) )
    {
        return STATUS_INVALID_PARAMETER ;
    }

    //
    // Determine what kind of call this is (first or second)
    //

    scRet = XtcbGetState(   dwCredHandle,
                            dwCtxtHandle,
                            pInput,
                            pOutput,
                            TRUE,
                            &Context,
                            &CredHandle,
                            &InToken,
                            &OutToken );

    if ( FAILED( scRet ) )
    {
        return scRet ;
    }


    //
    // Decide what to do:
    //


    if ( Context->Core.State == ContextFirstCall )
    {
        if ( InToken )
        {
            //
            // Something there
            //
            scRet = SEC_E_INVALID_TOKEN ;
        }
        else
        {

            if ( !OutToken )
            {
                scRet = SEC_E_INVALID_TOKEN ;
            }
            else 
            {
                //
                // Examine the target name.  See if we can handle it:
                //

                if ( MGroupParseTarget( TargetName->Buffer,
                                        &Target ) )
                {
                    //
                    // See if we have a group with that machine as a member:
                    //

                    if ( MGroupLocateKeys( Target,
                                           &Group,
                                           UniqueKey,
                                           GroupKey,
                                           MyKey ) )
                    {
                        //
                        // We do have one!  Calooh!  Calay!
                        //

                        RealTarget = TRUE ;

                    }

                }

                if ( !RealTarget )
                {
                    //
                    // Not one of ours.  Delete the context, 
                    // clean up
                    //

                    scRet = SEC_E_TARGET_UNKNOWN ;
                }

            }

            if ( RealTarget )
            {
                //
                // We've got a live target.  Fill in the context, and construct
                // the blob
                //

                scRet = XtcbBuildInitialToken(
                            CredHandle->Creds,
                            Context,
                            TargetName,
                            Group,
                            UniqueKey,
                            GroupKey,
                            MyKey,
                            &Buffer,
                            &BufferLen );



            }


            if ( NT_SUCCESS( scRet ) )
            {

                if ( fContextReq & ISC_REQ_ALLOCATE_MEMORY )
                {
                    OutToken->pvBuffer = Buffer ;
                    OutToken->cbBuffer = BufferLen ;
                }
                else 
                {
                    if ( BufferLen <= OutToken->cbBuffer )
                    {
                        RtlCopyMemory( 
                            OutToken->pvBuffer,
                            Buffer,
                            BufferLen );

                        OutToken->cbBuffer = BufferLen ;
                    }
                    else 
                    {
                        scRet = SEC_E_INSUFFICIENT_MEMORY ;
                    }
                }


            }

            if ( NT_SUCCESS( scRet ) )
            {

                Context->Core.State = ContextSecondCall ;
                Context->Core.Attributes = fContextReq ;

                *pdwNewContext = (LSA_SEC_HANDLE) Context ;
            }
            else 
            {
                XtcbDerefContextRecord( Context );

            }


            return scRet ;
        }
    }
    else
    {
        //
        // Second round
        //

        
    }


    return( scRet );


}


//+---------------------------------------------------------------------------
//
//  Function:   XtcbDeleteContext
//
//  Synopsis:   Deletes the LSA side of a context
//
//  Arguments:  [dwCtxtHandle] --
//
//  History:    8-15-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbDeleteContext(
    LSA_SEC_HANDLE dwCtxtHandle
    )
{
    PXTCB_CONTEXT Context ;

    DebugLog(( DEB_TRACE_CALLS, "DeleteContext( %x )\n", dwCtxtHandle ));

    Context = (PXTCB_CONTEXT) dwCtxtHandle ;

    if ( XtcbRefContextRecord( Context ) )
    {
        XtcbDerefContextRecord( Context );

        XtcbDerefContextRecord( Context );

        return SEC_E_OK ;
    }

    return( SEC_E_INVALID_HANDLE );
}


//+---------------------------------------------------------------------------
//
//  Function:   XtcbApplyControlToken
//
//  Synopsis:   Apply a control token to a context
//
//  Effects:    not supported
//
//  Arguments:  [dwCtxtHandle] --
//              [pInput]       --
//
//  History:    8-15-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------


SECURITY_STATUS
SEC_ENTRY
XtcbApplyControlToken(
    LSA_SEC_HANDLE dwCtxtHandle,
    PSecBufferDesc  pInput)
{
    DebugLog(( DEB_TRACE_CALLS, "ApplyControlToken( %x )\n", dwCtxtHandle ));

    return(SEC_E_UNSUPPORTED_FUNCTION);
}


//+---------------------------------------------------------------------------
//
//  Function:   XtcbAcceptLsaModeContext
//
//  Synopsis:   Creates a server side context representing the user connecting
//
//  Arguments:  [dwCredHandle]  --
//              [dwCtxtHandle]  --
//              [pInput]        --
//              [fContextReq]   --
//              [TargetDataRep] --
//              [pdwNewContext] --
//              [pOutput]       --
//              [pfContextAttr] --
//              [ptsExpiry]     --
//              [pfMapContext]  --
//              [pContextData]  --
//
//  History:    8-15-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbAcceptLsaModeContext(
    LSA_SEC_HANDLE  dwCredHandle,
    LSA_SEC_HANDLE  dwCtxtHandle,
    PSecBufferDesc  pInput,
    ULONG           fContextReq,
    ULONG           TargetDataRep,
    PLSA_SEC_HANDLE pdwNewContext,
    PSecBufferDesc  pOutput,
    PULONG          pfContextAttr,
    PTimeStamp      ptsExpiry,
    PBYTE           pfMapContext,
    PSecBuffer      pContextData)
{
    SECURITY_STATUS scRet;
    PXTCB_CONTEXT   Context ;
    PXTCB_CRED_HANDLE CredHandle ;
    PSecBuffer  OutToken ;
    PSecBuffer  InToken ;
    HANDLE      Token ;
    UNICODE_STRING Client;
    UNICODE_STRING Group ;
    UCHAR GroupKey[ SEED_KEY_SIZE ];
    UCHAR UniqueKey[ SEED_KEY_SIZE ];
    UCHAR MyKey[ SEED_KEY_SIZE ];
    BOOL Success = FALSE ;

    DebugLog(( DEB_TRACE_CALLS, "AcceptLsaModeContext( %x, %x, ... )\n",
                    dwCredHandle, dwCtxtHandle ));


    //
    // Determine what kind of call this is (first or second)
    //

    *pfMapContext = FALSE ;

    scRet = XtcbGetState(   dwCredHandle,
                            dwCtxtHandle,
                            pInput,
                            pOutput,
                            FALSE,
                            &Context,
                            &CredHandle,
                            &InToken,
                            &OutToken );

    if ( FAILED( scRet ) )
    {
        return scRet ;
    }


    //
    // Decide what to do:
    //

    if ( Context->Core.State == ContextFirstCall )
    {
        if ( !InToken )
        {
            return SEC_E_INVALID_TOKEN ;
        }

        if ( !XtcbParseInputToken(
                    InToken->pvBuffer,
                    InToken->cbBuffer,
                    &Client,
                    &Group ) )
        {
            DebugLog((DEB_TRACE, "Unable to parse input token\n" ));

            return SEC_E_INVALID_TOKEN ;
        }

        Success = MGroupLocateInboundKey(
                            &Group,
                            &Client,
                            UniqueKey,
                            GroupKey,
                            MyKey );

        LocalFree( Client.Buffer );
        LocalFree( Group.Buffer );

        if ( Success )
        {
            scRet = XtcbAuthenticateClient(
                        Context,
                        InToken->pvBuffer,
                        InToken->cbBuffer,
                        UniqueKey,
                        GroupKey,
                        MyKey
                        );
                        

        }
        else 
        {
            DebugLog(( DEB_TRACE, "Unable to find group entry for Group %ws, Client %ws\n",
                        Group.Buffer, Client.Buffer ));

            scRet = SEC_E_INVALID_TOKEN ;
        }

        if ( NT_SUCCESS( scRet ) )
        {
            scRet = XtcbBuildReplyToken(
                        Context,
                        fContextReq,
                        OutToken );
        }

        if ( NT_SUCCESS( scRet ) )
        {

            Context->Core.State = ContextSecondCall ;
            //
            // Ok, we've done the authentication.  Now, we need to map
            // the security context back to the client process
            //

            scRet = LsaTable->DuplicateHandle(
                                Context->Token,
                                &Token );

            if ( NT_SUCCESS( scRet ) )
            {
                Context->Core.CoreTokenHandle = HandleToUlong( Token );

                *pfMapContext = TRUE ;

                pContextData->BufferType = SECBUFFER_TOKEN ;
                pContextData->cbBuffer = sizeof( XTCB_CONTEXT_CORE );
                pContextData->pvBuffer = &Context->Core ;

                *pfContextAttr = ASC_RET_DELEGATE |
                                 ASC_RET_MUTUAL_AUTH |
                                 ASC_RET_REPLAY_DETECT |
                                 ASC_RET_SEQUENCE_DETECT |
                                 ASC_RET_CONFIDENTIALITY |
                                 ASC_
            }

            
        }


    }

    return( scRet );
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbQueryLsaModeContext
//
//  Synopsis:   Lifespan is thunked to LSA mode for demonstration purposes
//
//  Arguments:  [ContextHandle]    --
//              [ContextAttribute] --
//              [pBuffer]          --
//
//  History:    3-30-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
NTAPI
XtcbQueryLsaModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN OUT PVOID pBuffer
    )
{
    PXTCB_CONTEXT Context ;
    NTSTATUS Status ;

    Context = (PXTCB_CONTEXT) ContextHandle ;

    if ( !XtcbRefContextRecord( Context ))
    {
        return SEC_E_INVALID_HANDLE ;
    }

    Status = SEC_E_UNSUPPORTED_FUNCTION ;

    XtcbDerefContextRecord( Context );

    return( Status );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\protocol.h ===
#ifndef __PROTOCOL_H__
#define __PROTOCOL_H__


#define XTCB_SEED_LENGTH    16
#define XTCB_HMAC_LENGTH    16

typedef struct _XTCB_INIT_MESSAGE {
    ULONG   Version ;
    ULONG   Length ;
    UCHAR   Seed[ XTCB_SEED_LENGTH ];
    UCHAR   HMAC[ XTCB_HMAC_LENGTH ];
    UNICODE_STRING32 OriginatingNode ;
    UNICODE_STRING32 Group ;
    ULONG   PacOffset ;
    ULONG   PacLength ;
} XTCB_INIT_MESSAGE, * PXTCB_INIT_MESSAGE ;

typedef struct _XTCB_INIT_MESSAGE_REPLY {
    ULONG   Version ;
    ULONG   Length ;
    UCHAR   ReplySeed[ XTCB_SEED_LENGTH ];
    UCHAR   HMAC[ XTCB_HMAC_LENGTH ];
} XTCB_INIT_MESSAGE_REPLY, * PXTCB_INIT_MESSAGE_REPLY ;

typedef struct _XTCB_MESSAGE_SIGNATURE {
    ULONG   Version ;
    UCHAR   HMAC[ XTCB_HMAC_LENGTH ];
    ULONG   SequenceNumber ;
} XTCB_MESSAGE_SIGNATURE, * PXTCB_MESSAGE_SIGNATURE ;

typedef struct _XTCB_PAC {
    ULONG   Tag ;
    ULONG   Length ;

    ULONG   UserOffset ;
    ULONG   GroupCount ;
    ULONG   GroupOffset ;
    ULONG   UserLength ;
    ULONG   GroupLength ;
    ULONG   RestrictionCount ;
    ULONG   RestrictionOffset ;
    ULONG   RestrictionLength ;
    ULONG   NameOffset;
    ULONG   NameLength;
    ULONG   DomainOffset;
    ULONG   DomainLength;
    ULONG   CredentialOffset ;
    ULONG   CredentialLength ;

    UCHAR   UniqueTag[ XTCB_SEED_LENGTH ];
} XTCB_PAC, * PXTCB_PAC ;    

#define XTCB_PAC_TAG    'BCTX'

                      
#endif // __PROTOCOL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\creds.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       creds.h
//
//  Contents:   Credential mgmt prototypes
//
//  Classes:
//
//  Functions:
//
//  History:    2-19-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __CREDS_H__
#define __CREDS_H__


#define XTCB_CRED_CHECK      'tseT'

typedef struct _XTCB_CREDS {
    ULONG       Check;
    ULONG       Flags ;
    LIST_ENTRY  List ;
    LUID        LogonId ;
    ULONG       RefCount ;
    SECURITY_STRING Name ;
    PXTCB_PAC   Pac ;
} XTCB_CREDS, * PXTCB_CREDS ;

#define XTCB_CRED_TERMINATED    0x00000001

#define XTCB_CRED_HANDLE_CHECK  'naHC'

typedef struct _XTCB_CRED_HANDLE {
    ULONG       Check ;
    PXTCB_CREDS Creds ;
    PVOID       SharedMemory ;
    ULONG       Usage ;
    ULONG       RefCount ;
} XTCB_CRED_HANDLE, * PXTCB_CRED_HANDLE;


BOOL
XtcbInitCreds(
    VOID
    );

PXTCB_CREDS
XtcbFindCreds(
    PLUID   LogonId,
    BOOL    Ref
    );

PXTCB_CREDS
XtcbCreateCreds(
    PLUID LogonId
    );

VOID
XtcbRefCreds(
    PXTCB_CREDS Creds
    );

VOID
XtcbDerefCreds(
    PXTCB_CREDS Creds
    );

PXTCB_CRED_HANDLE
XtcbAllocateCredHandle(
    PXTCB_CREDS Creds
    );

VOID
XtcbRefCredHandle(
    PXTCB_CRED_HANDLE   Handle
    );

VOID
XtcbDerefCredHandle(
    PXTCB_CRED_HANDLE   Handle
    );

#endif // __CREDS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\mgroup.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       mgroup.c
//
//  Contents:   LSA Mode Context API
//
//  Classes:
//
//  Functions:
//
//  History:    2-24-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"
#include <cryptdll.h>

LIST_ENTRY MachineGroupList ;
CRITICAL_SECTION MachineGroupLock ;
WCHAR MachineLocalName[ MAX_PATH ];

#define LOOPBACK_KEY    L"Loopback"
#define GROUPKEY_VALUE  L"$$GroupKey"

PXTCB_MACHINE_GROUP_ENTRY
MGpCreateGroupEntry(
    PWSTR MachineName,
    PUCHAR Key
    )
{
    PXTCB_MACHINE_GROUP_ENTRY Entry ;
    ULONG Length ;

    Length = wcslen( MachineName ) + 1;
    
    Entry = LocalAlloc( LMEM_FIXED, 
                        sizeof( XTCB_MACHINE_GROUP_ENTRY ) + (Length * sizeof(WCHAR) ) );

    if ( Entry )
    {
        Entry->MachineName = (PWSTR) (Entry + 1);
        CopyMemory( Entry->UniqueKey, 
                    Key, 
                    SEED_KEY_SIZE );

        CopyMemory( Entry->MachineName,
                    MachineName,
                    Length * sizeof(WCHAR) );

        if ( _wcsicmp( MachineName, MachineLocalName ) == 0 )
        {
            Entry->Flags = MGROUP_ENTRY_SELF ;
        }
        else 
        {
            Entry->Flags = 0;
        }

    }

    return Entry ;
    
}

VOID
MGpFreeGroup(
    PXTCB_MACHINE_GROUP Group
    )
{
    ULONG i ;

    for ( i = 0 ; i < Group->Count ; i++ )
    {
        LocalFree( Group->GroupList[ i ] );
    }

    LocalFree( Group );
}

PXTCB_MACHINE_GROUP
MGpCreateMachineGroup(
    HKEY Root,
    PWSTR KeyName
    )
{
    ULONG Count ;
    ULONG Size ;
    ULONG Type ;
    UCHAR Key[ SEED_KEY_SIZE ];
    PWSTR Name ;
    ULONG MaxName ;
    ULONG NameSize ;
    ULONG Index ;
    PXTCB_MACHINE_GROUP Group ;
    int err ;


    err = RegQueryInfoKey(
                Root,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                &Count,
                &MaxName,
                NULL,
                NULL,
                NULL );

    if ( err )
    {
        return NULL ;
    }

    MaxName++;

    Name = LocalAlloc( LMEM_FIXED, (MaxName) * sizeof( WCHAR ) );

    if ( !Name )
    {
        return NULL ;
    }

    Group = LocalAlloc( LMEM_FIXED,
                        sizeof( XTCB_MACHINE_GROUP ) +
                            ( Count ) * sizeof( PXTCB_MACHINE_GROUP_ENTRY ) +
                            ( wcslen( KeyName ) + 1 ) * sizeof( WCHAR ) );

    if ( !Group )
    {
        LocalFree( Name );
        return NULL ;
    }

    //
    // We've got all the base structures.  Let's load it in:
    //

    Group->List.Flink = NULL ;
    Group->List.Blink = NULL ;
    Group->Count = 0 ;
    Group->GroupList = (PXTCB_MACHINE_GROUP_ENTRY *) (Group + 1);
    Group->Group.Buffer = (PWSTR) ((PUCHAR) Group->GroupList + 
                               (Count * sizeof( PXTCB_MACHINE_GROUP_ENTRY ) ) );

    wcscpy( Group->Group.Buffer, KeyName );
    Group->Group.Length = wcslen( Group->Group.Buffer ) * sizeof( WCHAR );
    Group->Group.MaximumLength = Group->Group.Length + sizeof( WCHAR );

    for ( Index = 0 ; Index < Count ; Index++ )
    {
        NameSize = MaxName ;
        Size = SEED_KEY_SIZE ;

        err = RegEnumValue(
                    Root,
                    Index,
                    Name,
                    &NameSize,
                    NULL,
                    &Type,
                    Key,
                    &Size );

        if ( (err == 0) && (Type == REG_BINARY) )
        {
            if ( _wcsicmp( Name, GROUPKEY_VALUE ) == 0 )
            {
                CopyMemory(
                    Group->SeedKey,
                    Key,
                    Size );

                continue;
            }

            Group->GroupList[ Group->Count ] = MGpCreateGroupEntry( Name, Key );
            if ( Group->GroupList[ Group->Count ] )
            {
                Group->Count++ ;
            }
        }

    }

    LocalFree( Name );

    if ( Group->Count == 0 )
    {
        DebugLog(( DEB_ERROR, "No machines found in group %ws\n", KeyName ));
        LocalFree( Group );
        Group = NULL ;
    }

    if ( Group )
    {
        for ( Index = 0 ; Index < Group->Count ; Index++ )
        {
            if ( Group->GroupList[ Index ]->Flags & MGROUP_ENTRY_SELF )
            {
                break;
            }
        }

        if ( Index == Group->Count )
        {
            DebugLog(( DEB_ERROR, "No entry for self found in group %ws\n", KeyName ));
            MGpFreeGroup( Group );
            Group = NULL ;
        }
    }


    return Group ;
}

VOID
MGpCreateLoopback(
    HKEY RootKey
    )
{
    int err ;
    DWORD Disp ;
    HKEY LoopbackKey ;
    UCHAR Random1[ XTCB_SEED_LENGTH ];
    UCHAR Random2[ XTCB_SEED_LENGTH ];


    err =  RegCreateKeyEx(
            RootKey,
            LOOPBACK_KEY,
            0,
            NULL,
            REG_OPTION_VOLATILE,
            KEY_READ | KEY_WRITE,
            NULL,
            &LoopbackKey,
            &Disp );

    if ( err == 0 )
    {
        if ( Disp == REG_OPENED_EXISTING_KEY )
        {
            RegCloseKey( LoopbackKey );
            return;
        }

        CDGenerateRandomBits( Random1, XTCB_SEED_LENGTH );
        CDGenerateRandomBits( Random2, XTCB_SEED_LENGTH );

        (VOID) RegSetValueEx(
                    LoopbackKey,
                    GROUPKEY_VALUE,
                    0,
                    REG_BINARY,
                    Random2,
                    XTCB_SEED_LENGTH );

        (VOID) RegSetValueEx(
                    LoopbackKey,
                    L"LocalHost",
                    0,
                    REG_BINARY,
                    Random1,
                    XTCB_SEED_LENGTH );

        (VOID) RegSetValueEx(
                    LoopbackKey,
                    XtcbUnicodeDnsName.Buffer,
                    0,
                    REG_BINARY,
                    Random1,
                    XTCB_SEED_LENGTH );

        //
        // Enumerate and stick aliases for this machine in the key here.
        //

        RegCloseKey( LoopbackKey );
                
    }
}



BOOL
MGpLoadGroups(
    VOID
    )
{
    HKEY RootKey = NULL ;
    HKEY Enum ;
    int err ;
    DWORD Index ;
    DWORD Disp ;
    PXTCB_MACHINE_GROUP Group ;
    DWORD MaxLen ;
    PWSTR KeyName = NULL ;
    WCHAR Buffer[ 32 ];
    DWORD Len ;
    BOOL Success = FALSE ;
    ULONG KeyCount ;

    err = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Control\\LSA\\XTCB\\Groups",
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_READ | KEY_WRITE,
            NULL,
            &RootKey,
            &Disp );

    if ( err )
    {
        return FALSE ;
    }

    MGpCreateLoopback( RootKey );

    err = RegQueryInfoKey(
            RootKey,
            NULL,
            NULL,
            NULL,
            &KeyCount,
            &MaxLen,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL );

    if ( err )
    {
        goto Cleanup ;

    }

    DebugLog(( DEB_TRACE, "Found %d groups\n", KeyCount ));

    if ( MaxLen < 32 )
    {
        KeyName = Buffer ;
        MaxLen = 32 ;
    }
    else 
    {
        KeyName = LocalAlloc( LMEM_FIXED, (MaxLen + 1) * sizeof( WCHAR ) );

        if ( KeyName == NULL )
        {
            goto Cleanup ;
        }
    }

    Index = 0 ;

    while ( Index < KeyCount )
    {

        Len = MaxLen ;
        
        err = RegEnumKeyEx(
                    RootKey,
                    Index,
                    KeyName,
                    &Len,
                    NULL,
                    NULL,
                    NULL,
                    NULL );

        if ( err )
        {
            Index++ ;
            continue;
        }

        err = RegOpenKeyEx(
                RootKey,
                KeyName,
                REG_OPTION_NON_VOLATILE,
                KEY_READ,
                &Enum );

        if ( err )
        {
            err = RegOpenKeyEx(
                        RootKey,
                        KeyName,
                        REG_OPTION_VOLATILE,
                        KEY_READ,
                        &Enum );
        }

        if ( err == 0 )
        {
            DebugLog(( DEB_TRACE, "Processing group %d:%ws\n", Index, KeyName ));

            Group = MGpCreateMachineGroup( Enum, KeyName );

            RegCloseKey( Enum );

            if ( Group )
            {
                InsertTailList( &MachineGroupList, &Group->List );
            }
        }
        else 
        {
            DebugLog(( DEB_TRACE, "Unable to open key %ws\n", KeyName ));
        }

        Index++ ;

    }
    
    Success = TRUE ;


Cleanup:
    if ( RootKey )
    {
        RegCloseKey( RootKey );
    }

    if ( KeyName )
    {
        if ( KeyName != Buffer )
        {
            LocalFree( KeyName );
        }
    }

    return Success ;

}



BOOL
MGroupReload(
    VOID
    )
{
    PLIST_ENTRY List ;
    PXTCB_MACHINE_GROUP Group ;
    BOOL Success ;
    DWORD Size = MAX_PATH ;

    EnterCriticalSection( &MachineGroupLock );

    while ( !IsListEmpty( &MachineGroupList ) )
    {
        List = RemoveHeadList( &MachineGroupList );

        Group = CONTAINING_RECORD( List, XTCB_MACHINE_GROUP, List );

        MGpFreeGroup( Group );
    }

    GetComputerNameEx( ComputerNamePhysicalDnsFullyQualified,
                       MachineLocalName,
                       &Size );

    Success = MGpLoadGroups();

    LeaveCriticalSection( &MachineGroupLock );

    return Success ;

}


BOOL
MGroupInitialize(
    VOID
    )
{
    BOOL Success = TRUE ;
    try {

        InitializeCriticalSection( &MachineGroupLock );
    }
    except ( EXCEPTION_EXECUTE_HANDLER )
    {
        Success = FALSE ;
    }

    InitializeListHead( &MachineGroupList );

    if ( Success )
    {
        Success = MGroupReload();
    }

    return Success ;
}

BOOL
MGroupLocateInboundKey(
    IN PSECURITY_STRING GroupName,
    IN PSECURITY_STRING Origin,
    OUT PUCHAR TargetKey,
    OUT PUCHAR GroupKey,
    OUT PUCHAR MyKey
    )
{
    PLIST_ENTRY Scan ;
    PXTCB_MACHINE_GROUP Group ;
    PXTCB_MACHINE_GROUP_ENTRY Entry ;
    PXTCB_MACHINE_GROUP_ENTRY Self = NULL ;
    ULONG i ;
    BOOL Success = FALSE ;


    EnterCriticalSection( &MachineGroupLock );

    Scan = MachineGroupList.Flink ;

    while ( Scan != &MachineGroupList )
    {
        Group = CONTAINING_RECORD( Scan, XTCB_MACHINE_GROUP, List );

        if ( RtlEqualUnicodeString( GroupName,
                                    &Group->Group,
                                    TRUE ) )
        {
            for ( i = 0 ; i < Group->Count ; i++ )
            {
                Entry = Group->GroupList[ i ];
                if ( Entry->Flags & MGROUP_ENTRY_SELF )
                {
                    Self = Entry ;
                }
                if ( _wcsicmp( Origin->Buffer, Entry->MachineName ) == 0 )
                {
                    //
                    // We have a hit:
                    //

                    Success = TRUE ;
                    CopyMemory( TargetKey, Entry->UniqueKey, SEED_KEY_SIZE );
                    CopyMemory( GroupKey, Group->SeedKey, SEED_KEY_SIZE );
                    break;
                }
            }

        }


        if ( Success )
        {
            break;
        }

        Scan = Scan->Flink ;
        Self = NULL ;

    }

    if ( Success && ( Self == NULL ) )
    {
        //
        // Continue through the group, looking for the 
        // self entry
        //
        for (  ; i < Group->Count ; i++ )
        {
            if ( Group->GroupList[ i ]->Flags & MGROUP_ENTRY_SELF )
            {
                Self = Group->GroupList[ i ];
                break;
            }
        }
    }

    if ( Success )
    {
        CopyMemory( MyKey, Self->UniqueKey, SEED_KEY_SIZE );
    }

    LeaveCriticalSection( &MachineGroupLock );

    return Success ;

}

BOOL
MGroupLocateKeys(
    IN PWSTR Target,
    OUT PSECURITY_STRING * GroupName,
    OUT PUCHAR TargetKey,
    OUT PUCHAR GroupKey,
    OUT PUCHAR MyKey
    )
{
    PLIST_ENTRY Scan ;
    PXTCB_MACHINE_GROUP Group ;
    PXTCB_MACHINE_GROUP_ENTRY Entry ;
    PXTCB_MACHINE_GROUP_ENTRY Self = NULL ;
    ULONG i ;
    BOOL Success = FALSE ;


    EnterCriticalSection( &MachineGroupLock );

    Scan = MachineGroupList.Flink ;

    while ( Scan != &MachineGroupList )
    {
        Group = CONTAINING_RECORD( Scan, XTCB_MACHINE_GROUP, List );

        for ( i = 0 ; i < Group->Count ; i++ )
        {
            Entry = Group->GroupList[ i ];
            if ( Entry->Flags & MGROUP_ENTRY_SELF )
            {
                Self = Entry ;
            }
            if ( _wcsicmp( Target, Entry->MachineName ) == 0 )
            {
                //
                // We have a hit:
                //

                Success = TRUE ;
                CopyMemory( TargetKey, Entry->UniqueKey, SEED_KEY_SIZE );
                CopyMemory( GroupKey, Group->SeedKey, SEED_KEY_SIZE );
                *GroupName = &Group->Group ;
                break;
            }
        }

        if ( Success )
        {
            break;
        }

        Scan = Scan->Flink ;
        Self = NULL ;

    }

    if ( Success && ( Self == NULL ) )
    {
        //
        // Continue through the group, looking for the 
        // self entry
        //
        for (  ; i < Group->Count ; i++ )
        {
            if ( Group->GroupList[ i ]->Flags & MGROUP_ENTRY_SELF )
            {
                Self = Group->GroupList[ i ];
                break;
            }
        }
    }

    if ( Success )
    {
        CopyMemory( MyKey, Self->UniqueKey, SEED_KEY_SIZE );
    }

    LeaveCriticalSection( &MachineGroupLock );

    return Success ;
}

BOOL
MGroupParseTarget(
    PWSTR TargetSpn,
    PWSTR * MachineName
    )
{
    PWSTR Scan ;
    PWSTR Tail ;
    PWSTR Copy ;
    ULONG Length ;

    *MachineName = NULL ;

    Scan = wcschr( TargetSpn, L'/' );

    if ( !Scan )
    {
        return FALSE ;
    }

    Scan++ ;
    Tail = wcschr( Scan, L'/' );

    if ( Tail != NULL )
    {
        //
        // three-part SPN (e.g. HOST/hostname.domain.com).
        // null out this slash for now
        //

        *Tail = L'\0';

    }

    Length = wcslen( Scan );

    Copy = LocalAlloc( LMEM_FIXED, (Length + 1) * sizeof( WCHAR ) );

    if ( Copy )
    {
        CopyMemory( Copy, Scan, (Length + 1) * sizeof( WCHAR ) );
    }

    if ( Tail )
    {
        *Tail = L'/' ;
    }

    *MachineName = Copy ;

    return ( Copy != NULL );
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\protocol.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       protocol.c
//
//  Contents:   Implements the XTCB protocol
//
//  Classes:
//
//  Functions:
//
//  History:    3-01-00   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"
#include "md5.h"
#include "hmac.h"
#include <cryptdll.h>

//
// The protocol is very straight-forward.  For any group, we have the following:
//
//      A Group Key (G)
//      A Client Key (C)
//      A Server Key (S)
//
//
// The protocol is as follows:
//
//  Client (C) sends a message to the server, consisting of:
//          A random seed [ R ]
//          The client's PAC
//          Name of the client and group
//          HMAC( G, S, R, PAC, Name )
//
//  Both sides create CS and SC keys by:
//          CS = HMAC( [S], G, R, "string1")
//          SC = HMAC( [C], G, R, "string2")
//
//  The server (S) verifies the HMAC, and replies with:
//          A different seed [ R2 ]
//          HMAC( G, C, R2 )
//

#define CS_HMAC_STRING  "Fairly long string for the client-server session key derivation"
#define SC_HMAC_STRING  "Equally long string to derive server-client session key for now"

LARGE_INTEGER XtcbExpirationTime = { 0xFFFFFFFF, 0x6FFFFFFF };

typedef struct _XTCB_HMAC {
    HMACMD5_CTX Context ;
} XTCB_HMAC, * PXTCB_HMAC;

PXTCB_HMAC
XtcbInitHmac(
    PUCHAR IndividualKey,
    PUCHAR GroupKey
    )
{
    PXTCB_HMAC HMac;
    UCHAR Key[ XTCB_SEED_LENGTH * 2 ];

    HMac = LocalAlloc( LMEM_FIXED, sizeof( XTCB_HMAC ) );

    if ( HMac )
    {
        RtlCopyMemory( Key,
                       IndividualKey,
                       XTCB_SEED_LENGTH );

        RtlCopyMemory( Key+XTCB_SEED_LENGTH,
                       GroupKey,
                       XTCB_SEED_LENGTH );

        HMACMD5Init( &HMac->Context,
                     Key,
                     XTCB_SEED_LENGTH * 2 );


    }

    return HMac ;
}

PXTCB_HMAC
XtcbPrepareHmac(
    PXTCB_HMAC HMac
    )
{
    PXTCB_HMAC Working ;

    Working = LocalAlloc( LMEM_FIXED, sizeof( XTCB_HMAC ) );

    return Working ;
}

#define XtcbHmacUpdate( H, p, s ) \
    HMACMD5Update( &((PXTCB_HMAC)H)->Context, p, s )



VOID
XtcbDeriveKeys(
    PXTCB_CONTEXT Context,
    PUCHAR ServerKey,
    PUCHAR GroupKey,
    PUCHAR ClientKey,
    PUCHAR RandomSeed
    )
{
    HMACMD5_CTX HMac ;

    HMACMD5Init( &HMac, ServerKey, XTCB_SEED_LENGTH );

    HMACMD5Update( &HMac, GroupKey, XTCB_SEED_LENGTH );

    HMACMD5Update( &HMac, RandomSeed, XTCB_SEED_LENGTH );

    HMACMD5Update( &HMac, CS_HMAC_STRING, sizeof( CS_HMAC_STRING ) );

    if ( Context->Core.Type == XtcbContextServer )
    {
        HMACMD5Final( &HMac, Context->Core.InboundKey );
    }
    else 
    {
        HMACMD5Final( &HMac, Context->Core.OutboundKey );
    }

    HMACMD5Init( &HMac, ClientKey, XTCB_SEED_LENGTH );
    
    HMACMD5Update( &HMac, GroupKey, XTCB_SEED_LENGTH );

    HMACMD5Update( &HMac, RandomSeed, XTCB_SEED_LENGTH );

    HMACMD5Update( &HMac, SC_HMAC_STRING, sizeof( SC_HMAC_STRING ) );

    if ( Context->Core.Type == XtcbContextServer )
    {
        HMACMD5Final( &HMac, Context->Core.OutboundKey );
    }
    else 
    {
        HMACMD5Final( &HMac, Context->Core.InboundKey );
    }
}



SECURITY_STATUS
XtcbBuildInitialToken(
    PXTCB_CREDS Creds,
    PXTCB_CONTEXT Context,
    PSECURITY_STRING Target,
    PSECURITY_STRING Group,
    PUCHAR ServerKey,
    PUCHAR GroupKey,
    PUCHAR ClientKey,
    PUCHAR * Token,
    PULONG TokenLen
    )
{
    PXTCB_HMAC HMac ;
    PXTCB_INIT_MESSAGE Message ;
    PUCHAR CopyTo ;
    PUCHAR Base ;

    Message = LsaTable->AllocateLsaHeap( sizeof( XTCB_INIT_MESSAGE ) +
                                         Creds->Pac->Length +
                                         XtcbUnicodeDnsName.Length +
                                         Group->Length );

    if ( !Message )
    {
        return SEC_E_INSUFFICIENT_MEMORY ;
    }

    CDGenerateRandomBits( Message->Seed, XTCB_SEED_LENGTH );

    //
    // Create keys in the context
    //

    XtcbDeriveKeys(
        Context,
        ServerKey,
        GroupKey,
        ClientKey,
        Message->Seed );

    //
    // Set random seed in the context
    //

    RtlCopyMemory(
        Context->Core.RootKey,
        Message->Seed,
        XTCB_SEED_LENGTH );


    //
    // Fill it in:
    //

    Message->Version = 1 ;
    Message->Length = sizeof( XTCB_INIT_MESSAGE ) +
                      Creds->Pac->Length +
                      XtcbUnicodeDnsName.Length +
                      Group->Length ;




    RtlZeroMemory( Message->HMAC, XTCB_HMAC_LENGTH );

    CopyTo = (PUCHAR) ( Message + 1 );
    Base = (PUCHAR) Message;

    RtlCopyMemory(
        CopyTo,
        Creds->Pac,
        Creds->Pac->Length );

    Message->PacOffset = (ULONG) (CopyTo - Base);
    Message->PacLength = Creds->Pac->Length ;
    CopyTo += Creds->Pac->Length ;
    RtlCopyMemory(
        CopyTo,
        XtcbUnicodeDnsName.Buffer,
        XtcbUnicodeDnsName.Length );

    Message->OriginatingNode.Buffer = (ULONG) (CopyTo - Base );
    Message->OriginatingNode.Length = XtcbUnicodeDnsName.Length ;
    Message->OriginatingNode.MaximumLength = XtcbUnicodeDnsName.Length ;

    CopyTo+= XtcbUnicodeDnsName.Length ;
    RtlCopyMemory(
        CopyTo,
        Group->Buffer,
        Group->Length );

    Message->Group.Buffer = (ULONG) (CopyTo - Base );
    Message->Group.Length = Group->Length ;
    Message->Group.MaximumLength = Group->Length ;
    

    //
    // Structure complete.
    //

    //
    // Do HMAC
    //


    *Token = (PUCHAR) Message ;
    *TokenLen = Message->Length ;

    return SEC_I_CONTINUE_NEEDED ;

}

BOOL
XtcbParseInputToken(
    IN PUCHAR Token,
    IN ULONG TokenLength,
    OUT PSECURITY_STRING Client,
    OUT PSECURITY_STRING Group
    )
{
    PXTCB_INIT_MESSAGE Message ;
    PWSTR Scan ;
    PUCHAR End ;
    ULONG Chars;
    UNICODE_STRING String = { 0 };
    BOOL Success = FALSE ;

    *Client = String ;
    *Group = String ;

    if ( TokenLength < sizeof( XTCB_INIT_MESSAGE ) )
    {
        goto ParseExit;

    }

    Message = (PXTCB_INIT_MESSAGE) Token ;

    if ( Message->Length != TokenLength )
    {
        goto ParseExit;
    }

    End = Token + Message->Length ;

    String.Length = Message->OriginatingNode.Length ;
    String.Buffer = (PWSTR) (Token + Message->OriginatingNode.Buffer );
    String.MaximumLength = String.Length ;

    if ( (PUCHAR) String.Buffer + String.Length > End )
    {
        goto ParseExit;
    }

    if ( !XtcbDupSecurityString( Client, &String ) )
    {
        goto ParseExit;
    }

    String.Length = Message->Group.Length ;
    String.Buffer = (PWSTR) (Token + Message->Group.Buffer );
    String.MaximumLength = String.Length ;
    
    if ( (PUCHAR) String.Buffer + String.Length > End )
    {
        goto ParseExit;
    }

    if ( !XtcbDupSecurityString( Group, &String ))
    {
        goto ParseExit ;
    }

    Success = TRUE ;


ParseExit:

    if ( !Success )
    {
        if ( Client->Buffer )
        {
            LocalFree( Client->Buffer );
        }

        if ( Group->Buffer )
        {
            LocalFree( Group->Buffer );
        }
    }

    return Success ;

}


SECURITY_STATUS
XtcbAuthenticateClient(
    PXTCB_CONTEXT Context,
    PUCHAR Token,
    ULONG TokenLength,
    PUCHAR ClientKey,
    PUCHAR GroupKey,
    PUCHAR MyKey
    )
{
    PXTCB_INIT_MESSAGE Message ;
    PXTCB_PAC Pac ;
    PLSA_TOKEN_INFORMATION_V2 TokenInfo ;
    ULONG Size ;
    PTOKEN_GROUPS Groups ;
    PUCHAR Scan ;
    PUCHAR Sid1 ;
    NTSTATUS Status = SEC_E_INVALID_TOKEN ;
    PSID Sid ;
    PUCHAR Target ;
    ULONG i ;
    LUID LogonId ;
    UNICODE_STRING UserName ;
    UNICODE_STRING DomainName ;
    HANDLE hToken ;
    NTSTATUS SubStatus ;



    //
    // On entry, we know that the message is in general ok, that the general 
    // bounds are ok, but not the PAC.  So validate the PAC first before using 
    // it.
    //

    Message = (PXTCB_INIT_MESSAGE) Token ;


    XtcbDeriveKeys(
        Context,
        MyKey,
        GroupKey,
        ClientKey,
        Message->Seed );

    //
    // Got the keys.  Let's examine the PAC/
    //

    Pac = (PXTCB_PAC) ( Token + Message->PacOffset );

    if ( ( Pac->Length != Message->PacLength ) ||
         ( Message->PacLength > TokenLength ) ||
         ( Pac->Length > TokenLength ) )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    //
    // Make sure offsets are within bounds.  Each area
    // will still have to confirm that offset + length
    // within limits
    //

    if ( ( Pac->UserOffset > Pac->Length )    ||
         ( Pac->GroupOffset > Pac->Length )   ||
         ( Pac->RestrictionOffset > Pac->Length ) ||
         ( Pac->NameOffset > Pac->Length ) ||
         ( Pac->DomainOffset > Pac->Length ) ||
         ( Pac->CredentialOffset > Pac->Length ) )
    {
        return SEC_E_INVALID_TOKEN ;
    }


    //
    // 1000 is the current LSA limit.  This is not exported to the packages
    // for some reason.  This is hard coded right now, but needs to be 
    // a global define, or a queryable value out of the LSA.
    //

    if ( Pac->GroupCount > 1000 )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    //
    // Looks good, lets start assembling the token information.
    //

    if ( Pac->GroupLength + Pac->GroupOffset > Pac->Length )
    {
        return SEC_E_INVALID_TOKEN ;
    }

    Size = sizeof( LSA_TOKEN_INFORMATION_V2 ) +       // Basic info
            ( Pac->GroupLength ) +                    // All the group SIDs
            ( Pac->UserLength ) +                     // User SID
            ROUND_UP_COUNT( ( ( Pac->GroupCount * sizeof( SID_AND_ATTRIBUTES ) ) +
                            sizeof( TOKEN_GROUPS ) ), ALIGN_LPVOID ) ;

    TokenInfo = LsaTable->AllocateLsaHeap( Size );

    if ( TokenInfo == NULL )
    {
        return SEC_E_INSUFFICIENT_MEMORY ;
    }

    //
    // Now fill in this structure.  
    //

    TokenInfo->ExpirationTime = XtcbExpirationTime ;

    TokenInfo->DefaultDacl.DefaultDacl = NULL ;

    TokenInfo->Privileges = NULL ;

    TokenInfo->Owner.Owner = NULL ;

    //
    // Set up initial pointers:
    //

    Groups = (PTOKEN_GROUPS) ( TokenInfo + 1 );
    Target = (PSID) ( (PUCHAR) Groups + 
                      ROUND_UP_COUNT( ( ( Pac->GroupCount * sizeof( SID_AND_ATTRIBUTES ) ) +
                                    sizeof( TOKEN_GROUPS ) ), ALIGN_LPVOID )  );

    //
    // Copy over the user SID
    //

    if ( Pac->UserOffset + Pac->UserLength > Pac->Length )
    {
        Status = SEC_E_INVALID_TOKEN ;

        goto Cleanup ;
    }

    Sid = (PSID) ((PUCHAR) Pac + Pac->UserOffset) ;

    if ( !RtlValidSid( Sid ) )
    {
        Status = SEC_E_INVALID_TOKEN ;
        
        goto Cleanup ;

    }

    if ( RtlLengthSid( Sid ) != Pac->UserLength )
    {
        Status = SEC_E_INVALID_TOKEN ;

        goto Cleanup ;
    }

    RtlCopySid( Pac->UserLength,
                (PSID) Target,
                Sid );

    Target += RtlLengthSid( Sid );

    TokenInfo->User.User.Sid = (PSID) Target ;
    TokenInfo->User.User.Attributes = 0 ;


    //
    // Now, do the groups.  Since all the SIDs are in one
    // contiguous block, the plan is to copy them over 
    // whole, then iterate through the list and fix up the 
    // pointers in the group list.
    //

    RtlCopyMemory(
        Target,
        (PUCHAR) Pac + Pac->GroupOffset,
        Pac->GroupLength );


    Scan = Target ;
    Target += Pac->GroupLength ;
    i = 0 ;

    while ( Scan < Target )
    {
        Sid = (PSID) Scan ;

        if ( RtlValidSid( Sid ) )
        {
            //
            // This is an ok SID.
            //

            Groups->Groups[ i ].Sid = Sid ;
            Groups->Groups[ i ].Attributes = SE_GROUP_MANDATORY |
                                             SE_GROUP_ENABLED |
                                             SE_GROUP_ENABLED_BY_DEFAULT ;

            if ( i == 0 )
            {
                TokenInfo->PrimaryGroup.PrimaryGroup = Sid ;
            }

            i++ ;

            Scan += RtlLengthSid( Sid );
        }
        else 
        {
            break;
        }

    }
                
    //
    // On exit, if Scan is less than Target, then we failed to
    // process all the SIDs.  Bail out
    //

    if ( Scan < Target )
    {
        Status = SEC_E_INVALID_TOKEN ;
        goto Cleanup ;
    }

    //
    // Pull out the user name/etc
    //

    if ( Pac->NameLength + Pac->NameOffset > Pac->Length )
    {
        Status = SEC_E_INVALID_TOKEN ;
        goto Cleanup ;
    }

    UserName.Buffer = (PWSTR) ((PUCHAR) Pac + Pac->NameOffset);
    UserName.Length = (WORD) Pac->NameLength ;
    UserName.MaximumLength = UserName.Length ;


    if ( Pac->DomainLength + Pac->DomainOffset > Pac->Length )
    {
        Status = SEC_E_INVALID_TOKEN ;
        goto Cleanup ;
    }

    DomainName.Buffer = (PWSTR) ((PUCHAR) Pac + Pac->DomainOffset );
    DomainName.Length = (WORD) Pac->DomainLength ;
    DomainName.MaximumLength = DomainName.Length ;

    //
    // We've assembled the token info.  Now, create the logon session
    //

    DebugLog(( DEB_TRACE, "Creating logon for %wZ\\%wZ\n", &DomainName, 
               &UserName ));


    AllocateLocallyUniqueId( &LogonId );

    Status = LsaTable->CreateLogonSession( &LogonId );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Cleanup ;
    }

    //
    // Create the token to represent this user:
    //

    Status = LsaTable->CreateToken(
                    &LogonId,
                    &XtcbSource,
                    Network,
                    TokenImpersonation,
                    LsaTokenInformationV2,
                    TokenInfo,
                    NULL,
                    &UserName,
                    &DomainName,
                    &XtcbComputerName,
                    NULL,
                    &hToken,
                    &SubStatus );

    TokenInfo = NULL ;

    if ( NT_SUCCESS( Status ) )
    {
        Status = SubStatus ;
    }

    if ( NT_SUCCESS( Status ) )
    {
        Context->Token = hToken ;
    }

Cleanup:
    
    if ( TokenInfo )
    {
        LsaTable->FreeLsaHeap( TokenInfo );
    }

    return Status ;
}


SECURITY_STATUS
XtcbBuildReplyToken(
    PXTCB_CONTEXT Context,
    ULONG   fContextReq,
    PSecBuffer pOutput
    )
{
    PXTCB_INIT_MESSAGE_REPLY Reply ;
    NTSTATUS Status ;

    if ( fContextReq & ASC_REQ_ALLOCATE_MEMORY )
    {
        Reply = LsaTable->AllocateLsaHeap( sizeof( XTCB_INIT_MESSAGE_REPLY ) );
    }
    else 
    {
        if ( pOutput->cbBuffer >= sizeof( XTCB_INIT_MESSAGE_REPLY ) )
        {
            Reply = pOutput->pvBuffer ;
        }
        else 
        {
            Reply = NULL ;
        }
    }

    if ( Reply == NULL )
    {
        Status = SEC_E_INSUFFICIENT_MEMORY ;

        goto Cleanup ;
    }

    Reply->Version = 1;
    Reply->Length = sizeof( XTCB_INIT_MESSAGE_REPLY );

    CDGenerateRandomBits( 
            Reply->ReplySeed, 
            XTCB_SEED_LENGTH );

    pOutput->cbBuffer = sizeof( XTCB_INIT_MESSAGE_REPLY );
    pOutput->pvBuffer = Reply ;
    Reply = NULL ;
    

Cleanup:
    if ( Reply )
    {
        LsaTable->FreeLsaHeap( Reply );
    }
    return Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\userctxt.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       userctxt.c
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3-26-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"

LIST_ENTRY  XtcbContextList ;
CRITICAL_SECTION XtcbContextListLock ;

#define LockContextList()   EnterCriticalSection( &XtcbContextListLock )
#define UnlockContextList() LeaveCriticalSection( &XtcbContextListLock )

BOOL
XtcbUserContextInit(
    VOID
    )
{
    InitializeListHead( &XtcbContextList );

    InitializeCriticalSection( &XtcbContextListLock );

    return TRUE ;
}


SECURITY_STATUS
XtcbAddUserContext(
    IN LSA_SEC_HANDLE LsaHandle,
    IN PSecBuffer   ContextData)
{
    DWORD   Size;
    PXTCB_USER_CONTEXT Context ;

    Context = XtcbFindUserContext( LsaHandle );

    if ( Context )
    {
        DebugLog(( DEB_TRACE, "Replacing existing context!\n" ));

    }

    if ( ContextData->cbBuffer < sizeof( XTCB_CONTEXT_CORE ) )
    {
        return( SEC_E_INVALID_TOKEN );
    }

    Size = sizeof( XTCB_CONTEXT_CORE );

    Context = LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                        sizeof( XTCB_USER_CONTEXT ) + Size );

    if ( !Context )
    {
        return( SEC_E_INSUFFICIENT_MEMORY );
    }

    Context->LsaHandle = LsaHandle ;

    CopyMemory( &Context->Context,
                ContextData->pvBuffer,
                ContextData->cbBuffer );

    LockContextList();

    InsertTailList( &XtcbContextList, &Context->List );

    UnlockContextList();

    return( SEC_E_OK );
}

PXTCB_USER_CONTEXT
XtcbFindUserContext(
    IN  LSA_SEC_HANDLE   LsaHandle
    )
{
    PLIST_ENTRY List ;
    PXTCB_USER_CONTEXT Context = NULL ;


    LockContextList();

    List = XtcbContextList.Flink ;

    while ( List != &XtcbContextList )
    {
        Context = CONTAINING_RECORD( List, XTCB_USER_CONTEXT, List.Flink );

        if ( Context->LsaHandle == LsaHandle )
        {
            break;
        }

        Context = NULL ;

        List = List->Flink ;
    }

    UnlockContextList();

    return( Context );
}

VOID
XtcbDeleteUserContext(
    IN LSA_SEC_HANDLE LsaHandle
    )
{
    PXTCB_USER_CONTEXT Context ;

    Context = XtcbFindUserContext( LsaHandle );

    if ( Context )
    {
        LockContextList();

        RemoveEntryList( &Context->List );

        UnlockContextList();

        DebugLog(( DEB_TRACE, "Deleting user mode context %x, handle = %x\n",
                        Context, LsaHandle ));

        LocalFree( Context );
    }
    else
    {
        DebugLog(( DEB_TRACE, "No context found for handle %x\n", LsaHandle ));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\server.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       server.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3-14-97   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __SERVER_H__
#define __SERVER_H__


typedef struct _XTCB_AUTH_REQ_MESSAGE {
    STRING  Challenge ;
    STRING  Response ;
    STRING  UserName ;
} XTCB_AUTH_REQ_MESSAGE, * PXTCB_AUTH_REQ_MESSAGE ;

typedef struct _XTCB_AUTH_RESP_MESSAGE {
    NTSTATUS Result ;
    NTSTATUS SubCode ;
    PUCHAR  AuthInfo ;
    ULONG   AuthInfoLength ;
} XTCB_AUTH_RESP_MESSAGE, * PXTCB_AUTH_RESP_MESSAGE ;

typedef enum {
    XtcbSrvAuthReq,
    XtcbSrvAuthResp,
    XtcbSrvMax
} XTCB_SERVER_MESSAGE_CODE ;

#define XTCB_SERVER_MESSAGE_TAG      'S5DM'
#define XTCB_MESSAGE_SELF_RELATIVE   0x00000001      // Pointers are offsets
#define XTCB_MESSAGE_ONE_BLOCK       0x00000002      // Pointers are within block

typedef struct _XTCB_SERVER_MESSAGE {
    ULONG Tag ;
    XTCB_SERVER_MESSAGE_CODE Code ;
    ULONG Flags ;
    ULONG DataLength ;
    union {
        XTCB_AUTH_REQ_MESSAGE AuthReq ;
        XTCB_AUTH_RESP_MESSAGE AuthResp ;
    } Message ;
    UCHAR   Data[1] ;
} XTCB_SERVER_MESSAGE, * PXTCB_SERVER_MESSAGE ;

#define XtcbMessageLength( x )   ( sizeof( XTCB_SERVER_MESSAGE ) - 1 + \
                                  ((PXTCB_SERVER_MESSAGE) x)->DataLength )


NTSTATUS
XtcbRemoteAuthHandler(
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );


SECURITY_STATUS
XtcbAuthenticateResponse(
    PSTRING Challenge,
    PSTRING UserName,
    PSTRING Response,
    PVOID * AuthInfo,
    PULONG  AuthInfoLength
    );

SECURITY_STATUS
XtcbLocalLogon(
    PVOID   AuthInfo,
    ULONG   AuthInfoLength,
    PLUID   NewLogonId,
    PHANDLE NewToken
    );

#endif // __SERVER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\protos.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       protos.h
//
//  Contents:   Xtcb Security Package Prototypes
//
//  Classes:
//
//  Functions:
//
//  History:    2-19-97   RichardW   Created
//
//----------------------------------------------------------------------------


SpInitializeFn                  XtcbInitialize;
SpGetInfoFn                     XtcbGetInfo;

SpAcceptCredentialsFn           XtcbAcceptCredentials;
SpAcquireCredentialsHandleFn    XtcbAcquireCredentialsHandle;
SpFreeCredentialsHandleFn       XtcbFreeCredentialsHandle;
SpQueryCredentialsAttributesFn  XtcbQueryCredentialsAttributes;
SpSaveCredentialsFn             XtcbSaveCredentials;
SpGetCredentialsFn              XtcbGetCredentials;
SpDeleteCredentialsFn           XtcbDeleteCredentials;

SpInitLsaModeContextFn          XtcbInitLsaModeContext;
SpDeleteContextFn               XtcbDeleteContext;
SpAcceptLsaModeContextFn        XtcbAcceptLsaModeContext;

LSA_AP_LOGON_TERMINATED         XtcbLogonTerminated;
SpApplyControlTokenFn           XtcbApplyControlToken;
LSA_AP_CALL_PACKAGE             XtcbCallPackage;
LSA_AP_CALL_PACKAGE             XtcbCallPackageUntrusted;
SpShutdownFn                    XtcbShutdown;
SpGetUserInfoFn                 XtcbGetUserInfo;

SpInstanceInitFn                XtcbInstanceInit;
SpInitUserModeContextFn         XtcbInitUserModeContext;
SpMakeSignatureFn               XtcbMakeSignature;
SpVerifySignatureFn             XtcbVerifySignature;
SpSealMessageFn                 XtcbSealMessage;
SpUnsealMessageFn               XtcbUnsealMessage;
SpGetContextTokenFn             XtcbGetContextToken;
SpQueryContextAttributesFn      XtcbQueryContextAttributes;
SpDeleteContextFn               XtcbDeleteUserModeContext;
SpCompleteAuthTokenFn           XtcbCompleteAuthToken;
SpFormatCredentialsFn           XtcbFormatCredentials;
SpMarshallSupplementalCredsFn   XtcbMarshallSupplementalCreds;

SpGetExtendedInformationFn      XtcbGetExtendedInformation ;
SpQueryContextAttributesFn      XtcbQueryLsaModeContext ;


//////////////////////////////
//
// Misc. Utility functions
//
//////////////////////////////


BOOL
XtcbDupSecurityString(
    PSECURITY_STRING    Dest,
    PSECURITY_STRING    Source
    );

BOOL
XtcbDupStringToSecurityString(
    PSECURITY_STRING    Dest,
    PWSTR               Source
    );

BOOL
XtcbCaptureAuthData(
    PVOID   pvAuthData,
    PSEC_WINNT_AUTH_IDENTITY * AuthData
    );

BOOL
XtcbGenerateChallenge(
    PUCHAR  Challenge,
    ULONG   Length,
    PULONG  Actual
    );

BOOL
XtcbAnsiStringToSecurityString(
    PSECURITY_STRING    Dest,
    PSTRING             Source
    );

BOOL
XtcbSecurityStringToAnsiString(
    PSTRING Dest,
    PSECURITY_STRING Source
    );

PXTCB_PAC
XtcbCreatePacForCaller(
    VOID
    );

SECURITY_STATUS
XtcbBuildInitialToken(
    PXTCB_CREDS Creds,
    PXTCB_CONTEXT Context,
    PSECURITY_STRING Target,
    PSECURITY_STRING Group,
    PUCHAR ServerKey,
    PUCHAR GroupKey,
    PUCHAR ClientKey,
    PUCHAR * Token,
    PULONG TokenLen
    );

BOOL
XtcbParseInputToken(
    IN PUCHAR Token,
    IN ULONG TokenLength,
    OUT PSECURITY_STRING Client,
    OUT PSECURITY_STRING Group
    );

SECURITY_STATUS
XtcbAuthenticateClient(
    PXTCB_CONTEXT Context,
    PUCHAR Token,
    ULONG TokenLength,
    PUCHAR ClientKey,
    PUCHAR GroupKey,
    PUCHAR MyKey
    );

SECURITY_STATUS
XtcbBuildReplyToken(
    PXTCB_CONTEXT Context,
    ULONG   fContextReq,
    PSecBuffer pOutput
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\userctxt.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       userctxt.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    3-26-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include <rc4.h>

#ifndef __USERCTXT_H__
#define __USERCTXT_H__

typedef struct _XTCB_USER_CONTEXT {
    LIST_ENTRY      List ;
    LSA_SEC_HANDLE  LsaHandle ;
    HANDLE          Token ;
    XTCB_CONTEXT_CORE Context ;
    ULONGLONG       Align ;
    RC4_KEYSTRUCT   InboundKey ;
    RC4_KEYSTRUCT   OutboundKey ;
} XTCB_USER_CONTEXT, *PXTCB_USER_CONTEXT ;

BOOL
XtcbUserContextInit(
    VOID
    );

SECURITY_STATUS
XtcbAddUserContext(
    IN LSA_SEC_HANDLE LsaHandle,
    IN PSecBuffer   ContextData
    );

PXTCB_USER_CONTEXT
XtcbFindUserContext(
    IN  LSA_SEC_HANDLE   LsaHandle
    );

VOID
XtcbDeleteUserContext(
    IN LSA_SEC_HANDLE LsaHandle
    );



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\server.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       server.c
//
//  Contents:   Server (DC) side of XTCB authentication
//
//  Classes:
//
//  Functions:
//
//  History:    3-12-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"
#include "md5.h"

//+---------------------------------------------------------------------------
//
//  Function:   XtcbGetMessageSize
//
//  Synopsis:   Determines the size of the message when serialized.
//
//  Arguments:  [Message] --
//
//  History:    3-25-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
XtcbGetMessageSize(
    PXTCB_SERVER_MESSAGE Message
    )
{
    DWORD   Size ;
    switch ( Message->Code )
    {
        case XtcbSrvAuthReq:
            Size = Message->Message.AuthReq.Challenge.Length + 1 +
                   Message->Message.AuthReq.Response.Length + 1 +
                   Message->Message.AuthReq.UserName.Length + 1 ;
            break;

        case XtcbSrvAuthResp:
            Size = Message->Message.AuthResp.AuthInfoLength ;
            break;

        default:
            Size = 0 ;

    }
    return Size ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\usermode.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       usermode.c
//
//  Contents:   User mode entry points for test package
//
//  Classes:
//
//  Functions:
//
//  History:    2-21-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"

PSECPKG_DLL_FUNCTIONS    UserTable ;

SECPKG_USER_FUNCTION_TABLE  XtcbUserTable =
        {
            XtcbInstanceInit,
            XtcbInitUserModeContext,
            XtcbMakeSignature,
            XtcbVerifySignature,
            XtcbSealMessage,
            XtcbUnsealMessage,
            XtcbGetContextToken,
            XtcbQueryContextAttributes,
            XtcbCompleteAuthToken,
            XtcbDeleteUserModeContext
        };


NTSTATUS
SEC_ENTRY
SpUserModeInitialize(
    IN ULONG    LsaVersion,
    OUT PULONG  PackageVersion,
    OUT PSECPKG_USER_FUNCTION_TABLE * UserFunctionTable,
    OUT PULONG  pcTables)
{
    if (LsaVersion != SECPKG_INTERFACE_VERSION)
    {
        DebugLog((DEB_ERROR,"Invalid LSA version: %d\n", LsaVersion));
        return(STATUS_INVALID_PARAMETER);
    }


    *PackageVersion = SECPKG_INTERFACE_VERSION ;

    *UserFunctionTable = &XtcbUserTable;
    *pcTables = 1;


    return( STATUS_SUCCESS );

}


NTSTATUS NTAPI
XtcbInstanceInit(
    IN ULONG Version,
    IN PSECPKG_DLL_FUNCTIONS DllFunctionTable,
    OUT PVOID * UserFunctionTable
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    XtcbUserContextInit();

    UserTable = DllFunctionTable ;

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   XtcbDeleteUserModeContext
//
//  Synopsis:   Deletes a user mode context by unlinking it and then
//              dereferencing it.
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa context handle of the context to delete
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, STATUS_INVALID_HANDLE if the
//              context can't be located
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
XtcbDeleteUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle
    )
{
    XtcbDeleteUserContext( ContextHandle );

    return( SEC_E_OK );

}


//+-------------------------------------------------------------------------
//
//  Function:   XtcbInitUserModeContext
//
//  Synopsis:   Creates a user-mode context from a packed LSA mode context
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa mode context handle for the context
//              PackedContext - A marshalled buffer containing the LSA
//                  mode context.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
XtcbInitUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBuffer PackedContext
    )
{
    SECURITY_STATUS scRet = SEC_E_INVALID_HANDLE ;

    scRet = XtcbAddUserContext( ContextHandle, PackedContext );

    if ( NT_SUCCESS( scRet ) )
    {
        FreeContextBuffer( PackedContext->pvBuffer );
    }

    return( scRet );
}


//+-------------------------------------------------------------------------
//
//  Function:   XtcbMakeSignature
//
//  Synopsis:   Signs a message buffer by calculatinga checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              QualityOfProtection - Unused flags.
//              MessageBuffers - Contains an array of buffers to sign and
//                      to store the signature.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found.
//              STATUS_BUFFER_TOO_SMALL - the signature buffer is too small
//                      to hold the signature
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
XtcbMakeSignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}

//+-------------------------------------------------------------------------
//
//  Function:   XtcbVerifySignature
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



NTSTATUS NTAPI
XtcbVerifySignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}

NTSTATUS NTAPI
XtcbSealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSequenceNumber
    )
{
    return( SEC_E_CONTEXT_EXPIRED );


}

NTSTATUS NTAPI
XtcbUnsealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc pMessage,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    // Output Buffer Types
    return( SEC_E_CONTEXT_EXPIRED );

}


//+-------------------------------------------------------------------------
//
//  Function:   SpGetContextToken
//
//  Synopsis:   returns a pointer to the token for a server-side context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
XtcbGetContextToken(
    IN LSA_SEC_HANDLE ContextHandle,
    OUT PHANDLE ImpersonationToken
    )
{
    PXTCB_USER_CONTEXT Context ;

    Context = XtcbFindUserContext( ContextHandle );

    if ( Context )
    {
        *ImpersonationToken = Context->Token ;

        return SEC_E_OK ;
    }
    else
    {
        return SEC_E_INVALID_HANDLE ;
    }

}


//+-------------------------------------------------------------------------
//
//  Function:   SpQueryContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
XtcbQueryContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN OUT PVOID pBuffer
    )
{
    PXTCB_USER_CONTEXT   Context ;
    PSecPkgContext_Sizes    Sizes ;
    PSecPkgContext_NamesW   Names ;
    PSecPkgContext_Lifespan Lifespan ;
    PSecPkgContext_DceInfo  DceInfo ;
    PSecPkgContext_Authority Authority ;
    SECURITY_STATUS Status ;
    int len ;

    Context = XtcbFindUserContext( ContextHandle );

    if ( !Context )
    {
        return SEC_E_INVALID_HANDLE ;
    }

    switch ( ContextAttribute )
    {
        case SECPKG_ATTR_SIZES:
            Sizes = (PSecPkgContext_Sizes) pBuffer ;
            ZeroMemory( Sizes, sizeof( SecPkgContext_Sizes ) );
            Status = SEC_E_OK ;
            break;

        case SECPKG_ATTR_NAMES:
            Status = SEC_E_OK ;
            break;

        case SECPKG_ATTR_LIFESPAN:
            Status = SEC_E_OK ;
            break;

        default:
            Status = SEC_E_UNSUPPORTED_FUNCTION ;


    }
    return Status ;
}



//+-------------------------------------------------------------------------
//
//  Function:   SpCompleteAuthToken
//
//  Synopsis:   Completes a context (in Kerberos case, does nothing)
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
NTAPI
XtcbCompleteAuthToken(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc InputBuffer
    )
{
    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\sources.inc ===
!IF 0

LINKER_FLAGS=$(LINKER_FLAGS) -debugtype:fixup,cv  -debug -opt:ref
USER_C_FLAGS=$(USER_C_FLAGS) /Zi
NTDBGFiles=  
NTBBT=1

!ENDIF

!IF "$(CERTSRV_W4)"!=""
MSC_WARNING_LEVEL=/W4
!ENDIF

!IF $(IA64)
# Emit LTCG codegen
LTCG_WKS=1
!ENDIF

CA_MAC_CONDITIONAL_INCLUDES= \
    macapi.h \
    macname1.h \
    macname2.h \
    macocidl.h \
    macpub.h \
    rpcerr.h \
    rpcmac.h \
    winwlm.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\xtcbpkg.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       xtcbpkg.c
//
//  Contents:   Xtcb Security Package
//
//  Classes:
//
//  Functions:  Basic management
//
//  History:    2-19-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"

SECPKG_FUNCTION_TABLE   XtcbTable = {
            NULL,                               // InitializePackage
            NULL,                               // LogonUser
            XtcbCallPackage,                    
            XtcbLogonTerminated,
            XtcbCallPackageUntrusted,
            NULL,                               // CallPackagePassthrough
            NULL,                               // LogonUserEx
            NULL,                               // LogonUserEx2
            XtcbInitialize,
            XtcbShutdown,
            XtcbGetInfo,
            XtcbAcceptCredentials,
            XtcbAcquireCredentialsHandle,
            XtcbQueryCredentialsAttributes,
            XtcbFreeCredentialsHandle,
            NULL,
            NULL,
            NULL,
            XtcbInitLsaModeContext,
            XtcbAcceptLsaModeContext,
            XtcbDeleteContext,
            XtcbApplyControlToken,
            XtcbGetUserInfo,
            XtcbGetExtendedInformation,
            XtcbQueryLsaModeContext
            };


ULONG_PTR   XtcbPackageId;
PLSA_SECPKG_FUNCTION_TABLE LsaTable ;
TimeStamp   XtcbNever = { 0xFFFFFFFF, 0x7FFFFFFF };
TOKEN_SOURCE XtcbSource ;
SECURITY_STRING XtcbComputerName ;
SECURITY_STRING XtcbUnicodeDnsName ;
SECURITY_STRING XtcbDomainName ;
STRING XtcbDnsName ;
PSID XtcbMachineSid ;

ULONG   ThunkedContextLevels[] = { SECPKG_ATTR_LIFESPAN };


//+---------------------------------------------------------------------------
//
//  Function:   SpLsaModeInitialize
//
//  Synopsis:   Initializes connection with LSA.  Allows the DLL to specify all the
//              packages contained within it, and their function tables.
//
//  Arguments:  [LsaVersion]     -- Version of the LSA
//              [PackageVersion] -- Version of the package (out)
//              [Table]          -- Table of package functions
//              [TableCount]     -- Count of tables
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
SpLsaModeInitialize(
    IN ULONG LsaVersion,
    OUT PULONG PackageVersion,
    OUT PSECPKG_FUNCTION_TABLE * Table,
    OUT PULONG TableCount)
{
    *PackageVersion = SECPKG_INTERFACE_VERSION ;
    *Table = &XtcbTable ;
    *TableCount = 1;

#if DBG
    InitDebugSupport();
#endif

    DebugLog(( DEB_TRACE, "XtcbPkg DLL Loaded\n" ));

    return( SEC_E_OK );
}

BOOL
XtcbReadParameters(
    VOID
    )
{
    MGroupReload();

    return TRUE ;

}




//+---------------------------------------------------------------------------
//
//  Function:   XtcbInitialize
//
//  Synopsis:   Actual initialization function for the security package
//
//  Arguments:  [dwPackageID] -- Assigned package ID
//              [pParameters] -- Initialization parameters
//              [Table]       -- Table of callbacks into the LSA for support
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbInitialize(
    ULONG_PTR   dwPackageID,
    PSECPKG_PARAMETERS  Parameters,
    PLSA_SECPKG_FUNCTION_TABLE  Table
    )
{
    WCHAR ComputerName[ MAX_PATH ];
    DWORD Size ;
    XtcbPackageId = dwPackageID ;
    LsaTable = Table ;

    //
    // Initialize our control structures
    //

    XtcbInitCreds();

    XtcbInitializeContexts();

    //
    // Set up the source name that we will use for tokens
    //

    CopyMemory( XtcbSource.SourceName, "XTCBPKG", sizeof( "XTCBPKG" ) );
    AllocateLocallyUniqueId( &XtcbSource.SourceIdentifier );

    //
    // Get the names for the XTCB protocol.
    //

    Size = sizeof( ComputerName ) / sizeof( WCHAR );

    GetComputerName( ComputerName, &Size );

    XtcbDupStringToSecurityString( &XtcbComputerName, ComputerName );

    Size = MAX_PATH ;

    if ( GetComputerNameEx( ComputerNameDnsFullyQualified,
                            ComputerName,
                            &Size ) )
    {
        XtcbDupStringToSecurityString( &XtcbUnicodeDnsName, ComputerName );
    }

    XtcbDupSecurityString( &XtcbDomainName, &Parameters->DomainName );

    if ( !MGroupInitialize() )
    {
        return STATUS_UNSUCCESSFUL ;
    }

    //
    // Start a watch on our reg key to reload any parameter change
    //

    

    DebugLog(( DEB_TRACE_CALLS, "Initialized in LSA mode\n" ));

    return(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   XtcbGetInfo
//
//  Synopsis:   Returns information about the package to the LSA
//
//  Arguments:  [pInfo] --
//
//  History:    2-19-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbGetInfo(PSecPkgInfo pInfo)
{

    DebugLog(( DEB_TRACE_CALLS, "GetInfo\n" ));

    pInfo->wVersion         = 1;
    pInfo->wRPCID           = 0x15 ;
    pInfo->fCapabilities    =
                              SECPKG_FLAG_CONNECTION |
                              SECPKG_FLAG_MULTI_REQUIRED |
                              SECPKG_FLAG_EXTENDED_ERROR |
                              SECPKG_FLAG_IMPERSONATION |
                              SECPKG_FLAG_ACCEPT_WIN32_NAME |
                              SECPKG_FLAG_NEGOTIABLE ;

    pInfo->cbMaxToken       = 8000;
    pInfo->Name             = L"XTCB";
    pInfo->Comment          = L"Extended TCB package";

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function:   XtcbGetExtendedInformation
//
//  Synopsis:   Return extended information to the LSA
//
//  Arguments:  [Class] -- Information Class
//              [pInfo] -- Returned Information Pointer
//
//  History:    3-04-97   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbGetExtendedInformation(
    SECPKG_EXTENDED_INFORMATION_CLASS   Class,
    PSECPKG_EXTENDED_INFORMATION *      pInfo
    )
{
    PSECPKG_EXTENDED_INFORMATION    Info ;
    SECURITY_STATUS Status ;

    DebugLog(( DEB_TRACE_CALLS, "GetExtendedInfo( %d )\n", Class ));

    switch ( Class )
    {
        case SecpkgContextThunks:

            //
            // Which context information levels do we want
            // thunked over to the LSA, and which can we handle
            // in the user process?
            //

            Info = (PSECPKG_EXTENDED_INFORMATION) LsaTable->AllocateLsaHeap(
                            sizeof( SECPKG_EXTENDED_INFORMATION ) +
                            sizeof( ThunkedContextLevels ) );

            if ( Info )
            {
                Info->Class = Class ;
                Info->Info.ContextThunks.InfoLevelCount =
                                sizeof( ThunkedContextLevels ) / sizeof( ULONG );
                CopyMemory( Info->Info.ContextThunks.Levels,
                            ThunkedContextLevels,
                            sizeof( ThunkedContextLevels ) );

                Status = SEC_E_OK ;

            }
            else
            {
                Status = SEC_E_INSUFFICIENT_MEMORY ;
            }

            break;


        default:
            Status = SEC_E_UNSUPPORTED_FUNCTION ;
            Info = NULL ;
            break;

    }

    *pInfo = Info ;
    return Status ;
}


NTSTATUS
NTAPI
XtcbCallPackage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    PULONG TagType ;
    NTSTATUS Status ;


    return( SEC_E_UNSUPPORTED_FUNCTION );
}

NTSTATUS
NTAPI
XtcbCallPackageUntrusted(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    return( SEC_E_UNSUPPORTED_FUNCTION );
}


//+---------------------------------------------------------------------------
//
//  Function:   XtcbShutdown
//
//  Synopsis:   Called at shutdown to clean up state
//
//  Arguments:  (none)
//
//  History:    8-15-98   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
SECURITY_STATUS
SEC_ENTRY
XtcbShutdown(void)
{
    return( STATUS_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\util.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       util.c
//
//  Contents:   General utility functions
//
//  Functions:
//
//  History:    2-20-97   RichardW   Created
//
//----------------------------------------------------------------------------

#include "xtcbpkg.h"
#include "stdio.h"

BOOL
XtcbDupSecurityString(
    PSECURITY_STRING    Dest,
    PSECURITY_STRING    Source
    )
{
    if ( Source->Buffer == NULL )
    {
        ZeroMemory( Dest, sizeof( SECURITY_STRING ) );
        return TRUE ;
    }
    Dest->Buffer = LocalAlloc( LMEM_FIXED, Source->Length + sizeof(WCHAR) );
    if ( Dest->Buffer )
    {
        Dest->MaximumLength = Source->Length + sizeof( WCHAR ) ;
        Dest->Length = Source->Length ;
        CopyMemory( Dest->Buffer, Source->Buffer, Source->Length);
        Dest->Buffer[ Dest->Length / sizeof( WCHAR ) ] = L'\0';
        return TRUE ;
    }
    return FALSE ;
}

BOOL
XtcbAnsiStringToSecurityString(
    PSECURITY_STRING    Dest,
    PSTRING             Source
    )
{
    int len;

    len = (Source->Length + 1) * sizeof(WCHAR) ;

    // overkill, but safe

    Dest->Buffer = LocalAlloc( LMEM_FIXED, len );

    if ( Dest->Buffer )
    {
        Dest->Length = (USHORT) (len - sizeof(WCHAR)) ;
        Dest->MaximumLength = (USHORT) len ;

        MultiByteToWideChar( CP_ACP, 0,
                             Source->Buffer, -1,
                             Dest->Buffer, len / sizeof(WCHAR) );

        return TRUE ;
    }

    return FALSE ;


}

BOOL
XtcbSecurityStringToAnsiString(
    PSTRING Dest,
    PSECURITY_STRING Source
    )
{
    int len ;

    len = (Source->Length / sizeof(WCHAR)) + 1 ;

    Dest->Buffer = LocalAlloc( LMEM_FIXED, len );

    if ( Dest->Buffer )
    {
        Dest->Length = (USHORT) (len - 1) ;
        Dest->MaximumLength = (USHORT) len ;

        WideCharToMultiByte( CP_ACP, 0,
                             Source->Buffer, -1,
                             Dest->Buffer, len,
                             NULL, NULL );

        return TRUE ;
    }

    return FALSE ;
}

BOOL
XtcbDupStringToSecurityString(
    PSECURITY_STRING    Dest,
    PWSTR               Source
    )
{
    ULONG   Len ;

    Len = (wcslen( Source ) + 1) * 2 ;

    Dest->Buffer = LocalAlloc( LMEM_FIXED, Len );

    if ( Dest->Buffer )
    {
        Dest->MaximumLength = (USHORT) Len ;
        Dest->Length = (USHORT) Len - 2 ;

        CopyMemory( Dest->Buffer, Source, Len );

        return TRUE ;
    }
    return FALSE ;
}

BOOL
XtcbGenerateChallenge(
    PUCHAR  Challenge,
    ULONG   Length,
    PULONG  Actual
    )
{
    CHAR    Temp[ MAX_PATH ];
    LUID    Unique;
    ULONG   Len ;

    AllocateLocallyUniqueId( &Unique );

    _snprintf( Temp, MAX_PATH, "<%x%x.%x%x@%s>",
                GetCurrentProcessId(), GetCurrentThreadId(),
                Unique.HighPart, Unique.LowPart,
                XtcbDnsName.Buffer
             );

    Len = strlen( Temp );

    if ( Len < Length )
    {
        strcpy( Challenge, Temp );
        *Actual = Len;
        return TRUE ;
    }

    *Actual = Len + 1;

    return FALSE ;

}

BOOL
XtcbCaptureAuthData(
    PVOID   pvAuthData,
    PSEC_WINNT_AUTH_IDENTITY * AuthData
    )
{
    SEC_WINNT_AUTH_IDENTITY Auth ;
    PSEC_WINNT_AUTH_IDENTITY pAuth ;
    SECURITY_STATUS Status ;
    ULONG   TotalSize ;
    PWSTR   Current ;

    ZeroMemory( &Auth, sizeof( Auth ) );

    Status = LsaTable->CopyFromClientBuffer(
                            NULL,
                            sizeof( SEC_WINNT_AUTH_IDENTITY ),
                            & Auth,
                            pvAuthData );

    if ( !NT_SUCCESS( Status ) )
    {
        return FALSE ;
    }

    if ( Auth.Flags & SEC_WINNT_AUTH_IDENTITY_ANSI )
    {
        return FALSE ;
    }

    TotalSize = sizeof( SEC_WINNT_AUTH_IDENTITY ) +
                ( Auth.UserLength + 1 +
                  Auth.DomainLength + 1 +
                  Auth.PasswordLength + 1 ) * sizeof( WCHAR );

    pAuth = (PSEC_WINNT_AUTH_IDENTITY) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                            TotalSize );

    if ( !pAuth )
    {
        return FALSE ;
    }

    pAuth->Flags = Auth.Flags ;

    Current = (PWSTR) (pAuth + 1);

    if ( Auth.User )
    {
        pAuth->User = Current ;
        pAuth->UserLength = Auth.UserLength ;

        Status = LsaTable->CopyFromClientBuffer(
                            NULL,
                            (Auth.UserLength + 1) * sizeof(WCHAR) ,
                            pAuth->User,
                            Auth.User );

        if ( !NT_SUCCESS( Status ) )
        {
            goto Error_Cleanup ;
        }

        Current += Auth.UserLength + 1;
    }

    if ( Auth.Domain )
    {
        pAuth->Domain = Current ;
        pAuth->DomainLength = Auth.DomainLength ;

        Status = LsaTable->CopyFromClientBuffer(
                            NULL,
                            (Auth.DomainLength + 1) * sizeof( WCHAR ),
                            pAuth->Domain,
                            Auth.Domain );

        if ( !NT_SUCCESS( Status ) )
        {
            goto Error_Cleanup ;
        }

        Current += Auth.DomainLength + 1;

    }

    if ( Auth.Password )
    {
        pAuth->Password = Current ;
        pAuth->PasswordLength = Auth.PasswordLength ;

        Status = LsaTable->CopyFromClientBuffer(
                            NULL,
                            (Auth.PasswordLength + 1) * sizeof( WCHAR ),
                            pAuth->Password,
                            Auth.Password );

        if ( !NT_SUCCESS( Status ) )
        {
            goto Error_Cleanup ;
        }

        Current += Auth.PasswordLength + 1;

    }

    *AuthData = pAuth ;

    return TRUE ;

Error_Cleanup:

    LocalFree( pAuth );

    return FALSE ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\about.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include <stdafx.h>


CCAPolicyAboutImpl::CCAPolicyAboutImpl()
{
}


CCAPolicyAboutImpl::~CCAPolicyAboutImpl()
{
}


HRESULT CCAPolicyAboutImpl::AboutHelper(UINT nID, LPOLESTR* lpPtr)
{
    if (lpPtr == NULL)
        return E_POINTER;

    CString s;

    // Needed for Loadstring
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    s.LoadString(nID);
    *lpPtr = reinterpret_cast<LPOLESTR>
            (CoTaskMemAlloc((s.GetLength() + 1)* sizeof(wchar_t)));

    if (*lpPtr == NULL)
        return E_OUTOFMEMORY;

	USES_CONVERSION;

    wcscpy(*lpPtr, T2OLE((LPTSTR)(LPCTSTR)s));

    return S_OK;
}

HRESULT CCAPolicyAboutImpl::AboutHelper2(LPSTR str, LPOLESTR* lpPtr)
{
    LPWSTR pwszTmp = NULL;

    if (!myConvertSzToWsz(&pwszTmp, str, -1))
        return myHLastError();

    *lpPtr = reinterpret_cast<LPOLESTR>
        (CoTaskMemAlloc((wcslen(pwszTmp)+1)*sizeof(wchar_t)));

    if(*lpPtr == NULL)
        return E_OUTOFMEMORY;

    wcscpy(*lpPtr, pwszTmp);

    LOCAL_FREE(pwszTmp);

    return S_OK;
}



STDMETHODIMP CCAPolicyAboutImpl::GetSnapinDescription(LPOLESTR* lpDescription)
{
    return AboutHelper(IDS_CAPOLICY_DESCRIPTION, lpDescription);
}


STDMETHODIMP CCAPolicyAboutImpl::GetProvider(LPOLESTR* lpName)
{
    return AboutHelper(IDS_COMPANY, lpName);
}


STDMETHODIMP CCAPolicyAboutImpl::GetSnapinVersion(LPOLESTR* lpVersion)
{
    return AboutHelper2(VER_PRODUCTVERSION_STR, lpVersion);
}


STDMETHODIMP CCAPolicyAboutImpl::GetSnapinImage(HICON* hAppIcon)
{
    if (hAppIcon == NULL)
        return E_POINTER;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // in MMC 1.1, this will be used as root node icon!!
    *hAppIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_APPICON));

    ASSERT(*hAppIcon != NULL);
    return (*hAppIcon != NULL) ? S_OK : E_FAIL;
}


STDMETHODIMP CCAPolicyAboutImpl::GetStaticFolderImage(HBITMAP* hSmallImage, 
                                                    HBITMAP* hSmallImageOpen,
                                                    HBITMAP* hLargeImage, 
                                                    COLORREF* cLargeMask)
{
	ASSERT(hSmallImage != NULL);
	ASSERT(hSmallImageOpen != NULL);
	ASSERT(hLargeImage != NULL);
	ASSERT(cLargeMask != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
	HINSTANCE hInstance = AfxGetInstanceHandle();

    *hSmallImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_FOLDER_SMALL));
	*hSmallImageOpen = ::LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_FOLDER_SMALL));
	*hLargeImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_FOLDER_LARGE));

	*cLargeMask = RGB(255, 0, 255);

	#ifdef _DEBUG
	if (NULL == *hSmallImage || NULL == *hSmallImageOpen || NULL == *hLargeImage)
		{
        OutputDebugString(L"WRN: CSnapinAbout::GetStaticFolderImage() - Unable to load all the bitmaps.\n"); 
		return E_FAIL;
		}
	#endif

    return S_OK;
}


CCertTypeAboutImpl::CCertTypeAboutImpl()
{
}


CCertTypeAboutImpl::~CCertTypeAboutImpl()
{
}


HRESULT CCertTypeAboutImpl::AboutHelper(UINT nID, LPOLESTR* lpPtr)
{
    if (lpPtr == NULL)
        return E_POINTER;

    CString s;

    // Needed for Loadstring
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    s.LoadString(nID);
    *lpPtr = reinterpret_cast<LPOLESTR>
            (CoTaskMemAlloc((s.GetLength() + 1)* sizeof(wchar_t)));

    if (*lpPtr == NULL)
        return E_OUTOFMEMORY;

	USES_CONVERSION;

    wcscpy(*lpPtr, T2OLE((LPTSTR)(LPCTSTR)s));

    return S_OK;
}

HRESULT CCertTypeAboutImpl::AboutHelper2(LPSTR str, LPOLESTR* lpPtr)
{
    LPWSTR pwszTmp = NULL;

    if (!myConvertSzToWsz(&pwszTmp, str, -1))
        return myHLastError();

    *lpPtr = reinterpret_cast<LPOLESTR>
        (CoTaskMemAlloc((wcslen(pwszTmp)+1)*sizeof(wchar_t)));

    if(*lpPtr == NULL)
        return E_OUTOFMEMORY;

    wcscpy(*lpPtr, pwszTmp);

    LOCAL_FREE(pwszTmp);

    return S_OK;
}

STDMETHODIMP CCertTypeAboutImpl::GetSnapinDescription(LPOLESTR* lpDescription)
{
    return AboutHelper(IDS_CERTTYPE_DESCRIPTION, lpDescription);
}


STDMETHODIMP CCertTypeAboutImpl::GetProvider(LPOLESTR* lpName)
{
    return AboutHelper(IDS_COMPANY, lpName);
}


STDMETHODIMP CCertTypeAboutImpl::GetSnapinVersion(LPOLESTR* lpVersion)
{
    return AboutHelper2(VER_PRODUCTVERSION_STR, lpVersion);
}


STDMETHODIMP CCertTypeAboutImpl::GetSnapinImage(HICON* hAppIcon)
{
    if (hAppIcon == NULL)
        return E_POINTER;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // in MMC 1.1, this will be used as root node icon!!
    *hAppIcon = LoadIcon(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDI_APPICON));

    ASSERT(*hAppIcon != NULL);
    return (*hAppIcon != NULL) ? S_OK : E_FAIL;
}


STDMETHODIMP CCertTypeAboutImpl::GetStaticFolderImage(HBITMAP* hSmallImage, 
                                                    HBITMAP* hSmallImageOpen,
                                                    HBITMAP* hLargeImage, 
                                                    COLORREF* cLargeMask)
{
	ASSERT(hSmallImage != NULL);
	ASSERT(hSmallImageOpen != NULL);
	ASSERT(hLargeImage != NULL);
	ASSERT(cLargeMask != NULL);
	AFX_MANAGE_STATE(AfxGetStaticModuleState());	// Required for AfxGetInstanceHandle()
	HINSTANCE hInstance = AfxGetInstanceHandle();

    *hSmallImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_FOLDER_SMALL));
	*hSmallImageOpen = ::LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_FOLDER_SMALL));
	*hLargeImage = ::LoadBitmap(hInstance, MAKEINTRESOURCE(IDB_FOLDER_LARGE));

	*cLargeMask = RGB(255, 0, 255);

	#ifdef _DEBUG
	if (NULL == *hSmallImage || NULL == *hSmallImageOpen || NULL == *hLargeImage)
		{
		OutputDebugString(L"WRN: CSnapinAbout::GetStaticFolderImage() - Unable to load all the bitmaps.\n");
		return E_FAIL;
		}
	#endif

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\compdata.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.



#include "stdafx.h"
#include <sceattch.h>
#include "genpage.h"

#include <atlimpl.cpp>

#define __dwFILE__	__dwFILE_CAPESNPN_COMPDATA_CPP__


// Array of menu item commands to be inserted into the contest menu.
// Note - the first item is the menu text, // CCM_SPECIAL_DEFAULT_ITEM
// the second item is the status string



///////////////////////////////////////////////////////////////////////////////
// IComponentData implementation

DEBUG_DECLARE_INSTANCE_COUNTER(CComponentDataImpl);

CComponentDataImpl::CComponentDataImpl()
    : m_bIsDirty(TRUE), m_pScope(NULL), m_pConsole(NULL),
#if DBG
     m_bInitializedCD(false), m_bDestroyedCD(false),
#endif
     m_fAdvancedServer(false), m_hrCreateFolder(S_OK)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CComponentDataImpl);

#ifdef _DEBUG
    m_cDataObjects = 0;
#endif
}

CComponentDataImpl::~CComponentDataImpl()
{
    DEBUG_DECREMENT_INSTANCE_COUNTER(CComponentDataImpl);

    ASSERT(m_pScope == NULL);
    
    ASSERT(!m_bInitializedCD || m_bDestroyedCD);
    
    // Some snap-in is hanging on to data objects.
    // If they access, it will crash!!!
    ASSERT(m_cDataObjects <= 1);
}

STDMETHODIMP CComponentDataImpl::Initialize(LPUNKNOWN pUnknown)
{
    DBX_PRINT(_T(" ----------  CComponentDataImpl::Initialize<0x08x>\n"), this);
#if DBG
    m_bInitializedCD = true;
#endif

    ASSERT(pUnknown != NULL);
    HRESULT hr;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // MMC should only call ::Initialize once!
    ASSERT(m_pScope == NULL);
    pUnknown->QueryInterface(IID_IConsoleNameSpace, 
                    reinterpret_cast<void**>(&m_pScope));

    // add the images for the scope tree
    ::CBitmap bmp16x16;
    LPIMAGELIST lpScopeImage;

    hr = pUnknown->QueryInterface(IID_IConsole2, reinterpret_cast<void**>(&m_pConsole));
    ASSERT(hr == S_OK);

    hr = m_pConsole->QueryScopeImageList(&lpScopeImage);

    ASSERT(hr == S_OK);

    // Load the bitmaps from the dll
    bmp16x16.LoadBitmap(IDB_16x16);

    // Set the images
    lpScopeImage->ImageListSetStrip(reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp16x16)),
                      reinterpret_cast<LONG_PTR *>(static_cast<HBITMAP>(bmp16x16)),
                       0, RGB(255, 0, 255));

    lpScopeImage->Release();


    // Add any init code here NOT based on info from .MSC file
    
    return S_OK;
}

STDMETHODIMP CComponentDataImpl::CreateComponent(LPCOMPONENT* ppComponent)
{
    ASSERT(ppComponent != NULL);

    CComObject<CSnapin>* pObject;
    CComObject<CSnapin>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    // Store IComponentData
    pObject->SetIComponentData(this);

    return  pObject->QueryInterface(IID_IComponent, 
                    reinterpret_cast<void**>(ppComponent));
}

STDMETHODIMP CComponentDataImpl::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    ASSERT(m_pScope != NULL);
    HRESULT     hr = S_OK;
    HWND        hwndConsole;
    
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    INTERNAL* pInternal;
    MMC_COOKIE cookie;

    // Since it's my folder it has an internal format.
    // Design Note: for extension.  I can use the fact, that the data object doesn't have 
    // my internal format and I should look at the node type and see how to extend it.

    // switch on events where we don't care about pInternal->m_cookie
    switch(event)
    {
    case MMCN_PROPERTY_CHANGE:
        hr = OnProperties(param);
        goto Ret;

    case MMCN_EXPAND:
        hr = OnExpand(lpDataObject, arg, param);
        goto Ret;

    default:
        break;
    }

    // handle cases where we do care about pInternal->m_cookie
    pInternal = ExtractInternalFormat(lpDataObject);
    if (pInternal == NULL)
        return S_OK;

    cookie = pInternal->m_cookie;
    ::GlobalFree(reinterpret_cast<HANDLE>(pInternal));

    switch(event)
    {
    case MMCN_PASTE:
        break;
    
    case MMCN_DELETE:
        hr = OnDelete(cookie);
        break;

    case MMCN_REMOVE_CHILDREN:
        hr = OnRemoveChildren(arg);
        break;

    case MMCN_RENAME:
        hr = OnRename(cookie, arg, param);
        break;

    default:
        break;
    }

Ret:
    return hr;
}

STDMETHODIMP CComponentDataImpl::Destroy()
{
    DBX_PRINT(_T(" ----------  CComponentDataImpl::Destroy<0x08x>\n"), this);
    ASSERT(m_bInitializedCD);
#if DBG
    m_bDestroyedCD = true;
#endif
    
    // Delete enumerated scope items
    DeleteList(); 

    SAFE_RELEASE(m_pScope);
    SAFE_RELEASE(m_pConsole);

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
#ifdef _DEBUG
    if (cookie == 0)
    {
        ASSERT(type != CCT_RESULT);
    }
    else 
    {
        ASSERT(type == CCT_SCOPE);
        
        DWORD dwItemType = GetItemType(cookie);
        ASSERT(dwItemType == SCOPE_LEVEL_ITEM);
        //ASSERT((dwItemType == SCOPE_LEVEL_ITEM) || (dwItemType == CA_LEVEL_ITEM));
    }
#endif 

    return _QueryDataObject(cookie, type, this, ppDataObject);
}



///////////////////////////////////////////////////////////////////////////////
//// ISnapinHelp interface
STDMETHODIMP CComponentDataImpl::GetHelpTopic(LPOLESTR* lpCompiledHelpFile)
{
  if (lpCompiledHelpFile == NULL)
     return E_POINTER;

  UINT cbWindows = 0;
  WCHAR szWindows[MAX_PATH+1];
  cbWindows = GetSystemWindowsDirectory(szWindows, MAX_PATH);
  if (cbWindows == 0)
     return S_FALSE;
  cbWindows += wcslen(HTMLHELP_COLLECTION_FILENAME);
  cbWindows++;  // include null term
  cbWindows *= sizeof(WCHAR);   // make this bytes, not chars

  *lpCompiledHelpFile = (LPOLESTR) CoTaskMemAlloc(cbWindows);
  if (*lpCompiledHelpFile == NULL)
     return E_OUTOFMEMORY;
  myRegisterMemFree(*lpCompiledHelpFile, CSM_COTASKALLOC);  // this is freed by mmc, not our tracking


  USES_CONVERSION;
  wcscpy(*lpCompiledHelpFile, T2OLE(szWindows));
  wcscat(*lpCompiledHelpFile, T2OLE(HTMLHELP_COLLECTION_FILENAME));

  return S_OK;
}

// tells of other topics my chm links to
STDMETHODIMP CComponentDataImpl::GetLinkedTopics(LPOLESTR* lpCompiledHelpFiles)
{
  if (lpCompiledHelpFiles == NULL)
     return E_POINTER;

  UINT cbWindows = 0;
  WCHAR szWindows[MAX_PATH+1];
  cbWindows = GetSystemWindowsDirectory(szWindows, MAX_PATH);
  if (cbWindows == 0)
     return S_FALSE;
  cbWindows += wcslen(HTMLHELP_COLLECTIONLINK_FILENAME);
  cbWindows++;  // include null term
  cbWindows *= sizeof(WCHAR);   // make this bytes, not chars

  *lpCompiledHelpFiles = (LPOLESTR) CoTaskMemAlloc(cbWindows);
  if (*lpCompiledHelpFiles == NULL)
     return E_OUTOFMEMORY;
  myRegisterMemFree(*lpCompiledHelpFiles, CSM_COTASKALLOC);  // this is freed by mmc, not our tracking


  USES_CONVERSION;
  wcscpy(*lpCompiledHelpFiles, T2OLE(szWindows));
  wcscat(*lpCompiledHelpFiles, T2OLE(HTMLHELP_COLLECTIONLINK_FILENAME));

  return S_OK;
}



///////////////////////////////////////////////////////////////////////////////
//// IPersistStream interface members
/*
STDMETHODIMP CComponentDataImpl::GetClassID(CLSID *pClassID)
{
    ASSERT(pClassID != NULL);

    // Copy the CLSID for this snapin
    *pClassID = CLSID_CAPolicyExtensionSnapIn;

    return E_NOTIMPL;
}
*/
STDMETHODIMP CComponentDataImpl::IsDirty()
{
    // Always save / Always dirty.
    return ThisIsDirty() ? S_OK : S_FALSE;
}

STDMETHODIMP CComponentDataImpl::Load(IStream *pStm)
{
    DBX_PRINT(_T(" ----------  CComponentDataImpl::Load<0x08x>\n"), this);

    ASSERT(pStm);
    ASSERT(m_bInitializedCD);

    // Read the string
    DWORD dwVer;
    ULONG nBytesRead;
    HRESULT hr = pStm->Read(&dwVer, sizeof(DWORD), &nBytesRead);

    // Verify that the read succeeded
    ASSERT(SUCCEEDED(hr) && nBytesRead == sizeof(DWORD));

    // check to see if this is the correct version
    if (dwVer != 0x1)
    {
        return STG_E_OLDFORMAT;
    }

    ClearDirty();

    return SUCCEEDED(hr) ? S_OK : E_FAIL;
}

STDMETHODIMP CComponentDataImpl::Save(IStream *pStm, BOOL fClearDirty)
{
    DBX_PRINT(_T(" ----------  CComponentDataImpl::Save<0x08x>\n"), this);

    ASSERT(pStm);
    ASSERT(m_bInitializedCD);

    // Write the string
    ULONG nBytesWritten;
    DWORD dwVer = 0x1;
    HRESULT hr = pStm->Write(&dwVer, sizeof(DWORD), &nBytesWritten);

    // Verify that the write operation succeeded
    ASSERT(SUCCEEDED(hr) && nBytesWritten == sizeof(DWORD));
    if (FAILED(hr))
        return STG_E_CANTSAVE;

    if (fClearDirty)
        ClearDirty();
    return S_OK;
}

STDMETHODIMP CComponentDataImpl::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ASSERT(pcbSize);

    DWORD cbSize;
    cbSize = sizeof(DWORD); // version

    // Set the size of the string to be saved
    ULISet32(*pcbSize, cbSize);

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//// Notify handlers for IComponentData

HRESULT CComponentDataImpl::OnDelete(MMC_COOKIE cookie)
{
    return S_OK;
}

HRESULT CComponentDataImpl::OnRemoveChildren(LPARAM arg)
{
    return S_OK;
}

HRESULT CComponentDataImpl::OnRename(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    if (arg == 0)
        return S_OK;
    
    LPOLESTR pszNewName = reinterpret_cast<LPOLESTR>(param);
    if (pszNewName == NULL)
        return E_INVALIDARG;

    CFolder* pFolder = reinterpret_cast<CFolder*>(cookie);
    ASSERT(pFolder != NULL);
    if (pFolder == NULL)
        return E_INVALIDARG;

    pFolder->SetName(pszNewName);
    
    return S_OK;
}

HRESULT CComponentDataImpl::OnExpand(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param)
{
    HRESULT hr = S_OK;

    GUID*       pNodeGUID = NULL;
    CFolder*    pFolder=NULL;
    bool fInsertFolder = false;

    STGMEDIUM stgmediumNodeType = { TYMED_HGLOBAL, NULL };
    STGMEDIUM stgmediumCAType = { TYMED_HGLOBAL, NULL };
    STGMEDIUM stgmediumCAName = { TYMED_HGLOBAL, NULL };
    STGMEDIUM stgmediumCARoles = { TYMED_HGLOBAL, NULL };

    LPWSTR pszDSName = NULL;

    if (arg == TRUE)
    {
        // Did Initialize get called?
        ASSERT(m_pScope != NULL);

        //
        // get the guid of the current node
        //
        UINT s_cfNodeType;
        s_cfNodeType = RegisterClipboardFormat(W2T(CCF_NODETYPE));
    
        FORMATETC formatetcNodeType = { (CLIPFORMAT)s_cfNodeType, NULL, 
                                        DVASPECT_CONTENT, -1, TYMED_HGLOBAL 
                                      };
    
        hr = lpDataObject->GetDataHere(&formatetcNodeType, &stgmediumNodeType);
        _JumpIfError(hr, Ret, "GetDataHere NodeType");
            
        pNodeGUID = (GUID*) GlobalLock(stgmediumNodeType.hGlobal);
        if (pNodeGUID == NULL)
        {
            hr = E_UNEXPECTED;
            _JumpError(hr, Ret, "GlobalLock failed");
        }

        //
        // if this is the parents node then add our node undeneath it
        //

        // CA Manager parent
        if (memcmp(pNodeGUID, (void *)&cCAManagerParentNodeID, sizeof(GUID)) == 0)
        {
            fInsertFolder = true;
            CString     szFolderName;

            // Only add node under ENT ROOT, ENT SUB 
            UINT    cfCAType = RegisterClipboardFormat(W2T((LPWSTR)SNAPIN_CA_INSTALL_TYPE));
            FORMATETC formatetcCAType = { (CLIPFORMAT)cfCAType, NULL, 
                DVASPECT_CONTENT, -1, TYMED_HGLOBAL 
                };
        
            hr = lpDataObject->GetDataHere(&formatetcCAType, &stgmediumCAType);
            _JumpIfError(hr, Ret, "GetDataHere CAType");
        
            PDWORD rgdw = (DWORD*)GlobalLock(stgmediumCAType.hGlobal);
            ENUM_CATYPES caType = (ENUM_CATYPES)rgdw[0];
        
            DBGPRINT((DBG_SS_CERTMMC, "CA Type: %d\n", caType));

            // return immediately if we're not an ENT {ROOT | SUB}
            if ((caType != ENUM_ENTERPRISE_SUBCA) &&
                (caType != ENUM_ENTERPRISE_ROOTCA))
            {
                hr = S_OK;
                goto Ret;
            }
        
            m_fAdvancedServer = (rgdw[1]!=0)?true:false;

            DBGPRINT((DBG_SS_CERTMMC, "Advanced Server: %hs\n", 
                m_fAdvancedServer?"yes":"no"));

            VERIFY(szFolderName.LoadString(IDS_POLICYSETTINGS));
            pFolder = new CFolder();
            if(pFolder == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Ret;
            }

            pFolder->Create(
                    (LPWSTR)((LPCTSTR)szFolderName), 
                    IMGINDEX_FOLDER, 
                    IMGINDEX_FOLDER_OPEN,
                    SCOPE_LEVEL_ITEM, 
                    POLICYSETTINGS, 
                    FALSE); 

            m_scopeItemList.AddTail(pFolder);
            pFolder->m_pScopeItem->relativeID = param;

            // Set the folder as the cookie
            pFolder->m_pScopeItem->mask |= SDI_PARAM;
            pFolder->m_pScopeItem->lParam = reinterpret_cast<LPARAM>(pFolder);
            pFolder->SetCookie(reinterpret_cast<LONG_PTR>(pFolder));

            // get the name of the CA that we are administering
            LPWSTR  pCAName = NULL;
        
            // nab CA Name
            UINT    cfCAName = RegisterClipboardFormat(W2T((LPWSTR)CA_SANITIZED_NAME));
            FORMATETC formatetcCAName = { (CLIPFORMAT)cfCAName, NULL, 
                                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL 
                                          };

            hr = lpDataObject->GetDataHere(&formatetcCAName, &stgmediumCAName);
            _JumpIfError(hr, Ret, "GetDataHere CAName");

            pCAName = (LPWSTR)GlobalLock(stgmediumCAName.hGlobal);
            if (pCAName == NULL)
            {
                hr = E_UNEXPECTED;
                _JumpError(hr, Ret, "GlobalLock");
            }

            pFolder->m_szCAName = pCAName;

            hr = mySanitizedNameToDSName(pCAName, &pszDSName);
            _JumpIfError(hr, Ret, "mySanitizedNameToDSName");

            // Get current user's roles
            DWORD* pdwRoles;
            UINT    cfCARoles = RegisterClipboardFormat(W2T((LPWSTR)CA_ROLES));
            FORMATETC formatetcCARoles = { (CLIPFORMAT)cfCARoles, NULL, 
                                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL 
                                          };

            hr = lpDataObject->GetDataHere(&formatetcCARoles, &stgmediumCARoles);
            _JumpIfError(hr, Ret, "GetDataHere CAName");

            pdwRoles = (DWORD*)GlobalLock(stgmediumCARoles.hGlobal);
            if (pdwRoles == NULL)
            {
                hr = E_UNEXPECTED;
                _JumpError(hr, Ret, "GlobalLock");
            }

            pFolder->m_dwRoles = *pdwRoles;

            DBGPRINT((DBG_SS_CERTMMC, "Roles: 0x%08x\n", *pdwRoles));

            //
            // get a handle to the CA based on the name
            //
            hr = CAFindByName(
                        pszDSName,
                        NULL,
                        CA_FIND_INCLUDE_UNTRUSTED,
                        &pFolder->m_hCAInfo);
            _JumpIfErrorStr(hr, Ret, "CAFindByName", pszDSName);

            // if we made it here then everything is initialized, so add the folder
        }
    }

    // Note - On return, the ID member of 'm_pScopeItem' 
    // contains the handle to the newly inserted item!
    ASSERT(pFolder->m_pScopeItem->ID != NULL);

Ret:
    // undo fix to add folder under all circumstances -- we were
    // inserting a NULL ptr!
    if(fInsertFolder && (NULL != pFolder))
    {
        m_hrCreateFolder = hr;
        m_pScope->InsertItem(pFolder->m_pScopeItem);
    }

    if (stgmediumNodeType.hGlobal)
    {
        GlobalUnlock(stgmediumNodeType.hGlobal);
        ReleaseStgMedium(&stgmediumNodeType);
    }
    if (stgmediumCAType.hGlobal)
    {
        GlobalUnlock(stgmediumCAType.hGlobal);
        ReleaseStgMedium(&stgmediumCAType);
    }
    if (stgmediumCAName.hGlobal)
    {
        GlobalUnlock(stgmediumCAName.hGlobal);
        ReleaseStgMedium(&stgmediumCAName);
    }

    if (stgmediumCARoles.hGlobal)
    {
        GlobalUnlock(stgmediumCARoles.hGlobal);
        ReleaseStgMedium(&stgmediumCARoles);
    }

    if (pszDSName)
        LocalFree(pszDSName);

    return hr;
}

HRESULT CComponentDataImpl::OnSelect(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return E_UNEXPECTED;
}

HRESULT CComponentDataImpl::OnProperties(LPARAM param)
{
    HRESULT hr = S_OK;

    CFolder* pItem = NULL;
    CFolder* pFolder = NULL;
    POSITION pos = 0;

    if (param == NULL)
    {
        goto error;
    }

    ASSERT(param != NULL);
    pFolder = new CFolder();
    if(pFolder == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    // Create a new folder object
    pFolder->Create( reinterpret_cast<LPOLESTR>(param), 0, 0, SCOPE_LEVEL_ITEM, STATIC, FALSE);

    // The static folder in the last item in the list
    pos = m_scopeItemList.GetTailPosition();
    ASSERT(pos);

    // Add it to the internal list
    if (pos)
    {
        pItem = m_scopeItemList.GetAt(pos);
        if(pItem == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto error;
        }
        m_scopeItemList.AddTail(pFolder);

        if((pFolder->m_pScopeItem == NULL) || (pItem->m_pScopeItem == NULL))
        {
            hr = E_POINTER;
            goto error;
        }
        pFolder->m_pScopeItem->relativeID = pItem->m_pScopeItem->relativeID;

        // Set the folder as the cookie
        pFolder->m_pScopeItem->mask |= SDI_PARAM;
        pFolder->m_pScopeItem->lParam = reinterpret_cast<LPARAM>(pFolder);
        pFolder->SetCookie(reinterpret_cast<LONG_PTR>(pFolder));
        m_pScope->InsertItem(pFolder->m_pScopeItem);
        pFolder = NULL;
    }

    ::GlobalFree(reinterpret_cast<void*>(param));

error:

    if(pFolder)
    {
        delete pFolder;
    }
    return hr;
}

void CComponentDataImpl::DeleteList()
{
    POSITION pos = m_scopeItemList.GetHeadPosition();

    while (pos)
        delete m_scopeItemList.GetNext(pos);
    
    m_scopeItemList.RemoveAll();
}

CFolder* CComponentDataImpl::FindObject(MMC_COOKIE cookie)
{
    CFolder* pFolder = NULL;
    POSITION pos = m_scopeItemList.GetHeadPosition();

    while(pos)
    {
        pFolder = m_scopeItemList.GetNext(pos);

        if (*pFolder == cookie)
            return pFolder;
    }

    return NULL;
}

STDMETHODIMP CComponentDataImpl::GetDisplayInfo(SCOPEDATAITEM* pScopeDataItem)
{
    ASSERT(pScopeDataItem != NULL);
    if (pScopeDataItem == NULL)
        return E_POINTER;

    CFolder* pFolder = reinterpret_cast<CFolder*>(pScopeDataItem->lParam);

    
    if (pScopeDataItem->mask & SDI_STR)
    {
        //
        // if this is certtype folder, and it is for the second column, then add usages string
        //
        if (FALSE)//(pFolder->m_hCertType != NULL) && (pScopeDataItem-> == ))
        {

        }
        else
        {
            pScopeDataItem->displayname = pFolder->m_pszName;
        }
    }

    if (pScopeDataItem->mask & SDI_IMAGE)
        pScopeDataItem->nImage = pFolder->m_pScopeItem->nImage;

    if (pScopeDataItem->mask & SDI_OPENIMAGE)
        pScopeDataItem->nOpenImage = pFolder->m_pScopeItem->nOpenImage;


    return S_OK;
}

STDMETHODIMP CComponentDataImpl::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    if (lpDataObjectA == NULL || lpDataObjectB == NULL)
        return E_POINTER;

    // Make sure both data object are mine
    INTERNAL* pA;
    INTERNAL* pB;
    HRESULT hr = S_FALSE;

    pA = ExtractInternalFormat(lpDataObjectA);
    pB = ExtractInternalFormat(lpDataObjectA);

   if (pA != NULL && pB != NULL)
        hr = (*pA == *pB) ? S_OK : S_FALSE;

   if(pA != NULL)
   {
        ::GlobalFree(reinterpret_cast<HANDLE>(pA));
   }

   if(pB != NULL)
   {
        ::GlobalFree(reinterpret_cast<HANDLE>(pB));
   }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation

STDMETHODIMP CComponentDataImpl::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, 
                    LONG_PTR handle, 
                    LPDATAOBJECT lpIDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Look at the data object and determine if this an extension or a primary
    ASSERT(lpIDataObject != NULL);


#if DBG
    CLSID* pCoClassID = ExtractClassID(lpIDataObject);
    if(pCoClassID == NULL)
    {
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }
    // Which page is needed? (determined by which node is active)
    ASSERT(IsEqualCLSID(*pCoClassID, GetCoClassID()));

    FREE_DATA(pCoClassID);
#endif

    PropertyPage* pBasePage;

    INTERNAL* pInternal = ExtractInternalFormat(lpIDataObject);
    if (pInternal == NULL)
    {
        return S_OK;
    }
    ASSERT(pInternal->m_type == CCT_SCOPE);
    ASSERT(pInternal->m_cookie);
                           
    CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);
    ASSERT(pFolder != NULL);
    
    if (pFolder == NULL)
        return E_INVALIDARG;

//     switch (pFolder->m_type) 

    return S_OK;
}

STDMETHODIMP CComponentDataImpl::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Get the node type and see if it's one of mine

    BOOL bResult = FALSE;
    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);
    if (pInternal == NULL)
    {
        return S_OK;
    }  
    ASSERT(pInternal);
    ASSERT(pInternal->m_cookie);

    CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);
    switch(pFolder->m_type)
    {
    case POLICYSETTINGS:
    case SCE_EXTENSION:
        bResult = TRUE;
        break;
    default:
        bResult = FALSE;
        break;
    }
            
    FREE_DATA(pInternal);
    return (bResult) ? S_OK : S_FALSE;
}


///////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu implementation
//
STDMETHODIMP CComponentDataImpl::AddMenuItems(LPDATAOBJECT pDataObject, 
                                    LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                    long *pInsertionAllowed)
{
    HRESULT         hr = S_OK;
    CONTEXTMENUITEM	menuItem;
    CString			szMenu;
    CString			szHint; 

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Note - snap-ins need to look at the data object and determine
    // in what context, menu items need to be added. They must also
    // observe the insertion allowed flags to see what items can be 
    // added.

    if (IsMMCMultiSelectDataObject(pDataObject) == TRUE)
        return S_FALSE;

    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
    if (pInternal == NULL)
    {
        return S_OK;
    }
    CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);
    
    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_NEW)
    {
        ::ZeroMemory (&menuItem, sizeof (menuItem));
	    menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_NEW;
	    menuItem.fFlags = 0;
	    menuItem.fSpecialFlags = 0;

        switch(pFolder->m_type)
        {
        case POLICYSETTINGS:
            VERIFY (szMenu.LoadString (IDS_CERTIFICATE_TYPE));
	        menuItem.strName = (LPTSTR)(LPCTSTR) szMenu;
            VERIFY (szHint.LoadString (IDS_CERTIFICATE_TYPE_HINT));
	        menuItem.strStatusBarText = (LPTSTR)(LPCTSTR) szHint;
	        menuItem.lCommandID = IDM_NEW_CERTTYPE;

            // only CA admins or user with DS write access 
            // can modify CA template list
            if(!(CA_ACCESS_ADMIN & pFolder->GetRoles()) &&
               !g_fCurrentUserHasDSWriteAccess)
                menuItem.fFlags = MFS_GRAYED;

            // bug 462320: for SUB CA, right after installing the CA cert, CA info is unavailable,
            // so there is no way to enable new certs.
            if(!pFolder->m_hCAInfo)
                menuItem.fFlags = MFS_GRAYED;

	        hr = pContextMenuCallback->AddItem (&menuItem);
	        ASSERT (SUCCEEDED (hr));
            break;


        default:
            break;
        }
    }

    if (*pInsertionAllowed & CCM_INSERTIONALLOWED_TOP)
    {
        ::ZeroMemory (&menuItem, sizeof (menuItem));
	    menuItem.lInsertionPointID = CCM_INSERTIONPOINTID_PRIMARY_TOP;
	    menuItem.fFlags = 0;
	    menuItem.fSpecialFlags = 0;

        switch(pFolder->m_type)
        {
        case POLICYSETTINGS:
            VERIFY (szMenu.LoadString (IDS_MANAGETASK));
	        menuItem.strName = (LPTSTR)(LPCTSTR) szMenu;
            VERIFY (szHint.LoadString (IDS_MANAGETASK_HINT));
	        menuItem.strStatusBarText = (LPTSTR)(LPCTSTR) szHint;
	        menuItem.lCommandID = IDM_MANAGE;
	        hr = pContextMenuCallback->AddItem (&menuItem);
	        ASSERT (SUCCEEDED (hr));
            break;
        }
    }

    return hr;
}


STDMETHODIMP CComponentDataImpl::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    // Note - snap-ins need to look at the data object and determine
    // in what context the command is being called.
    DWORD       dwErr;
    HCERTTYPE   hNewCertType;
    HWND        hwndConsole;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    INTERNAL* pi = ExtractInternalFormat(pDataObject);

    if(pi == NULL)
    {
        return E_POINTER;
    }
    ASSERT(pi);
    ASSERT(pi->m_type == CCT_SCOPE);
    CFolder* pFolder = reinterpret_cast<CFolder*>(pi->m_cookie);

        // Handle each of the commands.
    switch (nCommandID)
    {
    case IDM_NEW_CERTTYPE:
    {
        if (pFolder)
        {

            switch(pFolder->m_type)
            {
            case POLICYSETTINGS:
                {
                    // NOMFC
                    CCertTemplateSelectDialog TemplateSelectDialog;
                    TemplateSelectDialog.SetCA(pFolder->m_hCAInfo, m_fAdvancedServer);

                    // if fails, NULL will work
                    HWND hWnd = NULL;
                    m_pConsole->GetMainWindow(&hWnd);

                    DialogBoxParam(
                        g_hInstance,
                        MAKEINTRESOURCE(IDD_SELECT_CERTIFICATE_TEMPLATE),
                        hWnd,
                        SelectCertTemplateDialogProc,
                        (LPARAM)&TemplateSelectDialog);

                    break;
                }
            default:
                break;
            }

        }
            
        m_pConsole->UpdateAllViews(pDataObject, 0, 0);
        break;
    }

    case IDM_MANAGE:
    if (pFolder && pFolder->m_type == POLICYSETTINGS)
    {
        StartCertificateTemplatesSnapin();
    }
    break;
   
    default:
        ASSERT(FALSE); // Unknown command!
        break;
    }

    return S_OK;
}

HRESULT CComponentDataImpl::StartCertificateTemplatesSnapin()
{
    HRESULT hr = S_OK;
    SHELLEXECUTEINFO shi;
    HWND hwnd = NULL;

    m_pConsole->GetMainWindow(&hwnd);

    ZeroMemory(&shi, sizeof(shi));
    shi.cbSize = sizeof(shi);
    shi.hwnd = hwnd;
    shi.lpVerb = SZ_VERB_OPEN;
    shi.lpFile = SZ_CERTTMPL_MSC;
    shi.fMask = SEE_MASK_FLAG_NO_UI;

    if(!ShellExecuteEx(&shi))
    {
        hr = myHLastError();
        _JumpError(hr, error, "ShellExecuteEx");
    }

error:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\compdata.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// Compdata.h : Declaration of the CComponentDataImpl

#ifndef _COMPDATA_H_
#define _COMPDATA_H_

#include "resource.h"       // main symbols



#ifndef __mmc_h__
#include <mmc.h>
#endif

class CFolder; 

// Note - This is the offset in my image list that represents the folder
enum IMAGE_INDEXES
{
    IMGINDEX_FOLDER = 0,
    IMGINDEX_FOLDER_OPEN,
    IMGINDEX_CERTTYPE,
    IMGINDEX_UNKNOWNCERT,
};

// Event Values
#define IDC_STOPSERVER      0x100
#define IDC_STARTSERVER     0x101

#ifdef DBX
  void DbxPrint(LPTSTR pszFmt, ...)
  {
      va_list va;
      va_start (va, pszFmt);
      TCHAR buf[250];
      wsprintf(buf, pszFmt, va);
      OutputDebugString(buf);
      va_end(va);
  }
  //#define DBX_PRINT     DbxPrint
  inline void __DummyTrace(LPTSTR, ...) { }
  #define DBX_PRINT     1 ? (void)0 : ::__DummyTrace
#else
  inline void __DummyTrace(LPTSTR, ...) { }
  #define DBX_PRINT     1 ? (void)0 : ::__DummyTrace
#endif 


#define HTMLHELP_FILENAME L"cs.chm"
#define HTMLHELP_COLLECTION_FILENAME 	L"\\help\\" HTMLHELP_FILENAME 
#define HTMLHELP_COLLECTIONLINK_FILENAME 	L"\\help\\csconcepts.chm"

#define SZ_VERB_OPEN L"open"
#define SZ_CERTTMPL_MSC L"certtmpl.msc"

CONTEXTMENUITEM menuItems[];
CONTEXTMENUITEM viewItems[];

extern bool g_fCurrentUserHasDSWriteAccess;


class CComponentDataImpl:
    public IComponentData,
    public IExtendPropertySheet,
    public IExtendContextMenu,
    public IPersistStream,
    public CComObjectRoot,
    public ISnapinHelp2
{
BEGIN_COM_MAP(CComponentDataImpl)
    COM_INTERFACE_ENTRY(IComponentData)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IExtendContextMenu)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(ISnapinHelp2)
END_COM_MAP()

    friend class CSnapin;
    friend class CDataObject;

    CComponentDataImpl();
    ~CComponentDataImpl();

public:
    virtual const CLSID& GetCoClassID() = 0;
    virtual const BOOL IsPrimaryImpl() = 0;

public:
// ISnapinHelp2 interface members
    STDMETHOD(GetHelpTopic)(LPOLESTR* lpCompiledHelpFile);
    STDMETHOD(GetLinkedTopics)(LPOLESTR* lpCompiledHelpFiles);

// IComponentData interface members
    STDMETHOD(Initialize)(LPUNKNOWN pUnknown);
    STDMETHOD(CreateComponent)(LPCOMPONENT* ppComponent);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)();
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject);
    STDMETHOD(GetDisplayInfo)(SCOPEDATAITEM* pScopeDataItem);       
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider, 
                        LONG_PTR handle, 
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

// IExtendContextMenu 
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown, 
                            long *pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

public:
// IPersistStream interface members
    //STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

#if DBG
    bool m_bInitializedCD;
    bool m_bLoadedCD;
    bool m_bDestroyedCD;
#endif

// Notify handler declarations
private:
    HRESULT OnDelete(MMC_COOKIE cookie);
    HRESULT OnRemoveChildren(LPARAM arg);
    HRESULT OnRename(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnExpand(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnSelect(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnProperties(LPARAM param);

#if DBG==1
public:
    ULONG InternalAddRef()
    {
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Scope item creation helpers
private:
    CFolder* FindObject(MMC_COOKIE cookie); 
    void DeleteList();
    BOOL IsScopePaneNode(LPDATAOBJECT lpDataObject);    

private:
    LPCONSOLENAMESPACE      m_pScope;       // My interface pointer to the scope pane
    LPCONSOLE2               m_pConsole;     // My interface pointer to the console
    HSCOPEITEM              m_pStaticRoot;
    BOOL                    m_bIsDirty;

    void SetDirty(BOOL b = TRUE) { m_bIsDirty = b; }
    void ClearDirty() { m_bIsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_bIsDirty; }

    void AddScopeItemToResultPane(MMC_COOKIE cookie);

    ////////
    // persist
    enum 
    {   // Bit fields for m_dwFlagsPersist
		mskfAllowOverrideMachineName = 0x0001
    };

	DWORD m_dwFlagsPersist;				// General-purpose flags to be persisted into .msc file
	BOOL m_fAllowOverrideMachineName;	// TRUE => Allow the machine name to be overriden by the command line

    void SetPersistentFlags(DWORD dwFlags)
	{
		m_dwFlagsPersist = dwFlags;
		m_fAllowOverrideMachineName = (m_dwFlagsPersist & mskfAllowOverrideMachineName);
	}

	DWORD GetPersistentFlags()
	{
		if (m_fAllowOverrideMachineName)
			m_dwFlagsPersist |= mskfAllowOverrideMachineName;
		else
			m_dwFlagsPersist &= ~mskfAllowOverrideMachineName;
		return m_dwFlagsPersist;
	}
    // end persist
    ///////////////
    HRESULT StartCertificateTemplatesSnapin();

public:
    HRESULT GetCreateFolderHRESULT() { return m_hrCreateFolder; };

private:
    CList<CFolder*, CFolder*> m_scopeItemList; 
    bool m_fAdvancedServer;
    HRESULT m_hrCreateFolder;

#ifdef _DEBUG
    friend class CDataObject;
    int     m_cDataObjects;

#endif
};


class CComponentDataPolicySettings : public CComponentDataImpl,
    public CComCoClass<CComponentDataPolicySettings, &CLSID_CAPolicyExtensionSnapIn>
{
public:
    DECLARE_REGISTRY(CSnapin, _T("Snapin.PolicySettings.1"), _T("Snapin.PolicySettings"), IDS_SNAPIN_DESC, THREADFLAGS_APARTMENT)
    virtual const CLSID & GetCoClassID() { return CLSID_CAPolicyExtensionSnapIn; }
    virtual const BOOL IsPrimaryImpl() { return TRUE; }

    STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
    {
        *pClassID = CLSID_CAPolicyExtensionSnapIn;
        return S_OK;
    }
};

class CComponentDataGPEExtension : public CComponentDataImpl,
    public CComCoClass<CComponentDataGPEExtension, &CLSID_CACertificateTemplateManager>
{
public:
    // reid fix - IDS_SNAPIN_DESC is not right here
    DECLARE_REGISTRY(CSnapin, _T("Snapin.CertTempMgr.1"), _T("Snapin.CertTempMgr"), IDS_SNAPIN_DESC, THREADFLAGS_APARTMENT)
    virtual const CLSID & GetCoClassID() { return CLSID_CACertificateTemplateManager; }
    virtual const BOOL IsPrimaryImpl() { return TRUE; }

    STDMETHOD(GetClassID)(CLSID __RPC_FAR *pClassID)
    {
        *pClassID = CLSID_CACertificateTemplateManager;
        return S_OK;
    }
};

#endif // #define _COMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\xtcb\xtcbpkg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       md5ref.h
//
//  Contents:   XTCB Reference Security Package
//
//  Classes:
//
//  Functions:
//
//  History:    9-20-96   RichardW   Created
//
//----------------------------------------------------------------------------

#ifndef __XTCBREF_H__
#define __XTCBREF_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>
#include <stdio.h>
#include <align.h>

#define SECURITY_PACKAGE
#ifndef SECURITY_WIN32
#define SECURITY_WIN32
#endif
#include <security.h>
#include <secpkg.h>
#include <secint.h>

//
// Useful constants:
//

#define SEED_KEY_SIZE   16


#include "debug.h"
#include "protocol.h"
#include "creds.h"
#include "context.h"
#include "server.h"
#include "userctxt.h"
#include "protos.h"


extern PLSA_SECPKG_FUNCTION_TABLE   LsaTable ;
extern TimeStamp    XtcbNever ;
extern TOKEN_SOURCE XtcbSource ;
extern SECURITY_STRING XtcbComputerName ;
extern SECURITY_STRING XtcbUnicodeDnsName ;
extern SECURITY_STRING XtcbDomainName ;
extern STRING XtcbDnsName ;
extern PSID XtcbMachineSid ;

void InitDebugSupport( void );



typedef struct _XTCB_MACHINE_GROUP_ENTRY {
    PWSTR   MachineName ;
    UCHAR   UniqueKey[ SEED_KEY_SIZE ];
    ULONG   Flags ;
} XTCB_MACHINE_GROUP_ENTRY, * PXTCB_MACHINE_GROUP_ENTRY ;

#define MGROUP_ENTRY_SELF   0x00000001

typedef struct _XTCB_MACHINE_GROUP {
    LIST_ENTRY List ;
    SECURITY_STRING Group;
    UCHAR   SeedKey[ SEED_KEY_SIZE ];
    ULONG   Count ;
    PXTCB_MACHINE_GROUP_ENTRY * GroupList ;
} XTCB_MACHINE_GROUP, * PXTCB_MACHINE_GROUP ;


BOOL
MGroupParseTarget(
    PWSTR TargetSpn,
    PWSTR * MachineName
    );


BOOL
MGroupLocateKeys(
    IN PWSTR Target,
    OUT PSECURITY_STRING * GroupName,
    OUT PUCHAR TargetKey,
    OUT PUCHAR GroupKey,
    OUT PUCHAR MyKey
    );

BOOL
MGroupLocateInboundKey(
    IN PSECURITY_STRING Group,
    IN PSECURITY_STRING Origin,
    OUT PUCHAR TargetKey,
    OUT PUCHAR GroupKey,
    OUT PUCHAR MyKey
    );


BOOL
MGroupReload(
    VOID
    );

BOOL
MGroupInitialize(
    VOID
    );

#endif // __TESTREF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\csnapin.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// CSnapin.h : Declaration of the CSnapin

#ifndef _CSNAPIN_H_
#define _CSNAPIN_H_

#include "resource.h"       // main symbols

#ifndef __mmc_h__
#include <mmc.h>
#endif

using namespace CertSrv;

enum
{
    // Identifiers for each of the commands/views to be inserted into the context menu.
    IDM_COMMAND1,
    IDM_COMMAND2,
    IDM_SAMPLE_OCX_VIEW,
    IDM_SAMPLE_WEB_VIEW
};


template <class TYPE>
TYPE* Extract(LPDATAOBJECT lpDataObject, CLIPFORMAT cf);
BOOL IsMMCMultiSelectDataObject(IDataObject* pDataObject);
CLSID* ExtractClassID(LPDATAOBJECT lpDataObject);
GUID* ExtractNodeType(LPDATAOBJECT lpDataObject);
wchar_t* ExtractWorkstation(LPDATAOBJECT lpDataObject);
INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject);
HRESULT _QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, 
                         CComponentDataImpl* pImpl, LPDATAOBJECT* ppDataObject);
DWORD GetItemType(MMC_COOKIE cookie);


/////////////////////////////////////////////////////////////////////////////
// Snapin

//
// helper methods extracting data from data object
//
INTERNAL *   ExtractInternalFormat(LPDATAOBJECT lpDataObject);
wchar_t *    ExtractWorkstation(LPDATAOBJECT lpDataObject);
GUID *       ExtractNodeType(LPDATAOBJECT lpDataObject);
CLSID *      ExtractClassID(LPDATAOBJECT lpDataObject);





enum CUSTOM_VIEW_ID
{
    VIEW_DEFAULT_LV = 0,
    VIEW_ERROR_OCX = 1,
};

class CSnapin : 
    public IComponent,
    public IExtendContextMenu,   // Step 3
    public IExtendControlbar,
    public IExtendPropertySheet,
    public IResultDataCompare,
    public IPersistStream,
    public CComObjectRoot
{
public:
    CSnapin();
    ~CSnapin();

BEGIN_COM_MAP(CSnapin)
    COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IExtendContextMenu)   // Step 3
    COM_INTERFACE_ENTRY(IExtendControlbar)
    COM_INTERFACE_ENTRY(IExtendPropertySheet)
    COM_INTERFACE_ENTRY(IResultDataCompare)
    COM_INTERFACE_ENTRY(IPersistStream)
END_COM_MAP()

    friend class CDataObject;
    static long lDataObjectRefCount;

// IComponent interface members
public:
    STDMETHOD(Initialize)(LPCONSOLE lpConsole);
    STDMETHOD(Notify)(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);
    STDMETHOD(Destroy)(MMC_COOKIE cookie);
    STDMETHOD(GetResultViewType)(MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions);
    STDMETHOD(QueryDataObject)(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject);

    STDMETHOD(GetDisplayInfo)(RESULTDATAITEM*  pResultDataItem);
    STDMETHOD(CompareObjects)(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB);

// IResultDataCompare
    STDMETHOD(Compare)(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult);

// IExtendControlbar
    STDMETHOD(SetControlbar)(LPCONTROLBAR pControlbar);
    STDMETHOD(ControlbarNotify)(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param);

// IExtendPropertySheet interface
public:
    STDMETHOD(CreatePropertyPages)(LPPROPERTYSHEETCALLBACK lpProvider, 
                        LONG_PTR handle, 
                        LPDATAOBJECT lpIDataObject);
    STDMETHOD(QueryPagesFor)(LPDATAOBJECT lpDataObject);

public:
// IPersistStream interface members
    STDMETHOD(GetClassID)(CLSID *pClassID);
    STDMETHOD(IsDirty)();
    STDMETHOD(Load)(IStream *pStm);
    STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

    // Only for debug purpose
    bool m_bInitializedC;
    bool m_bLoadedC;
    bool m_bDestroyedC;

// Helpers for CSnapin
public:
    void SetIComponentData(CComponentDataImpl* pData);
    void GetItemName(LPDATAOBJECT lpDataObject, LPWSTR pszName, DWORD *pcName);
    BOOL IsPrimaryImpl() 
    {
        CComponentDataImpl* pData = 
            dynamic_cast<CComponentDataImpl*>(m_pComponentData);
        ASSERT(pData != NULL);
        if (pData != NULL)
            return pData->IsPrimaryImpl();

        return FALSE;
    }

#if DBG==1
public:
    int dbg_cRef;
    ULONG InternalAddRef()
    {
        ++dbg_cRef;
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        --dbg_cRef;
        return CComObjectRoot::InternalRelease();
    }
#endif // DBG==1

// Notify event handlers
protected:
    HRESULT OnFolder(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnAddImages(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnDelete(LPDATAOBJECT lpDataObject, LPARAM arg, LPARAM param);
    HRESULT OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param);
    HRESULT OnPropertyChange(LPDATAOBJECT lpDataObject); // Step 3
    HRESULT OnUpdateView(LPDATAOBJECT lpDataObject);
    HRESULT OnResultItemClk(DATA_OBJECT_TYPES type, MMC_COOKIE cookie);
    HRESULT OnContextHelp(LPDATAOBJECT lpDataObject);
    void OnButtonClick(LPDATAOBJECT pdtobj, int idBtn);

    HRESULT QueryMultiSelectDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                                   LPDATAOBJECT* ppDataObject);

// IExtendContextMenu 
public:
    STDMETHOD(AddMenuItems)(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK pCallbackUnknown,
                            long *pInsertionAllowed);
    STDMETHOD(Command)(long nCommandID, LPDATAOBJECT pDataObject);

// End step 3

// Helper functions
protected:
    void Construct();
    void LoadResources();
    HRESULT InitializeHeaders(MMC_COOKIE cookie);

    HRESULT Enumerate(MMC_COOKIE cookie, HSCOPEITEM pParent);
    HRESULT EnumerateResultPane(MMC_COOKIE cookie);

// Result pane helpers
    void RemoveResultItems(MMC_COOKIE cookie);
    void AddUser(CFolder* pFolder);
    void AddExtUser(CFolder* pFolder);
    void AddVirtual();
    HRESULT AddCACertTypesToResults(CFolder* pParentFolder);

    RESULT_DATA* GetVirtualResultItem(int iIndex);

// UI Helpers
    void HandleStandardVerbs(bool bDeselectAll, LPARAM arg, LPDATAOBJECT lpDataObject);
    void HandleExtToolbars(bool bDeselectAll, LPARAM arg, LPARAM param);
	void HandleExtMenus(LPARAM arg, LPARAM param);
    void _OnRefresh(LPDATAOBJECT pDataObject);

    CFolder* GetVirtualFolder();
    CFolder* GetParentFolder(INTERNAL* pInternal);

// Interface pointers
protected:
    LPCONSOLE2           m_pConsole;         // Console's IFrame interface
    LPHEADERCTRL        m_pHeader;          // Result pane's header control interface
    LPCOMPONENTDATA     m_pComponentData;   
    LPRESULTDATA        m_pResult;          // My interface pointer to the result pane
    LPIMAGELIST         m_pImageResult;     // My interface pointer to the result pane image list

    LPCONTROLBAR        m_pControlbar;      // control bar to hold my tool bars
    LPCONSOLEVERB       m_pConsoleVerb;     // pointer the console verb

#ifdef INSERT_DEBUG_FOLDERS
    LPMENUBUTTON        m_pMenuButton1;     // Menu Button for view
#endif // INSERT_DEBUG_FOLDERS

    LPTOOLBAR           m_pSvrMgrToolbar1;    // Toolbar for view
    CBitmap*            m_pbmpSvrMgrToolbar1; // Imagelist for the toolbar

    CFolder*            m_pCurrentlySelectedScopeFolder;    // keep track of who has focus

private:
    BOOL                m_bIsDirty;
    CUSTOM_VIEW_ID      m_CustomViewID;
    BOOL                m_bVirtualView;
    DWORD               m_dwVirtualSortOptions; 
    
    void SetDirty(BOOL b = TRUE) { m_bIsDirty = b; }
    void ClearDirty() { m_bIsDirty = FALSE; }
    BOOL ThisIsDirty() { return m_bIsDirty; }
};

inline void CSnapin::SetIComponentData(CComponentDataImpl* pData)
{
    ASSERT(pData);
    ASSERT(m_pComponentData == NULL);
    LPUNKNOWN pUnk = pData->GetUnknown();
    HRESULT hr;
    
    hr = pUnk->QueryInterface(IID_IComponentData, reinterpret_cast<void**>(&m_pComponentData));

    ASSERT(hr == S_OK);
}

class CCertTypeAboutImpl : 
    public ISnapinAbout,
    public CComObjectRoot,
    public CComCoClass<CCertTypeAboutImpl, &CLSID_CertTypeAbout>
{
public:
    CCertTypeAboutImpl();
    ~CCertTypeAboutImpl();

public:
DECLARE_REGISTRY(CSnapin, _T("Snapin.PolicySettingsAbout.1"), _T("Snapin.PolicySettingsAbout"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

BEGIN_COM_MAP(CCertTypeAboutImpl)
    COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()

public:
    STDMETHOD(GetSnapinDescription)(LPOLESTR* lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR* lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR* lpVersion);
    STDMETHOD(GetSnapinImage)(HICON* hAppIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP* hSmallImage, 
                                    HBITMAP* hSmallImageOpen, 
                                    HBITMAP* hLargeImage, 
                                    COLORREF* cLargeMask);

// Internal functions
private:
    HRESULT AboutHelper(UINT nID, LPOLESTR* lpPtr);
    HRESULT AboutHelper2(LPSTR str, LPOLESTR* lpPtr);
};

class CCAPolicyAboutImpl : 
    public ISnapinAbout,
    public CComObjectRoot,
    public CComCoClass<CCAPolicyAboutImpl, &CLSID_CAPolicyAbout>
{
public:
    CCAPolicyAboutImpl();
    ~CCAPolicyAboutImpl();

public:
DECLARE_REGISTRY(CSnapin, _T("Snapin.PolicySettingsAbout.1"), _T("Snapin.PolicySettingsAbout"), IDS_SNAPIN_DESC, THREADFLAGS_BOTH)

BEGIN_COM_MAP(CCAPolicyAboutImpl)
    COM_INTERFACE_ENTRY(ISnapinAbout)
END_COM_MAP()

public:
    STDMETHOD(GetSnapinDescription)(LPOLESTR* lpDescription);
    STDMETHOD(GetProvider)(LPOLESTR* lpName);
    STDMETHOD(GetSnapinVersion)(LPOLESTR* lpVersion);
    STDMETHOD(GetSnapinImage)(HICON* hAppIcon);
    STDMETHOD(GetStaticFolderImage)(HBITMAP* hSmallImage, 
                                    HBITMAP* hSmallImageOpen, 
                                    HBITMAP* hLargeImage, 
                                    COLORREF* cLargeMask);

// Internal functions
private:
    HRESULT AboutHelper(UINT nID, LPOLESTR* lpPtr);
    HRESULT AboutHelper2(LPSTR str, LPOLESTR* lpPtr);
};


#define FREE_DATA(pData) \
    ASSERT(pData != NULL); \
    do { if (pData != NULL) \
        GlobalFree(pData); } \
    while(0); 
    

#endif // #define _CSNAPIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\ctshlext.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    ctextshl.h

Abstract:
    This is the header for the Cert Type shell extension object.

Author:

    petesk 27-aug-98

Environment:
	
	 NT only.
--*/


#ifndef __CTSHLEXT_H_
#define __CTSHLEXT_H_


#include <shlobj.h>

/////////////////////////////////////////////////////////////////////////////
// CDfsShell
class ATL_NO_VTABLE CCertTypeShlExt : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCertTypeShlExt, &CLSID_CertTypeShellExt>,
	public IShellExtInit,
	public IShellPropSheetExt,
    public IContextMenu
{
public:
	CCertTypeShlExt()
	{
	}

	~CCertTypeShlExt()
	{	
	}

    //Simple ALL 1.0 based registry entry
    DECLARE_REGISTRY(   CCertTypeShlExt,
                        _T("CAPESNPN.CCTShellExt.1"),
                        _T("CAPESNPN.CCTShellExt"),
                        IDS_CCTSHELLEXT_DESC,
                        THREADFLAGS_APARTMENT)

BEGIN_COM_MAP(CCertTypeShlExt)
	COM_INTERFACE_ENTRY(IShellExtInit)
	COM_INTERFACE_ENTRY(IShellPropSheetExt)
	COM_INTERFACE_ENTRY(IContextMenu)
END_COM_MAP()

// IDfsShell
public:


// IShellExtInit Methods

	STDMETHOD (Initialize)
	(
		IN LPCITEMIDLIST	pidlFolder,		// Points to an ITEMIDLIST structure
		IN LPDATAOBJECT	lpdobj,			// Points to an IDataObject interface
		IN HKEY			hkeyProgID		// Registry key for the file object or folder type
	);	

    //IShellPropSheetExt methods
    STDMETHODIMP AddPages
	(
		IN LPFNADDPROPSHEETPAGE lpfnAddPage, 
		IN LPARAM lParam
	);
    
    STDMETHODIMP ReplacePage
	(
		IN UINT uPageID, 
		IN LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
		IN LPARAM lParam
	);

    // IContextMenu methods
    STDMETHODIMP GetCommandString
    (    
        UINT_PTR idCmd,    
        UINT uFlags,    
        UINT *pwReserved,
        LPSTR pszName,    
        UINT cchMax   
    );

    STDMETHODIMP InvokeCommand
    (    
        LPCMINVOKECOMMANDINFO lpici   
    );	



    STDMETHODIMP QueryContextMenu
    (
        HMENU hmenu,
        UINT indexMenu,
        UINT idCmdFirst,
        UINT idCmdLast,
        UINT uFlags
    );


};

#endif //__CTSHLEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\ctshlext.cpp ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

DfsShell.cpp

Abstract:
	This is the implementation file for Dfs Shell Extension object which implements
	IShellIExtInit and IShellPropSheetExt.

Author:

    Constancio Fernandes (ferns@qspl.stpp.soft.net) 12-Jan-1998

Environment:
	
	 NT only.
*/
    
#include "stdafx.h"
#include "ctshlext.h"	
#include "genpage.h"

/*----------------------------------------------------------------------
					IShellExtInit Implementation.
------------------------------------------------------------------------*/

STDMETHODIMP CCertTypeShlExt::Initialize
(
	IN LPCITEMIDLIST	pidlFolder,		// Points to an ITEMIDLIST structure
	IN LPDATAOBJECT	    pDataObj,		// Points to an IDataObject interface
	IN HKEY			    hkeyProgID		// Registry key for the file object or folder type
)
{
CString cstrFullText, cstrTitle;
cstrTitle.LoadString(IDS_POLICYSETTINGS);
cstrFullText.LoadString(IDS_ERROR_WIN2000_AD_LAUNCH_NOT_SUPPORTED);
::MessageBoxW(NULL, cstrFullText, cstrTitle, MB_OK | MB_ICONINFORMATION);

return S_OK;
}


STDMETHODIMP CCertTypeShlExt::AddPages
(
	IN LPFNADDPROPSHEETPAGE lpfnAddPage, 
	IN LPARAM lParam
)

{
    return S_OK;                                                            
}


STDMETHODIMP CCertTypeShlExt::ReplacePage
(
	IN UINT uPageID, 
    IN LPFNADDPROPSHEETPAGE lpfnReplaceWith, 
    IN LPARAM lParam
)
{
    return E_FAIL;
}


// IContextMenu methods
STDMETHODIMP CCertTypeShlExt::GetCommandString
(    
    UINT_PTR idCmd,    
    UINT uFlags,    
    UINT *pwReserved,
    LPSTR pszName,    
    UINT cchMax   
)
{
    return E_NOTIMPL;
}


STDMETHODIMP CCertTypeShlExt::InvokeCommand
(    
    LPCMINVOKECOMMANDINFO lpici   
)
{
    return E_NOTIMPL;
}



STDMETHODIMP CCertTypeShlExt::QueryContextMenu
(
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags
)
{
return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\dataobj.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _DATAOBJ_H
#define _DATAOBJ_H

typedef CArray<MMC_COOKIE, MMC_COOKIE> CCookiePtrArray;


class CDataObject : public IDataObject, public CComObjectRoot

{
    friend class CSnapin;

// ATL Maps
DECLARE_NOT_AGGREGATABLE(CDataObject)
BEGIN_COM_MAP(CDataObject)
	COM_INTERFACE_ENTRY(IDataObject)
END_COM_MAP()


// Construction/Destruction
    CDataObject();
    ~CDataObject() {}

// Clipboard formats that are required by the console
public:
    static unsigned int    m_cfNodeType;        // Required by the console
    static unsigned int    m_cfNodeTypeString;  // Required by the console
    static unsigned int    m_cfDisplayName;     // Required by the console
    static unsigned int    m_cfCoClass;         // Required by the console
    static unsigned int    m_cfIsMultiSel;        // Required by the console

    static unsigned int    m_cfInternal;        // Step 3
	static unsigned int	   m_cfWorkstation;     // Published information

// Standard IDataObject methods
public:
// Implemented
    STDMETHOD(GetData)(LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium);
    STDMETHOD(GetDataHere)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium);
    STDMETHOD(EnumFormatEtc)(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc);

    ULONG InternalAddRef()
    {
        return CComObjectRoot::InternalAddRef();
    }
    ULONG InternalRelease()
    {
        return CComObjectRoot::InternalRelease();
    }

// Not Implemented
private:
    STDMETHOD(QueryGetData)(LPFORMATETC lpFormatetc);

    STDMETHOD(GetCanonicalFormatEtc)(LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };

    STDMETHOD(SetData)(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };

    STDMETHOD(DAdvise)(LPFORMATETC lpFormatetc, DWORD advf,
                LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHOD(DUnadvise)(DWORD dwConnection)
    { return E_NOTIMPL; };

    STDMETHOD(EnumDAdvise)(LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };

// Implementation
public:
    void SetType(DATA_OBJECT_TYPES type) // Step 3
    { ASSERT(m_internal.m_type == CCT_UNINITIALIZED); m_internal.m_type = type; }

public:
    void SetCookie(MMC_COOKIE cookie) { m_internal.m_cookie = cookie; } // Step 3
    void SetString(LPTSTR lpString) { m_internal.m_string = lpString; }
    void SetClsid(const CLSID& clsid) { m_internal.m_clsid = clsid; }

    void SetMultiSelData(SMMCObjectTypes* psGuidObjTypes, UINT cbMultiSelData)
    {
        // make sure [1] still good enough
        ASSERT(cbMultiSelData == sizeof(m_sGuidObjTypes));
        if (cbMultiSelData == sizeof(m_sGuidObjTypes))
        {
            m_cbMultiSelData = cbMultiSelData;
            CopyMemory(&m_sGuidObjTypes, psGuidObjTypes, cbMultiSelData);
        }
    }

    ULONG AddCookie(MMC_COOKIE Cookie);


    ULONG QueryCookieCount(VOID)
    {
        return m_rgCookies.GetSize();
    }

    STDMETHODIMP GetCookieAt(ULONG iCookie, MMC_COOKIE *pCookie);
    
    STDMETHODIMP RemoveCookieAt(ULONG iCookie);

    void SetMultiSelDobj()
    {
        m_bMultiSelDobj = TRUE;
    }

#ifdef _DEBUG
    UINT dbg_refCount;
 

    void AddRefMultiSelDobj()
    {
        ASSERT(m_bMultiSelDobj == TRUE);
        ++dbg_refCount;
    }

    void ReleaseMultiSelDobj()
    {
        ASSERT(m_bMultiSelDobj == TRUE);
        --dbg_refCount;
        //if (dbg_refCount == 0)
        //    ::MessageBox(NULL, _T("Final release on multi-sel-dobj"), _T("Sample snapin"), MB_OK);
    }
#endif

private:
    HRESULT CreateNodeTypeData(LPSTGMEDIUM lpMedium);
    HRESULT CreateNodeTypeStringData(LPSTGMEDIUM lpMedium);
    HRESULT CreateDisplayName(LPSTGMEDIUM lpMedium);
    HRESULT CreateInternal(LPSTGMEDIUM lpMedium); // Step 3
    HRESULT CreateWorkstationName(LPSTGMEDIUM lpMedium);
    HRESULT CreateCoClassID(LPSTGMEDIUM lpMedium);
    HRESULT CreateMultiSelData(LPSTGMEDIUM lpMedium);

    HRESULT Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);
    HRESULT CreateVariableLen(const void* pBuffer, int len, LPSTGMEDIUM lpMedium);


    INTERNAL        m_internal;    // Step 3

    SMMCObjectTypes m_sGuidObjTypes; // length[1] good enough for now
    UINT            m_cbMultiSelData;
    BOOL            m_bMultiSelDobj;

    CCookiePtrArray m_rgCookies;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\events.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"

#define __dwFILE__	__dwFILE_CAPESNPN_EVENTS_CPP__


/////////////////////////////////////////////////////////////////////////////
// Event handlers for IFrame::Notify

HRESULT CSnapin::OnFolder(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    ASSERT(FALSE);

    return S_OK;
}

HRESULT CSnapin::OnAddImages(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    if (arg == 0)
        return E_INVALIDARG;
    
    // if cookie is from a different snapin
    // if (IsMyCookie(cookie) == FALSE)
    if (0)
    {
        // add the images for the scope tree only
        ::CBitmap bmp16x16;
        ::CBitmap bmp32x32;
        LPIMAGELIST lpImageList = reinterpret_cast<LPIMAGELIST>(arg);
    
        // Load the bitmaps from the dll
        bmp16x16.LoadBitmap(IDB_16x16);
        bmp32x32.LoadBitmap(IDB_32x32);
    
        // Set the images
        lpImageList->ImageListSetStrip(
                        reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
                        reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp32x32)),
                        0, RGB(255, 0, 255));
    
        lpImageList->Release();
    }
    else 
    {
        ASSERT(m_pImageResult != NULL);

        ::CBitmap bmp16x16;
        ::CBitmap bmp32x32;

        // Load the bitmaps from the dll
        bmp16x16.LoadBitmap(IDB_16x16);
        bmp32x32.LoadBitmap(IDB_32x32);

        // Set the images
        m_pImageResult->ImageListSetStrip(reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp16x16)),
                          reinterpret_cast<LONG_PTR*>(static_cast<HBITMAP>(bmp32x32)),
                           0, RGB(255, 0, 255));
    }
    return S_OK;
}

typedef IMessageView *LPMESSAGEVIEW;

HRESULT CSnapin::OnShow(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    CComponentDataImpl* pComp = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    CFolder* pFolder = pComp->FindObject(cookie);

    if ((cookie == NULL) || (pFolder == NULL))
    {
        return S_OK;
    }

    // Note - arg is TRUE when it is time to enumerate
    if (arg == TRUE)
    {
        m_pCurrentlySelectedScopeFolder = pFolder;

        // if list view on display
        if (m_CustomViewID == VIEW_DEFAULT_LV)
        {
            // Show the headers for this nodetype
            if (S_OK != InitializeHeaders(cookie))
            {
                // UNDONE: add informative "server down" result object
                goto done;
            }

            return Enumerate(cookie, param);
        }
		else if (m_CustomViewID == VIEW_ERROR_OCX)
		{
			HRESULT hr; 
                        CString strMessage;
                        strMessage.LoadString(IDS_ERROR_CANNOT_LOAD_TEMPLATES);

			LPUNKNOWN pUnk = NULL;
			LPMESSAGEVIEW pMessageView = NULL;

			hr = m_pConsole->QueryResultView(&pUnk);
			_JumpIfError(hr, done, "QueryResultView IUnk");

			hr = pUnk->QueryInterface(IID_IMessageView, reinterpret_cast<void**>(&pMessageView));
			_JumpIfError(hr, done, "IID_IMessageView");

			pMessageView->SetIcon(Icon_Error);

                        CAutoLPWSTR pwszErrorCode = BuildErrorMessage(pComp->GetCreateFolderHRESULT());

			pMessageView->SetTitleText(strMessage);
			pMessageView->SetBodyText(pwszErrorCode);
			
			pUnk->Release();
			pMessageView->Release();
		}

    }
    else
    {
        m_pCurrentlySelectedScopeFolder = NULL;

        // if list view is on display
        if (m_CustomViewID == VIEW_DEFAULT_LV)
        {
            RemoveResultItems(cookie);
        }

        // Free data associated with the result pane items, because
        // your node is no longer being displayed.
        // Note: The console will remove the items from the result pane

    }

done:

    return S_OK;
}

HRESULT CSnapin::OnDelete(LPDATAOBJECT pDataObject, LPARAM arg, LPARAM param)
{
    HRESULT     hr;
    WCHAR **    aszCertTypesCurrentlySupported;
    WCHAR **    aszNewCertTypesSupported;
    WCHAR **    aszNameOfDeleteType;
    HRESULTITEM	itemID;
    HWND        hwndConsole;
    CTemplateList TemplateList;

    CString cstrMsg, cstrTitle;
    cstrMsg.LoadString(IDS_ASK_CONFIRM_DELETETEMPLATES);
    cstrTitle.LoadString(IDS_TITLE_ASK_CONFIRM_DELETETEMPLATES);
    HWND hwndMain = NULL;

    m_pConsole->GetMainWindow(&hwndMain);

    if (IDYES != MessageBox(
                    hwndMain, 
                    (LPCWSTR)cstrMsg, 
                    (LPCWSTR)cstrTitle, 
                    MB_YESNO))
        return ERROR_CANCELLED;

    CWaitCursor hourglass;
    
    ASSERT(m_pResult != NULL); // make sure we QI'ed for the interface
    ASSERT(m_pComponentData != NULL);

    if(!IsMMCMultiSelectDataObject(pDataObject)) 
    {
        INTERNAL * pInternal = ExtractInternalFormat(pDataObject);
    
        if ((pInternal == NULL) ||
            (pInternal->m_cookie == NULL))
        {
            //ASSERT(FALSE);
            return S_OK;
        }

        CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);

        hr = myRetrieveCATemplateList(pFolder->m_hCAInfo, FALSE, TemplateList);
        if (FAILED(hr))
        {
            m_pConsole->GetMainWindow(&hwndConsole);
            MyErrorBox(hwndConsole, IDS_CERTTYPE_INFO_FAIL ,IDS_SNAPIN_NAME, hr);
            return hr;
        }

        ASSERT(pFolder != NULL);
        ASSERT(pFolder->m_hCertType != NULL);

        FOLDER_TYPES type = pFolder->GetType();

        if(type == CA_CERT_TYPE)
        {
            hr = myRemoveFromCATemplateList(
                pFolder->m_hCAInfo,
                TemplateList,
                pFolder->m_hCertType);

            if (FAILED(hr))
            {
                m_pConsole->GetMainWindow(&hwndConsole);
                MyErrorBox(hwndConsole, IDS_CERTTYPE_INFO_FAIL ,IDS_SNAPIN_NAME, hr);
                return hr;
            }

            m_pConsole->GetMainWindow(&hwndConsole);

            hr = UpdateCATemplateList(
                    hwndConsole,
                    pFolder->m_hCAInfo,
                    TemplateList);

            if (S_OK!=hr)
            {
                if ((HRESULT) ERROR_CANCELLED != hr)
                {
                    MyErrorBox(hwndConsole, IDS_DELETE_ERROR ,IDS_SNAPIN_NAME, hr);
                }
                else
                {
                    // user canceled removing it, add it back
                    hr = myAddToCATemplateList(
                        pFolder->m_hCAInfo,
                        TemplateList,
                        pFolder->m_hCertType,
			FALSE);
                    _PrintIfError(hr, "myAddToCATemplatelist");

                }
                return hr;
            }
    
	        hr = m_pResult->FindItemByLParam ((LPARAM)pFolder, &itemID);
            hr = m_pResult->DeleteItem (itemID, 0);

            delete(pFolder);
        }
    }
    else
    {
		// Is multiple select, get all selected items and paste each one
        MMC_COOKIE currentCookie = NULL;
        HCAINFO hCAInfo = NULL;

        CDataObject* pDO = dynamic_cast <CDataObject*>(pDataObject);
        ASSERT (pDO);
        if ( pDO )
        {
            INT i;
            bool fTemplateListRetrieved = false;

            for(i=pDO->QueryCookieCount()-1; i >= 0; i--)
            {

                hr = pDO->GetCookieAt(i, &currentCookie);
                if(hr != S_OK)
                {
                    return hr;
                }

                CFolder* pFolder = reinterpret_cast<CFolder*>(currentCookie);

                if(!fTemplateListRetrieved)
                {
                    hr = myRetrieveCATemplateList(
					pFolder->m_hCAInfo,
					FALSE,
					TemplateList);
                    if (FAILED(hr))
                    {
                        m_pConsole->GetMainWindow(&hwndConsole);
                        MyErrorBox(hwndConsole, IDS_CERTTYPE_INFO_FAIL ,IDS_SNAPIN_NAME, hr);
                        return hr;
                    }
                    fTemplateListRetrieved = true;
                }

                ASSERT(pFolder != NULL);
                ASSERT(pFolder->m_hCertType != NULL);

                FOLDER_TYPES type = pFolder->GetType();

                if(type == CA_CERT_TYPE)
                {
                    if(hCAInfo == NULL)
                    {
                        // Grab the CA this type belongs to.
                        hCAInfo = pFolder->m_hCAInfo;
                    }

                    hr = myRemoveFromCATemplateList(
                        hCAInfo,
                        TemplateList,
                        pFolder->m_hCertType);

                    if (FAILED(hr))
                    {
                        m_pConsole->GetMainWindow(&hwndConsole);
                        MyErrorBox(hwndConsole, IDS_CERTTYPE_INFO_FAIL ,IDS_SNAPIN_NAME, hr);
                        return hr;
                    }
                }
            }

            if(hCAInfo)
            {
                m_pConsole->GetMainWindow(&hwndConsole);

                hr = UpdateCATemplateList(
                        hwndConsole,
                        hCAInfo,
                        TemplateList);

                if (S_OK != hr)
                {
                    if ((HRESULT) ERROR_CANCELLED != hr)
                    {
                        MyErrorBox(hwndConsole, IDS_DELETE_ERROR ,IDS_SNAPIN_NAME, hr);
                    }
                    else
                    {
                        // user canceled, add the templates back
                        for(i=pDO->QueryCookieCount()-1; i >= 0; i--)
                        {
                            hr = pDO->GetCookieAt(i, &currentCookie);
                            if(hr != S_OK)
                            {
                                return hr;
                            }

                            CFolder* pFolder = reinterpret_cast<CFolder*>(currentCookie);
                            FOLDER_TYPES type = pFolder->GetType();

                            if(type == CA_CERT_TYPE)
                            {
                                hr = myAddToCATemplateList(
                                    hCAInfo,
                                    TemplateList,
                                    pFolder->m_hCertType,
				    FALSE);
                                _PrintIfError(hr, "myAddToCATemplateList");
                                if(S_OK != hr)
                                {
                                    return hr;
                                }
                            }
                        }
                    }
                }
                else
                {
                    for(i=pDO->QueryCookieCount()-1; i >= 0; i--)
                    {

                        hr = pDO->GetCookieAt(i, &currentCookie);
                        if(hr != S_OK)
                        {
                            return hr;
                        }

                        CFolder* pFolder = reinterpret_cast<CFolder*>(currentCookie);
                        FOLDER_TYPES type = pFolder->GetType();

                        if(type == CA_CERT_TYPE)
                        {
                            hr = m_pResult->FindItemByLParam ((LPARAM)pFolder, &itemID);
                            if(hr != S_OK)
                            {
                                return hr;
                            }

                            // We must delete the actual CFolder backing this item if we do this
                            // or we leak.
                            hr = m_pResult->DeleteItem (itemID, 0);
                            if(hr != S_OK)
                            {
                                return hr;
                            }

                            hr = pDO->RemoveCookieAt(i);
                            if(hr != S_OK)
                            {
                                return hr;
                            }

                            // Note, since this is a type folder, the CAInfo will not be closed on delete
                            delete pFolder;
                        }
                    }
                }
            }
        }
    }
    
    return S_OK;
}

HRESULT CSnapin::OnActivate(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return S_OK;
}

HRESULT CSnapin::OnResultItemClk(DATA_OBJECT_TYPES type, MMC_COOKIE cookie)
{
    RESULT_DATA* pResult;
    DWORD* pdw = reinterpret_cast<DWORD*>(cookie);
    if (*pdw == RESULT_ITEM)
    {
        pResult = reinterpret_cast<RESULT_DATA*>(cookie);
    }

    return S_OK;
}

HRESULT CSnapin::OnMinimize(MMC_COOKIE cookie, LPARAM arg, LPARAM param)
{
    return S_OK;
}

HRESULT CSnapin::OnPropertyChange(LPDATAOBJECT lpDataObject)
{
    return S_OK;
}

HRESULT CSnapin::Enumerate(MMC_COOKIE cookie, HSCOPEITEM pParent)
{
    return EnumerateResultPane(cookie);
}

HRESULT CSnapin::EnumerateResultPane(MMC_COOKIE cookie)
{
    ASSERT(m_pResult != NULL); // make sure we QI'ed for the interface
    ASSERT(m_pComponentData != NULL);

    // don't bother enumerating base
    if (cookie == NULL)
        return S_FALSE;

    // Our static folders must be displayed in the result pane
    // by use because the console doesn't do it.
    CFolder* pFolder = dynamic_cast<CComponentDataImpl*>(m_pComponentData)->FindObject(cookie);

    // The dynamic folder must be in our list
    ASSERT(pFolder != NULL);

    FOLDER_TYPES type = pFolder->GetType();

    switch(type)
    {
    case STATIC:
        break;

    case POLICYSETTINGS:
        return AddCACertTypesToResults(pFolder);
        break;
    default:
        break;
    }

    return S_FALSE;
}

void CSnapin::RemoveResultItems(MMC_COOKIE cookie)
{
    if (cookie == NULL)
        return;

    // Our static folders must be displayed in the result pane
    // by use because the console doesn't do it.
    CFolder* pFolder = dynamic_cast<CComponentDataImpl*>(m_pComponentData)->FindObject(cookie);

    // The dynamic folder must be in our list
    ASSERT(pFolder != NULL);

    FOLDER_TYPES type = pFolder->GetType();

    RESULTDATAITEM resultItem;
    ZeroMemory(&resultItem, sizeof(RESULTDATAITEM));
    
    // look for first rdi by index
    resultItem.mask = RDI_INDEX | RDI_PARAM;    // fill in index & param
    resultItem.nIndex = 0;

    switch (type)
    {
    case POLICYSETTINGS:
    case SCE_EXTENSION:
        while (S_OK == m_pResult->GetItem(&resultItem))
        {
            CFolder* pResult = reinterpret_cast<CFolder*>(resultItem.lParam);
            resultItem.lParam = NULL;

            delete pResult;
            
            // next item
            resultItem.nIndex++;
        }
        break;
    default:
        break;
    }

    return;
}

HRESULT CSnapin::AddCACertTypesToResults(CFolder* pFolder)
{
    HRESULT     hr = S_OK;
    CFolder     *pNewFolder;
    WCHAR **    aszCertTypeName;
    HWND        hwndConsole;
    BOOL        fMachine = FALSE;
    CTemplateList CATemplateList;
    CTemplateListEnum CATemplateListEnum(CATemplateList);
    CTemplateInfo *pTemplateInfo;
    HCERTTYPE hCertType;
    bool fNoCacheLookup = true;
    CWaitCursor WaitCursor;
    
    m_pConsole->GetMainWindow(&hwndConsole);    

    hr = myRetrieveCATemplateList(pFolder->m_hCAInfo, FALSE, CATemplateList);
    if(FAILED(hr)) 
    {
		m_CustomViewID = VIEW_ERROR_OCX; // change the view type
		m_pConsole->SelectScopeItem(m_pCurrentlySelectedScopeFolder->m_pScopeItem->ID); // select this node again

		// done, let's bail and let the error page do its job
		return S_OK;
    }

    CATemplateListEnum.Reset();

    for(pTemplateInfo=CATemplateListEnum.Next();
        pTemplateInfo;
        pTemplateInfo=CATemplateListEnum.Next())
    {
        CString strCert;
        hCertType = pTemplateInfo->GetCertType();

        if(!hCertType)
        {
            CSASSERT(pTemplateInfo->GetName());
            hr = CAFindCertTypeByName(
                    pTemplateInfo->GetName(), 
                    NULL, 
                    CT_ENUM_MACHINE_TYPES |
                    CT_ENUM_USER_TYPES |
                    (fNoCacheLookup?CT_FLAG_NO_CACHE_LOOKUP:0),
                    &hCertType);
            
            fNoCacheLookup = false;
            if(FAILED(hr))
            {
                // continue on errors
                strCert = pTemplateInfo->GetName()?
                    pTemplateInfo->GetName():pTemplateInfo->GetOID();
            }
        }

        if(hCertType)
        {
            hr = CAGetCertTypeProperty(
                        hCertType,
                        CERTTYPE_PROP_FRIENDLY_NAME,
                        &aszCertTypeName);

            if (FAILED(hr) || (aszCertTypeName == NULL))
            {
                strCert = pTemplateInfo->GetName()?
                    pTemplateInfo->GetName():pTemplateInfo->GetOID();
            }
            else
            {
                strCert = aszCertTypeName[0];
            }
        }

        pNewFolder = new CFolder();
        _JumpIfAllocFailed(pNewFolder, error);

        if(strCert.IsEmpty())
            strCert.LoadString(IDS_UNKNOWN);

        pNewFolder->Create(
                strCert, 
                IMGINDEX_CERTTYPE, 
                IMGINDEX_CERTTYPE,
                RESULT_ITEM, 
                CA_CERT_TYPE, 
                FALSE);

        pNewFolder->m_dwRoles = pFolder->GetRoles();

        if(aszCertTypeName)
        {
            CAFreeCertTypeProperty(
                    hCertType,
                    aszCertTypeName);
        }

        //
        // get the key usage string
        // 
        if(hCertType)
        {
            GetIntendedUsagesString(hCertType, &(pNewFolder->m_szIntendedUsages));
            if (pNewFolder->m_szIntendedUsages == L"")
            {
                pNewFolder->m_szIntendedUsages.LoadString(IDS_ALL);
            }
            pNewFolder->m_hCAInfo = pFolder->m_hCAInfo;
        }
        else
        {
            pNewFolder->m_szIntendedUsages.LoadString(IDS_UNKNOWN);
            pNewFolder->m_hCAInfo = NULL;
        }

        pNewFolder->m_hCertType = hCertType;


        RESULTDATAITEM resultItem;
        ZeroMemory(&resultItem, sizeof(RESULTDATAITEM));
        resultItem.mask = RDI_STR | RDI_IMAGE | RDI_PARAM;
        resultItem.bScopeItem = FALSE;
        resultItem.itemID = (LONG_PTR) pNewFolder;
        resultItem.str = MMC_CALLBACK;
        resultItem.nImage = hCertType?IMGINDEX_CERTTYPE:IMGINDEX_UNKNOWNCERT;
        resultItem.lParam = reinterpret_cast<LPARAM>(pNewFolder);
        
        // add to result pane
        resultItem.nCol = 0;
        hr = m_pResult->InsertItem(&resultItem);
        _JumpIfError(hr, error, "InsertItem");
    }


error:

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\csnapin.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
#include <userenv.h>
#include "genpage.h"
#include <winldap.h>
#include "csldap.h"

#define __dwFILE__	__dwFILE_CAPESNPN_CSNAPIN_CPP__

bool g_fCurrentUserHasDSWriteAccess = false;
bool g_fCurrentUserHasDSWriteAccessTested = false;


static MMCBUTTON SvrMgrToolbar1Buttons[] =
{
    { 0, IDC_STARTSERVER, TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Start", L"Start this service" },
    { 1, IDC_STOPSERVER,  TBSTATE_ENABLED, TBSTYLE_BUTTON, L"Stop",  L"Stop this service" },
};

static int n_count = 0;

//
// Extracts the coclass guid format from the data object
//
template <class TYPE>
TYPE* Extract(LPDATAOBJECT lpDataObject, unsigned int cf)
{
    ASSERT(lpDataObject != NULL);

    TYPE* p = NULL;

    STGMEDIUM stgmedium = { TYMED_HGLOBAL, NULL };
    FORMATETC formatetc = { (CLIPFORMAT)cf, NULL,
                            DVASPECT_CONTENT, -1, TYMED_HGLOBAL
                          };

    // Allocate memory for the stream
    int len = (int)((cf == CDataObject::m_cfWorkstation) ?
        ((MAX_COMPUTERNAME_LENGTH+1) * sizeof(TYPE)) : sizeof(TYPE));

    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, len);

    // Get the workstation name from the data object
    do
    {
        if (stgmedium.hGlobal == NULL)
            break;

        if (FAILED(lpDataObject->GetDataHere(&formatetc, &stgmedium)))
        {
            GlobalFree(stgmedium.hGlobal);
            break;
        }

        p = reinterpret_cast<TYPE*>(stgmedium.hGlobal);

        if (p == NULL)
            break;


    } while (FALSE);

    return p;
}

BOOL IsMMCMultiSelectDataObject(LPDATAOBJECT pDataObject)
{
    if (pDataObject == NULL)
        return FALSE;

    FORMATETC fmt = {(CLIPFORMAT)CDataObject::m_cfIsMultiSel, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    return (pDataObject->QueryGetData(&fmt) == S_OK);
}

// Data object extraction helpers
CLSID* ExtractClassID(LPDATAOBJECT lpDataObject)
{
    return Extract<CLSID>(lpDataObject, CDataObject::m_cfCoClass);
}

GUID* ExtractNodeType(LPDATAOBJECT lpDataObject)
{
    return Extract<GUID>(lpDataObject, CDataObject::m_cfNodeType);
}

wchar_t* ExtractWorkstation(LPDATAOBJECT lpDataObject)
{
    return Extract<wchar_t>(lpDataObject, CDataObject::m_cfWorkstation);
}

INTERNAL* ExtractInternalFormat(LPDATAOBJECT lpDataObject)
{
    return Extract<INTERNAL>(lpDataObject, CDataObject::m_cfInternal);
}


HRESULT _QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                         CComponentDataImpl* pImpl, LPDATAOBJECT* ppDataObject)
{
    ASSERT(ppDataObject != NULL);
    ASSERT(pImpl != NULL);

    CComObject<CDataObject>* pObject;

    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    if(pObject == NULL)
    {
        return E_FAIL;
    }

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // Store the coclass with the data object
    pObject->SetClsid(pImpl->GetCoClassID());

    return  pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));

}

DWORD GetItemType(MMC_COOKIE cookie)
{
    // folder = CFoder* is cookie
    // result = RESULT_DATA* is the cookie

    return (*reinterpret_cast<DWORD*>(cookie));
}


/////////////////////////////////////////////////////////////////////////////
// CSnapin's IComponent implementation

STDMETHODIMP CSnapin::GetResultViewType(MMC_COOKIE cookie,  LPOLESTR* ppViewType, long* pViewOptions)
{
	if (m_CustomViewID == VIEW_ERROR_OCX)
	{
		StringFromCLSID (CLSID_MessageView, ppViewType);
		return S_FALSE;
	}
	else
	{
		*pViewOptions = MMC_VIEW_OPTIONS_MULTISELECT;

		// if list view
		if (m_CustomViewID == VIEW_DEFAULT_LV)
		{
			return S_FALSE;
		}
	}

    return S_FALSE;
}

STDMETHODIMP CSnapin::Initialize(LPCONSOLE lpConsole)
{
    DBX_PRINT(_T(" ----------  CSnapin::Initialize<0x08x>\n"), this);
    ASSERT(lpConsole != NULL);
    m_bInitializedC = true;
    HRESULT hr; 

    AFX_MANAGE_STATE(AfxGetStaticModuleState());


    // Save the IConsole pointer
    if (lpConsole == NULL)
        return E_POINTER;

    hr = lpConsole->QueryInterface(IID_IConsole2,
                        reinterpret_cast<void**>(&m_pConsole));
    _JumpIfError(hr, Ret, "QI IID_IConsole2");

    // Load resource strings
    LoadResources();

    // QI for a IHeaderCtrl
    hr = m_pConsole->QueryInterface(IID_IHeaderCtrl,
                        reinterpret_cast<void**>(&m_pHeader));
    _JumpIfError(hr, Ret, "QI IID_IHeaderCtrl");

    // Give the console the header control interface pointer
    if (SUCCEEDED(hr))
        m_pConsole->SetHeader(m_pHeader);

    hr = m_pConsole->QueryInterface(IID_IResultData,
                        reinterpret_cast<void**>(&m_pResult));
    _JumpIfError(hr, Ret, "QI IID_IResultData");

    hr = m_pConsole->QueryResultImageList(&m_pImageResult);
    _JumpIfError(hr, Ret, "ImageResult");

    hr = m_pConsole->QueryConsoleVerb(&m_pConsoleVerb);
    _JumpIfError(hr, Ret, "m_pConsoleVerb");

Ret:
    
    return hr;
}

STDMETHODIMP CSnapin::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (IS_SPECIAL_DATAOBJECT(lpDataObject))
    {
        if (event == MMCN_BTN_CLICK)
        {
            if (m_CustomViewID != VIEW_DEFAULT_LV)
            {
                switch (param)
                {
                case MMC_VERB_REFRESH:
                    ::AfxMessageBox(_T("MMCN_BTN_CLICK::MMC_VERB_REFRESH"));
                    _OnRefresh(lpDataObject);
                    break;

                case MMC_VERB_PROPERTIES:
                    ::AfxMessageBox(_T("MMCN_BTN_CLICK::MMC_VERB_PROPERTIES"));
                    break;

                default:
                    ::AfxMessageBox(_T("MMCN_BTN_CLICK::param unknown"));
                    break;
                }
            }
        }
        else
        {
            switch (event)
            {
            case MMCN_REFRESH:
                ::AfxMessageBox(_T("MMCN_BTN_CLICK::MMCN_REFRESH"));
                _OnRefresh(lpDataObject);
                break;
            }
        }

        return S_OK;
    }

    HRESULT hr = S_OK;
    MMC_COOKIE cookie = NULL;

    switch(event)
    {
    case MMCN_COLUMNS_CHANGED:
        hr = S_OK;
        break;
    case MMCN_PROPERTY_CHANGE:
        hr = OnPropertyChange(lpDataObject);
        break;
    case MMCN_VIEW_CHANGE:
        hr = OnUpdateView(lpDataObject);
        break;
    case MMCN_DESELECT_ALL:
        DBX_PRINT(_T("CSnapin::Notify -> MMCN_DESELECT_ALL \n"));
        break;
    case MMCN_COLUMN_CLICK:
        DBX_PRINT(_T("CSnapin::Notify -> MMCN_COLUMN_CLICK \n"));
        break;
    case MMCN_SNAPINHELP:
        AfxMessageBox(_T("CSnapin::Notify ->MMCN_SNAPINHELP"));
        break;
    default:
        {
            INTERNAL* pInternal = NULL;

            if (IsMMCMultiSelectDataObject(lpDataObject) == FALSE)
            {
                pInternal = ExtractInternalFormat(lpDataObject);

                if (pInternal == NULL)
                {
                    //ASSERT(FALSE);
                    return S_OK;
                }
                cookie = pInternal->m_cookie;
            }

            switch(event)
            {
            case MMCN_ACTIVATE:
                break;

            case MMCN_CLICK:
                if (NULL == pInternal)
                {
                    hr = S_FALSE;
                    break;
                }

                hr = OnResultItemClk(pInternal->m_type, cookie);
                break;

            case MMCN_DBLCLICK:
                hr = S_FALSE; // do the default verb
                break;

            case MMCN_ADD_IMAGES:
                OnAddImages(cookie, arg, param);
                break;

            case MMCN_SHOW:
                hr = OnShow(cookie, arg, param);
                break;

            case MMCN_MINIMIZED:
                hr = OnMinimize(cookie, arg, param);
                break;

            case MMCN_DESELECT_ALL:
            case MMCN_SELECT:
                HandleStandardVerbs((event == MMCN_DESELECT_ALL),
                                    arg, lpDataObject);
                break;

            case MMCN_PASTE:
                AfxMessageBox(_T("CSnapin::MMCN_PASTE"));
                break;

            case MMCN_DELETE:
                hr = OnDelete(lpDataObject, arg, param);
                // fall through to refresh -- break;

            case MMCN_REFRESH:
                {
                    _OnRefresh(lpDataObject);
                }
                break;

            case MMCN_CONTEXTHELP:
                hr = OnContextHelp(lpDataObject);
                break;

            case MMCN_RENAME:
                OutputDebugString(_T("\n\n\t\tCSnapin::MMCN_RENAME\n\n"));
                break;

            // Note - Future expansion of notify types possible
            default:
                hr = E_UNEXPECTED;
                break;
            }

            if (pInternal != NULL)
                FREE_DATA(pInternal);

            break;
        }
    }
    return hr;
}

HRESULT CSnapin::OnUpdateView(LPDATAOBJECT pDataObject)
{
    _OnRefresh(pDataObject);
    return S_OK;
}

void CSnapin::_OnRefresh(LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    INTERNAL* pInternal = ExtractInternalFormat(pDataObject);
    if (pInternal == NULL)
        return;

    if (pInternal->m_type == CCT_SCOPE)
    {
        CComponentDataImpl* pData = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
        CFolder* pFolder = pData->FindObject(pInternal->m_cookie);

        // only do if this is the currently selected folder!!
        if (m_pCurrentlySelectedScopeFolder == pFolder)
        {
            // HIDE, remove all items, remove header, SHOW
            OnShow(pInternal->m_cookie, FALSE, 0);              // emulate HIDE
            m_pResult->DeleteAllRsltItems();                    // delete items from m_pResult
            while(S_OK == m_pHeader->DeleteColumn(0)) {};       // remove all cols from header
            OnShow(pInternal->m_cookie, TRUE, 0);               // emulate SHOW
        }
    }
    else
    {
        RESULT_DATA* pData = reinterpret_cast<RESULT_DATA*>(pInternal->m_cookie);
    }

    FREE_DATA(pInternal);
}


HRESULT CSnapin::OnContextHelp(LPDATAOBJECT pdtobj)
{
    HRESULT	hr = S_OK;

    CString cstrHelpFile;
    IDisplayHelp*	pDisplayHelp = NULL;
    WCHAR szWindows[MAX_PATH];
    szWindows[0] = L'\0';

    hr = m_pConsole->QueryInterface (IID_IDisplayHelp, (void**)&pDisplayHelp);
    _JumpIfError(hr, Ret, "QI IDisplayHelp");

    if (0 == GetSystemWindowsDirectory(szWindows, MAX_PATH))
    {
        hr = myHLastError();
        _JumpError(hr, Ret, "GetSystemWindowsDirectory");
    }

    cstrHelpFile = szWindows;
    cstrHelpFile += HTMLHELP_COLLECTIONLINK_FILENAME;
    cstrHelpFile += L"::/sag_cs_topnode.htm";

    hr = pDisplayHelp->ShowTopic (T2OLE ((LPWSTR)(LPCWSTR)cstrHelpFile));
    _JumpIfError(hr, Ret, "ShowTopic");

Ret:
    if (pDisplayHelp)
        pDisplayHelp->Release();

    return hr;
}


STDMETHODIMP CSnapin::Destroy(MMC_COOKIE cookie)
{
    DBX_PRINT(_T(" ----------  CSnapin::Destroy<0x08x>\n"), this);
    ASSERT(m_bInitializedC);

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    m_bDestroyedC = true;

    // Release the interfaces that we QI'ed
    if (m_pConsole != NULL)
    {
        // Tell the console to release the header control interface
        m_pConsole->SetHeader(NULL);
        SAFE_RELEASE(m_pHeader);

        SAFE_RELEASE(m_pResult);
        SAFE_RELEASE(m_pImageResult);

        // Release the IConsole interface last
        SAFE_RELEASE(m_pConsole);
        SAFE_RELEASE(m_pComponentData); // QI'ed in IComponentDataImpl::CreateComponent

        SAFE_RELEASE(m_pConsoleVerb);
    }

    return S_OK;
}


HRESULT CSnapin::QueryMultiSelectDataObject(MMC_COOKIE cookie,
                                                        DATA_OBJECT_TYPES type,
                                                        LPDATAOBJECT* ppDataObject)
{

    CComponentDataImpl* pImpl = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    CComObject<CDataObject>* pObject = NULL;
	HRESULT		    hr = S_OK;
    LPRESULTDATA    pResultData = NULL;
    RESULTDATAITEM  rdi;

    ASSERT(ppDataObject != NULL);

    if (ppDataObject == NULL)
    {
        hr = E_POINTER;
        goto error;
    }


    hr = m_pConsole->QueryInterface(IID_IResultData,
        reinterpret_cast<void**>(&pResultData));
    if(hr != S_OK)
    {
        goto error;
    }
    ASSERT(pResultData != NULL);


    CComObject<CDataObject>::CreateInstance(&pObject);
    ASSERT(pObject != NULL);

    // Save cookie and type for delayed rendering
    pObject->SetType(type);
    pObject->SetCookie(cookie);

    // tell dataobj who we are
    // pObject->SetComponentData(pImpl);


    // Determine the items selected

    ZeroMemory(&rdi, sizeof(rdi));
    rdi.mask = RDI_STATE;
    rdi.nIndex = -1;
    rdi.nState = TVIS_SELECTED;

    while (pResultData->GetNextItem (&rdi) == S_OK)
    {
        CFolder* pFolder = reinterpret_cast <CFolder *> (rdi.lParam);

        if ( pFolder )
        {
            if(pFolder->GetType() == CA_CERT_TYPE)
            {
                pObject->AddCookie((MMC_COOKIE)pFolder);
            }
        }
        else
        {
			hr = E_INVALIDARG;
            goto error;
        }
    }
    // We're always adding things from policy settings these days.

    pObject->SetMultiSelDobj();
    pObject->SetClsid(pImpl->GetCoClassID());

    SMMCObjectTypes sObjGuids; // one is fine for now
    sObjGuids.count = 1;
    CopyMemory(&sObjGuids.guid[0], &cNodeTypePolicySettings, sizeof(GUID));

    // Store the coclass with the data object
    pObject->SetMultiSelData(&sObjGuids, sizeof(SMMCObjectTypes));

    hr = pObject->QueryInterface(IID_IDataObject,
                    reinterpret_cast<void**>(ppDataObject));
    pObject = NULL;

error:
    if(pObject)
    {
        pObject->Release();
    }
    if (pResultData)
    {
        pResultData->Release();
    }

    return hr;
}

STDMETHODIMP CSnapin::QueryDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES type,
                        LPDATAOBJECT* ppDataObject)
{
    if (cookie == MMC_MULTI_SELECT_COOKIE)
    {
        return QueryMultiSelectDataObject(cookie, type, ppDataObject);
    }

    ASSERT(type == CCT_RESULT);

    // Delegate it to the IComponentData
    ASSERT(m_pComponentData != NULL);
    CComponentDataImpl* pImpl = dynamic_cast<CComponentDataImpl*>(m_pComponentData);
    ASSERT(pImpl != NULL);
    return _QueryDataObject(cookie, type, pImpl, ppDataObject);
}

/////////////////////////////////////////////////////////////////////////////
// CSnapin's implementation specific members

DEBUG_DECLARE_INSTANCE_COUNTER(CSnapin);

CSnapin::CSnapin()
: m_bIsDirty(TRUE), m_bInitializedC(false), m_bDestroyedC(false)
{
    DEBUG_INCREMENT_INSTANCE_COUNTER(CSnapin);
    Construct();
}

CSnapin::~CSnapin()
{
#if DBG==1
    ASSERT(dbg_cRef == 0);
#endif

    DEBUG_DECREMENT_INSTANCE_COUNTER(CSnapin);

    if (m_pSvrMgrToolbar1)
        SAFE_RELEASE(m_pSvrMgrToolbar1);

#ifdef INSERT_DEBUG_FOLDERS
    SAFE_RELEASE(m_pMenuButton1);
#endif // INSERT_DEBUG_FOLDERS

    if (m_pControlbar)
        SAFE_RELEASE(m_pControlbar);

    // Make sure the interfaces have been released
    ASSERT(m_pConsole == NULL);
    ASSERT(m_pHeader == NULL);
    ASSERT(m_pSvrMgrToolbar1 == NULL);

    delete m_pbmpSvrMgrToolbar1;

    ASSERT(!m_bInitializedC || m_bDestroyedC);

    Construct();
}

void CSnapin::Construct()
{
#if DBG==1
    dbg_cRef = 0;
#endif

    m_pConsole = NULL;
    m_pHeader = NULL;

    m_pResult = NULL;
    m_pImageResult = NULL;
    m_pComponentData = NULL;

    m_pControlbar = NULL;

#ifdef INSERT_DEBUG_FOLDERS
    m_pMenuButton1 = NULL;
#endif // INSERT_DEBUG_FOLDERS

    m_pSvrMgrToolbar1 = NULL;
    m_pbmpSvrMgrToolbar1 = NULL;

    m_pConsoleVerb = NULL;

    m_CustomViewID = VIEW_DEFAULT_LV;
    m_bVirtualView = FALSE;
}

CString g_ColumnHead_Name;
CString g_ColumnHead_Size;
CString g_ColumnHead_Type;
CString g_ColumnHead_IntendedPurpose;

void CSnapin::LoadResources()
{
    // Load strings from resources
    g_ColumnHead_Name.LoadString(IDS_COLUMN_NAME);
    g_ColumnHead_Size.LoadString(IDS_COLUMN_SIZE);
    g_ColumnHead_Type.LoadString(IDS_COLUMN_TYPE);
    g_ColumnHead_IntendedPurpose.LoadString(IDS_COLUMN_INTENDED_PURPOSE);
}

HRESULT CSnapin::InitializeHeaders(MMC_COOKIE cookie)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    ASSERT(m_pHeader);

    HRESULT hr = S_OK;
    BOOL fInsertedHeaders=FALSE;

    USES_CONVERSION;

    CFolder* pFolder = reinterpret_cast<CFolder*>(cookie);

    switch (pFolder->m_type)
    {
    case POLICYSETTINGS:
    case SCE_EXTENSION:

        m_pHeader->InsertColumn(0, W2COLE(g_ColumnHead_Name), LVCFMT_LEFT, 230);     // Name
        m_pHeader->InsertColumn(1, W2COLE(g_ColumnHead_IntendedPurpose), LVCFMT_LEFT, 230);     // Intended Purpose
        fInsertedHeaders = TRUE;
        break;

    default:
        // other scopes
        m_pHeader->InsertColumn(0, W2COLE(g_ColumnHead_Name), LVCFMT_LEFT, 180);     // Name
        m_pHeader->InsertColumn(1, W2COLE(g_ColumnHead_Size), LVCFMT_LEFT, 90);     // Size
        m_pHeader->InsertColumn(2, W2COLE(g_ColumnHead_Type), LVCFMT_LEFT, 160);     // Type
        fInsertedHeaders = TRUE;
    }

    return hr;
}

STDMETHODIMP CSnapin::GetDisplayInfo(LPRESULTDATAITEM pResult)
{
    static WCHAR* s_szSize = L"200";
    static WCHAR* s_szUnnamedItems = L"Unnamed subitem";
    ASSERT(pResult != NULL);

    CFolder* pFolder = reinterpret_cast<CFolder*>(pResult->lParam);
    ASSERT(pFolder);

    if (pResult)
    {
        // a folder or a result?
        if (pResult->bScopeItem == TRUE)
        {
            if (pResult->mask & RDI_STR)
            {
                switch (pFolder->m_type)
                {
                case POLICYSETTINGS:
                case SCE_EXTENSION:
                    // just a single column here
                    pResult->str = pFolder->m_pszName;

                    break;
                default:
                    break;
                }

                ASSERT(pResult->str != NULL);

                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }

            if (pResult->mask & RDI_IMAGE)
            {
                if (pResult->nState & TVIS_EXPANDED)
                    pResult->nImage = pFolder->m_pScopeItem->nOpenImage;
                else
                    pResult->nImage = pFolder->m_pScopeItem->nImage;
            }
        }
        else
        {
            RESULT_DATA* pData;

            // lParam is the item pointer
            pData= reinterpret_cast<RESULT_DATA*>(pResult->lParam);

            if (pResult->mask & RDI_STR)
            {
                ASSERT(pFolder->m_hCertType != NULL);

                if (pResult->nCol == 0)
                    pResult->str = pFolder->m_pszName;
                else if (pResult->nCol == 1)
                    pResult->str = (LPWSTR)((LPCWSTR) pFolder->m_szIntendedUsages);


                ASSERT(pResult->str != NULL);

                if (pResult->str == NULL)
                    pResult->str = (LPOLESTR)L"";
            }

            // MMC can request image and indent for virtual data
            if (pResult->mask & RDI_IMAGE)
            {
                // UNDONE: what to do here?
                ASSERT(0);
                pResult->nImage = IMGINDEX_CERTTYPE;
            }
        }
    }

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IExtendContextMenu Implementation
STDMETHODIMP CSnapin::AddMenuItems(LPDATAOBJECT pDataObject,
                                    LPCONTEXTMENUCALLBACK pContextMenuCallback,
                                    LONG *pInsertionAllowed)
{

    return dynamic_cast<CComponentDataImpl*>(m_pComponentData)->
            AddMenuItems(pDataObject, pContextMenuCallback, pInsertionAllowed);
}


STDMETHODIMP CSnapin::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    INTERNAL*   pInternal = ExtractInternalFormat(pDataObject);
    HRESULT     hr;
    HWND        hwndConsole;

    if (pInternal == NULL)
        return E_FAIL;

    CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);

    if (pInternal->m_type == CCT_SCOPE)
    {
        // Handle view specific commands here
        switch (nCommandID)
        {
        case MMCC_STANDARD_VIEW_SELECT:
            m_CustomViewID = VIEW_DEFAULT_LV;
            break;

        default:
            // Pass non-view specific commands to ComponentData
            return dynamic_cast<CComponentDataImpl*>(m_pComponentData)->
                Command(nCommandID, pDataObject);
        }
    }
    else if (pInternal->m_type == CCT_RESULT)
    {
        // snag the selected items

        // only support single selection for now
        m_pResult->ModifyViewStyle(MMC_SINGLESEL, (MMC_RESULT_VIEW_STYLE)0);

        RESULTDATAITEM rdi;
        ZeroMemory(&rdi, sizeof(rdi));

        rdi.mask = RDI_STATE;
        rdi.nState = LVIS_SELECTED;
        rdi.nIndex = -1;
        m_pResult->GetNextItem(&rdi);

        int iSel = rdi.nIndex;

        RESULT_DATA* pData;

        ZeroMemory(&rdi, sizeof(rdi));
        rdi.mask = RDI_PARAM;
        rdi.nIndex = iSel;
        hr = m_pResult->GetItem(&rdi);
        ASSERT(SUCCEEDED(hr));
        ASSERT(rdi.lParam != 0);

        pData = reinterpret_cast<RESULT_DATA*>(rdi.lParam);


        // No current commands :(
    }
    else
    {
        ASSERT(0);
    }

    FREE_DATA(pInternal);

    return S_OK;
}

STDMETHODIMP CSnapin::GetClassID(CLSID *pClassID)
{
    ASSERT(pClassID != NULL);

    ASSERT(0);

    // Copy the CLSID for this snapin
    // reid fix - what is up with this?
    *pClassID = CLSID_CAPolicyExtensionSnapIn;

    return E_NOTIMPL;
}

STDMETHODIMP CSnapin::IsDirty()
{
    // Always save / Always dirty.
    return ThisIsDirty() ? S_OK : S_FALSE;
}

STDMETHODIMP CSnapin::Load(IStream *pStm)
{
    DBX_PRINT(_T(" ----------  CSnapin::Load<0x08x>\n"), this);
    ASSERT(m_bInitializedC);

    ASSERT(pStm);
    // Read the string
    DWORD dwVer;
    ULONG nBytesRead;
    HRESULT hr = pStm->Read(&dwVer, sizeof(DWORD), &nBytesRead);
    ASSERT(SUCCEEDED(hr) && nBytesRead == sizeof(DWORD));

    if (dwVer != 0x1)
    {
        return (STG_E_OLDFORMAT);
    }

    ClearDirty();

    return SUCCEEDED(hr) ? S_OK : E_FAIL;
}

STDMETHODIMP CSnapin::Save(IStream *pStm, BOOL fClearDirty)
{
    DBX_PRINT(_T(" ----------  CSnapin::Save<0x08x>\n"), this);
    ASSERT(m_bInitializedC);

    ASSERT(pStm);

    // Write the string
    ULONG nBytesWritten;
    DWORD dwVersion = 0x1;
    HRESULT hr = pStm->Write(&dwVersion, sizeof(DWORD), &nBytesWritten);

    // Verify that the write operation succeeded
    ASSERT(SUCCEEDED(hr) && nBytesWritten == sizeof(DWORD));
    if (FAILED(hr))
        return STG_E_CANTSAVE;

    if (fClearDirty)
        ClearDirty();
    return S_OK;
}

STDMETHODIMP CSnapin::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    ASSERT(pcbSize);

    DWORD cbSize;
    cbSize = sizeof(DWORD); // version


    // Set the size of the string to be saved
    ULISet32(*pcbSize, cbSize);

    return S_OK;
}



///////////////////////////////////////////////////////////////////////////////
// IExtendControlbar implementation
//


STDMETHODIMP CSnapin::SetControlbar(LPCONTROLBAR pControlbar)
{
/*    TRACE(_T("CSnapin::SetControlbar(%ld)\n"),pControlbar);
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    if (m_pControlbar)
        SAFE_RELEASE(m_pControlbar);

    if (pControlbar != NULL)
    {
        // Hold on to the controlbar interface.
        m_pControlbar = pControlbar;
        m_pControlbar->AddRef();

        HRESULT hr=S_FALSE;

#ifdef INSERT_DEBUG_FOLDERS
        if (!m_pMenuButton1)
        {
            hr = m_pControlbar->Create(MENUBUTTON, this,
                                reinterpret_cast<LPUNKNOWN*>(&m_pMenuButton1));
            ASSERT(SUCCEEDED(hr));
        }

        if (m_pMenuButton1)
        {
            // Unlike toolbar buttons, menu buttons need to be added every time.
            hr = m_pMenuButton1->AddButton(FOLDEREX_MENU, L"FolderEx", L"Extended Folder Menu");
            ASSERT(SUCCEEDED(hr));
            hr = m_pMenuButton1->AddButton(FILEEX_MENU, L"FileEx", L"Extended File Menu");
            ASSERT(SUCCEEDED(hr));
        }
#endif // INSERT_DEBUG_FOLDERS


        // SvrMgrToolbar1
        if (!m_pSvrMgrToolbar1)
        {
            hr = m_pControlbar->Create(TOOLBAR, this, reinterpret_cast<LPUNKNOWN*>(&m_pSvrMgrToolbar1));
            ASSERT(SUCCEEDED(hr));

            // Add the bitmap
            m_pbmpSvrMgrToolbar1 = new ::CBitmap;
            m_pbmpSvrMgrToolbar1->LoadBitmap(IDB_TOOLBAR_SVRMGR1);
            hr = m_pSvrMgrToolbar1->AddBitmap(36, *m_pbmpSvrMgrToolbar1, 16, 16, RGB(192,192,192));
            ASSERT(SUCCEEDED(hr));

            // Add the buttons to the toolbar
            hr = m_pSvrMgrToolbar1->AddButtons(ARRAYLEN(SvrMgrToolbar1Buttons), SvrMgrToolbar1Buttons);
            ASSERT(SUCCEEDED(hr));
        }

    }
*/

    return S_OK;
}


void CSnapin::OnButtonClick(LPDATAOBJECT pdtobj, int idBtn)
{
    WCHAR name[128];
    DWORD cName = sizeof(name)/sizeof(WCHAR);
    GetItemName(pdtobj, name, &cName);

    switch(idBtn)
    {
    case IDC_STOPSERVER:
    case IDC_STARTSERVER:
        // bubble this to our other handler
        dynamic_cast<CComponentDataImpl*>(m_pComponentData)->
                Command(idBtn, pdtobj);
        break;
    default:
        {
#ifdef _DEBUG
        TCHAR buf[150];
        wsprintf(buf, L"Toolbar button<%d> was clicked.\nThe currently selected result item is <%ws>", idBtn, name);
        OutputDebugString(buf);
#endif // _DEBUG
        }
        break;
    }
}


STDMETHODIMP CSnapin::ControlbarNotify(MMC_NOTIFY_TYPE event, LPARAM arg, LPARAM param)
{
  /*  HRESULT hr=S_FALSE;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    switch (event)
    {
    case MMCN_BTN_CLICK:
        //TCHAR szMessage[MAX_PATH];
        //wsprintf(szMessage, _T("CommandID %ld"),param);
        //AfxMessageBox(szMessage);
        OnButtonClick(reinterpret_cast<LPDATAOBJECT>(arg), param);
        break;

    case MMCN_DESELECT_ALL:
    case MMCN_SELECT:
        HandleExtToolbars((event == MMCN_DESELECT_ALL), arg, param);
        break;

    case MMCN_MENU_BTNCLICK:
        HandleExtMenus(arg, param);
        break;

    default:
        break;
    }

*/
    return S_OK;
}

// This compares two data objects to see if they are the same object.
// return
//    S_OK if equal otherwise S_FALSE
//
// Note: check to make sure both objects belong to the snap-in.
//

STDMETHODIMP CSnapin::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    return S_FALSE;
}


// This compare is used to sort the item's in the listview
//
// Parameters:
//
// lUserParam - user param passed in when IResultData::Sort() was called
// cookieA - first item to compare
// cookieB - second item to compare
// pnResult [in, out]- contains the col on entry,
//          -1, 0, 1 based on comparison for return value.
//
// Note: Assum sort is ascending when comparing.


STDMETHODIMP CSnapin::Compare(LPARAM lUserParam, MMC_COOKIE cookieA, MMC_COOKIE cookieB, int* pnResult)
{
    if (pnResult == NULL)
    {
        ASSERT(FALSE);
        return E_POINTER;
    }

    // check col range
    int nCol = *pnResult;
    ASSERT(nCol >=0);

    *pnResult = 0;

    USES_CONVERSION;

    LPWSTR szStringA;
    LPWSTR szStringB;

    CFolder* pDataA = reinterpret_cast<CFolder*>(cookieA);
    CFolder* pDataB = reinterpret_cast<CFolder*>(cookieB);


    ASSERT(pDataA != NULL && pDataB != NULL);

    if (nCol == 0)
    {
        szStringA = OLE2W(pDataA->m_pszName);
        szStringB = OLE2W(pDataB->m_pszName);
    }
    else if (nCol == 1)
    {
        szStringA = OLE2W((LPWSTR)((LPCWSTR) pDataA->m_szIntendedUsages));
        szStringB = OLE2W((LPWSTR)((LPCWSTR) pDataB->m_szIntendedUsages));
    }
    else
        return S_OK;

    if ((szStringA == NULL) || (szStringB == NULL))
        return E_POINTER;

    *pnResult = wcscmp(szStringA, szStringB);


    return S_OK;
}

// independent of scope/result type, will return parent folder
CFolder*    GetParentFolder(INTERNAL* pInternal)
{
    if (NULL == pInternal)
        return NULL;

    if (CCT_SCOPE == pInternal->m_type)
    {
        return reinterpret_cast<CFolder*>(pInternal->m_cookie);
    }
    else if (CCT_RESULT == pInternal->m_type)
    {
        RESULT_DATA* pData = reinterpret_cast<RESULT_DATA*>(pInternal->m_cookie);
        CSASSERT(pData != NULL);
        if (pData != NULL)
            return pData->pParentFolder;
    }

    return NULL;
}

CFolder* CSnapin::GetVirtualFolder()
{
    CSASSERT(m_bVirtualView);
    return m_pCurrentlySelectedScopeFolder;
}

CFolder*    CSnapin::GetParentFolder(INTERNAL* pInternal)
{
    CFolder* p;

    if(m_bVirtualView)
        p = GetVirtualFolder();
    else
        p = ::GetParentFolder(pInternal);

#if DBG
    if (p != m_pCurrentlySelectedScopeFolder)
    {
        if (NULL == p)
            DBGPRINT((DBG_SS_CERTMMC, "Parent derived NULL, current saved folder is <%ws>\n", m_pCurrentlySelectedScopeFolder->m_pszName));
        else if (NULL == m_pCurrentlySelectedScopeFolder)
            DBGPRINT((DBG_SS_CERTMMC, "Parent derived as <%ws>, current saved folder is NULL\n", p->m_pszName));
        else
            DBGPRINT((DBG_SS_CERTMMC, "Parent derived as <%ws>, current saved folder is <%ws>\n", p->m_pszName, m_pCurrentlySelectedScopeFolder->m_pszName));
    }
#endif

    return p;
}


void CSnapin::HandleStandardVerbs(bool bDeselectAll, LPARAM arg,
                                  LPDATAOBJECT lpDataObject)
{

    if(m_pConsoleVerb == NULL)
    {
        return;
    }

    if (m_CustomViewID != VIEW_DEFAULT_LV)
    {
        if(m_CustomViewID != VIEW_ERROR_OCX)
        {
        m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

        m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);
        }
        return;
    }

    if (!bDeselectAll && lpDataObject == NULL)
        return;

    // You should crack the data object and enable/disable/hide standard
    // commands appropriately.  The standard commands are reset everytime you get
    // called. So you must reset them back.

    WORD bScope = LOWORD(arg);
    WORD bSelect = HIWORD(arg);

    DBX_PRINT(_T("      %4d - CSnapin::OnSelect<%d, %d>\n"), ++n_count, bScope, bSelect);

    DWORD       dwCertTypeFlags;
    HRESULT     hr;
    INTERNAL* pInternal = lpDataObject ? ExtractInternalFormat(lpDataObject) : NULL;
    // if scope item, derive parent folder from pInternal.
    // if result item, recall parent folder from saved state

    CFolder *pFolder = NULL;

    if (IsMMCMultiSelectDataObject(lpDataObject))
    {
        RESULTDATAITEM Item;

        CDataObject *pDataObject = reinterpret_cast<CDataObject*>(lpDataObject);

        MMC_COOKIE cookie;

        hr = pDataObject->GetCookieAt(0, &cookie);
        if(S_OK != hr)
        {
            _PrintIfError(hr, "GetCookieAt");
            return;
        }
        
        pFolder = reinterpret_cast<CFolder*>(cookie);

    }
    else
    {
        pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);
    }

    BOOL fRoleCanDelete = FALSE;

    if(!g_fCurrentUserHasDSWriteAccessTested)
    {
        CurrentUserCanInstallCA(g_fCurrentUserHasDSWriteAccess);
        g_fCurrentUserHasDSWriteAccessTested = true;
    }
    
    if(pFolder)
        fRoleCanDelete = 
        ((CA_ACCESS_ADMIN & pFolder->GetRoles())||
         g_fCurrentUserHasDSWriteAccess)?TRUE:FALSE;

    if (!bDeselectAll && IsMMCMultiSelectDataObject(lpDataObject) == TRUE)
    {
        m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, fRoleCanDelete);
        return;
    }
    if (bDeselectAll || !bSelect)
    {
        // we have no items selected, so add the Refresh verb
        m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE);
        m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);

        // bail
        return;
    }

    // Standard funcitonality NOT support by all items
    m_pConsoleVerb->SetVerbState(MMC_VERB_COPY, HIDDEN, TRUE);
    m_pConsoleVerb->SetVerbState(MMC_VERB_COPY, ENABLED, FALSE);

    m_pConsoleVerb->SetVerbState(MMC_VERB_PASTE, HIDDEN, TRUE);
    m_pConsoleVerb->SetVerbState(MMC_VERB_PASTE, ENABLED, FALSE);

    m_pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, FALSE);

    m_pConsoleVerb->SetVerbState(MMC_VERB_OPEN, HIDDEN, TRUE);
    m_pConsoleVerb->SetVerbState(MMC_VERB_OPEN, ENABLED, FALSE);

    m_pConsoleVerb->SetDefaultVerb(MMC_VERB_NONE);

    if (pInternal)
    {
        if (pInternal->m_type == CCT_SCOPE)
        {

            // Common verbs through all states
            m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, FALSE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, TRUE);


            // Scope items can't be deleted
            m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, TRUE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, FALSE);

            // No properties on the scope item
            m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, TRUE);
            m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, FALSE);

            // default folder verb is open
            m_pConsoleVerb->SetDefaultVerb(MMC_VERB_OPEN);
        }
        else
        {
            // check to see if this is a default cert type and we are in GPT,
            // if so then don't enable delete
            if (pFolder != NULL)
            {
                // Common verbs through all states
                m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, HIDDEN, TRUE);
                m_pConsoleVerb->SetVerbState(MMC_VERB_REFRESH, ENABLED, FALSE);

                // They do have properties
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, HIDDEN, FALSE);
                m_pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

                // They can be deleted
                m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, HIDDEN, FALSE);
                m_pConsoleVerb->SetVerbState(MMC_VERB_DELETE, ENABLED, fRoleCanDelete);

                m_pConsoleVerb->SetDefaultVerb(MMC_VERB_PROPERTIES);
            }

        }

    }


    FREE_DATA(pInternal);
}

void EnableToolbar(LPTOOLBAR pToolbar, MMCBUTTON rgSnapinButtons[], int nRgSize,
                   BOOL bEnable)
{
    for (int i=0; i < nRgSize; ++i)
    {
        if (rgSnapinButtons[i].idCommand != 0)
            pToolbar->SetButtonState(rgSnapinButtons[i].idCommand, ENABLED,
                                     bEnable);
    }
}


void EnableMenuBtns(LPMENUBUTTON pMenuBtn, MMCBUTTON rgSnapinButtons[], int nRgSize,
                   BOOL bEnable)
{
    for (int i=0; i < nRgSize; ++i)
    {
        if (rgSnapinButtons[i].idCommand != 0)
            pMenuBtn->SetButtonState(rgSnapinButtons[i].idCommand, ENABLED,
                                     bEnable);
    }
}

void CSnapin::HandleExtToolbars(bool bDeselectAll, LPARAM arg, LPARAM param)
{
    INTERNAL* pInternal = NULL;
    HRESULT hr;

    BOOL bScope = (BOOL) LOWORD(arg);
    BOOL bSelect = (BOOL) HIWORD(arg);

    if (param)
    {
        LPDATAOBJECT pDataObject = reinterpret_cast<LPDATAOBJECT>(param);
        pInternal = ExtractInternalFormat(pDataObject);
    }

#ifdef _DEBUG
    TCHAR buf[200];
    wsprintf(buf, _T("      %4d - CExtendControlbar::OnSelect<%d, %d> = %d\n"),
             ++n_count, bScope, bSelect, pInternal ? pInternal->m_cookie : 0);
    OutputDebugString(buf);
#endif //_DEBUG

    // Deselection Notification?
    if (bDeselectAll || bSelect == FALSE)
    {
        ASSERT(m_pSvrMgrToolbar1);
        EnableToolbar(m_pSvrMgrToolbar1, SvrMgrToolbar1Buttons,
                      ARRAYLEN(SvrMgrToolbar1Buttons), FALSE);

#ifdef INSERT_DEBUG_FOLDERS
        ASSERT(m_pMenuButton1 != NULL);
        m_pMenuButton1->SetButtonState(FOLDEREX_MENU, ENABLED, FALSE);
        m_pMenuButton1->SetButtonState(FILEEX_MENU, ENABLED, FALSE);
#endif // INSERT_DEBUG_FOLDERS
        return;
    }

    ASSERT(bSelect == TRUE);
    bool bFileExBtn = false;
    if (bScope == TRUE)
    {
        // at SCOPE level?
        LPDATAOBJECT pDataObject = reinterpret_cast<LPDATAOBJECT>(param);

        pInternal = ExtractInternalFormat(pDataObject);
        if (pInternal == NULL)
            return;

        CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);

        if (pInternal->m_cookie == 0)
        {
            if (IsPrimaryImpl() == TRUE)
            {
                // Attach the SvrMgrToolbar1 to the window
                hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pSvrMgrToolbar1);
                ASSERT(SUCCEEDED(hr));
            }
        }
        else if (IsPrimaryImpl() == TRUE /*&&
            (   pFolder->GetType() == SERVER_INSTANCE ||
                pFolder->GetType() ==  SERVERFUNC_CRL_PUBLICATION ||
                pFolder->GetType() ==  SERVERFUNC_ISSUED_CERTIFICATES ||
                pFolder->GetType() ==  SERVERFUNC_PENDING_CERTIFICATES )*/)
        {
            // Attach the SvrMgrToolbar1 to the window
            hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pSvrMgrToolbar1);
            ASSERT(SUCCEEDED(hr));
        }
        else
        {
            // Detach the SvrMgrToolbar1 to the window
            hr = m_pControlbar->Detach((LPUNKNOWN) m_pSvrMgrToolbar1);
            ASSERT(SUCCEEDED(hr));
        }

    }
    else // result item selected: result or subfolder
    {
        // at RESULTS level
        LPDATAOBJECT pDataObject = reinterpret_cast<LPDATAOBJECT>(param);

        if (pDataObject != NULL)
            pInternal = ExtractInternalFormat(pDataObject);

        if (pInternal == NULL)
            return;

        if (pInternal->m_type == CCT_RESULT)
        {
            bFileExBtn = true;

            // UNDONE: what to do here with SvrMgrToolbar1Buttons1?
            // For now, do nothing: allow them to remain in same state

        }
        else // sub folder slected
        {
            CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);

            ASSERT(m_pControlbar);

            if (pInternal->m_cookie == 0)
            {
                if (IsPrimaryImpl() == TRUE)
                {
                    // Attach the SvrMgrToolbar1 to the window
                    hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pSvrMgrToolbar1);
                    ASSERT(SUCCEEDED(hr));
                }
            }
            else if (IsPrimaryImpl() == TRUE /*&&
                (   pFolder->GetType() == SERVER_INSTANCE ||
                    pFolder->GetType() ==  SERVERFUNC_CRL_PUBLICATION ||
                    pFolder->GetType() ==  SERVERFUNC_ISSUED_CERTIFICATES ||
                    pFolder->GetType() ==  SERVERFUNC_PENDING_CERTIFICATES )*/)
            {
                // Attach the SvrMgrToolbar1 to the window
                hr = m_pControlbar->Attach(TOOLBAR, (LPUNKNOWN) m_pSvrMgrToolbar1);
                ASSERT(SUCCEEDED(hr));
            }
            else
            {
                // Detach the SvrMgrToolbar1 to the window
                hr = m_pControlbar->Detach((LPUNKNOWN) m_pSvrMgrToolbar1);
                ASSERT(SUCCEEDED(hr));
            }
        }
    }

#ifdef INSERT_DEBUG_FOLDERS
    if (m_pMenuButton1)
    {
        // Always make sure the menuButton is attached
        m_pControlbar->Attach(MENUBUTTON, m_pMenuButton1);

        if (bFileExBtn)
        {
            m_pMenuButton1->SetButtonState(FILEEX_MENU, HIDDEN, FALSE);
            m_pMenuButton1->SetButtonState(FOLDEREX_MENU, HIDDEN, TRUE);
            m_pMenuButton1->SetButtonState(FILEEX_MENU, ENABLED, TRUE);
        }
        else
        {
            m_pMenuButton1->SetButtonState(FOLDEREX_MENU, HIDDEN, FALSE);
            m_pMenuButton1->SetButtonState(FILEEX_MENU, HIDDEN, TRUE);
            m_pMenuButton1->SetButtonState(FOLDEREX_MENU, ENABLED, TRUE);
        }
    }
#endif // INSERT_DEBUG_FOLDERS
    FREE_DATA(pInternal);
}

// dropdown menu addition
void CSnapin::HandleExtMenus(LPARAM arg, LPARAM param)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    LPDATAOBJECT* ppDataObject = reinterpret_cast<LPDATAOBJECT*>(arg);
    LPMENUBUTTONDATA pMenuData = reinterpret_cast<LPMENUBUTTONDATA>(param);

    if (ppDataObject == NULL || pMenuData == NULL)
    {
        ASSERT(FALSE);
        return;
    }


    HMENU hMenu = NULL;
    HMENU hSubMenu = NULL;

    switch (pMenuData->idCommand)
    {
    case FOLDEREX_MENU:
        hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(FOLDEREX_MENU));
        if (NULL == hMenu)
           break;
        hSubMenu = GetSubMenu(hMenu, 0);
        break;

    case FILEEX_MENU:
        hMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(FILEEX_MENU));
        if (NULL == hMenu)
           break;
        hSubMenu = GetSubMenu(hMenu, 0);
        break;

    default:
        ASSERT(FALSE);
    }

    if (hSubMenu == NULL)
    {
        // might've already loaded hMenu -- free if we have
        if (NULL != hMenu)
            DestroyMenu(hMenu);

        return;
    }

    //pMenu->TrackPopupMenu(TPM_RETURNCMD | TPM_NONOTIFY, pMenuData->x, pMenuData->y, AfxGetMainWnd());
    HWND hwndMain = NULL;
    m_pConsole->GetMainWindow(&hwndMain);
    TrackPopupMenu(hSubMenu, TPM_RETURNCMD | TPM_NONOTIFY, pMenuData->x, pMenuData->y, 0, hwndMain, NULL);
 
    // Destroy the menu. 
    if (NULL != hMenu)
        DestroyMenu(hMenu); 
}


void CSnapin::GetItemName(LPDATAOBJECT pdtobj, LPWSTR pszName, DWORD *pcName)
{
    ASSERT(pszName != NULL);
    pszName[0] = 0;

    INTERNAL* pInternal = ExtractInternalFormat(pdtobj);
    ASSERT(pInternal != NULL);
    if (pInternal == NULL)
        return;

    ASSERT(pcName != NULL);
    if (pcName == NULL)
        return;



    OLECHAR *pszTemp;

    if (pInternal->m_type == CCT_RESULT)
    {
        RESULT_DATA* pData;
        pData = reinterpret_cast<RESULT_DATA*>(pInternal->m_cookie);

        ASSERT(pData != NULL);
        pszTemp = pData->szStringArray[RESULTDATA_ARRAYENTRY_NAME]; // szName
    }
    else
    {
        CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);
        if (pFolder == 0)
            pszTemp = L"Static folder";
        else
            pszTemp = OLE2W(pFolder->m_pszName);
    }

    USES_CONVERSION;


    lstrcpyn(pszName, OLE2W(pszTemp), *pcName);
    if(*pcName > wcslen(pszName))
    {
        *pcName = wcslen(pszName) + 1;
    }

    FREE_DATA(pInternal);
}



/////////////////////////////////////////////////////////////////////////////
// IExtendPropertySheet Implementation

STDMETHODIMP CSnapin::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider,
                    LONG_PTR handle,
                    LPDATAOBJECT lpIDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Look at the data object and determine if this an extension or a primary
    ASSERT(lpIDataObject != NULL);

    PropertyPage* pBasePage;

    INTERNAL* pInternal = ExtractInternalFormat(lpIDataObject);

    if(pInternal == NULL)
    {
        return E_POINTER;
    }

    switch (pInternal->m_type)
    {
    case CCT_RESULT:
    {
        if (0 == pInternal->m_cookie)
        {
            // base scope
            // no properties exist here
/*
            // Create the primary property page
            CGeneralPage* pPage = new CGeneralPage();
            if(pPage == NULL)
            {
                return E_OUTOFMEMORY;
            }
            pPage->m_hConsoleHandle = handle;
            pBasePage = pPage;
*/
            return S_OK;
            break;
        }
        else
        {
            // switch on folder type
            CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);
            ASSERT(pFolder != NULL);
            if (pFolder == NULL)
                return E_INVALIDARG;

            //1
            CCertTemplateGeneralPage* pControlPage = new CCertTemplateGeneralPage(pFolder->m_hCertType);
            if(pControlPage == NULL)
            {
                return E_OUTOFMEMORY;
            }
            {
                pControlPage->m_hConsoleHandle = handle;   // only do this on primary
                pBasePage = pControlPage;
                HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
                if (hPage == NULL)
                {
                    delete (pControlPage);
                    return E_UNEXPECTED;
                }
                lpProvider->AddPage(hPage);
            }



            return S_OK;
        }
    }
        break;
    default:
            return S_OK;
    }


    // Object gets deleted when the page is destroyed
    ASSERT(lpProvider != NULL);


    HPROPSHEETPAGE hPage = CreatePropertySheetPage(&pBasePage->m_psp);
    if (hPage == NULL)
        return E_UNEXPECTED;

    lpProvider->AddPage(hPage);

    return S_OK;
}

STDMETHODIMP CSnapin::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    INTERNAL* pInternal = ExtractInternalFormat(lpDataObject);

    if(pInternal == NULL)
    {
        return E_POINTER;
    }
    ASSERT(pInternal);
    ASSERT(pInternal->m_type == CCT_RESULT);

    CFolder* pFolder = reinterpret_cast<CFolder*>(pInternal->m_cookie);

    FREE_DATA(pInternal);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\dataobj.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.


#include "stdafx.h"

#define __dwFILE__	__dwFILE_CAPESNPN_DATAOBJ_CPP__


///////////////////////////////////////////////////////////////////////////////
// Sample code to show how to Create DataObjects
// Minimal error checking for clarity

///////////////////////////////////////////////////////////////////////////////
// Snap-in NodeType in both GUID format and string format
// Note - Typically there is a node type for each different object, sample
// only uses one node type.

unsigned int CDataObject::m_cfNodeType       = 0;
unsigned int CDataObject::m_cfNodeTypeString = 0;  
unsigned int CDataObject::m_cfDisplayName    = 0; 
unsigned int CDataObject::m_cfCoClass        = 0; 

unsigned int CDataObject::m_cfInternal       = 0; 
unsigned int CDataObject::m_cfIsMultiSel     = 0;



    
// The only additional clipboard format supported is to get the workstation name.
unsigned int CDataObject::m_cfWorkstation    = 0;

/////////////////////////////////////////////////////////////////////////////
// CDataObject implementations

CDataObject::CDataObject()
{
	USES_CONVERSION;

	m_cfNodeType       = RegisterClipboardFormat(W2T(CCF_NODETYPE));
	m_cfNodeTypeString = RegisterClipboardFormat(W2T(CCF_SZNODETYPE));  
	m_cfDisplayName    = RegisterClipboardFormat(W2T(CCF_DISPLAY_NAME)); 
	m_cfCoClass        = RegisterClipboardFormat(W2T(CCF_SNAPIN_CLASSID)); 
    m_cfIsMultiSel     = RegisterClipboardFormat(W2T(CCF_OBJECT_TYPES_IN_MULTI_SELECT));
	m_cfInternal       = RegisterClipboardFormat(W2T((LPWSTR)SNAPIN_INTERNAL)); 
	m_cfWorkstation    = RegisterClipboardFormat(W2T((LPWSTR)SNAPIN_WORKSTATION));

    m_cbMultiSelData = 0;
    m_bMultiSelDobj = FALSE;
}

STDMETHODIMP CDataObject::QueryGetData(LPFORMATETC lpFormatetc)
{
	HRESULT hr = S_FALSE;

    if ( lpFormatetc )
    {
        const CLIPFORMAT cf = lpFormatetc->cfFormat;

        if ( cf == m_cfIsMultiSel )
        {
            // hr = S_FALSE; // always return this; MMC returns S_OK if ptr to SI_MS_DO
            hr = (m_bMultiSelDobj ? S_OK : S_FALSE);
        }
        else if (	cf == m_cfNodeType ||
                    cf == m_cfCoClass ||
                    cf == m_cfNodeTypeString ||
                    cf == m_cfDisplayName ||
                    cf == m_cfInternal 
		        )
        {
	        hr = S_OK;
        }
    }

    return hr;
}
STDMETHODIMP CDataObject::GetData(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    HRESULT hr = DV_E_CLIPFORMAT;

    if (lpFormatetc->cfFormat == m_cfIsMultiSel)
    {
        ASSERT(m_internal.m_cookie == MMC_MULTI_SELECT_COOKIE);
        if (m_internal.m_cookie != MMC_MULTI_SELECT_COOKIE)
            return E_FAIL;
        
        return CreateMultiSelData(lpMedium);
    }

    return hr;
}

STDMETHODIMP CDataObject::GetDataHere(LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_CLIPFORMAT;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    // Based on the CLIPFORMAT write data to the stream
    const CLIPFORMAT cf = lpFormatetc->cfFormat;

    if (cf == m_cfNodeType)
    {
        hr = CreateNodeTypeData(lpMedium);
    }
    else if (cf == m_cfCoClass)
    {
        hr = CreateCoClassID(lpMedium);
    }
    else if(cf == m_cfNodeTypeString) 
    {
        hr = CreateNodeTypeStringData(lpMedium);
    }
    else if (cf == m_cfDisplayName)
    {
        hr = CreateDisplayName(lpMedium);
    }
    else if (cf == m_cfInternal)
    {
        hr = CreateInternal(lpMedium);
    }
    else if (cf == m_cfWorkstation)
    {
        hr = CreateWorkstationName(lpMedium);
    }

    return hr;
}

STDMETHODIMP CDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CDataObject creation members

HRESULT CDataObject::Create(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
        return E_POINTER;

    // Make sure the type medium is HGLOBAL
    if (lpMedium->tymed == TYMED_HGLOBAL)
    {
        // Create the stream on the hGlobal passed in
        LPSTREAM lpStream;
        hr = CreateStreamOnHGlobal(lpMedium->hGlobal, FALSE, &lpStream);

        if (SUCCEEDED(hr))
        {
            // Write to the stream the number of bytes
            unsigned long written;

            if (NULL == lpMedium->hGlobal) 
            {
                // always return a valid hGlobal for the caller
                hr = GetHGlobalFromStream(lpStream, &lpMedium->hGlobal);
                if (hr != S_OK)
                    goto err;
            }

            hr = lpStream->Write(pBuffer, len, &written);

            // Because we told CreateStreamOnHGlobal with 'FALSE', 
            // only the stream is released here.
            // Note - the caller (i.e. snap-in, object) will free the HGLOBAL 
            // at the correct time.  This is according to the IDataObject specification.
            lpStream->Release();
        }
    }

err:
    return hr;
}

HRESULT CDataObject::CreateVariableLen(const void* pBuffer, int len, LPSTGMEDIUM lpMedium)
{
    HRESULT hr = DV_E_TYMED;
    BYTE* pb;

    // Do some simple validation
    if (pBuffer == NULL || lpMedium == NULL)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "Invalid args");
    }

    // Make sure the type medium is HGLOBAL
    lpMedium->tymed = TYMED_HGLOBAL; 

    lpMedium->hGlobal = ::GlobalAlloc(GMEM_SHARE|GMEM_MOVEABLE, (len));
    if (NULL == lpMedium->hGlobal)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "GlobalAlloc");
    }

    pb = reinterpret_cast<BYTE*>(::GlobalLock(lpMedium->hGlobal));
    CopyMemory(pb, pBuffer, len);
    ::GlobalUnlock(lpMedium->hGlobal);

    hr = S_OK;

error:
    return hr;
}


HRESULT CDataObject::CreateMultiSelData(LPSTGMEDIUM lpMedium)
{
    ASSERT(m_internal.m_cookie == MMC_MULTI_SELECT_COOKIE);

    ASSERT(m_cbMultiSelData != 0);

    return CreateVariableLen(&m_sGuidObjTypes, m_cbMultiSelData, lpMedium);
}

HRESULT CDataObject::CreateNodeTypeData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID format
    const GUID* pcObjectType = NULL;

    if (m_internal.m_type == CCT_SCOPE)
    {
        // reid fix
        CFolder* pFolder = reinterpret_cast<CFolder*>(m_internal.m_cookie);

        switch (pFolder->GetType())
        {
        case POLICYSETTINGS:
        case CA_CERT_TYPE:
            pcObjectType = &cNodeTypePolicySettings;
            break;

        case SCE_EXTENSION:
        case GLOBAL_CERT_TYPE:
            pcObjectType = &cNodeTypeCertificateTemplate;
            break;
        }
    }
    else if (m_internal.m_type == CCT_RESULT)
    {
        pcObjectType = &cObjectTypeResultItem;
    }

    return Create(reinterpret_cast<const void*>(pcObjectType), sizeof(GUID), 
                  lpMedium);
}

HRESULT CDataObject::CreateNodeTypeStringData(LPSTGMEDIUM lpMedium)
{
    // Create the node type object in GUID string format
    const WCHAR* cszObjectType = L"";

    if (m_internal.m_type == CCT_SCOPE)
    {
        CFolder* pFolder = reinterpret_cast<CFolder*>(m_internal.m_cookie);

        switch (pFolder->GetType())
        {
        case POLICYSETTINGS:
        case CA_CERT_TYPE:
            cszObjectType = cszNodeTypePolicySettings;
            break;

        case SCE_EXTENSION:
        case GLOBAL_CERT_TYPE:
            cszObjectType = cszNodeTypeCertificateTemplate;
            break;
        }
    }
    else if (m_internal.m_type == CCT_RESULT)
    {
        cszObjectType = cszObjectTypeResultItem;
    }

    ASSERT(cszObjectType[0] != 0);

    return Create(cszObjectType, ((wcslen(cszObjectType)+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateDisplayName(LPSTGMEDIUM lpMedium)
{
    // This is the display named used in the scope pane and snap-in manager

    // Load the name to display
    // Note - if this is not provided, the console will used the snap-in name
    CString szDispName;
    szDispName.LoadString(IDS_NODENAME_PREFIX);

    USES_CONVERSION;

	return Create(szDispName, ((szDispName.GetLength()+1) * sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateInternal(LPSTGMEDIUM lpMedium)
{
    return Create(&m_internal, sizeof(INTERNAL), lpMedium);
}

HRESULT CDataObject::CreateWorkstationName(LPSTGMEDIUM lpMedium)
{
    TCHAR pzName[MAX_COMPUTERNAME_LENGTH+1] = {0};
    DWORD len = MAX_COMPUTERNAME_LENGTH+1;

    if (GetComputerName(pzName, &len) == FALSE)
        return E_FAIL;

    // Add 1 for the NULL and calculate the bytes for the stream
	USES_CONVERSION;
    return Create(T2W(pzName), ((len+1)* sizeof(WCHAR)), lpMedium);
}

HRESULT CDataObject::CreateCoClassID(LPSTGMEDIUM lpMedium)
{
    // Create the CoClass information
    return Create(reinterpret_cast<const void*>(&m_internal.m_clsid), sizeof(CLSID), lpMedium);
}

ULONG CDataObject::AddCookie(MMC_COOKIE Cookie)
{
    m_rgCookies.Add(Cookie);
    return m_rgCookies.GetSize()-1;
}


STDMETHODIMP CDataObject::GetCookieAt(ULONG iCookie, MMC_COOKIE *pCookie)
{
    if((LONG)iCookie > m_rgCookies.GetSize())
    {
        return S_FALSE;
    }

    *pCookie = m_rgCookies[iCookie];

    return  S_OK;
}

STDMETHODIMP CDataObject::RemoveCookieAt(ULONG iCookie)
{
    if((LONG)iCookie > m_rgCookies.GetSize())
    {
        return S_FALSE;
    }
    m_rgCookies.RemoveAt(iCookie);

    return  S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\helparr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       helparr.h
//
//--------------------------------------------------------------------------



#define CAPESNPN_HELPFILENAME TEXT("capesnpn.hlp")

#define	IDH_SCT_CERTIFICATE_TYPE_LIST	70007125
#define	IDH_TP_CERTIFICATE_TEMPLATE_NAME	70007025
#define	IDH_TP_OTHER_INFO_LIST	70007027
#define	IDH_TP_PURPOSE_LIST	70007026


const DWORD g_aHelpIDs_IDD_SELECT_CERTIFICATE_TEMPLATE[]=
{
	IDC_CERTIFICATE_TYPE_LIST,IDH_SCT_CERTIFICATE_TYPE_LIST,
	0, 0
};


const DWORD g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE[]=
{
	IDC_CERTIFICATE_TEMPLATE_NAME,IDH_TP_CERTIFICATE_TEMPLATE_NAME,
	IDC_PURPOSE_LIST,IDH_TP_PURPOSE_LIST,
	IDC_OTHER_INFO_LIST,IDH_TP_OTHER_INFO_LIST,
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\genpage.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       genpage.cpp
//
//--------------------------------------------------------------------------

// genpage.cpp : implementation file
//

#include "stdafx.h"
#include "certca.h"
#include "tfcprop.h"
#include "genpage.h"

// sddl.h requires this value to be at least
// 0x0500.  Bump it up if necessary.  NOTE:  This
// 'bump' comes after all other H files that may
// be sensitive to this value.
#if(_WIN32_WINNT < 0x500)
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#include <sddl.h>
#include "helparr.h"

#define __dwFILE__	__dwFILE_CAPESNPN_GENPAGE_CPP__


#define DURATION_INDEX_YEARS    0
#define DURATION_INDEX_MONTHS   1
#define DURATION_INDEX_WEEKS    2
#define DURATION_INDEX_DAYS     3

void myDisplayError(HWND hwnd, HRESULT hr, UINT id)
{
    CString cstrTitle, cstrFullText;
    cstrTitle.LoadString(IDS_SNAPIN_NAME);

    if (hr != S_OK)
    {
        WCHAR const *pwszError = myGetErrorMessageText(hr, TRUE);

        cstrFullText = pwszError;

        // Free the buffer
        if (NULL != pwszError)
	{
            LocalFree(const_cast<WCHAR *>(pwszError));
	}
    }

    if (id != -1)
    {
        CString cstrMsg;
        cstrMsg.LoadString(id);
        cstrFullText += cstrMsg;
    }

    ::MessageBoxW(hwnd, cstrFullText, cstrTitle, MB_OK | MB_ICONERROR);
}

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
// replacement for DoDataExchange
BOOL CAutoDeletePropPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
//        m_cstrModuleName.FromWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    else
    {
//        m_cstrModuleName.ToWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    return TRUE;
}

// replacement for BEGIN_MESSAGE_MAP
BOOL CAutoDeletePropPage::OnCommand(WPARAM wParam, LPARAM lParam)
{

/*
    switch(LOWORD(wParam))
    {
    default:
        return FALSE;
        break;
    }
*/
    return TRUE;
}

/////////////////////////////////////////////////////////////////////
//	Constructor
CAutoDeletePropPage::CAutoDeletePropPage(UINT uIDD) : PropertyPage(uIDD)
{
	m_prgzHelpIDs = NULL;
	m_autodeleteStuff.cWizPages = 1; // Number of pages in wizard
	m_autodeleteStuff.pfnOriginalPropSheetPageProc = m_psp.pfnCallback;


    m_psp.dwFlags |= PSP_USECALLBACK;
	m_psp.pfnCallback = S_PropSheetPageProc;
	m_psp.lParam = reinterpret_cast<LPARAM>(this);
}

CAutoDeletePropPage::~CAutoDeletePropPage()
{
}


/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetCaption(LPCTSTR pszCaption)
{
    m_strCaption = pszCaption;		// Copy the caption
    m_psp.pszTitle = m_strCaption;	// Set the title
    m_psp.dwFlags |= PSP_USETITLE;
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetCaption(UINT uStringID)
{
    VERIFY(m_strCaption.LoadString(uStringID));
    SetCaption(m_strCaption);
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::SetHelp(LPCTSTR szHelpFile, const DWORD rgzHelpIDs[])
{
    //szHelpFile == NULL;	// TRUE => No help file supplied (meaning no help)
    //rgzHelpIDs == NULL;	// TRUE => No help at all
    m_strHelpFile = szHelpFile;
    m_prgzHelpIDs = rgzHelpIDs;
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::EnableDlgItem(INT nIdDlgItem, BOOL fEnable)
{
    ASSERT(IsWindow(::GetDlgItem(m_hWnd, nIdDlgItem)));
    ::EnableWindow(::GetDlgItem(m_hWnd, nIdDlgItem), fEnable);
}

/////////////////////////////////////////////////////////////////////
BOOL CAutoDeletePropPage::OnSetActive()
{
    HWND hwndParent = ::GetParent(m_hWnd);
    ASSERT(IsWindow(hwndParent));
    ::PropSheet_SetWizButtons(hwndParent, PSWIZB_FINISH);
    return PropertyPage::OnSetActive();
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::OnContextHelp(HWND hwnd)
{
    if (m_prgzHelpIDs == NULL || m_strHelpFile.IsEmpty())
        return;
    ASSERT(IsWindow(hwnd));

    if(HasContextHelp(GetDlgCtrlID(hwnd)))
    {
        ::WinHelp(
            hwnd, 
            m_strHelpFile, 
            HELP_CONTEXTMENU, 
            (ULONG_PTR)(LPVOID)m_prgzHelpIDs);
    }
    return;
}

/////////////////////////////////////////////////////////////////////
void CAutoDeletePropPage::OnHelp(LPHELPINFO pHelpInfo)
{
    if (m_prgzHelpIDs == NULL || m_strHelpFile.IsEmpty())
        return;
    if (pHelpInfo != NULL && 
        pHelpInfo->iContextType == HELPINFO_WINDOW &&
        HasContextHelp(pHelpInfo->iCtrlId))
    {
        // Display context help for a control
        ::WinHelp((HWND)pHelpInfo->hItemHandle, m_strHelpFile,
            HELP_WM_HELP, (ULONG_PTR)(LPVOID)m_prgzHelpIDs);
    }
    return;
}

/////////////////////////////////////////////////////////////////////
bool CAutoDeletePropPage::HasContextHelp(int nDlgItem)
{
    const DWORD * pdwHelpIDs;

    for(pdwHelpIDs = m_prgzHelpIDs; 
        *pdwHelpIDs; 
        pdwHelpIDs += 2)
    {
        if(nDlgItem == *pdwHelpIDs)
            return true;
    }
    return false;
}

/////////////////////////////////////////////////////////////////////
//	S_PropSheetPageProc()
//
//	Static member function used to delete the CAutoDeletePropPage object
//	when wizard terminates
//
UINT CALLBACK CAutoDeletePropPage::S_PropSheetPageProc(
                                                       HWND hwnd,	
                                                       UINT uMsg,	
                                                       LPPROPSHEETPAGE ppsp)
{
    ASSERT(ppsp != NULL);
    CAutoDeletePropPage *pThis;
    pThis = reinterpret_cast<CAutoDeletePropPage*>(ppsp->lParam);
    ASSERT(pThis != NULL);

    BOOL fDefaultRet;

    switch (uMsg)
    {
    case PSPCB_RELEASE:
        fDefaultRet = FALSE;
        if (--(pThis->m_autodeleteStuff.cWizPages) <= 0)
        {
            // Remember callback on stack since "this" will be deleted
            LPFNPSPCALLBACK pfnOrig = pThis->m_autodeleteStuff.pfnOriginalPropSheetPageProc;
            delete pThis;

            if (pfnOrig)
                return (pfnOrig)(hwnd, uMsg, ppsp);
            else
                return fDefaultRet;
        }
        break;
    case PSPCB_CREATE:
        fDefaultRet = TRUE;
        // do not increase refcount, PSPCB_CREATE may or may not be called
        // depending on whether the page was created.  PSPCB_RELEASE can be
        // depended upon to be called exactly once per page however.
        break;

    } // switch
    if (pThis->m_autodeleteStuff.pfnOriginalPropSheetPageProc)
        return (pThis->m_autodeleteStuff.pfnOriginalPropSheetPageProc)(hwnd, uMsg, ppsp);
    else
        return fDefaultRet;
} // CAutoDeletePropPage::S_PropSheetPageProc()




//////////////////////////////
// hand-hewn pages

////
// 1



///////////////////////////////////////////
// CCertTemplateGeneralPage
/////////////////////////////////////////////////////////////////////////////
// CCertTemplateGeneralPage property page
CCertTemplateGeneralPage::CCertTemplateGeneralPage(HCERTTYPE hCertType, UINT uIDD)
    : CAutoDeletePropPage(uIDD), m_hCertType(hCertType)
{
    m_hConsoleHandle = NULL;
    m_bUpdate = FALSE;
    SetHelp(CAPESNPN_HELPFILENAME , g_aHelpIDs_IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE);
}

CCertTemplateGeneralPage::~CCertTemplateGeneralPage()
{
}

// replacement for DoDataExchange
BOOL CCertTemplateGeneralPage::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
//        m_cstrModuleName.FromWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    else
    {
//        m_cstrModuleName.ToWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    return TRUE;
}
// replacement for BEGIN_MESSAGE_MAP
BOOL CCertTemplateGeneralPage::OnCommand(WPARAM wParam, LPARAM lParam)
{
/*
    switch(LOWORD(wParam))
    {
    default:
        return FALSE;
        break;
    }
    */
    return TRUE;
}
/////////////////////////////////////////////////////////////////////////////
// CCertTemplateGeneralPage message handlers

void CCertTemplateGeneralPage::OnDestroy()
{
    // Note - This needs to be called only once.
    // If called more than once, it will gracefully return an error.
    if (m_hConsoleHandle)
        MMCFreeNotifyHandle(m_hConsoleHandle);
    m_hConsoleHandle = NULL;

    CAutoDeletePropPage::OnDestroy();
}


void CCertTemplateGeneralPage::SetItemTextWrapper(UINT nID, int *piItem, BOOL fDoInsert, BOOL *pfFirstUsageItem)
{
    CString szOtherInfoName;

    if (fDoInsert)
    {
        szOtherInfoName.LoadString(nID);
        if (!(*pfFirstUsageItem))
        {
	        ListView_NewItem(m_hwndOtherInfoList, *piItem, L"");
        }
        else
        {
            *pfFirstUsageItem = FALSE;
        }

        ListView_SetItemText(m_hwndOtherInfoList, *piItem, 1, (LPWSTR)(LPCWSTR)szOtherInfoName);
        (*piItem)++;
    }
}

BOOL CCertTemplateGeneralPage::OnInitDialog()
{
    // does parent init and UpdateData call
    CAutoDeletePropPage::OnInitDialog();

    m_hwndPurposesList = GetDlgItem(m_hWnd, IDC_PURPOSE_LIST);
    m_hwndOtherInfoList = GetDlgItem(m_hWnd, IDC_OTHER_INFO_LIST);

    int                 i=0;
    CString             **aszUsages = NULL;
    DWORD               cNumUsages;
    WCHAR               **pszNameArray = NULL;
    CString             szOtherInfoName;
    CRYPT_BIT_BLOB      *pBitBlob;
    BOOL                fPublicKeyUsageCritical;
    BOOL                bKeyUsageFirstItem = TRUE;
    BOOL                fCA;
    BOOL                fPathLenConstraint;
    DWORD               dwPathLenConstraint;
    WCHAR               szNumberString[256];
    CString             szAll;
    BOOL                fEKUCritical;
    DWORD               dwFlags;
    HRESULT             hr;

    //
    // get the name of the certificate template and set it in the dialog
    //
    if((S_OK == CAGetCertTypeProperty(m_hCertType, CERTTYPE_PROP_FRIENDLY_NAME, &pszNameArray)) &&
        (pszNameArray != NULL))
    {
        SendMessage(GetDlgItem(m_hWnd, IDC_CERTIFICATE_TEMPLATE_NAME), EM_SETSEL, 0, -1);
        SendMessage(GetDlgItem(m_hWnd, IDC_CERTIFICATE_TEMPLATE_NAME), EM_REPLACESEL, FALSE, (LPARAM)(LPCWSTR)pszNameArray[0]);
        CAFreeCertTypeProperty(m_hCertType, pszNameArray);
    }

    //
    // get the list of purposes for this certificate template and
    // add all of them to the list in the dialog
    //
    ListView_NewColumn(m_hwndPurposesList, 0, 200);

    if(!MyGetEnhancedKeyUsages(m_hCertType, NULL, &cNumUsages, &fEKUCritical, FALSE))
    {
        return FALSE;
    }

    if (cNumUsages == 0)
    {
        szAll.LoadString(IDS_ALL);
		ListView_NewItem(m_hwndPurposesList, i, szAll);
    }
    else
    {

        aszUsages = new CString*[cNumUsages];
        if(!aszUsages)
            return FALSE;

        if(!MyGetEnhancedKeyUsages(m_hCertType, aszUsages, &cNumUsages, &fEKUCritical, FALSE))
        {
            delete[] aszUsages;
            return FALSE;
        }

        for (i=0; i<(LONG)cNumUsages; i++)
        {
			ListView_NewItem(m_hwndPurposesList, i, *(aszUsages[i]));
            delete(aszUsages[i]);
        }

        delete[] aszUsages;
    }

    ListView_SetColumnWidth(m_hwndPurposesList, 0, LVSCW_AUTOSIZE);

    //
    // add the other certificate type info
    //

    ListView_NewColumn(m_hwndOtherInfoList, 0, 200);
    ListView_NewColumn(m_hwndOtherInfoList, 1, 200);

    //
    // add include email address flag to other certificate type info
    //
    szOtherInfoName.LoadString(IDS_INCLUDE_EMAIL_ADDRESS);

    i = 0;
	ListView_NewItem(m_hwndOtherInfoList, i, szOtherInfoName);

    hr = CAGetCertTypeFlags(m_hCertType, &dwFlags);
    if (FAILED(hr))
    {
        return FALSE;
    }

    if (dwFlags & CT_FLAG_ADD_EMAIL)
        szOtherInfoName.LoadString(IDS_YES);
    else
        szOtherInfoName.LoadString(IDS_NO);

    ListView_SetItemText(m_hwndOtherInfoList, i++, 1, (LPWSTR)(LPCWSTR)szOtherInfoName);

    //
    // add key usages to other certificate type info
    //

    if (MyGetKeyUsages(m_hCertType, &pBitBlob, &fPublicKeyUsageCritical))
    {
        szOtherInfoName.LoadString(IDS_PUBLIC_KEY_USAGE_LIST);
		ListView_NewItem(m_hwndOtherInfoList, i, szOtherInfoName);


        if (pBitBlob->cbData >= 1)
        {
            SetItemTextWrapper(
                    IDS_DIGITAL_SIGNATURE_KEY_USAGE,
                    &i,
                    pBitBlob->pbData[0] & CERT_DIGITAL_SIGNATURE_KEY_USAGE,
                    &bKeyUsageFirstItem);

            SetItemTextWrapper(
                    IDS_NON_REPUDIATION_KEY_USAGE,
                    &i,
                    pBitBlob->pbData[0] & CERT_NON_REPUDIATION_KEY_USAGE,
                    &bKeyUsageFirstItem);

            SetItemTextWrapper(
                    IDS_KEY_ENCIPHERMENT_KEY_USAGE,
                    &i,
                    pBitBlob->pbData[0] & CERT_KEY_ENCIPHERMENT_KEY_USAGE,
                    &bKeyUsageFirstItem);

            SetItemTextWrapper(
                    IDS_DATA_ENCIPHERMENT_KEY_USAGE,
                    &i,
                    pBitBlob->pbData[0] & CERT_DATA_ENCIPHERMENT_KEY_USAGE,
                    &bKeyUsageFirstItem);

            SetItemTextWrapper(
                    IDS_KEY_AGREEMENT_KEY_USAGE,
                    &i,
                    pBitBlob->pbData[0] & CERT_KEY_AGREEMENT_KEY_USAGE,
                    &bKeyUsageFirstItem);

            SetItemTextWrapper(
                    IDS_KEY_CERT_SIGN_KEY_USAGE,
                    &i,
                    pBitBlob->pbData[0] & CERT_KEY_CERT_SIGN_KEY_USAGE,
                    &bKeyUsageFirstItem);

           SetItemTextWrapper(
                    IDS_OFFLINE_CRL_SIGN_KEY_USAGE,
                    &i,
                    pBitBlob->pbData[0] & CERT_OFFLINE_CRL_SIGN_KEY_USAGE,
                    &bKeyUsageFirstItem);

           SetItemTextWrapper(
                    IDS_ENCIPHER_ONLY_KEY_USAGE,
                    &i,
                    pBitBlob->pbData[0] & CERT_ENCIPHER_ONLY_KEY_USAGE,
                    &bKeyUsageFirstItem);
        }

        if (pBitBlob->cbData >= 2)
        {
            SetItemTextWrapper(
                    IDS_DECIPHER_ONLY_KEY_USAGE,
                    &i,
                    pBitBlob->pbData[1] & CERT_DECIPHER_ONLY_KEY_USAGE,
                    &bKeyUsageFirstItem);
        }

        szOtherInfoName.LoadString(IDS_PUBLIC_KEY_USAGE_CRITICAL);
		ListView_NewItem(m_hwndOtherInfoList, i, szOtherInfoName);


        if (fPublicKeyUsageCritical)
            szOtherInfoName.LoadString(IDS_YES);
        else
            szOtherInfoName.LoadString(IDS_NO);
        ListView_SetItemText(m_hwndOtherInfoList, i++, 1, (LPWSTR)(LPCWSTR)szOtherInfoName);

        delete[]((BYTE *)pBitBlob);
    }

    //
    // maybe we should add a display of whether this is a ca cert or not
    //
/*
    if (MyGetBasicConstraintInfo(m_hCertType, &fCA, &fPathLenConstraint, &dwPathLenConstraint))
    {

    }
*/

    ListView_SetColumnWidth(m_hwndOtherInfoList, 0, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(m_hwndOtherInfoList, 1, LVSCW_AUTOSIZE);

    return TRUE;
}

BOOL CCertTemplateGeneralPage::OnApply()
{
	DWORD dwRet;

    if (m_bUpdate == TRUE)
    {
        m_bUpdate = FALSE;
    }
	
    return CAutoDeletePropPage::OnApply();
}




/////////////////////////////////////////////////////////////////////////////
// CCertTemplateSelectDialog property page
CCertTemplateSelectDialog::CCertTemplateSelectDialog(HWND hParent) :
    m_hCAInfo(NULL)
{
     SetHelp(CAPESNPN_HELPFILENAME , g_aHelpIDs_IDD_SELECT_CERTIFICATE_TEMPLATE);

}

CCertTemplateSelectDialog::~CCertTemplateSelectDialog()
{
}

// replacement for DoDataExchange
BOOL CCertTemplateSelectDialog::UpdateData(BOOL fSuckFromDlg /*= TRUE*/)
{
    if (fSuckFromDlg)
    {
//        m_cstrModuleName.FromWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    else
    {
//        m_cstrModuleName.ToWindow(GetDlgItem(m_hWnd, IDC_MODULENAME));
    }
    return TRUE;
}
// replacement for BEGIN_MESSAGE_MAP
BOOL CCertTemplateSelectDialog::OnCommand(WPARAM wParam, LPARAM lParam)
{
/*
    switch(LOWORD(wParam))
    {
    default:
        return FALSE;
        break;
    }
    */
    return TRUE;
}

BOOL CCertTemplateSelectDialog::OnNotify(UINT idCtrl, NMHDR* pnmh)
{
    switch(idCtrl)
    {
    case IDC_CERTIFICATE_TYPE_LIST:
        if (LVN_ITEMCHANGED == pnmh->code)
        {
            OnSelChange(pnmh);
            break;
        }
        else if (NM_DBLCLK == pnmh->code)
        {
            SendMessage(m_hDlg, WM_COMMAND, IDOK, NULL);
            break;
        }
    default:
        return FALSE;
    }

    return TRUE;
}

BOOL CertTypeAlreadyExists(WCHAR *szCertTypeName, WCHAR **aszCertTypesCurrentlySupported)
{
    int i = 0;

    //
    // if there are no cert types then obvisously this one doesn't already exist
    //
    if (aszCertTypesCurrentlySupported == NULL)
    {
        return FALSE;
    }

    while (aszCertTypesCurrentlySupported[i] != NULL)
    {
        if (wcscmp(szCertTypeName, aszCertTypesCurrentlySupported[i]) == 0)
        {
            return TRUE;
        }
        i++;
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////
void CCertTemplateSelectDialog::SetHelp(LPCTSTR szHelpFile, const DWORD rgzHelpIDs[])
	{
	//szHelpFile == NULL;	// TRUE => No help file supplied (meaning no help)
	//rgzHelpIDs == NULL;	// TRUE => No help at all
	m_strHelpFile = szHelpFile;
	m_prgzHelpIDs = rgzHelpIDs;
	}

/////////////////////////////////////////////////////////////////////
void CCertTemplateSelectDialog::OnContextHelp(HWND hwnd)
{
    if (m_prgzHelpIDs == NULL || m_strHelpFile.IsEmpty())
        return;
    ASSERT(IsWindow(hwnd));

    if(HasContextHelp(GetDlgCtrlID(hwnd)))
    {
        ::WinHelp(
            hwnd, 
            m_strHelpFile, 
            HELP_CONTEXTMENU, 
            (ULONG_PTR)(LPVOID)m_prgzHelpIDs);
    }
    return;
}

/////////////////////////////////////////////////////////////////////
void CCertTemplateSelectDialog::OnHelp(LPHELPINFO pHelpInfo)
{
    if (m_prgzHelpIDs == NULL || m_strHelpFile.IsEmpty())
        return;
    if (pHelpInfo != NULL && 
        pHelpInfo->iContextType == HELPINFO_WINDOW &&
        HasContextHelp(pHelpInfo->iCtrlId))
    {
        // Display context help for a control
        ::WinHelp((HWND)pHelpInfo->hItemHandle, m_strHelpFile,
            HELP_WM_HELP, (ULONG_PTR)(LPVOID)m_prgzHelpIDs);
    }
    return;
}

/////////////////////////////////////////////////////////////////////
bool CCertTemplateSelectDialog::HasContextHelp(int nDlgItem)
{
    const DWORD * pdwHelpIDs;

    for(pdwHelpIDs = m_prgzHelpIDs; 
        *pdwHelpIDs; 
        pdwHelpIDs += 2)
    {
        if(nDlgItem == *pdwHelpIDs)
            return true;
    }
    return false;
}

int CALLBACK CertTemplCompareFunc(
    LPARAM lParam1, 
    LPARAM lParam2, 
	LPARAM lParamSort)
{
    BOOL fSortAscending = (BOOL)lParamSort;
    HCERTTYPE hCertTypeLeft = (HCERTTYPE)lParam1;
    HCERTTYPE hCertTypeRight = (HCERTTYPE)lParam2;
    WCHAR ** ppwszFriendlyNameLeft = NULL;
    WCHAR ** ppwszFriendlyNameRight = NULL;
    int nRet;

    CAGetCertTypeProperty(
            hCertTypeLeft,
            CERTTYPE_PROP_FRIENDLY_NAME,
            &ppwszFriendlyNameLeft);

    CAGetCertTypeProperty(
            hCertTypeRight,
            CERTTYPE_PROP_FRIENDLY_NAME,
            &ppwszFriendlyNameRight);


    if(!ppwszFriendlyNameLeft ||  
       !ppwszFriendlyNameLeft[0] ||
       !ppwszFriendlyNameRight ||  
       !ppwszFriendlyNameRight[0])
       return 0; // couldn't figure it out

    nRet = wcscmp(ppwszFriendlyNameLeft[0], ppwszFriendlyNameRight[0]);

    CAFreeCertTypeProperty(
            hCertTypeLeft,
            ppwszFriendlyNameLeft);

    CAFreeCertTypeProperty(
            hCertTypeRight,
            ppwszFriendlyNameRight);

    return nRet;
}


/////////////////////////////////////////////////////////////////////////////
// CCertTemplateSelectDialog message handlers
BOOL CCertTemplateSelectDialog::OnInitDialog(HWND hDlg)
{
    // does parent init and UpdateData call
    m_hwndCertTypeList = GetDlgItem(hDlg, IDC_CERTIFICATE_TYPE_LIST);

    CString             szColumnHeading;
    HRESULT             hr;
    HCERTTYPE           hCertTypeNext;
    HCERTTYPE           hCertTypePrev;
    WCHAR **            aszCertTypeName;
    WCHAR **            aszCertTypeCN;
    int                 i = 0;
    CString             szUsageString;
    DWORD               dwVersion;

    m_hDlg = hDlg;

    ::SetWindowLong(m_hDlg, GWL_EXSTYLE, ::GetWindowLong(m_hDlg, GWL_EXSTYLE) | WS_EX_CONTEXTHELP);
    ListView_SetExtendedListViewStyle(GetDlgItem(m_hDlg, IDC_CERTIFICATE_TYPE_LIST), LVS_EX_FULLROWSELECT);


    hr = myRetrieveCATemplateList(m_hCAInfo, FALSE, m_TemplateList);
    if(S_OK != hr)
    {
        MyErrorBox(hDlg, IDS_CERTTYPE_INFO_FAIL ,IDS_SNAPIN_NAME, hr);
        return TRUE;
    }

    HIMAGELIST hImgList = ImageList_LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_16x16), 16, 1, RGB(255, 0, 255));
    ListView_SetImageList(m_hwndCertTypeList, hImgList, LVSIL_SMALL);


    szColumnHeading.LoadString(IDS_COLUMN_NAME);
    ListView_NewColumn(m_hwndCertTypeList, 0, 200, szColumnHeading);


    szColumnHeading.LoadString(IDS_COLUMN_INTENDED_PURPOSE);
    ListView_NewColumn(m_hwndCertTypeList, 1, 200, szColumnHeading);

    hr = CAEnumCertTypes(CT_ENUM_USER_TYPES |
                         CT_ENUM_MACHINE_TYPES |
                         CT_FLAG_NO_CACHE_LOOKUP,
                         &hCertTypeNext
                         );
    // display error in getting 1st element
    if (hr != S_OK)
    {
        MyErrorBox(hDlg, IDS_CERTTYPE_INFO_FAIL ,IDS_SNAPIN_NAME, hr);
        return TRUE;
    }
    else if (hCertTypeNext == NULL)
    {
        myDisplayError(hDlg, S_OK, IDS_NO_TEMPLATES);
    }

    while ((hCertTypeNext != NULL) && (!FAILED(hr)))
    {
        //
        // get the CN of the cert type being processed, and if it already
        // exists in the list of currently supported types then move on
        // to the next one
        //
        hr = CAGetCertTypeProperty(
                    hCertTypeNext,
                    CERTTYPE_PROP_DN,
                    &aszCertTypeCN);
	_PrintIfErrorStr(hr, "CAGetCertTypeProperty", CERTTYPE_PROP_DN);

        if(hr == S_OK)
        {

            hr = CAGetCertTypePropertyEx (
                hCertTypeNext,
                CERTTYPE_PROP_SCHEMA_VERSION,
                &dwVersion);
	    _PrintIfErrorStr(
		    hr,
		    "CAGetCertTypeProperty",
		    CERTTYPE_PROP_SCHEMA_VERSION);

            if(S_OK == hr &&
               (m_fAdvancedServer || dwVersion==CERTTYPE_SCHEMA_VERSION_1))
            {

                if((aszCertTypeCN != NULL) &&
                    (aszCertTypeCN[0] != NULL) &&
                   (_wcsicmp(aszCertTypeCN[0], wszCERTTYPE_CA) != 0) &&
                   (!m_TemplateList.TemplateExistsName(aszCertTypeCN[0])))
                {
                    //
                    // the cert type is not already supported so add it to the list of choices
                    //
                    hr = CAGetCertTypeProperty(
					hCertTypeNext,
					CERTTYPE_PROP_FRIENDLY_NAME,
					&aszCertTypeName);
		    _PrintIfErrorStr(
			    hr,
			    "CAGetCertTypeProperty",
			    CERTTYPE_PROP_FRIENDLY_NAME);
		    if (S_OK == hr && NULL != aszCertTypeName)
		    {
			if (NULL != aszCertTypeName[0])
			{
			    if (!GetIntendedUsagesString(
						hCertTypeNext,
						&szUsageString) ||
				szUsageString == L"")
			    {
				szUsageString.LoadString(IDS_ALL);
			    }

			    LVITEM lvItem;
			    lvItem.mask = LVIF_IMAGE | LVIF_TEXT;

			    // nImage - the certificate template image is #2

			    lvItem.iImage = 2;
			    lvItem.iSubItem = 0;
			    lvItem.pszText = aszCertTypeName[0];
			    lvItem.iItem = ListView_NewItem(
						    m_hwndCertTypeList,
						    i,
						    aszCertTypeName[0],
						    (LPARAM) hCertTypeNext);
			    // set other attribs

			    ListView_SetItem(m_hwndCertTypeList, &lvItem);

			    ListView_SetItemText(
					    m_hwndCertTypeList,
					    i++,
					    1,
					    (LPWSTR) (LPCTSTR) szUsageString);
			}
			CAFreeCertTypeProperty(hCertTypeNext, aszCertTypeName);
		    }
                }
            }

            CAFreeCertTypeProperty(
                        hCertTypeNext,
                        aszCertTypeCN);
        }

        hCertTypePrev = hCertTypeNext;
        hCertTypeNext = NULL;
        hr = CAEnumNextCertType(hCertTypePrev, &hCertTypeNext);
    }

    ListView_SetColumnWidth(m_hwndCertTypeList, 0, LVSCW_AUTOSIZE);
    ListView_SetColumnWidth(m_hwndCertTypeList, 1, LVSCW_AUTOSIZE);

    ListView_SortItems(m_hwndCertTypeList, CertTemplCompareFunc, TRUE);

    UpdateData(FALSE);
    return TRUE;
}

void CCertTemplateSelectDialog::OnDestroy()
{
    int         i = 0;
    int         iCount = ListView_GetItemCount(m_hwndCertTypeList);


    for (i=0; i<iCount; i++)
    {
        HCERTTYPE hCT = (HCERTTYPE)ListView_GetItemData(m_hwndCertTypeList, i);
        CACloseCertType(hCT);
    }

    //
    // does this actually need to be done?
    //
    //(m_CertTypeCListCtrl.GetImageList(LVSIL_SMALL))->DeleteImageList();
}

void CCertTemplateSelectDialog::OnSelChange(NMHDR * pNotifyStruct/*, LRESULT * result*/)
{
    LPNMLISTVIEW        pListItem = (LPNMLISTVIEW) pNotifyStruct;

    if (pListItem->uNewState & LVIS_SELECTED)
    {
    }
}


void CCertTemplateSelectDialog::OnOK()
{
    int         i;
    HRESULT     hr;
    UINT        cSelectedItems;
    HCERTTYPE   hSelectedCertType;
    int         itemIndex;

    cSelectedItems = ListView_GetSelectedCount(m_hwndCertTypeList);

    if (cSelectedItems != 0)
    {
        //
        // get each selected item and add its cert type to the array
        //
        itemIndex = ListView_GetNextItem(m_hwndCertTypeList, -1, LVNI_ALL | LVNI_SELECTED);
        while (itemIndex != -1)
        {
			HCERTTYPE hCT = (HCERTTYPE)ListView_GetItemData(m_hwndCertTypeList, itemIndex);
            hr = myAddToCATemplateList(m_hCAInfo, m_TemplateList, hCT, FALSE);
            if(FAILED(hr))
                return;
            itemIndex = ListView_GetNextItem(m_hwndCertTypeList, itemIndex, LVNI_ALL | LVNI_SELECTED);
        }

        hr = UpdateCATemplateList(m_hDlg, m_hCAInfo, m_TemplateList);
        if (S_OK != hr)
        {
            if ((HRESULT) ERROR_CANCELLED != hr)
            {
                MyErrorBox(m_hDlg, IDS_FAILED_CA_UPDATE ,IDS_SNAPIN_NAME, hr);
            }

            // Set the old values back.
            itemIndex = ListView_GetNextItem(m_hwndCertTypeList, -1, LVNI_ALL | LVNI_SELECTED);
            while (itemIndex != -1)
            {
				HCERTTYPE hCT = (HCERTTYPE)ListView_GetItemData(m_hwndCertTypeList, itemIndex);
                myRemoveFromCATemplateList(m_hCAInfo, m_TemplateList, hCT);

                itemIndex = ListView_GetNextItem(m_hwndCertTypeList, itemIndex, LVNI_ALL | LVNI_SELECTED);
            }
        }
    }
}


void CCertTemplateSelectDialog::SetCA(HCAINFO hCAInfo, bool fAdvancedServer)
{
    m_hCAInfo = hCAInfo;
    m_fAdvancedServer = fAdvancedServer;
}


INT_PTR SelectCertTemplateDialogProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    CCertTemplateSelectDialog* pParam;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            // remember PRIVATE_DLGPROC_QUERY_LPARAM
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);
            pParam = (CCertTemplateSelectDialog*)lParam;

			return pParam->OnInitDialog(hwndDlg);
			break;
        }
    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
			pParam = (CCertTemplateSelectDialog*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
			if (pParam == NULL)
				break;
			pParam->OnOK();
            EndDialog(hwndDlg, LOWORD(wParam));
			break;

        case IDCANCEL:
			pParam = (CCertTemplateSelectDialog*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
			if (pParam == NULL)
				break;
			//pParam->OnCancel();
            EndDialog(hwndDlg, LOWORD(wParam));
            break;
        default:
			pParam = (CCertTemplateSelectDialog*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
			if (pParam == NULL)
				break;
			return pParam->OnCommand(wParam, lParam);
            break;
        }
	case WM_NOTIFY:
		pParam = (CCertTemplateSelectDialog*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
		if (pParam == NULL)
			break;
		return pParam->OnNotify((int)wParam, (NMHDR*)lParam);
		break;

	case WM_DESTROY:
		pParam = (CCertTemplateSelectDialog*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
		if (pParam == NULL)
			break;
		pParam->OnDestroy();
		break;
    case WM_HELP:
    {
        pParam = (CCertTemplateSelectDialog*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pParam == NULL)
            break;
        pParam->OnHelp((LPHELPINFO) lParam);
        break;
    }
    case WM_CONTEXTMENU:
    {
        pParam = (CCertTemplateSelectDialog*)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);
        if (pParam == NULL)
            break;
        pParam->OnContextHelp((HWND)wParam);
        break;
    }
    default:
        break;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\misc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       misc.h
//
//--------------------------------------------------------------------------

#ifndef __MISC_H_
#define __MISC_H_


// count the number of bytes needed to fully store the WSZ
#define WSZ_BYTECOUNT(__z__)   \
    ( (__z__ == NULL) ? 0 : (wcslen(__z__)+1)*sizeof(WCHAR) )


#define IDM_NEW_CERTTYPE 1
#define IDM_EDIT_GLOBAL_CERTTYPE 2
#define IDM_MANAGE 3

#define wszSNAPIN_FILENAME L"capesnpn.dll"

LPCWSTR GetNullMachineName(CString* pcstr);

STDMETHODIMP CStringLoad(CString& cstr, IStream *pStm);
STDMETHODIMP CStringSave(CString& cstr, IStream *pStm, BOOL fClearDirty);

void DisplayGenericCertSrvError(LPCONSOLE2 pConsole, DWORD dwErr);
LPWSTR BuildErrorMessage(DWORD dwErr);
BOOL FileTimeToLocalTimeString(FILETIME* pftGMT, LPWSTR* ppszTmp);

BOOL MyGetEnhancedKeyUsages(HCERTTYPE hCertType, CString **aszUsages, DWORD *cUsages, BOOL *pfCritical, BOOL fGetOIDSNotNames);
BOOL GetIntendedUsagesString(HCERTTYPE hCertType, CString *pUsageString);
BOOL MyGetKeyUsages(HCERTTYPE hCertType, CRYPT_BIT_BLOB **ppBitBlob, BOOL *pfPublicKeyUsageCritical);
BOOL MyGetBasicConstraintInfo(HCERTTYPE hCertType, BOOL *pfCA, BOOL *pfPathLenConstraint, DWORD *pdwPathLenConstraint);

LPSTR MyMkMBStr(LPCWSTR pwsz);
LPWSTR MyMkWStr(LPCSTR psz);

void MyErrorBox(HWND hwndParent, UINT nIDText, UINT nIDCaption, DWORD dwErrorCode = 0);

LPSTR AllocAndCopyStr(LPCSTR psz);
LPWSTR AllocAndCopyStr(LPCWSTR pwsz);
BOOL MyGetOIDInfo(LPWSTR string, DWORD stringSize, LPSTR pszObjId);

HRESULT
UpdateCATemplateList(
    IN HWND hwndParent,
    IN HCAINFO hCAInfo,
    IN const CTemplateList& list);

#endif //__MISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by snapin.rc
//
#define IDS_SNAPIN_DESC                 1
#define IDS_COLUMN_NAME                 2
#define IDC_REMOVE_BUTTON               2
#define IDS_SIZE                        3
#define IDS_COLUMN_SIZE                 3
#define IDS_TYPE                        4
#define IDS_COLUMN_TYPE                 4
#define IDS_NODENAME                    5
#define IDS_COLUMN_INTENDED_PURPOSE     5
#define IDS_ERROR_WIN2000_AD_LAUNCH_NOT_SUPPORTED 6
#define IDS_NODENAME_PREFIX             12
#define IDS_SNAPIN_NAME                 15
#define IDS_CERTIFICATE_TYPE            16
#define IDS_CERTIFICATE_TYPE_HINT       17
#define IDS_POLICYSETTINGS              18
#define IDS_INCLUDE_EMAIL_ADDRESS       19
#define IDS_PUBLIC_KEY_USAGE_LIST       20
#define IDS_PUBLIC_KEY_USAGE_CRITICAL   21
#define IDS_DIGITAL_SIGNATURE_KEY_USAGE 23
#define IDS_NON_REPUDIATION_KEY_USAGE   24
#define IDS_KEY_ENCIPHERMENT_KEY_USAGE  25
#define IDS_DATA_ENCIPHERMENT_KEY_USAGE 26
#define IDS_KEY_AGREEMENT_KEY_USAGE     27
#define IDS_KEY_CERT_SIGN_KEY_USAGE     28
#define IDS_OFFLINE_CRL_SIGN_KEY_USAGE  29
#define IDS_ENCIPHER_ONLY_KEY_USAGE     30
#define IDS_YES                         31
#define IDS_NO                          32
#define IDS_DECIPHER_ONLY_KEY_USAGE     33
#define IDS_NO_MAXIMUM                  34
#define IDS_SELECT_CERTIFICATE_TEMPLATE 35
#define IDS_ALL                         36
#define IDS_NO_TEMPLATES                39
#define IDS_MANAGETASK                  40
#define IDS_MANAGETASK_HINT             41
#define IDD_NEWCERTTYPE_COMPLETION      101
#define IDD_NEWCERTTYPE_TYPE            102
#define IDD_NEWCERTTYPE_INFORMATION     103
#define IDD_NEWCERTTYPE_CONTROL         105
#define IDD_NEWCERTTYPE_KEY_USAGE       106
#define IDD_GENERAL                     107
#define IDD_EXTENSION_PAGE              108
#define IDD_NEWCERTTYPE_CA_CERTIFICATE  108
#define IDD_POLICYSETTINGS_PROPPAGE1    109
#define IDD_CERTSRV_PROPPAGE            110
#define IDD_CERTSRV_PROPPAGE2           110
#define IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE 110
#define IDD_CERTSRV_PROPPAGE4           112
#define IDD_CERTSRV_PROPPAGE5           113
#define IDD_NEWCERTTYPE_CSP_SELECTION   113
#define IDD_CERTSRV_PROPPAGE3           114
#define IDD_CRL_PROPPAGE                115
#define IDS_DELETE_ERROR                135
#define IDS_CERTTYPE_INFO_FAIL          139
#define IDS_FAILED_CA_UPDATE            141
#define IDS_DLL_INSTALL_USAGE_TEXT      150
#define IDS_DLL_INSTALL_USAGE_TITLE     151
#define IDS_CERTTYPE_DESCRIPTION        152
#define IDS_COMPANY                     154
#define IDS_CAPOLICY_DESCRIPTION        155
#define IDC_NEW_FOLDER                  201
#define IDB_16x16                       202
#define IDC_EXT_STATIC                  202
#define IDC_ORGANIZATION                202
#define IDB_32x32                       203
#define IDC_EXT_TEXT                    203
#define IDC_ORGUNIT                     203
#define IDI_COMPUTER                    204
#define IDC_LOCALITY                    204
#define IDI_FOLDER                      205
#define IDC_CERTSRV_PROPPAGE_TAB1       205
#define IDC_STATE                       205
#define IDC_COUNTRY                     206
#define IDB_TOOLBAR1                    207
#define IDC_DESCRIPTION                 207
#define IDB_TOOLBAR2                    208
#define IDC_CANAME                      208
#define IDI_APPICON                     209
#define IDC_COUNTRY2                    209
#define IDB_SMALLBMP                    210
#define IDC_COUNTRY3                    210
#define IDB_LARGE                       211
#define IDC_COUNTRY4                    211
#define IDC_CA_HIERARCHY                211
#define IDR_MENU1                       212
#define IDC_BUTTON_INSTALLCERT          212
#define FILEEX_MENU                     213
#define IDC_BUTTON_VIEWCERT             213
#define FOLDEREX_MENU                   214
#define IDC_RADIO1                      214
#define IDC_RADIO2                      215
#define IDC_EDIT1                       216
#define IDC_EDIT_SHAREDFOLDER           216
#define IDC_DURATION_EDIT               216
#define IDC_BUTTON1                     217
#define IDC_UP_BUTTON                   217
#define IDB_COMPUTER_LARGE              218
#define IDC_EDIT2                       218
#define IDC_BUTTON4                     218
#define IDD_SELECT_CERTIFICATE_TEMPLATE 218
#define IDB_COMPUTER_SMALL              219
#define IDC_BUTTON5                     219
#define IDC_EDIT4                       219
#define IDC_EDIT_NUMUNITS               219
#define IDB_TOOLBAR_SVRMGR1             220
#define IDC_BUTTON2                     220
#define IDD_CERTIFICATE_TEMPLATE_ACCESS_CONTROL_PAGE 220
#define IDC_DOWN_BUTTON                 220
#define IDC_EDIT3                       221
#define IDB_USER_GROUP_BITMAP           221
#define IDD_NEWCERTTYPE_WELCOME         221
#define IDC_BUTTON3                     222
#define IDD_USER_PURPOSE                222
#define IDC_EDIT5                       223
#define IDC_EDIT_UNITS                  223
#define IDB_WIZ_WATERMARK               223
#define IDC_CHECK1                      224
#define IDB_WIZ_BANNER                  224
#define IDC_ALLOW_AUTOENROLL_CHECK      224
#define IDC_COMBO1                      225
#define IDD_GLOBAL_TEMPLATE_PROPERTIES  225
#define IDC_CHECK2                      226
#define IDD_ORDER_CSPS                  226
#define IDC_EDIT6                       227
#define IDC_COMBO_UNITS                 228
#define IDC_CHECK3                      229
#define IDC_EDIT_LASTUPDATE             230
#define IDC_CSP_NAME                    231
#define IDC_HASHALG                     232
#define IDC_EDIT_DATABASE_LOC           233
#define IDC_EDIT_LOG_LOC                234
#define IDC_DURATION_UNIT_COMBO         236
#define IDC_CERTIFICATE_TEMPLATE_NAME   237
#define IDC_PURPOSE_LIST                239
#define IDC_OTHER_INFO_LIST             240
#define IDC_CERTIFICATE_TYPE_LIST       240
#define IDC_USER_ACCESS_LIST            242
#define IDC_ADD_BUTTON                  243
#define IDC_SUMMARY_LIST                244
#define IDC_ACCESS_LIST                 245
#define IDC_CA_FILL_IN_CHECK            246
#define IDC_BOLB_STATIC_CA_CERTIFICATE  247
#define IDC_BOLD_STATIC_CA_CERTIFICATE  247
#define IDC_BOLB_STATIC_ACCESS_CONTROL  248
#define IDC_BOLD_STATIC_ACCESS_CONTROL  248
#define IDC_BOLB_STATIC_BASIC_INFORMATION 249
#define IDC_BOLD_STATIC_BASIC_INFORMATION 249
#define IDC_BOLB_STATIC_KEYUSAGE        250
#define IDC_BOLD_STATIC_KEYUSAGE        250
#define IDC_BOLB_STATIC_BASETYPE        251
#define IDC_BOLD_STATIC_BASETYPE        251
#define IDC_WELCOME_BIGBOLD_STATIC      252
#define IDC_WELCOM_BOLD_STATIC          253
#define IDC_COMPLETION_BIGBOLD_STATIC   254
#define IDC_CSP_LIST                    255
#define IDC_ADDCSPS_BUTTON              256
#define IDC_REMOVECSPS_BUTTON           257
#define IDC_ORDERED_CSP_LIST            259
#define IDB_SID_ICONS                   260
#define IDB_FOLDER_SMALL                261
#define IDB_FOLDER_LARGE                262
#define IDI_CERTIFICATION_AUTHORITY     263
#define IDI_CDP                         264
#define IDI_ENROLLMENT_SERVICE          265
#define IDC_BASE_CERT_TYPE_LIST         1001
#define IDC_VERIFY_SIGNATURE_CHECK      1002
#define IDC_CRITICAL_CHECK              1002
#define IDC_DIGITAL_SIGNATURE_CHECK     1002
#define IDC_ISSUE_CRL_CHECK             1003
#define IDC_INCLUDE_EMAIL_CHECK         1003
#define IDC_PREVENT_CHECK               1003
#define IDC_SPECIFY_MAX_CA_LEVELS_CHECK 1004
#define IDC_ADVANCED_OPTIONS_CHECK      1004
#define IDC_DATA_ENCRYPTION_CHECK       1004
#define IDC_NEW_PURPOSE_BUTTON          1005
#define IDC_MAX_CA_EDIT                 1006
#define IDC_CERTIFICATE_TEMPLATE_EDIT   1006
#define IDC_DIGSIG_RADIO                1006
#define IDC_KEYEX_RADIO                 1007
#define IDC_KEY_ENCRYPTION_CHECK        1009
#define IDC_ENCIPHER_ONLY_CHECK         1010
#define IDC_EXPORTABLE_CHECK            1010
#define IDC_KEY_AGREEMENT_CHECK         1011
#define IDC_DECIPHER_ONLY_CHECK         1012
#define IDC_KEYUSAGE_CRITICAL_CHECK     1013
#define IDC_MOVEUP_BUTTON               1016
#define IDC_MOVEDOWN_BUTTON             1018
#define IDC_ORDER_BUTTON                1018
#define IDR_CTSHELL                     1019
#define IDC_ADD_FROM_STORE              1021
#define IDC_ADD_FROM_FILE               1022
#define IDB_CERTIFICATE                 1023
#define IDC_CERT_LIST                   1024
#define IDC_VIEW_CERT                   1039
#define IDC_REMOVE                      1040
#define IDC_COPY_TO_FILE                1041
#define IDD_CACERTS                     1044
#define IDR_CASHELL                     1047
#define IDS_CCTSHELLEXT_DESC            1049
#define IDS_ASK_CONFIRM_DELETETEMPLATES 1053
#define IDS_TITLE_ASK_CONFIRM_DELETETEMPLATES 1054
#define IDS_ERROR_CANNOT_LOAD_TEMPLATES 1055
#define IDS_TITLE_CANNOT_SAVE_TEMPLATES 1056
#define IDS_ERROR_CANNOT_SAVE_TEMPLATES 1057
#define IDS_UNKNOWN                     1058
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        228
#define _APS_NEXT_COMMAND_VALUE         32787
#define _APS_NEXT_CONTROL_VALUE         260
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\genpage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       genpage.h
//
//--------------------------------------------------------------------------

#ifndef _GENPAGE_H
#define _GENPAGE_H
// genpage.h : header file
//

#include <tfcprop.h>

/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
//	class CAutoDeletePropPage
//
//	This object is the backbone for property page
//	that will *destroy* itself when no longer needed.
//	The purpose of this object is to maximize code reuse
//	among the various pages in the snapin wizards.
//
//
class CAutoDeletePropPage : public PropertyPage
{
public:
    // Construction
    CAutoDeletePropPage(UINT uIDD);
    virtual ~CAutoDeletePropPage();

protected:
    // Dialog Data

    // Overrides
    virtual BOOL OnSetActive();
    virtual BOOL UpdateData(BOOL fSuckFromDlg = TRUE);
    void OnHelp(LPHELPINFO lpHelp);
    void OnContextHelp(HWND hwnd);
    bool HasContextHelp(int nDlgItem);

    // Implementation
protected:
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

    // This mechanism deletes the CAutoDeletePropPage object
    // when the wizard is finished
    struct
    {
        INT cWizPages;	// Number of pages in wizard
        LPFNPSPCALLBACK pfnOriginalPropSheetPageProc;
    } m_autodeleteStuff;

    static UINT CALLBACK S_PropSheetPageProc(HWND hwnd,	UINT uMsg, LPPROPSHEETPAGE ppsp);


protected:
    CString m_strHelpFile;				// Name for the .hlp file
    CString m_strCaption;				// Name for the .hlp file
    const DWORD * m_prgzHelpIDs;		// Optional: Pointer to an array of help IDs

public:
    void SetCaption(UINT uStringID);
    void SetCaption(LPCTSTR pszCaption);
    void SetHelp(LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);
    void EnableDlgItem(INT nIdDlgItem, BOOL fEnable);

}; // CAutoDeletePropPage



#include <gpedit.h>
//////////////////////////////
// hand-hewn pages


/////////////////////////////////////////
// CCertTemplateGeneralPage
class CCertTemplateGeneralPage : public CAutoDeletePropPage
{
public:
    enum { IID_DEFAULT = IDD_CERTIFICATE_TEMPLATE_PROPERTIES_GENERAL_PAGE };

    // Construction
public:
    CCertTemplateGeneralPage(HCERTTYPE hCertType, UINT uIDD = IID_DEFAULT);
    ~CCertTemplateGeneralPage();

    void SetItemTextWrapper(UINT nID, int *piItem, BOOL fDoInsert, BOOL *pfFirstUsageItem);

    // Dialog Data
    HWND        m_hwndPurposesList;
    HWND        m_hwndOtherInfoList;

    // Overrides
public:
    BOOL OnApply();
    BOOL OnInitDialog();
protected:
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);

    // Implementation
protected:
    void OnDestroy();
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);

public:
    LONG_PTR    m_hConsoleHandle; // Handle given to the snap-in by the console
    HCERTTYPE   m_hCertType;

private:
    BOOL    m_bUpdate;
};



/////////////////////////////////////////
// CCertTemplateSelectPage
INT_PTR SelectCertTemplateDialogProc(
                                  HWND hwndDlg,
                                  UINT uMsg,
                                  WPARAM wParam,
                                  LPARAM lParam);

class CCertTemplateSelectDialog
{
    // Construction
public:
    CCertTemplateSelectDialog(HWND hParent = NULL);
    ~CCertTemplateSelectDialog();

    // Dialog Data
    enum { IDD = IDD_SELECT_CERTIFICATE_TEMPLATE };
    HWND        m_hDlg;
    HWND        m_hwndCertTypeList;


    // Overrides
public:
    BOOL OnInitDialog(HWND hDlg);
    void OnOK();
    void OnHelp(LPHELPINFO lpHelp);
    void OnContextHelp(HWND hwnd);
    bool HasContextHelp(int nDlgItem);

protected:
    BOOL UpdateData(BOOL fSuckFromDlg = TRUE);



public:
    void SetCA(HCAINFO hCAInfo, bool fAdvancedServer);
    void SetHelp(LPCTSTR szHelpFile, const DWORD rgzHelpIDs[]);

    // Implementation
    //protected:
public:
    void OnDestroy();
    void OnSelChange(NMHDR * pNotifyStruct);
    BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    BOOL OnNotify(UINT idCtrl, NMHDR* pnmh);

protected:
	CString m_strHelpFile;				// Name for the .hlp file
	const DWORD * m_prgzHelpIDs;		// Optional: Pointer to an array of help IDs
    bool m_fAdvancedServer;
    CTemplateList m_TemplateList;

public:
    HCAINFO     m_hCAInfo;
};

#endif // _GENPAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\resstr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resstr.h
//
//--------------------------------------------------------------------------

    RESSTR(IDS_SNAPIN_DESC),
    RESSTR(IDS_COLUMN_NAME),
    RESSTR(IDS_SIZE),
    RESSTR(IDS_COLUMN_SIZE),
    RESSTR(IDS_TYPE),
    RESSTR(IDS_COLUMN_TYPE),
    RESSTR(IDS_NODENAME),
    RESSTR(IDS_COLUMN_INTENDED_PURPOSE),
    RESSTR(IDS_ERROR_WIN2000_AD_LAUNCH_NOT_SUPPORTED),
    RESSTR(IDS_NODENAME_PREFIX),
    RESSTR(IDS_SNAPIN_NAME),
    RESSTR(IDS_CERTIFICATE_TYPE),
    RESSTR(IDS_CERTIFICATE_TYPE_HINT),
    RESSTR(IDS_POLICYSETTINGS),
    RESSTR(IDS_INCLUDE_EMAIL_ADDRESS),
    RESSTR(IDS_PUBLIC_KEY_USAGE_LIST),
    RESSTR(IDS_PUBLIC_KEY_USAGE_CRITICAL),
    RESSTR(IDS_DIGITAL_SIGNATURE_KEY_USAGE),
    RESSTR(IDS_NON_REPUDIATION_KEY_USAGE),
    RESSTR(IDS_KEY_ENCIPHERMENT_KEY_USAGE),
    RESSTR(IDS_DATA_ENCIPHERMENT_KEY_USAGE),
    RESSTR(IDS_KEY_AGREEMENT_KEY_USAGE),
    RESSTR(IDS_KEY_CERT_SIGN_KEY_USAGE),
    RESSTR(IDS_OFFLINE_CRL_SIGN_KEY_USAGE),
    RESSTR(IDS_ENCIPHER_ONLY_KEY_USAGE),
    RESSTR(IDS_YES),
    RESSTR(IDS_NO),
    RESSTR(IDS_DECIPHER_ONLY_KEY_USAGE),
    RESSTR(IDS_NO_MAXIMUM),
    RESSTR(IDS_SELECT_CERTIFICATE_TEMPLATE),
    RESSTR(IDS_ALL),
    RESSTR(IDS_NO_TEMPLATES),
    RESSTR(IDS_MANAGETASK),
    RESSTR(IDS_MANAGETASK_HINT),
    RESSTR(IDS_DELETE_ERROR),
    RESSTR(IDS_CERTTYPE_INFO_FAIL),
    RESSTR(IDS_FAILED_CA_UPDATE),
    RESSTR(IDS_DLL_INSTALL_USAGE_TEXT),
    RESSTR(IDS_DLL_INSTALL_USAGE_TITLE),
    RESSTR(IDS_CERTTYPE_DESCRIPTION),
    RESSTR(IDS_COMPANY),
    RESSTR(IDS_CAPOLICY_DESCRIPTION),
    RESSTR(IDS_CCTSHELLEXT_DESC),
    RESSTR(IDS_ASK_CONFIRM_DELETETEMPLATES),
    RESSTR(IDS_TITLE_ASK_CONFIRM_DELETETEMPLATES),
    RESSTR(IDS_ERROR_CANNOT_LOAD_TEMPLATES),
    RESSTR(IDS_TITLE_CANNOT_SAVE_TEMPLATES),
    RESSTR(IDS_ERROR_CANNOT_SAVE_TEMPLATES),
    RESSTR(IDS_UNKNOWN),
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\service.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"


CFolder::~CFolder()
{ 

    if (m_pScopeItem)
    {
        delete m_pScopeItem; 
    }
    CoTaskMemFree(m_pszName); 

    if (m_hCertType != NULL)
    {
        CACloseCertType(m_hCertType);
    }
    // dont close the m_hCAInfo if this is a result folder, it is the same as the scope folders m_hCAInfo
    else if (m_hCAInfo != NULL)
    {
        CACloseCA(m_hCAInfo);
    }
}

void CFolder::Create(LPCWSTR szName, int nImage, int nOpenImage, SCOPE_TYPES itemType,
                                FOLDER_TYPES type, BOOL bHasChildren)
{
    ASSERT(m_pScopeItem == NULL); // Calling create twice on this item?

    // Two-stage construction
    m_pScopeItem = new SCOPEDATAITEM;
    if(m_pScopeItem == NULL)
    {
        return;
    }

    ZeroMemory(m_pScopeItem, sizeof(SCOPEDATAITEM));

    // Set folder type 
    m_type = type;

    // Set scope
    m_itemType = itemType;


    // Add node name
    if (szName != NULL)
    {
        m_pScopeItem->mask = SDI_STR;
    	m_pScopeItem->displayname = (unsigned short*)(-1);
        
        UINT uiByteLen = (wcslen(szName) + 1) * sizeof(OLECHAR);
        LPOLESTR psz = (LPOLESTR)::CoTaskMemAlloc(uiByteLen);
    
        if (psz != NULL)
        {
            wcscpy(psz, szName);
            m_pszName = psz;
        }
    }

    // Add close image
    if (nImage != 0)
    {
        m_pScopeItem->mask |= SDI_IMAGE;
        m_pScopeItem->nImage = nImage;
    }

    // Add open image
    if (nOpenImage != 0)
    {
        m_pScopeItem->mask |= SDI_OPENIMAGE;
        m_pScopeItem->nOpenImage = nOpenImage;
    }

    // Children value is valid
    m_pScopeItem->mask |= SDI_CHILDREN;
    
    // Add button to node if the folder has children
    if (bHasChildren == TRUE)
    {
        m_pScopeItem->cChildren = 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\misc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       misc.cpp
//
//--------------------------------------------------------------------------

#include <stdafx.h>

// sddl.h requires this value to be at least
// 0x0500.  Bump it up if necessary.  NOTE:  This
// 'bump' comes after all other H files that may
// be sensitive to this value.
#if(_WIN32_WINNT < 0x500)
#undef _WIN32_WINNT
#define _WIN32_WINNT 0x0500
#endif

#include "tmpllist.h"
#include <sddl.h>
#include <shlobj.h>
#include <dsclient.h>
#include <dsgetdc.h>
#include <lm.h>
#include <lmapibuf.h>
#include <objsel.h>

#define __dwFILE__	__dwFILE_CAPESNPN_MISC_CPP__


CLIPFORMAT g_cfDsObjectPicker = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);


// returns (if cstr.IsEmpty()) ? NULL : cstr)
LPCWSTR GetNullMachineName(CString* pcstr)
{
    LPCWSTR     szMachine = (pcstr->IsEmpty()) ? NULL : (LPCWSTR)*pcstr;
    return szMachine;
}

/////////////////////////////////////////
// fxns to load/save cstrings to a streams
STDMETHODIMP CStringLoad(CString& cstr, IStream *pStm)
{
    ASSERT(pStm);
    HRESULT hr;

    DWORD cbSize=0;
    ULONG nBytesRead;

    // get cbSize (bytes)
    hr = pStm->Read(&cbSize, sizeof(cbSize), &nBytesRead);
    ASSERT(SUCCEEDED(hr) && (nBytesRead == sizeof(cbSize)) );

    if (FAILED(hr))
        return E_FAIL;

    // get string
    hr = pStm->Read(cstr.GetBuffer(cbSize), cbSize, &nBytesRead);
    ASSERT(SUCCEEDED(hr) && (nBytesRead == cbSize));

    cstr.ReleaseBuffer();

    return SUCCEEDED(hr) ? S_OK : E_FAIL;
}

STDMETHODIMP CStringSave(CString& cstr, IStream *pStm, BOOL fClearDirty)
{
    // Write the string
    DWORD cbSize = (cstr.GetLength()+1)*sizeof(WCHAR);
    ULONG nBytesWritten;
    HRESULT hr;

    // write size in bytes
    hr = pStm->Write(&cbSize, sizeof(cbSize), &nBytesWritten);
    ASSERT(SUCCEEDED(hr) && (nBytesWritten == sizeof(cbSize)) );

    if (FAILED(hr))
        return STG_E_CANTSAVE;

    // write string
    hr = pStm->Write((LPCWSTR)cstr, cbSize, &nBytesWritten);
    ASSERT(SUCCEEDED(hr) && (nBytesWritten == cbSize));

    // Verify that the write operation succeeded
    return SUCCEEDED(hr) ? S_OK : STG_E_CANTSAVE;
}

LPSTR AllocAndCopyStr(LPCSTR psz)
{
    LPSTR pszReturn;

    pszReturn = (LPSTR) new(BYTE[strlen(psz)+1]);
    if(pszReturn)
    {
        strcpy(pszReturn, psz);
    }
    return pszReturn;
}


LPWSTR AllocAndCopyStr(LPCWSTR pwsz)
{
    LPWSTR pwszReturn;

    pwszReturn = (LPWSTR) new(WCHAR[wcslen(pwsz)+1]);
    if(pwszReturn)
    {
        wcscpy(pwszReturn, pwsz);
    }
    return pwszReturn;
}

LPWSTR BuildErrorMessage(DWORD dwErr)
{
    LPWSTR lpMsgBuf = NULL;
    FormatMessageW(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                dwErr,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                (LPWSTR) &lpMsgBuf,    
                0,    
                NULL );
    return lpMsgBuf;
}

//////////////////////////////////////////////////////////////////
// given an error code and a console pointer, will pop error dlg
void DisplayGenericCertSrvError(LPCONSOLE2 pConsole, DWORD dwErr)
{
    ASSERT(pConsole);
    LPWSTR lpMsgBuf = BuildErrorMessage(dwErr);


    if(lpMsgBuf)
    {    
    // ...
    // Display the string.
    pConsole->MessageBoxW(lpMsgBuf, L"Certificate Services Error", MB_OK | MB_ICONINFORMATION, NULL);
    
    // Free the buffer.
    LocalFree( lpMsgBuf );
    }
}
// returns localized, stringized time
BOOL FileTimeToLocalTimeString(FILETIME* pftGMT, LPWSTR* ppszTmp)
{
    FILETIME ftLocal;
    if (FileTimeToLocalFileTime(pftGMT, &ftLocal))
    {
        SYSTEMTIME sysLocal;
        if (FileTimeToSystemTime(
                &ftLocal, 
                &sysLocal))
        {
            WCHAR rgTmpDate[128], rgTmpTime[128];
            DWORD dwLen;
            dwLen = GetDateFormatW(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &sysLocal,
                NULL, rgTmpDate, ARRAYLEN(rgTmpDate));

            dwLen += GetTimeFormatW(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &sysLocal,
                NULL, rgTmpTime, ARRAYLEN(rgTmpTime));

            dwLen += sizeof(L" ");

            *ppszTmp = new WCHAR[dwLen];
            if(*ppszTmp == NULL)
            {
                return FALSE;
            }
            wcscpy(*ppszTmp, rgTmpDate);
            wcscat(*ppszTmp, L" ");
            wcscat(*ppszTmp, rgTmpTime);
        }
    }
    
    return TRUE;
}


void MyErrorBox(HWND hwndParent, UINT nIDText, UINT nIDCaption, DWORD dwErrorCode)
{
    CString cstrTitle, cstrFormatText, cstrFullText;
    cstrTitle.LoadString(nIDCaption);
    cstrFormatText.LoadString(nIDText);

    WCHAR const *pwszError = NULL;
    if (dwErrorCode != ERROR_SUCCESS)
    {
        pwszError = myGetErrorMessageText(dwErrorCode, TRUE);

        cstrFullText.Format(cstrFormatText, pwszError);

        // Free the buffer
        if (NULL != pwszError)
	{
            LocalFree(const_cast<WCHAR *>(pwszError));
	}
    }

    ::MessageBoxW(hwndParent, cstrFullText, cstrTitle, MB_OK | MB_ICONERROR);
}


BOOL MyGetOIDInfo(LPWSTR string, DWORD stringSize, LPSTR pszObjId)
{   
    PCCRYPT_OID_INFO pOIDInfo;
            
    pOIDInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_OID_KEY, 
                pszObjId, 
                0);

    if (pOIDInfo != NULL)
    {
        if (wcslen(pOIDInfo->pwszName)+1 <= stringSize)
        {
            wcscpy(string, pOIDInfo->pwszName);
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return (MultiByteToWideChar(CP_ACP, 0, pszObjId, -1, string, stringSize) != 0);
    }
    return TRUE;
}


BOOL MyGetEnhancedKeyUsages(HCERTTYPE hCertType, CString **aszUsages, DWORD *cUsages, BOOL *pfCritical, BOOL fGetOIDSNotNames)
{
    PCERT_EXTENSIONS    pCertExtensions;
    CERT_ENHKEY_USAGE   *pehku;
    DWORD               cb = 0;
    WCHAR               OIDName[256];
    unsigned int        i;
    LPWSTR              pwszOID;
    HRESULT hr;

    CSASSERT(cUsages);

    if(aszUsages)
        *aszUsages = NULL;

    hr = CAGetCertTypeExtensionsEx(hCertType, CT_EXTENSION_EKU, NULL, &pCertExtensions);

    if(hr != S_OK)
    {
        return FALSE;
    }

    if(1 != pCertExtensions->cExtension)
    {
        CAFreeCertTypeExtensions(hCertType, pCertExtensions);
        return FALSE;
    }

    i = 0;

    if (pfCritical != NULL)
    {
        *pfCritical = pCertExtensions->rgExtension[i].fCritical;
    }

    CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_ENHANCED_KEY_USAGE,
            pCertExtensions->rgExtension[i].Value.pbData, 
            pCertExtensions->rgExtension[i].Value.cbData,
            0,
            NULL,
            &cb);

    if (NULL == (pehku = (CERT_ENHKEY_USAGE *) new(BYTE[cb])))
    {
        CAFreeCertTypeExtensions(hCertType, pCertExtensions);
        return FALSE;
    }

    CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_ENHANCED_KEY_USAGE,
            pCertExtensions->rgExtension[i].Value.pbData, 
            pCertExtensions->rgExtension[i].Value.cbData,
            0,
            pehku,
            &cb);

    if(!aszUsages)
    {
        // only retrieving the usage count
        *cUsages = pehku->cUsageIdentifier;
    }
    else
    {
        // retrieving usage strings, count better match
        CSASSERT(*cUsages == pehku->cUsageIdentifier);

        for (i=0; i<pehku->cUsageIdentifier; i++)
        {
            if (fGetOIDSNotNames)
            {
                pwszOID = MyMkWStr(pehku->rgpszUsageIdentifier[i]);
                aszUsages[i]= new CString(pwszOID);
                delete(pwszOID);
                if(aszUsages[i] == NULL)
                {
                    return FALSE;
                }

            }
            else
            {
                MyGetOIDInfo(OIDName, sizeof(OIDName)/sizeof(WCHAR), pehku->rgpszUsageIdentifier[i]);
                aszUsages[i]= new CString(OIDName);
                if(aszUsages[i] == NULL)
                {
                    return FALSE;
                }
            }
        }
    }

    delete[](pehku);

    CAFreeCertTypeExtensions(hCertType, pCertExtensions);
    return TRUE;
}


BOOL GetIntendedUsagesString(HCERTTYPE hCertType, CString *pUsageString)
{
    CString **aszUsages = NULL;
    DWORD   cNumUsages = 0;
    unsigned int     i;

    if(!MyGetEnhancedKeyUsages(hCertType, NULL, &cNumUsages, NULL, FALSE))
        return FALSE;

    if(0==cNumUsages)
    {
        *pUsageString = "";
        return TRUE;
    }

    aszUsages = new CString*[cNumUsages];
    if(!aszUsages)
        return FALSE;

    if(!MyGetEnhancedKeyUsages(hCertType, aszUsages, &cNumUsages, NULL, FALSE))
    {
        delete[] aszUsages;
        return FALSE;
    }

    *pUsageString = "";

    for (i=0; i<cNumUsages; i++)
    {
        if (i != 0)
        {
            *pUsageString += ", ";
        }
        *pUsageString += *(aszUsages[i]);

        delete(aszUsages[i]);
    }

    delete[] aszUsages;

    return TRUE;
}


BOOL MyGetKeyUsages(HCERTTYPE hCertType, CRYPT_BIT_BLOB **ppBitBlob, BOOL *pfPublicKeyUsageCritical)
{
    PCERT_EXTENSIONS    pCertExtensions;
    DWORD               cb = 0;
    unsigned int                 i;
    
    HRESULT hr;
    hr = CAGetCertTypeExtensionsEx(hCertType, CT_EXTENSION_KEY_USAGE, NULL, &pCertExtensions);

    if(hr != S_OK)
    {
        return FALSE;
    }

    if(1 != pCertExtensions->cExtension)
    {
        CAFreeCertTypeExtensions(hCertType, pCertExtensions);
        return FALSE;
    }

    i = 0;

    if (pfPublicKeyUsageCritical != NULL)
    {
        *pfPublicKeyUsageCritical = pCertExtensions->rgExtension[i].fCritical;
    }

    CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_KEY_USAGE,
            pCertExtensions->rgExtension[i].Value.pbData, 
            pCertExtensions->rgExtension[i].Value.cbData,
            0,
            NULL,
            &cb);

    if (NULL == (*ppBitBlob = (CRYPT_BIT_BLOB *) new(BYTE[cb])))
    {
        CAFreeCertTypeExtensions(hCertType, pCertExtensions);
        return FALSE;
    }

    CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_KEY_USAGE,
            pCertExtensions->rgExtension[i].Value.pbData, 
            pCertExtensions->rgExtension[i].Value.cbData,
            0,
            *ppBitBlob,
            &cb);

    CAFreeCertTypeExtensions(hCertType, pCertExtensions);
    return TRUE;
}

BOOL MyGetBasicConstraintInfo(HCERTTYPE hCertType, BOOL *pfCA, BOOL *pfPathLenConstraint, DWORD *pdwPathLenConstraint)
{
    PCERT_EXTENSIONS                pCertExtensions;
    DWORD                           cb = sizeof(CERT_BASIC_CONSTRAINTS2_INFO);
    unsigned int                    i;
    CERT_BASIC_CONSTRAINTS2_INFO    basicConstraintsInfo;
    
    HRESULT hr;
    hr = CAGetCertTypeExtensionsEx(hCertType, CT_EXTENSION_BASIC_CONTRAINTS, NULL, &pCertExtensions);

    if(hr != S_OK)
    {
        return FALSE;
    }

    if(1 != pCertExtensions->cExtension)
    {
        CAFreeCertTypeExtensions(hCertType, pCertExtensions);
        return FALSE;
    }

    i = 0;

    CryptDecodeObject(
            X509_ASN_ENCODING,
            X509_BASIC_CONSTRAINTS2,
            pCertExtensions->rgExtension[i].Value.pbData, 
            pCertExtensions->rgExtension[i].Value.cbData,
            0,
            &basicConstraintsInfo,
            &cb);

    *pfCA = basicConstraintsInfo.fCA;
    *pfPathLenConstraint = basicConstraintsInfo.fPathLenConstraint;
    *pdwPathLenConstraint = basicConstraintsInfo.dwPathLenConstraint;

    CAFreeCertTypeExtensions(hCertType, pCertExtensions);
    return TRUE;
}


LPSTR MyMkMBStr(LPCWSTR pwsz)
{
    int     cb;
    LPSTR   psz;

    if (pwsz == NULL)
    {
        return NULL;
    }
    
    cb = WideCharToMultiByte(
                    0,
                    0,
                    pwsz,
                    -1,
                    NULL,
                    0,
                    NULL,
                    NULL);
            
    if (NULL == (psz = (LPSTR) new BYTE[cb]))
    {
        return NULL;
    }

    cb = WideCharToMultiByte(
                0,
                0,
                pwsz,
                -1,
                psz,
                cb,
                NULL,
                NULL);

    if (cb==0)
    { 
       delete [] psz;
       return NULL;
    }
    return(psz);
}

LPWSTR MyMkWStr(LPCSTR psz)
{
    int     cWChars;
    LPWSTR   pwsz;

    if (psz == NULL)
    {
        return NULL;
    }

    cWChars = MultiByteToWideChar(
                    0,
                    0,
                    psz,
                    -1,
                    NULL,
                    0);
            
    if (NULL == (pwsz = (LPWSTR) new BYTE[cWChars * sizeof(WCHAR)] ))
    {
        return NULL;
    }

    cWChars = MultiByteToWideChar(
                    0,
                    0,
                    psz,
                    -1,
                    pwsz,
                    cWChars);

    if (cWChars == 0)
    {
        delete [] pwsz;
        return NULL;
    }
    return(pwsz);
}


HRESULT
UpdateCATemplateList(
    HWND hwndParent,
    HCAINFO hCAInfo,
    const CTemplateList& list)
{
    HRESULT hr = myUpdateCATemplateListToCA(hCAInfo, list);
    if(S_OK != hr)
    {
        // if failed to update through the CA for any reason, try
        // writing directly to DS

        CString cstrMsg, cstrTitle, cstrFormat;
        cstrFormat.LoadString(IDS_ERROR_CANNOT_SAVE_TEMPLATES);
        cstrTitle.LoadString(IDS_TITLE_CANNOT_SAVE_TEMPLATES);

        CAutoLPWSTR pwszError;
        pwszError.Attach((LPWSTR)myGetErrorMessageText(hr, TRUE));
        
        cstrMsg.Format(cstrFormat, (LPCWSTR)pwszError);

        if (IDYES != MessageBox(
                        hwndParent,
                        (LPCWSTR)cstrMsg,
                        (LPCWSTR)cstrTitle,
                        MB_YESNO))
            return ERROR_CANCELLED;

        hr = myUpdateCATemplateListToDS(hCAInfo);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\stdafx.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\snapin.cpp ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f Snapinps.mak in the project directory.

#include "stdafx.h"

#define myHLastError GetLastError
#include "csresstr.h"

CComModule _Module;
HINSTANCE  g_hInstance = NULL;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CAPolicyExtensionSnapIn, CComponentDataPolicySettings)
    OBJECT_ENTRY(CLSID_CACertificateTemplateManager, CComponentDataGPEExtension)
    OBJECT_ENTRY(CLSID_CertTypeShellExt, CCertTypeShlExt)
	OBJECT_ENTRY(CLSID_CAPolicyAbout, CCAPolicyAboutImpl)
	OBJECT_ENTRY(CLSID_CertTypeAbout, CCertTypeAboutImpl)
END_OBJECT_MAP()


STDAPI UnregisterGPECertTemplates(void);


BOOL WINAPI DllMain(  
    HINSTANCE hinstDLL,  // handle to DLL module
    DWORD dwReason,     // reason for calling function
    LPVOID lpvReserved)
{
    switch (dwReason)
    {
    case  DLL_PROCESS_ATTACH:
    {
        g_hInstance = hinstDLL;
	myVerifyResourceStrings(hinstDLL);
        _Module.Init(ObjectMap, hinstDLL);

        DisableThreadLibraryCalls(hinstDLL);
        break;
    }
    case DLL_PROCESS_DETACH:
    {
        _Module.Term();

        DEBUG_VERIFY_INSTANCE_COUNT(CSnapin);
        DEBUG_VERIFY_INSTANCE_COUNT(CComponentDataImpl);
        break;
    }

    default:
        break;
    }
    
    return TRUE;
}




/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	AFX_MANAGE_STATE(AfxGetStaticModuleState());
	return (_Module.GetLockCount() == 0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hResult = S_OK;
    CString cstrSubKey;
    DWORD   dwDisp;
    LONG    lResult;
    HKEY    hKey;
    CString cstrSnapInKey;
    CString cstrCAPolicyAboutKey;
    CString cstrSnapInName;
    CString cstrSnapInNameIndirect;
    LPWSTR pszTmp;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    cstrSnapInName.LoadString(IDS_SNAPIN_NAME);

    // be sure this is alloced
    if (NULL == (pszTmp = cstrSubKey.GetBuffer(MAX_PATH)))
         return SELFREG_E_CLASS;
    StringFromGUID2( CLSID_CAPolicyExtensionSnapIn, 
                       pszTmp, 
                       MAX_PATH);
    cstrSnapInKey = cstrSubKey;


    // be sure this is alloced
    if (NULL == (pszTmp = cstrSubKey.GetBuffer(MAX_PATH)))
         return SELFREG_E_CLASS;
    StringFromGUID2( CLSID_CAPolicyAbout, 
                       pszTmp, 
                       MAX_PATH);
    cstrCAPolicyAboutKey = cstrSubKey;


    cstrSnapInNameIndirect.Format(
        wszSNAPINNAMESTRINGINDIRECT_TEMPLATE,
        wszSNAPIN_FILENAME,
        IDS_SNAPIN_NAME);

    //
    // Register Policy Extensions SnapIn with MMC
    //

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\SnapIns\\%ws", (LPCWSTR)cstrSnapInKey);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, cstrSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, L"NameString", 0, REG_SZ, (LPBYTE)((LPCTSTR)cstrSnapInName),
                   (cstrSnapInName.GetLength() + 1) * sizeof(WCHAR));

    RegSetValueEx (hKey, wszSNAPINNAMESTRINGINDIRECT, 0, REG_SZ, 
        (LPBYTE)((LPCTSTR)cstrSnapInNameIndirect),
        (cstrSnapInNameIndirect.GetLength() + 1) * sizeof(WCHAR));

    RegSetValueEx (hKey, L"About", 0, REG_SZ, (LPBYTE)((LPCTSTR)cstrCAPolicyAboutKey),
                   (cstrCAPolicyAboutKey.GetLength() + 1) * sizeof(WCHAR));

    RegCloseKey (hKey);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\SnapIns\\%ws\\NodeTypes", (LPCWSTR)cstrSnapInKey);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, cstrSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegCloseKey (hKey);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\SnapIns\\%ws\\NodeTypes\\%ws", (LPCWSTR)cstrSnapInKey, cszNodeTypePolicySettings);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, cstrSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegCloseKey (hKey);



    //
    // Register Policy Settings in the NodeTypes key
    //
    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\NodeTypes\\%ws", cszNodeTypePolicySettings);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, cstrSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, NULL, 0, REG_SZ, (LPBYTE)((LPCTSTR)cstrSnapInName),
                   (cstrSnapInName.GetLength() + 1) * sizeof(WCHAR));

    RegCloseKey (hKey);


    //
    // register as an extension under the CA snapin
    //
    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\NodeTypes\\%ws\\Extensions\\NameSpace", cszCAManagerParentNodeID);
    lResult = RegCreateKeyEx (HKEY_LOCAL_MACHINE, cstrSubKey, 0, NULL,
                              REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                              &hKey, &dwDisp);

    if (lResult != ERROR_SUCCESS) {
        return SELFREG_E_CLASS;
    }

    RegSetValueEx (hKey, cstrSnapInKey, 0, REG_SZ, (LPBYTE)((LPCTSTR)cstrSnapInName),
                   (cstrSnapInName.GetLength() + 1) * sizeof(WCHAR));

    RegCloseKey (hKey);


    // kill beta2 GPT cert type editing
    UnregisterGPECertTemplates();

    // registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(FALSE);
    //return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    CString cstrSubKey;
    LONG    lResult;
    HKEY    hKey;
    WCHAR   szSnapInKey[50];

    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    _Module.UnregisterServer();

    StringFromGUID2 (CLSID_CAPolicyExtensionSnapIn, szSnapInKey, 50);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\NodeTypes\\%ws\\Extensions\\NameSpace", cszCAManagerParentNodeID);
    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, cstrSubKey, 0,
                              KEY_WRITE, &hKey);

    if (lResult == ERROR_SUCCESS) {
        RegDeleteValue (hKey, szSnapInKey);
        RegCloseKey (hKey);
    }
    
    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\NodeTypes\\%ws\\Extensions\\NameSpace", cszNodeTypePolicySettings);
    RegDeleteKey (HKEY_LOCAL_MACHINE, cstrSubKey);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\NodeTypes\\%ws", cszNodeTypePolicySettings);
    RegDeleteKey (HKEY_LOCAL_MACHINE, cstrSubKey);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\SnapIns\\%ws\\NodeTypes\\%ws", szSnapInKey, cszNodeTypePolicySettings);
    RegDeleteKey (HKEY_LOCAL_MACHINE, cstrSubKey);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\SnapIns\\%ws\\NodeTypes", szSnapInKey);
    RegDeleteKey (HKEY_LOCAL_MACHINE, cstrSubKey);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\SnapIns\\%ws", szSnapInKey);
    RegDeleteKey (HKEY_LOCAL_MACHINE, cstrSubKey);


    // kill beta2 GPT cert type editing
    UnregisterGPECertTemplates();
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// UnregisterGPECertTemplates - Removes GPECertTemplateEditing from the registry

STDAPI UnregisterGPECertTemplates(void)
{
	CString cstrSubKey;
    LONG    lResult;
    HKEY    hKey;
    WCHAR   szSnapInKeyForGPT[50];
    WCHAR   szSnapInKey[50];

    StringFromGUID2 (CLSID_CACertificateTemplateManager, szSnapInKeyForGPT, 50);
    StringFromGUID2 (CLSID_CAPolicyExtensionSnapIn, szSnapInKey, 50);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\NodeTypes\\%ws\\Extensions\\NameSpace", cszSCEParentNodeIDUSER);
    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, cstrSubKey, 0,
                              KEY_WRITE, &hKey);

    if (lResult == ERROR_SUCCESS) {
        RegDeleteValue (hKey, szSnapInKeyForGPT);
        RegCloseKey (hKey);
    }

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\NodeTypes\\%ws\\Extensions\\NameSpace", cszSCEParentNodeIDCOMPUTER);
    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, cstrSubKey, 0,
                              KEY_WRITE, &hKey);

    if (lResult == ERROR_SUCCESS) {
        RegDeleteValue (hKey, szSnapInKeyForGPT);
        RegCloseKey (hKey);
    }    

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\NodeTypes\\%ws", cszNodeTypeCertificateTemplate);
    RegDeleteKey (HKEY_LOCAL_MACHINE, cstrSubKey);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\SnapIns\\%ws\\NodeTypes\\%ws", (LPCWSTR)szSnapInKey, cszNodeTypeCertificateTemplate);
    RegDeleteKey (HKEY_LOCAL_MACHINE, cstrSubKey);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\SnapIns\\%ws\\NodeTypes", (LPCWSTR)szSnapInKeyForGPT);
    RegDeleteKey (HKEY_LOCAL_MACHINE, cstrSubKey);

    cstrSubKey.Format(L"Software\\Microsoft\\MMC\\SnapIns\\%ws", (LPCWSTR)szSnapInKeyForGPT);
    RegDeleteKey (HKEY_LOCAL_MACHINE, cstrSubKey);

    return S_OK;
}

VOID Usage()
{
    CString cstrDllInstallUsageText;
    CString cstrDllInstallUsageTitle;
    cstrDllInstallUsageText.LoadString(IDS_DLL_INSTALL_USAGE_TEXT);
    cstrDllInstallUsageTitle.LoadString(IDS_DLL_INSTALL_USAGE_TITLE);

    MessageBox(NULL, cstrDllInstallUsageText, cstrDllInstallUsageTitle, MB_OK);
    
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    LPCWSTR wszCurrentCmd = pszCmdLine;

    AFX_MANAGE_STATE(AfxGetStaticModuleState());


    // parse the cmd line
    while(wszCurrentCmd && *wszCurrentCmd)
    {
        while(*wszCurrentCmd == L' ')
            wszCurrentCmd++;
        if(*wszCurrentCmd == 0)
            break;

        switch(*wszCurrentCmd++)
        {
            case L'?':
            
                Usage();
                return S_OK;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\stdafx.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#undef _MSC_EXTENSIONS

#define __DIR__		"capesnpn"

#include <windows.h>
#include <objbase.h>
#include <coguid.h>

#include <wincrypt.h>
#include <certsrv.h>
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

extern const CLSID CLSID_CAPolicyExtensionSnapIn;    // In-Proc server GUID
extern const CLSID CLSID_CACertificateTemplateManager;    // In-Proc server GUID
extern const CLSID CLSID_Extension; // In-Proc server GUID
extern const CLSID CLSID_CAPolicyAbout; 
extern const CLSID CLSID_CertTypeAbout; 
#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

#include <atlcom.h>

#pragma comment(lib, "mmc")
#include <mmc.h>

extern HINSTANCE g_hInstance;

// most common private includes
#include "certlib.h"
#include "tfc.h"	// Thomlinson Foundation Classes
#include "tmpllist.h"
#include "uuids.h"
#include "service.h"
#include "compdata.h"
#include "CSnapin.h"
#include "DataObj.h"
#include "resource.h"
#include "ctshlext.h"
#include "misc.h"
#include "genpage.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\service.h ===
// This is a part of the Microsoft Management Console.
// Copyright (C) Microsoft Corporation, 1995 - 1999
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Management Console and related
// electronic documentation provided with the interfaces.

#ifndef _SERVICE_H
#define _SERVICE_H

#include "certca.h"

// Forward declarations
class CSnapin;
class CFolder;

// Internal structure used for cookies
struct FOLDER_DATA
{
    wchar_t*    szName;
    wchar_t*    szSize;
    wchar_t*    szType;

    FOLDER_TYPES    type;
};

#define MAX_RESULTDATA_STRINGS 64

struct RESULT_DATA
{
    SCOPE_TYPES itemType; 
    CFolder*    pParentFolder;

    DWORD       cStringArray;
    LPWSTR      szStringArray[MAX_RESULTDATA_STRINGS];
};

enum 
{
    RESULTDATA_ARRAYENTRY_NAME =0,
    RESULTDATA_ARRAYENTRY_SIZE,
    RESULTDATA_ARRAYENTRY_TYPE,
};

class CFolder 
{
    SCOPE_TYPES  m_itemType;   // Used for debug purposes. This should be the first 
                            // member. The class should not have any virtual fuctions.

    friend class CSnapin;
    friend class CComponentDataImpl;

public:
    // UNINITIALIZED is an invalid memory address and is a good cookie initializer
    CFolder() 
    { 
        m_itemType = UNINITIALIZED_ITEM;  
        m_cookie = UNINITIALIZED; 
        m_enumed = FALSE; 
        m_pScopeItem = NULL; 
        m_type = NONE;
        m_pszName = NULL;
        m_hCAInfo = NULL;
        m_hCertType = NULL;
        m_dwSCEMode = 0;
        m_fGlobalCertType = FALSE;
        m_fMachineFolder = FALSE;
        m_dwRoles = 0;
    }; 

    ~CFolder();

// Interface
public:
    BOOL IsEnumerated() { return  m_enumed; };
    void Set(BOOL state) { m_enumed = state; };
    void SetCookie(MMC_COOKIE cookie) { m_cookie = cookie; }
    FOLDER_TYPES GetType() { ASSERT(m_type != NONE); return m_type; };
    BOOL operator == (const CFolder& rhs) const { return rhs.m_cookie == m_cookie; };
    BOOL operator == (MMC_COOKIE cookie) const { return cookie == m_cookie; };
    void SetName(LPWSTR pszIn) 
    { 
        UINT len = wcslen(pszIn) + 1;
        LPWSTR psz = (LPWSTR)CoTaskMemAlloc(len * sizeof(WCHAR));
        if (psz != NULL)
        {
            wcscpy(psz, pszIn);
            CoTaskMemFree(m_pszName);
            m_pszName = psz;
        }
    }
    DWORD GetRoles() { return m_dwRoles; }

// Implementation
private:
    void Create(
                LPCWSTR szName, 
                int nImage, 
                int nOpenImage,
                SCOPE_TYPES itemType,
                FOLDER_TYPES type, 
                BOOL bHasChildren = FALSE);

// Attributes
private:
    LPSCOPEDATAITEM     m_pScopeItem;
    MMC_COOKIE                m_cookie;
    BOOL                m_enumed;
    FOLDER_TYPES        m_type;
    LPOLESTR            m_pszName;
    CString             m_szCAName;
    CString             m_szIntendedUsages;
    HCAINFO             m_hCAInfo;
    HCERTTYPE           m_hCertType;
    DWORD               m_dwSCEMode;
    BOOL                m_fGlobalCertType;
    BOOL                m_fMachineFolder;
    DWORD               m_dwRoles;  
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\uuids.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       uuids.h
//
//--------------------------------------------------------------------------

#ifndef __UUIDS_H_
#define __UUIDS_H_

const long UNINITIALIZED = -1;

// Constants used in samples
const int MAX_ITEM_NAME = 64;

enum SCOPE_TYPES
{
    UNINITIALIZED_ITEM  = 0,

    SCOPE_LEVEL_ITEM    = 111,
    RESULT_ITEM         = 222,
    //CA_LEVEL_ITEM       = 333,
};

// Sample folder types
enum FOLDER_TYPES
{
    STATIC = 0x8000,

    // policy settings node
    POLICYSETTINGS = 0x8007,

    // cert types manager node
    SCE_EXTENSION = 0x8100,

    // cert types displayed in results pane for policy settings node
    CA_CERT_TYPE = 0x8107,

    // cert types displayed in results pane for cert types manager node
    GLOBAL_CERT_TYPE = 0x8110,
    
    NONE = 0xFFFF
};

/////////////////////////////////////////////////////////////////////////////
// Helper functions

template<class TYPE>
inline void SAFE_RELEASE(TYPE*& pObj)
{
    if (pObj != NULL) 
    { 
        pObj->Release(); 
        pObj = NULL; 
    } 
    else 
    { 
#ifdef _DEBUG
        OutputDebugString(L"CAPESNPN: Release called on NULL interface ptr\n"); 
#endif
    }
}

extern const CLSID CLSID_CAPolicyExtensionSnapIn;
extern const CLSID CLSID_CACertificateTemplateManager;
extern const CLSID CLSID_CertTypeAbout; 
extern const CLSID CLSID_CAPolicyAbout;
extern const CLSID CLSID_CertTypeShellExt;
extern const CLSID CLSID_CAShellExt;
///////////////////////////////////////////////////////////////////////////////
//
//                  OBJECT TYPES
//

//
// OBJECT TYPE for Scope Nodes.
//

// Static NodeType GUID in numeric & string formats.
extern const GUID cNodeTypePolicySettings;
extern const WCHAR*  cszNodeTypePolicySettings;
extern const GUID cNodeTypeCertificateTemplate;
extern const WCHAR*  cszNodeTypeCertificateTemplate;

//
// OBJECT TYPE for result items.
//

// Result items object type GUID in numeric & string formats.
extern const GUID cObjectTypeResultItem;
extern const wchar_t*  cszObjectTypeResultItem;


// CA Manager snapin parent node
extern const CLSID cCAManagerParentNodeID;
extern const WCHAR* cszCAManagerParentNodeID;

// CA Manager snapin parent node
extern const CLSID cSCEParentNodeIDUSER;
extern const WCHAR* cszSCEParentNodeIDUSER;
extern const CLSID cSCEParentNodeIDCOMPUTER;
extern const WCHAR* cszSCEParentNodeIDCOMPUTER;

//
//
//////////////////////////////////////////////////////////////////////////////



// New Clipboard format that has the Type and Cookie
extern const wchar_t* SNAPIN_INTERNAL;

// Published context information for extensions to extend
extern const wchar_t* SNAPIN_WORKSTATION;

// format for getting CA name from parent node
extern const wchar_t* CA_COMMON_NAME;

// format for getting CA name from parent node
extern const wchar_t* CA_SANITIZED_NAME;

extern const wchar_t* SNAPIN_CA_INSTALL_TYPE;

extern const wchar_t* CA_ROLES;

// Clipboard format for SCE's mode DWORD
extern const wchar_t* CCF_SCE_MODE_TYPE;

// Clipboard format for GPT's IUnknown interface
extern const wchar_t* CCF_SCE_GPT_UNKNOWN;

struct INTERNAL 
{
    INTERNAL() 
    {
        m_type = CCT_UNINITIALIZED; 
        m_cookie = -1;
        ZeroMemory(&m_clsid, sizeof(CLSID));
    };

    ~INTERNAL() {}

    DATA_OBJECT_TYPES   m_type;         // What context is the data object.
    MMC_COOKIE                m_cookie;       // What object the cookie represents
    CString             m_string;       // 
    CLSID               m_clsid;       // Class ID of who created this data object

    INTERNAL & operator=(const INTERNAL& rhs) 
    { 
        if (&rhs == this)
            return *this;

        // Deep copy the information
        m_type = rhs.m_type; 
        m_cookie = rhs.m_cookie; 
        m_string = rhs.m_string;
        memcpy(&m_clsid, &rhs.m_clsid, sizeof(CLSID));

        return *this;
    } 

    BOOL operator==(const INTERNAL& rhs) 
    {
        return rhs.m_string == m_string;
    }
};

// Debug instance counter
#ifdef _DEBUG
inline void DbgInstanceRemaining(char * pszClassName, int cInstRem)
{
    char buf[100];
    wsprintfA(buf, "%hs has %d instances left over.", pszClassName, cInstRem);
    ::MessageBoxA(NULL, buf, "CAPESNPN: Memory Leak!!!", MB_OK);
}
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)      extern int s_cInst_##cls = 0;
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    ++(s_cInst_##cls);
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    --(s_cInst_##cls);
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    \
        extern int s_cInst_##cls; \
        if (s_cInst_##cls) DbgInstanceRemaining(#cls, s_cInst_##cls);
#else
    #define DEBUG_DECLARE_INSTANCE_COUNTER(cls)   
    #define DEBUG_INCREMENT_INSTANCE_COUNTER(cls)    
    #define DEBUG_DECREMENT_INSTANCE_COUNTER(cls)    
    #define DEBUG_VERIFY_INSTANCE_COUNT(cls)    
#endif 


#endif //__UUIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\celib\cedebug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//	File:		cedebug.cpp
//
//	Contents:	Debug support
//
//----------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "celib.h"
#include <stdarg.h>


//+-------------------------------------------------------------------------
//
//  Function:  ceDbgPrintf
//
//  Synopsis:  outputs debug info to stdout and debugger
//
//  Returns:   number of chars output
//
//--------------------------------------------------------------------------

int WINAPIV
ceDbgPrintf(
    IN BOOL fDebug,
    IN LPCSTR lpFmt,
    ...)
{
    va_list arglist;
    CHAR ach[4096];
    int cch = 0;
    HANDLE hStdOut;
    DWORD dwErr;

    dwErr = GetLastError();
    if (fDebug)
    {
	__try 
	{
	    va_start(arglist, lpFmt);
	    cch = _vsnprintf(ach, sizeof(ach), lpFmt, arglist);
	    ach[ARRAYSIZE(ach)-1] = L'\0';
	    va_end(arglist);

	    if (0 > cch)
	    {
		strcpy(&ach[sizeof(ach) - 5], "...\n");
	    }

	    if (!IsDebuggerPresent())
	    {
		hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
		if (hStdOut != INVALID_HANDLE_VALUE)
		{
		    fputs(ach, stdout);
		    fflush(stdout);
		}
	    }
	    OutputDebugStringA(ach);
	}
	__except(EXCEPTION_EXECUTE_HANDLER) 
	{
	    // return failure
	    cch = 0;
	}
    }
    SetLastError(dwErr);
    return(cch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\capesnpn\uuids.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       uuids.cpp
//
//--------------------------------------------------------------------------


#include <stdafx.h>

#include <initguid.h>
#include <gpedit.h>

const CLSID CLSID_CAPolicyExtensionSnapIn = /*3F276EB4-70EE-11d1-8A0F-00C04FB93753*/\
{0x3f276eb4,0x70ee,0x11d1,{0x8a,0x0f,0x00,0xc0,0x4f,0xb9,0x37,0x53}};

const CLSID CLSID_CACertificateTemplateManager = /*ACE10358-974C-11d1-A48D-00C04FB93753*/\
{0xace10358,0x974c,0x11d1,{0xa4,0x8d,0x0,0xc0,0x4f,0xb9,0x37,0x53}};

const CLSID CLSID_CAPolicyAbout = /*{1F823A6A-863F-11d1-A484-00C04FB93753}*/ \
{0x1f823a6a,0x863f,0x11d1,{0xa4,0x84,0x0,0xc0,0x4f,0xb9,0x37,0x53}};

const CLSID CLSID_CertTypeAbout = /* {BF84C0C5-0C80-11d2-A497-00C04FB93209} */
{ 0xbf84c0c5, 0xc80, 0x11d2, { 0xa4, 0x97, 0x0, 0xc0, 0x4f, 0xb9, 0x32, 0x9 } };

const CLSID CLSID_CertTypeShellExt = /* {9bff616c-3e02-11d2-a4ca-00c04fb93209} */
{ 0x9bff616c, 0x3e02, 0x11d2, { 0xa4, 0xca, 0x0, 0xc0, 0x4f, 0xb9, 0x32, 0x9 } };

const CLSID CLSID_CAShellExt = { /* a4e91b6a-dcae-11d2-a045-00c04f79dc55 */
    0xa4e91b6a, 0xdcae, 0x11d2, {0xa0, 0x45, 0x00, 0xc0, 0x4f, 0x79, 0xdc, 0x55} };


///////////////////////////////////////////////////////////////////////////////
//
//                  OBJECT TYPES
//

//
// OBJECT TYPE for Scope Nodes.
//

// Static NodeType GUID in numeric & string formats.
const GUID cNodeTypePolicySettings = 
{0x3f276eb3,0x70ee,0x11d1,{0x8a, 0x0f, 0x00, 0xc0, 0x4f, 0xb9, 0x37, 0x53}};
const WCHAR*  cszNodeTypePolicySettings = L"{3F276EB3-70EE-11d1-8A0F-00C04FB93753}";

// Static NodeType GUID in numeric & string formats.
const GUID cNodeTypeCertificateTemplate = 
{0x3e3dcd02,0x9755,0x11d1,{0xa4,0x8d,0x0,0xc0,0x4f,0xb9,0x37,0x53}};
const WCHAR*  cszNodeTypeCertificateTemplate = L"{3E3DCD02-9755-11d1-A48D-00C04FB93753}";

//
// OBJECT TYPE for result items.
//

// Result items object type GUID in numeric & string formats.
extern const GUID cObjectTypeResultItem = 
{0x1f823a69,0x863f,0x11d1,{0xa4,0x84,0x0,0xc0,0x4f,0xb9,0x37,0x53}};
extern const wchar_t*  cszObjectTypeResultItem = L"{1F823A69-863F-11d1-A484-00C04FB93753}";


//
//
//////////////////////////////////////////////////////////////////////////////

// Internal private format
const wchar_t* SNAPIN_INTERNAL = L"CAPESNPN_SNAPIN_INTERNAL"; // Step 3

// Published formats
const wchar_t* SNAPIN_WORKSTATION = L"CAPESNPN_SNAPIN_WORKSTATION"; // Extension 

// format for getting CA name from parent node
const wchar_t* CA_COMMON_NAME = L"SNAPIN_CA_COMMON_NAME"; // Extension

// format for getting the type of CA
const wchar_t* SNAPIN_CA_INSTALL_TYPE = L"SNAPIN_CA_INSTALL_TYPE";

// format for getting CA name from parent node
const wchar_t* CA_SANITIZED_NAME = L"SNAPIN_CA_SANITIZED_NAME"; // Extension

// format for getting CA roles from parent node
const wchar_t* CA_ROLES = L"SNAPIN_CA_ROLES"; // Extension

// Clipboard format for SCE's mode DWORD
const wchar_t* CCF_SCE_MODE_TYPE = L"CCF_SCE_MODE_TYPE";

// Clipboard format for GPT's IUnknown interface
const wchar_t* CCF_SCE_GPT_UNKNOWN = L"CCF_SCE_GPT_UNKNOWN";



// CA manager snapin parent node 
const CLSID cCAManagerParentNodeID = /*5d972ee4-7576-11d1-8cbe-00c04fc297eb*/ \
{0x5d972ee4,0x7576,0x11d1,{0x8c,0xbe,0x00,0xc0,0x4f,0xc2,0x97,0xeb}};
const WCHAR* cszCAManagerParentNodeID = L"{5d972ee4-7576-11d1-8cbe-00c04fc297eb}";

// SCE-GPT parent node
const CLSID cSCEParentNodeIDUSER = /*A6B4EEBC-B681-11D0-9484-080036B11A03*/ \
{0xc4a92b42,0x91ee,0x11d1,{0x85,0xfd,0x0,0xc0,0x4f,0xb9,0x4f,0x17}};
const WCHAR* cszSCEParentNodeIDUSER = L"{C4A92B42-91EE-11D1-85FD-00C04FB94F17}";

const CLSID cSCEParentNodeIDCOMPUTER = /*A6B4EEBB-B681-11D0-9484-080036B11A03*/ \
{0xc4a92b43,0x91ee,0x11d1,{0x85,0xfd,0x0,0xc0,0x4f,0xb9,0x4f,0x17}};
const WCHAR* cszSCEParentNodeIDCOMPUTER = L"{C4A92B43-91EE-11D1-85FD-00C04FB94F17}";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\celib\ceerror.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2002
//
// File:        ceerror.cpp
//
// Contents:    Cert Server error wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "celib.h"
#include <assert.h>
#include <ntdsbmsg.h>
#include <delayimp.h>
#include <wininet.h>

#define CERTLIB_12BITERRORMASK  0x00000fff
#define CERTLIB_WIN32ERRORMASK  0x0000ffff


//+--------------------------------------------------------------------------
// Jet errors:

#define HRESULT_FROM_JETWARNING(jerr) \
        (ERROR_SEVERITY_WARNING | (FACILITY_NTDSB << 16) | jerr)

#define HRESULT_FROM_JETERROR(jerr) \
        (ERROR_SEVERITY_ERROR | (FACILITY_NTDSB << 16) | -jerr)

#define JETERROR_FROM_HRESULT(hr) \
        (-(LONG) (CERTLIB_WIN32ERRORMASK & (hr)))

#define ISJETERROR(hr) \
        ((~CERTLIB_WIN32ERRORMASK & (hr)) == (HRESULT) ~CERTLIB_WIN32ERRORMASK)

#define ISJETHRESULT(hr) \
    ((~CERTLIB_WIN32ERRORMASK & (hr)) == (HRESULT) (ERROR_SEVERITY_ERROR | \
					      (FACILITY_NTDSB << 16)))

#define wszJETERRORPREFIX       L"ESE"


//+--------------------------------------------------------------------------
// Setup API errors:

#define ISSETUPHRESULT(hr) \
    ((~CERTLIB_WIN32ERRORMASK & (hr)) == (HRESULT) (ERROR_SEVERITY_ERROR | \
                                              APPLICATION_ERROR_MASK | \
                                              (FACILITY_NULL << 16)))

#define wszSETUPERRORPREFIX       L"INF"


//+--------------------------------------------------------------------------
// Win32 errors:

#define ISWIN32ERROR(hr) \
        ((~CERTLIB_WIN32ERRORMASK & (hr)) == 0)

#define ISWIN32HRESULT(hr) \
    ((~CERTLIB_WIN32ERRORMASK & (hr)) == (HRESULT) (ERROR_SEVERITY_WARNING | \
					      (FACILITY_WIN32 << 16)))

#define WIN32ERROR_FROM_HRESULT(hr) \
        (CERTLIB_WIN32ERRORMASK & (hr))

#define wszWIN32ERRORPREFIX     L"WIN32"


//+--------------------------------------------------------------------------
// Http errors:

#define ISHTTPERROR(hr) \
    ((HRESULT) HTTP_STATUS_FIRST <= (hr) && (HRESULT) HTTP_STATUS_LAST >= (hr))

#define ISHTTPHRESULT(hr) \
    (ISWIN32HRESULT(hr) && ISHTTPERROR(WIN32ERROR_FROM_HRESULT(hr)))

#define wszHTTPERRORPREFIX     L"HTTP"


//+--------------------------------------------------------------------------
// Delayload errors:

#define DELAYLOAD_FROM_WIN32(hr)  VcppException(ERROR_SEVERITY_ERROR, (hr))

#define WIN32ERROR_FROM_DELAYLOAD(hr)  (CERTLIB_WIN32ERRORMASK & (hr))

#define ISDELAYLOADHRESULTFACILITY(hr) \
    ((~CERTLIB_WIN32ERRORMASK & (hr)) == (HRESULT) (ERROR_SEVERITY_ERROR | \
                                              (FACILITY_VISUALCPP << 16)))

// E_DELAYLOAD_MOD_NOT_FOUND    0xc06d007e
#define E_DELAYLOAD_MOD_NOT_FOUND   DELAYLOAD_FROM_WIN32(ERROR_MOD_NOT_FOUND)

// E_DELAYLOAD_PROC_NOT_FOUND   0xc06d007f
#define E_DELAYLOAD_PROC_NOT_FOUND  DELAYLOAD_FROM_WIN32(ERROR_PROC_NOT_FOUND)

#define ISDELAYLOADHRESULT(hr) \
        ((HRESULT) E_DELAYLOAD_MOD_NOT_FOUND == (hr) || \
         (HRESULT) E_DELAYLOAD_PROC_NOT_FOUND == (hr) || \
         HRESULT_FROM_WIN32(ERROR_MOD_NOT_FOUND) == (hr) || \
         HRESULT_FROM_WIN32(ERROR_PROC_NOT_FOUND) == (hr))


//+--------------------------------------------------------------------------
// ASN encoding errors:

#define ISOSSERROR(hr) \
        ((~CERTLIB_12BITERRORMASK & (hr)) == CRYPT_E_OSS_ERROR)

#define OSSERROR_FROM_HRESULT(hr) \
        (CERTLIB_12BITERRORMASK & (hr))

#define wszOSSERRORPREFIX       L"ASN"


HRESULT
ceJetHResult(
    IN HRESULT hr)
{
    if (S_OK != hr)
    {
        if (SUCCEEDED(hr))
        {
#if 0
            hr = HRESULT_FROM_JETWARNING(hr);
#else
            if (S_FALSE != hr)
            {
                _PrintError(hr, "JetHResult: mapping to S_FALSE");
            }
            assert(S_FALSE == hr);
            hr = S_FALSE;
#endif
        }
        else if (ISJETERROR(hr))
        {
            hr = HRESULT_FROM_JETERROR(hr);
        }
    }
    assert(S_OK == hr || S_FALSE == hr || FAILED(hr));
    return(hr);
}


HRESULT
ceHExceptionCode(
    IN EXCEPTION_POINTERS const *pep)
{
    HRESULT hr = pep->ExceptionRecord->ExceptionCode;

#if (0 == i386)
    if ((HRESULT) STATUS_DATATYPE_MISALIGNMENT == hr)
    {
	hr = CERTSRV_E_ALIGNMENT_FAULT;
    }
#endif
    return(ceHError(hr));
}


BOOL
ceIsDelayLoadHResult(
    IN HRESULT hr)
{
    return(ISDELAYLOADHRESULT(hr));
}


#define wszCOLONSPACE   L": "

WCHAR const *
ceHResultToStringEx(
    IN OUT WCHAR *awchr,
    IN HRESULT hr,
    IN BOOL fRaw)
{
    HRESULT hrd;
    WCHAR const *pwszType;

    hrd = hr;
    pwszType = L"";
    if (ISJETERROR(hr))
    {
        pwszType = wszJETERRORPREFIX wszCOLONSPACE;
    }
    else if (ISJETHRESULT(hr))
    {
        hrd = JETERROR_FROM_HRESULT(hr);
        pwszType = wszJETERRORPREFIX wszCOLONSPACE;
    }
    else if (ISOSSERROR(hr))
    {
        hrd = OSSERROR_FROM_HRESULT(hr);
        pwszType = wszOSSERRORPREFIX wszCOLONSPACE;
    }
    else if (ISHTTPHRESULT(hr) || ISHTTPERROR(hr))
    {
        hrd = WIN32ERROR_FROM_HRESULT(hr);
        pwszType = wszWIN32ERRORPREFIX L"/" wszHTTPERRORPREFIX wszCOLONSPACE;
    }
    else if (ISWIN32HRESULT(hr) || ISWIN32ERROR(hr))
    {
        hrd = WIN32ERROR_FROM_HRESULT(hr);
        pwszType = wszWIN32ERRORPREFIX wszCOLONSPACE;
    }
    else if (ISDELAYLOADHRESULTFACILITY(hr))
    {
        hrd = WIN32ERROR_FROM_DELAYLOAD(hr);
        pwszType = wszWIN32ERRORPREFIX wszCOLONSPACE;
    }
    else if (ISSETUPHRESULT(hr))
    {
        pwszType = wszSETUPERRORPREFIX wszCOLONSPACE;
    }
    if (fRaw)
    {
        pwszType = L"";
    }

    _snwprintf(
        awchr,
        cwcHRESULTSTRING,
        L"0x%x (%ws%d)",
        hr,
        pwszType,
        hrd);
    return(awchr);
}


WCHAR const *
ceHResultToString(
    IN OUT WCHAR *awchr,
    IN HRESULT hr)
{
    return(ceHResultToStringEx(awchr, hr, FALSE));
}


WCHAR const *
ceHResultToStringRaw(
    IN OUT WCHAR *awchr,
    IN HRESULT hr)
{
    return(ceHResultToStringEx(awchr, hr, TRUE));
}


static HMODULE s_hMod = NULL;
static DWORD s_idsUnexpected = 0;
static DWORD s_idsUnknownErrorCode = 0;	// L"Error %ws %ws"

VOID
ceInitErrorMessageText(
    IN HMODULE hMod,
    IN DWORD idsUnexpected,
    IN DWORD idsUnknownErrorCode)	// L"Error %ws %ws"
{
    s_hMod = hMod;
    s_idsUnexpected = idsUnexpected;
    s_idsUnknownErrorCode = idsUnknownErrorCode;
}


DWORD
errFormatMessage(
    IN HMODULE hMod,
    IN HRESULT hr,
    OUT WCHAR const **ppwszOut,
    OPTIONAL IN WCHAR const * const *ppwszArgs)
{
    DWORD dwFlags;

    dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER;
    if (NULL == hMod)
    {
	dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else
    {
	dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
    }
    if (NULL == ppwszArgs || NULL == ppwszArgs[0])
    {
	dwFlags |= FORMAT_MESSAGE_IGNORE_INSERTS;
    }
    else
    {
	dwFlags |= FORMAT_MESSAGE_ARGUMENT_ARRAY;
    }
    return(FormatMessage(
		dwFlags,
                hMod,
                hr,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), 
                (WCHAR *) ppwszOut,
                1,    
		(va_list *) ppwszArgs));
}


// Alloc and return error message string

WCHAR const *
ceGetErrorMessageText(
    IN HRESULT hr,
    IN BOOL fHResultString)
{
    return(ceGetErrorMessageTextEx(hr, fHResultString, NULL));
}


WCHAR const *
ceGetErrorMessageText1(
    IN HRESULT hr,
    IN BOOL fHResultString,
    IN OPTIONAL WCHAR const *pwszInsertionText)
{
    WCHAR const *apwszInsertionText[2];
    WCHAR const * const *papwsz = NULL;

    if (NULL != pwszInsertionText)
    {
	apwszInsertionText[0] = pwszInsertionText;
	apwszInsertionText[1] = NULL;
	papwsz = apwszInsertionText;
    }
    return(ceGetErrorMessageTextEx(hr, fHResultString, papwsz));
}


WCHAR const *
ceGetErrorMessageTextEx(
    IN HRESULT hr,
    IN BOOL fHResultString,
    IN OPTIONAL WCHAR const * const *papwszInsertionText)
{
    WCHAR const *pwszRet = NULL;
    WCHAR const *pwszRetStatic = NULL;
    WCHAR *pwszMsgT;
    WCHAR awchr[cwcHRESULTSTRING];
    DWORD cwc;
    DWORD cwcCopy;
    DWORD cwcUnexpected;
    WCHAR const *pwszUnexpected = NULL;
    WCHAR wszEmpty[] = L"";
    HMODULE hMod1 = NULL;
    HMODULE hMod2 = NULL;

    if (E_UNEXPECTED == hr)
    {
	pwszUnexpected = L"Unexpected method call sequence.";
    }
#if (0 == i386)
    else if (STATUS_DATATYPE_MISALIGNMENT == hr)
    {
	pwszUnexpected = L"Possible data alignment fault.";
    }
#endif
    if (NULL == pwszUnexpected)
    {
	pwszUnexpected = wszEmpty;
    }
    cwcUnexpected = wcslen(pwszUnexpected);

    cwc = errFormatMessage(NULL, hr, &pwszRet, papwszInsertionText);
    if (0 == cwc && ISDELAYLOADHRESULTFACILITY(hr))
    {
	cwc = errFormatMessage(
			NULL,
			WIN32ERROR_FROM_DELAYLOAD(hr),
			&pwszRet,
			papwszInsertionText);
    }
    if (0 == cwc)
    {
        hMod1 = LoadLibrary(L"ntdsbmsg.dll");
        if (NULL != hMod1)
        {
            HRESULT hrEDB = hr;
            HRESULT hrFormat;
            BOOL fFirst = TRUE;

            while (TRUE)
            {
                cwc = errFormatMessage(hMod1, hrEDB, &pwszRet, papwszInsertionText);
                if (0 == cwc && FAILED(hrEDB) && fFirst)
                {
                    hrFormat = ceHLastError();
                    if (HRESULT_FROM_WIN32(ERROR_MR_MID_NOT_FOUND) == hrFormat)
                    {
                        hrEDB = ceJetHResult(hrEDB);
                        if (hrEDB != hr)
                        {
                            fFirst = FALSE;
                            continue;
                        }
                    }
                }
                break;
            }
        }
    }
    if (0 == cwc)
    {
	HMODULE hModT = GetModuleHandle(L"wininet.dll");
        if (NULL != hModT)
        {
            HRESULT hrHttp = hr;
            HRESULT hrFormat;
            BOOL fFirst = TRUE;

            while (TRUE)
            {
		cwc = errFormatMessage(hModT, hrHttp, &pwszRet, papwszInsertionText);
                if (0 == cwc && ISWIN32HRESULT(hrHttp) && fFirst)
                {
                    hrFormat = ceHLastError();
                    if (HRESULT_FROM_WIN32(ERROR_MR_MID_NOT_FOUND) == hrFormat)
                    {
			hrHttp = WIN32ERROR_FROM_HRESULT(hrHttp);
                        if (hrHttp != hr)
                        {
                            fFirst = FALSE;
                            continue;
                        }
                    }
                }
                break;
            }
        }
    }
    if (0 == cwc)
    {
        hMod2 = LoadLibrary(L"cdosys.dll");
        if (NULL != hMod2)
        {
	    cwc = errFormatMessage(hMod2, hr, &pwszRet, papwszInsertionText);
        }
    }

    if (0 == cwc)	// couldn't find error, use default & error code
    {
	fHResultString = TRUE;
    }
    awchr[0] = L'\0';
    if (fHResultString)
    {
	ceHResultToString(awchr, hr);
    }

    if (0 == cwc)
    {
	pwszRetStatic = L"Error";
	pwszRet = pwszRetStatic;
    }

    // strip trailing \r\n

    cwcCopy = wcslen(pwszRet);
    if (2 <= cwcCopy &&
	L'\r' == pwszRet[cwcCopy - 2] &&
	L'\n' == pwszRet[cwcCopy - 1])
    {
	cwcCopy -= 2;
    }
    cwc = cwcCopy + 1 + cwcUnexpected + 1 + wcslen(awchr) + 1;
    pwszMsgT = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszMsgT)
    {
	_JumpError(E_OUTOFMEMORY, error, "LocalAlloc");
    }
    CopyMemory(pwszMsgT, pwszRet, cwcCopy * sizeof(WCHAR));
    pwszMsgT[cwcCopy] = L'\0';

    if (0 != cwcUnexpected)
    {
	wcscat(pwszMsgT, L" ");
	wcscat(pwszMsgT, pwszUnexpected);
    }
    if (fHResultString)
    {
	wcscat(pwszMsgT, L" ");
	wcscat(pwszMsgT, awchr);
    }
    assert(wcslen(pwszMsgT) < cwc);
    if (NULL != pwszRet && pwszRetStatic != pwszRet)
    {
	LocalFree(const_cast<WCHAR *>(pwszRet));
    }
    pwszRet = pwszMsgT;

error:
    if (NULL != hMod1)
    {
        FreeLibrary(hMod1);
    }
    if (NULL != hMod2)
    {
        FreeLibrary(hMod2);
    }
    return(pwszRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\celib\ceformat.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       ceformat.cpp
//
//  Contents:   helper functions
//
//--------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "celib.h"
#include <assert.h>
#include <wininet.h>



HRESULT
ceDupString(
    IN WCHAR const *pwszIn,
    IN WCHAR **ppwszOut)
{
    DWORD cb;
    HRESULT hr;

    cb = (wcslen(pwszIn) + 1) * sizeof(WCHAR);
    *ppwszOut = (WCHAR *) LocalAlloc(LMEM_FIXED, cb);
    if (NULL == *ppwszOut)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(*ppwszOut, pwszIn, cb);
    hr = S_OK;

error:
    return(hr);
}


#define cwcCNMAX 	64		// 64 chars max for CN
#define cwcCHOPHASHMAX	(1 + 5)		// "-%05hu" decimal USHORT hash digits
#define cwcCHOPBASE 	(cwcCNMAX - (cwcCHOPHASHMAX + cwcSUFFIXMAX))

HRESULT
ceSanitizedNameToDSName(
    IN WCHAR const *pwszSanitizedName,
    OUT WCHAR **ppwszNameOut)
{
    HRESULT hr;
    DWORD cwc;
    DWORD cwcCopy;
    WCHAR wszDSName[cwcCHOPBASE + cwcCHOPHASHMAX + 1];

    *ppwszNameOut = NULL;

    cwc = wcslen(pwszSanitizedName);
    cwcCopy = cwc;
    if (cwcCHOPBASE < cwcCopy)
    {
	cwcCopy = cwcCHOPBASE;
    }
    CopyMemory(wszDSName, pwszSanitizedName, cwcCopy * sizeof(WCHAR));
    wszDSName[cwcCopy] = L'\0';

    if (cwcCHOPBASE < cwc)
    {
        // Hash the rest of the name into a USHORT
        USHORT usHash = 0;
	DWORD i;
	WCHAR *pwsz;

	// Truncate an incomplete sanitized Unicode character
	
	pwsz = wcsrchr(wszDSName, L'!');
	if (NULL != pwsz && wcslen(pwsz) < 5)
	{
	    cwcCopy -= wcslen(pwsz);
	    *pwsz = L'\0';
	}

        for (i = cwcCopy; i < cwc; i++)
        {
            USHORT usLowBit = (0x8000 & usHash)? 1 : 0;

	    usHash = ((usHash << 1) | usLowBit) + pwszSanitizedName[i];
        }
	wsprintf(&wszDSName[cwcCopy], L"-%05hu", usHash);
	assert(wcslen(wszDSName) < ARRAYSIZE(wszDSName));
    }

    hr = ceDupString(wszDSName, ppwszNameOut);
    _JumpIfError(hr, error, "ceDupString");

error:
    return(hr);
}


HRESULT
ceInternetCanonicalizeUrl(
    IN WCHAR const *pwszIn,
    OUT WCHAR **ppwszOut)
{
    HRESULT hr;
    WCHAR *pwsz = NULL;

    assert(NULL != pwszIn);

    if (0 == _wcsnicmp(L"file:", pwszIn, 5))
    {
	hr = ceDupString(pwszIn, &pwsz);
        _JumpIfError(hr, error, "ceDupString");
    }
    else
    {
	// Calculate required buffer size by passing a very small buffer
	// The call will fail, and tell us how big the buffer should be.

	WCHAR wszPlaceHolder[1];
	DWORD cwc = ARRAYSIZE(wszPlaceHolder);
	BOOL bResult;

	bResult = InternetCanonicalizeUrl(
				    pwszIn,		// lpszUrl
				    wszPlaceHolder,	// lpszBuffer
				    &cwc,		// lpdwBufferLength
				    0);		// dwFlags
	assert(!bResult);	// This will always fail

	hr = ceHLastError();
	if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
	{
	    // unexpected error

	    _JumpError(hr, error, "InternetCanonicalizeUrl");
	}

	// NOTE: InternetCanonicalizeUrl counts characters, not bytes as doc'd
	// cwc includes trailing L'0'

	pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	if (NULL == pwsz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	// canonicalize
	if (!InternetCanonicalizeUrl(
				pwszIn,	// lpszUrl
				pwsz,	// lpszBuffer
				&cwc,	// lpdwBufferLength
				0))		// dwFlags
	{
	    hr = ceHLastError();
	    _JumpError(hr, error, "InternetCanonicalizeUrl");
	}
    }
    *ppwszOut = pwsz;
    pwsz = NULL;
    hr = S_OK;

error:
    if (NULL != pwsz)
    {
        LocalFree(pwsz);
    }
    return(hr);
}


// ceFormatCertsrvStringArray FormatMessage arguments:
//
// %1 -- Machine full DNS name: pwszServerName_p1_2;
//
// %2 -- Machine short name: first DNS component of pwszServerName_p1_2
//
// %3 -- Sanitized CA name: pwszSanitizedName_p3_7 
//
// %4 -- Cert Filename Suffix:
//       if 0 == iCert_p4 && MAXDWORD == iCertTarget_p4: L""
//       else if MAXDWORD != iCertTarget_p4 L"(%u-%u)"
//       else L"(%u)"
//
// %5 -- DS DN path to Domain root: pwszDomainDN_p5
//
// %6 -- DS DN path to Configuration container: pwszConfigDN_p6
//
// %7 -- Sanitized CA name, truncated and hash suffix added if too long:
//	 pwszSanitizedName_p3_7
//
// %8 -- CRL Filename/Key Name Suffix: L"" if 0 == iCRL_p8; else L"(%u)"
//
// %9 -- CRL Filename Suffix: L"" if !fDeltaCRL_p9; else L"+"
//
// %10 -- DS CRL attribute: L"" if !fDSAttrib_p10_11; depends on fDeltaCRL_p9
//
// %11 -- DS CA Cert attribute: L"" if !fDSAttrib_p10_11
//
// %12 -- DS user cert attribute
//
// %13 -- DS KRA cert attribute
//
// %14 -- DS cross cert pair attribute

#ifndef wszDSSEARCHBASECRLATTRIBUTE
#define wszDSSEARCHBASECRLATTRIBUTE L"?certificateRevocationList?base?objectclass=cRLDistributionPoint"
#endif

#ifndef wszDSSEARCHDELTACRLATTRIBUTE
#define wszDSSEARCHDELTACRLATTRIBUTE L"?deltaRevocationList?base?objectclass=cRLDistributionPoint"
#endif

#ifndef wszDSSEARCHCACERTATTRIBUTE
#define wszDSSEARCHCACERTATTRIBUTE L"?cACertificate?base?objectclass=certificationAuthority"
#endif

#ifndef wszDSSEARCHUSERCERTATTRIBUTE
#define wszDSSEARCHUSERCERTATTRIBUTE L"?userCertificate?base?objectClass=*"
#endif

#ifndef wszDSSEARCHKRACERTATTRIBUTE
#define wszDSSEARCHKRACERTATTRIBUTE L"?userCertificate?one?objectClass=msPKI-PrivateKeyRecoveryAgent"
#endif

#ifndef wszDSSEARCHCROSSCERTPAIRATTRIBUTE
#define wszDSSEARCHCROSSCERTPAIRATTRIBUTE L"?crossCertificatePair?one?objectClass=certificationAuthority"
#endif


HRESULT 
ceFormatCertsrvStringArray(
    IN BOOL    fURL,
    IN LPCWSTR pwszServerName_p1_2,
    IN LPCWSTR pwszSanitizedName_p3_7, 
    IN DWORD   iCert_p4,
    IN DWORD   iCertTarget_p4,
    IN LPCWSTR pwszDomainDN_p5,
    IN LPCWSTR pwszConfigDN_p6, 
    IN DWORD   iCRL_p8,
    IN BOOL    fDeltaCRL_p9,
    IN BOOL    fDSAttrib_p10_11,
    IN DWORD   cStrings,
    IN LPCWSTR *apwszStringsIn,
    OUT LPWSTR *apwszStringsOut)
{
    HRESULT hr = S_OK;
    LPCWSTR apwszInsertionArray[100];  // 100 'cause this is the max number of insertion numbers allowed by FormatMessage
    LPWSTR    pwszCurrent = NULL;
    BSTR      strShortMachineName = NULL;
    DWORD     i;
    WCHAR *pwszSanitizedDSName = NULL;
    WCHAR wszCertSuffix[2 * cwcFILENAMESUFFIXMAX];
    WCHAR wszCRLSuffix[cwcFILENAMESUFFIXMAX];
    WCHAR wszDeltaCRLSuffix[cwcFILENAMESUFFIXMAX];
    WCHAR const *pwszT;


    ZeroMemory(apwszStringsOut, cStrings * sizeof(apwszStringsOut[0]));
    ZeroMemory(apwszInsertionArray, sizeof(apwszInsertionArray));

    // Format the template into a real name
    // Initialize the insertion string array.

    //+================================================
    // Machine DNS name (%1)    

    assert(L'1' == wszFCSAPARM_SERVERDNSNAME[1]);
    apwszInsertionArray[1 - 1] = pwszServerName_p1_2;

    //+================================================
    // Short Machine Name (%2)

    assert(L'2' == wszFCSAPARM_SERVERSHORTNAME[1]);
    strShortMachineName = SysAllocString(pwszServerName_p1_2);
    if (strShortMachineName == NULL)
    {
        hr = E_OUTOFMEMORY;
        _JumpIfError(hr, error, "SysAllocString");
    }

    pwszCurrent = wcschr(strShortMachineName, L'.');
    if (NULL != pwszCurrent)
    {
        *pwszCurrent = 0;
    }
    apwszInsertionArray[2 - 1] = strShortMachineName;

    //+================================================
    // sanitized name (%3)

    assert(L'3' == wszFCSAPARM_SANITIZEDCANAME[1]);
    apwszInsertionArray[3 - 1] = pwszSanitizedName_p3_7;  

    //+================================================
    // Cert filename suffix (%4) | (%4-%4)

    assert(L'4' == wszFCSAPARM_CERTFILENAMESUFFIX[1]);
    wszCertSuffix[0] = L'\0';
    if (0 != iCert_p4 || MAXDWORD != iCertTarget_p4)
    {
        wsprintf(
	    wszCertSuffix,
	    MAXDWORD != iCertTarget_p4? L"(%u-%u)" : L"(%u)",
	    iCert_p4,
	    iCertTarget_p4);
    }
    apwszInsertionArray[4 - 1] = wszCertSuffix;  

    //+================================================
    // Domain DN (%5)

    if (NULL == pwszDomainDN_p5 || L'\0' == *pwszDomainDN_p5)
    {
	pwszDomainDN_p5 = L"DC=UnavailableDomainDN";
    }
    assert(L'5' == wszFCSAPARM_DOMAINDN[1]);
    apwszInsertionArray[5 - 1] = pwszDomainDN_p5;

    //+================================================
    // Config DN (%6)

    if (NULL == pwszConfigDN_p6 || L'\0' == *pwszConfigDN_p6)
    {
	pwszConfigDN_p6 = L"DC=UnavailableConfigDN";
    }
    assert(L'6' == wszFCSAPARM_CONFIGDN[1]);
    apwszInsertionArray[6 - 1] = pwszConfigDN_p6;

    // Don't pass pwszSanitizedName_p3_7 to SysAllocStringLen with the extended
    // length to avoid faulting past end of pwszSanitizedName_p3_7.

    //+================================================
    // Sanitized Short Name (%7)

    assert(L'7' == wszFCSAPARM_SANITIZEDCANAMEHASH[1]);
    hr = ceSanitizedNameToDSName(pwszSanitizedName_p3_7, &pwszSanitizedDSName);
    _JumpIfError(hr, error, "ceSanitizedNameToDSName");

    apwszInsertionArray[7 - 1] = pwszSanitizedDSName;

    //+================================================
    // CRL filename suffix (%8)

    assert(L'8' == wszFCSAPARM_CRLFILENAMESUFFIX[1]);
    wszCRLSuffix[0] = L'\0';
    if (0 != iCRL_p8)
    {
        wsprintf(wszCRLSuffix, L"(%u)", iCRL_p8);
    }
    apwszInsertionArray[8 - 1] = wszCRLSuffix;  

    //+================================================
    // Delta CRL filename suffix (%9)

    assert(L'9' == wszFCSAPARM_CRLDELTAFILENAMESUFFIX[1]);
    wszDeltaCRLSuffix[0] = L'\0';
    if (fDeltaCRL_p9)
    {
        wcscpy(wszDeltaCRLSuffix, L"+");
    }
    apwszInsertionArray[9 - 1] = wszDeltaCRLSuffix;  

    //+================================================
    // CRL attribute (%10)

    assert(L'1' == wszFCSAPARM_DSCRLATTRIBUTE[1]);
    assert(L'0' == wszFCSAPARM_DSCRLATTRIBUTE[2]);
    pwszT = L"";
    if (fDSAttrib_p10_11)
    {
	pwszT = fDeltaCRL_p9?
		    wszDSSEARCHDELTACRLATTRIBUTE :
		    wszDSSEARCHBASECRLATTRIBUTE;
    }
    apwszInsertionArray[10 - 1] = pwszT;  

    //+================================================
    // CA cert attribute (%11)

    assert(L'1' == wszFCSAPARM_DSCACERTATTRIBUTE[1]);
    assert(L'1' == wszFCSAPARM_DSCACERTATTRIBUTE[2]);
    pwszT = L"";
    if (fDSAttrib_p10_11)
    {
	pwszT = wszDSSEARCHCACERTATTRIBUTE;
    }
    apwszInsertionArray[11 - 1] = pwszT;  

    //+================================================
    // User cert attribute (%12)

    assert(L'1' == wszFCSAPARM_DSUSERCERTATTRIBUTE[1]);
    assert(L'2' == wszFCSAPARM_DSUSERCERTATTRIBUTE[2]);
    pwszT = L"";
    if (fDSAttrib_p10_11)
    {
	pwszT = wszDSSEARCHUSERCERTATTRIBUTE;
    }
    apwszInsertionArray[12 - 1] = pwszT;  

    //+================================================
    // KRA cert attribute (%13)

    assert(L'1' == wszFCSAPARM_DSKRACERTATTRIBUTE[1]);
    assert(L'3' == wszFCSAPARM_DSKRACERTATTRIBUTE[2]);
    pwszT = L"";
    if (fDSAttrib_p10_11)
    {
	pwszT = wszDSSEARCHKRACERTATTRIBUTE;
    }
    apwszInsertionArray[13 - 1] = pwszT;  

    //+================================================
    // Cross cert pair attribute (%14)

    assert(L'1' == wszFCSAPARM_DSCROSSCERTPAIRATTRIBUTE[1]);
    assert(L'4' == wszFCSAPARM_DSCROSSCERTPAIRATTRIBUTE[2]);
    pwszT = L"";
    if (fDSAttrib_p10_11)
    {
	pwszT = wszDSSEARCHCROSSCERTPAIRATTRIBUTE;
    }
    apwszInsertionArray[14 - 1] = pwszT;  

    //+================================================
    // Now format the strings...

    for (i = 0; i < cStrings; i++)
    {
        if (0 == FormatMessage(
			FORMAT_MESSAGE_ALLOCATE_BUFFER |
			    FORMAT_MESSAGE_FROM_STRING |
			    FORMAT_MESSAGE_ARGUMENT_ARRAY,
			(VOID *) apwszStringsIn[i],
			0,              // dwMessageID
			0,              // dwLanguageID
			(LPWSTR) &apwszStringsOut[i], 
			wcslen(apwszStringsIn[i]),
			(va_list *) apwszInsertionArray))
        {
            hr = ceHLastError();
	    _JumpError(hr, error, "FormatMessage");
        }
	if (fURL)
	{
	    WCHAR *pwsz;
	    
	    hr = ceInternetCanonicalizeUrl(apwszStringsOut[i], &pwsz);
	    _JumpIfError(hr, error, "ceInternetCanonicalizeUrl");

	    LocalFree(apwszStringsOut[i]);
	    apwszStringsOut[i] = pwsz;
	}
    }

error:
    if (S_OK != hr)
    {
	for (i = 0; i < cStrings; i++)
	{
	    if (NULL != apwszStringsOut[i])
	    {
		LocalFree(apwszStringsOut[i]);
		apwszStringsOut[i] = NULL;
	    }
	}
    }
    if (NULL != strShortMachineName)
    {
        SysFreeString(strShortMachineName);
    }
    if (NULL != pwszSanitizedDSName)
    {
        LocalFree(pwszSanitizedDSName);
    }
    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\celib\celib.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       celib.cpp
//
//  Contents:   helper functions
//
//--------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

#include "celib.h"
#include <assert.h>

//+--------------------------------------------------------------------------
// ceDecodeObject -- call CryptDecodeObject, and allocate memory for output
//
//+--------------------------------------------------------------------------

#pragma warning(push)
#pragma warning(disable: 4100)	// unreferenced formal parameter
BOOL
ceDecodeObject(
    IN DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN BOOL fCoTaskMemAlloc,	// referenced only by assert
    OUT VOID **ppvStructInfo,
    OUT DWORD *pcbStructInfo)
{
    BOOL b;

    assert(!fCoTaskMemAlloc);
    *ppvStructInfo = NULL;
    *pcbStructInfo = 0;
    while (TRUE)
    {
	b = CryptDecodeObject(
		    dwEncodingType,
		    lpszStructType,
		    pbEncoded,
		    cbEncoded,
		    0,                  // dwFlags
		    *ppvStructInfo,
		    pcbStructInfo);
	if (b && 0 == *pcbStructInfo)
	{
	    SetLastError((DWORD) HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	    b = FALSE;
	}
	if (!b)
	{
	    if (NULL != *ppvStructInfo)
	    {
		HRESULT hr = GetLastError();

		LocalFree(*ppvStructInfo);
		*ppvStructInfo = NULL;
		SetLastError(hr);
	    }
	    break;
	}
	if (NULL != *ppvStructInfo)
	{
	    break;
	}
	*ppvStructInfo = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbStructInfo);
	if (NULL == *ppvStructInfo)
	{
	    b = FALSE;
	    break;
	}
    }
    return(b);
}
#pragma warning(pop)


#pragma warning(push)
#pragma warning(disable: 4100)	// unreferenced formal parameter
BOOL
ceEncodeObject(
    IN DWORD dwEncodingType,
    IN LPCSTR lpszStructType,
    IN VOID const *pvStructInfo,
    IN DWORD dwFlags,		// referenced only by assert
    IN BOOL fCoTaskMemAlloc,	// referenced only by assert
    OUT BYTE **ppbEncoded,
    OUT DWORD *pcbEncoded)
{
    BOOL b;

    assert(0 == dwFlags);
    assert(!fCoTaskMemAlloc);
    *ppbEncoded = NULL;
    *pcbEncoded = 0;
    while (TRUE)
    {
	b = CryptEncodeObject(
		    dwEncodingType,
		    lpszStructType,
		    const_cast<VOID *>(pvStructInfo),
		    *ppbEncoded,
		    pcbEncoded);
	if (b && 0 == *pcbEncoded)
	{
	    SetLastError((DWORD) HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	    b = FALSE;
	}
	if (!b)
	{
	    if (NULL != *ppbEncoded)
	    {
		HRESULT hr = GetLastError();

		LocalFree(*ppbEncoded);
		*ppbEncoded = NULL;
		SetLastError(hr);
	    }
	    break;
	}
	if (NULL != *ppbEncoded)
	{
	    break;
	}
	*ppbEncoded = (BYTE *) LocalAlloc(LMEM_FIXED, *pcbEncoded);
	if (NULL == *ppbEncoded)
	{
	    b = FALSE;
	    break;
	}
    }
    return(b);
}
#pragma warning(pop)


// The returned pszObjId is a constant that must not be freed.  CryptFindOIDInfo
// has a static internal database that is valid until crypt32.dll is unloaded.

WCHAR const *
ceGetOIDNameA(
    IN char const *pszObjId)
{
    CRYPT_OID_INFO const *pInfo = NULL;
    WCHAR const *pwszName = L"";

    // First try looking up the ObjectId as an Extension or Attribute, because
    // we get a better Display Name, especially for Subject RDNs: CN, L, etc.
    // If that fails, look it up withoput restricting the group.

    pInfo = CryptFindOIDInfo(
			CRYPT_OID_INFO_OID_KEY,
			(VOID *) pszObjId,
			CRYPT_EXT_OR_ATTR_OID_GROUP_ID);

    if (NULL == pInfo || NULL == pInfo->pwszName || L'\0' == pInfo->pwszName[0])
    {
	pInfo = CryptFindOIDInfo(CRYPT_OID_INFO_OID_KEY, (VOID *) pszObjId, 0);
    }
    if (NULL != pInfo && NULL != pInfo->pwszName && L'\0' != pInfo->pwszName[0])
    {
	pwszName = pInfo->pwszName;
    }
    return(pwszName);
}


WCHAR const *
ceGetOIDName(
    IN WCHAR const *pwszObjId)
{
    char *pszObjId = NULL;
    WCHAR const *pwszName = L"";

    if (!ceConvertWszToSz(&pszObjId, pwszObjId, -1))
    {
	_JumpError(E_OUTOFMEMORY, error, "ceConvertWszToSz");
    }
    pwszName = ceGetOIDNameA(pszObjId);

error:
    if (NULL != pszObjId)
    {
	LocalFree(pszObjId);
    }
    return(pwszName);
}


WCHAR *
ceDuplicateString(
    IN WCHAR const *pwsz)
{
    WCHAR *pwszOut;

    pwszOut = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				(wcslen(pwsz) + 1) * sizeof(pwsz[0]));
    if (NULL != pwszOut)
    {
	wcscpy(pwszOut, pwsz);
    }
    return(pwszOut);
}


BOOL
ceConvertWszToSz(
    OUT CHAR **ppsz,
    IN WCHAR const *pwc,
    IN LONG cwc)
{
    BOOL fOk = FALSE;
    LONG cch = 0;

    *ppsz = NULL;
    while (TRUE)
    {
	cch = WideCharToMultiByte(
			GetACP(),
			0,          // dwFlags
			pwc,
			cwc,        // cchWideChar, -1 => null terminated
			*ppsz,
			cch,
			NULL,
			NULL);
	if (0 >= cch)
	{
	    DWORD err;

	    err = GetLastError();
	    ceERRORPRINTLINE("WideCharToMultiByte", err);
	    if (NULL != *ppsz)
	    {
		LocalFree(*ppsz);
		*ppsz = NULL;
	    }
	    break;
	}
	if (NULL != *ppsz)
	{
	    fOk = TRUE;
	    break;
	}
	*ppsz = (CHAR *) LocalAlloc(LMEM_FIXED, cch + 1);
	if (NULL == *ppsz)
	{
	    break;
	}
    }
    return(fOk);
}


BOOL
ceConvertWszToBstr(
    OUT BSTR *pbstr,
    IN WCHAR const *pwc,
    IN LONG cb)
{
    BOOL fOk = FALSE;
    BSTR bstr;

    ceFreeBstr(pbstr);
    do
    {
	bstr = NULL;
	if (NULL != pwc)
	{
	    if (-1 == cb)
	    {
		cb = wcslen(pwc) * sizeof(WCHAR);
	    }
	    bstr = SysAllocStringByteLen((char const *) pwc, cb);
	    if (NULL == bstr)
	    {
		break;
	    }
	}
	*pbstr = bstr;
	fOk = TRUE;
    } while (FALSE);
    return(fOk);
}


BOOL
ceConvertSzToWsz(
    OUT WCHAR **ppwsz,
    IN char const *pch,
    IN LONG cch)
{
    BOOL fOk = FALSE;
    LONG cwc = 0;

    *ppwsz = NULL;
    while (TRUE)
    {
	cwc = MultiByteToWideChar(GetACP(), 0, pch, cch, *ppwsz, cwc);
	if (0 >= cwc)
	{
	    DWORD err;

	    err = GetLastError();
	    ceERRORPRINTLINE("MultiByteToWideChar", err);
	    if (NULL != *ppwsz)
	    {
		LocalFree(*ppwsz);
		*ppwsz = NULL;
	    }
	    break;
	}
	if (NULL != *ppwsz)
	{
	    fOk = TRUE;
	    break;
	}
	*ppwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	if (NULL == *ppwsz)
	{
	    break;
	}
    }
    return(fOk);
}


BOOL
ceConvertSzToBstr(
    OUT BSTR *pbstr,
    IN CHAR const *pch,
    IN LONG cch)
{
    BOOL fOk = FALSE;
    BSTR bstr = NULL;
    LONG cwc = 0;

    ceFreeBstr(pbstr);
    if (-1 == cch)
    {
	cch = strlen(pch);
    }
    while (TRUE)
    {
	cwc = MultiByteToWideChar(GetACP(), 0, pch, cch, bstr, cwc);
	if (0 >= cwc)
	{
	    //hr = ceHLastError();
	    //printf("MultiByteToWideChar returned %d (%x)\n", hr, hr);
	    break;
	}
	if (NULL != bstr)
	{
	    bstr[cwc] = L'\0';
	    *pbstr = bstr;
	    fOk = TRUE;
	    break;
	}
	bstr = SysAllocStringLen(NULL, cwc);
	if (NULL == bstr)
	{
	    break;
	}
    }
    return(fOk);
}


VOID
ceFreeBstr(
    IN OUT BSTR *pstr)
{
    if (NULL != *pstr)
    {
	SysFreeString(*pstr);
	*pstr = NULL;
    }
}


HRESULT
ceHError(
    IN HRESULT hr)
{
    assert(S_FALSE != hr);

    if (S_OK != hr && S_FALSE != hr && !FAILED(hr))
    {
        hr = HRESULT_FROM_WIN32(hr);
	if ((HRESULT) 0 == HRESULT_CODE(hr))
	{
	    // A call failed without properly setting an error condition!
	    hr = E_UNEXPECTED;
	}
	assert(FAILED(hr));
    }
    return(hr);
}


HRESULT
ceHLastError(VOID)
{
    return(ceHError(GetLastError()));
}


VOID
ceErrorPrintLine(
    IN char const *pszFile,
    IN DWORD line,
    IN char const *pszMessage,
    IN WCHAR const *pwszData,
    IN HRESULT hr)
{
    CHAR ach[4096];
    LONG cch;

#pragma prefast(disable:53, "PREfast bug 650")
    cch = _snprintf(
		ach,
		sizeof(ach),
		"CeLib: Error: %hs(%u): %hs%hs%ws%hs 0x%x (%d)\n",
		pszFile,
		line,
		pszMessage,
		NULL == pwszData? "" : szLPAREN,
		NULL == pwszData? L"" : pwszData,
		NULL == pwszData? "" : szRPAREN,
		hr,
		hr);
#pragma prefast(enable:53, "re-enable")
    if (0 > cch || sizeof(ach) <= cch)
    {
	strcpy(&ach[sizeof(ach) - 5], "...\n");
    }
    OutputDebugStringA(ach);
    wprintf(L"%hs", ach);
}


HRESULT
ceDateToFileTime(
    IN DATE const *pDate,
    OUT FILETIME *pft)
{
    SYSTEMTIME st;
    HRESULT hr = S_OK;

    if (*pDate == 0.0)
    {
        GetSystemTime(&st);
    }
    else
    {
	if (!VariantTimeToSystemTime(*pDate, &st))
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _JumpError(hr, error, "VariantTimeToSystemTime");
	}
    }

    if (!SystemTimeToFileTime(&st, pft))
    {
        hr = ceHLastError();
        _JumpError(hr, error, "SystemTimeToFileTime");
    }

error:
    return(hr);
}


HRESULT
ceFileTimeToDate(
    IN FILETIME const *pft,
    OUT DATE *pDate)
{
    SYSTEMTIME st;
    HRESULT hr = S_OK;

    if (!FileTimeToSystemTime(pft, &st))
    {
        hr = ceHLastError();
        _JumpError(hr, error, "FileTimeToSystemTime");
    }
    if (!SystemTimeToVariantTime(&st, pDate))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        _JumpError(hr, error, "SystemTimeToVariantTime");
    }

error:
    return(hr);
}


VOID
ceMakeExprDateTime(
    IN OUT FILETIME *pft,
    IN LONG lDelta,
    IN enum ENUM_PERIOD enumPeriod)
{
    LLFILETIME llft;
    LONGLONG llDelta;
    BOOL fSysTimeDelta;

    llft.ft = *pft;
    llDelta = lDelta;
    fSysTimeDelta = FALSE;
    switch (enumPeriod)
    {
	case ENUM_PERIOD_WEEKS:   llDelta *= CVT_WEEKS;    break;
	case ENUM_PERIOD_DAYS:    llDelta *= CVT_DAYS;     break;
	case ENUM_PERIOD_HOURS:   llDelta *= CVT_HOURS;    break;
	case ENUM_PERIOD_MINUTES: llDelta *= CVT_MINUTES;  break;
	case ENUM_PERIOD_SECONDS: 			   break;
	default:
	    fSysTimeDelta = TRUE;
	    break;
    }
    if (fSysTimeDelta)
    {
	SYSTEMTIME SystemTime;

	FileTimeToSystemTime(&llft.ft, &SystemTime);
	switch (enumPeriod)
	{
	    case ENUM_PERIOD_MONTHS:
		if (0 > lDelta)
		{
		    DWORD dwDelta = (DWORD) -lDelta;

		    SystemTime.wYear -= (WORD) (dwDelta / 12) + 1;
		    SystemTime.wMonth += 12 - (WORD) (dwDelta % 12);
		}
		else
		{
		    SystemTime.wMonth = (WORD) lDelta + SystemTime.wMonth;
		}
		if (12 < SystemTime.wMonth)
		{
		    SystemTime.wYear += (SystemTime.wMonth - 1) / 12;
		    SystemTime.wMonth = ((SystemTime.wMonth - 1) % 12) + 1;
		}
		break;

	    case ENUM_PERIOD_YEARS:
		SystemTime.wYear = (WORD) lDelta + SystemTime.wYear;
		break;

	    default:
		SystemTime.wYear += 1;
		break;
	}

DoConvert:
        if (!SystemTimeToFileTime(&SystemTime, &llft.ft))
        {
            if (GetLastError() != ERROR_INVALID_PARAMETER)
            {
                assert(!"Unable to do time conversion");
                return;
            }

            // In some cases we'll convert to an invalid month-end

            // only one month changes length from year to year
            if (SystemTime.wMonth == 2)
            {
                // > 29? try leap year
                if (SystemTime.wDay > 29)
                {
                    SystemTime.wDay = 29;
                    goto DoConvert;
                }
                // == 29? try non-leap year
                else if (SystemTime.wDay == 29)
                {
                    SystemTime.wDay = 28;
                    goto DoConvert;
                }
            }
            // sept (9), apr(4), jun(6), nov(11) all have 30 days
            else if ((SystemTime.wMonth == 9) ||
                     (SystemTime.wMonth == 4) ||
                     (SystemTime.wMonth == 6) ||
                     (SystemTime.wMonth == 11))
            {
                if (SystemTime.wDay > 30)
                {
                    SystemTime.wDay = 30;
                    goto DoConvert;
                }
            }

            // should never get here
            assert(!"Month/year processing: inaccessible code");
            return;
        }
    }
    else
    {
	llft.ll += llDelta * CVT_BASE;
    }
    *pft = llft.ft;
}


HRESULT
ceMakeExprDate(
    IN OUT DATE *pDate,
    IN LONG lDelta,
    IN enum ENUM_PERIOD enumPeriod)
{
    HRESULT hr;
    FILETIME ft;

    hr = ceDateToFileTime(pDate, &ft);
    _JumpIfError(hr, error, "ceDateToFileTime");

    ceMakeExprDateTime(&ft, lDelta, enumPeriod);

    hr = ceFileTimeToDate(&ft, pDate);
    _JumpIfError(hr, error, "ceFileTimeToDate");

error:
    return(hr);
}


typedef struct _UNITSTABLE
{
    WCHAR const     *pwszString;
    enum ENUM_PERIOD enumPeriod;
} UNITSTABLE;


UNITSTABLE g_aut[] =
{
    { wszPERIODSECONDS, ENUM_PERIOD_SECONDS },
    { wszPERIODMINUTES, ENUM_PERIOD_MINUTES },
    { wszPERIODHOURS,   ENUM_PERIOD_HOURS },
    { wszPERIODDAYS,    ENUM_PERIOD_DAYS },
    { wszPERIODWEEKS,   ENUM_PERIOD_WEEKS },
    { wszPERIODMONTHS,  ENUM_PERIOD_MONTHS },
    { wszPERIODYEARS,   ENUM_PERIOD_YEARS },
};
#define CUNITSTABLEMAX	(sizeof(g_aut)/sizeof(g_aut[0]))


HRESULT
ceTranslatePeriodUnits(
    IN WCHAR const *pwszPeriod,
    IN LONG lCount,
    OUT enum ENUM_PERIOD *penumPeriod,
    OUT LONG *plCount)
{
    HRESULT hr;
    UNITSTABLE const *put;

    for (put = g_aut; put < &g_aut[CUNITSTABLEMAX]; put++)
    {
	if (0 == celstrcmpiL(pwszPeriod, put->pwszString))
	{
	    *penumPeriod = put->enumPeriod;
	    if (0 > lCount)
	    {
		lCount = MAXLONG;
	    }
	    *plCount = lCount;
	    hr = S_OK;
	    goto error;
	}
    }
    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

error:
    return(hr);
}


//+-------------------------------------------------------------------------
// ceVerifyObjIdA - verify the passed pszObjId is valid as per X.208
//
// Encode and Decode the Object Id and make sure it suvives the round trip.
// The first number must be 0, 1 or 2.
// Enforce all characters are digits and dots.
// Enforce that no dot starts or ends the Object Id, and disallow double dots.
// Enforce there is at least one dot separator.
// If the first number is 0 or 1, the second number must be between 0 & 39.
// If the first number is 2, the second number can be any value.
//--------------------------------------------------------------------------

HRESULT
ceVerifyObjIdA(
    IN CHAR const *pszObjId)
{
    HRESULT hr;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    CRYPT_ATTRIBUTE ainfo;
    CRYPT_ATTRIBUTE *painfo = NULL;
    DWORD cbainfo;
    char const *psz;
    int i;

    ainfo.pszObjId = const_cast<char *>(pszObjId);
    ainfo.cValue = 0;
    ainfo.rgValue = NULL;

    if (!ceEncodeObject(
		    X509_ASN_ENCODING,
		    PKCS_ATTRIBUTE,
		    &ainfo,
		    0,
		    FALSE,
		    &pbEncoded,
		    &cbEncoded))
    {
	hr = ceHLastError();
	_JumpError(hr, error, "ceEncodeObject");
    }

    if (!ceDecodeObject(
		    X509_ASN_ENCODING,
		    PKCS_ATTRIBUTE,
		    pbEncoded,
		    cbEncoded,
		    FALSE,
		    (VOID **) &painfo,
		    &cbainfo))
    {
	hr = ceHLastError();
	_JumpError(hr, error, "ceDecodeObject");
    }

    hr = E_INVALIDARG;
    if (0 != strcmp(ainfo.pszObjId, painfo->pszObjId))
    {
	_JumpError(hr, error, "bad ObjId: decode mismatch");
    }
    for (psz = painfo->pszObjId; '\0' != *psz; psz++)
    {
	// must be a digit or a dot separator
	
	if (!isdigit(*psz))
	{
	    if ('.' != *psz)
	    {
		_JumpError(hr, error, "bad ObjId: bad char");
	    }

	    // can't have dot at start, double dots or dot at end

	    if (psz == painfo->pszObjId || '.' == psz[1] || '\0' == psz[1])
	    {
		_JumpError(hr, error, "bad ObjId: dot location");
	    }
	}
    }
    psz = strchr(painfo->pszObjId, '.');
    if (NULL == psz)
    {
	_JumpError(hr, error, "bad ObjId: must have at least one dot");
    }
    i = atoi(painfo->pszObjId);
    switch (i)
    {
	case 0:
	case 1:
	    i = atoi(++psz);
	    if (0 > i || 39 < i)
	    {
		_JumpError(hr, error, "bad ObjId: 0. or 1. must be followed by 0..39");
	    }
	    break;

	case 2:
	    break;

	default:
	    _JumpError(hr, error, "bad ObjId: must start with 0, 1 or 2");
    }
    hr = S_OK;

error:
    if (NULL != pbEncoded)
    {
    	LocalFree(pbEncoded);
    }
    if (NULL != painfo)
    {
    	LocalFree(painfo);
    }
    return(hr);
}


HRESULT
ceVerifyObjId(
    IN WCHAR const *pwszObjId)
{
    HRESULT hr;
    CHAR *pszObjId = NULL;

    if (!ceConvertWszToSz(&pszObjId, pwszObjId, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ceConvertWszToSz");
    }
    hr = ceVerifyObjIdA(pszObjId);
    _JumpIfErrorStr(hr, error, "ceVerifyObjIdA", pwszObjId);

error:
    if (NULL != pszObjId)
    {
    	LocalFree(pszObjId);
    }
    return(hr);
}


HRESULT
ceVerifyAltNameString(
    IN LONG NameChoice,
    IN BSTR strName)
{
    HRESULT hr = S_OK;
    CERT_ALT_NAME_INFO AltName;
    CERT_ALT_NAME_ENTRY Entry;
    CERT_OTHER_NAME OtherName;
    char *pszObjectId = NULL;
    DWORD cbEncoded;

    ZeroMemory(&AltName, sizeof(AltName));
    AltName.cAltEntry = 1;
    AltName.rgAltEntry = &Entry;

    ZeroMemory(&Entry, sizeof(Entry));
    Entry.dwAltNameChoice = NameChoice;

    switch (NameChoice)
    {
	case CERT_ALT_NAME_RFC822_NAME:
	    Entry.pwszRfc822Name = strName;
	    break;

	case CERT_ALT_NAME_DNS_NAME:
	    Entry.pwszDNSName = strName;
	    break;

	case CERT_ALT_NAME_URL:
	    Entry.pwszURL = strName;
	    break;

	case CERT_ALT_NAME_REGISTERED_ID:
	    if (!ceConvertWszToSz(&pszObjectId, strName, -1))
	    {
		hr = E_OUTOFMEMORY;
		ceERRORPRINTLINE("ceConvertWszToSz", hr);
		goto error;
	    }
	    Entry.pszRegisteredID = pszObjectId;
	    break;

	case CERT_ALT_NAME_OTHER_NAME:
	    Entry.pOtherName = &OtherName;
	    OtherName.pszObjId = szOID_NT_PRINCIPAL_NAME;
	    OtherName.Value.cbData = SysStringByteLen(strName);
	    OtherName.Value.pbData = (BYTE *) strName;
	    break;

	case CERT_ALT_NAME_DIRECTORY_NAME:
	    Entry.DirectoryName.cbData = SysStringByteLen(strName);
	    Entry.DirectoryName.pbData = (BYTE *) strName;
	    break;

	case CERT_ALT_NAME_IP_ADDRESS:
	    Entry.IPAddress.cbData = SysStringByteLen(strName);
	    Entry.IPAddress.pbData = (BYTE *) strName;
	    break;

	//case CERT_ALT_NAME_X400_ADDRESS:
	//case CERT_ALT_NAME_EDI_PARTY_NAME:
	default:
	    hr = E_INVALIDARG;
	    ceERRORPRINTLINE("NameChoice", hr);
	    goto error;
		
    }

    // Encode CERT_ALT_NAME_INFO:

    if (!CryptEncodeObject(
		    X509_ASN_ENCODING,
		    X509_ALTERNATE_NAME,
		    &AltName,
		    NULL,
		    &cbEncoded))
    {
	hr = ceHLastError();
	ceERRORPRINTLINE("ceEncodeObject", hr);
	goto error;
    }

error:
    if (NULL != pszObjectId)
    {
	LocalFree(pszObjectId);
    }
    return(hr);
}


HRESULT
ceDispatchSetErrorInfoSub(
    IN HRESULT hrError,
    OPTIONAL IN WCHAR const *pwszIDispatchMethod,
    OPTIONAL IN WCHAR const *pwszDescription,
    OPTIONAL IN WCHAR const *pwszSource,
    OPTIONAL IN IID const *piid,
    OPTIONAL IN WCHAR const *pwszHelpFile,
    IN DWORD dwHelpFileContext)
{
    HRESULT hr;
    WCHAR const *pwszError = NULL;
    ICreateErrorInfo *pCreateErrorInfo = NULL;
    IErrorInfo *pErrorInfo = NULL;

    if (NULL != pwszIDispatchMethod)
    {
	pwszError = ceGetErrorMessageText(hrError, TRUE);
    }

    hr = CreateErrorInfo(&pCreateErrorInfo);
    _JumpIfError(hr, error, "CreateErrorInfo");

    if (NULL != piid)
    {
	hr = pCreateErrorInfo->SetGUID(*piid);
	_PrintIfError(hr, "SetGUID");
    }
    if (NULL != pwszSource)
    {
	hr = pCreateErrorInfo->SetSource(const_cast<WCHAR *>(pwszSource));
	_PrintIfError(hr, "SetSource");
    }
    if (NULL != pwszDescription)
    {
	hr = pCreateErrorInfo->SetDescription(
					const_cast<WCHAR *>(pwszDescription));
	_PrintIfError(hr, "SetDescription");
    }
    if (NULL != pwszHelpFile)
    {
	hr = pCreateErrorInfo->SetHelpFile(const_cast<WCHAR *>(pwszHelpFile));
	_PrintIfError(hr, "SetHelpFile");

	hr = pCreateErrorInfo->SetHelpContext(dwHelpFileContext);
	_PrintIfError(hr, "SetHelpContext");
    }

    hr = pCreateErrorInfo->QueryInterface(
				    IID_IErrorInfo,
				    (VOID **) &pErrorInfo);
    _JumpIfError(hr, error, "QueryInterface");

    SetErrorInfo(0, pErrorInfo);
    hr = S_OK;

error:
    if (NULL != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
    if (NULL != pErrorInfo)
    {
	pErrorInfo->Release();
    }
    if (NULL != pCreateErrorInfo)
    {
	pCreateErrorInfo->Release();
    }
    return(hr);
}


HRESULT
ceDispatchSetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription,
    OPTIONAL IN WCHAR const *pwszProgId,
    OPTIONAL IN IID const *piid)
{
    HRESULT hr;
    WCHAR const *pwszError = NULL;
    WCHAR *pwszText = NULL;

    if (NULL == pwszDescription)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL pointer");
    }
    assert(FAILED(hrError));
    pwszError = ceGetErrorMessageText(hrError, TRUE);
    if (NULL == pwszError)
    {
	_PrintError(E_OUTOFMEMORY, "myGetErrorMessageText");
    }
    else
    {
	pwszText = (WCHAR *) LocalAlloc(
	    LMEM_FIXED,
	    (wcslen(pwszDescription) + 1 + wcslen(pwszError) + 1) *
	     sizeof(WCHAR));
	if (NULL == pwszText)
	{
	    _PrintError(E_OUTOFMEMORY, "LocalAlloc");
	}
	else
	{
	    wcscpy(pwszText, pwszDescription);
	    wcscat(pwszText, L" ");
	    wcscat(pwszText, pwszError);
	}
    }
    hr = ceDispatchSetErrorInfoSub(
			hrError,
			NULL,		// pwszIDispatchMethod
			NULL != pwszText?
			    pwszText : const_cast<WCHAR *>(pwszDescription),
			pwszProgId,
			piid,
			NULL,		// pwszHelpFile
			0);		// dwHelpFileContext
    _PrintIfError(hr, "ceDispatchSetErrorInfoSub");

error:
    if (NULL != pwszText)
    {
	LocalFree(pwszText);
    }
    if (NULL != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
    return(hrError);	// return input error!
}


int 
ceWtoI(
    IN WCHAR const *string,
    OUT BOOL *pfValid)
{
    HRESULT hr;
    WCHAR szBuf[16];
    WCHAR *szTmp = szBuf;
    int cTmp = ARRAYSIZE(szBuf);
    int i = 0;
    WCHAR const *pwsz;
    BOOL fSawDigit = FALSE;

    if (pfValid == NULL)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULLPARAM");
    }
    *pfValid = FALSE;
 
    assert(NULL != pfValid);
    cTmp = FoldString(
        MAP_FOLDDIGITS, 
        string,
        -1,
        szTmp,
        cTmp);
    if (cTmp == 0)
    {
        hr = ceHLastError();
        if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
        {
            hr = S_OK;
            cTmp = FoldString(
                MAP_FOLDDIGITS, 
                string,
                -1,
                NULL,
                0);

            szTmp = (WCHAR*)LocalAlloc(LMEM_FIXED, cTmp*sizeof(WCHAR));
	    if (NULL == szTmp)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }

            cTmp = FoldString(
                MAP_FOLDDIGITS, 
                string,
                -1,
                szTmp,
                cTmp);

            if (cTmp == 0)
                hr = ceHLastError();
        }
        _JumpIfError(hr, error, "FoldString");
    }    
    pwsz = szTmp;
    while (iswspace(*pwsz))
    {
	pwsz++;
    }
    while (iswdigit(*pwsz))
    {
	fSawDigit = TRUE;
	pwsz++;
    }
    while (iswspace(*pwsz))
    {
	pwsz++;
    }
    if (L'\0' == *pwsz)
    {
	*pfValid = fSawDigit;
    }
    i = _wtoi(szTmp);

error:
    if (szTmp && (szTmp != szBuf))
       LocalFree(szTmp);

    return i;
}


HRESULT
ceGetMachineDnsName(
    OUT WCHAR **ppwszDnsName)
{
    HRESULT hr;
    WCHAR *pwszDnsName = NULL;
    DWORD cwc;
    COMPUTER_NAME_FORMAT NameType = ComputerNameDnsFullyQualified;

    *ppwszDnsName = NULL;
    while (TRUE)
    {
	cwc = 0;
	if (!GetComputerNameEx(NameType, NULL, &cwc))
	{
	    hr = ceHLastError();
	    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr &&
		ComputerNameDnsFullyQualified == NameType)
	    {
		_PrintError(hr, "GetComputerNameEx(DnsFullyQualified) -- switching to NetBIOS");
		NameType = ComputerNameNetBIOS;
		continue;
	    }
	    if (HRESULT_FROM_WIN32(ERROR_MORE_DATA) != hr)
	    {
		_JumpError(hr, error, "GetComputerNameEx");
	    }
	    break;
	}
    }
    pwszDnsName = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszDnsName)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!GetComputerNameEx(NameType, pwszDnsName, &cwc))
    {
	hr = ceHLastError();
	_JumpError(hr, error, "GetComputerNameEx");
    }

    *ppwszDnsName = pwszDnsName;
    pwszDnsName = NULL;
    hr = S_OK;

error:
    if (NULL != pwszDnsName)
    {
	LocalFree(pwszDnsName);
    }
    return(hr);
}


HRESULT
ceGetComputerNames(
    OUT WCHAR **ppwszDnsName,
    OUT WCHAR **ppwszOldName)
{
    HRESULT hr;
    DWORD cwc;
    WCHAR *pwszOldName = NULL;

    *ppwszOldName = NULL;
    *ppwszDnsName = NULL;

    cwc = MAX_COMPUTERNAME_LENGTH + 1;
    pwszOldName = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszOldName)
    {
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
    }
    if (!GetComputerName(pwszOldName, &cwc))
    {
        hr = ceHLastError();
        _JumpError(hr, error, "GetComputerName");
    }

    hr = ceGetMachineDnsName(ppwszDnsName);
    _JumpIfError(hr, error, "ceGetMachineDnsName");

    *ppwszOldName = pwszOldName;
    pwszOldName = NULL;

error:
    if (NULL != pwszOldName)
    {
	LocalFree(pwszOldName);
    }
    return(hr);
}


HRESULT
_IsConfigLocal(
    IN WCHAR const *pwszConfig,
    IN WCHAR const *pwszDnsName,
    IN WCHAR const *pwszOldName,
    OPTIONAL OUT WCHAR **ppwszMachine,
    OUT BOOL *pfLocal)
{
    HRESULT hr;
    WCHAR *pwszMachine = NULL;
    WCHAR const *pwsz;
    DWORD cwc;

    *pfLocal = FALSE;
    if (NULL != ppwszMachine)
    {
	*ppwszMachine = NULL;
    }

    while (L'\\' == *pwszConfig)
    {
	pwszConfig++;
    }
    pwsz = wcschr(pwszConfig, L'\\');
    if (NULL != pwsz)
    {
	cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszConfig);
    }
    else
    {
	cwc = wcslen(pwszConfig);
    }
    pwszMachine = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszMachine)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pwszMachine, pwszConfig, cwc * sizeof(WCHAR));
    pwszMachine[cwc] = L'\0';

    if (0 == celstrcmpiL(pwszMachine, pwszDnsName) ||
	0 == celstrcmpiL(pwszMachine, pwszOldName))
    {
	*pfLocal = TRUE;
    }
    if (NULL != ppwszMachine)
    {
	*ppwszMachine = pwszMachine;
	pwszMachine = NULL;
    }
    hr = S_OK;

error:
    if (NULL != pwszMachine)
    {
	LocalFree(pwszMachine);
    }
    return(hr);
}


HRESULT
ceIsConfigLocal(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT WCHAR **ppwszMachine,
    OUT BOOL *pfLocal)
{
    HRESULT hr;
    WCHAR *pwszDnsName = NULL;
    WCHAR *pwszOldName = NULL;

    *pfLocal = FALSE;
    if (NULL != ppwszMachine)
    {
	*ppwszMachine = NULL;
    }

    hr = ceGetComputerNames(&pwszDnsName, &pwszOldName);
    _JumpIfError(hr, error, "ceGetComputerNames");

    hr = _IsConfigLocal(
		    pwszConfig,
		    pwszDnsName,
		    pwszOldName,
		    ppwszMachine,
		    pfLocal);
    _JumpIfError(hr, error, "_IsConfigLocal");

error:
    if (NULL != pwszDnsName)
    {
	LocalFree(pwszDnsName);
    }
    if (NULL != pwszOldName)
    {
	LocalFree(pwszOldName);
    }
    return(hr);
}


HRESULT
ceBuildPathAndExt(
    IN WCHAR const *pwszDir,
    IN WCHAR const *pwszFile,
    OPTIONAL IN WCHAR const *pwszExt,
    OUT WCHAR **ppwszPath)
{
    HRESULT hr;
    WCHAR *pwsz;
    DWORD cwc;

    *ppwszPath = NULL;
    cwc = wcslen(pwszDir) + 1 + wcslen(pwszFile) + 1;
    if (NULL != pwszExt)
    {
	cwc += wcslen(pwszExt);
    }

    pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwsz)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwsz, pwszDir);
    if (L'\\' != pwsz[wcslen(pwsz) - 1])
    {
	wcscat(pwsz, L"\\");
    }
    wcscat(pwsz, pwszFile);
    if (NULL != pwszExt)
    {
	wcscat(pwsz, pwszExt);
    }
    *ppwszPath = pwsz;
    hr = S_OK;

error:
    return(hr);
}


// Locale-independent case-ignore string compare

int
celstrcmpiL(
    IN WCHAR const *pwsz1,
    IN WCHAR const *pwsz2)
{
    // CSTR_LESS_THAN(1) - CSTR_EQUAL(2)    == -1 string 1 less than string 2
    // CSTR_EQUAL(2) - CSTR_EQUAL(2)        == 0 string 1 equal to string 2
    // CSTR_GREATER_THAN(3) - CSTR_EQUAL(2) == 1 string 1 greater than string 2

    return(CompareString(
		LOCALE_INVARIANT,
		NORM_IGNORECASE,
		pwsz1,
		-1,
		pwsz2,
		-1) -
	    CSTR_EQUAL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certadm\admin.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        admin.cpp
//
// Contents:    Cert Server admin implementation
//
// History:     24-Aug-96       vich created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <objbase.h>
#include "certsrvd.h"

#include "certbcli.h"
#include "csprop.h"
#include "csdisp.h"
#include "admin.h"
#include "certadmp.h"
#include "config.h"

#define __dwFILE__	__dwFILE_CERTADM_ADMIN_CPP__


//+--------------------------------------------------------------------------
// CCertAdmin::~CCertAdmin -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertAdmin::~CCertAdmin()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertAdmin::_CleanupOldConnection -- free memory
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertAdmin::_CleanupOldConnection()
{
    _CleanupCAPropInfo();
}


//+--------------------------------------------------------------------------
// CCertAdmin::_Cleanup -- free memory
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertAdmin::_Cleanup()
{
    _CloseConnection();
    _CleanupOldConnection();
}


//+--------------------------------------------------------------------------
// CCertAdmin::_OpenConnection -- get DCOM object interface
//
//+--------------------------------------------------------------------------

HRESULT
CCertAdmin::_OpenConnection(
    IN WCHAR const *pwszConfig,
    IN DWORD RequiredVersion,
    OUT WCHAR const **ppwszAuthority)
{
    HRESULT hr;

    hr = myOpenAdminDComConnection(
			pwszConfig,
			ppwszAuthority,
			&m_pwszServerName,
			&m_dwServerVersion,
			&m_pICertAdminD);
    _JumpIfError(hr, error, "myOpenAdminDComConnection");

    CSASSERT(NULL != m_pICertAdminD);
    CSASSERT(0 != m_dwServerVersion);

    if (m_dwServerVersion < RequiredVersion)
    {
	hr = RPC_E_VERSION_MISMATCH;
	_JumpError(hr, error, "old server");
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertAdmin::_CloseConnection -- release DCOM object
//
//+--------------------------------------------------------------------------

VOID
CCertAdmin::_CloseConnection()
{
    myCloseDComConnection((IUnknown **) &m_pICertAdminD, &m_pwszServerName);
    m_dwServerVersion = 0;
}


//+--------------------------------------------------------------------------
// CCertAdmin::IsValidCertificate -- Verify certificate validity
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::IsValidCertificate(
    /* [in] */ BSTR const strConfig,
    /* [in] */ BSTR const strSerialNumber,
    /* [out, retval] */ LONG *pDisposition)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;

    if (NULL == strSerialNumber || NULL == pDisposition)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = _OpenConnection(strConfig, 1, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    m_fRevocationReasonValid = FALSE;
    __try
    {
	hr = m_pICertAdminD->IsValidCertificate(
					    pwszAuthority,
					    strSerialNumber,
					    &m_RevocationReason,
					    pDisposition);

        if (S_OK != hr || CA_DISP_REVOKED != *pDisposition)
        {
            m_fRevocationReasonValid = FALSE;
        }
        else
        {
	    m_fRevocationReasonValid = TRUE;
        }
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "IsValidCertificate");

    m_fRevocationReasonValid = TRUE;

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::IsValidCertificate"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::GetRevocationReason -- Get Revocation Reason
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::GetRevocationReason(
    /* [out, retval] */ LONG *pReason)
{
    HRESULT hr = S_OK;

    if (NULL == pReason)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (!m_fRevocationReasonValid)
    {
	hr = E_UNEXPECTED;
	_JumpError(hr, error, "m_fRevocationReasonValid");
    }
    *pReason = m_RevocationReason;

error:
    return(_SetErrorInfo(hr, L"CCertAdmin::GetRevocationReason"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::RevokeCertificate -- Revoke a certificate
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::RevokeCertificate(
    /* [in] */ BSTR const strConfig,
    /* [in] */ BSTR const strSerialNumber,
    /* [in] */ LONG Reason,
    /* [in] */ DATE Date)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    FILETIME ft;

    if (NULL == strConfig || NULL == strSerialNumber)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = myDateToFileTime(&Date, &ft);
    _JumpIfError(hr, error, "myDateToFileTime");

    hr = _OpenConnection(strConfig, 1, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->RevokeCertificate(
					pwszAuthority,
					strSerialNumber,
					Reason,
					ft);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "RevokeCertificate");

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::RevokeCertificate"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::SetRequestAttributes -- Add request attributes
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::SetRequestAttributes(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG RequestId,
    /* [in] */ BSTR const strAttributes)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;

    if (NULL == strAttributes)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = _OpenConnection(strConfig, 1, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->SetAttributes(
				    pwszAuthority,
				    (DWORD) RequestId,
				    strAttributes);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "SetAttributes");

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::SetRequestAttributes"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::SetCertificateExtension -- Set a Certificate Extension
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::SetCertificateExtension(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG RequestId,
    /* [in] */ BSTR const strExtensionName,
    /* [in] */ LONG Type,
    /* [in] */ LONG Flags,
    /* [in] */ VARIANT const *pvarValue)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbValue;

    ctbValue.pb = NULL;

    if (NULL == strExtensionName || NULL == pvarValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = _OpenConnection(strConfig, 1, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    hr = myMarshalVariant(pvarValue, Type, &ctbValue.cb, &ctbValue.pb);
    _JumpIfError(hr, error, "myMarshalVariant");

    __try
    {
	hr = m_pICertAdminD->SetExtension(
				    pwszAuthority,
				    (DWORD) RequestId,
				    strExtensionName,
				    Type,
				    Flags,
				    &ctbValue);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "SetExtension");

error:
    if (NULL != ctbValue.pb)
    {
        LocalFree(ctbValue.pb);
    }
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::SetCertificateExtension"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::ResubmitRequest -- Resubmit a certificate request
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::ResubmitRequest(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG RequestId,
    /* [out, retval] */ LONG *pDisposition)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;

    if (NULL == pDisposition)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *pDisposition = 0;

    hr = _OpenConnection(strConfig, 1, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->ResubmitRequest(
					pwszAuthority,
					(DWORD) RequestId,
					(DWORD *) pDisposition);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "ResubmitRequest");

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::ResubmitRequest"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::DenyRequest -- Deny a certificate request
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::DenyRequest(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG RequestId)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;

    hr = _OpenConnection(strConfig, 1, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->DenyRequest(pwszAuthority, (DWORD) RequestId);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "DenyRequest");

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::DenyRequest"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::PublishCRL -- Puhlish a new CRL
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::PublishCRL(
    /* [in] */ BSTR const strConfig,
    /* [in] */ DATE Date)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    FILETIME ft;

    // Date = 0.0 means pass ft = 0 to the DCOM interface

    if (Date == 0.0)
    {
        ZeroMemory(&ft, sizeof(FILETIME));
    }
    else  // translate date to ft
    {
        hr = myDateToFileTime(&Date, &ft);
        _JumpIfError(hr, error, "myDateToFileTime");
    }

    hr = _OpenConnection(strConfig, 1, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->PublishCRL(pwszAuthority, ft);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "PublishCRL");

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::PublishCRL"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::PublishCRLs -- Publish new base CRL, delta CRL or both
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertAdmin::PublishCRLs(
    /* [in] */ BSTR const strConfig,
    /* [in] */ DATE Date,
    /* [in] */ LONG CRLFlags)		// CA_CRL_*
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    FILETIME ft;

    // Date = 0.0 means pass ft = 0 to the DCOM interface

    if (Date == 0.0)
    {
        ZeroMemory(&ft, sizeof(FILETIME));
    }
    else  // translate date to ft
    {
        hr = myDateToFileTime(&Date, &ft);
        _JumpIfError(hr, error, "myDateToFileTime");
    }

    hr = _OpenConnection(strConfig, 2, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->PublishCRLs(pwszAuthority, ft, CRLFlags);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "PublishCRLs");

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::PublishCRLs"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::GetCRL -- Get the latest CRL
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::GetCRL(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG Flags,
    /* [out, retval] */ BSTR *pstrCRL)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbCRL;

    ctbCRL.pb = NULL;

    if (NULL == pstrCRL)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = _OpenConnection(strConfig, 1, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    ctbCRL.cb = 0;
    __try
    {
	hr = m_pICertAdminD->GetCRL(pwszAuthority, &ctbCRL);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "GetCRL");

    myRegisterMemAlloc(ctbCRL.pb, ctbCRL.cb, CSM_COTASKALLOC);

    CSASSERT(CR_OUT_BASE64HEADER == CRYPT_STRING_BASE64HEADER);

    if (CR_OUT_BASE64HEADER == Flags)
    {
	Flags = CRYPT_STRING_BASE64X509CRLHEADER;
    }
    hr = EncodeCertString(ctbCRL.pb, ctbCRL.cb, Flags, pstrCRL);
    _JumpIfError(hr, error, "EncodeCertString");

error:
    if (NULL != ctbCRL.pb)
    {
    	CoTaskMemFree(ctbCRL.pb);
    }
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::GetCRL"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::ImportCertificate -- Import a certificate into the database
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::ImportCertificate(
    /* [in] */ BSTR const strConfig,
    /* [in] */ BSTR const strCertificate,
    /* [in] */ LONG Flags,
    /* [out, retval] */ LONG *pRequestId)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbCert;

    ctbCert.pb = NULL;
    if (NULL == strCertificate)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = DecodeCertString(
		    strCertificate,
		    Flags & CR_IN_ENCODEMASK,
		    &ctbCert.pb,
		    &ctbCert.cb);
    _JumpIfError(hr, error, "DecodeCertString");

    hr = _OpenConnection(strConfig, 1, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->ImportCertificate(
					pwszAuthority,
					&ctbCert,
					Flags,
					pRequestId);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError3(
	    hr,
	    error,
	    "ImportCertificate",
	    NTE_BAD_SIGNATURE,
	    HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS));

error:
    if (NULL != ctbCert.pb)
    {
    	LocalFree(ctbCert.pb);
    }
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::ImportCertificate"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::GetArchivedKey --  Get archived, encrypted key in a PKCS7
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::GetArchivedKey(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG RequestId,
    /* [in] */ LONG Flags,
    /* [out, retval] */ BSTR *pstrArchivedKey)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbArchivedKey;

    ctbArchivedKey.pb = NULL;

    if (NULL == pstrArchivedKey)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = _OpenConnection(strConfig, 2, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    ctbArchivedKey.cb = 0;
    __try
    {
	hr = m_pICertAdminD->GetArchivedKey(
					pwszAuthority,
					RequestId,
					&ctbArchivedKey);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "GetArchivedKey");

    myRegisterMemAlloc(
		ctbArchivedKey.pb,
		ctbArchivedKey.cb,
		CSM_COTASKALLOC);

    CSASSERT(CR_OUT_BASE64HEADER == CRYPT_STRING_BASE64HEADER);

    hr = EncodeCertString(
		    ctbArchivedKey.pb,
		    ctbArchivedKey.cb,
		    Flags,
		    pstrArchivedKey);
    _JumpIfError(hr, error, "EncodeCertString");

error:
    if (NULL != ctbArchivedKey.pb)
    {
    	CoTaskMemFree(ctbArchivedKey.pb);
    }
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::GetArchivedKey"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::GetConfigEntry --  get CA configuration entry
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::GetConfigEntry(
    /* [in] */ BSTR const strConfig,
    /* [in] */ BSTR const strNodePath,
    /* [in] */ BSTR const strEntryName,
    /* [out, retval] */ VARIANT *pvarEntry)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;

    if (NULL == strEntryName || NULL == pvarEntry)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = _OpenConnection(strConfig, 2, &pwszAuthority);

    __try
    {
        if(S_OK != hr)
        {
            hr = _GetConfigEntryFromRegistry(
                strConfig,
                strNodePath,
                strEntryName,
                pvarEntry);
            _LeaveIfError(hr, "_GetConfigEntryFromRegistry");
        }
        else
        {
	    hr = m_pICertAdminD->GetConfigEntry(
				            pwszAuthority,
				            strNodePath,
				            strEntryName,
				            pvarEntry);
            _LeaveIfError(hr, "GetConfigEntry");

	    myRegisterMemAlloc(pvarEntry, 0, CSM_VARIANT);
        }
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    _JumpIfError2(hr, error, "GetConfigEntry", 
        HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::GetConfigEntry"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::SetConfigEntry --  set CA configuration entry
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::SetConfigEntry(
    /* [in] */ BSTR const strConfig,
    /* [in] */ BSTR const strNodePath,
    /* [in] */ BSTR const strEntryName,
    /* [in] */ VARIANT *pvarEntry)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;

    if (NULL == strEntryName || NULL == pvarEntry)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = _OpenConnection(strConfig, 2, &pwszAuthority);

    __try
    {
        if(S_OK != hr)
        {
            hr = _SetConfigEntryFromRegistry(
                strConfig,
                strNodePath,
                strEntryName,
                pvarEntry);
        }
        else
        {
	        hr = m_pICertAdminD->SetConfigEntry(
				            pwszAuthority,
				            strNodePath,
				            strEntryName,
				            pvarEntry);
        }
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    _JumpIfError(hr, error, "SetConfigEntry");

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::SetConfigEntry"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::ImportKey --  Archive Private Key
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::ImportKey(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG RequestId,
    /* [in] */ BSTR const strCertHash,
    /* [in] */ LONG Flags,
    /* [in] */ BSTR const strKey)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbKey;

    ctbKey.pb = NULL;
    if (NULL == strKey)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = DecodeCertString(
		    strKey,
		    Flags & CR_IN_ENCODEMASK,
		    &ctbKey.pb,
		    &ctbKey.cb);
    _JumpIfError(hr, error, "DecodeCertString");

    hr = _OpenConnection(strConfig, 2, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->ImportKey(
				    pwszAuthority,
				    RequestId,
				    strCertHash,
				    Flags,
				    &ctbKey);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError2(
	    hr,
	    error,
	    "ImportKey",
	    HRESULT_FROM_WIN32(ERROR_OBJECT_ALREADY_EXISTS));

error:
    if (NULL != ctbKey.pb)
    {
    	LocalFree(ctbKey.pb);
    }
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::ImportKey"));
}


HRESULT
CCertAdmin::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTADMIN,
			    &IID_ICertAdmin);
	CSASSERT(hr == hrError);
    }
    return(hrError);
}

//+--------------------------------------------------------------------------
// CCertAdmin::GetMyRoles -- Gets current user roles
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::GetMyRoles(
    /* [in] */ BSTR const strConfig,
    /* [out, retval] */ LONG *pRoles)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;

    if (NULL == strConfig || NULL == pRoles)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    hr = _OpenConnection(strConfig, 2, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
    hr = m_pICertAdminD->GetMyRoles(
                        pwszAuthority,
                        pRoles);
    } 
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "GetMyRoles");

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::GetMyRoles"));
}


//+--------------------------------------------------------------------------
// CCertAdmin::DeleteRow -- Delete row from database
//
// ...
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertAdmin::DeleteRow(
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG Flags,		// CDR_*
    /* [in] */ DATE Date,
    /* [in] */ LONG Table,		// CVRC_TABLE_*
    /* [in] */ LONG RowId,
    /* [out, retval]*/ LONG *pcDeleted)
{
    HRESULT hr;
    FILETIME ft;
    WCHAR const *pwszAuthority;

    if (NULL == strConfig)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }

    // Date = 0.0 means pass ft = 0 to the DCOM interface

    if (Date == 0.0)
    {
        ZeroMemory(&ft, sizeof(FILETIME));
    }
    else  // translate date to ft
    {
        hr = myDateToFileTime(&Date, &ft);
        _JumpIfError(hr, error, "myDateToFileTime");
    }

    hr = _OpenConnection(strConfig, 2, &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    __try
    {
	hr = m_pICertAdminD->DeleteRow(
				pwszAuthority,
				Flags,
				ft,
				Table,
				RowId,
				pcDeleted);
    } 
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "DeleteRow");

error:
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertAdmin::DeleteRow"));
}


HRESULT 
CCertAdmin::_GetConfigEntryFromRegistry(
    IN BSTR const strConfig,
    IN BSTR const strNodePath,
    IN BSTR const strEntryName,
    IN OUT VARIANT *pvarEntry)
{
    HRESULT hr;
    CertSrv::CConfigStorage stg;
    LPWSTR pwszMachine = NULL;
    LPWSTR pwszCAName = NULL;

    hr = mySplitConfigString(
        strConfig,
        &pwszMachine, 
        &pwszCAName);
    _JumpIfErrorStr(hr, error, "mySplitConfigString", strConfig);

    hr = stg.InitMachine(pwszMachine);
    _JumpIfError(hr, error, "CConfigStorage::InitMachine");

    hr = stg.GetEntry(
        pwszCAName,
        strNodePath,
        strEntryName,
        pvarEntry);
    _JumpIfError(hr, error, "CConfigStorage::GetEntry");

error:
    LOCAL_FREE(pwszMachine);
    LOCAL_FREE(pwszCAName);
    return hr;
}

HRESULT 
CCertAdmin::_SetConfigEntryFromRegistry(
    IN BSTR const strConfig,
    IN BSTR const strNodePath,
    IN BSTR const strEntryName,
    IN const VARIANT *pvarEntry)
{
    HRESULT hr;
    CertSrv::CConfigStorage stg;
    LPWSTR pwszMachine = NULL;
    LPWSTR pwszCAName = NULL;

    hr = mySplitConfigString(
        strConfig,
        &pwszMachine, 
        &pwszCAName);
    _JumpIfErrorStr(hr, error, "mySplitConfigString", strConfig);

    hr = stg.InitMachine(pwszMachine);
    _JumpIfError(hr, error, "CConfigStorage::InitMachine");

    hr = stg.SetEntry(
        pwszCAName,
        strNodePath,
        strEntryName,
        const_cast<VARIANT*>(pvarEntry));
    _JumpIfError(hr, error, "CConfigStorage::GetEntry");

error:
    LOCAL_FREE(pwszMachine);
    LOCAL_FREE(pwszCAName);
    return hr;
}


#undef __DIR__
#undef __dwFILE__
#define CCERTADMIN
#include "csprop2.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certadm\atl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       atl.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp: source file that includes just the standard includes
// stdafx.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certadm\admin.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        admin.h
//
// Contents:    Declaration of CCertAdmin
//
//---------------------------------------------------------------------------


#include "cscomres.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certadm


class ATL_NO_VTABLE CCertAdmin: 
    public IDispatchImpl<ICertAdmin2, &IID_ICertAdmin2, &LIBID_CERTADMINLib>, 
    public ISupportErrorInfoImpl<&IID_ICertAdmin2>,
    public CComObjectRoot,
    public CComCoClass<CCertAdmin, &CLSID_CCertAdmin>
{
public:
    CCertAdmin()
    {
	m_fRevocationReasonValid = FALSE;
	m_dwServerVersion = 0;
	m_pICertAdminD = NULL;
	m_pwszServerName = NULL;
	_InitCAPropInfo();
	_Cleanup();
    }
    ~CCertAdmin();

BEGIN_COM_MAP(CCertAdmin)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertAdmin)
    COM_INTERFACE_ENTRY(ICertAdmin2)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertAdmin) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertAdmin,
    wszCLASS_CERTADMIN TEXT(".1"),
    wszCLASS_CERTADMIN,
    IDS_CERTADMIN_DESC,
    THREADFLAGS_BOTH)

// ICertAdmin
public:
    STDMETHOD(IsValidCertificate)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ BSTR const strSerialNumber,
		/* [out, retval] */ LONG *pDisposition);

    STDMETHOD(GetRevocationReason)(
		/* [out, retval] */ LONG *pReason);

    STDMETHOD(RevokeCertificate)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ BSTR const strSerialNumber,
		/* [in] */ LONG Reason,
		/* [in] */ DATE Date);

    STDMETHOD(SetRequestAttributes)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG RequestId,
		/* [in] */ BSTR const strAttributes);

    STDMETHOD(SetCertificateExtension)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG RequestId,
		/* [in] */ BSTR const strExtensionName,
		/* [in] */ LONG Type,
		/* [in] */ LONG Flags,
		/* [in] */ VARIANT const *pvarValue);

    STDMETHOD(DenyRequest)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG RequestId);

    STDMETHOD(ResubmitRequest)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG RequestId,
		/* [out, retval] */ LONG __RPC_FAR *pDisposition);

    STDMETHOD(PublishCRL)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ DATE Date);

    STDMETHOD(GetCRL)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG Flags,
		/* [out, retval] */ BSTR *pstrCRL);

    STDMETHOD(ImportCertificate)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ BSTR const strCertificate,
		/* [in] */ LONG Flags,
		/* [out, retval] */ LONG *pRequestId);

// ICertAdmin2
public:
    STDMETHOD(PublishCRLs)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ DATE Date,
		/* [in] */ LONG CRLFlags);		// CA_CRL_*

    STDMETHOD(GetCAProperty)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG PropId,			// CR_PROP_*
		/* [in] */ LONG PropIndex,
		/* [in] */ LONG PropType,		// PROPTYPE_*
		/* [in] */ LONG Flags,			// CR_OUT_*
		/* [out, retval] */ VARIANT *pvarPropertyValue);

    STDMETHOD(SetCAProperty)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG PropId,			// CR_PROP_*
		/* [in] */ LONG PropIndex,
		/* [in] */ LONG PropType,		// PROPTYPE_*
		/* [in] */ VARIANT *pvarPropertyValue);

    STDMETHOD(GetCAPropertyFlags)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG PropId,			// CR_PROP_*
		/* [out, retval] */ LONG *pPropFlags);

    STDMETHOD(GetCAPropertyDisplayName)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG PropId,			// CR_PROP_*
		/* [out, retval] */ BSTR *pstrDisplayName);

    STDMETHOD(GetArchivedKey)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG RequestId,
		/* [in] */ LONG Flags,			// CR_OUT_*
		/* [out, retval] */ BSTR *pstrArchivedKey);

    STDMETHOD(GetConfigEntry)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ BSTR const strNodePath,
		/* [in] */ BSTR const strEntryName,
		/* [out, retval] */ VARIANT *pvarEntry);

    STDMETHOD(SetConfigEntry)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ BSTR const strNodePath,
		/* [in] */ BSTR const strEntryName,
		/* [in] */ VARIANT *pvarEntry);

    STDMETHOD(ImportKey)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG RequestId,
		/* [in] */ BSTR const strCertHash,
		/* [in] */ LONG Flags,
		/* [in] */ BSTR const strKey);

    STDMETHOD(GetMyRoles)(
		/* [in] */ BSTR const strConfig,
		/* [out, retval] */ LONG *pRoles);

    STDMETHOD(DeleteRow)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG Flags,		// CDR_*
		/* [in] */ DATE Date,
		/* [in] */ LONG Table,		// CVRC_TABLE_*
		/* [in] */ LONG RowId,
		/* [out, retval] */ LONG *pcDeleted);

private:
    HRESULT _OpenConnection(
		IN WCHAR const *pwszConfig,
		IN DWORD RequiredVersion,
		OUT WCHAR const **ppwszAuthority);

    VOID _CloseConnection();

    VOID _InitCAPropInfo();
    VOID _CleanupCAPropInfo();

    VOID _Cleanup();
    VOID _CleanupOldConnection();

    HRESULT _FindCAPropInfo(
		IN BSTR const strConfig,
		IN LONG PropId,
		OUT CAPROP const **ppcap);

    HRESULT _SetErrorInfo(
		IN HRESULT hrError,
		IN WCHAR const *pwszDescription);

    HRESULT _GetConfigEntryFromRegistry(
		IN BSTR const strConfig,
		IN BSTR const strNodePath,
		IN BSTR const strEntryName,
		IN OUT VARIANT *pvarEntry);

    HRESULT _SetConfigEntryFromRegistry(
		IN BSTR const strConfig,
		IN BSTR const strNodePath,
		IN BSTR const strEntryName,
		IN const VARIANT *pvarEntry);

    DWORD         m_dwServerVersion;
    ICertAdminD2 *m_pICertAdminD;

    LONG    m_RevocationReason;
    BOOL    m_fRevocationReasonValid;

    BYTE   *m_pbCACertState;
    DWORD   m_cbCACertState;

    BYTE   *m_pbCACertVersion;
    DWORD   m_cbCACertVersion;

    BYTE   *m_pbCRLState;
    DWORD   m_cbCRLState;

    CAPROP *m_pCAPropInfo;
    LONG    m_cCAPropInfo;
    CAINFO *m_pCAInfo;
    DWORD   m_cbCAInfo;

    WCHAR  *m_pwszServerName;

    BYTE   *m_pbKRACertState;
    DWORD   m_cbKRACertState;

    BYTE   *m_pbForwardCrossCertState;
    DWORD   m_cbForwardCrossCertState;

    BYTE   *m_pbBackwardCrossCertState;
    DWORD   m_cbBackwardCrossCertState;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certadm\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 1998

Module Name:

    makefile.inc.

!ENDIF

$(O)\$(TARGETNAME).res:    ..\idl\com\$(O)\$(TARGETNAME).tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certadm\backup.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        backup.cpp
//
// Contents:    Cert Server client database backup APIs
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "certsrvd.h"
#include "csdisp.h"
#include "certadmp.h"

#define __dwFILE__	__dwFILE_CERTADM_BACKUP_CPP__


#if DBG
#define _CERTBCLI_TYPECHECK
#endif

#include <certbcli.h>


WCHAR g_wszBackupAnnotation[] = L"backup";
WCHAR g_wszRestoreAnnotation[] = L"restore";


HRESULT
AllocateContext(
    IN WCHAR const *pwszConfig,
    OUT CSBACKUPCONTEXT **ppcsbc)
{
    HRESULT hr;
    WCHAR *pwszT = NULL;

    CSASSERT(NULL != pfnCertSrvIsServerOnline);
    pwszT = (WCHAR *) LocalAlloc(
			    LMEM_FIXED,
			    (wcslen(pwszConfig) + 1) * sizeof(WCHAR));
    if (NULL == pwszT)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    wcscpy(pwszT, pwszConfig);
    
    *ppcsbc = (CSBACKUPCONTEXT *) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					sizeof(**ppcsbc));
    if (NULL == *ppcsbc)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    (*ppcsbc)->pwszConfig = pwszT;
    pwszT = NULL;
    hr = S_OK;

error:
    if (NULL != pwszT)
    {
	LocalFree(pwszT);
    }
    return(hr);
}


VOID
ReleaseContext(
    IN OUT CSBACKUPCONTEXT *pcsbc)
{
    CSASSERT(NULL != pcsbc);
    if (NULL != pcsbc->pwszConfig)
    {
	LocalFree(const_cast<WCHAR *>(pcsbc->pwszConfig));
	pcsbc->pwszConfig = NULL;
    }
    if (NULL != pcsbc->pICertAdminD)
    {
	CloseAdminServer(&pcsbc->pICertAdminD);
	CSASSERT(NULL == pcsbc->pICertAdminD);
    }
    if (NULL != pcsbc->pbReadBuffer)
    {
	VirtualFree(pcsbc->pbReadBuffer, 0, MEM_RELEASE);
    }
    LocalFree(pcsbc);
}


HRESULT
OpenAdminServer(
    IN WCHAR const *pwszConfig,
    OUT WCHAR const **ppwszAuthority,
    OUT DWORD *pdwServerVersion,
    OUT ICertAdminD2 **ppICertAdminD)
{
    HRESULT hr;
    BOOL fCoInitialized = FALSE;

    hr = CoInitialize(NULL);
    if (RPC_E_CHANGED_MODE == hr)
    {
	_PrintError(hr, "CoInitialize");
	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    }
    if (S_OK != hr && S_FALSE != hr)
    {
	_JumpError(hr, error, "CoInitialize");
    }
    fCoInitialized = TRUE;

    *pdwServerVersion = 0;
    hr = myOpenAdminDComConnection(
			pwszConfig,
			ppwszAuthority,
			NULL,
			pdwServerVersion,
			ppICertAdminD);
    _JumpIfError(hr, error, "myOpenDComConnection");

    CSASSERT(0 != *pdwServerVersion);

error:
    if (S_OK != hr && fCoInitialized)
    {
	CoUninitialize();
    }
    return(hr);
}


VOID
CloseAdminServer(
    IN OUT ICertAdminD2 **ppICertAdminD)
{
    myCloseDComConnection((IUnknown **) ppICertAdminD, NULL);
    CoUninitialize();
}


//+--------------------------------------------------------------------------
// CertSrvIsServerOnline -- check to see if the Cert Server is Online on the
//	given server. This call is guaranteed to return quickly.
//
// Parameters:
//	[in]  pwszConfig - name of the server to check
//	[out] pfServerOnline - pointer to receive the bool result
//		(TRUE if Cert Server is online; FALSE, otherwise)
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//+--------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvIsServerOnlineW(
    IN WCHAR const *pwszConfig,
    OPTIONAL OUT BOOL *pfServerOnline)
{
    HRESULT hr;
    ICertAdminD2 *pICertAdminD = NULL;
    WCHAR const *pwszAuthority;
    DWORD State;
    DWORD dwServerVersion;

    if (NULL == pwszConfig)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = S_OK;
    __try
    {
	if (NULL != pfServerOnline)
	{
	    *pfServerOnline = FALSE;
	}
	hr = OpenAdminServer(
		    pwszConfig,
		    &pwszAuthority,
		    &dwServerVersion,
		    &pICertAdminD);

	// OpenAdminServer etc might get E_ACCESSDENIED -- meaning server down

	if (S_OK != hr)
	{
	    _PrintError(hr, "OpenAdminServer");
	    if (E_ACCESSDENIED == hr || (HRESULT) ERROR_ACCESS_DENIED == hr)
	    {
		hr = S_OK;
	    }
	    __leave;
	}
	hr = pICertAdminD->GetServerState(pwszAuthority, &State);
	_LeaveIfError(hr, "GetServerState");

	if (NULL != pfServerOnline && 0 != State)
	{
	    *pfServerOnline = TRUE;
	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != pICertAdminD)
    {
	CloseAdminServer(&pICertAdminD);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupPrepare -- prepare the DS for the online backup and return a
//	Backup Context Handle to be used for subsequent calls to backup
//	functions.
//
// Parameters:
//	[in]  pwszConfig - server name to prepare for online backup
//	[in]  grbitJet - flag to be passed to jet while backing up dbs
//	[in]  dwBackupFlags - CSBACKUP_TYPE_FULL or CSBACKUP_TYPE_LOGS_ONLY
//	[out] phbc - pointer that will receive the backup context handle
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvBackupPrepareW(
    IN  WCHAR const *pwszConfig,
    IN  ULONG grbitJet,
    IN  ULONG dwBackupFlags,
    OUT HCSBC *phbc)
{
    HRESULT hr;
    CSBACKUPCONTEXT *pcsbc = NULL;

    if (NULL == pwszConfig || NULL == phbc)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *phbc = NULL;
    if (CSBACKUP_TYPE_LOGS_ONLY == dwBackupFlags)
    {
	grbitJet |= JET_bitBackupIncremental;
    }
    else if (CSBACKUP_TYPE_FULL != dwBackupFlags)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "dwBackupFlags");
    }

    hr = S_OK;
    __try
    {
	hr = AllocateContext(pwszConfig, &pcsbc);
	_LeaveIfError(hr, "AllocateContext");

	hr = OpenAdminServer(
		    pcsbc->pwszConfig,
		    &pcsbc->pwszAuthority,
		    &pcsbc->dwServerVersion,
		    &pcsbc->pICertAdminD);
	_LeaveIfError(hr, "OpenAdminServer");

	hr = pcsbc->pICertAdminD->BackupPrepare(	
				    pcsbc->pwszAuthority,
				    grbitJet,
				    dwBackupFlags,
				    g_wszBackupAnnotation,
				    0);		// dwClientIdentifier
	_LeaveIfError(hr, "BackupPrepare");

	*phbc = (HCSBC) pcsbc;
	pcsbc = NULL;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != pcsbc)
    {
	ReleaseContext(pcsbc);
    }
    return(hr);
}


// Return the length of a double '\0' terminated string -- includes the
// trailing '\0's.


DWORD
mySzzLen(
    CHAR const *pszz)
{
    CHAR const *psz;
    DWORD cb;

    psz = pszz;
    do
    {
	cb = strlen(psz);
	psz += cb + 1;
    } while (0 != cb);
    return SAFE_SUBTRACT_POINTERS(psz, pszz); // includes double trailing '\0's
}


HRESULT
myLocalAllocCopy(
    IN VOID *pbIn,
    IN DWORD cbIn,
    OUT VOID **pbOut)
{
    HRESULT hr;
    
    *pbOut = LocalAlloc(LMEM_FIXED, cbIn);
    if (NULL == *pbOut)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(*pbOut, pbIn, cbIn);
    hr = S_OK;

error:
    return(hr);
}


HRESULT
BackupRestoreGetFileList(
    IN  DWORD FileListType,
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzFileList,
    OUT DWORD *pcbList)
{
    HRESULT hr;
    CSBACKUPCONTEXT *pcsbc;
    WCHAR *pwszzFileList = NULL;
    LONG cwcList;
    DWORD cbList;

    if (NULL == hbc)
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "NULL handle");
    }
    if (NULL != ppwszzFileList)
    {
	*ppwszzFileList = NULL;
    }
    if (NULL != pcbList)
    {
	*pcbList = 0;
    }
    if (NULL == ppwszzFileList || NULL == pcbList)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    pcsbc = (CSBACKUPCONTEXT *) hbc;

    hr = S_OK;
    __try
    {
	if (NULL == pcsbc->pICertAdminD)
	{
	    hr = OpenAdminServer(
			pcsbc->pwszConfig,
			&pcsbc->pwszAuthority,
			&pcsbc->dwServerVersion,
			&pcsbc->pICertAdminD);
	    _LeaveIfError(hr, "OpenAdminServer");
	}
	CSASSERT(NULL != pcsbc->pICertAdminD);

	if (FLT_DBFILES == FileListType)
	{
	    hr = pcsbc->pICertAdminD->BackupGetAttachmentInformation(
							&pwszzFileList,
							&cwcList);
	    _LeaveIfError(hr, "BackupGetAttachmentInformation");
	}
	else if (FLT_LOGFILES == FileListType)
	{
	    hr = pcsbc->pICertAdminD->BackupGetBackupLogs(
						&pwszzFileList,
						&cwcList);
	    _LeaveIfError(hr, "BackupGetBackupLogs");
	}
	else if (FLT_DYNAMICFILES == FileListType)
	{
	    hr = pcsbc->pICertAdminD->BackupGetDynamicFiles(
						&pwszzFileList,
						&cwcList);
	    _LeaveIfError(hr, "BackupGetDynamicFileList");
	}
	else
	{
	    CSASSERT(FLT_RESTOREDBLOCATIONS == FileListType);
	    hr = pcsbc->pICertAdminD->RestoreGetDatabaseLocations(
						    &pwszzFileList,
						    &cwcList);
	    _LeaveIfError(hr, "RestoreGetDatabaseLocations");
	}

	cbList = cwcList * sizeof(WCHAR);
	myRegisterMemAlloc(pwszzFileList, cbList, CSM_COTASKALLOC);

	hr = myLocalAllocCopy(pwszzFileList, cbList, (VOID **) ppwszzFileList);
	_JumpIfError(hr, error, "myLocalAllocCopy");

	*pcbList = cbList;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != pwszzFileList)
    {
	CoTaskMemFree(pwszzFileList);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupGetDatabaseNames -- return the list of data bases that need to
//	be backed up for the given backup context The information returned in
//	ppwszzFileList should not be interpreted, as it only has meaning on
//	the server being backed up.
//
//	This API will allocate a buffer of sufficient size to hold the entire
//	attachment list, which must be later freed with CertSrvBackupFree.
//
// Parameters:
//	[in]  hbc - backup context handle
//	[out] ppwszzFileList - pointer that will receive the pointer to the
//		attachment info; allocated memory should be freed using
//		CertSrvBackupFree() API by the caller when it is no longer
//		needed; ppwszzFileList info is an array of null-terminated
//		filenames and the list is terminated by two L'\0's.
//	[out] pcbList - will receive the number of bytes returned
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvBackupGetDatabaseNamesW(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzFileList,
    OUT DWORD *pcbList)
{
    HRESULT hr;

    hr = BackupRestoreGetFileList(FLT_DBFILES, hbc, ppwszzFileList, pcbList);
    _JumpIfError(hr, error, "BackupRestoreGetFileList");

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupGetDynamicFileList -- return the list of dynamic files that
//	need to be backed up for the given backup context The information
//	returned in ppwszzFileList should not be interpreted, as it only has
//	meaning on the server being backed up.
//
//	This API will allocate a buffer of sufficient size to hold the entire
//	attachment list, which must be later freed with CertSrvBackupFree.
//
// Parameters:
//	[in]  hbc - backup context handle
//	[out] ppwszzFileList - pointer that will receive the pointer to the
//		attachment info; allocated memory should be freed using
//		CertSrvBackupFree() API by the caller when it is no longer
//		needed; ppwszzFileList info is an array of null-terminated
//		filenames and the list is terminated by two L'\0's.
//	[out] pcbList - will receive the number of bytes returned
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvBackupGetDynamicFileListW(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzFileList,
    OUT DWORD *pcbList)
{
    HRESULT hr;

    hr = BackupRestoreGetFileList(
				FLT_DYNAMICFILES,
				hbc,
				ppwszzFileList,
				pcbList);
    _JumpIfError(hr, error, "BackupRestoreGetFileList");

error:
    return(hr);
}


#define CBREADMIN	(64 * 1024)		// 64k minimum buffer
#define CBREADDEFAULT	(512 * 1024)		// 512k recommended
#define CBREADMAX	(4 * 1024 * 1024)	// 4mb maximum buffer

HRESULT
BufferAllocate(
    IN  DWORD cbHintSize,
    OUT BYTE **ppbBuffer,
    OUT DWORD *pcbBuffer)
{
    HRESULT hr;
    DWORD cb;

    *ppbBuffer = NULL;
    if (0 == cbHintSize)
    {
	// at 512k the server begins doing efficient backups

	cbHintSize = CBREADDEFAULT;
    }
    else if (CBREADMIN > cbHintSize)
    {
	cbHintSize = CBREADMIN;
    }

    for (cb = CBREADMAX; (cb >> 1) >= cbHintSize; cb >>= 1)
    	;

    while (TRUE)
    {
        *ppbBuffer = (BYTE *) VirtualAlloc(
					NULL,
					cb,
					MEM_COMMIT,
					PAGE_READWRITE);
        if (NULL != *ppbBuffer)
        {
	    break;
	}
	hr = myHLastError();
	CSASSERT(S_OK == hr);
	_PrintError(hr, "VirtualAlloc");

	cb >>= 1;
	if (CBREADMIN > cb)
	{
	    goto error;
	}
    }
    *pcbBuffer = cb;
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupOpenFile -- open a remote file for backup, and perform whatever
//	client and server side operations to prepare for the backup.
//	It takes in a hint of the size of the buffer that will later be passed
//	into the CertSrvBackupRead API that can be used to optimize the network
//	traffic for the API.
//
// Parameters:
//	[in]  hbc - backup context handle
//	[in]  pwszPath - name of the attachment to be opened for read
//	[in]  cbReadHintSize - suggested size in bytes that might be used
//		during the subsequent reads on this attachment
//	[out] pliFileSize - pointer to a large integer that would receive the
//		size in bytes of the given attachment
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvBackupOpenFileW(
    IN  HCSBC hbc,
    IN  WCHAR const *pwszPath,
    IN  DWORD cbReadHintSize,
    OUT LARGE_INTEGER *pliFileSize)
{
    HRESULT hr;
    CSBACKUPCONTEXT *pcsbc;

    if (NULL == hbc)
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "NULL handle");
    }
    if (NULL == pwszPath || NULL == pliFileSize)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    pcsbc = (CSBACKUPCONTEXT *) hbc;
    if (pcsbc->fFileOpen)
    {
	hr = HRESULT_FROM_WIN32(ERROR_BUSY);
	_JumpError(hr, error, "File already open");
    }

    hr = S_OK;
    __try
    {
	hr = pcsbc->pICertAdminD->BackupOpenFile(
					    pwszPath,
					    (ULONGLONG *) pliFileSize);
	_LeaveIfErrorStr(hr, "BackupOpenFile", pwszPath);

	if (NULL == pcsbc->pbReadBuffer)
	{
	    hr = BufferAllocate(
			    cbReadHintSize,
			    &pcsbc->pbReadBuffer,
			    &pcsbc->cbReadBuffer);
	    _LeaveIfError(hr, "BufferAllocate");
	}
	pcsbc->fFileOpen = TRUE;
	pcsbc->cbCache = 0;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupRead -- read the currently open attachment bytes into the given
//	buffer.  The client application is expected to call this function
//	repeatedly until it gets the entire file (the application would have
//	received the file size through the CertSrvBackupOpenFile call before.
//
// Parameters:
//	[in]  hbc - backup context handle
//	[in]  pvBuffer - pointer to the buffer that would receive the read data.
//	[in]  cbBuffer - specifies the size of the above buffer
//	[out] pcbRead - pointer to receive the actual number of bytes read.
//
// Returns:
//	HRESULT - The status of the operation.
//	S_OK if successful.
//	ERROR_END_OF_FILE if the end of file was reached while being backed up
//	Other Win32 and RPC error code.
//
// Note:
//	It is important to realize that pcbRead may be less than cbBuffer.
//	This does not indicate an error, some transports may choose to fragment
//	the buffer being transmitted instead of returning the entire buffers
//	worth of data.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvBackupRead(
    IN  HCSBC hbc,
    IN  VOID *pvBuffer,
    IN  DWORD cbBuffer,
    OUT DWORD *pcbRead)
{
    HRESULT hr;
    CSBACKUPCONTEXT *pcsbc;
    BYTE *pbBuffer = (BYTE *) pvBuffer;
    DWORD cbRead;
    DWORD cb;

    hr = E_HANDLE;
    if (NULL == hbc)
    {
	_JumpError(hr, error, "NULL handle");
    }
    if (NULL == pvBuffer || NULL == pcbRead)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *pcbRead = 0;
    pcsbc = (CSBACKUPCONTEXT *) hbc;
    if (NULL == pcsbc->pbReadBuffer)
    {
	_JumpError(hr, error, "NULL buffer");
    }
    if (!pcsbc->fFileOpen)
    {
	_JumpError(hr, error, "File not open");
    }

    while (TRUE)
    {
	if (0 != pcsbc->cbCache)
	{
	    cb = min(pcsbc->cbCache, cbBuffer);
	    CopyMemory(pbBuffer, pcsbc->pbCache, cb);
	    pbBuffer += cb;
	    cbBuffer -= cb;
	    pcsbc->pbCache += cb;
	    pcsbc->cbCache -= cb;
	    *pcbRead += cb;
	}
	hr = S_OK;
	if (0 == cbBuffer)
	{
	    break;		// request satisfied
	}

	pcsbc->cbCache = 0;
	cbRead = 0;
	__try
	{
	    hr = pcsbc->pICertAdminD->BackupReadFile(
						pcsbc->pbReadBuffer,
						pcsbc->cbReadBuffer,
						(LONG *) &cbRead);
	    _LeaveIfError(hr, "BackupReadFile");
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
	if (S_OK != hr || 0 == cbRead)
	{
	    break;		// EOF
	}
	pcsbc->cbCache = cbRead;
	pcsbc->pbCache = pcsbc->pbReadBuffer;
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupClose -- called by the application after it completes reading
//	all the data in the currently opened attachement.
//
// Parameters:
//	[in] hbc - backup context handle
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvBackupClose(
    IN HCSBC hbc)
{
    HRESULT hr;
    CSBACKUPCONTEXT *pcsbc;

    hr = E_HANDLE;
    if (NULL == hbc)
    {
	_JumpError(hr, error, "NULL handle");
    }
    pcsbc = (CSBACKUPCONTEXT *) hbc;
    if (!pcsbc->fFileOpen)
    {
	_JumpError(hr, error, "File not open");
    }

    __try
    {
	hr = pcsbc->pICertAdminD->BackupCloseFile();
	_LeaveIfError(hr, "BackupCloseFile");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    // Clear flag even on failure...

    pcsbc->fFileOpen = FALSE;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupGetBackupLogs -- return the list of log files that need to be
//	backed up for the given backup context
//
//	This API will allocate a buffer of sufficient size to hold the entire
//	backup log list, which must be later freed with CertSrvBackupFree.
//
// Parameters:
//	[in]  hbc - backup context handle
//	[out] pszBackupLogFiles - pointer that will receive the pointer to the
//		list of log files; allocated memory should be freed using
//		CertSrvBackupFree() API by the caller when it is no longer
//		needed; Log files are returned in an array of null-terminated
//		filenames and the list is terminated by two L'\0's.
//	[out] pcbList - will receive the number of bytes returned
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvBackupGetBackupLogsW(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzFileList,
    OUT DWORD *pcbList)
{
    HRESULT hr;

    hr = BackupRestoreGetFileList(
			    FLT_LOGFILES,
			    hbc,
			    ppwszzFileList,
			    pcbList);
    _JumpIfError(hr, error, "BackupRestoreGetFileList");

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupTruncateLogs -- terminate the backup operation.  Called when
//	the backup has completed successfully.
//
// Parameters:
//	[in] hbc - backup context handle
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//
// Note:
//	Again, this API may have to take a grbit parameter to be passed to the
//	server to indicate the backup type.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvBackupTruncateLogs(
    IN HCSBC hbc)
{
    HRESULT hr;
    CSBACKUPCONTEXT *pcsbc;

    if (NULL == hbc)
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "NULL handle");
    }
    pcsbc = (CSBACKUPCONTEXT *) hbc;

    hr = S_OK;
    __try
    {
	hr = pcsbc->pICertAdminD->BackupTruncateLogs();
	_LeaveIfError(hr, "BackupTruncateLogs");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupEnd -- clean up after a backup operation has been performed.
//	This API will close outstanding binding handles, and do whatever is
//	necessary to clean up after successful/unsuccesful backup attempts.
//
// Parameters:
//	[in] hbc - backup context handle of the backup session
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvBackupEnd(
    IN HCSBC hbc)
{
    HRESULT hr;
    CSBACKUPCONTEXT *pcsbc;

    if (NULL == hbc)
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "NULL handle");
    }
    pcsbc = (CSBACKUPCONTEXT *) hbc;

    hr = S_OK;
    __try
    {
	hr = pcsbc->pICertAdminD->BackupEnd();
	_LeaveIfError(hr, "BackupEnd");

    ReleaseContext((CSBACKUPCONTEXT *) hbc);
	hr = S_OK;
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvBackupFree -- free any buffer allocated by certbcli.dll APIs.
//
// Parameters:
//	[in] pv - pointer to the buffer that is to be freed.
//
// Returns:
//	None.
//---------------------------------------------------------------------------

VOID
CERTBCLI_API
CertSrvBackupFree(
    IN VOID *pv)
{
    LocalFree(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certadm\manage.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        module.cpp
//
// Contents:    LEGACY Policy Manage Module implementation
// Contents:    LEGACY Exit   Manage Module implementation
//
//---------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

#include "manage.h"

#define __dwFILE__	__dwFILE_CERTADM_MANAGE_CPP__


extern HINSTANCE g_hInstance;

// LEGACY Policy module

STDMETHODIMP
CCertManagePolicyModule::GetProperty(
    /* [in] */ const BSTR, // strConfig
    /* [in] */ BSTR, // strStorageLocation
    /* [in] */ BSTR strPropertyName,
    /* [in] */ LONG, // dwFlags
    /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty)
{
    UINT uiStr = 0;
    HRESULT hr;
    WCHAR *pwszStr = NULL;

    if (NULL == strPropertyName)
    {
        hr = S_FALSE;
        _JumpError(hr, error, "NULL in parm");
    }
    if (NULL == pvarProperty)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }

    if (0 == mylstrcmpiL(strPropertyName, wszCMM_PROP_NAME))
        uiStr = IDS_LEGACYPOLICYMODULE_NAME;
    else
    {
        hr = S_FALSE;  
        _JumpError(hr, error, "invalid property name");
    }

    // load string from resource
    hr = myLoadRCString(g_hInstance, uiStr, &pwszStr);
    _JumpIfError(hr, error, "myLoadRCString");

    pvarProperty->bstrVal = SysAllocString(pwszStr);
    if (NULL == pvarProperty->bstrVal)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "out of memory");
    }

    myRegisterMemFree(pvarProperty->bstrVal, CSM_SYSALLOC);  // this mem owned by caller

    pvarProperty->vt = VT_BSTR;

    hr = S_OK;
error:
    if (NULL != pwszStr)
    {
        LocalFree(pwszStr);
    }
    return hr;
}
        
STDMETHODIMP 
CCertManagePolicyModule::SetProperty(
    /* [in] */ const BSTR, // strConfig
    /* [in] */ BSTR, // strStorageLocation
    /* [in] */ BSTR, // strPropertyName
    /* [in] */ LONG, // dwFlags
    /* [in] */ VARIANT const __RPC_FAR * /* pvalProperty */ )
{
    // no settable properties supported
    return S_FALSE;
}

        
STDMETHODIMP
CCertManagePolicyModule::Configure( 
    /* [in] */ const BSTR, // strConfig
    /* [in] */ BSTR, // strStorageLocation
    /* [in] */ LONG /* dwFlags */ )
{
    // no settable properties supported
    return S_FALSE;
}


// LEGACY Exit module

STDMETHODIMP
CCertManageExitModule::GetProperty(
    /* [in] */ const BSTR, // strConfig
    /* [in] */ BSTR, // strStorageLocation
    /* [in] */ BSTR strPropertyName,
    /* [in] */ LONG, // dwFlags
    /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty)
{
    UINT uiStr = 0;
    HRESULT hr;
    WCHAR *pwszStr = NULL;

    if (NULL == strPropertyName)
    {
        hr = S_FALSE;
        _JumpError(hr, error, "NULL in parm");
    }
    if (NULL == pvarProperty)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }

    if (0 == mylstrcmpiL(strPropertyName, wszCMM_PROP_NAME))
        uiStr = IDS_LEGACYEXITMODULE_NAME;
    else
    {
        hr = S_FALSE;  
        _JumpError(hr, error, "invalid property name");
    }

    // load string from resource
    hr = myLoadRCString(g_hInstance, uiStr, &pwszStr);
    _JumpIfError(hr, error, "myLoadRCString");

    pvarProperty->bstrVal = SysAllocString(pwszStr);
    if (NULL == pvarProperty->bstrVal)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "out of memory");
    }
    myRegisterMemFree(pvarProperty->bstrVal, CSM_SYSALLOC);  // this mem owned by caller

    pvarProperty->vt = VT_BSTR;

    hr = S_OK;
error:
    if (NULL != pwszStr)
    {
        LocalFree(pwszStr);
    }
    return hr;
}
        
STDMETHODIMP 
CCertManageExitModule::SetProperty(
    /* [in] */ const BSTR, // strConfig
    /* [in] */ BSTR, // strStorageLocation
    /* [in] */ BSTR, // strPropertyName
    /* [in] */ LONG, // dwFlags
    /* [in] */ VARIANT const __RPC_FAR * /* pvalProperty */ )
{
    // no settable properties supported
    return S_FALSE;
}

        
STDMETHODIMP
CCertManageExitModule::Configure( 
    /* [in] */ const BSTR, // strConfig
    /* [in] */ BSTR, // strStorageLocation
    /* [in] */ LONG /* dwFlags */ )
{
    // no settable properties supported
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certadm\certadm.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certadm.cpp
//
// Contents:    Cert Server client implementation
//
// History:     24-Aug-96       vich created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <objbase.h>
#include "certsrvd.h"

#include "admin.h"
#include "csview.h"		// CertView includes

#include "manage.h"

CComModule _Module;

HINSTANCE g_hInstance = NULL;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertAdmin, CCertAdmin)
#include "csviewm.h"		// CertView object map entries
    OBJECT_ENTRY(CLSID_CCertManagePolicyModule, CCertManagePolicyModule)
    OBJECT_ENTRY(CLSID_CCertManageExitModule, CCertManageExitModule)
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    switch (dwReason)
    {
	case DLL_PROCESS_ATTACH:
            g_hInstance = hInstance;
	    _Module.Init(ObjectMap, hInstance);
	    DisableThreadLibraryCalls(hInstance);
	    break;

        case DLL_PROCESS_DETACH:
	    _Module.Term();
            break;
    }
    return(TRUE);    // ok
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(_Module.GetLockCount() == 0? S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;
    
    hr = _Module.GetClassObject(rclsid, riid, ppv);
    if (S_OK == hr && NULL != *ppv)
    {
	myRegisterMemFree(*ppv, CSM_NEW | CSM_GLOBALDESTRUCTOR);
    }
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return(_Module.RegisterServer(TRUE));
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    _Module.UnregisterServer();
    return(S_OK);
}


void __RPC_FAR *__RPC_USER
MIDL_user_allocate(
    IN size_t cb)
{
    return(CoTaskMemAlloc(cb));
}


void __RPC_USER
MIDL_user_free(
    IN void __RPC_FAR *pb)
{
    CoTaskMemFree(pb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certadm\certadmp.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1998 - 1999
//
// File:        certadmnp.h
//
// Contents:    private certadm declarations
//
//---------------------------------------------------------------------------

#define FLT_DBFILES			0
#define FLT_LOGFILES			1
#define FLT_DYNAMICFILES		2
#define FLT_RESTOREDBLOCATIONS		3

typedef struct _CSBACKUPCONTEXT
{
    DWORD dwServerVersion;
    ICertAdminD2 *pICertAdminD;
    WCHAR const *pwszConfig;
    WCHAR const *pwszAuthority;
    DWORD RestoreFlags;
    BOOL fFileOpen;
    BYTE *pbReadBuffer;
    DWORD cbReadBuffer;
    BYTE *pbCache;
    DWORD cbCache;
} CSBACKUPCONTEXT;


HRESULT
AllocateContext(
    IN  WCHAR const *pwszConfig,
    OUT CSBACKUPCONTEXT **ppcsbc);

VOID
ReleaseContext(
    IN OUT CSBACKUPCONTEXT *pcsbc);

HRESULT
BackupRestoreGetFileList(
    IN  DWORD FileListType,
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzFileList,
    OUT DWORD *pcbList);

HRESULT
OpenAdminServer(
    IN WCHAR const *pwszConfig,
    OUT WCHAR const **ppwszAuthority,
    OUT DWORD *pdwServerVersion,
    OUT ICertAdminD2 **ppICertAdminD);

VOID
CloseAdminServer(
    IN OUT ICertAdminD2 **ppICertAdminD);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certadm\manage.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       manage.h
//
//--------------------------------------------------------------------------

#include "legacy.h"
#include "cscomres.h"

// LEGACY policy modules don't have a CCertManagePolicyModule -- create one for them!
// They only have one name: "CertificateAuthority.Policy", so they only need one 
// manage: "CertificateAuthority.PolicyManage"

// Once we create this, all legacy modules will be displayed through this managemodule.


class CCertManagePolicyModule: 
    public CComDualImpl<ICertManageModule, &IID_ICertManageModule, &LIBID_CERTPOLICYLib>, 
    public CComObjectRoot,
    public CComCoClass<CCertManagePolicyModule, &CLSID_CCertManagePolicyModule>
{
public:
    CCertManagePolicyModule() {};
    ~CCertManagePolicyModule() {};

BEGIN_COM_MAP(CCertManagePolicyModule)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertManageModule)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertManagePolicyModule) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

#define WSZ_LEGACY_POLICYPREFIX L"CertificateAuthority"
#define WSZ_LEGACY_POLICYMANAGE WSZ_LEGACY_POLICYPREFIX wszCERTMANAGEPOLICY_POSTFIX

DECLARE_REGISTRY(
    CCertManagePolicyModule,
    WSZ_LEGACY_POLICYMANAGE TEXT(".1"),
    WSZ_LEGACY_POLICYMANAGE,
    IDS_CERTMANAGEPOLICYMODULE_DESC,    
    THREADFLAGS_BOTH)

// ICertManageModule
public:

    STDMETHOD (GetProperty) (
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
    STDMETHOD (SetProperty)(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty);

        
    STDMETHOD (Configure)( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags);

};


// LEGACY exit modules don't have a CCertManageExitModule -- create one for them!
// They only have one name: "CertificateAuthority.Exit", so they only need one 
// manage: "CertificateAuthority.ExitManage"

// Once we create this, all legacy modules will be displayed through this managemodule.

class CCertManageExitModule: 
    public CComDualImpl<ICertManageModule, &IID_ICertManageModule, &LIBID_CERTPOLICYLib>, 
    public CComObjectRoot,
    public CComCoClass<CCertManageExitModule, &CLSID_CCertManageExitModule>
{
public:
    CCertManageExitModule() {};
    ~CCertManageExitModule() {};

BEGIN_COM_MAP(CCertManageExitModule)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ICertManageModule)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertManageExitModule) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

#define WSZ_LEGACY_EXITPREFIX L"CertificateAuthority"
#define WSZ_LEGACY_EXITMANAGE WSZ_LEGACY_EXITPREFIX wszCERTMANAGEEXIT_POSTFIX

DECLARE_REGISTRY(
    CCertManageExitModule,
    WSZ_LEGACY_EXITMANAGE TEXT(".1"),
    WSZ_LEGACY_EXITMANAGE,
    IDS_CERTMANAGEEXITMODULE_DESC,    
    THREADFLAGS_BOTH)

// ICertManageModule
public:

    STDMETHOD (GetProperty) (
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarProperty);
        
    STDMETHOD (SetProperty)(
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ BSTR strPropertyName,
            /* [in] */ LONG dwFlags,
            /* [in] */ VARIANT const __RPC_FAR *pvarProperty);

        
    STDMETHOD (Configure)( 
            /* [in] */ const BSTR strConfig,
            /* [in] */ BSTR strStorageLocation,
            /* [in] */ LONG dwFlags);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certcli\atl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       atl.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp: source file that includes just the standard includes
// stdafx.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include <pch.cpp>

#pragma hdrstop

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certadm\restore.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        restore.cpp
//
// Contents:    Cert Server client database restore APIs
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#include "certsrvd.h"
#include "csdisp.h"
#include "certadmp.h"

#define __dwFILE__	__dwFILE_CERTADM_RESTORE_CPP__


extern WCHAR g_wszRestoreAnnotation[];


//+--------------------------------------------------------------------------
// CertSrvServerControl -- send a control command to the cert server.
//
// Parameters:
//	[in]  pwszConfig - name or config string of the server to control
//	[in]  dwControlFlags - control command and flags
//	[out] pcbOut - pointer to receive the size of command output data
//	[out] ppbOut - pointer to receive command output data.  Use the
//		CertSrvBackupFree() API to free the buffer.
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//+--------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvServerControlW(
    IN WCHAR const *pwszConfig,
    IN DWORD dwControlFlags,
    OPTIONAL OUT DWORD *pcbOut,
    OPTIONAL OUT BYTE **ppbOut)
{
    HRESULT hr;
    ICertAdminD2 *pICertAdminD = NULL;
    DWORD dwServerVersion;
    WCHAR const *pwszAuthority;
    CERTTRANSBLOB ctbOut = { 0, NULL };

    if (NULL != pcbOut)
    {
	*pcbOut = 0;
    }
    if (NULL != ppbOut)
    {
	*ppbOut = NULL;
    }
    if (NULL == pwszConfig)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = S_OK;
    __try
    {
	hr = OpenAdminServer(
		    pwszConfig,
		    &pwszAuthority,
		    &dwServerVersion,
		    &pICertAdminD);
	_LeaveIfError(hr, "OpenAdminServer");

	hr = pICertAdminD->ServerControl(
				    pwszAuthority,
				    dwControlFlags,
				    &ctbOut);
	_LeaveIfError(hr, "ServerControl");

	if (NULL != ctbOut.pb && NULL != ppbOut)
	{
	    *ppbOut = (BYTE *) LocalAlloc(LMEM_FIXED, ctbOut.cb);
	    if (NULL == *ppbOut)
	    {
		hr = E_OUTOFMEMORY;
		_LeaveError(hr, "LocalAlloc");
	    }
	    CopyMemory(*ppbOut, ctbOut.pb, ctbOut.cb);
	    if (NULL != pcbOut)
	    {
		*pcbOut = ctbOut.cb;
	    }
	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != ctbOut.pb)
    {
	CoTaskMemFree(ctbOut.pb);
    }
    if (NULL != pICertAdminD)
    {
	CloseAdminServer(&pICertAdminD);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvRestorePrepare -- indicate beginning of a restore session.
//
// Parameters:
//	[in]  pwszConfig - name of the server into which the restore
//		operation is going to be performed.
//	[in]  dwRestoreFlags -  Or'ed combination of RESTORE_TYPE_* flags; 0 if
//		no special flags are to be specified
//	[out] phbc - pointer to receive the backup context handle which is to
//		be passed to the subsequent restore APIs
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvRestorePrepareW(
    IN  WCHAR const *pwszConfig,
    IN  ULONG dwRestoreFlags,
    OUT HCSBC *phbc)
{
    HRESULT hr;
    CSBACKUPCONTEXT *pcsbc = NULL;

    if (NULL == pwszConfig || NULL == phbc)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *phbc = NULL;
    if (~CSRESTORE_TYPE_FULL & dwRestoreFlags)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "dwRestoreFlags");
    }

    hr = AllocateContext(pwszConfig, &pcsbc);
    _JumpIfError(hr, error, "AllocateContext");

    pcsbc->RestoreFlags = dwRestoreFlags;

    *phbc = (HCSBC) pcsbc;
    pcsbc = NULL;

error:
    if (NULL != pcsbc)
    {
	ReleaseContext(pcsbc);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvRestoreGetDatabaseLocations -- called both at backup time as well as at
//	restore time to get data base locations for different types of files.
//
// Parameters:
//	[in]  hbc - backup context handle which would have been obtained
//		through CertSrvBackupPrepare in the backup case and through
//		CertSrvRestorePrepare in the restore case.
//	[out] ppwszzFileList - pointer that will receive the pointer
//		to the list of database locations; allocated memory should be
//		freed using CertSrvBackupFree() API by the caller when it is no
//		longer needed; locations are returned in an array of null
//		terminated names and and the list is terminated by two L'\0's.
//		The first character of each name is the BFT character that
//		indicates the type of the file and the rest of the name tells
//		gives the path into which that particular type of file should
//		be restored.
//	[out] pcbList - will receive the number of bytes returned
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//
// Note:
//    This API returns only the fully qualified path of the databases, not the
//    name of the databases.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvRestoreGetDatabaseLocationsW(
    IN  HCSBC hbc,
    OUT WCHAR **ppwszzFileList,
    OUT DWORD *pcbList)
{
    HRESULT hr;

    if (NULL == hbc)
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "NULL handle");
    }
    if (NULL == ppwszzFileList || NULL == pcbList)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    hr = S_OK;
    __try
    {
	hr = BackupRestoreGetFileList(
				FLT_RESTOREDBLOCATIONS,
				hbc,
				ppwszzFileList,
				pcbList);
	_LeaveIfError(hr, "BackupRestoreGetFileList");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    return(hr);
}


HRESULT
CleanupOldLogs(
    OPTIONAL IN WCHAR const *pwszConfig,
    OPTIONAL IN HKEY hkey,
    OPTIONAL IN WCHAR const *pwszLogPath, 
    IN ULONG genLow, 
    IN ULONG genHigh)
{
    HRESULT hr;
    DWORD cb;
    DWORD dwType;
    HANDLE hFind = INVALID_HANDLE_VALUE;
    WCHAR *pwsz;
    WCHAR *pwszLogPathUNC = NULL;
    WCHAR *pwszLogPathLocal = NULL;
    WCHAR *pwszLogPathWild = NULL;

    WIN32_FIND_DATA wfd;
    WCHAR wszServer[MAX_PATH];
    WCHAR wszLogFileName[2 * MAX_PATH]; // UNC logfile name
    WCHAR *pwszFileName;		// filename (edb0006A.log)   

    if (genHigh < genLow)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "bad parm");
    }

    wszServer[0] = L'\0';
    if (NULL != pwszConfig)
    {
	// Allow UNC-style config strings: \\server\CAName

	while (L'\\' == *pwszConfig)
	{
	    pwszConfig++;
	}
	wcscpy(wszServer, pwszConfig);
	pwsz = wcschr(wszServer, L'\\');
	if (NULL != pwsz)
	{
	    *pwsz = L'\0';
	}
    }

    // If the Log Path wasn't passed in, fetch it from the server's registry

    if (NULL == pwszLogPath)
    {
	if (NULL == hkey)
	{
	    hr = E_POINTER;
	    _JumpError(hr, error, "NULL parm");
	}
	cb = sizeof(wszLogFileName);
	hr = RegQueryValueEx(
			hkey,
			wszREGDBLOGDIRECTORY,
			0,
			&dwType,
			(BYTE *) wszLogFileName,
			&cb);
	_JumpIfError(hr, error, "RegQueryValueEx");

	// Assume remote access -- convert to UNC path

	hr = myConvertLocalPathToUNC(
				wszServer,
				wszLogFileName,
				&pwszLogPathUNC);
	_JumpIfError(hr, error, "myConvertLocalPathToUNC");

	pwszLogPath = pwszLogPathUNC;
    }

    // If local machine -- convert UNC path to Local Path

    if (NULL == pwszConfig)
    {
	hr = myConvertUNCPathToLocal(pwszLogPath, &pwszLogPathLocal);
	_JumpIfError(hr, error, "myConvertUNCPathToLocal");

	pwszLogPath = pwszLogPathLocal;
    }

    // copy the LogPath -- it's of the form "\\server\c$\winnt\ntlog" or
    // "c:\winnt\ntlog", possibly with a trailing backslash
    //
    // make two copies of the logpath - one to pass a wildcard string for
    // searching and other to create filenames with full path for the logfiles

    hr = myBuildPathAndExt(
		    pwszLogPath,
		    L"edb*.log",
		    NULL, 		// pwszExt
		    &pwszLogPathWild);
    _JumpIfError(hr, error, "myBuildPathAndExt");

    // make pwszFileName point past the last backslash in wszLogFileName

    wcscpy(wszLogFileName, pwszLogPathWild);
    pwszFileName = wcsrchr(wszLogFileName, L'\\');
    CSASSERT(NULL != pwszFileName);
    pwszFileName++;

    hFind = FindFirstFile(pwszLogPathWild, &wfd);
    if (INVALID_HANDLE_VALUE != hFind)
    {
	do
	{
	    // wfd.cFileName points to the name of edb*.log file found

	    ULONG ulLogNo = wcstoul(wfd.cFileName + 3, NULL, 16);

	    if (ulLogNo < genLow || ulLogNo > genHigh)
	    {
		// This is an old logfile which was not copied down by ntbackup
		// -- clean it up.  First append the filename to the logpath
		// (Note: pwszFileName already points past the end of the final
		// backslash in logpath).  Then delete the file by passing in
		// the full path.

		wcscpy(pwszFileName, wfd.cFileName); 
		//printf("Deleting: %ws\n", wszLogFileName);
		if (!DeleteFile(wszLogFileName))
		{
		    // Unable to delete the old logfile; not cleaning up will
		    // cause problems later.  Return failure code.

		    hr = myHLastError();
		    _JumpError(hr, error, "DeleteFile");
		}
	    }

	} while (FindNextFile(hFind, &wfd));
	
	hr = myHLastError();
	if (HRESULT_FROM_WIN32(ERROR_NO_MORE_FILES) != hr)
	{
	    // we came out of the loop for some unexpected error -- return the
	    // error code.

	    _JumpError(hr, error, "FindNextFile");
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszLogPathUNC)
    {
	LocalFree(pwszLogPathUNC);
    }
    if (NULL != pwszLogPathLocal)
    {
	LocalFree(pwszLogPathLocal);
    }
    if (NULL != pwszLogPathWild)
    {
	LocalFree(pwszLogPathWild);
    }
    if (INVALID_HANDLE_VALUE != hFind)
    {
	FindClose(hFind);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvRestoreRegister -- register a restore operation. It will interlock all
//	subsequent restore operations, and will prevent the restore target from
//	starting until the call to CertSrvRestoreRegisterComplete is made.
//
// Parameters:
//	[in] hbc - backup context handle for the restore session.
//	[in] pwszCheckPointFilePath - path to restore the check point files
//	[in] pwszLogPath - path where the log files are restored
//	[in] rgrstmap - restore map
//	[in] crstmap - tells if there is a new restore map
//	[in] pwszBackupLogPath - path where the backup logs are located
//	[in] genLow - Lowest log# that was restored in this restore session
//	[in] genHigh - Highest log# that was restored in this restore session
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvRestoreRegisterW(
    OPTIONAL IN HCSBC hbc,
    OPTIONAL IN WCHAR const *pwszCheckPointFilePath,
    OPTIONAL IN WCHAR const *pwszLogPath,
    OPTIONAL IN CSEDB_RSTMAPW rgrstmap[],
    IN LONG crstmap,
    OPTIONAL IN WCHAR const *pwszBackupLogPath,
    IN ULONG genLow,
    IN ULONG genHigh)
{
    HRESULT hr;
    WCHAR const *pwszConfig = NULL;
    HKEY hkey = NULL;
    HKEY hkeyRestore = NULL;
    WCHAR *pwszPath = NULL;
    DWORD cwcRstMap;
    WCHAR *pwszRstMap = NULL;
    WCHAR *pwsz;
    LONG i;
    DWORD dwDisposition;
    DWORD dwType;
    DWORD cbGen;
    ULONG genCurrent;
    BOOLEAN fDatabaseRecovered = FALSE;

#if DBG_CERTSRV
    if (NULL != getenv("certsrv_CertSrvRestoreRegisterThroughFile"))
    {
	hr = E_ACCESSDENIED;
	_JumpError(hr, error, "force CertSrvRestoreRegisterThroughFile");
    }
#endif
    if (0 != crstmap && NULL == rgrstmap)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (NULL != hbc)
    {
	CSBACKUPCONTEXT *pcsbc = (CSBACKUPCONTEXT *) hbc;

	pwszConfig = pcsbc->pwszConfig;
    }

    hr = myRegOpenRelativeKey(
			pwszConfig,
			L"",
			RORKF_CREATESUBKEYS,
			&pwszPath,
			NULL,		// ppwszName
			&hkey);

    // If the registry key doesn't exist, and we're restoring the local
    // machine, create it now.  The rest of the registry will be restored
    // prior to starting the cert server to recover the cert server database.

    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
	BOOL fLocal = TRUE;

	if (NULL != pwszConfig)
	{
	    hr = myIsConfigLocal(pwszConfig, NULL, &fLocal);
	    _JumpIfErrorStr(hr, error, "myIsConfigLocal", pwszConfig);
	}
	if (fLocal)
	{
	    hr = RegCreateKeyEx(
			    HKEY_LOCAL_MACHINE,
			    wszREGKEYCONFIGPATH,
			    0,			// Reserved
			    NULL,		// lpClass
			    0,			// dwOptions
			    KEY_ALL_ACCESS,
			    NULL,
			    &hkey,
			    &dwDisposition);
	    _JumpIfError(hr, error, "RegCreateKeyEx");
	}
	else
	{
	    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}
    }
    _JumpIfErrorStr(hr, error, "myRegOpenRelativeKey", pwszConfig);

    hr = RegCreateKeyEx(
		    hkey,
		    wszREGKEYRESTOREINPROGRESS,
		    0,			// Reserved
		    NULL,		// lpClass
		    0,			// dwOptions
		    KEY_ALL_ACCESS,
		    NULL,
		    &hkeyRestore,
		    &dwDisposition);
    _JumpIfError(hr, error, "RegCreateKeyEx");

    // Seed the restore-in-progress in the registry.

    hr = CERTSRV_E_SERVER_SUSPENDED;

    hr = RegSetValueEx(
		    hkeyRestore,
		    wszREGRESTORESTATUS,
		    0,
		    REG_DWORD,
		    (BYTE *) &hr,
		    sizeof(DWORD));
    _JumpIfError(hr, error, "RegSetValueEx");

    // We've now interlocked other restore operations from coming in from other
    // machines.

    if (0 != crstmap)
    {
	// Full backup:
	//
	// The restore map should only be set on a full backup.  If there's
	// already a restore map size (or restore map), then this full backup
	// is overriding a previously incomplete full backup.

	// Save away the size of the restore map.

	hr = RegSetValueEx(
			hkeyRestore,
			wszREGRESTOREMAPCOUNT,
			0,
			REG_DWORD,
			(BYTE *) &crstmap,
			sizeof(DWORD));

	// We now need to convert the restore map into one that we can put
	// into the registry.  First figure out how big it will be.

	cwcRstMap = 1;
	for (i = 0 ; i < crstmap ; i++)
	{
	    cwcRstMap +=
		myLocalPathwcslen(rgrstmap[i].pwszDatabaseName) + 1 +
		myLocalPathwcslen(rgrstmap[i].pwszNewDatabaseName) + 1;
	}

	pwszRstMap = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    cwcRstMap * sizeof(WCHAR));
	if (NULL == pwszRstMap)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	pwsz = pwszRstMap;
	for (i = 0 ; i < crstmap ; i++)
	{
	    myLocalPathwcscpy(pwsz, rgrstmap[i].pwszDatabaseName);
	    pwsz += wcslen(pwsz) + 1;

	    myLocalPathwcscpy(pwsz, rgrstmap[i].pwszNewDatabaseName);
	    pwsz += wcslen(pwsz) + 1;
	}

	*pwsz++ = L'\0';

	hr = RegSetValueEx(
			hkeyRestore,
			wszREGRESTOREMAP,
			0,
			REG_MULTI_SZ,
			(BYTE *) pwszRstMap,
			SAFE_SUBTRACT_POINTERS(
					(BYTE *) pwsz,
					(BYTE *) pwszRstMap));
    }
    else
    {
	// Incremental backup:
	//
	// Fail if no restore map exists -- Insist that a full backup be in
	// progress...

	cbGen = sizeof(genCurrent);
	hr = RegQueryValueEx(
			hkeyRestore,
			wszREGRESTOREMAPCOUNT,
			0,
			&dwType,
			(BYTE *) &genCurrent,
			&cbGen);
	_JumpIfError(hr, error, "RegQueryValueEx");

	// Expand genLow and genHigh to include previously registered log files

	cbGen = sizeof(genCurrent);
	hr = RegQueryValueEx(
			hkeyRestore,
			wszREGLOWLOGNUMBER,
			0,
			&dwType,
			(BYTE *) &genCurrent,
			&cbGen);
	if (S_OK == hr &&
	    REG_DWORD == dwType &&
	    sizeof(genCurrent) == cbGen &&
	    genLow > genCurrent)
	{
	    genLow = genCurrent;
	}

	cbGen = sizeof(genCurrent);
	hr = RegQueryValueEx(
			hkeyRestore,
			wszREGHIGHLOGNUMBER,
			0,
			&dwType,
			(BYTE *) &genCurrent,
			&cbGen);
	if (S_OK == hr &&
	    REG_DWORD == dwType &&
	    sizeof(genCurrent) == cbGen &&
	    genHigh < genCurrent)
	{
	    genHigh = genCurrent;
	}
    }

    hr = RegSetValueEx(
		    hkeyRestore,
		    wszREGLOWLOGNUMBER,
		    0,
		    REG_DWORD,
		    (BYTE *) &genLow,
		    sizeof(DWORD));
    _JumpIfError(hr, error, "RegSetValueEx");

    hr = RegSetValueEx(
		    hkeyRestore,
		    wszREGHIGHLOGNUMBER,
		    0,
		    REG_DWORD,
		    (BYTE *) &genHigh,
		    sizeof(DWORD));
    _JumpIfError(hr, error, "RegSetValueEx");

    if (NULL != pwszBackupLogPath)
    {
	hr = mySetRegistryLocalPathString(
				    hkeyRestore,
				    wszREGBACKUPLOGDIRECTORY,
				    pwszBackupLogPath);
	_JumpIfError(hr, error, "mySetRegistryLocalPathString");
    }

    if (NULL != pwszCheckPointFilePath)
    {
	hr = mySetRegistryLocalPathString(
				    hkeyRestore,
				    wszREGCHECKPOINTFILE,
				    pwszCheckPointFilePath);
	_JumpIfError(hr, error, "mySetRegistryLocalPathString");
    }

    if (NULL != pwszLogPath)
    {
	hr = mySetRegistryLocalPathString(
				    hkeyRestore,
				    wszREGLOGPATH,
				    pwszLogPath);
	_JumpIfError(hr, error, "mySetRegistryLocalPathString");
    }

    // Reset the "database recovered" bit.

    hr = RegSetValueEx(
		    hkeyRestore,
		    wszREGDATABASERECOVERED,
		    0,
		    REG_BINARY,
		    (BYTE *) &fDatabaseRecovered,
		    sizeof(BOOLEAN));
    _JumpIfError(hr, error, "RegSetValueEx");

    // We have successfully registered the restore, now cleanup any
    // pre-existing logfiles in the logdir to avoid JetExternalRestore using
    // logfiles that are not specified by the low and high log numbers.

    hr = CleanupOldLogs(pwszConfig, hkey, pwszLogPath, genLow, genHigh);
    _JumpIfError(hr, error, "CleanupOldLogs");

error:
    if (NULL != pwszRstMap)
    {
	LocalFree(pwszRstMap);
    }
    if (NULL != hkeyRestore)
    {
        RegCloseKey(hkeyRestore);
    }
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    if (NULL != pwszPath)
    {
	LocalFree(pwszPath);
    }

    hr = myHError(hr);

    return hr;
}


//+--------------------------------------------------------------------------
// CertSrvRestoreRegisterComplete -- indicate that a previously registered restore
//	is complete.
//
// Parameters:
//	[in] hbc - backup context handle
//	[in] hrRestoreState - success code if the restore was successful
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvRestoreRegisterComplete(
    OPTIONAL IN HCSBC hbc,
    IN HRESULT hrRestore)
{
    HRESULT hr;
    WCHAR const *pwszConfig = NULL;
    HKEY hkey = NULL;
    HKEY hkeyRestore = NULL;
    WCHAR *pwszPath = NULL;
    DWORD dwDisposition;

    if (NULL != hbc)
    {
	CSBACKUPCONTEXT *pcsbc = (CSBACKUPCONTEXT *) hbc;

	pwszConfig = pcsbc->pwszConfig;
    }
    if (S_OK != hrRestore && SUCCEEDED(hrRestore))
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "hrRestore");
    }

    hr = myRegOpenRelativeKey(
			pwszConfig,
			L"",
			RORKF_CREATESUBKEYS,
			&pwszPath,
			NULL,		// ppwszName
			&hkey);
    _JumpIfErrorStr(hr, error, "myRegOpenRelativeKey", pwszConfig);

    hr = RegCreateKeyEx(
		    hkey,
		    wszREGKEYRESTOREINPROGRESS,
		    0,			// Reserved
		    NULL,		// lpClass
		    0,			// dwOptions
		    KEY_ALL_ACCESS,
		    NULL,
		    &hkeyRestore,
		    &dwDisposition);
    _JumpIfError(hr, error, "RegCreateKeyEx");

    // If the restore status is not S_OK, then set the status to the error.
    // If the restore status is success, then clear the restore-in-progress
    // indicator.

    if (S_OK != hrRestore)
    {
	hr = RegSetValueEx(
			hkeyRestore,
			wszREGRESTORESTATUS,
			0,
			REG_DWORD,
			(BYTE *) &hrRestore,
			sizeof(DWORD));
	_JumpIfError(hr, error, "RegSetValueEx");
    }
    else
    {
	hr = RegDeleteValue(hkeyRestore, wszREGRESTORESTATUS);
	_JumpIfError(hr, error, "RegDeleteValue");
    }

error:
    if (NULL != hkeyRestore)
    {
        RegCloseKey(hkeyRestore);
    }
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    if (NULL != pwszPath)
    {
	LocalFree(pwszPath);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CertSrvRestoreEnd -- end a restore session
//
// Parameters:
//	[in] hbc - backup context handle
//
// Returns:
//	S_OK if the call executed successfully;
//	Failure code otherwise.
//---------------------------------------------------------------------------

HRESULT
CERTBCLI_API
CertSrvRestoreEnd(
    IN HCSBC hbc)
{
    HRESULT hr;

    if (NULL == hbc)
    {
	hr = E_HANDLE;
	_JumpError(hr, error, "NULL handle");
    }

    hr = S_OK;
    __try
    {
	ReleaseContext((CSBACKUPCONTEXT *) hbc);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    return(hr);
}

HRESULT
rsGetRestoreDataDWORD(
    IN LPCWSTR pwszRestoreFile,
    IN LPCWSTR pwszName,
    OUT DWORD *pdwData)
{
    WCHAR buffer[cwcDWORDSPRINTF];

    GetPrivateProfileString(
        wszRESTORE_SECTION,
        pwszName,
        L"",
        buffer,
        ARRAYSIZE(buffer),
        pwszRestoreFile);

    if (0 == wcscmp(buffer, L""))
    {
        return(S_FALSE);
    }
    *pdwData = _wtoi(buffer);
    return(S_OK);
}


HRESULT
CERTBCLI_API
CertSrvRestoreRegisterThroughFile(
    IN HCSBC hbc,
    OPTIONAL IN WCHAR const *pwszCheckPointFilePath,
    OPTIONAL IN WCHAR const *pwszLogPath,
    OPTIONAL IN CSEDB_RSTMAPW rgrstmap[],
    IN LONG crstmap,
    OPTIONAL IN WCHAR const *pwszBackupLogPath,
    IN ULONG genLow,
    IN ULONG genHigh)
{
    HRESULT hr = S_OK;
    WCHAR const *pwszConfig = NULL;
    LONG i;
    DWORD dwType;
    ULONG genCurrent;
    BOOLEAN fDatabaseRecovered = FALSE;
    WCHAR wszLogPath[MAX_PATH+1];
    WCHAR wszFormat[256]; // must fit MAXDWORD
    WCHAR wszKeyName[256]; // must fit RestoreMapN
    LPWSTR pwszLogPathUNC = NULL;
    HKEY hkey = NULL;
    LPWSTR pwszPath = NULL;
    LPWSTR pwszRestoreFile = NULL;
    LPWSTR pwszServer = NULL;
    LPWSTR pwszAuthority = NULL;

    if (!hbc ||
        (0 != crstmap && NULL == rgrstmap))
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL parm");
    }
    pwszConfig = ((CSBACKUPCONTEXT *) hbc)->pwszConfig;

    if (NULL == pwszLogPath)
    {
        DWORD cb;

	hr = myRegOpenRelativeKey(
			pwszConfig,
			L"",
			0,
			&pwszPath,
			NULL,		// ppwszName
			&hkey);
	_JumpIfError(hr, error, "RegQueryValueEx");

        cb = sizeof(wszLogPath);
        hr = RegQueryValueEx(
		        hkey,
		        wszREGDBLOGDIRECTORY,
		        0,
		        &dwType,
		        (BYTE *) wszLogPath,
		        &cb);
        _JumpIfError(hr, error, "RegQueryValueEx");

        pwszLogPath = wszLogPath;
    }

    if (L'\\' != pwszLogPath[0] || L'\\' != pwszLogPath[1])
    {
	// local path - convert to UNC for the INI file

	if (NULL != pwszConfig)		// if remote access
	{
	    hr = mySplitConfigString(pwszConfig, &pwszServer, &pwszAuthority);
	    _JumpIfError(hr, error, "mySplitConfigString");
	}
	else	// else local machine
	{
	    hr = myGetMachineDnsName(&pwszServer);
	    _JumpIfError(hr, error, "myGetMachineDnsName");
	}
	hr = myConvertLocalPathToUNC(pwszServer, pwszLogPath, &pwszLogPathUNC);
	_JumpIfError(hr, error, "myConvertLocalPathToUNC");
    }

    pwszRestoreFile = (LPWSTR) LocalAlloc(
				    LMEM_FIXED,
				    sizeof(WCHAR) * (
					wcslen(pwszLogPath) +
					wcslen(wszRESTORE_FILENAME) +
					2));
    _JumpIfAllocFailed(pwszRestoreFile, error);

    wcscpy(pwszRestoreFile, pwszLogPath);
    wcscat(pwszRestoreFile, L"\\");
    wcscat(pwszRestoreFile, wszRESTORE_FILENAME);

    wsprintf(wszFormat, L"%d", CERTSRV_E_SERVER_SUSPENDED);
    if (!WritePrivateProfileString(
            wszRESTORE_SECTION,
            wszREGRESTORESTATUS,
            wszFormat,
            pwszRestoreFile))
    {
        hr = myHLastError();
        _JumpError(hr, error, "WritePrivateProfileString");
    }
    
    if (0 != crstmap)
    {
	// Full backup:
	//
	// The restore map should only be set on a full backup.  If there's
	// already a restore map size (or restore map), then this full backup
	// is overriding a previously incomplete full backup.

        wsprintf(wszFormat, L"%d", crstmap);
        if (!WritePrivateProfileString(
                wszRESTORE_SECTION,
                wszREGRESTOREMAPCOUNT,
                wszFormat,
                pwszRestoreFile))
        {
            hr = myHLastError();
            _JumpError(hr, error, "WritePrivateProfileString");
        }

        for (i = 0 ; i < crstmap ; i++)
        {
            WCHAR wszPath[MAX_PATH];
            wsprintf(wszKeyName, L"%ws%d", wszREGRESTOREMAP, i);

            myLocalPathwcscpy(wszPath, rgrstmap[i].pwszDatabaseName);
        
            if (!WritePrivateProfileString(
                    wszRESTORE_SECTION,
                    wszKeyName,
                    wszPath,
                    pwszRestoreFile))
            {
                hr = myHLastError();
                _JumpError(hr, error, "WritePrivateProfileInt");
            }

            wsprintf(
		wszKeyName,
		L"%ws%ws%d",
		wszREGRESTOREMAP, 
                wszRESTORE_NEWLOGSUFFIX,
		i);

            myLocalPathwcscpy(wszPath, rgrstmap[i].pwszNewDatabaseName);

            if (!WritePrivateProfileString(
                    wszRESTORE_SECTION,
                    wszKeyName,
                    wszPath,
                    pwszRestoreFile))
            {
                hr = myHLastError();
                _JumpError(hr, error, "WritePrivateProfileInt");
            }

        }
    }
    else
    {
	// Incremental backup:
	//
	// Fail if no restore map exists -- Insist that a full backup be in
	// progress...

	hr = rsGetRestoreDataDWORD(
			    pwszRestoreFile,
			    wszREGRESTOREMAPCOUNT,
			    &genCurrent);
	if (S_FALSE == hr)
	{
	    hr = E_ABORT;	// mandatory
	}
	_JumpIfError(
		hr,
		error, 
		"restore ini file invalid, wszREGRESTOREMAPCOUNT not found");

	// Expand genLow and genHigh to include previously registered log files

	hr = rsGetRestoreDataDWORD(
			    pwszRestoreFile,
			    wszREGLOWLOGNUMBER,
			    &genCurrent);
	if (S_OK == hr && genLow > genCurrent)
	{
	    genLow = genCurrent;
	}

	hr = rsGetRestoreDataDWORD(
			    pwszRestoreFile,
			    wszREGHIGHLOGNUMBER,
			    &genCurrent);
	if (S_OK == hr && genHigh < genCurrent)
	{
	    genHigh = genCurrent;
	}
    }

    // dword wszREGLOWLOGNUMBER=genLow
    wsprintf(wszFormat, L"%d", genLow);
    if (!WritePrivateProfileString(
            wszRESTORE_SECTION,
            wszREGLOWLOGNUMBER,
            wszFormat,
            pwszRestoreFile))
    {
        hr = myHLastError();
        _JumpError(hr, error, "WritePrivateProfileString");
    }

    // dword wszREGHIGHLOGNUMBER=genHigh
    wsprintf(wszFormat, L"%d", genHigh);
    if (!WritePrivateProfileString(
            wszRESTORE_SECTION,
            wszREGHIGHLOGNUMBER,
            wszFormat,
            pwszRestoreFile))
    {
        hr = myHLastError();
        _JumpError(hr, error, "WritePrivateProfileString");
    }

    // string wszREGBACKUPLOGDIRECTORY=pwszBackupLogPath
    if (!WritePrivateProfileString(
            wszRESTORE_SECTION,
            wszREGBACKUPLOGDIRECTORY,
            pwszBackupLogPath,
            pwszRestoreFile))
    {
        hr = myHLastError();
        _JumpError(hr, error, "WritePrivateProfileString");
    }

    // string wszREGCHECKPOINTFILE=pwszCheckPointFilePath
    if (!WritePrivateProfileString(
            wszRESTORE_SECTION,
            wszREGCHECKPOINTFILE,
            pwszCheckPointFilePath,
            pwszRestoreFile))
    {
        hr = myHLastError();
        _JumpError(hr, error, "WritePrivateProfileString");
    }

    // string wszREGLOGPATH=pwszLogPath -- always write a UNC path
    if (!WritePrivateProfileString(
            wszRESTORE_SECTION,
            wszREGLOGPATH,
            NULL != pwszLogPathUNC? pwszLogPathUNC : pwszLogPath,
            pwszRestoreFile))
    {
        hr = myHLastError();
        _JumpError(hr, error, "WritePrivateProfileString");
    }

    // dword wszREGDATABASERECOVERED=fDatabaseRecovered
    wsprintf(wszFormat, L"%d", fDatabaseRecovered);
    if (!WritePrivateProfileString(
            wszRESTORE_SECTION,
            wszREGDATABASERECOVERED,
            wszFormat,
            pwszRestoreFile))
    {
        hr = myHLastError();
        _JumpError(hr, error, "WritePrivateProfileString");
    }

    // We have successfully registered the restore, now cleanup any
    // pre-existing logfiles in the logdir to avoid JetExternalRestore using
    // logfiles that are not specified by the low and high log numbers.

    CSASSERT(NULL != pwszLogPath);
    hr = CleanupOldLogs(pwszConfig, hkey, pwszLogPath, genLow, genHigh);
    _JumpIfError(hr, error, "CleanupOldLogs");

    // delete restore status error
    if (!WritePrivateProfileString(
            wszRESTORE_SECTION,
            wszREGRESTORESTATUS,
            NULL,
            pwszRestoreFile))
    {
        hr = myHLastError();
        _JumpError(hr, error, "WritePrivateProfileString");
    }

error:
    if (S_OK != hr && NULL != pwszRestoreFile)
    {
	// in case of failure, try to delete restore file

        if (!DeleteFile(pwszRestoreFile))
        {
            _PrintIfError(myHLastError(), "DeleteFile");
        }
    }
    LOCAL_FREE(pwszPath);
    LOCAL_FREE(pwszLogPathUNC);
    LOCAL_FREE(pwszRestoreFile);
    LOCAL_FREE(pwszServer);
    LOCAL_FREE(pwszAuthority);
    if (NULL != hkey)
    {
        RegCloseKey(hkey);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certadm\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#define __DIR__		"certadm"

#include <windows.h>
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>

#include <certsrv.h>
#include "certlib.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certcli\column.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        column.cpp
//
// Contents:    CertCli implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <common.ver>
#include "csprop.h"
#include "resource.h"

#define __dwFILE__	__dwFILE_CERTCLI_COLUMN_CPP__


extern HINSTANCE g_hInstance;


typedef struct _COLUMNTRANSLATE
{
    WCHAR const *pwszColumnName;
    DWORD        idMsgDisplayName;
    WCHAR const *pwszDisplayName;
} COLUMNTRANSLATE;


COLUMNTRANSLATE g_aColTable[] =
{
    { wszPROPREQUESTDOT wszPROPREQUESTREQUESTID, IDS_COLUMN_REQUESTID, },
    { wszPROPREQUESTDOT wszPROPREQUESTRAWREQUEST, IDS_COLUMN_REQUESTRAWREQUEST, },
    { wszPROPREQUESTDOT wszPROPREQUESTRAWARCHIVEDKEY, IDS_COLUMN_REQUESTRAWARCHIVEDKEY, },
    { wszPROPREQUESTDOT wszPROPREQUESTKEYRECOVERYHASHES, IDS_COLUMN_REQUESTKEYRECOVERYHASHES, },
    { wszPROPREQUESTDOT wszPROPREQUESTRAWOLDCERTIFICATE, IDS_COLUMN_REQUESTRAWOLDCERTIFICATE, },
    { wszPROPREQUESTDOT wszPROPREQUESTATTRIBUTES, IDS_COLUMN_REQUESTATTRIBUTES, },
    { wszPROPREQUESTDOT wszPROPREQUESTTYPE, IDS_COLUMN_REQUESTTYPE, },
    { wszPROPREQUESTDOT wszPROPREQUESTFLAGS, IDS_COLUMN_REQUESTFLAGS, },
    { wszPROPREQUESTDOT L"Status", IDS_COLUMN_REQUESTSTATUS, },
    { wszPROPREQUESTDOT wszPROPREQUESTSTATUSCODE, IDS_COLUMN_REQUESTSTATUSCODE, },
    { wszPROPREQUESTDOT wszPROPREQUESTDISPOSITION, IDS_COLUMN_REQUESTDISPOSITION, },
    { wszPROPREQUESTDOT wszPROPREQUESTDISPOSITIONMESSAGE, IDS_COLUMN_REQUESTDISPOSITIONMESSAGE, },
    { wszPROPREQUESTDOT wszPROPREQUESTSUBMITTEDWHEN, IDS_COLUMN_REQUESTSUBMITTEDWHEN, },
    { wszPROPREQUESTDOT wszPROPREQUESTRESOLVEDWHEN, IDS_COLUMN_REQUESTRESOLVEDWHEN, },
    { wszPROPREQUESTDOT wszPROPREQUESTREVOKEDWHEN, IDS_COLUMN_REQUESTREVOKEDWHEN, },
    { wszPROPREQUESTDOT wszPROPREQUESTREVOKEDEFFECTIVEWHEN, IDS_COLUMN_REQUESTREVOKEDEFFECTIVEWHEN, },
    { wszPROPREQUESTDOT wszPROPREQUESTREVOKEDREASON, IDS_COLUMN_REQUESTREVOKEDREASON, },
    { wszPROPREQUESTDOT wszPROPREQUESTERNAME, IDS_COLUMN_REQUESTERNAME, },
    { wszPROPREQUESTDOT wszPROPCALLERNAME, IDS_COLUMN_CALLERNAME, },
    { wszPROPREQUESTDOT wszPROPREQUESTERADDRESS, IDS_COLUMN_REQUESTERADDRESS, },

    { wszPROPREQUESTDOT wszPROPDISTINGUISHEDNAME, IDS_COLUMN_REQUESTDISTINGUISHEDNAME, },
    { wszPROPREQUESTDOT wszPROPRAWNAME, IDS_COLUMN_REQUESTRAWNAME, },
    { wszPROPREQUESTDOT wszPROPCOUNTRY, IDS_COLUMN_REQUESTCOUNTRY, },
    { wszPROPREQUESTDOT wszPROPORGANIZATION, IDS_COLUMN_REQUESTORGANIZATION, },
    { wszPROPREQUESTDOT wszPROPORGUNIT, IDS_COLUMN_REQUESTORGUNIT, },
    { wszPROPREQUESTDOT wszPROPCOMMONNAME, IDS_COLUMN_REQUESTCOMMONNAME, },
    { wszPROPREQUESTDOT wszPROPLOCALITY, IDS_COLUMN_REQUESTLOCALITY, },
    { wszPROPREQUESTDOT wszPROPSTATE, IDS_COLUMN_REQUESTSTATE, },
    { wszPROPREQUESTDOT wszPROPTITLE, IDS_COLUMN_REQUESTTITLE, },
    { wszPROPREQUESTDOT wszPROPGIVENNAME, IDS_COLUMN_REQUESTGIVENNAME, },
    { wszPROPREQUESTDOT wszPROPINITIALS, IDS_COLUMN_REQUESTINITIALS, },
    { wszPROPREQUESTDOT wszPROPSURNAME, IDS_COLUMN_REQUESTSURNAME, },
    { wszPROPREQUESTDOT wszPROPDOMAINCOMPONENT, IDS_COLUMN_REQUESTDOMAINCOMPONENT, },
    { wszPROPREQUESTDOT wszPROPEMAIL, IDS_COLUMN_REQUESTEMAIL, },
    { wszPROPREQUESTDOT wszPROPSTREETADDRESS, IDS_COLUMN_REQUESTSTREETADDRESS, },
    { wszPROPREQUESTDOT wszPROPUNSTRUCTUREDNAME, IDS_COLUMN_REQUESTUNSTRUCTUREDNAME, },
    { wszPROPREQUESTDOT wszPROPUNSTRUCTUREDADDRESS, IDS_COLUMN_REQUESTUNSTRUCTUREDADDRESS, },
    { wszPROPREQUESTDOT wszPROPDEVICESERIALNUMBER, IDS_COLUMN_REQUESTDEVICESERIALNUMBER },
    { wszPROPREQUESTDOT wszPROPSIGNERPOLICIES, IDS_COLUMN_REQUESTSIGNERPOLICIES },
    { wszPROPREQUESTDOT wszPROPSIGNERAPPLICATIONPOLICIES, IDS_COLUMN_REQUESTSIGNERAPPLICATIONPOLICIES },
    { wszPROPREQUESTDOT wszPROPOFFICER, IDS_COLUMN_REQUESTOFFICER },

    { wszPROPCERTIFICATEREQUESTID, IDS_COLUMN_CERTIFICATEREQUESTID, },
    { wszPROPRAWCERTIFICATE, IDS_COLUMN_CERTIFICATERAWCERTIFICATE, },
    { wszPROPCERTIFICATEHASH, IDS_COLUMN_CERTIFICATECERTIFICATEHASH, },
    { wszPROPCERTIFICATETEMPLATE, IDS_COLUMN_PROPCERTIFICATETEMPLATE, },
    { wszPROPCERTIFICATEENROLLMENTFLAGS, IDS_COLUMN_PROPCERTIFICATEENROLLMENTFLAGS, },
    { wszPROPCERTIFICATEGENERALFLAGS, IDS_COLUMN_PROPCERTIFICATEGENERALFLAGS, },
    { wszPROPCERTIFICATESERIALNUMBER, IDS_COLUMN_CERTIFICATESERIALNUMBER, },
    { wszPROPCERTIFICATEISSUERNAMEID, IDS_COLUMN_CERTIFICATEISSUERNAMEID, },
    { wszPROPCERTIFICATENOTBEFOREDATE, IDS_COLUMN_CERTIFICATENOTBEFOREDATE, },
    { wszPROPCERTIFICATENOTAFTERDATE, IDS_COLUMN_CERTIFICATENOTAFTERDATE, },
    { wszPROPCERTIFICATESUBJECTKEYIDENTIFIER, IDS_COLUMN_CERTIFICATESUBJECTKEYIDENTIFIER , },
    { wszPROPCERTIFICATERAWPUBLICKEY, IDS_COLUMN_CERTIFICATERAWPUBLICKEY, },
    { wszPROPCERTIFICATEPUBLICKEYLENGTH, IDS_COLUMN_CERTIFICATEPUBLICKEYLENGTH, },
    { wszPROPCERTIFICATEPUBLICKEYALGORITHM, IDS_COLUMN_CERTIFICATEPUBLICKEYALGORITHM, },
    { wszPROPCERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS, IDS_COLUMN_CERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS, },
    { wszPROPCERTIFICATEUPN, IDS_COLUMN_CERTIFICATEUPN, },

    { wszPROPDISTINGUISHEDNAME, IDS_COLUMN_CERTIFICATEDISTINGUISHEDNAME, },
    { wszPROPRAWNAME, IDS_COLUMN_CERTIFICATERAWNAME, },
    { wszPROPCOUNTRY, IDS_COLUMN_CERTIFICATECOUNTRY, },
    { wszPROPORGANIZATION, IDS_COLUMN_CERTIFICATEORGANIZATION, },
    { wszPROPORGUNIT, IDS_COLUMN_CERTIFICATEORGUNIT, },
    { wszPROPCOMMONNAME, IDS_COLUMN_CERTIFICATECOMMONNAME, },
    { wszPROPLOCALITY, IDS_COLUMN_CERTIFICATELOCALITY, },
    { wszPROPSTATE, IDS_COLUMN_CERTIFICATESTATE, },
    { wszPROPTITLE, IDS_COLUMN_CERTIFICATETITLE, },
    { wszPROPGIVENNAME, IDS_COLUMN_CERTIFICATEGIVENNAME, },
    { wszPROPINITIALS, IDS_COLUMN_CERTIFICATEINITIALS, },
    { wszPROPSURNAME, IDS_COLUMN_CERTIFICATESURNAME, },
    { wszPROPDOMAINCOMPONENT, IDS_COLUMN_CERTIFICATEDOMAINCOMPONENT, },
    { wszPROPEMAIL, IDS_COLUMN_CERTIFICATEEMAIL, },
    { wszPROPSTREETADDRESS, IDS_COLUMN_CERTIFICATESTREETADDRESS, },
    { wszPROPUNSTRUCTUREDNAME, IDS_COLUMN_CERTIFICATEUNSTRUCTUREDNAME, },
    { wszPROPUNSTRUCTUREDADDRESS, IDS_COLUMN_CERTIFICATEUNSTRUCTUREDADDRESS, },
    { wszPROPDEVICESERIALNUMBER, IDS_COLUMN_CERTIFICATEDEVICESERIALNUMBER },

    { wszPROPEXTREQUESTID, IDS_COLUMN_EXTREQUESTID, },
    { wszPROPEXTNAME, IDS_COLUMN_EXTNAME, },
    { wszPROPEXTFLAGS, IDS_COLUMN_EXTFLAGS, },
    { wszPROPEXTRAWVALUE, IDS_COLUMN_EXTRAWVALUE, },

    { wszPROPATTRIBREQUESTID, IDS_COLUMN_ATTRIBREQUESTID, },
    { wszPROPATTRIBNAME, IDS_COLUMN_ATTRIBNAME, },
    { wszPROPATTRIBVALUE, IDS_COLUMN_ATTRIBVALUE, },

    { wszPROPCRLROWID, IDS_COLUMN_CRLROWID, },
    { wszPROPCRLNUMBER, IDS_COLUMN_CRLNUMBER, },
    { wszPROPCRLMINBASE, IDS_COLUMN_CRLMINBASE, },
    { wszPROPCRLNAMEID, IDS_COLUMN_CRLNAMEID, },
    { wszPROPCRLCOUNT, IDS_COLUMN_CRLCOUNT, },
    { wszPROPCRLTHISUPDATE, IDS_COLUMN_CRLTHISUPDATE, },
    { wszPROPCRLNEXTUPDATE, IDS_COLUMN_CRLNEXTUPDATE, },
    { wszPROPCRLTHISPUBLISH, IDS_COLUMN_CRLTHISPUBLISH, },
    { wszPROPCRLNEXTPUBLISH, IDS_COLUMN_CRLNEXTPUBLISH, },
    { wszPROPCRLEFFECTIVE, IDS_COLUMN_CRLEFFECTIVE, },
    { wszPROPCRLPROPAGATIONCOMPLETE, IDS_COLUMN_CRLPROPAGATIONCOMPLETE, },
    { wszPROPCRLLASTPUBLISHED, IDS_COLUMN_CRLLASTPUBLISHED, },
    { wszPROPCRLPUBLISHATTEMPTS, IDS_COLUMN_CRLPUBLISHATTEMPTS, },
    { wszPROPCRLPUBLISHFLAGS, IDS_COLUMN_CRLPUBLISHFLAGS, },
    { wszPROPCRLPUBLISHSTATUSCODE, IDS_COLUMN_CRLPUBLISHSTATUSCODE, },
    { wszPROPCRLPUBLISHERROR, IDS_COLUMN_CRLPUBLISHERROR, },
    { wszPROPCRLRAWCRL, IDS_COLUMN_CRLRAWCRL, },

    // Obsolete:
    { wszPROPCERTIFICATETYPE, IDS_COLUMN_CERTIFICATETYPE, },
    { wszPROPCERTIFICATERAWSMIMECAPABILITIES, IDS_COLUMN_CERTIFICATERAWSMIMECAPABILITIES },
    { wszPROPNAMETYPE, IDS_COLUMN_CERTIFICATENAMETYPE, },
    { wszPROPREQUESTDOT wszPROPNAMETYPE, IDS_COLUMN_REQUESTNAMETYPE, },

    { NULL, 0, },
};

#define CCOL_MAX	(ARRAYSIZE(g_aColTable) - 1)


typedef struct _CAPROPTRANSLATE
{
    LONG         lPropId;
    DWORD        idMsgDisplayName;
    WCHAR const *pwszDisplayName;
} CAPROPTRANSLATE;


CAPROPTRANSLATE g_aCAPropTable[] =
{
    { CR_PROP_FILEVERSION,	 IDS_CAPROP_FILEVERSION, },
    { CR_PROP_PRODUCTVERSION,	 IDS_CAPROP_PRODUCTVERSION, },
    { CR_PROP_EXITCOUNT,	 IDS_CAPROP_EXITCOUNT, },
    { CR_PROP_EXITDESCRIPTION,	 IDS_CAPROP_EXITDESCRIPTION, },
    { CR_PROP_POLICYDESCRIPTION, IDS_CAPROP_POLICYDESCRIPTION, },
    { CR_PROP_CANAME,		 IDS_CAPROP_CANAME, },
    { CR_PROP_SANITIZEDCANAME,	 IDS_CAPROP_SANITIZEDCANAME, },
    { CR_PROP_SANITIZEDCASHORTNAME, IDS_CAPROP_SANITIZEDCASHORTNAME, },
    { CR_PROP_SHAREDFOLDER,	 IDS_CAPROP_SHAREDFOLDER, },
    { CR_PROP_PARENTCA,		 IDS_CAPROP_PARENTCA, },

    { CR_PROP_CATYPE,		 IDS_CAPROP_CATYPE, },
    { CR_PROP_CASIGCERTCOUNT,	 IDS_CAPROP_CASIGCERTCOUNT, },
    { CR_PROP_CASIGCERT,	 IDS_CAPROP_CASIGCERT, },
    { CR_PROP_CASIGCERTCHAIN,	 IDS_CAPROP_CASIGCERTCHAIN, },
    { CR_PROP_CAXCHGCERTCOUNT,	 IDS_CAPROP_CAXCHGCERTCOUNT, },
    { CR_PROP_CAXCHGCERT,	 IDS_CAPROP_CAXCHGCERT, },
    { CR_PROP_CAXCHGCERTCHAIN,	 IDS_CAPROP_CAXCHGCERTCHAIN, },
    { CR_PROP_BASECRL,		 IDS_CAPROP_BASECRL, },
    { CR_PROP_DELTACRL,		 IDS_CAPROP_DELTACRL, },
    { CR_PROP_CACERTSTATE,	 IDS_CAPROP_CACERTSTATE, },
    { CR_PROP_CRLSTATE,		 IDS_CAPROP_CRLSTATE, },
    { CR_PROP_CAPROPIDMAX,	 IDS_CAPROP_CAPROPIDMAX, },
    { CR_PROP_DNSNAME,	 	 IDS_CAPROP_DNSNAME, },
    { CR_PROP_KRACERTUSEDCOUNT,	 IDS_CAPROP_KRACERTUSEDCOUNT, },
    { CR_PROP_KRACERTCOUNT,	 IDS_CAPROP_KRACERTCOUNT, },
    { CR_PROP_KRACERT,		 IDS_CAPROP_KRACERT, },
    { CR_PROP_KRACERTSTATE,	 IDS_CAPROP_KRACERTSTATE, },
    { CR_PROP_ADVANCEDSERVER,	 IDS_CAPROP_ADVANCEDSERVER, },
    { CR_PROP_TEMPLATES,	 IDS_CAPROP_TEMPLATES, },
    { CR_PROP_BASECRLPUBLISHSTATUS, IDS_CAPROP_BASECRLPUBLISHSTATUS, },
    { CR_PROP_DELTACRLPUBLISHSTATUS, IDS_CAPROP_DELTACRLPUBLISHSTATUS, },
    { CR_PROP_CASIGCERTCRLCHAIN, IDS_CAPROP_CASIGCERTCRLCHAIN, },
    { CR_PROP_CAXCHGCERTCRLCHAIN,IDS_CAPROP_CAXCHGCERTCRLCHAIN, },
    { CR_PROP_CACERTSTATUSCODE,	 IDS_CAPROP_CACERTSTATUSCODE, },
    { CR_PROP_CAFORWARDCROSSCERT, IDS_CAPROP_CAFORWARDCROSSCERT, },
    { CR_PROP_CABACKWARDCROSSCERT, IDS_CAPROP_CABACKWARDCROSSCERT, },
    { CR_PROP_CAFORWARDCROSSCERTSTATE, IDS_CAPROP_CAFORWARDCROSSCERTSTATE, },
    { CR_PROP_CABACKWARDCROSSCERTSTATE, IDS_CAPROP_CABACKWARDCROSSCERTSTATE, },
    { CR_PROP_CACERTVERSION,	 IDS_CAPROP_CACERTVERSION, },
    { 0, 0, },
};

#define CAPROP_MAX	(ARRAYSIZE(g_aCAPropTable) - 1)

WCHAR *g_pwszCertCliVersion = NULL;


VOID
myFreeColumnDisplayNames2()
{
    COLUMNTRANSLATE *pct;
    CAPROPTRANSLATE *pcapt;

    if (NULL != g_aColTable[0].pwszDisplayName)
    {
	for (pct = g_aColTable; NULL != pct->pwszColumnName; pct++)
	{
	    if (NULL != pct->pwszDisplayName)
	    {
		LocalFree(const_cast<WCHAR *>(pct->pwszDisplayName));
		pct->pwszDisplayName = NULL;
	    }
	}
    }
    if (NULL != g_aCAPropTable[0].pwszDisplayName)
    {
	for (pcapt = g_aCAPropTable; 0 != pcapt->lPropId; pcapt++)
	{
	    if (NULL != pcapt->pwszDisplayName)
	    {
		LocalFree(const_cast<WCHAR *>(pcapt->pwszDisplayName));
		pcapt->pwszDisplayName = NULL;
	    }
	}
    }
    if (NULL != g_pwszCertCliVersion)
    {
	LocalFree(g_pwszCertCliVersion);
	g_pwszCertCliVersion = NULL;
    }
}


HRESULT
LoadDisplayNames()
{
    HRESULT hr;
    COLUMNTRANSLATE *pct;
    CAPROPTRANSLATE *pcapt;
    WCHAR awc[512];

    for (pct = g_aColTable; NULL != pct->pwszColumnName; pct++)
    {
	WCHAR *pwsz;

	if (!LoadString(
		    g_hInstance,
		    pct->idMsgDisplayName,
		    awc,
		    ARRAYSIZE(awc)))
	{
	    hr = myHLastError();
	    CSASSERT(S_OK != hr);
	    _JumpError(hr, error, "LoadString");
	}
	pwsz = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				(wcslen(awc) + 1) * sizeof(WCHAR));
	if (NULL == pwsz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc display name");
	}
	wcscpy(pwsz, awc);
	pct->pwszDisplayName = pwsz;
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "%x: '%ws' --> '%ws'\n",
	    SAFE_SUBTRACT_POINTERS(pct, g_aColTable),
	    pct->pwszColumnName,
	    pct->pwszDisplayName));
    }
    for (pcapt = g_aCAPropTable; 0 != pcapt->lPropId; pcapt++)
    {
	WCHAR *pwsz;

	if (!LoadString(
		    g_hInstance,
		    pcapt->idMsgDisplayName,
		    awc,
		    ARRAYSIZE(awc)))
	{
	    hr = myHLastError();
	    CSASSERT(S_OK != hr);
	    _JumpError(hr, error, "LoadString");
	}
	pwsz = (WCHAR *) LocalAlloc(
				LMEM_FIXED,
				(wcslen(awc) + 1) * sizeof(WCHAR));
	if (NULL == pwsz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc display name");
	}
	wcscpy(pwsz, awc);
	pcapt->pwszDisplayName = pwsz;
	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "%x: %x --> '%ws'\n",
	    SAFE_SUBTRACT_POINTERS(pcapt, g_aCAPropTable),
	    pcapt->lPropId,
	    pcapt->pwszDisplayName));
    }
    if (!myConvertSzToWsz(&g_pwszCertCliVersion, szCSVER_STR, -1))
    {
       hr = E_OUTOFMEMORY;
       _JumpError(hr, error, "myConvertSzToWsz");
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	myFreeColumnDisplayNames2();
    }
    return(hr);
}


HRESULT
myGetColumnDisplayName(
    IN  WCHAR const  *pwszColumnName,
    OUT WCHAR const **ppwszDisplayName)
{
    HRESULT hr;
    COLUMNTRANSLATE *pct;

    *ppwszDisplayName = NULL;
    if (NULL == g_aColTable[0].pwszDisplayName)
    {
	hr = LoadDisplayNames();
	_JumpIfError(hr, error, "LoadDisplayNames");
    }
    
    for (pct = g_aColTable; NULL != pct->pwszColumnName; pct++)
    {
	if (0 == mylstrcmpiS(pwszColumnName, pct->pwszColumnName))
	{
	    *ppwszDisplayName = pct->pwszDisplayName;
	    break;
	}
    }
    if (NULL == *ppwszDisplayName &&
	0 == LSTRCMPIS(pwszColumnName, wszPROPCERTCLIDLL_VERSION))
    {
	*ppwszDisplayName = g_pwszCertCliVersion;
    }
    if (NULL == *ppwszDisplayName)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Bad Column Name");
    }
    hr = S_OK;

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myGetColumnDisplayName(%ws) --> '%ws'\n",
	pwszColumnName,
	*ppwszDisplayName));
error:
    return(hr);
}


HRESULT
myGetColumnName(
    IN  DWORD         Index,
    IN  BOOL          fDisplayName,
    OUT WCHAR const **ppwszName)
{
    HRESULT hr;
    COLUMNTRANSLATE *pct;

    *ppwszName = NULL;
    if (NULL == g_aColTable[0].pwszDisplayName)
    {
	hr = LoadDisplayNames();
	_JumpIfError(hr, error, "LoadDisplayNames");
    }
    if (CCOL_MAX <= Index)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "Bad Index");
    }
    pct = &g_aColTable[Index];
    *ppwszName = fDisplayName? pct->pwszDisplayName : pct->pwszColumnName;
    hr = S_OK;

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"myGetColumnName(%x, fDisplay=%d) --> '%ws'\n",
	Index,
	fDisplayName,
	*ppwszName));

error:
    return(hr);
}


HRESULT
myCAPropGetDisplayName(
    IN  LONG          lPropId,
    OUT WCHAR const **ppwszDisplayName)
{
    HRESULT hr;
    CAPROPTRANSLATE *pcapt;

    *ppwszDisplayName = NULL;
    if (NULL == g_aColTable[0].pwszDisplayName)
    {
	hr = LoadDisplayNames();
	_JumpIfError(hr, error, "LoadDisplayNames");
    }
    
    hr = E_INVALIDARG;
    for (pcapt = g_aCAPropTable; 0 != pcapt->lPropId; pcapt++)
    {
	if (lPropId == pcapt->lPropId)
	{
	    *ppwszDisplayName = pcapt->pwszDisplayName;
	    hr = S_OK;
	    break;
	}
    }
    _JumpIfError(hr, error, "Bad PropId");

error:
    DBGPRINT((
	S_OK == hr? DBG_SS_CERTLIBI : DBG_SS_CERTLIB,
	"myCAPropGetDisplayName(%x) --> hr=%x, '%ws'\n",
	lPropId,
	hr,
	*ppwszDisplayName));
    return(hr);
}


HRESULT
myCAPropInfoLookup(
    IN CAPROP const *pCAPropInfo,
    IN LONG cCAPropInfo,
    IN LONG lPropId,
    OUT CAPROP const **ppcap)
{
    HRESULT hr;
    CAPROP const *pcap;
    CAPROP const *pcapEnd;

    if (NULL == ppcap)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppcap = NULL;

    hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
    pcapEnd = &pCAPropInfo[cCAPropInfo];
    for (pcap = pCAPropInfo; pcap < pcapEnd; pcap++)
    {
	if (lPropId == pcap->lPropId)
	{
	    *ppcap = pcap;
	    hr = S_OK;
	    break;
	}
    }
    _JumpIfError(hr, error, "Bad lPropId");

error:
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certcli\certcli.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        certcli.cpp
//
// Contents:    Cert Server client implementation
//
// History:     24-Aug-96       vich created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "certsrvd.h"
#include "configp.h"
#include "config.h"
#include "getconf.h"
#include "request.h"
#include "certtype.h"

#include "csif.h"		// CertIf includes
#include "csprxy.h"		// CertPrxy includes
#include "resource.h"
#include "csresstr.h"


HINSTANCE g_hInstance = NULL; 

extern CRITICAL_SECTION g_csDomainSidCache;
extern CRITICAL_SECTION g_csOidURL;
extern BOOL g_fInitDone = FALSE;
extern BOOL g_fOidURL = FALSE;

#if DBG_CERTSRV
extern VOID RegisterMemoryDeleteCriticalSection();
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CCertConfig, CCertConfig)
    OBJECT_ENTRY(CLSID_CCertGetConfig, CCertGetConfig)
    OBJECT_ENTRY(CLSID_CCertRequest, CCertRequest)
#include "csifm.h"		// CertIf object map entries
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    BOOL fRet = TRUE;	// assume OK
    
    __try
    {
	fRet = CertPrxyDllMain(hInstance, dwReason, lpReserved);
	switch (dwReason)
	{
	    case DLL_PROCESS_ATTACH:
		myVerifyResourceStrings(hInstance);
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
		g_hInstance = hInstance;
		InitializeCriticalSection(&g_csDomainSidCache);
		g_fInitDone = TRUE;
		InitializeCriticalSection(&g_csOidURL);
		g_fOidURL = TRUE;
		break;

	    case DLL_PROCESS_DETACH:
		myFreeColumnDisplayNames();
		if (g_fOidURL)
		{
		    DeleteCriticalSection(&g_csOidURL);
		}
		if (g_fInitDone)
		{
		    DeleteCriticalSection(&g_csDomainSidCache);
		}
		DbgTerminate();
		_Module.Term();
#if DBG_CERTSRV
		RegisterMemoryDeleteCriticalSection();
#endif
		g_hInstance = NULL;
		break;
	}
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
	// return failure
	fRet = FALSE;
    }
    return(fRet);
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return(
	(S_OK == CertPrxyDllCanUnloadNow() && 0 == _Module.GetLockCount())?
	S_OK : S_FALSE);
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    HRESULT hr;
    
    hr = CertPrxyDllGetClassObject(rclsid, riid, ppv);
    if (S_OK != hr)
    {
	hr = _Module.GetClassObject(rclsid, riid, ppv);
	if (S_OK == hr && NULL != *ppv)
	{
	    myRegisterMemFree(*ppv, CSM_NEW | CSM_GLOBALDESTRUCTOR);
	}
    }
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    HRESULT hr;
    HRESULT hr2;
    HKEY hGPOExtensions;

    // we remove the registration of GPO Processing call backs.  This was
    // intended for upgrading B2 clients.

    hr = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions"),
                0,
                KEY_WRITE | KEY_READ,
                &hGPOExtensions);

    if (S_OK == hr)
    {
        RegDeleteKey(hGPOExtensions, TEXT("PublicKeyPolicy"));
        RegCloseKey(hGPOExtensions);
    }

    hr = CertPrxyDllRegisterServer();

    // registers object, typelib and all interfaces in typelib
    hr2 = _Module.RegisterServer(TRUE);

    if (S_OK == hr)
    {
	hr = hr2;
    }

    //register the evenlog
    hr2 =  myAddLogSourceToRegistry(L"%SystemRoot%\\System32\\pautoenr.dll",
                                    L"AutoEnrollment");

    if (S_OK == hr)
    {
	hr = hr2;
    }
    return(hr);
}


/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    HRESULT hr;
    HRESULT hr2;
    HKEY hGPOExtensions;

    hr = RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions"),
                0,
                KEY_WRITE | KEY_READ,
                &hGPOExtensions);
    if (S_OK == hr)
    {
        hr = RegDeleteKey(hGPOExtensions, TEXT("PublicKeyPolicy"));
        RegCloseKey(hGPOExtensions);
    }

    hr = CertPrxyDllUnregisterServer();
    hr2 = _Module.UnregisterServer();
    if (S_OK == hr)
    {
	hr = hr2;
    }
    return(hr);
}


// Register certcli.dll with the following command line to install templates:
//	regsvr32 /i:i /n certcli.dll

STDAPI
DllInstall(
    IN BOOL,	// bInstall
    IN LPCWSTR pszCmdLine)
{
    LPCWSTR wszCurrentCmd = pszCmdLine;

    // parse the cmd line

    while(wszCurrentCmd && *wszCurrentCmd)
    {
        while(*wszCurrentCmd == L' ')
            wszCurrentCmd++;
        if(*wszCurrentCmd == 0)
            break;

        switch(*wszCurrentCmd++)
        {
            case L'i':
            
                CCertTypeInfo::InstallDefaultTypes();
                return S_OK;
        }
    }
    return S_OK;
}


void __RPC_FAR *__RPC_USER
MIDL_user_allocate(
    IN size_t cb)
{
    return(CoTaskMemAlloc(cb));
}


void __RPC_USER
MIDL_user_free(
    IN void __RPC_FAR *pb)
{
    CoTaskMemFree(pb);
}


VOID
myFreeColumnDisplayNames()
{
    extern VOID myFreeColumnDisplayNames2();

    CACleanup();
    myFreeColumnDisplayNames2();
    myFreeResourceStrings("certcli.dll");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certcli\config.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        config.h
//
// Contents:    Declaration of CCertConfig
//
//---------------------------------------------------------------------------


#include "cscomres.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certcli


class ATL_NO_VTABLE CCertConfig: 
    public IDispatchImpl<ICertConfig2, &IID_ICertConfig2, &LIBID_CERTCLIENTLib>, 
    public ISupportErrorInfoImpl<&IID_ICertConfig2>,
    public CComObjectRoot,
    public CComCoClass<CCertConfig, &CLSID_CCertConfig>,
    public CCertConfigPrivate
{
public:
    CCertConfig() { }
    ~CCertConfig();

BEGIN_COM_MAP(CCertConfig)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertConfig)
    COM_INTERFACE_ENTRY(ICertConfig2)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertConfig) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertConfig,
    wszCLASS_CERTCONFIG TEXT(".1"),
    wszCLASS_CERTCONFIG,
    IDS_CERTCONFIG_DESC,
    THREADFLAGS_BOTH)

// ICertConfig
public:
    STDMETHOD(Reset)( 
            /* [in] */ LONG Index,
            /* [out, retval] */ LONG __RPC_FAR *pCount);

    STDMETHOD(Next)(
            /* [out, retval] */ LONG __RPC_FAR *pIndex);

    STDMETHOD(GetField)( 
            /* [in] */ BSTR const strFieldName,
            /* [out, retval] */ BSTR __RPC_FAR *pstrOut);

    STDMETHOD(GetConfig)( 
            /* [in] */ LONG Flags,
            /* [out, retval] */ BSTR __RPC_FAR *pstrOut);

// ICertConfig2
public:
    STDMETHOD(SetSharedFolder)( 
            /* [in] */ const BSTR strSharedFolder);

private:
    HRESULT _SetErrorInfo(
	    IN HRESULT hrError,
	    IN WCHAR const *pwszDescription);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certcli\crypt.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        crypt.cpp
//
// Contents:    Cert Server wrapper routines
//
// History:     17-Oct-96       vich created
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#define __dwFILE__	__dwFILE_CERTCLI_CRYPT_CPP__


HRESULT
myCryptStringToBinaryA(
    IN     LPCSTR    pszString,
    IN     DWORD     cchString,
    IN     DWORD     dwFlags,
    OUT    BYTE    **ppbBinary,
    OUT    DWORD    *pcbBinary,
    OUT    DWORD    *pdwSkip,    // OPTIONAL
    OUT    DWORD    *pdwFlags)   // OPTIONAL
{
    HRESULT hr;
    BYTE *pb = NULL;
    DWORD cb;

    while (TRUE)
    {
	if (!CryptStringToBinaryA(
			pszString,
			cchString,
			dwFlags,
			pb,
			&cb,
			pdwSkip,
			pdwFlags))
	{
	    hr = myHLastError();
	    _JumpError2(
		    hr,
		    error,
		    "CryptStringToBinaryA",
		    HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	}
	if (NULL != pb)
	{
	    break;	// done
	}
	pb = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
	if (NULL == pb)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    *pcbBinary = cb;
    *ppbBinary = pb;
    pb = NULL;
    hr = S_OK;

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


HRESULT
myCryptStringToBinary(
    IN     LPCWSTR   pwszString,
    IN     DWORD     cwcString,
    IN     DWORD     dwFlags,
    OUT    BYTE    **ppbBinary,
    OUT    DWORD    *pcbBinary,
    OUT    DWORD    *pdwSkip,    // OPTIONAL
    OUT    DWORD    *pdwFlags)   // OPTIONAL
{
    HRESULT hr;
    BYTE *pb = NULL;
    DWORD cb;

    while (TRUE)
    {
	if (!CryptStringToBinaryW(
			pwszString,
			cwcString,
			dwFlags,
			pb,
			&cb,
			pdwSkip,
			pdwFlags))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptStringToBinaryW");
	}
	if (NULL != pb)
	{
	    break;	// done
	}
	pb = (BYTE *) LocalAlloc(LMEM_FIXED, cb);
	if (NULL == pb)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    *pcbBinary = cb;
    *ppbBinary = pb;
    pb = NULL;
    hr = S_OK;

error:
    if (NULL != pb)
    {
	LocalFree(pb);
    }
    return(hr);
}


HRESULT
myCryptBinaryToStringA(
    IN     CONST BYTE  *pbBinary,
    IN     DWORD        cbBinary,
    IN     DWORD        dwFlags,
    OUT    LPSTR       *ppszString)
{
    HRESULT hr;
    char *psz = NULL;
    DWORD cch;

    while (TRUE)
    {
	if (!CryptBinaryToStringA(pbBinary, cbBinary, dwFlags, psz, &cch))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptBinaryToStringA");
	}
	if (NULL != psz)
	{
	    break;	// done
	}
	psz = (char *) LocalAlloc(LMEM_FIXED, cch * sizeof(char));
	if (NULL == psz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }
    *ppszString = psz;
    psz = NULL;
    hr = S_OK;

error:
    if (NULL != psz)
    {
	LocalFree(psz);
    }
    return(hr);
}


HRESULT
myCryptBinaryToString(
    IN     CONST BYTE  *pbBinary,
    IN     DWORD        cbBinary,
    IN     DWORD        dwFlags,
    OUT    LPWSTR      *ppwszString)
{
    HRESULT hr;
    WCHAR *pwsz = NULL;
    DWORD cwc;
    DWORD cwc0 =0;

    while (TRUE)
    {
	if (!CryptBinaryToStringW(pbBinary, cbBinary, dwFlags, pwsz, &cwc))
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CryptBinaryToStringW");
	}
	if (NULL != pwsz)
	{
	    break;	// done
	}
        cwc0 = cwc;
	pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
	if (NULL == pwsz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }

    CSASSERT(cwc0 == cwc + 1);
    CSASSERT(L'\0' == pwsz[cwc]);

    *ppwszString = pwsz;
    pwsz = NULL;
    hr = S_OK;

error:
    if (NULL != pwsz)
    {
	LocalFree(pwsz);
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certcli\config.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        config.cpp
//
// Contents:    Cert Server client implementation
//
// History:     24-Aug-96       vich created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "csdisp.h"
#include "configp.h"
#include "config.h"

#include <limits.h>


//+--------------------------------------------------------------------------
// CCertConfig::~CCertConfig -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertConfig::~CCertConfig()
{
}


//+--------------------------------------------------------------------------
// CCertConfig::Reset -- load config data, reset to indexed entry, return count
//
// Load the configuration data if not already loaded.  To reload the data after
// the data have changed, CCertConfig must be released and reinstantiated.
//
// Resets the current config entry to the Certification Authority configuration
// listed in the configuration file, indexed by the Index parameter.  0 indexes
// the first configuration.
//
// Upon successful completion, *pCount will be set to the number of Certificate
// Authority configurations listed in the configuration file.
//
// Returns S_FALSE if no entries are available at or after the passed Index.
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertConfig::Reset(
    /* [in] */ LONG Index,
    /* [retval][out] */ LONG __RPC_FAR *pCount)
{
    HRESULT hr;
    
    hr = CCertConfigPrivate::Reset(Index, pCount);
    return(_SetErrorInfo(hr, L"CCertConfig::Reset"));
}


//+--------------------------------------------------------------------------
// CCertConfig::Next -- skip to next config entry
//
// Changes the current config entry to the next Certification Authority
// configuration listed in the configuration file.
//
// Upon successful completion, *pIndex will be set to the index of Certificate
// Authority configurations listed in the configuration file.
//
// Returns S_FALSE if no more entries are available.  *pIndex is set to -1.
// Returns S_OK on success.  *pIndex is set to index the current configuration.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertConfig::Next(
    /* [retval][out] */ LONG __RPC_FAR *pIndex)
{
    HRESULT hr;
    
    hr = CCertConfigPrivate::Next(pIndex);
    return(_SetErrorInfo(hr, L"CCertConfig::Next"));
}


//+--------------------------------------------------------------------------
// CCertConfig::GetField -- return a field from the current config entry.
//
// pstrOut points to a BSTR string filled in by this routine.  If *pstrOut is
// non-NULL and this method is successful, the old string is freed.  If any
// value other than S_OK is returned, the string pointer will not be modified.
//
// Upon successful completion, *pstrOut will point to a string that contains
// the requested field from the current config entry.
//
// When the caller no longer needs the string, it must be freed by calling
// SysFreeString().
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertConfig::GetField(
    /* [in] */ BSTR const strFieldName,
    /* [retval][out] */ BSTR __RPC_FAR *pstrOut)
{
    HRESULT hr;
    
    hr = CCertConfigPrivate::GetField(strFieldName, pstrOut);
    return(_SetErrorInfo(hr, L"CCertConfig::GetField"));
}


//+--------------------------------------------------------------------------
// CCertConfig::GetConfig -- select a certificate issuer, return config data.
//
// pstrOut points to a BSTR string filled in by this routine.  If *pstrOut is
// non-NULL and this method is successful, the old string is freed.  If any
// value other than S_OK is returned, the string pointer will not be modified.
//
// Flags must be set to 0.
//
// Upon successful completion, *pstrOut will point to a string that contains
// the server name and Certification Authority name.
//
// When the caller no longer needs the string, it must be freed by calling
// SysFreeString().
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertConfig::GetConfig(
    /* [in] */ LONG Flags,
    /* [retval][out] */ BSTR __RPC_FAR *pstrOut)
{
    HRESULT hr;
    
    hr = CCertConfigPrivate::GetConfig(Flags, pstrOut);
    return(_SetErrorInfo(hr, L"CCertConfig::GetConfig"));
}


//+--------------------------------------------------------------------------
// CCertConfig::SetSharedFolder -- set the shared folder
//
// strSharedFolder is the new shared folder directory path.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertConfig::SetSharedFolder( 
    /* [in] */ const BSTR strSharedFolder)
{
    HRESULT hr;
    
    hr = CCertConfigPrivate::SetSharedFolder(strSharedFolder);
    return(_SetErrorInfo(hr, L"CCertConfig::SetSharedFolder"));
}


HRESULT
CCertConfig::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTCONFIG,
			    &IID_ICertConfig);
	CSASSERT(hr == hrError);
    }
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certcli\configp.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        configp.h
//
// Contents:    Declaration of CCertConfigPrivate
//
//---------------------------------------------------------------------------


#include <cryptui.h>
#include "cscomres.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certcli


typedef struct _CERT_AUTHORITY_INFO
{
    WCHAR *pwszSanitizedName;
    WCHAR *pwszSanitizedShortName;
    WCHAR *pwszSanitizedOrgUnit;
    WCHAR *pwszSanitizedOrganization;
    WCHAR *pwszSanitizedLocality;
    WCHAR *pwszSanitizedState;
    WCHAR *pwszSanitizedCountry;
    WCHAR *pwszSanitizedConfig;
    WCHAR *pwszSanitizedExchangeCertificate;
    WCHAR *pwszSanitizedSignatureCertificate;
    WCHAR *pwszSanitizedDescription;
    DWORD  Flags;
} CERT_AUTHORITY_INFO;

typedef CRYPTUI_CA_CONTEXT const * (WINAPI FNCRYPTUIDLGSELECTCA)(
    IN CRYPTUI_SELECT_CA_STRUCT const *pCryptUISelectCA);

typedef BOOL (WINAPI FNCRYPTUIDLGFREECACONTEXT)(
    IN CRYPTUI_CA_CONTEXT const *pCAContext);

class CCertConfigPrivate
{
public:
    CCertConfigPrivate()
    {
        m_pCertAuthorityInfo = NULL;
        m_fUseDS = TRUE;
	m_pwszSharedFolder = NULL;
	m_hModuleCryptUI = NULL;
    }
    ~CCertConfigPrivate();

// ICertConfig
public:
    HRESULT Reset( 
            /* [in] */ LONG Index,
            /* [retval][out] */ LONG __RPC_FAR *pCount);

    HRESULT Next(
            /* [retval][out] */ LONG __RPC_FAR *pIndex);

    HRESULT GetField( 
            /* [in] */ BSTR const strFieldName,
            /* [retval][out] */ BSTR __RPC_FAR *pstrOut);

    HRESULT GetConfig( 
            /* [in] */ LONG Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pstrOut);

// ICertConfig2
public:
    HRESULT SetSharedFolder( 
            /* [in] */ const BSTR strSharedFolder);

// myGetConfigFromPicker
public:
    HRESULT GetConfigFromPicker(
	    OPTIONAL IN HWND               hwndParent,
	    OPTIONAL IN WCHAR const       *pwszPrompt,
	    OPTIONAL IN WCHAR const       *pwszTitle,
	    OPTIONAL IN WCHAR const       *pwszSharedFolder,
	    IN BOOL                        fUseDS,
	    IN BOOL                        fSkipLocalCA,
	    IN BOOL                        fCountOnly,
	    OUT DWORD                     *pdwCount,
	    OUT CRYPTUI_CA_CONTEXT const **ppCAContext);

private:
    HRESULT _ResizeCAInfo(
	    IN LONG Count);

    HRESULT _LoadTable(VOID);

    CRYPTUI_CA_CONTEXT const *_CryptUIDlgSelectCA(
	    IN CRYPTUI_SELECT_CA_STRUCT const *pCryptUISelectCA);

    BOOL _CryptUIDlgFreeCAContext(
	    IN CRYPTUI_CA_CONTEXT const *pCAContext);

    HRESULT _AddRegistryConfigEntry(
	    IN WCHAR const *pwszMachine,
	    IN WCHAR const *pwszMachineOld,
	    IN WCHAR const *pwszSanitizedCAName,
	    IN BOOL fParentCA,
	    OPTIONAL IN CERT_CONTEXT const *pccCAChild,
	    OPTIONAL OUT CERT_CONTEXT const **ppccCAOut); // NULL == local CA

    CERT_AUTHORITY_INFO *m_pCertAuthorityInfo;
    LONG m_Index;
    LONG m_Count;
    BOOL m_fUseDS;
    WCHAR *m_pwszSharedFolder;

    HMODULE m_hModuleCryptUI;
    FNCRYPTUIDLGSELECTCA *m_pfnCryptUIDlgSelectCA;
    FNCRYPTUIDLGFREECACONTEXT *m_pfnCryptUIDlgFreeCAContext;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certcli\getconf.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        config.cpp
//
// Contents:    Cert Server client implementation
//
// History:     24-Aug-96       vich created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "csdisp.h"
#include "configp.h"
#include "getconf.h"

//+--------------------------------------------------------------------------
// CCertGetConfig::~CCertGetConfig -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertGetConfig::~CCertGetConfig()
{
}


//+--------------------------------------------------------------------------
// CCertGetConfig::GetConfig -- select a certificate issuer, return config data.
//
// pstrOut points to a BSTR string filled in by this routine.  If *pstrOut is
// non-NULL and this method is successful, the old string is freed.  If any
// value other than S_OK is returned, the string pointer will not be modified.
//
// Flags must be set to 0.
//
// Upon successful completion, *pstrOut will point to a string that contains
// the server name and Certification Authority name.
//
// When the caller no longer needs the string, it must be freed by calling
// SysFreeString().
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertGetConfig::GetConfig(
    /* [in] */ LONG Flags,
    /* [retval][out] */ BSTR __RPC_FAR *pstrOut)
{
    HRESULT hr;
    
    hr = CCertConfigPrivate::GetConfig(Flags, pstrOut);
    return(_SetErrorInfo(hr, L"CCertGetConfig::GetConfig"));
}


HRESULT
CCertGetConfig::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTGETCONFIG,
			    &IID_ICertGetConfig);
	CSASSERT(hr == hrError);
    }
    return(hrError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certcli\getconf.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        getconf.h
//
// Contents:    Declaration of CCertGetConfig
//
//---------------------------------------------------------------------------


#include "clibres.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certcli


class CCertGetConfig: 
    public IDispatchImpl<ICertGetConfig, &IID_ICertGetConfig, &LIBID_CERTCLIENTLib>, 
    public ISupportErrorInfoImpl<&IID_ICertGetConfig>,
    public CComObjectRoot,
    public CComCoClass<CCertGetConfig, &CLSID_CCertGetConfig>,
    public CCertConfigPrivate
{
public:
    CCertGetConfig() { }
    ~CCertGetConfig();

BEGIN_COM_MAP(CCertGetConfig)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertGetConfig)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertGetConfig) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertGetConfig,
    wszCLASS_CERTGETCONFIG TEXT(".1"),
    wszCLASS_CERTGETCONFIG,
    IDS_CERTGETCONFIG_DESC,
    THREADFLAGS_BOTH)

// ICertGetConfig
public:
    STDMETHOD(GetConfig)( 
            /* [in] */ LONG Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pstrOut);
private:
    HRESULT _SetErrorInfo(
	    IN HRESULT hrError,
	    IN WCHAR const *pwszDescription);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certcli\configp.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        config.cpp
//
// Contents:    Cert Server client implementation
//
// History:     24-Aug-96       vich created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include "csdisp.h"
#include "certca.h"
#include "configp.h"
#include <assert.h>

#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmwksta.h>

#include <limits.h>

#define __dwFILE__	__dwFILE_CERTCLI_CONFIGP_CPP__


WCHAR g_wszConfigFile[] = L"\\certsrv.txt";

WCHAR const g_wszRegDirectory[] = wszREGDIRECTORY;

extern "C"
{
HWND GetDeskTopWindow(VOID);
}

HRESULT
certRequestGetConfigInfo(
    IN WCHAR *pwszSharedFolder,
    IN OUT LONG *pIndex,
    IN OUT LONG *pCount,
    OUT CERT_AUTHORITY_INFO **ppCertAuthorityInfo);

VOID
_CleanupCAInfo(
    IN OUT CERT_AUTHORITY_INFO *pCA)
{
    if (NULL != pCA->pwszSanitizedName)
    {
	LocalFree(pCA->pwszSanitizedName);
    }
    if (NULL != pCA->pwszSanitizedShortName)
    {
	LocalFree(pCA->pwszSanitizedShortName);
    }
    if (NULL != pCA->pwszSanitizedOrgUnit)
    {
	LocalFree(pCA->pwszSanitizedOrgUnit);
    }
    if (NULL != pCA->pwszSanitizedOrganization)
    {
	LocalFree(pCA->pwszSanitizedOrganization);
    }
    if (NULL != pCA->pwszSanitizedLocality)
    {
	LocalFree(pCA->pwszSanitizedLocality);
    }
    if (NULL != pCA->pwszSanitizedState)
    {
	LocalFree(pCA->pwszSanitizedState);
    }
    if (NULL != pCA->pwszSanitizedCountry)
    {
	LocalFree(pCA->pwszSanitizedCountry);
    }
    if (NULL != pCA->pwszSanitizedConfig)
    {
	LocalFree(pCA->pwszSanitizedConfig);
    }
    if (NULL != pCA->pwszSanitizedExchangeCertificate)
    {
	LocalFree(pCA->pwszSanitizedExchangeCertificate);
    }
    if (NULL != pCA->pwszSanitizedSignatureCertificate)
    {
	LocalFree(pCA->pwszSanitizedSignatureCertificate);
    }
    if (NULL != pCA->pwszSanitizedDescription)
    {
	LocalFree(pCA->pwszSanitizedDescription);
    }
    ZeroMemory(pCA, sizeof(*pCA));
}


//+--------------------------------------------------------------------------
// CCertConfigPrivate::~CCertConfigPrivate -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertConfigPrivate::~CCertConfigPrivate()
{
    LONG i;

    if (NULL != m_pCertAuthorityInfo)
    {
        if (0 != m_Count)
        {
            for (i = 0; i < m_Count; ++i)
            {
		_CleanupCAInfo(&m_pCertAuthorityInfo[i]);
            }
        }
        LocalFree(m_pCertAuthorityInfo);
    }
    if (NULL != m_pwszSharedFolder)
    {
	LocalFree(m_pwszSharedFolder);
    }
    if (NULL != m_hModuleCryptUI)
    {
	FreeLibrary(m_hModuleCryptUI);
    }
}


//+--------------------------------------------------------------------------
// CCertConfigPrivate::_CryptUIDlgSelectCA
//
//+--------------------------------------------------------------------------

CRYPTUI_CA_CONTEXT const *
CCertConfigPrivate::_CryptUIDlgSelectCA(
    IN CRYPTUI_SELECT_CA_STRUCT const *pCryptUISelectCA)
{
    HRESULT hr;
    HMODULE hModule = NULL;
    CRYPTUI_CA_CONTEXT const *pCAContext = NULL;

    if (NULL == m_hModuleCryptUI)
    {
	hModule = LoadLibrary(TEXT("cryptui.dll"));
	if (NULL == hModule)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "LoadLibrary(cryptui.dll)");
	}
	m_pfnCryptUIDlgSelectCA = (FNCRYPTUIDLGSELECTCA *)
						GetProcAddress(
						    hModule,
						    "CryptUIDlgSelectCA");
	if (NULL == m_pfnCryptUIDlgSelectCA)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "GetProcAddress(CryptUIDlgSelectCA)");
	}
	m_pfnCryptUIDlgFreeCAContext = (FNCRYPTUIDLGFREECACONTEXT *)
						GetProcAddress(
						    hModule,
						    "CryptUIDlgFreeCAContext");
	if (NULL == m_pfnCryptUIDlgFreeCAContext)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "GetProcAddress(CryptUIDlgFreeCAContext)");
	}
	m_hModuleCryptUI = hModule;
	hModule = NULL;
    }
    CSASSERT(NULL != m_pfnCryptUIDlgSelectCA);
    CSASSERT(NULL != m_pfnCryptUIDlgFreeCAContext);
    pCAContext = (*m_pfnCryptUIDlgSelectCA)(pCryptUISelectCA);
    if (NULL == pCAContext)
    {
	hr = myHLastError();
	_JumpError(hr, error, "m_pfnCryptUIDlgSelectCA");
    }
    hr = S_OK;

error:
    if (NULL != hModule)
    {
	FreeLibrary(hModule);
    }
    if (NULL == pCAContext)
    {
	SetLastError(hr);
    }
    return(pCAContext);
}


//+--------------------------------------------------------------------------
// CCertConfigPrivate::_CryptUIDlgFreeCAContext
//
//+--------------------------------------------------------------------------

BOOL
CCertConfigPrivate::_CryptUIDlgFreeCAContext(
    IN CRYPTUI_CA_CONTEXT const *pCAContext)
{
    BOOL b = FALSE;
    
    if (NULL != m_hModuleCryptUI && NULL != m_pfnCryptUIDlgFreeCAContext)
    {
	b = (*m_pfnCryptUIDlgFreeCAContext)(pCAContext);
    }
    return(b);
}


HRESULT
fillEmptyField(
    WCHAR **ppwszField)
{
    HRESULT hr;

    *ppwszField = (WCHAR *) LocalAlloc(LMEM_FIXED, sizeof(WCHAR));
    if (NULL == *ppwszField)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    *ppwszField[0] = L'\0';

    hr = S_OK;
error:
    return(hr);
}


VOID
dsFreeCAConfig(
    LONG                 cCA,
    CERT_AUTHORITY_INFO *pCA)
{
    LONG i;

    if (NULL != pCA && 0 < cCA)
    {
        for (i = 0; i < cCA; ++i)
        {
            if (NULL != pCA[i].pwszSanitizedName)
            {
                LocalFree(pCA[i].pwszSanitizedName);
            }
            if (NULL != pCA[i].pwszSanitizedShortName)
            {
                LocalFree(pCA[i].pwszSanitizedShortName);
            }
            if (NULL != pCA[i].pwszSanitizedConfig)
            {
                LocalFree(pCA[i].pwszSanitizedConfig);
            }
            if (NULL != pCA[i].pwszSanitizedOrganization)
            {
                LocalFree(pCA[i].pwszSanitizedOrganization);
            }
            if (NULL != pCA[i].pwszSanitizedOrgUnit)
            {
                LocalFree(pCA[i].pwszSanitizedOrgUnit);
            }
            if (NULL != pCA[i].pwszSanitizedLocality)
            {
                LocalFree(pCA[i].pwszSanitizedLocality);
            }
            if (NULL != pCA[i].pwszSanitizedState)
            {
                LocalFree(pCA[i].pwszSanitizedState);
            }
            if (NULL != pCA[i].pwszSanitizedCountry)
            {
                LocalFree(pCA[i].pwszSanitizedCountry);
            }
        }
        LocalFree(pCA);
    }
}


HRESULT
ConfigGetCertNameDNInfo(
    IN CERT_NAME_INFO const *pCertNameInfo,
    IN CHAR const *pszObjId,
    IN OUT WCHAR **ppwszDNInfo)
{
    HRESULT hr;
    WCHAR const *pwszProperty = NULL;

    if (NULL != *ppwszDNInfo && L'\0' != **ppwszDNInfo)
    {
	hr = S_OK;
	goto error;
    }
    hr = myGetCertNameProperty(FALSE, pCertNameInfo, pszObjId, &pwszProperty);
    if (CERTSRV_E_PROPERTY_EMPTY == hr)
    {
	hr = S_OK;
	goto error;
    }
    _JumpIfError(hr, error, "myGetCertNameProperty");

    if (NULL != pwszProperty)
    {
	WCHAR *pwsz;
	
	hr = myDupString(pwszProperty, &pwsz);
	_JumpIfError(hr, error, "myDupString");

	if (NULL != *ppwszDNInfo)
	{
	    LocalFree(*ppwszDNInfo);
	}
	*ppwszDNInfo = pwsz;
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
ConfigLoadDNInfo(
    IN BYTE const *pbEncoded,
    IN DWORD cbEncoded,
    IN OUT CERT_AUTHORITY_INFO *pCA)
{
    HRESULT hr;
    CERT_NAME_INFO *pCertNameInfo = NULL;
    DWORD cbCertNameInfo;

    // decode to name info
    if (!myDecodeName(
	    X509_ASN_ENCODING,
	    X509_UNICODE_NAME,
	    pbEncoded,
	    cbEncoded,
	    CERTLIB_USE_LOCALALLOC,
	    &pCertNameInfo,
	    &cbCertNameInfo))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myDecodeName");
    }

    hr = ConfigGetCertNameDNInfo(
	     pCertNameInfo,
	     szOID_ORGANIZATION_NAME,
	     &pCA->pwszSanitizedOrganization);
    _JumpIfError(hr, error, "ConfigGetCertNameDNInfo");

    hr = ConfigGetCertNameDNInfo(
	     pCertNameInfo,
	     szOID_ORGANIZATIONAL_UNIT_NAME,
	     &pCA->pwszSanitizedOrgUnit);
    _JumpIfError(hr, error, "ConfigGetCertNameDNInfo");

    hr = ConfigGetCertNameDNInfo(
	     pCertNameInfo,
	     szOID_LOCALITY_NAME,
	     &pCA->pwszSanitizedLocality);
    _JumpIfError(hr, error, "ConfigGetCertNameDNInfo");

    hr = ConfigGetCertNameDNInfo(
	     pCertNameInfo,
	     szOID_STATE_OR_PROVINCE_NAME,
	     &pCA->pwszSanitizedState);
    _JumpIfError(hr, error, "ConfigGetCertNameDNInfo");

    hr = ConfigGetCertNameDNInfo(
	     pCertNameInfo,
	     szOID_COUNTRY_NAME,
	     &pCA->pwszSanitizedCountry);
    _JumpIfError(hr, error, "ConfigGetCertNameDNInfo");

error:
    if (NULL != pCertNameInfo)
    {
        LocalFree(pCertNameInfo);
    }
    return(hr);
}


HRESULT
dsGetCAConfig(
    OUT CERT_AUTHORITY_INFO **ppCAConfig,
    OUT LONG                 *pcCAConfig)
{
    HRESULT  hr;
    HCAINFO  hCACurrent = NULL;
    HCAINFO  hCANext = NULL;
    WCHAR    **ppwszCommonName = NULL;
    WCHAR    **ppwszSanitizedShortName = NULL;
    WCHAR    **ppwszDescription = NULL;
    WCHAR    **ppwszMachine = NULL;
    WCHAR    **ppwszDN = NULL;
    LONG     cCA;
    LONG     iDst;
    LONG     iSrc;
    CERT_AUTHORITY_INFO *pCA = NULL;
    BYTE           *pbEncoded = NULL;
    DWORD           cbEncoded;

    *ppCAConfig = NULL;
    *pcCAConfig = 0;

    cCA = 0;

    hr = CAEnumFirstCA(
		NULL,
		CA_FIND_INCLUDE_UNTRUSTED | CA_FIND_INCLUDE_NON_TEMPLATE_CA,
		&hCACurrent);
    if (HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE) != hr)
    {
	_PrintIfErrorStr4(
		    hr,
		    "CAEnumFirstCA",
		    L"Ignored!",
		    HRESULT_FROM_WIN32(ERROR_SERVER_DISABLED),
		    HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN),
		    HRESULT_FROM_WIN32(ERROR_WRONG_PASSWORD));
    }

    cCA = CACountCAs(hCACurrent);  // 0 on error
    if (0 < cCA)
    {
        pCA = (CERT_AUTHORITY_INFO *) LocalAlloc(
                               LMEM_FIXED | LMEM_ZEROINIT,
			       cCA * sizeof(CERT_AUTHORITY_INFO));
        if (NULL == pCA)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        for (iDst = 0, iSrc = 0; iSrc < cCA; iSrc++)
        {
            CSASSERT(NULL == ppwszCommonName);
            CSASSERT(NULL == ppwszSanitizedShortName);
            CSASSERT(NULL == ppwszDescription);
            CSASSERT(NULL == ppwszMachine);
            CSASSERT(NULL == ppwszDN);
            CSASSERT(NULL == pCA[iDst].pwszSanitizedName);
            CSASSERT(NULL == pCA[iDst].pwszSanitizedShortName);
            CSASSERT(NULL == pCA[iDst].pwszSanitizedConfig);

            hr = CAGetCAProperty(
			    hCACurrent,
			    CA_PROP_DISPLAY_NAME,
			    &ppwszCommonName);
	    _JumpIfError(hr, error, "CAGetCAProperty(CA_PROP_DISPLAY_NAME)");

            hr = CAGetCAProperty(hCACurrent, CA_PROP_NAME, &ppwszSanitizedShortName);
	    _JumpIfError(hr, error, "CAGetCAProperty(CA_PROP_NAME)");

            hr = CAGetCAProperty(hCACurrent, CA_PROP_DESCRIPTION, &ppwszDescription);
	    _JumpIfError(hr, error, "CAGetCAProperty(CA_PROP_DESCRIPTION)");

            hr = CAGetCAProperty(hCACurrent, CA_PROP_DNSNAME, &ppwszMachine);
	    _JumpIfError(hr, error, "CAGetCAProperty(CA_PROP_DNSNAME)");

            hr = CAGetCAProperty(hCACurrent, CA_PROP_CERT_DN, &ppwszDN);
	    _JumpIfError(hr, error, "CAGetCAProperty(CA_PROP_CERT_DN)");

	    if (NULL == ppwszCommonName ||
		NULL == ppwszSanitizedShortName ||
		NULL == ppwszMachine ||
		NULL == ppwszDN)
            {
                _PrintError(E_INVALIDARG, "missing CA property");
                goto skipca; // skip and don't take the CA
            }

	    hr = mySanitizeName(*ppwszCommonName, &pCA[iDst].pwszSanitizedName);
	    _JumpIfError(hr, error, "mySanitizeName");

	    // already sanitized:

	    hr = myDupString(*ppwszSanitizedShortName, &pCA[iDst].pwszSanitizedShortName);
	    _JumpIfError(hr, error, "myDupString");

	    if (NULL != ppwszDescription)
	    {
		hr = myDupString(*ppwszDescription, &pCA[iDst].pwszSanitizedDescription);
		_JumpIfError(hr, error, "myDupString");
	    }

            pCA[iDst].pwszSanitizedConfig = (WCHAR *) LocalAlloc(
		    LMEM_FIXED,
		    (wcslen(*ppwszMachine) + wcslen(pCA[iDst].pwszSanitizedName) + 2) *
			sizeof(WCHAR));
            if (NULL == pCA[iDst].pwszSanitizedConfig)
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "LocalAlloc(pwszSanitizedConfig)");
            }
            wcscpy(pCA[iDst].pwszSanitizedConfig, *ppwszMachine);
            wcscat(pCA[iDst].pwszSanitizedConfig, L"\\");
            wcscat(pCA[iDst].pwszSanitizedConfig, pCA[iDst].pwszSanitizedName);

            pbEncoded = NULL;
            while (TRUE)
            {
                // convert dn string to name blob
                if (!CertStrToName(
                         X509_ASN_ENCODING,
                         *ppwszDN,
                         CERT_X500_NAME_STR,
                         NULL,
                         pbEncoded,
                         &cbEncoded,
                         NULL))
                {
                    hr = myHLastError();
                    _JumpIfError(hr, error, "CertStrToName");
                }
                if (NULL != pbEncoded)
                {
                    // get name
                    break;
                }
                pbEncoded = (BYTE*)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                       cbEncoded);
		if (NULL == pbEncoded)
		{
		    hr = E_OUTOFMEMORY;
		    _JumpError(hr, error, "LocalAlloc");
		}
            }

	    hr = ConfigLoadDNInfo(pbEncoded, cbEncoded, &pCA[iDst]);
            _JumpIfError(hr, error, "ConfigLoadDNInfo");

            // fill empty for the rest
            CSASSERT(NULL == pCA[iDst].pwszSanitizedExchangeCertificate);
            CSASSERT(NULL == pCA[iDst].pwszSanitizedSignatureCertificate);
            pCA[iDst].Flags = CAIF_DSENTRY;
            ++iDst;

            // free dn blobs
            if (NULL != pbEncoded)
            {
                LocalFree(pbEncoded);
                pbEncoded = NULL;
            }
skipca:
            // free ds out properties

	    if (NULL != ppwszCommonName)
	    {
		CAFreeCAProperty(hCACurrent, ppwszCommonName);
		ppwszCommonName = NULL;
	    }
	    if (NULL != ppwszSanitizedShortName)
	    {
		CAFreeCAProperty(hCACurrent, ppwszSanitizedShortName);
		ppwszSanitizedShortName = NULL;
	    }
	    if (NULL != ppwszDescription)
	    {
		CAFreeCAProperty(hCACurrent, ppwszDescription);
		ppwszDescription = NULL;
	    }
	    if (NULL != ppwszMachine)
	    {
		CAFreeCAProperty(hCACurrent, ppwszMachine);
		ppwszMachine = NULL;
	    }
	    if (NULL != ppwszDN)
	    {
		CAFreeCAProperty(hCACurrent, ppwszDN);
		ppwszDN = NULL;
	    }

            hr = CAEnumNextCA(hCACurrent, &hCANext);
            CACloseCA(hCACurrent);
            hCACurrent = hCANext;
	    if (S_OK != hr || NULL == hCACurrent)
	    {
		break;
	    }
        }
        *pcCAConfig = iDst;
        *ppCAConfig = pCA;
        pCA = NULL;
    }
    hr = S_OK;

error:
    if (NULL != hCACurrent)
    {
        CACloseCA(hCACurrent);
    }
    if (NULL != pbEncoded)
    {
        LocalFree(pbEncoded);
    }
    if (NULL != ppwszCommonName)
    {
        CAFreeCAProperty(hCACurrent, ppwszCommonName);
    }
    if (NULL != ppwszSanitizedShortName)
    {
        CAFreeCAProperty(hCACurrent, ppwszSanitizedShortName);
    }
    if (NULL != ppwszMachine)
    {
        CAFreeCAProperty(hCACurrent, ppwszMachine);
    }
    if (NULL != ppwszDN)
    {
        CAFreeCAProperty(hCACurrent, ppwszDN);
    }
    if (NULL != pCA)
    {
        dsFreeCAConfig(cCA, pCA);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


BOOL
FindSharedCAInDSList(
    IN CERT_AUTHORITY_INFO       *pDSCA,
    IN LONG                       countDSCA,
    IN CERT_AUTHORITY_INFO const *pCAFromShared,
    OUT CERT_AUTHORITY_INFO     **ppDSCA)
{
    BOOL found = FALSE;
    LONG i;

    *ppDSCA = NULL;
    for (i = 0; i < countDSCA; ++i)
    {
        if (0 == mylstrcmpiL(pDSCA[i].pwszSanitizedConfig, pCAFromShared->pwszSanitizedConfig) &&
            0 == mylstrcmpiL(pDSCA[i].pwszSanitizedName, pCAFromShared->pwszSanitizedName))
        {
            *ppDSCA = &pDSCA[i];
	    found = TRUE;
            break;
        }
    }
    return(found);
}


HRESULT
updateField(
   IN WCHAR const *pwszSource,
   OUT WCHAR **ppwszDest)
{
    HRESULT hr;

    if (NULL != pwszSource &&
	(NULL == *ppwszDest || L'\0' == **ppwszDest))
    {
	if (NULL != *ppwszDest)
	{
	    LocalFree(*ppwszDest);
	}
	hr = myDupString(pwszSource, ppwszDest);
	_JumpIfError(hr, error, "myDupString");
    }
    hr = S_OK;

error:
    return(hr);
}


HRESULT
mergeConfigFields(
    IN CERT_AUTHORITY_INFO const *pCAIn,
    IN OUT CERT_AUTHORITY_INFO *pCA)
{
    HRESULT hr;

    if (NULL == pCAIn || NULL == pCA)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "Internal Error");
    }

    hr = updateField(pCAIn->pwszSanitizedName, &pCA->pwszSanitizedName);
    _JumpIfError(hr, error, "updateField(pwszSanitizedName)");

    hr = updateField(pCAIn->pwszSanitizedOrgUnit, &pCA->pwszSanitizedOrgUnit);
    _JumpIfError(hr, error, "updateField(pwszSanitizedOrgUnit)");

    hr = updateField(pCAIn->pwszSanitizedOrganization, &pCA->pwszSanitizedOrganization);
    _JumpIfError(hr, error, "updateField(pwszSanitizedOrganization)");

    hr = updateField(pCAIn->pwszSanitizedLocality, &pCA->pwszSanitizedLocality);
    _JumpIfError(hr, error, "updateField(pwszSanitizedLocality)");

    hr = updateField(pCAIn->pwszSanitizedState, &pCA->pwszSanitizedState);
    _JumpIfError(hr, error, "updateField(pwszSanitizedState)");

    hr = updateField(pCAIn->pwszSanitizedCountry, &pCA->pwszSanitizedCountry);
    _JumpIfError(hr, error, "updateField(pwszSanitizedCountry)");

    hr = updateField(pCAIn->pwszSanitizedConfig, &pCA->pwszSanitizedConfig);
    _JumpIfError(hr, error, "updateField(pwszSanitizedConfig)");

    hr = updateField(pCAIn->pwszSanitizedExchangeCertificate, &pCA->pwszSanitizedExchangeCertificate);
    _JumpIfError(hr, error, "updateField(pwszSanitizedExchangeCertificate)");

    hr = updateField(pCAIn->pwszSanitizedSignatureCertificate, &pCA->pwszSanitizedSignatureCertificate);
    _JumpIfError(hr, error, "updateField(pwszSanitizedSignatureCertificate)");

    hr = updateField(pCAIn->pwszSanitizedDescription, &pCA->pwszSanitizedDescription);
    _JumpIfError(hr, error, "updateField(pwszSanitizedDescription)");

    hr = mySanitizedNameToDSName(pCAIn->pwszSanitizedName, &pCA->pwszSanitizedShortName);
    _JumpIfError(hr, error, "mySanitizedNameToDSName");

    pCA->Flags |= pCAIn->Flags;

error:
    return(hr);
}


HRESULT
CCertConfigPrivate::_ResizeCAInfo(
    IN LONG Count)
{
   HRESULT hr = E_OUTOFMEMORY;
   
   if (NULL == m_pCertAuthorityInfo)
   {
	m_pCertAuthorityInfo = (CERT_AUTHORITY_INFO *) LocalAlloc(
					   LMEM_FIXED | LMEM_ZEROINIT,
					   Count * sizeof(CERT_AUTHORITY_INFO));
	if (NULL == m_pCertAuthorityInfo)
	{
	    _JumpError(hr, error, "LocalAlloc");
	}
   }
   else
   {
	CERT_AUTHORITY_INFO *pCAI;

	pCAI = (CERT_AUTHORITY_INFO *) LocalReAlloc(
					   m_pCertAuthorityInfo,
					   Count * sizeof(CERT_AUTHORITY_INFO),
					   LMEM_MOVEABLE);
	if (NULL == pCAI)
	{
	    _JumpError(hr, error, "LocalReAlloc");
	}
	m_pCertAuthorityInfo = pCAI;

	// LocalReAlloc won't zero memory when old size was already > m_Count

	if (Count > m_Count)
	{
	    ZeroMemory(
		&m_pCertAuthorityInfo[m_Count],
		(Count - m_Count) * sizeof(m_pCertAuthorityInfo[0]));
	}
   }
   hr = S_OK;

error:
    return(hr);
}


HRESULT
CCertConfigPrivate::_AddRegistryConfigEntry(
    IN WCHAR const *pwszDnsName,
    IN WCHAR const *pwszOldName,
    IN WCHAR const *pwszSanitizedCAName,
    IN BOOL fParentCA,
    OPTIONAL IN CERT_CONTEXT const *pccCAChild,
    OPTIONAL OUT CERT_CONTEXT const **ppccCAOut) // non-NULL means local CA
{
    HRESULT hr;
    HCERTSTORE hMyStore = NULL;
    LONG i;
    BOOL fFoundCA = FALSE;
    WCHAR *pwszDescription = NULL;
    WCHAR *pwszSanitizedShortName = NULL;
    CERT_CONTEXT const *pccCA = NULL;
    CERT_AUTHORITY_INFO *pCA = NULL;
    WCHAR *pwsz;
    WCHAR *pwszRegPath = NULL;
    HKEY hKey = NULL;

    if (NULL != ppccCAOut)
    {
	CSASSERT(NULL == pccCAChild);
	*ppccCAOut = NULL;
    }

    for (i = 0; i < m_Count; ++i)
    {
	BOOL fMachineNameMatch;
	
	hr = myIsConfigLocal2(
			m_pCertAuthorityInfo[i].pwszSanitizedConfig,
			pwszDnsName,
			pwszOldName,
			&fMachineNameMatch);
	_JumpIfError(hr, error, "myIsConfigLocal2");

	if (fMachineNameMatch)
	{
	    if (!fParentCA)	// Local CA
	    {
		m_pCertAuthorityInfo[i].Flags |= CAIF_LOCAL;
	    }

	    if (0 == mylstrcmpiL(
			pwszSanitizedCAName,
			m_pCertAuthorityInfo[i].pwszSanitizedName))
	    {
		fFoundCA = TRUE;

		pCA = &m_pCertAuthorityInfo[i];
		pCA->Flags |= CAIF_REGISTRY;
		if (fParentCA)
		{
		    pCA->Flags |= CAIF_REGISTRYPARENT;
		}
		break;
	    }
	}
    }
    if (!fFoundCA)
    {
	hr = _ResizeCAInfo(m_Count + 1);
	_JumpIfError(hr, error, "_ResizeCAInfo");

	pCA = &m_pCertAuthorityInfo[m_Count];

	hr = myFormConfigString(
			pwszDnsName,
			pwszSanitizedCAName,
			&pCA->pwszSanitizedConfig);
	_JumpIfError(hr, error, "myFormConfigString");

	hr = myDupString(pwszSanitizedCAName, &pCA->pwszSanitizedName);
	_JumpIfError(hr, error, "myDupString");

	hr = mySanitizedNameToDSName(
			pwszSanitizedCAName,
			&pCA->pwszSanitizedShortName);
	_JumpIfError(hr, error, "mySanitizedNameToDSName");

	pCA->Flags = CAIF_REGISTRY;
	if (fParentCA)
	{
	    pCA->Flags |= CAIF_REGISTRYPARENT;
	}
	else
	{
	    pCA->Flags |= CAIF_LOCAL;
	}

    }

    CSASSERT(NULL != pCA);	// either found or added

    if (NULL == pCA->pwszSanitizedDescription ||
	L'\0' == *pCA->pwszSanitizedDescription)
    {
	if (!fParentCA)	// Local CA
	{
	    hr = myGetCertRegStrValue(
			pCA->pwszSanitizedName,
			NULL,
			NULL,
			wszREGCADESCRIPTION,
			&pwszDescription);
	    _PrintIfErrorStr2(
			hr,
			"myGetCertRegStrValue",
			wszREGCADESCRIPTION,
			HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
	}
	else
	{
	    hr = myRegOpenRelativeKey(
			    pwszDnsName,
			    L"ca",
			    0,
			    &pwszRegPath,
			    NULL,
			    &hKey);
	    _PrintIfErrorStr(hr, "myGetCertRegStrValue", wszREGCADESCRIPTION);
	    if (S_OK == hr)
	    {
		DWORD cb;
		DWORD cwc;
		DWORD dwType;

		hr = RegQueryValueEx(
				hKey,
				wszREGCADESCRIPTION,
				NULL,
				&dwType,
				NULL,
				&cb);
		if (S_OK == hr && REG_SZ == dwType && sizeof(WCHAR) < cb)
		{
		    cwc = cb / sizeof(WCHAR);

		    pwszDescription = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					(cwc + 1) * sizeof(WCHAR));
		    if (NULL == pwszDescription)
		    {
			hr = E_OUTOFMEMORY;
			_JumpError(hr, error, "LocalAlloc");
		    }
		    hr = RegQueryValueEx(
				    hKey,
				    wszREGCADESCRIPTION,
				    NULL,
				    &dwType,
				    (BYTE *) pwszDescription,
				    &cb);
		    _JumpIfError(hr, error, "RegQueryValueEx");
		    pwszDescription[cwc] = L'\0';
		}
	    }
	}
	if (NULL != pwszDescription)
	{
	    hr = mySanitizeName(pwszDescription, &pwsz);
	    _JumpIfError(hr, error, "mySanitizeName");

	    if (NULL != pCA->pwszSanitizedDescription)
	    {
		LocalFree(pCA->pwszSanitizedDescription);
	    }
	    pCA->pwszSanitizedDescription = pwsz;
	}
    }
    if (fParentCA)
    {
	pccCA = pccCAChild;
    }
    else
    {
	DWORD ccert;

	CSASSERT(NULL == pccCAChild);

	hr = myGetCARegHashCount(
			    pCA->pwszSanitizedName,
			    CSRH_CASIGCERT,
			    &ccert);
	_PrintIfError(hr, "myGetCARegHashCount");
	if (S_OK == hr && 0 != ccert)
	{
	    DWORD NameId;
		
	    // open MY store

	    hMyStore = CertOpenStore(
			   CERT_STORE_PROV_SYSTEM_W,
			   X509_ASN_ENCODING,
			   NULL,			// hProv
			   CERT_SYSTEM_STORE_LOCAL_MACHINE |
			   CERT_STORE_READONLY_FLAG,
			   wszMY_CERTSTORE);
	    if (NULL == hMyStore)
	    {
		hr = myHLastError();
		_JumpError(hr, error, "CertOpenStore");
	    }

	    hr = myFindCACertByHashIndex(
				hMyStore,
				pCA->pwszSanitizedName,
				CSRH_CASIGCERT,
				ccert - 1,
				&NameId,
				&pccCA);
	}
    }
    if (NULL != pccCA)
    {
	CERT_NAME_BLOB *pName = !fParentCA? 
			&pccCA->pCertInfo->Subject :
			&pccCA->pCertInfo->Issuer;

	hr = ConfigLoadDNInfo(pName->pbData, pName->cbData, pCA);
	_PrintIfError(hr, "ConfigLoadDNInfo");
    }
    if (NULL == pCA->pwszSanitizedSignatureCertificate ||
	L'\0' == *pCA->pwszSanitizedSignatureCertificate)
    {
	DWORD cwc;

	// pwszDnsName + "_" + pwszSanitizedCAName + ".crt"

	cwc = wcslen(pwszDnsName) + 1 + wcslen(pwszSanitizedCAName) + 4;

	pwsz = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	if (NULL == pwsz)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	wcscpy(pwsz, pwszDnsName);
	wcscat(pwsz, L"_");
	wcscat(pwsz, pwszSanitizedCAName);
	wcscat(pwsz, L".crt");
	CSASSERT(wcslen(pwsz) == cwc);

	if (NULL != pCA->pwszSanitizedSignatureCertificate)
	{
	    LocalFree(pCA->pwszSanitizedSignatureCertificate);
	}
	pCA->pwszSanitizedSignatureCertificate = pwsz;
    }
    if (!fFoundCA)
    {
	m_Count++;
    }
    if (NULL != pccCA && NULL != ppccCAOut)
    {
	*ppccCAOut = CertDuplicateCertificateContext(pccCA);
    }
    DBGPRINT((
	DBG_SS_CERTLIBI,
	"%ws %ws CA entry: %ws\n",
	fFoundCA? L"Merged" : L"Added",
	fParentCA? L"Parent" : L"Local",
	pCA->pwszSanitizedConfig));
    pCA = NULL;
    hr = S_OK;

error:
    if (NULL != hKey)
    {
	RegCloseKey(hKey);
    }
    if (NULL != pwszRegPath)
    {
	LocalFree(pwszRegPath);
    }
    if (!fFoundCA && NULL != pCA)
    {
	_CleanupCAInfo(pCA);
    }
    if (NULL != pwszDescription)
    {
        LocalFree(pwszDescription);
    }
    if (NULL != pwszSanitizedShortName)
    {
        LocalFree(pwszSanitizedShortName);
    }
    if (NULL != pccCA && pccCAChild != pccCA)
    {
        CertFreeCertificateContext(pccCA);
    }
    if (NULL != hMyStore)
    {
        CertCloseStore(hMyStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertConfigPrivate::_LoadTable -- load config data into class instance
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertConfigPrivate::_LoadTable(VOID)
{
    HRESULT hr;
    LONG Index;
    LONG CountShared = 0;
    LONG i;
    LONG actualSharedCount;
    CERT_AUTHORITY_INFO *pCAFromShared = NULL;
    BOOL fDSCA = TRUE;
    WCHAR *pwszSanitizedCAName = NULL;
    WCHAR *pwszDnsName = NULL;
    WCHAR *pwszOldName = NULL;
    CERT_CONTEXT const *pccCA = NULL;
    WCHAR *pwszParentMachine = NULL;
    WCHAR *pwszParentMachineOld = NULL;
    WCHAR *pwszParentCAName = NULL;
    WCHAR *pwszParentSanitizedCAName = NULL;

    m_Index = -1;
    m_Count = 0;

    if (m_fUseDS)
    {
	hr = dsGetCAConfig(&m_pCertAuthorityInfo, &m_Count);
	_JumpIfError(hr, error, "dsGetCAConfig");
    }

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"%x DS entries @%x\n",
	m_Count,
	m_pCertAuthorityInfo));
    if (NULL == m_pCertAuthorityInfo && 0 == m_Count)
    {
        fDSCA = FALSE;
    }

    Index = 0;
    CountShared = INT_MAX;
    hr = certRequestGetConfigInfo(
			    m_pwszSharedFolder,
			    &Index,
			    &CountShared,
			    &pCAFromShared);
    // Don't fail if file not found or unc path is bad

    CSASSERT(S_OK == hr || FAILED(hr));
    _PrintIfError4(
		hr,
		"certRequestGetConfigInfo",
		HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND),
		HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE),
		HRESULT_FROM_WIN32(ERROR_INVALID_NETNAME));

    DBGPRINT((
	DBG_SS_CERTLIBI,
	"%x Shared Folder entries @%x\n",
	CountShared,
	pCAFromShared));

    actualSharedCount = 0;
    if (0 < CountShared)
    {
	hr = _ResizeCAInfo(m_Count + CountShared);
	_JumpIfError(hr, error, "_ResizeCAInfo");

	DBGPRINT((
	    DBG_SS_CERTLIBI,
	    "%x %ws @%x\n",
	    m_Count + CountShared,
	    fDSCA? L"Total entries" : L"new Shared Folder entries",
	    m_pCertAuthorityInfo));

        for (i = 0; i < CountShared; ++i)
        {
	    CERT_AUTHORITY_INFO *pCAInDS = NULL;
	    CERT_AUTHORITY_INFO *pCAUpdate;
	    
	    if (fDSCA)
	    {
		FindSharedCAInDSList(
				m_pCertAuthorityInfo,
				m_Count,
				&pCAFromShared[i],
				&pCAInDS);
            }

	    if (NULL != pCAInDS)
	    {
		pCAUpdate = pCAInDS;
	    }
	    else
	    {
		pCAUpdate = &m_pCertAuthorityInfo[m_Count + actualSharedCount];
		ZeroMemory(pCAUpdate, sizeof(*pCAUpdate));
	    }

	    hr = mergeConfigFields(&pCAFromShared[i], pCAUpdate);
	    _JumpIfError(hr, error, "mergeConfigFields");

	    DBGPRINT((
		DBG_SS_CERTLIBI,
		"%hs CA entry: %ws\n",
		NULL != pCAInDS? "Merged" : "Added",
		pCAUpdate->pwszSanitizedConfig));

	    if (NULL == pCAInDS)
	    {
                ++actualSharedCount;
	    }
        }
    }
    m_Count += actualSharedCount;

    // Add local CA to the table.  Merge entry if it already exists.
    // Also flags all local CAs.

    hr = myGetCertRegStrValue(
			NULL,
			NULL,
			NULL,
			wszREGACTIVE,
			&pwszSanitizedCAName);
    _PrintIfErrorStr(hr, "myGetCertRegStrValue", wszREGACTIVE);

    if (S_OK == hr)
    {
	hr = myGetComputerNames(&pwszDnsName, &pwszOldName);
	_JumpIfError(hr, error, "myGetComputerNames");

	hr = _AddRegistryConfigEntry(
			pwszDnsName,
			pwszOldName,
			pwszSanitizedCAName,
			FALSE,		// fParentCA
			NULL,
			&pccCA);
	_JumpIfError(hr, error, "_AddRegistryConfigEntry");

	// Add parent CA to the table.  Merge entry if it already exists.

	hr = myGetCertRegStrValue(
		    pwszSanitizedCAName,
		    NULL,
		    NULL,
		    wszREGPARENTCANAME,
		    &pwszParentCAName);
	_PrintIfErrorStr2(
		    hr,
		    "myGetCertRegStrValue",
		    wszREGPARENTCANAME,
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
	if (S_OK == hr)
	{
	    hr = myGetCertRegStrValue(
			pwszSanitizedCAName,
			NULL,
			NULL,
			wszREGPARENTCAMACHINE,
			&pwszParentMachine);
	    _PrintIfErrorStr(hr, "myGetCertRegStrValue", wszREGPARENTCAMACHINE);
	}

	if (NULL != pwszParentMachine && NULL != pwszParentCAName)
	{
	    WCHAR *pwsz;
	    
	    hr = mySanitizeName(pwszParentCAName, &pwszParentSanitizedCAName);
	    _JumpIfError(hr, error, "mySanitizeName");

	    hr = myDupString(pwszParentMachine, &pwszParentMachineOld);
	    _JumpIfError(hr, error, "myDupString");

	    pwsz = wcschr(pwszParentMachineOld, L'.');
	    if (NULL != pwsz)
	    {
		*pwsz = L'\0';
	    }
	    hr = _AddRegistryConfigEntry(
			    pwszParentMachine,
			    pwszParentMachineOld,
			    pwszParentSanitizedCAName,
			    TRUE,		// fParentCA
			    pccCA,
			    NULL);
	    _JumpIfError(hr, error, "_AddRegistryConfigEntry");
	}
    }
    hr = S_OK;

error:
    if (NULL != pwszDnsName)
    {
        LocalFree(pwszDnsName);
    }
    if (NULL != pwszOldName)
    {
        LocalFree(pwszOldName);
    }
    if (NULL != pwszSanitizedCAName)
    {
        LocalFree(pwszSanitizedCAName);
    }
    if (NULL != pwszParentCAName)
    {
	LocalFree(pwszParentCAName);
    }
    if (NULL != pwszParentMachine)
    {
	LocalFree(pwszParentMachine);
    }
    if (NULL != pwszParentMachineOld)
    {
	LocalFree(pwszParentMachineOld);
    }
    if (NULL != pwszParentSanitizedCAName)
    {
        LocalFree(pwszParentSanitizedCAName);
    }
    if (NULL != pCAFromShared)
    {
        LocalFree(pCAFromShared);
    }
    if (NULL != pccCA)
    {
        CertFreeCertificateContext(pccCA);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertConfigPrivate::Reset -- load config data, reset to indexed entry,
// return count
//
// Load the configuration data if not already loaded.  To reload the data after
// the data have changed, CCertConfigPrivate must be released and reloaded.
//
// Resets the current config entry to the Certification Authority configuration
// listed in the configuration file, indexed by the Index parameter.  0 indexes
// the first configuration.
//
// Upon successful completion, *pCount will be set to the number of Certificate
// Authority configurations listed in the configuration file.
//
// Returns S_FALSE if no entries are available at or after the passed Index.
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertConfigPrivate::Reset(
    /* [in] */ LONG Index,
    /* [retval][out] */ LONG __RPC_FAR *pCount)
{
    HRESULT hr = S_OK;

    if (NULL == pCount)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pCount");
    }
    if (NULL == m_pCertAuthorityInfo)
    {
	hr = _LoadTable();
	_JumpIfError(hr, error, "_LoadTable");
    }
    *pCount = m_Count;
    if (0 > Index || Index > m_Count)
    {
	Index = m_Count + 1;
	hr = S_FALSE;
    }
    m_Index = Index - 1;

error:
    CSASSERT(S_OK == hr || S_FALSE == hr || FAILED(hr));
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertConfigPrivate::Next -- skip to next config entry
//
// Changes the current config entry to the next Certification Authority
// configuration listed in the configuration file.
//
// Upon successful completion, *pIndex will be set to the index of Certificate
// Authority configurations listed in the configuration file.
//
// Returns S_FALSE if no more entries are available.  *pIndex is set to -1.
// Returns S_OK on success.  *pIndex is set to index the current configuration.
//+--------------------------------------------------------------------------

HRESULT
CCertConfigPrivate::Next(
    /* [retval][out] */ LONG __RPC_FAR *pIndex)
{
    HRESULT hr = S_OK;

    if (NULL == pIndex)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pIndex");
    }
    *pIndex = -1;
    if (NULL == m_pCertAuthorityInfo)
    {
	hr = _LoadTable();
	_JumpIfError(hr, error, "_LoadTable");
    }
    if (m_Index < m_Count)
    {
	m_Index++;
    }
    if (m_Index < m_Count)
    {
	*pIndex = m_Index;
    }
    else
    {
	hr = S_FALSE;
    }

error:
    CSASSERT(S_OK == hr || S_FALSE == hr || FAILED(hr));
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertConfigPrivate::GetField -- return a field from the current config entry.
//
// pstrOut points to a BSTR string filled in by this routine.  If *pstrOut is
// non-NULL and this method is successful, the old string is freed.  If any
// value other than S_OK is returned, the string pointer will not be modified.
//
// Upon successful completion, *pstrOut will point to a string that contains
// the requested field from the current config entry.
//
// When the caller no longer needs the string, it must be freed by calling
// SysFreeString().
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertConfigPrivate::GetField(
    /* [in] */ BSTR const strFieldName,
    /* [retval][out] */ BSTR __RPC_FAR *pstrOut)
{
    HRESULT hr = S_OK;
    CERT_AUTHORITY_INFO *pcai;
    BSTR bstr;
    DWORD cwc;
    WCHAR *pwsz = NULL;
    WCHAR *pwszRevert = NULL;
    WCHAR *pwszT = NULL;
    BOOL fDesanitize = TRUE;
    WCHAR awc[12];

    if (NULL == pstrOut || NULL == strFieldName)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pstrOut|strFieldName");
    }
    if (NULL != *pstrOut)
    {
	SysFreeString(*pstrOut);
	*pstrOut = NULL;
    }
    if (NULL == m_pCertAuthorityInfo)
    {
	hr = _LoadTable();
	_JumpIfError(hr, error, "_LoadTable");
    }

    if (-1 == m_Index)
    {
	m_Index++;	// implicit Next() for compatibility with Version 1
    }
    if (0 > m_Index || m_Index >= m_Count)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "m_Index");
    }

    pcai = &m_pCertAuthorityInfo[m_Index];
    bstr = strFieldName;

    if (0 == LSTRCMPIS(bstr, wszCONFIG_COMMONNAME))
    {
	pwsz = pcai->pwszSanitizedName;
    }
    else
    if (0 == LSTRCMPIS(bstr, wszCONFIG_SANITIZEDNAME))
    {
	pwsz = pcai->pwszSanitizedName;
	fDesanitize = FALSE;
    }
    else
    if (0 == LSTRCMPIS(bstr, wszCONFIG_SHORTNAME))
    {
	pwsz = pcai->pwszSanitizedShortName;
    }
    else
    if (0 == LSTRCMPIS(bstr, wszCONFIG_SANITIZEDSHORTNAME))
    {
	pwsz = pcai->pwszSanitizedShortName;
	fDesanitize = FALSE;
    }
    else
    if (0 == LSTRCMPIS(bstr, wszCONFIG_ORGUNIT))
    {
	pwsz = pcai->pwszSanitizedOrgUnit;
    }
    else
    if (0 == LSTRCMPIS(bstr, wszCONFIG_ORGANIZATION))
    {
	pwsz = pcai->pwszSanitizedOrganization;
    }
    else
    if (0 == LSTRCMPIS(bstr, wszCONFIG_LOCALITY))
    {
	pwsz = pcai->pwszSanitizedLocality;
    }
    else
    if (0 == LSTRCMPIS(bstr, wszCONFIG_STATE))
    {
	pwsz = pcai->pwszSanitizedState;
    }
    else
    if (0 == LSTRCMPIS(bstr, wszCONFIG_COUNTRY))
    {
	pwsz = pcai->pwszSanitizedCountry;
    }
    else
    if (0 == LSTRCMPIS(bstr, wszCONFIG_CONFIG))
    {
	pwsz = pcai->pwszSanitizedConfig;
    }
    else
    if (0 == LSTRCMPIS(bstr, wszCONFIG_EXCHANGECERTIFICATE))
    {
	pwsz = pcai->pwszSanitizedExchangeCertificate;
	fDesanitize = FALSE;
    }
    else
    if (0 == LSTRCMPIS(bstr, wszCONFIG_SIGNATURECERTIFICATE))
    {
	pwsz = pcai->pwszSanitizedSignatureCertificate;
	fDesanitize = FALSE;
    }
    else
    if (0 == LSTRCMPIS(bstr, wszCONFIG_DESCRIPTION) ||
	0 == LSTRCMPIS(bstr, wszCONFIG_COMMENT))	// obsolete
    {
	pwsz = pcai->pwszSanitizedDescription;
    }
    else
    if (0 == LSTRCMPIS(bstr, wszCONFIG_SERVER))
    {
	pwsz = wcschr(pcai->pwszSanitizedConfig, L'\\');
	if (NULL == pwsz)
	{
	    cwc = wcslen(pcai->pwszSanitizedConfig);
	}
	else
	{
	    cwc = SAFE_SUBTRACT_POINTERS(pwsz, pcai->pwszSanitizedConfig);
	}
	pwszT = (WCHAR *) LocalAlloc(LMEM_FIXED, (cwc + 1) * sizeof(WCHAR));
	if (NULL == pwszT)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
	CopyMemory(pwszT, pcai->pwszSanitizedConfig, cwc * sizeof(WCHAR));
	pwszT[cwc] = L'\0';
	pwsz = pwszT;
    }
    else
    if (0 == LSTRCMPIS(bstr, wszCONFIG_AUTHORITY))
    {
	pwsz = wcschr(pcai->pwszSanitizedConfig, L'\\');
	if (NULL == pwsz)
	{
	    pwsz = L"";
	}
	else
	{
	    pwsz++;
	}
    }
    else
    if (0 == LSTRCMPIS(bstr, wszCONFIG_FLAGS))
    {
	wsprintf(awc, L"%u", pcai->Flags);
	CSASSERT(ARRAYSIZE(awc) > wcslen(awc));
	pwsz = awc;
    }

    if (NULL == pwsz)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError2(hr, error, "ConvertWszToBstr", CERTSRV_E_PROPERTY_EMPTY);
    }

    if (fDesanitize)
    {
	hr = myRevertSanitizeName(pwsz, &pwszRevert);
	_JumpIfError(hr, error, "myRevertSanitizeName");

	pwsz = pwszRevert;
    }

    if (!ConvertWszToBstr(pstrOut, pwsz, -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }

error:
    if (NULL != pwszT)
    {
	LocalFree(pwszT);
    }
    if (NULL != pwszRevert)
    {
	LocalFree(pwszRevert);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
CCertConfigPrivate::GetConfigFromPicker(
    OPTIONAL IN HWND               hwndParent,
    OPTIONAL IN WCHAR const       *pwszPrompt,
    OPTIONAL IN WCHAR const       *pwszTitle,
    OPTIONAL IN WCHAR const       *pwszSharedFolder,
    IN BOOL                        fUseDS,
    IN BOOL                        fSkipLocalCA,
    IN BOOL                        fCountOnly,
    OUT DWORD                     *pdwCount,
    OUT CRYPTUI_CA_CONTEXT const **ppCAContext)
{
    HRESULT hr;
    CRYPTUI_CA_CONTEXT *prgCAC = NULL;
    CRYPTUI_CA_CONTEXT const **pprgCAC = NULL;
    CRYPTUI_SELECT_CA_STRUCT UISelectCA;
    CRYPTUI_CA_CONTEXT const *pCAContext = NULL;

    LONG realCount = 0;
    LONG cCA;
    LONG i;

    BSTR strFieldFlags = NULL;
    BSTR strFieldConfig = NULL;
    BSTR strValue = NULL;
    WCHAR *pwszPtr;
    WCHAR **ppwszCAName = NULL;
    WCHAR **ppwszCAMachineName = NULL;
    BSTR strFolder = NULL;

    if ((NULL == ppCAContext) || (NULL == pdwCount))
    {
        hr = E_POINTER;
        _JumpError (hr, error, "NULL parm");
    }

    *ppCAContext = NULL;
    *pdwCount = 0;

    m_fUseDS = fUseDS;
    if (NULL != pwszSharedFolder)
    {
	strFolder = SysAllocString(pwszSharedFolder);
	if (NULL == strFolder)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "SysAllocString");
	}
	hr = SetSharedFolder(strFolder);
	_JumpIfError(hr, error, "configPrivate.SetSharedFolder");
    }

    hr = Reset(0, &cCA);
    if (S_OK != hr && S_FALSE != hr)
    {
       _JumpError(hr, error, "configPrivate.Reset");
    }
    hr = S_OK; // in case of S_FALSE;

    if (0 < cCA)
    {
	prgCAC = (CRYPTUI_CA_CONTEXT *) LocalAlloc(
					    LMEM_FIXED | LMEM_ZEROINIT, 
					    cCA * sizeof(prgCAC[0]));
	if (NULL == prgCAC)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	pprgCAC = (CRYPTUI_CA_CONTEXT const **) LocalAlloc(
						LMEM_FIXED | LMEM_ZEROINIT, 
						cCA * sizeof(pprgCAC[0]));
	if (NULL == pprgCAC)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	ppwszCAName = (WCHAR **) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					cCA * sizeof(ppwszCAName[0]));
	if (NULL == ppwszCAName)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	ppwszCAMachineName = (WCHAR **) LocalAlloc(
					LMEM_FIXED | LMEM_ZEROINIT,
					cCA * sizeof(ppwszCAMachineName[0]));
	if (NULL == ppwszCAMachineName)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}

	if (!ConvertWszToBstr(&strFieldFlags, wszCONFIG_FLAGS, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertWszToBstr");
	}
	if (!ConvertWszToBstr(&strFieldConfig, wszCONFIG_CONFIG, -1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertWszToBstr");
	}
	while (realCount < cCA)
	{
	    hr = Next(&i);
	    if (S_OK != hr)
	    {
		if (S_FALSE == hr)
		{
		    hr = S_OK;  // no more entry is not an error
		}
		break;
	    }
	    hr = GetField(strFieldFlags, &strValue);
	    _JumpIfError(hr, error, "configPrivate.GetField");

	    if (fSkipLocalCA && (CAIF_LOCAL & _wtoi(strValue)))
	    {
		continue;
	    }
	    SysFreeString(strValue);
	    strValue = NULL;
	    
	    hr = GetField(strFieldConfig, &strValue);
	    _JumpIfError(hr, error, "configPrivate.GetField");
	    
	    pwszPtr = wcsstr(strValue, L"\\");
	    if (NULL == pwszPtr)
	    {
		continue;
	    }
	    // change \ to null terminator
	    pwszPtr[0] = L'\0';
	    // point to CA name
	    pwszPtr = &pwszPtr[1];

	    ppwszCAName[realCount] = (WCHAR *) LocalAlloc(
				    LMEM_FIXED, 
				    (wcslen(pwszPtr) + 1) * sizeof(WCHAR));
	    if (NULL == ppwszCAName[realCount])
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    ppwszCAMachineName[realCount] = (WCHAR *) LocalAlloc(
				LMEM_FIXED, 
				(wcslen(strValue) + 1) * sizeof(WCHAR));
	    if (NULL == ppwszCAMachineName[realCount])
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    prgCAC[realCount].dwSize = sizeof(CRYPTUI_CA_CONTEXT);
	    wcscpy(ppwszCAName[realCount], pwszPtr);
	    wcscpy(ppwszCAMachineName[realCount], strValue);
	    prgCAC[realCount].pwszCAName = ppwszCAName[realCount];
	    prgCAC[realCount].pwszCAMachineName = ppwszCAMachineName[realCount];
	    ++realCount;

	    SysFreeString(strValue);
	    strValue = NULL;
	}
	for (i = 0; i < realCount; ++i)
	{
	    pprgCAC[i] = &prgCAC[i];
	}
    }

    *pdwCount = realCount;
    if (fCountOnly || 1 > realCount)
    {
        // done
        goto error; // normal return
    }

    ZeroMemory(&UISelectCA, sizeof(CRYPTUI_SELECT_CA_STRUCT));
    UISelectCA.cCAContext = realCount;
    UISelectCA.rgCAContext = pprgCAC;
    UISelectCA.dwSize = sizeof(UISelectCA);
    UISelectCA.wszDisplayString = pwszPrompt;
    UISelectCA.wszTitle = pwszTitle;
    UISelectCA.hwndParent = hwndParent;

    // invoke dialog

    pCAContext = _CryptUIDlgSelectCA(&UISelectCA);
    if (NULL == pCAContext) // user cancel?
    {
	hr = myHLastError();
	if (S_OK == hr)		
	{
	    hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
	}
	_JumpError(hr, error, "_CryptUIDlgSelectCA");
     }
    *ppCAContext = pCAContext;
    hr = S_OK;

error:
    // change to default
    m_fUseDS = TRUE;

    if (NULL != ppwszCAName)
    {
        for (i = 0; i < realCount; ++i)
        {
            if (NULL != ppwszCAName[i])
            {
                LocalFree(ppwszCAName[i]);
            }
        }
        LocalFree(ppwszCAName);
    }
    if (NULL != ppwszCAMachineName)
    {
        for (i = 0; i < realCount; ++i)
        {
            if (NULL != ppwszCAMachineName[i])
            {
                LocalFree(ppwszCAMachineName[i]);
            }
        }
        LocalFree(ppwszCAMachineName);
    }
    if (NULL != pprgCAC)
    {
        LocalFree(pprgCAC);
    }
    if (NULL != prgCAC)
    {
        LocalFree(prgCAC);
    }
    if (NULL != strFieldFlags)
    {
        SysFreeString(strFieldFlags);
    }
    if (NULL != strFieldConfig)
    {
        SysFreeString(strFieldConfig);
    }
    if (NULL != strValue)
    {
	SysFreeString(strValue);
    }
    if (NULL != strFolder)
    {
	SysFreeString(strFolder);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertConfigPrivate::GetConfig -- select a cert issuer, return config data.
//
// pstrOut points to a BSTR string filled in by this routine.  If *pstrOut is
// non-NULL and this method is successful, the old string is freed.  If any
// value other than S_OK is returned, the string pointer will not be modified.
//
// Flags must be set to 0.
//
// Upon successful completion, *pstrOut will point to a string that contains
// the server name and Certification Authority name.
//
// When the caller no longer needs the string, it must be freed by calling
// SysFreeString().
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertConfigPrivate::GetConfig(
    /* [in] */ LONG Flags,
    /* [retval][out] */ BSTR __RPC_FAR *pstrOut)
{
    HRESULT hr = S_OK;
    WCHAR *pwszSanitizedConfig = NULL;
    BOOL fSanitizedConfigAlloced = FALSE;
    WCHAR *pwszConfigRevert = NULL;
    WCHAR *pwszSanitize = NULL;
    CRYPTUI_CA_CONTEXT const *pCAContext = NULL;
    DWORD dwCACount;
    LONG lIndex;
    LONG cCA;
    LONG i;

    if (NULL == pstrOut)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pstrOut");
    }
    if (NULL != *pstrOut)
    {
	SysFreeString(*pstrOut);
	*pstrOut = NULL;
    }
    if (NULL == m_pCertAuthorityInfo)
    {
	hr = _LoadTable();
	_JumpIfError(hr, error, "_LoadTable");
    }
    if (0 > m_Count)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "m_Count");
    }

    switch (Flags)
    {
        case CC_UIPICKCONFIG:
	case CC_UIPICKCONFIGSKIPLOCALCA:
	    hr = GetConfigFromPicker(
				GetDesktopWindow(),	// hDlg
				NULL,	// pwszPrompt
				NULL,	// pwszTitle
				m_pwszSharedFolder,
				TRUE,	// fUseDS
				CC_UIPICKCONFIGSKIPLOCALCA == Flags,
				FALSE,	// fCountOnly
				&dwCACount,
				&pCAContext);
	    _JumpIfError(hr, error, "GetConfigFromPicker");

	    if (NULL == pCAContext)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
		_JumpError(hr, error, "No CA Config");
	    }

	    // ca name in UI has been reverted so sanitize it

	    hr = mySanitizeName(pCAContext->pwszCAName, &pwszSanitize);
	    _JumpIfError(hr, error, "mySanitizeName");

	    pwszSanitizedConfig = (WCHAR *) LocalAlloc(
			LMEM_FIXED,
			(wcslen(pwszSanitize) +
			 wcslen(pCAContext->pwszCAMachineName) + 2) *
			    sizeof(WCHAR));
	    if (NULL == pwszSanitizedConfig)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    fSanitizedConfigAlloced = TRUE;
	    wcscpy(pwszSanitizedConfig, pCAContext->pwszCAMachineName);
	    wcscat(pwszSanitizedConfig, L"\\");
	    wcscat(pwszSanitizedConfig, pwszSanitize);
	    for (lIndex = 0; lIndex < m_Count; ++lIndex)
	    {
		if (0 == mylstrcmpiL(pwszSanitizedConfig, m_pCertAuthorityInfo[lIndex].pwszSanitizedConfig))
		{
		    // update index
		    Reset(lIndex + 1, &cCA);
		    break;
		}
	    }
	    break;
    
	case CC_LOCALCONFIG:
	case CC_LOCALACTIVECONFIG:
        case CC_DEFAULTCONFIG:
	    if (NULL == m_pCertAuthorityInfo)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		_JumpError(hr, error, "no CAs");
	    }
	    if (CC_LOCALCONFIG != Flags && CC_LOCALACTIVECONFIG != Flags)
	    {
		// Make a recursive call to first look for a local pingable CA.
		// If that fails, pick any pingable CA.

		hr = GetConfig(CC_LOCALACTIVECONFIG, pstrOut);
		if (S_OK == hr)
		{
		    break;
		}
		_PrintError(hr, "GetConfig(CC_LOCALACTIVECONFIG)");
	    }
            for (i = 0; i < m_Count; i++)
            {
		CSASSERT(NULL != m_pCertAuthorityInfo[i].pwszSanitizedConfig);

		pwszSanitizedConfig = m_pCertAuthorityInfo[i].pwszSanitizedConfig;

		if (CC_LOCALCONFIG == Flags || CC_LOCALACTIVECONFIG == Flags)
		{
		    DWORD InfoFlags;

		    InfoFlags = m_pCertAuthorityInfo[i].Flags;
		    if (0 == (CAIF_LOCAL & InfoFlags))
		    {
			continue;
		    }
		    if (0 == (CAIF_REGISTRY & InfoFlags))
		    {
			LONG j;

			for (j = i + 1; j < m_Count; j++)
			{
			    InfoFlags = m_pCertAuthorityInfo[j].Flags;

			    if ((CAIF_LOCAL & InfoFlags) &&
				(CAIF_REGISTRY & InfoFlags))
			    {
				break;
			    }
			}
			if (j < m_Count)
			{
			    i = j;
			}
		    }
		}
		if (CC_LOCALCONFIG == Flags)
		{
		    hr = S_OK;
		}
		else
		{
		    hr = myRevertSanitizeName(pwszSanitizedConfig, &pwszConfigRevert);
		    _JumpIfError(hr, error, "myRevertSanitizeName");

		    hr = myPingCertSrv(
				pwszConfigRevert,
				NULL,
				NULL,
				NULL,
				NULL,
				NULL,
                                NULL);
		}
		if (S_OK == hr)
		{
		    // update index
		    Reset(i + 1, &cCA);
		    break; // take it
		}
		if (NULL != pwszConfigRevert)
		{
		    LocalFree(pwszConfigRevert);
		    pwszConfigRevert = NULL;
		}
            }
            if (S_OK != hr || i >= m_Count)
            {
                hr = HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS);
                _JumpError(hr, error, "No matching CA");
            }
	    break;

        case CC_FIRSTCONFIG:
	    if (NULL == m_pCertAuthorityInfo)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		_JumpError(hr, error, "no CAs");
	    }
	    pwszSanitizedConfig = m_pCertAuthorityInfo[0].pwszSanitizedConfig;
            // update index
            Reset(1, &cCA);
	    break;

        default:
            hr = E_INVALIDARG;
           _JumpError(hr, error, "Flags");
    }

    if(!*pstrOut)
    {
        if (NULL == pwszConfigRevert)
        {
	    // always revert

	    hr = myRevertSanitizeName(pwszSanitizedConfig, &pwszConfigRevert);
	    _JumpIfError(hr, error, "myRevertSanitizeName");
        }
        if (!ConvertWszToBstr(pstrOut, pwszConfigRevert, -1))
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "ConvertWszToBstr");
        }
    }
    hr = S_OK;

error:
    if (fSanitizedConfigAlloced && NULL != pwszSanitizedConfig)
    {
	LocalFree(pwszSanitizedConfig);
    }
    if (NULL != pwszConfigRevert)
    {
        LocalFree(pwszConfigRevert);
    }
    if (NULL != pwszSanitize)
    {
        LocalFree(pwszSanitize);
    }
    if (NULL != pCAContext)
    {
        _CryptUIDlgFreeCAContext(pCAContext);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertConfigPrivate::SetSharedFolder -- set the shared folder
//
// strSharedFolder is the new shared folder dorectory path.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertConfigPrivate::SetSharedFolder(
    /* [in] */ const BSTR strSharedFolder)
{
    HRESULT hr;
    WCHAR *pwsz;

    pwsz = NULL;
    if (NULL != strSharedFolder)
    {
	hr = myDupString(strSharedFolder, &pwsz);
	_JumpIfError(hr, error, "myDupString");
    }
    if (NULL != m_pwszSharedFolder)
    {
	LocalFree(m_pwszSharedFolder);
    }
    m_pwszSharedFolder = pwsz;
    hr = S_OK;

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT WINAPI
certLoadFile(
    WCHAR const *pwszfn,
    BYTE **ppbData,
    DWORD *pcbData)
{
    HANDLE hFile;
    DWORD cbLow, cbHigh, cbRead;
    HRESULT hr;

    hFile = CreateFile(
                    pwszfn,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    0);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        hr = myHLastError();
	_JumpErrorStr(hr, error, "CreateFile", pwszfn);
    }

    cbLow = GetFileSize(hFile, &cbHigh);
    if (0xffffffff == cbLow)
    {
        hr = myHLastError();
	_JumpError(hr, error, "GetFileSize");
    }

    *ppbData = (BYTE *) LocalAlloc(LMEM_FIXED, cbLow + 1);
    if (NULL == *ppbData)
    {
        hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (!ReadFile(hFile, *ppbData, cbLow, &cbRead, NULL))
    {
        hr = myHLastError();
        LocalFree(*ppbData);
        *ppbData = NULL;
	_JumpError(hr, error, "ReadFile");
    }
    (*ppbData)[cbLow] = '\0';
    *pcbData = cbLow;
    hr = S_OK;

error:
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle(hFile);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


// certTrimToken -- trim white space from the beginning and end of a line.
// Bump caller's string pointer, reduce the caller's input buffer count,
// and L'\0' terminate the result -- IN PLACE!

VOID
certTrimToken(
    WCHAR **ppwsz)
{
    WCHAR *pwsz;
    WCHAR *pwszEnd;
    static WCHAR wszTrim[] = L" \t\r\n";

    pwsz = *ppwsz;
    while (L'\0' != *pwsz)
    {
	if (NULL == wcschr(wszTrim, *pwsz))
	{
	    break;
	}
	pwsz++;
    }

    pwszEnd = wcschr(pwsz, L'\0');
    assert(NULL != pwszEnd);

    while (pwsz < pwszEnd)
    {
	if (NULL == wcschr(wszTrim, *--pwszEnd))
	{
	    break;
	}
	*pwszEnd = L'\0';
    }
    *ppwsz = pwsz;
}


BOOL
certExtractToken(
    WCHAR **ppwszIn,
    WCHAR const **ppwszOut)
{
    WCHAR *pwsz;
    WCHAR *pwszNext;
    BOOL fQuoted = FALSE;

    pwsz = *ppwszIn;
    while (L' ' == *pwsz || L'\t' == *pwsz)
    {
	pwsz++;
    }

    pwszNext = pwsz;
    if (L'"' == *pwsz)
    {
	fQuoted = TRUE;
	pwsz++;
	pwszNext++;

	while (TRUE)
	{
	    // Find a mid-string escaped quote or the terminating quote.

	    pwszNext = wcschr(pwszNext, L'"');

	    if (NULL == pwszNext)
	    {
		break;		// missing terminating quote!
	    }

	    // If a terminating quote, terminate the string with L'\0',
	    // and point past the quoted string.  Break to search for a comma.

	    if (L'"' != pwszNext[1])
	    {
		*pwszNext++ = L'\0';
		break;
	    }

	    // Found a mid-string escaped quote.  Move the first part of the
	    // string forward one character position, overwriting the first
	    // quote character.  Bump the string pointer to the new location,
	    // point pwszNext past the remaining quote character, and loop.

	    MoveMemory(
		&pwsz[1],
		pwsz,
		SAFE_SUBTRACT_POINTERS(pwszNext, pwsz) * sizeof(*pwsz));
	    pwsz++;
	    pwszNext += 2;
	}
    }

    if (NULL != pwszNext)
    {
	pwszNext = wcschr(pwszNext, L',');
    }
    if (NULL != pwszNext)
    {
	*pwszNext++ = L'\0';
    }
    else
    {
	pwszNext = wcschr(pwsz, L'\0');
	assert(NULL != pwszNext);
    }

    certTrimToken(&pwsz);

    *ppwszOut = pwsz;
    *ppwszIn = pwszNext;

    return(fQuoted || L'\0' != *pwsz);
}


// certExtractLine -- convert one line to Unicode and return it in a L'\0'
// terminated output buffer.  Bump caller's input buffer pointer and reduce
// the caller's input buffer count.

HRESULT
certExtractLine(
    IN char const **ppchLine,
    IN OUT LONG *pcchLine,
    OUT WCHAR *pwc,
    IN OUT LONG *pcwc)
{
    char const *pch;
    char const *pchEnd;
    LONG cch;
    HRESULT hr = S_OK;
    int cwc;

    pch = *ppchLine;
    cch = *pcchLine;
    pchEnd = &pch[cch];

    while (pch < pchEnd)
    {
	if ('\n' == *pch++)
	{
	    pchEnd = pch;
	    cch = SAFE_SUBTRACT_POINTERS(pchEnd, *ppchLine);
	    break;
	}
    }

    do
    {
	cwc = MultiByteToWideChar(GetACP(), 0, *ppchLine, cch, pwc, *pcwc - 1);
	if (0 == cwc)
	{
	    hr = myHLastError();
	    break;
	}
	pwc[cwc] = L'\0';
	*pcwc = cwc;
	*pcchLine -= cch;
	*ppchLine = pchEnd;
    } while (FALSE);

    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


// Format of each line is:
// <name>, <OrgUnit>, <Organization>, <Locality>, <State>, <Country>, <Server Name>, <Exchange Cert>, <Self signed cert>, <Comment>

HRESULT
certParseLine(
    char const **ppchLine,
    LONG *pcchLine,
    CERT_AUTHORITY_INFO *pcai,
    WCHAR *pwsz,
    LONG *pcwc)
{
    HRESULT hr;
    LONG cwc;

    do
    {
	if (0 == *pcchLine)
	{
	    hr = S_OK;
	    *pcwc = 0;
	    goto error;
	}
	cwc = *pcwc;
	hr = certExtractLine(ppchLine, pcchLine, pwsz, &cwc);
	if (S_OK != hr)
	{
	    goto error;
	}
	*pcwc = cwc + 1;
	certTrimToken(&pwsz);
    } while (L'\0' == *pwsz || L'#' == *pwsz);

    if (!certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedName) ||
	!certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedOrgUnit) ||
	!certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedOrganization) ||
	!certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedLocality) ||
	!certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedState) ||
	!certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedCountry) ||
	!certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedConfig) ||
	!certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedExchangeCertificate) ||
	!certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedSignatureCertificate))
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	goto error;
    }
    certExtractToken(&pwsz, (WCHAR const **) &pcai->pwszSanitizedDescription);
    pcai->Flags = CAIF_SHAREDFOLDERENTRY;

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


LONG
certSkipLine(
    IN char const **ppchData,
    IN LONG *pcchData)
{
    HRESULT hr;
    LONG cb = 0;
    CERT_AUTHORITY_INFO cai;
    WCHAR *pwszLine = NULL;
    LONG cwc;
    char const *pchData;
    LONG cchData;

    pchData = *ppchData;
    cchData = *pcchData;

    cwc = strcspn(pchData, "\n") + 2;	// leave room for \n and \0
    pwszLine = (WCHAR *) LocalAlloc(LMEM_FIXED, cwc * sizeof(WCHAR));
    if (NULL == pwszLine)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    hr = certParseLine(&pchData, &cchData, &cai, pwszLine, &cwc);
    if (S_OK != hr || 0 == cwc)
    {
	_PrintIfError(hr, "certParseLine");
	goto error;
    }
    cb = sizeof(cai) + cwc * sizeof(WCHAR);
    *ppchData = pchData;
    *pcchData = cchData;

error:
    //printf("certSkipLine: %u bytes\n", cb);

    if (NULL != pwszLine)
    {
	LocalFree(pwszLine);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(cb);
}


VOID
certAppendBSFileName(
    IN OUT WCHAR *pwszPath,
    IN WCHAR *pwszBSFN)		// backslash + filename.ext
{
    DWORD cwc;

    cwc = wcslen(pwszPath);
    if (0 < cwc--)
    {
	if (L'\\' == pwszPath[cwc])
	{
	    pwszPath[cwc] = L'\0';
	}
    }
    wcscat(pwszPath, pwszBSFN);
}


HRESULT
certGetConfigFileName(
    OUT WCHAR **ppwszFileConfig)
{
    HRESULT hr;
    DWORD dwLen;
    DWORD dwType;
    HKEY hKeyConfig = NULL;
    WCHAR *pwszFileName = NULL;

    *ppwszFileConfig = NULL;

    do
    {
	hr = RegOpenKeyEx(
			HKEY_LOCAL_MACHINE,
			wszREGKEYCONFIGPATH,
			0,
			KEY_READ,
			&hKeyConfig);
	if (S_OK != hr)
	{
	    _PrintErrorStr2(
		    hr,
		    "RegOpenKeyEx",
		    wszREGKEYCONFIGPATH,
		    ERROR_FILE_NOT_FOUND);
	   break;
	}

	// Get the size of the value first

	hr = RegQueryValueEx(
			    hKeyConfig,
			    g_wszRegDirectory,
			    0,
			    &dwType,
			    NULL,
			    &dwLen);
	if (S_OK != hr)
	{
	    _PrintErrorStr2(
		    hr,
		    "RegQueryValueEx",
		    g_wszRegDirectory,
		    ERROR_FILE_NOT_FOUND);
	    break;
	}

	if (0 == dwLen)
	{
	    hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	    _PrintErrorStr2(hr, "RegQueryValueEx", g_wszRegDirectory, hr);
	    break;
	}

	// Allocate enough memory for the directory path plus the file name.

	pwszFileName = (WCHAR *) LocalAlloc(LMEM_FIXED,
			dwLen + (wcslen(g_wszConfigFile) + 1) * sizeof(WCHAR));
	if (NULL == pwszFileName)
	{
	    hr = E_OUTOFMEMORY;
	    _PrintError2(hr, "LocalAlloc", hr);
	    break;
	}

	hr = RegQueryValueEx(
			    hKeyConfig,
			    g_wszRegDirectory,
			    0,
			    &dwType,
			    (BYTE *) pwszFileName,
			    &dwLen);
	if (S_OK != hr)
	{
	    _PrintErrorStr(hr, "RegQueryValueEx", g_wszRegDirectory);
	    break;
	}
	if (L'\0' == *pwszFileName)
	{
	    hr = S_OK;
	    break;
	}

	// Place config file name on end of path to open

	certAppendBSFileName(pwszFileName, g_wszConfigFile);
	*ppwszFileConfig = pwszFileName;
	pwszFileName = NULL;

    } while (FALSE);

    if (NULL != pwszFileName)
    {
	LocalFree(pwszFileName);
    }
    if (NULL != hKeyConfig)
    {
	RegCloseKey(hKeyConfig);
    }
    return(myHError(hr));
}


HRESULT
certLoadConfigFile(
    IN WCHAR const *pwszSharedFolder,
    OUT BYTE **ppchData,
    OUT DWORD *pcchData)
{
    HRESULT hr;
    WCHAR *pwszfn = NULL;

    *ppchData = NULL;
    *pcchData = 0;

    if (NULL == pwszSharedFolder)
    {
	hr = certGetConfigFileName(&pwszfn);
	_JumpIfError2(
		    hr,
		    error,
		    "certGetConfigFileName",
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));
    }
    else
    {
        pwszfn = (WCHAR *) LocalAlloc(
	    LMEM_FIXED,
            (wcslen(pwszSharedFolder) + wcslen(g_wszConfigFile) + 1) *
		sizeof(WCHAR));
        if (NULL == pwszfn)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
        wcscpy(pwszfn, pwszSharedFolder);
	certAppendBSFileName(pwszfn, g_wszConfigFile);
    }
    if (NULL != pwszfn)
    {
	hr = certLoadFile(pwszfn, ppchData, pcchData);
	_JumpIfError3(
		hr,
		error,
		"certLoadFile",
		HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE),
		HRESULT_FROM_WIN32(ERROR_INVALID_NETNAME));
    }
    hr = S_OK;

error:
    if (NULL != pwszfn)
    {
	LocalFree(pwszfn);
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


//+--------------------------------------------------------------------------
// certRequestGetConfig -- return config data for all requested authorities.
//
// *pIndex should be set to 0 prior to the first call.  It will be modified by
// certRequestGetConfig to index the next entry after those returned.
//
// *pCount is a pointer to the number of authorities for which information is
// requested.  Upon successful completion, *pCount will contain the number of
// authorities for which information is returned.  If the returned value is
// less than requested (or 0) no more entries are available.
//
// ppCertAuthorityInfo is a pointer to an uninitialized pointer on input.
// Upon successful completion, a pointer to an array of CERT_AUTHORITY_INFO
// structures is returned.  When the caller no longer needs the array, it must
// be freed by calling CertFreeMemory.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
certRequestGetConfigInfo(
    IN WCHAR *pwszSharedFolder,
    IN OUT LONG *pIndex,
    IN OUT LONG *pCount,
    OUT CERT_AUTHORITY_INFO **ppCertAuthorityInfo)
{
    HRESULT hr = S_OK;
    LONG cSkip = *pIndex;
    LONG cLine = *pCount;
    DWORD cchData;
    char const *pchData = NULL;
    LONG cLineReturned = 0;
    CERT_AUTHORITY_INFO *pcaiBase = NULL;

    *ppCertAuthorityInfo = NULL;

    do
    {
        char const *pch;
        LONG cch;
        char const *pchSave;
        LONG cchSave;
        LONG cbTotal;
        CERT_AUTHORITY_INFO *pcai;
        WCHAR *pwc;
        LONG cwc;
        LONG cwcRemain;
        LONG i;
        
        hr = certLoadConfigFile(pwszSharedFolder, (BYTE **) &pchData, &cchData);
        if (S_OK != hr || (NULL == pchData && 0 == cchData))
        {
            break;
        }
        pch = pchData;
        cch = cchData;
        
        // Skip cSkip entries:
        
        //printf("Skipping lines:\n");
        for (i = 0; i < cSkip; i++)
        {
            if (0 == certSkipLine(&pch, &cch))
            {
                break;			// ran out of config data
            }
        }
        if (i < cSkip)
        {
            break;			// no data to return
        }
        pchSave = pch;
        cchSave = cch;
        
        // Compute total size of cLine entries:
        
        //printf("Sizing lines:\n");
        cbTotal = 0;
        for (i = 0; i < cLine; i++)
        {
            LONG cb;
            
            cb = certSkipLine(&pch, &cch);
            if (0 == cb)
            {
                cLine = i;		// reduce return line count
                break;			// ran out of config data
            }
            cbTotal += cb;
        }
        if (0 == cLine)
        {
            break;			// no data to return
        }
        
        pcaiBase = (CERT_AUTHORITY_INFO *) LocalAlloc(LMEM_FIXED, cbTotal);
        if (NULL == pcaiBase)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        //printf("Returning lines:\n");
        pch = pchSave;
        cch = cchSave;
        pcai = pcaiBase;
        pwc = (WCHAR *) &pcai[cLine];
        cwcRemain = (cbTotal - sizeof(*pcai) * cLine)/sizeof(*pwc);
        for (i = 0; i < cLine; i++)
        {
            cwc = cwcRemain;
            hr = certParseLine(&pch, &cch, pcai, pwc, &cwc);
            if (S_OK != hr)
            {
                break;
            }
            pcai++;
            pwc += cwc;
            cwcRemain -= cwc;
        }
        if (S_OK != hr)
        {
            break;
        }
        cLineReturned = cLine;
        *ppCertAuthorityInfo = pcaiBase;
        pcaiBase = NULL;
        hr = S_OK;
    } while (FALSE);

    *pIndex += cLineReturned;
    *pCount = cLineReturned;

    if (NULL != pcaiBase)
    {
        LocalFree(pcaiBase);
    }
    if (NULL != pchData)
    {
	LocalFree(const_cast<char *>(pchData));
    }
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}


HRESULT
myGetConfigFromPicker(
    OPTIONAL IN HWND               hwndParent,
    OPTIONAL IN WCHAR const       *pwszPrompt,
    OPTIONAL IN WCHAR const       *pwszTitle,
    OPTIONAL IN WCHAR const       *pwszSharedFolder,
    IN  DWORD                      dwFlags,	// GCFPF_*
    IN  BOOL                       fCountOnly,
    OUT DWORD                     *pdwCACount,
    OUT CRYPTUI_CA_CONTEXT const **ppCAContext)
{
    HRESULT hr;
    CCertConfigPrivate configPrivate;

    if (~(GCFPF_USEDS | GCFPF_SKIPLOCALCA) & dwFlags)
    {
	hr = E_INVALIDARG;
	_JumpError(hr, error, "dwFlags");
    }
    hr = configPrivate.GetConfigFromPicker(
				hwndParent,
				pwszPrompt,
				pwszTitle,
				pwszSharedFolder,
				(GCFPF_USEDS & dwFlags)? TRUE : FALSE,
				(GCFPF_SKIPLOCALCA & dwFlags)? TRUE : FALSE,
				fCountOnly,
				pdwCACount,
				ppCAContext);
    _JumpIfError(hr, error, "configPrivate.GetConfigFromPicker");

error:
    CSASSERT(S_OK == hr || FAILED(hr));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certcli\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1997

Module Name:

    makefile.inc.

!ENDIF

$(O)\$(MINORCOMP).res:    ..\idl\com\$(O)\$(MINORCOMP).tlb

$(O)\$(MINORCOMP).lib : $(PRIVLIB)

$(PRIVLIB) $(PRIVLIB:.lib=.exp): $(O)\$(MINORCOMP)p.def $(LIBRARY_OBJS)
   -$(LIB_NAME) -out:$(PRIVLIB) @<<
$(LIBRARIAN_FLAGS)
-def:$(O)\$(MINORCOMP)p.def
$(LIBRARY_OBJS)
<<NOKEEP

$(O)\$(MINORCOMP)p.def: $(MINORCOMP).src
    $(C_PREPROCESSOR) $** -DPRIVATEEXPORT= > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certcli\request.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        request.cpp
//
// Contents:    Cert Server client implementation
//
// History:     24-Aug-96       vich created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <objbase.h>
#include "certsrvd.h"
#include "csdisp.h"
#include "certrpc.h"
#include <certca.h>

#include "request.h"

#define __dwFILE__	__dwFILE_CERTCLI_REQUEST_CPP__


#define CR_RPC_CANCEL_TIMEOUT 5
#define CR_RPC_REQUEST_TIMEOUT 60000 /* 60 seconds for the request timeout */



typedef struct _RPC_TIMEOUT_CONTEXT
{
    HANDLE hWait;
    HANDLE hEvent;
    HANDLE hThread;
    HRESULT hrRpcError;
} RPC_TIMEOUT_CONTEXT, *PRPC_TIMEOUT_CONTEXT;

typedef struct _WZR_RPC_BINDING_LIST
{
    LPWSTR pszProtSeq;
    LPWSTR pszEndpoint;
} WZR_RPC_BINDING_LIST;

WZR_RPC_BINDING_LIST g_awzrBindingList[] =
{
    { L"ncacn_ip_tcp", NULL },
    { L"ncacn_np", L"\\pipe\\cert" }
};

INT g_cwzrBindingList = sizeof(g_awzrBindingList)/sizeof(g_awzrBindingList[0]);

typedef struct _WZR_RPC_ATHN_LIST
{
    DWORD dwAuthnLevel;
    DWORD dwAuthnService;
} WZR_RPC_ATHN_LIST;

WZR_RPC_ATHN_LIST g_awzrAthnList[] =
{
    { RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_AUTHN_GSS_NEGOTIATE},
    { RPC_C_AUTHN_LEVEL_PKT_INTEGRITY, RPC_C_AUTHN_GSS_NEGOTIATE},
    { RPC_C_AUTHN_LEVEL_NONE, RPC_C_AUTHN_NONE }
};

INT g_cwzrAthnList = sizeof(g_awzrAthnList)/sizeof(g_awzrAthnList[0]);

HRESULT
crRegisterRPCCallTimeout(
    IN DWORD dwMilliseconds,
    OUT PRPC_TIMEOUT_CONTEXT pTimeout);

HRESULT
crCloseRPCCallTimeout(
    IN  PRPC_TIMEOUT_CONTEXT pTimeout);



HRESULT
crSetRPCSecurity(
    IN handle_t hRPCCertServer,
    IN OUT INT *prpcAuthProtocol)
{
    HRESULT hr = S_OK;
    LPWSTR pwszCAPrinceName = NULL;
    INT rpcAuthProtocol = *prpcAuthProtocol;

    // Set the RPC connect as the SNEGO connect, which can authenticate
    // a machine if supported by the system.
    // Don't need to check the return value since not supported by NT4/Win9x.

    if (rpcAuthProtocol >= g_cwzrAthnList)
    {
        hr = RPC_S_UNKNOWN_AUTHN_SERVICE;
        goto error;
    }
    for ( ; rpcAuthProtocol < g_cwzrAthnList; rpcAuthProtocol++)
    {
        pwszCAPrinceName = NULL;
        if (RPC_C_AUTHN_NONE != g_awzrAthnList[rpcAuthProtocol].dwAuthnService)
        {
            hr = RpcMgmtInqServerPrincName(
			    hRPCCertServer,
			    g_awzrAthnList[rpcAuthProtocol].dwAuthnService,
			    &pwszCAPrinceName);
            if (hr == RPC_S_UNKNOWN_AUTHN_SERVICE)
            {
                continue;
            }
        }

        hr = RpcBindingSetAuthInfo(
			    hRPCCertServer,
			    pwszCAPrinceName,
			    g_awzrAthnList[rpcAuthProtocol].dwAuthnLevel,
			    g_awzrAthnList[rpcAuthProtocol].dwAuthnService,
			    NULL,
			    RPC_C_AUTHZ_NONE);

        if (NULL != pwszCAPrinceName)
        {
            RpcStringFree(&pwszCAPrinceName);
        }
        if (hr != RPC_S_UNKNOWN_AUTHN_SERVICE)
        {
            break;
        }
    }

error:
    *prpcAuthProtocol = rpcAuthProtocol;
    return(hr);
}


HRESULT
crOpenRPCConnection(
    IN WCHAR const *pwszServerName,
    IN OUT INT *prpcAuthProtocol,
    OUT handle_t *phRPCCertServer)
{
    HRESULT hr = S_OK;
    INT i;
    WCHAR *pwszStringBinding = NULL;

    for (i = 0; i < g_cwzrBindingList; i++)
    {
	if (RPC_S_OK != RpcNetworkIsProtseqValid(
				    g_awzrBindingList[i].pszProtSeq))
	{
	    continue;
	}

	hr = RpcStringBindingCompose(
			      NULL,
			      g_awzrBindingList[i].pszProtSeq,
			      const_cast<WCHAR *>(pwszServerName),
			      g_awzrBindingList[i].pszEndpoint,
			      NULL,
			      &pwszStringBinding);
	if (S_OK != hr)
	{
	    continue;
	}

	hr = RpcBindingFromStringBinding(
				    pwszStringBinding,
				    phRPCCertServer);
	if (NULL != pwszStringBinding)
	{
	    RpcStringFree(&pwszStringBinding);
	}
	if (S_OK != hr)
	{
	    continue;
	}

	hr = RpcEpResolveBinding(
			    *phRPCCertServer,
			    ICertPassage_v0_0_c_ifspec);
	if (S_OK == hr)
	{
	    break;
	}
    }
    _JumpIfError(hr, error, "RPC Resolve Binding Loop");

    hr = crSetRPCSecurity(*phRPCCertServer, prpcAuthProtocol);
    _JumpIfError(hr, error, "_SetRPCSecurity");

error:
    if (NULL != pwszStringBinding)
    {
        RpcStringFree(&pwszStringBinding);
    }
    return(hr);
}


VOID
crCloseRPCConnection(
    IN OUT handle_t *phRPCCertServer)
{
    if (NULL != *phRPCCertServer)
    {
        RpcBindingFree(phRPCCertServer);
        *phRPCCertServer = NULL;
    }
}


HRESULT
crCertServerRequest(
    IN handle_t hRPCCertServer,
    IN OUT INT *prpcAuthProtocol,
    IN DWORD Flags,
    IN WCHAR const *pwszAuthority,
    IN OUT DWORD *pRequestId,
    OUT DWORD *pDisposition,
    IN CERTTRANSBLOB const *pctbAttrib,
    IN CERTTRANSBLOB const *pctbSerial,
    IN CERTTRANSBLOB const *pctbRequest,
    OUT CERTTRANSBLOB *pctbCertChain,
    OUT CERTTRANSBLOB *pctbCert,
    OUT CERTTRANSBLOB *pctbDispositionMessage)
{
    HRESULT hr;

    RPC_TIMEOUT_CONTEXT Timeout = {NULL, NULL, NULL, S_OK};
    
    do
    {
	// Midl_user_allocate registers memory in RPC case

        hr = crRegisterRPCCallTimeout(CR_RPC_REQUEST_TIMEOUT, &Timeout);
	_JumpIfError(hr, error, "crRegisterRPCCallTimeout");

	// for pending requests, pass the serial number in pctbAttrib

	if (NULL == pctbAttrib ||
	    NULL == pctbAttrib->pb ||
	    0 == pctbAttrib->cb)
	{
	    pctbAttrib = pctbSerial;
	}

        __try
        {
            hr = CertServerRequest(
		            hRPCCertServer,
		            Flags,
		            pwszAuthority,
		            pRequestId,
		            pDisposition,
		            pctbAttrib,		// or SerialNumber
		            pctbRequest,
		            pctbCertChain,
		            pctbCert,
		            pctbDispositionMessage);
        }
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
        {
        }
	if (HRESULT_FROM_WIN32(RPC_S_CALL_CANCELLED) == hr)
	{
            hr = Timeout.hrRpcError;
	    crCloseRPCCallTimeout(&Timeout);
	}
        _PrintIfError(hr, "CertServerRequest");

        if (hr == RPC_S_UNKNOWN_AUTHN_SERVICE)
        {
            (*prpcAuthProtocol)++;
            hr = crSetRPCSecurity(hRPCCertServer, prpcAuthProtocol);
            if (hr == RPC_S_UNKNOWN_AUTHN_SERVICE)
            {
                break;
            }
            if (hr == S_OK)
            {
                continue;
            }
        }
    } while (hr == RPC_S_UNKNOWN_AUTHN_SERVICE);
error:
    return(hr);
}


HRESULT
crRequestCertificate(
    IN DWORD Flags,
    OPTIONAL IN BYTE const *pbRequest,
    IN DWORD cbRequest,
    IN DWORD RequestId,
    OPTIONAL IN WCHAR const *pwszRequestAttributes,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszAuthority,
    OUT CERTSERVERENROLL **ppcsEnroll) // free via CertServerFreeMemory
{
    HRESULT hr;
    handle_t hRPCCertServer = NULL;
    INT rpcAuthProtocol = 0;
    CERTTRANSBLOB ctbRequest;
    CERTTRANSBLOB ctbAttrib;
    CERTTRANSBLOB ctbSerial;
    CERTTRANSBLOB ctbCert = { 0, NULL };
    CERTTRANSBLOB ctbCertChain = { 0, NULL };
    CERTTRANSBLOB ctbDispositionMessage = { 0, NULL };
    CERTSERVERENROLL csEnroll;
    CERTSERVERENROLL *pcsEnroll = NULL;
    BYTE *pbOut;
    DWORD cbAlloc;

    if (NULL == pwszServerName || NULL == pwszAuthority || NULL == ppcsEnroll)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    *ppcsEnroll = NULL;

    ZeroMemory(&csEnroll, sizeof(csEnroll));
    csEnroll.hrLastStatus = E_FAIL;
    csEnroll.Disposition = CR_DISP_ERROR;
    csEnroll.RequestId = RequestId;

    ctbRequest.pb = const_cast<BYTE *>(pbRequest);
    ctbRequest.cb = cbRequest;

    ctbAttrib.pb = (BYTE *) pwszRequestAttributes;
    ctbAttrib.cb = 0;
    if (NULL != pwszRequestAttributes)
    {
	ctbAttrib.cb = (wcslen(pwszRequestAttributes) + 1) * sizeof(WCHAR);
    }

    ctbSerial.pb = (BYTE *) pwszSerialNumber;
    ctbSerial.cb = 0;
    if (NULL != pwszSerialNumber)
    {
	ctbSerial.cb = (wcslen(pwszSerialNumber) + 1) * sizeof(WCHAR);
    }

    hr = crOpenRPCConnection(pwszServerName, &rpcAuthProtocol, &hRPCCertServer);
    _JumpIfError(hr, error, "crOpenRPCConnection");

    hr = crCertServerRequest(
			hRPCCertServer,
			&rpcAuthProtocol,
			Flags,
			pwszAuthority,
			&csEnroll.RequestId,
			&csEnroll.Disposition,
			&ctbAttrib,
			&ctbSerial,
			&ctbRequest,
			&ctbCertChain,
			&ctbCert,
			&ctbDispositionMessage);
    _JumpIfError(hr, error, "crCertServerRequest");

    csEnroll.hrLastStatus = hr;
    if (FAILED(csEnroll.Disposition))
    {
	csEnroll.hrLastStatus = csEnroll.Disposition;
	csEnroll.Disposition = CR_DISP_DENIED;
    }

    cbAlloc = sizeof(*pcsEnroll) +
		DWORDROUND(ctbCert.cb) +
		DWORDROUND(ctbCertChain.cb) +
		DWORDROUND(ctbDispositionMessage.cb);

    pcsEnroll = (CERTSERVERENROLL *) LocalAlloc(LMEM_FIXED, cbAlloc);
    if (NULL == pcsEnroll)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    *pcsEnroll = csEnroll;	// structure copy

    pbOut = (BYTE *) &pcsEnroll[1];
    if (0 != ctbCert.cb)
    {
	CSASSERT(NULL != ctbCert.pb);
	pcsEnroll->pbCert = pbOut;
	pcsEnroll->cbCert = ctbCert.cb;
	CopyMemory(pbOut, ctbCert.pb, ctbCert.cb);
	pbOut += DWORDROUND(ctbCert.cb);
    }
    if (0 != ctbCertChain.cb)
    {
	CSASSERT(NULL != ctbCertChain.pb);
	pcsEnroll->pbCertChain = pbOut;
	pcsEnroll->cbCertChain = ctbCertChain.cb;
	CopyMemory(pbOut, ctbCertChain.pb, ctbCertChain.cb);
	pbOut += DWORDROUND(ctbCertChain.cb);
    }
    if (0 != ctbDispositionMessage.cb)
    {
	CSASSERT(NULL != ctbDispositionMessage.pb);
	pcsEnroll->pwszDispositionMessage = (WCHAR *) pbOut;
	CopyMemory(pbOut, ctbDispositionMessage.pb, ctbDispositionMessage.cb);
	pbOut += DWORDROUND(ctbDispositionMessage.cb);
    }
    CSASSERT(pbOut == &((BYTE *) pcsEnroll)[cbAlloc]);

    *ppcsEnroll = pcsEnroll;

error:
    if (NULL != ctbCert.pb)
    {
	MIDL_user_free(ctbCert.pb);
    }
    if (NULL != ctbCertChain.pb)
    {
	MIDL_user_free(ctbCertChain.pb);
    }
    if (NULL != ctbDispositionMessage.pb)
    {
	MIDL_user_free(ctbDispositionMessage.pb);
    }
    crCloseRPCConnection(&hRPCCertServer);
    return(hr);
}


HRESULT
CertServerSubmitRequest(
    IN DWORD Flags,
    IN BYTE const *pbRequest,
    IN DWORD cbRequest,
    OPTIONAL IN WCHAR const *pwszRequestAttributes,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszAuthority,
    OUT CERTSERVERENROLL **ppcsEnroll) // free via CertServerFreeMemory
{
    HRESULT hr;

    if (NULL == pbRequest)
    {
        hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    if (CR_IN_BINARY != (CR_IN_ENCODEMASK & Flags))
    {
	hr = E_INVALIDARG;
        _JumpError(hr, error, "not CR_IN_BINARY");
    }
    hr = crRequestCertificate(
			Flags,
			pbRequest,
			cbRequest,
			0,		// RequestId
			pwszRequestAttributes,
			NULL,		// pwszSerialNumber
			pwszServerName,
			pwszAuthority,
			ppcsEnroll);
    _JumpIfError(hr, error, "crRequestCertificate");

error:
    return(hr);
}


HRESULT
CertServerRetrievePending(
    IN DWORD RequestId,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    IN WCHAR const *pwszServerName,
    IN WCHAR const *pwszAuthority,
    OUT CERTSERVERENROLL **ppcsEnroll) // free via CertServerFreeMemory
{
    HRESULT hr;

    if ((0 == RequestId) ^ (NULL != pwszSerialNumber))
    {
	hr = E_INVALIDARG;
        _JumpError(hr, error, "use RequestId OR pwszSerialNumber");
    }
    hr = crRequestCertificate(
			0,		// Flags
			NULL,		// pbRequest
			0,		// cbRequest
			RequestId,
			NULL,		// pwszRequestAttributes
			pwszSerialNumber,
			pwszServerName,
			pwszAuthority,
			ppcsEnroll);
    _JumpIfError(hr, error, "crRequestCertificate");

error:
    return(hr);
}


VOID
CertServerFreeMemory(
    IN VOID *pv)
{
    LocalFree(pv);
}


//+--------------------------------------------------------------------------
// CCertRequest::~CCertRequest -- destructor
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

CCertRequest::~CCertRequest()
{
    _Cleanup();
}


//+--------------------------------------------------------------------------
// CCertRequest::_CleanupOldConnection -- free memory
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertRequest::_CleanupOldConnection()
{
    // bytes returned from interfaces are MIDL_user_allocate

    _CleanupCAPropInfo();

    if (NULL != m_pwszDispositionMessage)
    {
        MIDL_user_free(m_pwszDispositionMessage);
	m_pwszDispositionMessage = NULL;
    }
    if (NULL != m_pbCert)
    {
        MIDL_user_free(m_pbCert);
	m_pbCert = NULL;
    }
    if (NULL != m_pbCertificateChain)
    {
        MIDL_user_free(m_pbCertificateChain);
	m_pbCertificateChain = NULL;
    }
    if (NULL != m_pbFullResponse)
    {
        MIDL_user_free(m_pbFullResponse);
	m_pbFullResponse = NULL;
    }
    if (NULL != m_pbRequest)
    {
    	LocalFree(m_pbRequest);
    	m_pbRequest = NULL;
    }
    if (NULL != m_rgResponse)
    {
	FreeCMCResponse(m_rgResponse, m_cResponse);
	m_rgResponse = NULL;
    }
    if (NULL != m_hStoreResponse)
    {
	CertCloseStore(m_hStoreResponse, CERT_CLOSE_STORE_CHECK_FLAG);
	m_hStoreResponse = NULL;
    }
    m_cResponse = 0;
    m_LastStatus = S_OK;
    m_RequestId = 0;
    m_Disposition = 0;
    _CleanupCAPropInfo();
}


//+--------------------------------------------------------------------------
// CCertRequest::_Cleanup -- free memory
//
// free memory associated with this instance
//+--------------------------------------------------------------------------

VOID
CCertRequest::_Cleanup()
{
    _CloseConnection();
    _CleanupOldConnection();
}


//+--------------------------------------------------------------------------
// CCertRequest::_OpenRPCConnection -- establish RPC connection
//
// establish RPC connection
//+--------------------------------------------------------------------------

HRESULT
CCertRequest::_OpenRPCConnection(
    IN WCHAR const *pwszConfig,
    OUT BOOL *pfNewConnection,
    OUT WCHAR const **ppwszAuthority)
{
    HRESULT hr;
    WCHAR *pwszServerName = NULL;
    WCHAR *pwsz;
    DWORD cwc;

    CSASSERT(NULL != pwszConfig && NULL != pfNewConnection);

    *pfNewConnection = FALSE;
    pwsz = wcschr(pwszConfig, L'\\');
    if (NULL == pwsz)
    {
        cwc = wcslen(pwszConfig);
        *ppwszAuthority = &pwszConfig[cwc];
    }
    else
    {
        cwc = SAFE_SUBTRACT_POINTERS(pwsz, pwszConfig);
        *ppwszAuthority = &pwsz[1];
    }
    pwszServerName = (WCHAR *) LocalAlloc(
				    LMEM_FIXED,
				    (cwc + 1) * sizeof(WCHAR));
    if (NULL == pwszServerName)
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
    }
    CopyMemory(pwszServerName, pwszConfig, cwc * sizeof(WCHAR));
    pwszServerName[cwc] = L'\0';

    if (NULL == m_hRPCCertServer ||
        NULL == m_pwszServerName ||
        0 != mylstrcmpiL(pwszServerName, m_pwszServerName))
    {
        _CloseConnection();
        CSASSERT(NULL == m_pwszServerName);
        m_pwszServerName = pwszServerName;
        pwszServerName = NULL;

	hr = crOpenRPCConnection(
			    m_pwszServerName,
			    &m_rpcAuthProtocol,
			    &m_hRPCCertServer);
        _JumpIfError(hr, error, "crOpenRPCConnection");

	*pfNewConnection = TRUE;
    }
    hr = S_OK;

error:
    if (S_OK != hr)
    {
	_CloseConnection();
	hr = myHError(hr);
    }
    if (NULL != pwszServerName)
    {
        LocalFree(pwszServerName);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertRequest::_OpenConnection -- establish RPC connection
//
//+--------------------------------------------------------------------------

HRESULT
CCertRequest::_OpenConnection(
    IN BOOL fRPC,
    IN WCHAR const *pwszConfig,
    IN DWORD RequiredVersion,
    OUT WCHAR const **ppwszAuthority)
{
    HRESULT hr;
    BOOL fNewConnection = FALSE;

    if (NULL == pwszConfig)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "pwszConfig");
    }
    if (fRPC)
    {
        if (NULL != m_pICertRequestD)
        {
	    _CloseConnection();		// switching to RPC
        }
        hr = _OpenRPCConnection(pwszConfig, &fNewConnection, ppwszAuthority);
        _JumpIfError(hr, error, "_OpenRPCConnection");

	CSASSERT(NULL != m_hRPCCertServer);
	CSASSERT(0 == m_dwServerVersion);
    }
    else
    {
        if (NULL != m_hRPCCertServer)
        {
            _CloseConnection();		// switching to DCOM
        }
	hr = myOpenRequestDComConnection(
			    pwszConfig,
			    ppwszAuthority,
			    &m_pwszServerName,
			    &fNewConnection,
			    &m_dwServerVersion,
			    &m_pICertRequestD);
	_JumpIfError(hr, error, "myOpenRequestDComConnection");

	CSASSERT(NULL != m_pICertRequestD);
	CSASSERT(0 != m_dwServerVersion);
    }
    if (m_dwServerVersion < RequiredVersion)
    {
	hr = RPC_E_VERSION_MISMATCH;
	_JumpError(hr, error, "old server");
    }
    if (fNewConnection)
    {
	_CleanupOldConnection();
    }

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertRequest::_CloseConnection -- release DCOM object
//
//+--------------------------------------------------------------------------

VOID
CCertRequest::_CloseConnection()
{
    crCloseRPCConnection(&m_hRPCCertServer);
    myCloseDComConnection((IUnknown **) &m_pICertRequestD, &m_pwszServerName);
    m_dwServerVersion = 0;
}


//+--------------------------------------------------------------------------
// CCertRequest::Submit -- Submit a cert request and return the disposition.
//
// Submit the passed certificate request to the Certificate Server and retrieve
// the certificate from the server, if it is immediately available.  If the
// returned disposition so indicates, other CCertRequest methods may be called
// to return the certificate or certificate chain to the caller.
//
// All state from previous method calls is cleared.
//
// After the Submit method completes execution, the GetDispositionMessage and
// GetLastStatus methods may be called to retrieve informational disposition
// text and a more specific error code.
//
// Flags contains flags that describe the input data format as defined above.
//
// strRequest points to the input request data, in base64-encoded form.
//
// strAttributes is optional.  When non-NULL, it points to a string containing
// attribute value pairs, one pair per line.  The attribute name and value
// strings may contain any text of the caller's choosing.  Only the syntax of a
// colon-separated attribute name and value string followed by a newline is
// enforced.  Attribute names that are not understood by the Certificate Server
// will be available to Policy Modules, but are otherwise ignored by the
// Certificate Server.
// Example:
//      "Phone: 0424-12-3456\r\nServer: Microsoft Key Manager for IIS 2.0\r\n"
//      "Version: 3\r\nRequestType: Client\r\n"
//
// strConfig points to a string that contains the server name and Certificate
// Authority name.  See the ICertConfig interface.
//
// pDisposition points to the returned disposition of the request as defined
// above. When the request cannot be immediately granted or denied (some off-
// line processing may be required), *pDisposition is set to
// CR_DISP_UNDER_SUBMISSION.  After CR_DISP_UNDER_SUBMISSION is returned for
// the initial request's disposition, the RetrievePending method may be called
// to interrogate the disposition again and to retrieve the certificate if it
// has been issued.  If the returned disposition so indicates, RetrievePending
// will retrieve the certificate and allow the other methods defined here to
// return the certificate to the caller.  If denied, the appropriate
// disposition code will be returned.  If the request has still not been
// processed, CR_DISP_UNDER_SUBMISSION will again be returned by the
// RetrievePending method.
//
// Returns S_OK if the method completed execution.  Errors are indicated by
// the returned disposition.
//+--------------------------------------------------------------------------


STDMETHODIMP
CCertRequest::Submit(
    /* [in] */ LONG Flags,
    /* [in] */ BSTR const strRequest,
    /* [in] */ BSTR const strAttributes,
    /* [in] */ BSTR const strConfig,
    /* [out, retval] */ LONG __RPC_FAR *pDisposition)
{
    HRESULT hr;

    if ((NULL == strRequest) || (NULL == pDisposition))
    {
	hr = E_POINTER;
	_JumpError(hr, error, "strRequest or pDisposition");
    }
    hr = _RequestCertificate(
			Flags,
			0,				// RequestId
			strRequest,
			strAttributes,
			NULL,				// pwszSerialNumber
			strConfig,
			(CR_IN_RPC & Flags)? 0 : 1,	// RequiredVersion
			pDisposition);
    _JumpIfError2(
	    hr,
	    error,
	    "_RequestCertificate",
	    HRESULT_FROM_WIN32(ERROR_INVALID_DATA));

error:
    return(_SetErrorInfo(hr, L"CCertRequest::Submit"));
}


//+--------------------------------------------------------------------------
// CCertRequest::RetrievePending -- Retrieve pending request disposition.
//
// Interrogate the Certificate Server and retrieve the certificate identified
// by the passed RequestId, if it is now available.  If the returned
// disposition so indicates, other CCertRequest methods may be called to return
// the certificate or certificate chain to the caller.
//
// All state from previous method calls is cleared.
//
// After the RetrievePending method completes execution, the
// GetDispositionMessage and GetLastStatus methods may be called to retrieve
// informational disposition text and a more specific error code.
//
// RequestId identifies a previously submitted request.
//
// strConfig points to a string that contains the server name and Certificate
// Authority name.  
//
// pDisposition points to the returned disposition of the pending request.
//
// Returns S_OK if the method completed execution.  Errors are indicated by
// the returned disposition.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertRequest::RetrievePending(
    /* [in] */ LONG RequestId,
    /* [in] */ BSTR const strConfig,
    /* [out, retval] */ LONG __RPC_FAR *pDisposition)
{
    HRESULT hr;
    BSTR strConfigT = strConfig;
    WCHAR *pwszSerialNumber = NULL;

    if (NULL == pDisposition || NULL == strConfig)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL param");
    }
    if (0 == RequestId)
    {
	DWORD cwc;
	
	pwszSerialNumber = wcschr(strConfigT, L'\\');
	if (NULL != pwszSerialNumber)
	{
	    pwszSerialNumber = wcschr(&pwszSerialNumber[1], L'\\');
	}
	if (NULL == pwszSerialNumber)
	{
	    hr = E_INVALIDARG;
	    _JumpError(hr, error, "Missing SerialNumber");
	}

	cwc = SAFE_SUBTRACT_POINTERS(pwszSerialNumber, strConfigT);
	pwszSerialNumber++;
	strConfigT = SysAllocStringLen(strConfigT, cwc);
	if (NULL == strConfigT)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "SysAllocStringLen");
	}
    }
    hr = _RequestCertificate(
			0,			// Flags
			RequestId,
			NULL,			// strRequest
			NULL,			// strAttributes
			pwszSerialNumber,
			strConfigT,
			1,			// RequiredVersion
			pDisposition);
    _JumpIfError(hr, error, "_RequestCertificate");

error:
    if (NULL != strConfigT && strConfig != strConfigT)
    {
	SysFreeString(strConfigT);
    }
    return(_SetErrorInfo(hr, L"CCertRequest::RetrievePending"));
}


//+--------------------------------------------------------------------------
// CCertRequest::GetIssuedCertificate -- Get an issued Certificate
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertRequest::GetIssuedCertificate(
    /* [in] */ const BSTR strConfig,
    /* [in] */ LONG RequestId,
    /* [in] */ const BSTR strSerialNumber,		// OPTIONAL
    /* [out, retval] */ LONG __RPC_FAR *pDisposition)
{
    HRESULT hr;
    WCHAR const *pwszSerialNumber = NULL;

    if (NULL == pDisposition || NULL == strConfig)
    {
        hr = E_POINTER;
        _JumpError(hr, error, "NULL param");
    }

    // VB callers pass "" instead of NULL, so treat them identically.

    if (NULL != strSerialNumber && L'\0' != *strSerialNumber)
    {
	pwszSerialNumber = strSerialNumber;
    }
    hr = _RequestCertificate(
			0,			// Flags
			RequestId,
			NULL,			// strRequest
			NULL,			// strAttributes
			pwszSerialNumber,	// pwszSerialNumber
			strConfig,
			2,			// RequiredVersion
			pDisposition);
    _JumpIfError(hr, error, "_RequestCertificate");

error:
    return(_SetErrorInfo(hr, L"CCertRequest::GetIssuedCertificate"));
}


//+--------------------------------------------------------------------------
// CCertRequest::_RequestCertificate -- Submit the request
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertRequest::_RequestCertificate(
    IN LONG Flags,
    IN LONG RequestId,
    OPTIONAL IN BSTR const strRequest,
    OPTIONAL IN BSTR const strAttributes,
    OPTIONAL IN WCHAR const *pwszSerialNumber,
    IN BSTR const strConfig,
    IN DWORD RequiredVersion,
    OUT LONG *pDisposition)
{
    HRESULT hr;
    WCHAR const *pwszAuthority;
    WCHAR *pwszAttrib = strAttributes;
    WCHAR *pwszAttribAlloc = NULL;
    BYTE *pbT = NULL;
    CERTTRANSBLOB ctbRequest = { 0, NULL };
    CERTTRANSBLOB ctbCert = { 0, NULL };
    CERTTRANSBLOB ctbCertChain = { 0, NULL };
    CERTTRANSBLOB ctbFullResponse = { 0, NULL };
    CERTTRANSBLOB ctbDispositionMessage = { 0, NULL };
    DWORD adwEncode[] = { CR_IN_BASE64HEADER, CR_IN_BASE64, CR_IN_BINARY };
    DWORD dwEncode;
    DWORD *pdwEncode;
    DWORD cEncode;
    WCHAR *pwszDnsName = NULL;

    if (NULL == pDisposition)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    _Cleanup();
    *pDisposition = CR_DISP_INCOMPLETE;

    hr = _OpenConnection(
		    (CR_IN_RPC & Flags)? TRUE : FALSE,
		    strConfig,
		    RequiredVersion,
		    &pwszAuthority);
    _JumpIfError(hr, error, "_OpenConnection");

    // If a new request, point at the attributes & decode the Base64 request.

    if (NULL != strRequest)
    {
	DWORD cchHeader;
	DWORD cwc;
	WCHAR *pch;

	CSASSERT(CR_IN_BASE64HEADER == CRYPT_STRING_BASE64HEADER);
	CSASSERT(CR_IN_BASE64 == CRYPT_STRING_BASE64);
	CSASSERT(CR_IN_BINARY == CRYPT_STRING_BINARY);

	hr = myGetMachineDnsName(&pwszDnsName);
	_JumpIfError(hr, error, "myGetMachineDnsName");

	dwEncode = CR_IN_ENCODEMASK & Flags;
	switch (dwEncode)
	{
	    case CR_IN_BASE64HEADER:
	    case CR_IN_BASE64:
	    case CR_IN_BINARY:
		cEncode = 1;
		pdwEncode = &dwEncode;
		break;

	    case CR_IN_ENCODEANY:
		cEncode = ARRAYSIZE(adwEncode);
		pdwEncode = adwEncode;
		break;

	    default:
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Flags");
	}
	while (TRUE)
	{
	    hr = DecodeCertString(
			strRequest,
			*pdwEncode,
			&m_pbRequest,
			(DWORD *) &m_cbRequest);
	    if (S_OK == hr)
	    {
		Flags = (~CR_IN_ENCODEMASK & Flags) | *pdwEncode;
		break;
	    }
	    if (1 == cEncode || HRESULT_FROM_WIN32(ERROR_INVALID_DATA) != hr)
	    {
		_JumpError(hr, error, "DecodeCertString");
	    }
	    _PrintErrorStr2(
			hr,
			"DecodeCertString",
			L"CR_IN_ENCODEANY",
			HRESULT_FROM_WIN32(ERROR_INVALID_DATA));
	    cEncode--;
	    pdwEncode++;
	}
	CSASSERT(0 < cEncode);
	CSASSERT(S_OK == hr);

	ctbRequest.pb = m_pbRequest;
	ctbRequest.cb = m_cbRequest;

	cchHeader = 0;
	if (CR_IN_BASE64HEADER == *pdwEncode)
	{
	    DWORD cb;

	    hr = myCryptStringToBinary(
				strRequest,
				wcslen(strRequest),
				CRYPT_STRING_BASE64HEADER,
				&pbT,
				&cb,
				&cchHeader,
				NULL);
	    if (S_OK != hr)
	    {
		cchHeader = 0;
	    }
	}
	cwc = cchHeader;
	if (NULL != pwszAttrib)
	{
	    cwc += 1 + wcslen(pwszAttrib);
	}
	cwc += 1 + WSZARRAYSIZE(wszPROPCERTCLIENTMACHINE) + 1 + wcslen(pwszDnsName);
	pwszAttribAlloc = (WCHAR *) LocalAlloc(
					LMEM_FIXED,
					(cwc + 1) * sizeof(WCHAR));
	if (NULL == pwszAttribAlloc)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "alloc attributes");
	}
	pch = pwszAttribAlloc;
	if (0 != cchHeader)
	{
	    CopyMemory(pch, strRequest, cchHeader * sizeof(WCHAR));
	    pch += cchHeader;
	}
	*pch = L'\0';
	if (NULL != pwszAttrib)
	{
	    *pch++ = L'\n';
	    wcscpy(pch, (WCHAR const *) pwszAttrib);
	}
	wcscat(pch, L"\n" wszPROPCERTCLIENTMACHINE L":");
	wcscat(pch, pwszDnsName);
	CSASSERT(wcslen(pwszAttribAlloc) == cwc);

	pwszAttrib = pwszAttribAlloc;
    }
    m_RequestId = RequestId;

    __try
    {
	Flags |= CR_IN_FULLRESPONSE;
	if (NULL != m_hRPCCertServer)
	{
	    CERTTRANSBLOB ctbAttrib;
	    CERTTRANSBLOB ctbSerial;

	    ctbAttrib.cb = 0;
	    ctbAttrib.pb = (BYTE *) pwszAttrib;
	    if (NULL != pwszAttrib)
	    {
		ctbAttrib.cb = (wcslen(pwszAttrib) + 1) * sizeof(WCHAR);
	    }

	    ctbSerial.cb = 0;
	    ctbSerial.pb = (BYTE *) pwszSerialNumber;
	    if (NULL != pwszSerialNumber)
	    {
		ctbAttrib.cb = (wcslen(pwszSerialNumber) + 1) * sizeof(WCHAR);
	    }

	    hr = crCertServerRequest(
			    m_hRPCCertServer,
			    &m_rpcAuthProtocol,
			    Flags,
			    pwszAuthority,
			    (DWORD *) &m_RequestId,
			    (DWORD *) &m_Disposition,
			    &ctbAttrib,
			    &ctbSerial,
			    &ctbRequest,
			    &ctbCertChain,
			    &ctbCert,
			    &ctbDispositionMessage);
	    _PrintIfError(hr, "crCertServerRequest");
	}
	else
	{
	    if (2 <= m_dwServerVersion)
	    {
		hr = m_pICertRequestD->Request2(
				pwszAuthority,
				Flags,
				pwszSerialNumber,
				(DWORD *) &m_RequestId,
				(DWORD *) &m_Disposition,
				pwszAttrib,
				&ctbRequest,
				&ctbFullResponse,
				&ctbCert,
				&ctbDispositionMessage);
		_PrintIfError(hr, "m_pICertRequestD->Request2");
	    }
	    else
	    {
		Flags &= ~CR_IN_FULLRESPONSE;
		hr = m_pICertRequestD->Request(
				Flags,
				pwszAuthority,
				(DWORD *) &m_RequestId,
				(DWORD *) &m_Disposition,
				pwszAttrib,
				&ctbRequest,
				&ctbCertChain,
				&ctbCert,
				&ctbDispositionMessage);
		_PrintIfError(hr, "m_pICertRequestD->Request");
	    }

	    // Midl_user_allocate registers memory in RPC case

	    if (NULL != ctbCertChain.pb)
	    {
		myRegisterMemAlloc(
				ctbCertChain.pb,
				ctbCertChain.cb,
				CSM_COTASKALLOC);
	    }
	    if (NULL != ctbFullResponse.pb)
	    {
		myRegisterMemAlloc(
				ctbFullResponse.pb,
				ctbFullResponse.cb,
				CSM_COTASKALLOC);
	    }
	    if (NULL != ctbCert.pb)
	    {
		myRegisterMemAlloc(ctbCert.pb, ctbCert.cb, CSM_COTASKALLOC);
	    }
	    if (NULL != ctbDispositionMessage.pb)
	    {
		myRegisterMemAlloc(
			    ctbDispositionMessage.pb,
			    ctbDispositionMessage.cb,
			    CSM_COTASKALLOC);
	    }
	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

    if (HRESULT_FROM_WIN32(RPC_X_WRONG_STUB_VERSION) == hr)
    {
	_PrintError(hr, "Compile with MIDL_NO_ROBUST=1 to run on NT 4");
    }

    m_LastStatus = hr;
    _JumpIfError(hr, error, "Request");

    if (FAILED(m_Disposition))
    {
	m_LastStatus = m_Disposition;
	m_Disposition = CR_DISP_DENIED;
    }

    *pDisposition = m_Disposition;
    m_pbCertificateChain = ctbCertChain.pb;     // CoTaskMem*
    m_cbCertificateChain = ctbCertChain.cb;
    m_pbFullResponse = ctbFullResponse.pb;	// CoTaskMem*
    m_cbFullResponse = ctbFullResponse.cb;
    m_pbCert = ctbCert.pb;      		// CoTaskMem*
    m_cbCert = ctbCert.cb;
    m_pwszDispositionMessage = (WCHAR *) ctbDispositionMessage.pb;  // CoTaskMem*
    CSASSERT(0 == (ctbDispositionMessage.cb & (sizeof(WCHAR) - 1)));
    CSASSERT(
	NULL == m_pwszDispositionMessage ||
	L'\0' ==
	m_pwszDispositionMessage[ctbDispositionMessage.cb/sizeof(WCHAR) - 1]);

    if (S_OK == hr && NULL != ctbFullResponse.pb)
    {
	hr = ParseCMCResponse(
			m_pbFullResponse,
			m_cbFullResponse,
			&m_hStoreResponse,
			&m_rgResponse,
			&m_cResponse);
#if 0 // When all Whistler servers are upgraded to return full responses...
	if (S_OK != hr && NULL != m_hRPCCertServer)
#else
	if (S_OK != hr)
#endif
	{
	    // Must be an old RPC cert server that ignored CR_IN_FULLRESPONSE,
	    // and returned a PKCS7 chain instead.

	    CSASSERT(NULL == m_pbCertificateChain);
	    m_pbCertificateChain = m_pbFullResponse;
	    m_cbCertificateChain = m_cbFullResponse;
	    m_pbFullResponse = NULL;
	    m_cbFullResponse = 0;
	    hr = S_OK;
	}
	_JumpIfError(hr, error, "ParseCMCResponse");
    }

error:
    if (NULL != pwszDnsName)
    {
        LocalFree(pwszDnsName);
    }
    if (NULL != pwszAttribAlloc)
    {
	LocalFree(pwszAttribAlloc);
    }
    if (NULL != pbT)
    {
	LocalFree(pbT);
    }
    return(myHError(hr));
}


//+--------------------------------------------------------------------------
// CCertRequest::GetLastStatus -- Get the status of the last request
//
// One of the Submit, RetrievePending or GetCACertificate methods must
// have been previously called for the returned status to be meaningful.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertRequest::GetLastStatus(
    /* [out, retval] */ LONG __RPC_FAR *pLastStatus)
{
    HRESULT hr;

    if (NULL == pLastStatus)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pLastStatus");
    }
    *pLastStatus = m_LastStatus;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CCertRequest::GetLastStatus"));
}


//+--------------------------------------------------------------------------
// CCertRequest::GetRequestId -- Get the RequestId of the last request
//
// The Submit or RetrievePending method must have been previously called for
// the returned RequestId to be meaningful.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertRequest::GetRequestId(
    /* [out, retval] */ LONG __RPC_FAR *pRequestId)
{
    HRESULT hr;

    if (NULL == pRequestId)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pRequestId");
    }
    *pRequestId = m_RequestId;
    hr = S_OK;

error:
    return(_SetErrorInfo(hr, L"CCertRequest::GetRequestId"));
}


//+--------------------------------------------------------------------------
// CCertRequest::GetDispositionMessage -- Get the Disposition Message
//
// The Submit or RetrievePending method must have been previously called for
// the returned disposition message text to be meaningful.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertRequest::GetDispositionMessage(
    /* [out, retval] */ BSTR __RPC_FAR *pstrDispositionMessage)
{
    HRESULT hr = S_OK;

    if (NULL == pstrDispositionMessage)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pstrDispositionMessage");
    }
    if (NULL != *pstrDispositionMessage)
    {
	SysFreeString(*pstrDispositionMessage);
	*pstrDispositionMessage = NULL;
    }
    if (NULL != m_pwszDispositionMessage)
    {
	if (!ConvertWszToBstr(
			pstrDispositionMessage,
			m_pwszDispositionMessage,
			-1))
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "ConvertWszToBstr");
	}
    }

error:
    return(_SetErrorInfo(hr, L"CCertRequest::GetDispositionMessage"));
}


//+--------------------------------------------------------------------------
// CCertRequest::_BuildIssuedCertificateChain -- Build issued cert chain
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertRequest::_BuildIssuedCertificateChain(
    OPTIONAL IN BYTE const *pbCertHash,
    IN DWORD cbCertHash,
    IN BOOL fIncludeCRLs,
    OUT BYTE **ppbCertChain,
    OUT DWORD *pcbCertChain)
{
    HRESULT hr;
    CERT_CONTEXT const *pccIssued = NULL;
    CERT_CHAIN_PARA CertChainPara;
    CERT_CHAIN_CONTEXT const *pCertChainContext = NULL;
    CERT_SIMPLE_CHAIN *pSimpleChain;
    CRYPT_SIGN_MESSAGE_PARA csmp;
    CRYPT_ALGORITHM_IDENTIFIER DigestAlgorithm = { szOID_OIWSEC_sha1, 0, 0 };
    CERT_CONTEXT const **ppcc;
    DWORD i;

    *ppbCertChain = NULL;

    // init csmp for empty signature

    ZeroMemory(&csmp, sizeof(csmp));
    csmp.cbSize = sizeof(csmp);
    csmp.dwMsgEncodingType = PKCS_7_ASN_ENCODING;
    //csmp.pSigningCert = NULL;
    csmp.HashAlgorithm = DigestAlgorithm;
    //csmp.cMsgCert = 0;
    //csmp.rgpMsgCert = NULL;
    //csmp.cMsgCrl = 0;
    //csmp.rgpMsgCrl = NULL;

    hr = _FindIssuedCertificate(pbCertHash, cbCertHash, &pccIssued);
    _JumpIfError(hr, error, "_FindIssuedCertificate");

    // build the user cert chain

    ZeroMemory(&CertChainPara, sizeof(CertChainPara));
    CertChainPara.cbSize = sizeof(CertChainPara);

    if (!CertGetCertificateChain(
			    HCCE_LOCAL_MACHINE,
			    pccIssued,
			    NULL,		// pTime
			    m_hStoreResponse,
			    &CertChainPara,
			    fIncludeCRLs? 
				CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT :
				0,
			    NULL,		// pvReserved
			    &pCertChainContext))
    {
	hr = myHLastError();
	_JumpError(hr, error, "CertGetCertificateChain");
    }

    // make sure there is at least 1 simple chain

    if (0 == pCertChainContext->cChain)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "No user chain");
    }
    pSimpleChain = pCertChainContext->rgpChain[0];

    csmp.cMsgCert = pSimpleChain->cElement;
    if (0 == csmp.cMsgCert)
    {
	hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
	_JumpError(hr, error, "no certs");
    }

    csmp.rgpMsgCert = (CERT_CONTEXT const **) LocalAlloc(
				LMEM_FIXED,
				csmp.cMsgCert * sizeof(csmp.rgpMsgCert[0]));
    if (NULL == csmp.rgpMsgCert)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    if (fIncludeCRLs)
    {
	csmp.rgpMsgCrl = (CRL_CONTEXT const **) LocalAlloc(
				LMEM_FIXED,
				2 * csmp.cMsgCert * sizeof(csmp.rgpMsgCrl[0]));
	if (NULL == csmp.rgpMsgCrl)
	{
	    hr = E_OUTOFMEMORY;
	    _JumpError(hr, error, "LocalAlloc");
	}
    }

    ppcc = csmp.rgpMsgCert;
    for (i = 0; i < csmp.cMsgCert; i++)
    {
	*ppcc++ = pSimpleChain->rgpElement[i]->pCertContext;
	if (fIncludeCRLs)
	{
	    CERT_REVOCATION_INFO *pRevocationInfo;

	    pRevocationInfo = pSimpleChain->rgpElement[i]->pRevocationInfo;

	    if (NULL != pRevocationInfo &&
		CCSIZEOF_STRUCT(CERT_REVOCATION_INFO, pCrlInfo) <=
		    pRevocationInfo->cbSize &&
		NULL != pRevocationInfo->pCrlInfo)
	    {
		CERT_REVOCATION_CRL_INFO *pCrlInfo;

		pCrlInfo = pRevocationInfo->pCrlInfo;
		if (NULL != pCrlInfo)
		{
		    if (NULL != pCrlInfo->pBaseCrlContext)
		    {
			csmp.rgpMsgCrl[csmp.cMsgCrl++] = pCrlInfo->pBaseCrlContext;
		    }
		    if (NULL != pCrlInfo->pDeltaCrlContext)
		    {
			csmp.rgpMsgCrl[csmp.cMsgCrl++] = pCrlInfo->pDeltaCrlContext;
		    }
		}
	    }
	}
    }
    CSASSERT(csmp.cMsgCrl <= 2 * csmp.cMsgCert);

    if (!myCryptSignMessage(
			&csmp,
			pccIssued->pbCertEncoded,
			pccIssued->cbCertEncoded,
			CERTLIB_USE_LOCALALLOC,
			ppbCertChain,
			pcbCertChain))
    {
	hr = myHLastError();
	_JumpError(hr, error, "myCryptSignMessage");
    }
    hr = S_OK;

error:
    if (NULL != csmp.rgpMsgCert)
    {
	LocalFree(csmp.rgpMsgCert);
    }
    if (NULL != csmp.rgpMsgCrl)
    {
	LocalFree(csmp.rgpMsgCrl);
    }
    if (NULL != pccIssued)
    {
	CertFreeCertificateContext(pccIssued);
    }
    if (NULL != pCertChainContext)
    {
        CertFreeCertificateChain(pCertChainContext);
    }
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertRequest::_FindIssuedCertificate -- Find Issued cert in store.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

HRESULT
CCertRequest::_FindIssuedCertificate(
    OPTIONAL IN BYTE const *pbCertHash,
    IN DWORD cbCertHash,
    OUT CERT_CONTEXT const **ppccIssued)
{
    HRESULT hr;
    CRYPT_HASH_BLOB BlobHash;

    *ppccIssued = NULL;

    if (NULL == pbCertHash)
    {
	if (1 < m_cResponse || NULL == m_pbCert)
	{
	    hr = CERTSRV_E_PROPERTY_EMPTY;
	    _JumpError(hr, error, "no cert");
	}
	*ppccIssued = CertCreateCertificateContext(
				    X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
				    m_pbCert,
				    m_cbCert);
	if (NULL == *ppccIssued)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertCreateCertificateContext");
	}
    }
    else
    {
	BlobHash.pbData = const_cast<BYTE *>(pbCertHash);
	BlobHash.cbData = cbCertHash;

	*ppccIssued = CertFindCertificateInStore(
				m_hStoreResponse,
				X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
				0,			// dwFindFlags
				CERT_FIND_HASH,
				&BlobHash,		// pvFindPara
				NULL);		// pPrevCertContext
	if (NULL == *ppccIssued)
	{
	    hr = myHLastError();
	    _JumpError(hr, error, "CertFindCertificateInStore");
	}
    }
    hr = S_OK;

error:
    return(hr);
}


//+--------------------------------------------------------------------------
// CCertRequest::GetCertificate -- Get the Certificate encoding as requested
//
// The Submit or RetrievePending method must have previously returned
// CR_DISP_ISSUED, or this method will fail.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertRequest::GetCertificate(
    /* [in] */ LONG Flags,
    /* [out, retval] */ BSTR __RPC_FAR *pstrCertificate)
{
    HRESULT hr;
    BYTE *pbChain = NULL;
    DWORD cbChain;
    BYTE *pbCert;
    DWORD cbCert;

    if (NULL == pstrCertificate)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pstrCertificate");
    }
    pbCert = m_pbCert;
    cbCert = m_cbCert;
    if (CR_OUT_CHAIN & Flags)
    {
	pbCert = m_pbCertificateChain;
	cbCert = m_cbCertificateChain;
	if (NULL == m_pbCertificateChain)
	{
	    hr = _BuildIssuedCertificateChain(
					NULL,		// pbCertHash
					0,		// cbCertHash
					0 != (CR_OUT_CRLS & Flags),
					&pbChain,
					&cbChain);
	    _JumpIfError(hr, error, "_BuildIssuedCertificateChain");

	    pbCert = pbChain;
	    cbCert = cbChain;
	}
    }

    CSASSERT(CR_OUT_BASE64HEADER == CRYPT_STRING_BASE64HEADER);
    CSASSERT(CR_OUT_BASE64 == CRYPT_STRING_BASE64);
    CSASSERT(CR_OUT_BINARY == CRYPT_STRING_BINARY);

    hr = EncodeCertString(
		    pbCert,
		    cbCert,
		    ~(CR_OUT_CHAIN | CR_OUT_CRLS) & Flags,
		    pstrCertificate);
    _JumpIfError(hr, error, "EncodeCertString");

error:
    if (NULL != pbChain)
    {
	LocalFree(pbChain);
    }
    hr = myHError(hr);
    return(_SetErrorInfo(hr, L"CCertRequest::GetCertificate"));
}


//+--------------------------------------------------------------------------
// CCertRequest::GetCACertificate -- Get the specified CA Certificate
//
// Interrogate the Certificate Server and retrieve the base64-encoded exchange
// or signature site certificate as indicated by fExchangeCertificate.
//
// All state from previous method calls is cleared.
//
// After the GetCACertificate method completes execution, the GetLastStatus
// method may be called to retrieve a more specific error code.
//
// fExchangeCertificate is TRUE to retrieve the Certificate Server's Exchange
// certificate.  fExchangeCertificate is FALSE to retrieve the Certificate
// Server's Signature site certificate.
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertRequest::GetCACertificate(
    /* [in] */ LONG fExchangeCertificate,
    /* [in] */ BSTR const strConfig,
    /* [in] */ LONG Flags,
    /* [out, retval] */ BSTR __RPC_FAR *pstrCACertificate)
{
    HRESULT hr;
    CERTTRANSBLOB ctbSite = { 0, NULL };
    WCHAR const *pwszAuthority;
    WCHAR const *pwszOut = NULL;
    CAINFO const *pCAInfo;
    BYTE *pbOut;
    BOOL fCallServer;
    DWORD Index;
    WCHAR wszBuf[5 * (10 + 1)];	// enough for 5 numbers

    if (NULL == pstrCACertificate)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "pstrCACertificate");
    }

    fCallServer = TRUE;
    pbOut = NULL;
    switch (fExchangeCertificate)
    {
	case GETCERT_ERRORTEXT1:
	case GETCERT_ERRORTEXT2:
	    pwszOut = myGetErrorMessageText(
			    Flags,	// error code passed in Flags parm
			    GETCERT_ERRORTEXT2 == fExchangeCertificate);
	    if (NULL == pwszOut)
	    {
		hr = E_OUTOFMEMORY;
		_JumpError(hr, error, "LocalAlloc");
	    }
	    Flags = CR_OUT_BINARY;
	    pbOut = (BYTE *) pwszOut;
	    fCallServer = FALSE;
	    break;
    }
    Index = MAXDWORD;
    switch (GETCERT_BYINDEXMASK & fExchangeCertificate)
    {
	case GETCERT_CACERTSTATEBYINDEX:
	case GETCERT_CRLSTATEBYINDEX:
	    if (CR_OUT_CHAIN & Flags)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Flags");
	    }
	    Index = GETCERT_INDEXVALUEMASK & fExchangeCertificate;
	    fExchangeCertificate &= ~GETCERT_INDEXVALUEMASK;

	    fCallServer =
		NULL == ((GETCERT_CACERTSTATEBYINDEX == fExchangeCertificate)?
			 m_pbCACertState : m_pbCRLState);
	    break;
    }
    if (fCallServer)
    {
	hr = _OpenConnection(FALSE, strConfig, 1, &pwszAuthority);
	_JumpIfError(hr, error, "_OpenConnection");

	if (CR_OUT_CHAIN & Flags)
	{
	    fExchangeCertificate |= GETCERT_CHAIN;
	    if (CR_OUT_CRLS & Flags)
	    {
		fExchangeCertificate |= GETCERT_CRLS;
	    }
	}

	__try
	{
	    hr = m_pICertRequestD->GetCACert(
					fExchangeCertificate,
					pwszAuthority,
					&ctbSite);
	}
	__except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
	{
	}
	_JumpIfError2(
		    hr,
		    error,
		    "GetCACert",
		    HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND));

	// must register this memory
	myRegisterMemAlloc(ctbSite.pb, ctbSite.cb, CSM_COTASKALLOC);
	pbOut = ctbSite.pb;
    }

    CSASSERT(CR_OUT_BASE64HEADER == CRYPT_STRING_BASE64HEADER);
    CSASSERT(CR_OUT_BASE64 == CRYPT_STRING_BASE64);
    CSASSERT(CR_OUT_BINARY == CRYPT_STRING_BINARY);

    switch (fExchangeCertificate)
    {
	// Serialize CAType into a string:
	
	case GETCERT_CATYPE:
	    wsprintf(wszBuf, L"%u", *(ENUM_CATYPES const *) pbOut);
	    pwszOut = wszBuf;
	    pbOut = (BYTE *) pwszOut;
	    break;

	// Serialize CAInfo into a string:
	
	case GETCERT_CAINFO:
	    pCAInfo = (CAINFO const *) pbOut;
	    if (CCSIZEOF_STRUCT(CAINFO, cCASignatureCerts) > pCAInfo->cbSize)
	    {
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
		_JumpError(hr, error, "CAINFO size");
	    }
	    wsprintf(
		wszBuf,
		L"%u,%u",
		pCAInfo->CAType,
		pCAInfo->cCASignatureCerts);
	    pwszOut = wszBuf;
	    pbOut = (BYTE *) pwszOut;
	    break;

	case GETCERT_CACERTSTATEBYINDEX:
	case GETCERT_CRLSTATEBYINDEX:
	{
	    BYTE **ppb;
	    DWORD *pcb;
	    
	    if (GETCERT_CACERTSTATEBYINDEX == fExchangeCertificate)
	    {
		ppb = &m_pbCACertState;
		pcb = &m_cbCACertState;
	    }
	    else
	    {
		ppb = &m_pbCRLState;
		pcb = &m_cbCRLState;
	    }
	    if (fCallServer)
	    {
		CSASSERT(NULL == *ppb);
		CSASSERT(NULL != ctbSite.pb);
		*pcb = ctbSite.cb;
		*ppb = ctbSite.pb;
		ctbSite.pb = NULL;
	    }
	    if (Index >= *pcb)
	    {
		hr = E_INVALIDARG;
		_JumpError(hr, error, "Index");
	    }
	    wsprintf(wszBuf, L"%u", (*ppb)[Index]);
	    pwszOut = wszBuf;
	    pbOut = (BYTE *) pwszOut;
	    break;
	}

	// If retrieving a CRL in Base64, use "-----BEGIN X509 CRL..."
	default:
	     if (GETCERT_CRLBYINDEX !=
		 (GETCERT_BYINDEXMASK & fExchangeCertificate))
	     {
		break;
	     }
	     // FALLTHROUGH

	case GETCERT_CURRENTCRL:
	    if (CR_OUT_BASE64HEADER == (~CR_OUT_CHAIN & Flags))
	    {
		Flags = CRYPT_STRING_BASE64X509CRLHEADER;
	    }
	    break;
    }
    hr = EncodeCertString(
			pbOut,
			pbOut == (BYTE *) pwszOut? 
			    wcslen(pwszOut) * sizeof(WCHAR) : ctbSite.cb,
			~CR_OUT_CHAIN & Flags,
			pstrCACertificate);
    _JumpIfError(hr, error, "EncodeCertString");

error:
    m_LastStatus = hr;
    if (NULL != pwszOut && wszBuf != pwszOut)
    {
	LocalFree(const_cast<WCHAR *>(pwszOut));
    }
    if (NULL != ctbSite.pb)
    {
	CoTaskMemFree(ctbSite.pb);
    }
    return(_SetErrorInfo(hr, L"CCertRequest::GetCACertificate"));
}


//+--------------------------------------------------------------------------
// CCertRequest::GetErrorMessageText -- Get error message text
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertRequest::GetErrorMessageText( 
    /* [in] */ LONG hrMessage,
    /* [in] */ LONG Flags,
    /* [out, retval] */ BSTR __RPC_FAR *pstrErrorMessageText)
{
    HRESULT hr;
    WCHAR const *pwszError = NULL;

    if (~CR_GEMT_HRESULT_STRING & Flags)
    {
	hr = E_INVALIDARG;
        _JumpError(hr, error, "not CR_IN_BINARY");
    }

    pwszError = myGetErrorMessageText(
			hrMessage,
			0 != (CR_GEMT_HRESULT_STRING & Flags));
    if (NULL == pwszError)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }
    if (!ConvertWszToBstr(
		    pstrErrorMessageText,
		    pwszError,
		    -1))
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "ConvertWszToBstr");
    }
    hr = S_OK;

error:
    if (NULL != pwszError)
    {
	LocalFree(const_cast<WCHAR *>(pwszError));
    }
    return(_SetErrorInfo(hr, L"CCertRequest::GetErrorMessageText"));
}


// for ICertRequest2::GetFullResponseProperty

CAPROP s_aFRProp[] = {
    { FR_PROP_FULLRESPONSE,           PROPTYPE_BINARY, },
    { FR_PROP_FULLRESPONSENOPKCS7,    PROPTYPE_BINARY, },
    { FR_PROP_STATUSINFOCOUNT,        PROPTYPE_LONG, },
    { FR_PROP_BODYPARTSTRING,         PROPTYPE_STRING | PROPFLAGS_INDEXED, },
    { FR_PROP_STATUS,                 PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { FR_PROP_STATUSSTRING,           PROPTYPE_STRING | PROPFLAGS_INDEXED, },
    { FR_PROP_OTHERINFOCHOICE,        PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { FR_PROP_FAILINFO,               PROPTYPE_LONG | PROPFLAGS_INDEXED, },
    { FR_PROP_PENDINFOTOKEN,          PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { FR_PROP_PENDINFOTIME,           PROPTYPE_DATE | PROPFLAGS_INDEXED, },
    { FR_PROP_ISSUEDCERTIFICATEHASH,  PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { FR_PROP_ISSUEDCERTIFICATE,      PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { FR_PROP_ISSUEDCERTIFICATECHAIN, PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { FR_PROP_ISSUEDCERTIFICATECRLCHAIN, PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
    { FR_PROP_ENCRYPTEDKEYHASH,	      PROPTYPE_BINARY | PROPFLAGS_INDEXED, },
};


//+--------------------------------------------------------------------------
// CCertRequest::GetFullResponseProperty -- Get CMC Response property
//
// Returns S_OK on success.
//+--------------------------------------------------------------------------

STDMETHODIMP
CCertRequest::GetFullResponseProperty( 
    /* [in] */ LONG PropId,		// FR_PROP_*
    /* [in] */ LONG PropIndex,
    /* [in] */ LONG PropType,		// PROPTYPE_*
    /* [in] */ LONG Flags,		// CR_OUT_*
    /* [out, retval] */ VARIANT *pvarPropertyValue)
{
    HRESULT hr;
    DWORD i;
    BYTE const *pbOut;
    WCHAR const *pwszOut;
    DWORD cbOut;
    DWORD dw;
    XCMCRESPONSE *pResponse = NULL;
    CERT_CONTEXT const *pccIssued = NULL;
    BYTE *pbChain = NULL;
    DWORD cbChain;

    if (NULL == pvarPropertyValue)
    {
	hr = E_POINTER;
	_JumpError(hr, error, "NULL parm");
    }
    VariantInit(pvarPropertyValue);

    hr = E_INVALIDARG;
    for (i = 0; PropId != s_aFRProp[i].lPropId; i++)
    {
	if (i >= ARRAYSIZE(s_aFRProp))
	{
	    _JumpError(hr, error, "PropId");
	}
    }
    if ((PROPTYPE_MASK & s_aFRProp[i].lPropFlags) != PropType)
    {
	_JumpError(hr, error, "PropType");
    }
    if (PROPFLAGS_INDEXED & s_aFRProp[i].lPropFlags)
    {
	if ((DWORD) PropIndex >= m_cResponse)
	{
	    _JumpError(hr, error, "PropIndex");
	}
	pResponse = &m_rgResponse[PropIndex];
    }
    else if (0 != PropIndex)
    {
	_JumpError(hr, error, "non-zero PropIndex");
    }

    
    pbOut = NULL;
    cbOut = 0;
    pwszOut = NULL;
    switch (PropId)
    {
    	case FR_PROP_FULLRESPONSE:
    	case FR_PROP_FULLRESPONSENOPKCS7:
	    pbOut = m_pbFullResponse;
	    cbOut = m_cbFullResponse;
	    if (NULL == pbOut && FR_PROP_FULLRESPONSE == PropId)
	    {
		pbOut = m_pbCertificateChain;
		cbOut = m_cbCertificateChain;
	    }
	    break;

    	case FR_PROP_STATUSINFOCOUNT:
	    pbOut = (BYTE const *) &m_cResponse;
	    cbOut = sizeof(m_cResponse);
	    break;

    	case FR_PROP_BODYPARTSTRING:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    pwszOut = pResponse->pwszBodyPart;
	    break;

    	case FR_PROP_STATUS:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    pbOut = (BYTE const *) &pResponse->StatusInfo.dwStatus;
	    cbOut = sizeof(pResponse->StatusInfo.dwStatus);
	    break;

    	case FR_PROP_STATUSSTRING:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    pwszOut = pResponse->StatusInfo.pwszStatusString;
	    break;

    	case FR_PROP_OTHERINFOCHOICE:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    pbOut = (BYTE const *) &pResponse->StatusInfo.dwOtherInfoChoice;
	    cbOut = sizeof(pResponse->StatusInfo.dwOtherInfoChoice);
	    break;

    	case FR_PROP_FAILINFO:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    if (CMC_OTHER_INFO_FAIL_CHOICE ==
		pResponse->StatusInfo.dwOtherInfoChoice)
	    {
		pbOut = (BYTE const *) &pResponse->StatusInfo.dwFailInfo;
		cbOut = sizeof(pResponse->StatusInfo.dwFailInfo);
	    }
	    break;

    	case FR_PROP_PENDINFOTOKEN:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    if (CMC_OTHER_INFO_PEND_CHOICE ==
		pResponse->StatusInfo.dwOtherInfoChoice)
	    {
		pbOut = (BYTE const *) &dw;
		cbOut = sizeof(dw);
		pbOut = pResponse->StatusInfo.pPendInfo->PendToken.pbData;
		cbOut = pResponse->StatusInfo.pPendInfo->PendToken.cbData;
	    }
	    break;

    	case FR_PROP_PENDINFOTIME:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    if (CMC_OTHER_INFO_PEND_CHOICE ==
		pResponse->StatusInfo.dwOtherInfoChoice)
	    {
		pbOut = (BYTE const *) &pResponse->StatusInfo.pPendInfo->PendTime;
		cbOut = sizeof(pResponse->StatusInfo.pPendInfo->PendTime);
	    }
	    break;

    	case FR_PROP_ISSUEDCERTIFICATEHASH:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    pbOut = pResponse->pbCertHash;
	    cbOut = pResponse->cbCertHash;
	    break;

    	case FR_PROP_ENCRYPTEDKEYHASH:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    pbOut = pResponse->pbEncryptedKeyHash;
	    cbOut = pResponse->cbEncryptedKeyHash;
	    break;

    	case FR_PROP_ISSUEDCERTIFICATE:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    hr = _FindIssuedCertificate(
				pResponse->pbCertHash,
				pResponse->cbCertHash,
				&pccIssued);
	    _JumpIfError(hr, error, "_FindIssuedCertificate");

	    pbOut = pccIssued->pbCertEncoded;
	    cbOut = pccIssued->cbCertEncoded;
	    break;

    	case FR_PROP_ISSUEDCERTIFICATECHAIN:
    	case FR_PROP_ISSUEDCERTIFICATECRLCHAIN:
            if (pResponse == NULL)
            {
               hr = E_POINTER;
               _JumpError(hr, error, "Bad switch setup: NULL pResponse");
            }
	    hr = _BuildIssuedCertificateChain(
			pResponse->pbCertHash,
			pResponse->cbCertHash,
			FR_PROP_ISSUEDCERTIFICATECRLCHAIN == PropId ||
			    0 != (CR_OUT_CRLS & Flags),
			&pbChain,
			&cbChain);
	    _JumpIfError(hr, error, "_BuildIssuedCertificateChain");

	    pbOut = pbChain;
	    cbOut = cbChain;
	    break;
    }
    if (NULL != pwszOut)
    {
	pbOut = (BYTE const *) pwszOut;
	cbOut = (wcslen(pwszOut) + 1) * sizeof(WCHAR);
    }
    if (NULL == pbOut || 0 == cbOut)
    {
	hr = CERTSRV_E_PROPERTY_EMPTY;
	_JumpError2(hr, error, "Empty", CERTSRV_E_PROPERTY_EMPTY);
    }
    __try
    {
	hr = myUnmarshalFormattedVariant(
				    Flags,
				    CR_PROP_CASIGCERT,
				    PropType,
				    cbOut,
				    pbOut,
				    pvarPropertyValue);
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    _JumpIfError(hr, error, "myUnmarshalFormattedVariant");

error:
    if (NULL != pccIssued)
    {
	CertFreeCertificateContext(pccIssued);
    }
    if (S_OK != hr && NULL != pvarPropertyValue)
    {
	VariantClear(pvarPropertyValue);
    }
    if (NULL != pbChain)
    {
	LocalFree(pbChain);
    }
    return(_SetErrorInfo(hr, L"CCertRequest::GetFullResponseProperty"));
}


HRESULT
CCertRequest::_SetErrorInfo(
    IN HRESULT hrError,
    IN WCHAR const *pwszDescription)
{
    CSASSERT(FAILED(hrError) || S_OK == hrError || S_FALSE == hrError);
    if (FAILED(hrError))
    {
	HRESULT hr;

	hr = DispatchSetErrorInfo(
			    hrError,
			    pwszDescription,
			    wszCLASS_CERTREQUEST,
			    &IID_ICertRequest);
	CSASSERT(hr == hrError);
    }
    return(hrError);
}


VOID
crRPCTimeoutCallback(
    IN OUT VOID *pVoid,
    IN BOOLEAN fTimeout)
{

    PRPC_TIMEOUT_CONTEXT pTimeout = (RPC_TIMEOUT_CONTEXT *) pVoid;

    if(fTimeout)
    {
        RpcCancelThreadEx(pTimeout->hThread, CR_RPC_CANCEL_TIMEOUT);
        pTimeout->hrRpcError = RPC_E_TIMEOUT;
    }

}


HRESULT
crRegisterRPCCallTimeout(
    IN DWORD dwMilliseconds,
    OUT PRPC_TIMEOUT_CONTEXT pTimeout)
{
    HRESULT hr = S_OK;

    pTimeout->hrRpcError = RPC_S_CALL_CANCELLED;

    if (!DuplicateHandle(
		    GetCurrentProcess(),	// hSourceProcessHandle
		    GetCurrentThread(),		// hSourceHandle
		    GetCurrentProcess(),	// hTargetProcessHandle
		    &pTimeout->hThread,		// lpTargetHandle
		    0,				// dwDesiredAccess
		    FALSE,			// bInheritHandle
		    DUPLICATE_SAME_ACCESS))	// dwOptions
    {
        hr = myHLastError();
        _JumpError(hr, error, "DuplicateHandle");
    }

    pTimeout->hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if(pTimeout->hEvent == NULL)
    {
        hr = myHLastError();
        _JumpError(hr, error, "CreateEvent");
    }


    if (!RegisterWaitForSingleObject(&pTimeout->hWait,
                                      pTimeout->hEvent, 
                                      crRPCTimeoutCallback,
                                      (PVOID)pTimeout   , 
                                      dwMilliseconds,
                                      WT_EXECUTEONLYONCE))
    {
        hr = myHLastError();
        _JumpError(hr, error, "RegisterWaitForSingleObject");
    }

error:
    if (S_OK != hr)
    {
	crCloseRPCCallTimeout(pTimeout);
    }
    return hr;

}


HRESULT
crCloseRPCCallTimeout(
    IN  PRPC_TIMEOUT_CONTEXT pTimeout)
{
    if(pTimeout->hWait)
    {
        UnregisterWait(pTimeout->hWait);
        pTimeout->hWait = NULL;
    }

    if(pTimeout->hEvent)
    {
        CloseHandle(pTimeout->hEvent);
        pTimeout->hEvent = NULL;
    }

    if(pTimeout->hThread)
    {
        CloseHandle(pTimeout->hThread);
        pTimeout->hThread = NULL;
    }

    return S_OK;
}


#undef __DIR__
#undef __dwFILE__
#define CCERTREQUEST
#include "csprop2.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certcli\pch.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        pch.cpp
//
// Contents:    Cert Server precompiled header
//
// History:     25-Jul-96       vich created
//
//---------------------------------------------------------------------------

#define __DIR__		"certcli"

#include <windows.h>
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>

#include <certsrv.h>
#include "certlib.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certcli\request.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        request.h
//
// Contents:    Declaration of CCertRequest
//
//---------------------------------------------------------------------------


#include "xelib.h"
#include "cscomres.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// certcli


class ATL_NO_VTABLE CCertRequest: 
    public IDispatchImpl<ICertRequest2, &IID_ICertRequest2, &LIBID_CERTCLIENTLib>, 
    public ISupportErrorInfoImpl<&IID_ICertRequest2>,
    public CComObjectRoot,
    public CComCoClass<CCertRequest, &CLSID_CCertRequest>
{
public:
    CCertRequest()
    {
        m_dwServerVersion = 0;
        m_pICertRequestD = NULL;
        m_hRPCCertServer = NULL;
        m_pwszDispositionMessage = NULL;
        m_pbRequest = NULL;
        m_pbCert = NULL;
        m_pbCertificateChain = NULL;
        m_pbFullResponse = NULL;
        m_pwszServerName = NULL;
        m_rpcAuthProtocol = 0;
	m_rgResponse = NULL;
	m_hStoreResponse = NULL;
	_InitCAPropInfo();
        _Cleanup();
    }
    ~CCertRequest();

BEGIN_COM_MAP(CCertRequest)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(ICertRequest)
    COM_INTERFACE_ENTRY(ICertRequest2)
END_COM_MAP()

DECLARE_NOT_AGGREGATABLE(CCertRequest) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(
    CCertRequest,
    wszCLASS_CERTREQUEST TEXT(".1"),
    wszCLASS_CERTREQUEST,
    IDS_CERTREQUEST_DESC,
    THREADFLAGS_BOTH)

// ICertRequest
public:
    STDMETHOD(Submit)(
		/* [in] */ LONG Flags,
		/* [in] */ BSTR const strRequest,
		/* [in] */ BSTR const strAttributes,
		/* [in] */ BSTR const strConfig,
		/* [out, retval] */ LONG __RPC_FAR *pDisposition);

    STDMETHOD(RetrievePending)(
		/* [in] */ LONG RequestId,
		/* [in] */ BSTR const strConfig,
		/* [out, retval] */ LONG __RPC_FAR *pDisposition);

    STDMETHOD(GetLastStatus)(
		/* [out, retval] */ LONG __RPC_FAR *pLastStatus);

    STDMETHOD(GetRequestId)(
		/* [out, retval] */ LONG __RPC_FAR *pRequestId);

    STDMETHOD(GetDispositionMessage)(
		/* [out, retval] */ BSTR __RPC_FAR *pstrDispositionMessage);

    STDMETHOD(GetCACertificate)(
		/* [in] */ LONG fExchangeCertificate,
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG Flags,
		/* [out, retval] */ BSTR __RPC_FAR *pstrCACertificate);

    STDMETHOD(GetCertificate)(
		/* [in] */ LONG Flags,
		/* [out, retval] */ BSTR __RPC_FAR *pstrCertificate);

// ICertRequest2
public:
    STDMETHOD(GetIssuedCertificate)( 
		/* [in] */ const BSTR strConfig,
		/* [in] */ LONG RequestId,
		/* [in] */ const BSTR strSerialNumber,
		/* [out, retval] */ LONG __RPC_FAR *pDisposition);
        
    STDMETHOD(GetErrorMessageText)( 
		/* [in] */ LONG hrMessage,
		/* [in] */ LONG Flags,
		/* [out, retval] */ BSTR __RPC_FAR *pstrErrorMessageText);
        
    STDMETHOD(GetCAProperty)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG PropId,		// CR_PROP_*
		/* [in] */ LONG PropIndex,
		/* [in] */ LONG PropType,	// PROPTYPE_*
		/* [in] */ LONG Flags,		// CR_OUT_*
		/* [out, retval] */ VARIANT *pvarPropertyValue);

    STDMETHOD(GetCAPropertyFlags)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG PropId,		// CR_PROP_*
		/* [out, retval] */ LONG *pPropFlags);

    STDMETHOD(GetCAPropertyDisplayName)(
		/* [in] */ BSTR const strConfig,
		/* [in] */ LONG PropId,		// CR_PROP_*
		/* [out, retval] */ BSTR *pstrDisplayName);

    STDMETHOD(GetFullResponseProperty)(
		/* [in] */ LONG PropId,		// FR_PROP_*
		/* [in] */ LONG PropIndex,
		/* [in] */ LONG PropType,	// PROPTYPE_*
		/* [in] */ LONG Flags,		// CR_OUT_*
		/* [out, retval] */ VARIANT *pvarPropertyValue);

private:
    HRESULT _OpenRPCConnection(
		IN WCHAR const *pwszConfig,
		OUT BOOL *pfNewConnection,
		OUT WCHAR const **ppwszAuthority);

    HRESULT _OpenConnection(
		IN BOOL fRPC,
		IN WCHAR const *pwszConfig,
		IN DWORD RequiredVersion,
		OUT WCHAR const **ppwszAuthority);

    VOID _CloseConnection();

    VOID _InitCAPropInfo();
    VOID _CleanupCAPropInfo();

    VOID _Cleanup();
    VOID _CleanupOldConnection();

    HRESULT _FindCAPropInfo(
		IN BSTR const strConfig,
		IN LONG PropId,
		OUT CAPROP const **ppcap);

    HRESULT _RequestCertificate(
		IN LONG Flags,
		IN LONG RequestId,
		OPTIONAL IN BSTR const strRequest,
		OPTIONAL IN BSTR const strAttributes,
		OPTIONAL IN WCHAR const *pwszSerialNumber,
		IN BSTR const strConfig,
		IN DWORD RequiredVersion,
		OUT LONG *pDisposition);

    HRESULT _FindIssuedCertificate(
		OPTIONAL IN BYTE const *pbCertHash,
		IN DWORD cbCertHash,
		OUT CERT_CONTEXT const **ppccIssued);

    HRESULT _BuildIssuedCertificateChain(
		OPTIONAL IN BYTE const *pbCertHash,
		IN DWORD cbCertHash,
		IN BOOL fIncludeCRLs,
		OUT BYTE **ppbCertChain,
		OUT DWORD *pcbCertChain);

    HRESULT _SetErrorInfo(
		IN HRESULT hrError,
		IN WCHAR const *pwszDescription);

    DWORD	    m_dwServerVersion;
    ICertRequestD2 *m_pICertRequestD;
    handle_t        m_hRPCCertServer;

    LONG            m_LastStatus;
    LONG            m_RequestId;
    LONG            m_Disposition;
    WCHAR          *m_pwszDispositionMessage;

    BYTE           *m_pbRequest;
    LONG            m_cbRequest;

    BYTE           *m_pbCert;
    LONG            m_cbCert;

    BYTE           *m_pbCertificateChain;
    LONG            m_cbCertificateChain;

    BYTE           *m_pbFullResponse;
    LONG            m_cbFullResponse;

    HCERTSTORE      m_hStoreResponse;
    XCMCRESPONSE   *m_rgResponse;
    DWORD	    m_cResponse;

    BYTE           *m_pbCACertState;
    DWORD           m_cbCACertState;

    BYTE           *m_pbCACertVersion;
    DWORD           m_cbCACertVersion;

    BYTE           *m_pbCRLState;
    DWORD           m_cbCRLState;

    CAPROP         *m_pCAPropInfo;
    LONG	    m_cCAPropInfo;
    CAINFO	   *m_pCAInfo;
    DWORD	    m_cbCAInfo;

    WCHAR          *m_pwszServerName;

    INT             m_rpcAuthProtocol;

    BYTE           *m_pbKRACertState;
    DWORD           m_cbKRACertState;

    BYTE           *m_pbForwardCrossCertState;
    DWORD           m_cbForwardCrossCertState;

    BYTE           *m_pbBackwardCrossCertState;
    DWORD           m_cbBackwardCrossCertState;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certcli\uwbase64.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        uwbase64.cpp
//
// Contents:    obsolete base64 encode/decode implementation
//              for backward compatibility
//
// History:     3-2000       xtan created
//
//---------------------------------------------------------------------------

#include <pch.cpp>
#pragma hdrstop

#include <certsrv.h>
#include "csdisp.h"

#define __dwFILE__	__dwFILE_CERTCLI_UWBASE64_CPP__


HRESULT
ObsoleteDecodeFileA(
    IN CHAR const *pszfn,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut,
    IN DWORD Flags)
{
    HRESULT hr;
    WCHAR *pwszfn = NULL;

    if (!myConvertSzToWsz(&pwszfn, pszfn, -1))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "myConvertSzToWsz");
    }

    hr = DecodeFileW(pwszfn, ppbOut, pcbOut, Flags);

error:
    if (NULL != pwszfn)
    {
        LocalFree(pwszfn);
    }
    return hr;
}

HRESULT
ObsoleteEncodeToFileA(
    IN CHAR const *pszfn,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags)
{
    HRESULT hr;
    WCHAR *pwszfn = NULL;

    if (!myConvertSzToWsz(&pwszfn, pszfn, -1))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "myConvertSzToWsz");
    }

    hr = EncodeToFileW(pwszfn, pbIn, cbIn, Flags);

error:
    if (NULL != pwszfn)
    {
        LocalFree(pwszfn);
    }
    return hr;
}

HRESULT
ObsoleteDecodeCertX(
    IN BOOL fUnicode,
    IN void const *pchIn,
    IN DWORD cchIn,
    IN DWORD Flags,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    HRESULT hr;
    BYTE *pbOut = NULL;
    DWORD cbOut;
    BOOL fRet;

    //init
    *ppbOut = NULL;
    *pcbOut = 0;

    while (TRUE)
    {
        if (fUnicode)
            fRet = CryptStringToBinaryW((LPCWSTR)pchIn, cchIn, Flags, pbOut, &cbOut, NULL, NULL);
        else
            fRet = CryptStringToBinaryA((LPCSTR)pchIn, cchIn, Flags, pbOut, &cbOut, NULL, NULL);
        if (!fRet)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptStringToBinary");
        }
        if (NULL != pbOut)
        {
            break; //done
        }
        pbOut = (BYTE*)LocalAlloc(LMEM_FIXED, cbOut);
        if (NULL == pbOut)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalALloc");
        }
    }
    *ppbOut = pbOut;
    pbOut = NULL;
    *pcbOut = cbOut;

    hr = S_OK;
error:
    if (NULL != pbOut)
    {
        LocalFree(pbOut);
    }
    return hr;
}

HRESULT
ObsoleteDecodeCertA(
    IN CHAR const *pchIn,
    IN DWORD cchIn,
    IN DWORD Flags,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    return ObsoleteDecodeCertX(
                FALSE, //ansi
                (void const *)pchIn,
                cchIn,
                Flags,
                ppbOut,
                pcbOut);
}

HRESULT
ObsoleteDecodeCertW(
    IN CHAR const *pchIn,
    IN DWORD cchIn,
    IN DWORD Flags,
    OUT BYTE **ppbOut,
    OUT DWORD *pcbOut)
{
    return ObsoleteDecodeCertX(
                TRUE, //unicode
                (void const *)pchIn,
                cchIn,
                Flags,
                ppbOut,
                pcbOut);
}


HRESULT
ObsoleteEncodeCertX(
    IN BOOL fUnicode,
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OUT void **ppchOut,
    OUT DWORD *pcchOut)
{ 
    HRESULT hr;
    BOOL  fRet;
    void  *pOut = NULL;
    DWORD  ccOut = 0;

    //init
    *ppchOut = NULL;
    *pcchOut = 0;

    while (TRUE)
    {
        if (fUnicode)
            fRet = CryptBinaryToStringW(
                            pbIn,
                            cbIn,
                            Flags,
                            (WCHAR*)pOut,
                            &ccOut);
        else
            fRet = CryptBinaryToStringA(
                            pbIn,
                            cbIn,
                            Flags,
                            (CHAR*)pOut,
                            &ccOut);
        if (!fRet)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CryptBinaryToString");
        }
        if (NULL != pOut)
        {
            break; //done
        }
        pOut = LocalAlloc(LMEM_FIXED,
                    ccOut * (fUnicode ? sizeof(WCHAR) : sizeof(CHAR)));
        if (NULL == pOut)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }
    }
    *ppchOut = pOut;
    pOut = NULL;
    *pcchOut = ccOut;

    hr = S_OK;
error:
    if (NULL != pOut)
    {
        LocalFree(pOut);
    }
    return hr;
}

HRESULT
ObsoleteEncodeCertA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OUT CHAR **ppchOut,
    OUT DWORD *pcchOut)
{
    return ObsoleteEncodeCertX(
                FALSE, //ansi
                pbIn,
                cbIn,
                Flags,
                (void**)ppchOut,
                pcchOut);
}

HRESULT
ObsoleteEncodeCertW(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OUT WCHAR **ppchOut,
    OUT DWORD *pcchOut)
{
    return ObsoleteEncodeCertX(
                TRUE, //unicode
                pbIn,
                cbIn,
                Flags,
                (void**)ppchOut,
                pcchOut);
}

DWORD			// cchHeader
ObsoleteSizeBase64HeaderA(
    IN char const *pchIn,
    IN DWORD cchIn,
    IN BOOL, // fBegin
    OUT DWORD *pcchSkip)
{
    DWORD cchHeader = 0;
    DWORD cb;

    // fBegin and pcchSkip are ignored???
    *pcchSkip = 0;

    if (!CryptStringToBinaryA(
			pchIn,
			cchIn,
			CRYPT_STRING_ANY,
			NULL,
			&cb,
			&cchHeader,
			NULL))
    {
        _PrintError(myHLastError(), "CryptStringToBinaryA");
        cchHeader = MAXDWORD;
    }
    return cchHeader;
}

DWORD			// cchHeader
ObsoleteSizeBase64HeaderW(
    IN WCHAR const *pchIn,
    IN DWORD cchIn,
    IN BOOL, // fBegin
    OUT DWORD *pcchSkip)
{
    DWORD cchHeader = 0;
    DWORD cb;

    // fBegin and pcchSkip are ignored???
    *pcchSkip = 0;

    if (!CryptStringToBinaryW(
			pchIn,
			cchIn,
			CRYPT_STRING_ANY,
			NULL,
			&cb,
			&cchHeader,
			NULL))
    {
        _PrintError(myHLastError(), "CryptStringToBinaryW");
        cchHeader = MAXDWORD;
    }
    return cchHeader;
}


HRESULT
ObsoleteHexDecodeA(
    IN CHAR const *pchIn,
    IN DWORD cchIn,
    IN DWORD Flags,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD *pcbOut)
{
    HRESULT hr = S_OK;
    
    if (!CryptStringToBinaryA(pchIn, cchIn, Flags, pbOut, pcbOut, NULL, NULL))
    {
	hr = myHLastError();
    }
    return(hr);
}

HRESULT
ObsoleteHexDecodeW(
    IN WCHAR const *pchIn,
    IN DWORD cchIn,
    IN DWORD Flags,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD *pcbOut)
{
    HRESULT hr = S_OK;
    
    if (!CryptStringToBinaryW(pchIn, cchIn, Flags, pbOut, pcbOut, NULL, NULL))
    {
	hr = myHLastError();
    }
    return(hr);
}

HRESULT
ObsoleteHexEncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OPTIONAL OUT CHAR *pchOut,
    IN OUT DWORD *pcchOut)
{
    HRESULT hr = S_OK;
    
    if (!CryptBinaryToStringA(pbIn, cbIn, Flags, pchOut, pcchOut))
    {
	hr = myHLastError();
    }
    return(hr);
}

HRESULT
ObsoleteHexEncodeW(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    IN DWORD Flags,
    OPTIONAL OUT WCHAR *pchOut,
    IN OUT DWORD *pcchOut)
{
    HRESULT hr = S_OK;
    
    if (!CryptBinaryToStringW(pbIn, cbIn, Flags, pchOut, pcchOut))
    {
	hr = myHLastError();
    }
    return(hr);
}

HRESULT
ObsoleteBase64DecodeA(
    IN CHAR const *pchIn,
    IN DWORD cchIn,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD *pcbOut)
{
    HRESULT hr = S_OK;
    
    if (!CryptStringToBinaryA(
			pchIn,
			cchIn,
			CRYPT_STRING_BASE64,
			pbOut,
			pcbOut,
			NULL,
			NULL))
    {
	hr = myHLastError();
    }
    return(hr);
}

HRESULT
ObsoleteBase64DecodeW(
    IN WCHAR const *pchIn,
    IN DWORD cchIn,
    OPTIONAL OUT BYTE *pbOut,
    IN OUT DWORD *pcbOut)
{
    HRESULT hr = S_OK;
    
    if (!CryptStringToBinaryW(
			pchIn,
			cchIn,
			CRYPT_STRING_BASE64,
			pbOut,
			pcbOut,
			NULL,
			NULL))
    {
	hr = myHLastError();
    }
    return(hr);
}

HRESULT
ObsoleteBase64EncodeA(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OPTIONAL OUT CHAR *pchOut,
    IN OUT DWORD *pcchOut)
{
    HRESULT hr = S_OK;
    
    if (!CryptBinaryToStringA(pbIn, cbIn, CRYPT_STRING_BASE64, pchOut, pcchOut))
    {
	hr = myHLastError();
    }
    return(hr);
}

HRESULT
ObsoleteBase64EncodeW(
    IN BYTE const *pbIn,
    IN DWORD cbIn,
    OPTIONAL OUT WCHAR *pchOut,
    IN OUT DWORD *pcchOut)
{
    HRESULT hr = S_OK;
    
    if (!CryptBinaryToStringW(pbIn, cbIn, CRYPT_STRING_BASE64, pchOut, pcchOut))
    {
	hr = myHLastError();
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certcli\resource.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997 - 1999
//
// File:        resource.h
//
// Contents:    CertCli implementation
//
//---------------------------------------------------------------------------

#define IDS_COLUMN_REQUESTID				101
#define IDS_COLUMN_REQUESTRAWREQUEST			102
#define IDS_COLUMN_REQUESTRAWOLDCERTIFICATE		103
#define IDS_COLUMN_REQUESTATTRIBUTES			104
#define IDS_COLUMN_REQUESTTYPE				105
#define IDS_COLUMN_REQUESTFLAGS				106
#define IDS_COLUMN_REQUESTSTATUS			107
#define IDS_COLUMN_REQUESTSTATUSCODE			108
#define IDS_COLUMN_REQUESTDISPOSITION			109
#define IDS_COLUMN_REQUESTDISPOSITIONMESSAGE		110
#define IDS_COLUMN_REQUESTSUBMITTEDWHEN			111
#define IDS_COLUMN_REQUESTRESOLVEDWHEN			112
#define IDS_COLUMN_REQUESTREVOKEDWHEN			113
#define IDS_COLUMN_REQUESTREVOKEDEFFECTIVEWHEN		114
#define IDS_COLUMN_REQUESTREVOKEDREASON			115
#define IDS_COLUMN_REQUESTERNAME			116
#define IDS_COLUMN_REQUESTERADDRESS			117

#define IDS_COLUMN_REQUESTDISTINGUISHEDNAME		118
#define IDS_COLUMN_REQUESTRAWNAME			119
#define IDS_COLUMN_REQUESTNAMETYPE			120
#define IDS_COLUMN_REQUESTCOUNTRY			121
#define IDS_COLUMN_REQUESTORGANIZATION			122
#define IDS_COLUMN_REQUESTORGUNIT			123
#define IDS_COLUMN_REQUESTCOMMONNAME			124
#define IDS_COLUMN_REQUESTLOCALITY			125
#define IDS_COLUMN_REQUESTSTATE				126
#define IDS_COLUMN_REQUESTTITLE				127
#define IDS_COLUMN_REQUESTGIVENNAME			128
#define IDS_COLUMN_REQUESTINITIALS			129
#define IDS_COLUMN_REQUESTSURNAME			130
#define IDS_COLUMN_REQUESTDOMAINCOMPONENT		131
#define IDS_COLUMN_REQUESTEMAIL				132
#define IDS_COLUMN_REQUESTSTREETADDRESS			133

#define IDS_COLUMN_CERTIFICATEREQUESTID			134
#define IDS_COLUMN_CERTIFICATERAWCERTIFICATE		135
#define IDS_COLUMN_CERTIFICATECERTIFICATEHASH		136
#define IDS_COLUMN_CERTIFICATETYPE			137
#define IDS_COLUMN_CERTIFICATESERIALNUMBER		138
#define IDS_COLUMN_CERTIFICATEISSUERNAMEID		139
#define IDS_COLUMN_CERTIFICATENOTBEFOREDATE		140
#define IDS_COLUMN_CERTIFICATENOTAFTERDATE		141
#define IDS_COLUMN_CERTIFICATERAWPUBLICKEY		142
#define IDS_COLUMN_CERTIFICATEPUBLICKEYALGORITHM	143
#define IDS_COLUMN_CERTIFICATERAWPUBLICKEYALGORITHMPARAMETERS	144

#define IDS_COLUMN_CERTIFICATEDISTINGUISHEDNAME		145
#define IDS_COLUMN_CERTIFICATERAWNAME			146
#define IDS_COLUMN_CERTIFICATENAMETYPE			147
#define IDS_COLUMN_CERTIFICATECOUNTRY			148
#define IDS_COLUMN_CERTIFICATEORGANIZATION		149
#define IDS_COLUMN_CERTIFICATEORGUNIT			150
#define IDS_COLUMN_CERTIFICATECOMMONNAME		151
#define IDS_COLUMN_CERTIFICATELOCALITY			152
#define IDS_COLUMN_CERTIFICATESTATE			153
#define IDS_COLUMN_CERTIFICATETITLE			154
#define IDS_COLUMN_CERTIFICATEGIVENNAME			155
#define IDS_COLUMN_CERTIFICATEINITIALS			156
#define IDS_COLUMN_CERTIFICATESURNAME			157
#define IDS_COLUMN_CERTIFICATEDOMAINCOMPONENT		158
#define IDS_COLUMN_CERTIFICATEEMAIL			159
#define IDS_COLUMN_CERTIFICATESTREETADDRESS		160
#define IDS_COLUMN_CERTIFICATEUNSTRUCTUREDNAME		161
#define IDS_COLUMN_CERTIFICATEUNSTRUCTUREDADDRESS	162

#define IDS_COLUMN_REQUESTUNSTRUCTUREDNAME		163
#define IDS_COLUMN_REQUESTUNSTRUCTUREDADDRESS		164
#define IDS_COLUMN_REQUESTDEVICESERIALNUMBER		165
#define IDS_COLUMN_CERTIFICATEDEVICESERIALNUMBER	166
#define IDS_FILESHARE_REMARK				167
#define IDS_COLUMN_CERTIFICATERAWSMIMECAPABILITIES	168

#define IDS_COLUMN_EXTREQUESTID				169
#define IDS_COLUMN_EXTNAME				170
#define IDS_COLUMN_EXTFLAGS				171
#define IDS_COLUMN_EXTRAWVALUE				172

#define IDS_COLUMN_ATTRIBREQUESTID			173
#define IDS_COLUMN_ATTRIBNAME				174
#define IDS_COLUMN_ATTRIBVALUE				175

#define IDS_COLUMN_CRLROWID				176
#define IDS_COLUMN_CRLNUMBER				177
#define IDS_COLUMN_CRLMINBASE				178
#define IDS_COLUMN_CRLNAMEID				179
#define IDS_COLUMN_CRLCOUNT				180
#define IDS_COLUMN_CRLTHISUPDATE			181
#define IDS_COLUMN_CRLNEXTUPDATE			182
#define IDS_COLUMN_CRLTHISPUBLISH			183
#define IDS_COLUMN_CRLNEXTPUBLISH			184
#define IDS_COLUMN_CRLEFFECTIVE				185
#define IDS_COLUMN_CRLPROPAGATIONCOMPLETE		186
#define IDS_COLUMN_CRLRAWCRL				187

#define IDS_CAPROP_FILEVERSION				188
#define IDS_CAPROP_PRODUCTVERSION			189
#define IDS_CAPROP_EXITCOUNT				190
#define IDS_CAPROP_EXITDESCRIPTION			191
#define IDS_CAPROP_POLICYDESCRIPTION			192
#define IDS_CAPROP_CANAME				193
#define IDS_CAPROP_SANITIZEDCANAME			194
#define IDS_CAPROP_SHAREDFOLDER				195
#define IDS_CAPROP_PARENTCA				196

#define IDS_CAPROP_CATYPE				197
#define IDS_CAPROP_CASIGCERTCOUNT			198
#define IDS_CAPROP_CASIGCERT				199
#define IDS_CAPROP_CASIGCERTCHAIN			200
#define IDS_CAPROP_CAXCHGCERTCOUNT			201
#define IDS_CAPROP_CAXCHGCERT				202
#define IDS_CAPROP_CAXCHGCERTCHAIN			203
#define IDS_CAPROP_BASECRL				204
#define IDS_CAPROP_DELTACRL				205
#define IDS_CAPROP_CACERTSTATE				206
#define IDS_CAPROP_CRLSTATE				207
#define IDS_CAPROP_CAPROPIDMAX				208

#define IDS_COLUMN_CERTIFICATESUBJECTKEYIDENTIFIER	209

#define IDS_UNKNOWN_ERROR_CODE				210
#define IDS_E_UNEXPECTED				211

#define IDS_SETUP_ERROR_EXPECTED_SECTION_NAME		212
#define IDS_SETUP_ERROR_BAD_SECTION_NAME_LINE		213
#define IDS_SETUP_ERROR_SECTION_NAME_TOO_LONG		214
#define IDS_SETUP_ERROR_GENERAL_SYNTAX			215

#define IDS_SETUP_ERROR_WRONG_INF_STYLE			216
#define IDS_SETUP_ERROR_SECTION_NOT_FOUND		217
#define IDS_SETUP_ERROR_LINE_NOT_FOUND			218

#define IDS_COLUMN_REQUESTRAWARCHIVEDKEY		219
#define IDS_COLUMN_REQUESTKEYRECOVERYHASHES		220

#define IDS_CAPROP_DNSNAME				221
#define IDS_COLUMN_PROPCERTIFICATETEMPLATE		222
#define IDS_COLUMN_REQUESTSIGNERPOLICIES		223
#define IDS_COLUMN_REQUESTSIGNERAPPLICATIONPOLICIES	224
#define IDS_COLUMN_PROPCERTIFICATEENROLLMENTFLAGS	225
#define IDS_COLUMN_PROPCERTIFICATEGENERALFLAGS		226
#define IDS_COLUMN_CERTIFICATEPUBLICKEYLENGTH		227
#define IDS_CAPROP_KRACERTUSEDCOUNT			228
#define IDS_CAPROP_KRACERTCOUNT				229
#define IDS_CAPROP_KRACERT				230
#define IDS_CAPROP_KRACERTSTATE				231
#define IDS_CAPROP_ROLESEPARATIONENABLED		232
#define IDS_CAPROP_ADVANCEDSERVER			233
#define IDS_COLUMN_CRLLASTPUBLISHED			234
#define IDS_COLUMN_CRLPUBLISHATTEMPTS			235
#define IDS_COLUMN_CRLPUBLISHFLAGS			236
#define IDS_COLUMN_CRLPUBLISHSTATUSCODE			237
#define IDS_COLUMN_CRLPUBLISHERROR			238
#define IDS_COLUMN_CALLERNAME				239
#define IDS_CAPROP_TEMPLATES				240
#define IDS_CAPROP_BASECRLPUBLISHSTATUS			241
#define IDS_CAPROP_DELTACRLPUBLISHSTATUS		242
#define IDS_CAPROP_CASIGCERTCRLCHAIN			243
#define IDS_CAPROP_CAXCHGCERTCRLCHAIN			244
#define IDS_COLUMN_CERTIFICATEUPN			245
#define IDS_E_DATA_MISALIGNMENT				246
#define IDS_CAPROP_CACERTSTATUSCODE			247

#define IDS_HTTP_STATUS_CONTINUE			248
#define IDS_HTTP_STATUS_SWITCH_PROTOCOLS		249
#define IDS_HTTP_STATUS_OK				250
#define IDS_HTTP_STATUS_CREATED				251
#define IDS_HTTP_STATUS_ACCEPTED			252
#define IDS_HTTP_STATUS_PARTIAL				253
#define IDS_HTTP_STATUS_NO_CONTENT			254
#define IDS_HTTP_STATUS_RESET_CONTENT			255
#define IDS_HTTP_STATUS_PARTIAL_CONTENT			256
#define IDS_HTTP_STATUS_AMBIGUOUS			257
#define IDS_HTTP_STATUS_MOVED				258
#define IDS_HTTP_STATUS_REDIRECT			259
#define IDS_HTTP_STATUS_REDIRECT_METHOD			260
#define IDS_HTTP_STATUS_NOT_MODIFIED			261
#define IDS_HTTP_STATUS_USE_PROXY			262
#define IDS_HTTP_STATUS_REDIRECT_KEEP_VERB		263
#define IDS_HTTP_STATUS_BAD_REQUEST			264
#define IDS_HTTP_STATUS_DENIED				265
#define IDS_HTTP_STATUS_PAYMENT_REQ			266
#define IDS_HTTP_STATUS_FORBIDDEN			267
#define IDS_HTTP_STATUS_NOT_FOUND			268
#define IDS_HTTP_STATUS_BAD_METHOD			269
#define IDS_HTTP_STATUS_NONE_ACCEPTABLE			270
#define IDS_HTTP_STATUS_PROXY_AUTH_REQ			271
#define IDS_HTTP_STATUS_REQUEST_TIMEOUT			272
#define IDS_HTTP_STATUS_CONFLICT			273
#define IDS_HTTP_STATUS_GONE				274
#define IDS_HTTP_STATUS_LENGTH_REQUIRED			275
#define IDS_HTTP_STATUS_PRECOND_FAILED			276
#define IDS_HTTP_STATUS_REQUEST_TOO_LARGE		277
#define IDS_HTTP_STATUS_URI_TOO_LONG			278
#define IDS_HTTP_STATUS_UNSUPPORTED_MEDIA		279
#define IDS_HTTP_STATUS_RETRY_WITH			280
#define IDS_HTTP_STATUS_SERVER_ERROR			281
#define IDS_HTTP_STATUS_NOT_SUPPORTED			282
#define IDS_HTTP_STATUS_BAD_GATEWAY			283
#define IDS_HTTP_STATUS_SERVICE_UNAVAIL			284
#define IDS_HTTP_STATUS_GATEWAY_TIMEOUT			285
#define IDS_HTTP_STATUS_VERSION_NOT_SUP			286

#define IDS_CAPROP_CAFORWARDCROSSCERT			287
#define IDS_CAPROP_CABACKWARDCROSSCERT			288
#define IDS_CAPROP_CAFORWARDCROSSCERTSTATE		289
#define IDS_CAPROP_CABACKWARDCROSSCERTSTATE		290
#define IDS_CAPROP_CACERTVERSION			291
#define IDS_CAPROP_SANITIZEDCASHORTNAME			292

#define IDS_CERTIFICATE_SERVICES			293
#define	IDS_MSCEP					294
#define	IDS_MSCEP_DES					295
#define IDS_COLUMN_REQUESTOFFICER			296
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certcli\vroot.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       vroot.cpp
//
//--------------------------------------------------------------------------

//+------------------------------------------------------------------------
//
//  File:       vroot.cpp
//
//  Contents:   Code for creating IIS web server virtual roots under K2.
//
//  Functions:  AddNewVDir()
//
//  History:    5/16/97         JerryK  Created
//
//-------------------------------------------------------------------------


// Include File Voodoo
#include "pch.cpp"
#pragma hdrstop

#include <lm.h>
#include <sddl.h>
#include "resource.h"
#include "certacl.h"
#include "multisz.h"

#define __dwFILE__	__dwFILE_CERTCLI_VROOT_CPP__


#undef DEFINE_GUID
#define INITGUID
#ifndef INITGUID
#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID FAR name
#else

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#endif // INITGUID

#include <iwamreg.h>
#include <iadmw.h>
#include <iiscnfg.h>


extern HINSTANCE g_hInstance;


#define MAX_METABASE_ATTEMPTS           10      // Times to bang head on wall
#define METABASE_PAUSE                  500     // Time to pause in msec

#define VRE_DELETEONLY  0x00000001      // Obsolete VRoot -- delete
#define VRE_SCRIPTMAP   0x00000002      // Add additional associations to the script map
#define VRE_ALLOWNTLM   0x00000004      // Alloc NTLM authentication
#define VRE_CREATEAPP   0x00000008      // Create an in-process Web application

typedef struct _VROOTENTRY
{
    WCHAR *pwszVRootName;
    WCHAR *pwszDirectory;       // relative to System32 directory
    DWORD  Flags;
} VROOTENTRY;

VROOTENTRY g_avr[] = {
// pwszVRootName   pwszDirectory              Flags
 { L"CertSrv",     L"\\CertSrv",              VRE_ALLOWNTLM | VRE_SCRIPTMAP | VRE_CREATEAPP},
 { L"CertControl", L"\\CertSrv\\CertControl", VRE_ALLOWNTLM },
 { L"CertEnroll",  L"\\" wszCERTENROLLSHAREPATH,  0 },
 { L"CertQue",     L"\\CertSrv\\CertQue",     VRE_DELETEONLY },
 { L"CertAdm",     L"\\CertSrv\\CertAdm",     VRE_DELETEONLY },
 { NULL }
};

typedef struct _VRFSPARMS
{
    IN DWORD Flags;                     // VFF_*
    IN ENUM_CATYPES CAType;             // CAType
    IN BOOL  fAsynchronous;
    IN DWORD csecTimeOut;
    OUT DWORD *pVRootDisposition;       // VFD_*
    OUT DWORD *pShareDisposition;       // VFD_*
} VRFSPARMS;



// Globals
WCHAR const g_wszBaseRoot[] = L"/LM/W3svc/1/ROOT";
WCHAR const g_wszCertCliDotDll[] = L"certcli.dll";
WCHAR const g_wszDotAsp[] = L".asp";
WCHAR const g_wszDotCer[] = L".cer";
WCHAR const g_wszDotP7b[] = L".p7b";
WCHAR const g_wszDotCrl[] = L".crl";
WCHAR const g_wszW3SVC[] = L"/LM/W3SVC";

WCHAR const g_wszMSCEP[] = L"mscep.dll";
WCHAR const g_wszMSCEPID[] = L"MSCEPGroup";

// caller must have CoInitialize()'d

BOOL
IsIISInstalled(
    OUT HRESULT *phr)
{
    IMSAdminBase *pIMeta = NULL;

    *phr = CoCreateInstance(
                    CLSID_MSAdminBase,
                    NULL,
                    CLSCTX_ALL,
                    IID_IMSAdminBase,
                    (VOID **) &pIMeta);
    _JumpIfError2(*phr, error, "CoCreateInstance(CLSID_MSAdminBase)", *phr);

error:
    if (NULL != pIMeta)
    {
        pIMeta->Release();
    }
    return(S_OK == *phr);
}

HRESULT
vrOpenRoot(
    IN IMSAdminBase *pIMeta,
    IN BOOL fReadOnly,
    OUT METADATA_HANDLE *phMetaRoot)
{
    HRESULT hr;
    DWORD i;

    hr = S_OK;
    __try
    {
        // Re-try a few times to see if we can get past the block

	for (i = 0; i < MAX_METABASE_ATTEMPTS; i++)
        {
            if (0 != i)
            {
                Sleep(METABASE_PAUSE);          // Pause and try again
            }

            // Make an attempt to open the root

            hr = pIMeta->OpenKey(
                            METADATA_MASTER_ROOT_HANDLE,
                            g_wszBaseRoot,
                            fReadOnly?
                                METADATA_PERMISSION_READ :
                                (METADATA_PERMISSION_READ |
                                 METADATA_PERMISSION_WRITE),
                            1000,
                            phMetaRoot);
            if (S_OK == hr)
            {
                break;                          // Success -- we're done!
            }

            // See if a previous call has things tied up

            if (HRESULT_FROM_WIN32(ERROR_PATH_BUSY) != hr)
            {
                _LeaveIfError(hr, "OpenKey");   // Detected some other error
            }
        }
        _LeaveIfError(hr, "OpenKey(timeout)"); // Detected some other error
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

//error:
    return(hr);
}


HRESULT
vrCloseKey(
    IN IMSAdminBase *pIMeta,
    IN METADATA_HANDLE hMeta,
    IN HRESULT hr)
{
    HRESULT hr2;

    hr2 = S_OK;
    __try
    {
        hr2 = pIMeta->CloseKey(hMeta);
        _LeaveIfError(hr2, "CloseKey");
    }
    __except(hr2 = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
    if (S_OK != hr2)
    {
        if (S_OK == hr)
        {
            hr = hr2;
        }
        _PrintError(hr2, "CloseKey");
    }
    return(hr);
}


//+----------------------------------------------------------------------------
//
//  Function:   AddNewVDir(. . . .)
//
//  Synopsis:   Creates a new virtual root using the K2 metabase.
//
//  Arguments:  [pwszVRootName] Name to give to the virtual root
//              [pwszDirectory] Path for the directory to use as the root.
//
//  Returns:    HRESULT status code regurgitated from metabase COM interfaces
//
//
//  History:    05/16/97        JerryK  Put in this file
//              05/22/97        JerryK  Made OCM setup build with this stuff
//                                      in place.
//
//  Notes:      Originally derived from sample code provided by MikeHow;
//              hacked up a lot in between.
//
//              We do a try, fail, pause, retry loop on our attempts to open
//              the metabase master key to get around a K2 bug that can result
//              in it being left busy if this function is called too many
//              times successively.
//
//  TO DO:      COME BACK AND PUT SEMIREADABLE GUI LEVEL MESSAGEBOX REPORTING
//              THAT THE VROOTS IN QUESTION DIDN'T SET UP CORRECTLY.
//
//-----------------------------------------------------------------------------

HRESULT
AddNewVDir(
    IN LPWSTR pwszVRootName,
    IN LPWSTR pwszDirectory,
    IN BOOL fScriptMap,
    IN BOOL fNTLM,
    IN BOOL fCreateApp,
    OUT BOOL *pfExists)
{
    HRESULT hr;
    METADATA_RECORD mr;
    IMSAdminBase *pIMeta = NULL;
    IWamAdmin *pIWam = NULL;
    WCHAR *pwszNewPath = NULL;
    WCHAR *pwszCurrentScriptMap=NULL;
    WCHAR *pwszNewScriptMap=NULL;
    WCHAR wszKeyType[] = TEXT(IIS_CLASS_WEB_VDIR);
    METADATA_HANDLE hMetaRoot = NULL;   // Open key to ROOT (where VDirs live)
    METADATA_HANDLE hMetaKey = NULL;
    DWORD dwMDData = MD_LOGON_NETWORK; // Create network token when logging on anonymous account
    METADATA_RECORD MDData = 
        {
        MD_LOGON_METHOD,
        METADATA_INHERIT,
        IIS_MD_UT_FILE,
        DWORD_METADATA,
	sizeof(dwMDData),
        (unsigned char*)&dwMDData,
        0        
        };

    *pfExists = FALSE;
    DBGPRINT((
        DBG_SS_CERTLIBI,
        "AddNewVDir(%ws, %ws, fScriptMap=%d, fNTLM=%d, fCreateApp=%d)\n",
        pwszVRootName,
        pwszDirectory,
        fScriptMap,
        fNTLM,
        fCreateApp));

    // Create an instance of the metabase object
    hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (void **) &pIMeta);
    _JumpIfError(hr, error, "CoCreateInstance");

    __try
    {
        hr = vrOpenRoot(pIMeta, FALSE, &hMetaRoot);
        _LeaveIfError(hr, "vrOpenRoot");

        // Add new VDir called pwszVRootName

        hr = pIMeta->AddKey(hMetaRoot, pwszVRootName);

        DBGPRINT((
            DBG_SS_CERTLIBI,
            "AddNewVDir: AddKey(%ws) --> %x\n",
            pwszVRootName,
            hr));
        if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr)
        {
            *pfExists = TRUE;
        }
        else
        {
            _LeaveIfError(hr, "AddKey");
        }

        if (fScriptMap) {

            // get the current script map
            DWORD dwDataSize;
            mr.dwMDIdentifier=MD_SCRIPT_MAPS;
            mr.dwMDAttributes=METADATA_INHERIT;
            mr.dwMDUserType=IIS_MD_UT_FILE;
            mr.dwMDDataType=MULTISZ_METADATA;
            mr.dwMDDataLen=0;
            mr.pbMDData=NULL;
            hr=pIMeta->GetData(hMetaRoot, L"", &mr, &dwDataSize);
            if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER)!=hr) {
                _LeaveError(hr, "GetData");
            }
            pwszCurrentScriptMap=reinterpret_cast<WCHAR *>(new unsigned char[dwDataSize]);
            if (NULL==pwszCurrentScriptMap) {
                hr=E_OUTOFMEMORY;
                _LeaveError(hr, "new");
            }
            mr.pbMDData=reinterpret_cast<unsigned char *>(pwszCurrentScriptMap);
            mr.dwMDDataLen=dwDataSize;
            hr=pIMeta->GetData(hMetaRoot, L"", &mr, &dwDataSize);
            _LeaveIfError(hr, "GetData");
        }

        hr = pIMeta->SetData(hMetaRoot, pwszVRootName, &MDData);
        _LeaveIfError(hr, "CloseKey");

        hr = pIMeta->CloseKey(hMetaRoot);
        _LeaveIfError(hr, "CloseKey");

        hMetaRoot = NULL;

        // Build the name of the new VDir
        pwszNewPath = new WCHAR[wcslen(g_wszBaseRoot) + 1 + wcslen(pwszVRootName) + 1];
        if (NULL == pwszNewPath)
        {
            hr = E_OUTOFMEMORY;
            _LeaveError(hr, "new");
        }
        wcscpy(pwszNewPath, g_wszBaseRoot);
        wcscat(pwszNewPath, L"/");
        wcscat(pwszNewPath, pwszVRootName);

        // Open the new VDir

        hr = pIMeta->OpenKey(
                        METADATA_MASTER_ROOT_HANDLE,
                        pwszNewPath,
                        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                        1000,
                        &hMetaKey);
        _LeaveIfErrorStr(hr, "OpenKey", pwszNewPath);


        // Set the physical path for this VDir

        // virtual root path
        mr.dwMDIdentifier = MD_VR_PATH;
        mr.dwMDAttributes = METADATA_INHERIT;
        mr.dwMDUserType = IIS_MD_UT_FILE;
        mr.dwMDDataType = STRING_METADATA;
        mr.dwMDDataLen = (wcslen(pwszDirectory) + 1) * sizeof(WCHAR);
        mr.pbMDData = reinterpret_cast<unsigned char *>(pwszDirectory);
        hr = pIMeta->SetData(hMetaKey, L"", &mr);
        _LeaveIfError(hr, "SetData");

        // access permissions on VRoots: read & execute scripts only
        DWORD dwAccessPerms = MD_ACCESS_SCRIPT | MD_ACCESS_READ;

        mr.dwMDIdentifier = MD_ACCESS_PERM;
        mr.dwMDAttributes = METADATA_INHERIT;
        mr.dwMDUserType = IIS_MD_UT_FILE;
        mr.dwMDDataType = DWORD_METADATA;
        mr.dwMDDataLen = sizeof(dwAccessPerms);
        mr.pbMDData = reinterpret_cast<unsigned char *>(&dwAccessPerms);
        hr = pIMeta->SetData(hMetaKey, L"", &mr);
        _LeaveIfError(hr, "SetData");

        // key type
        mr.dwMDIdentifier = MD_KEY_TYPE;
        mr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
        mr.dwMDUserType = IIS_MD_UT_SERVER;
        mr.dwMDDataType = STRING_METADATA;
        mr.dwMDDataLen = (wcslen(wszKeyType) + 1) * sizeof(WCHAR);
        mr.pbMDData = reinterpret_cast<unsigned char *>(wszKeyType);
        hr = pIMeta->SetData(hMetaKey, L"", &mr);
        _LeaveIfError(hr, "SetData");


        // set authentication to be anonymous
        DWORD dwAuthenticationType = MD_AUTH_ANONYMOUS;

        // chg to Basic/NTLM if we're told to
        if (fNTLM)
            dwAuthenticationType = MD_AUTH_NT;

        mr.dwMDIdentifier = MD_AUTHORIZATION;
        mr.dwMDAttributes = METADATA_INHERIT;
        mr.dwMDUserType = IIS_MD_UT_FILE;
        mr.dwMDDataType = DWORD_METADATA;
        mr.dwMDDataLen = sizeof(dwAuthenticationType);
        mr.pbMDData = reinterpret_cast<unsigned char *>(&dwAuthenticationType);
        hr = pIMeta->SetData(hMetaKey, L"", &mr);
        _LeaveIfError(hr, "SetData");

        if (fScriptMap) {

            // already have current script map.

            // walk through the script map and find .asp
            WCHAR * pwszCurAssoc=pwszCurrentScriptMap;
            do {
                if (L'\0'==pwszCurAssoc[0]) {
                    hr=HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
                    _LeaveError(hr, ".asp association not found");
                } else if (0==_wcsnicmp(pwszCurAssoc, g_wszDotAsp, 4)) {
                    break;
                } else {
                    pwszCurAssoc+=wcslen(pwszCurAssoc)+1;
                }
            } while (TRUE);

            // Walk through the script map and find the last association.
            // We can't just subtract one from the total length
            // because there is a bug in IIS where sometimes it has a
            // triple terminator instead of a double terminator. <Sigh>
            unsigned int cchCurScriptMap=0;
            while(L'\0'!=pwszCurrentScriptMap[cchCurScriptMap]) {
                cchCurScriptMap+=wcslen(pwszCurrentScriptMap+cchCurScriptMap)+1;
            }

            // create a new script map that has .crl, .cer, and .p7b in it.
            // allocate enough space for the existing map, the three new associations, and the terminating \0.
            unsigned int cchAssocLen=wcslen(pwszCurAssoc)+1;
            pwszNewScriptMap=new WCHAR[cchCurScriptMap+cchAssocLen*3+1];
            if (NULL==pwszNewScriptMap) {
                hr=E_OUTOFMEMORY;
                _LeaveError(hr, "new");
            }

            // build the map
            WCHAR * pwszTravel=pwszNewScriptMap;

            // copy the existing map
            CopyMemory(pwszTravel, pwszCurrentScriptMap, cchCurScriptMap*sizeof(WCHAR));
            pwszTravel+=cchCurScriptMap;

            // add the .cer association
            wcscpy(pwszTravel, pwszCurAssoc);
            wcsncpy(pwszTravel, g_wszDotCer, 4);
            pwszTravel+=cchAssocLen;

            // add the .p7b association
            wcscpy(pwszTravel, pwszCurAssoc);
            wcsncpy(pwszTravel, g_wszDotP7b, 4);
            pwszTravel+=cchAssocLen;

            // add the .crl association
            wcscpy(pwszTravel, pwszCurAssoc);
            wcsncpy(pwszTravel, g_wszDotCrl, 4);
            pwszTravel+=cchAssocLen;

            // add the terminator
            pwszTravel[0]=L'\0';

            // set the new script map
            mr.dwMDIdentifier=MD_SCRIPT_MAPS;
            mr.dwMDAttributes=METADATA_INHERIT;
            mr.dwMDUserType=IIS_MD_UT_FILE;
            mr.dwMDDataType=MULTISZ_METADATA;
            mr.dwMDDataLen=(cchCurScriptMap+cchAssocLen*3+1) * sizeof(WCHAR);
            mr.pbMDData=reinterpret_cast<unsigned char *>(pwszNewScriptMap);
            hr=pIMeta->SetData(hMetaKey, L"", &mr);
            _LeaveIfError(hr, "SetData");
        }

        hr = pIMeta->CloseKey(hMetaKey);
        _LeaveIfError(hr, "CloseKey");

        hMetaKey = NULL;

        // Flush out the changes and close
        hr = pIMeta->SaveData();

// Note: W2k used to swallow this error
        _LeaveIfError(hr, "SaveData");
//      _PrintIfError(hr, "SaveData");
//        hr = S_OK;

        // Create a 'web application' so that scrdenrl.dll runs in-process
        if (fCreateApp)
        {
            // Create an instance of the metabase object
            hr = CoCreateInstance(
                            CLSID_WamAdmin,
                            NULL,
                            CLSCTX_ALL,
                            IID_IWamAdmin,
                            (void **) &pIWam);
	    _LeaveIfError(hr, "CoCreateInstance");

            // Create the application running in-process

            hr = pIWam->AppCreate(pwszNewPath, TRUE);
            _LeaveIfError(hr, "AppCreate");
        }

    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != pwszCurrentScriptMap)
    {
        delete [] pwszCurrentScriptMap;
    }
    if (NULL != pwszNewScriptMap)
    {
        delete [] pwszNewScriptMap;
    }
    if (NULL != pwszNewPath)
    {
        delete [] pwszNewPath;
    }
    if (pIMeta && NULL != hMetaKey)
    {
        pIMeta->CloseKey(hMetaKey);
    }
    if (NULL != hMetaRoot)
    {
        hr = vrCloseKey(pIMeta, hMetaRoot, hr);
    }
    if (NULL != pIWam)
    {
        pIWam->Release();
    }
    if (NULL != pIMeta)
    {
        pIMeta->Release();
    }
    return(hr);
}


BOOL
TestForVDir(
    IN WCHAR *pwszVRootName)
{
    HRESULT hr;
    IMSAdminBase *pIMeta = NULL;
    BOOL fExists = FALSE;
    BOOL fCoInit = FALSE;
    METADATA_HANDLE hMetaRoot = NULL;   // Open key to ROOT (where VDirs live)
    METADATA_HANDLE hTestHandle = NULL;

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    if (!IsIISInstalled(&hr))
    {
        goto error;     // Ignore if IIS is not functioning or not installed
    }

    // Create an instance of the metabase object
    hr = CoCreateInstance(
                      CLSID_MSAdminBase,
                      NULL,
                      CLSCTX_ALL,
                      IID_IMSAdminBase,
                      (void **) &pIMeta);
    _JumpIfError(hr, error, "CoCreateInstance");

    __try
    {
        hr = vrOpenRoot(pIMeta, TRUE, &hMetaRoot);
        _LeaveIfError(hr, "vrOpenRoot");

        // If we got here, we must have the master root handle
        // look for VDir

        hr = pIMeta->OpenKey(
                        hMetaRoot,
                        pwszVRootName,
                        METADATA_PERMISSION_READ,
                        1000,
                        &hTestHandle);

        DBGPRINT((
            DBG_SS_CERTLIBI,
            "TestForVDir: OpenKey(%ws) --> %x\n",
            pwszVRootName,
            hr));

        if (S_OK != hr)
        {
            hr = S_OK;
            __leave;
        }
        fExists = TRUE;

        hr = pIMeta->CloseKey(hTestHandle);
        _LeaveIfError(hr, "CloseKey");
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != hMetaRoot)
    {
        hr = vrCloseKey(pIMeta, hMetaRoot, hr);
    }
    if (NULL != pIMeta)
    {
        pIMeta->Release();
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    return(fExists);
}

#define SZ_HKEY_IIS_REGVROOT L"SYSTEM\\CurrentControlSet\\Services\\W3SVC\\Parameters\\Virtual Roots"

HRESULT
RemoveVDir(
    IN WCHAR *pwszVRootName,
    OUT BOOL *pfExisted)
{
    HRESULT hr;
    HRESULT hr2;
    BOOL fCoInit = FALSE;
    IMSAdminBase *pIMeta = NULL;
    METADATA_HANDLE hMetaRoot = NULL;   // Open key to ROOT (where VDirs live)

    *pfExisted = FALSE;
    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    // Create an instance of the metabase object

    hr = CoCreateInstance(
                    CLSID_MSAdminBase,
                    NULL,
                    CLSCTX_ALL,
                    IID_IMSAdminBase,
                    (void **) &pIMeta);
    _JumpIfError(hr, error, "CoCreateInstance");

    __try
    {
        hr = vrOpenRoot(pIMeta, FALSE, &hMetaRoot);
        _LeaveIfError(hr, "vrOpenRoot");

        // If we got to here, we must have the master root handle
        // remove VDir

        hr2 = pIMeta->DeleteAllData(
                                hMetaRoot,
                                pwszVRootName,
                                ALL_METADATA,
                                ALL_METADATA);
        if (S_OK != hr2 && HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) != hr2)
        {
            hr = hr2;
            _PrintError(hr2, "DeleteAllData");
        }
        if (S_OK == hr2)
        {
            *pfExisted = TRUE;
        }

        hr2 = pIMeta->DeleteKey(hMetaRoot, pwszVRootName);
        if (S_OK != hr2 && HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) != hr2)
        {
            if (S_OK == hr)
            {
                hr = hr2;
            }
            _PrintError(hr2, "DeleteKey");
        }

        // HACKHACK: IIS reports S_OK in all cases above.  However, if IIS is
	// stopped, it will recreate vroots when restarted. We have to delete
	// them from the registry manually (bleah!).

	{
	    HKEY hKey;

	    hr2 = RegOpenKeyEx(
			HKEY_LOCAL_MACHINE,
			SZ_HKEY_IIS_REGVROOT,
			0,
			KEY_SET_VALUE,
			&hKey);
	    _PrintIfError2(hr2, "RegDeleteValue", ERROR_FILE_NOT_FOUND);
	    if (hr2 == S_OK)
	    {
		WCHAR wsz[MAX_PATH + 1];

		if (wcslen(pwszVRootName) + 2 > ARRAYSIZE(wsz))
		{
		    CSASSERT(!"pwszVRootName too long!");
		}
		else
		{
		    wsz[0] = L'/';
		    wcscpy(&wsz[1], pwszVRootName);

		    hr2 = RegDeleteValue(hKey, wsz);
		    _PrintIfError2(
			    hr2,
			    "RegDeleteValue (manual deletion of IIS VRoot)",
			    ERROR_FILE_NOT_FOUND);
		}
		RegCloseKey(hKey);
	    }

	    // ignore missing vroot entries

	    if (S_OK == hr && (HRESULT) ERROR_FILE_NOT_FOUND != hr2)
	    {
		hr = hr2;
	    }
	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }

error:
    if (NULL != hMetaRoot)
    {
        hr = vrCloseKey(pIMeta, hMetaRoot, hr);
    }
    if (NULL != pIMeta)
    {
        pIMeta->Release();
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    return(hr);
}

//+------------------------------------------------------------------------
//  Function:   vrModifyVirtualRoots()
//
//  Synopsis:   Creates the virtual roots needed for cert server web pages.
//
//  Effects:    Creates IIS Virtual Roots
//
//  Arguments:  None.
//-------------------------------------------------------------------------

HRESULT
vrModifyVirtualRoots(
    IN BOOL fCreate,            // else Delete
    IN BOOL fNTLM,
    OPTIONAL OUT DWORD *pDisposition)
{
    HRESULT hr;
    HRESULT hr2;
    WCHAR wszSystem32Path[MAX_PATH];
    WCHAR wszVRootPathTemp[MAX_PATH];
    BOOL fCoInit = FALSE;
    VROOTENTRY *pavr;
    BOOL fExist;
    DWORD Disposition = 0;

    if (NULL != pDisposition)
    {
        *pDisposition = 0;
    }
    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = TRUE;

    DBGPRINT((
        DBG_SS_CERTLIBI,
        "vrModifyVirtualRoots(tid=%x, fCreate=%d, fNTLM=%d)\n",
        GetCurrentThreadId(),
        fCreate,
        fNTLM));

    if (!IsIISInstalled(&hr))
    {
        // IIS is not functioning or not installed

        _PrintError2(hr, "IsIISInstalled", hr);
        hr = S_OK;
        Disposition = VFD_NOTSUPPORTED;
        goto error;
    }

    // Create path for SYSTEM32 directory

    if (0 == GetSystemDirectory(wszSystem32Path, ARRAYSIZE(wszSystem32Path)))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSystemDirectory");
    }

    // Create virtual roots

    for (pavr = g_avr; NULL != pavr->pwszVRootName; pavr++)
    {
        CSASSERT(ARRAYSIZE(wszVRootPathTemp) >
            wcslen(wszSystem32Path) + wcslen(pavr->pwszDirectory));

        wcscpy(wszVRootPathTemp, wszSystem32Path);
        wcscat(wszVRootPathTemp, pavr->pwszDirectory);

        if (fCreate)
        {
            if (0 == (VRE_DELETEONLY & pavr->Flags))    // if not obsolete
            {
                hr = AddNewVDir(
                    pavr->pwszVRootName,
                    wszVRootPathTemp,
                    (VRE_SCRIPTMAP & pavr->Flags)? TRUE : FALSE,
                    (fNTLM && (VRE_ALLOWNTLM & pavr->Flags))? TRUE : FALSE,
                    (VRE_CREATEAPP & pavr->Flags)? TRUE : FALSE,
                    &fExist);
                if (S_OK != hr)
                {
                    Disposition = VFD_CREATEERROR;
                    _JumpErrorStr(hr, error, "AddNewVDir", pavr->pwszVRootName);
                }
                Disposition = fExist? VFD_EXISTS : VFD_CREATED;
            }
        }
        else // else Delete
        {
            hr2 = RemoveVDir(pavr->pwszVRootName, &fExist);
            if (0 == (VRE_DELETEONLY & pavr->Flags))    // if not obsolete
            {
                if (S_OK != hr2)
                {
                    if (S_OK == hr)
                    {
                        hr = hr2;
                    }
                    Disposition = VFD_DELETEERROR;
                    _PrintError(hr2, "RemoveVDir");
                }
                else
                {
                    Disposition = fExist? VFD_DELETED : VFD_NOTFOUND;
                }
            }
        }
    }

error:
    if (NULL != pDisposition)
    {
        *pDisposition = Disposition;
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    DBGPRINT((
        DBG_SS_CERTLIBI,
        "vrModifyVirtualRoots(tid=%x, hr=%x, disp=%d)\n",
        GetCurrentThreadId(),
        hr,
        Disposition));
    return(hr);
}


// myAddShare: create and test new net share
HRESULT
myAddShare(
    LPCWSTR szShareName,
    LPCWSTR szShareDescr,
    LPCWSTR szSharePath,
    BOOL fOverwrite,
    OPTIONAL BOOL *pfCreated)
{
    HRESULT hr;
    BOOL fCreated = FALSE;

    HANDLE hTestFile = INVALID_HANDLE_VALUE;
    LPWSTR pwszTestComputerName = NULL;
    LPWSTR pwszTestUNCPath = NULL;

    // Share local path
    SHARE_INFO_502 shareStruct;
    ZeroMemory(&shareStruct, sizeof(shareStruct));

    shareStruct.shi502_netname = const_cast<WCHAR *>(szShareName);
    shareStruct.shi502_type = STYPE_DISKTREE;
    shareStruct.shi502_remark = const_cast<WCHAR *>(szShareDescr);
    shareStruct.shi502_max_uses = MAXDWORD;
    shareStruct.shi502_path = const_cast<WCHAR *>(szSharePath);

    hr = myGetSDFromTemplate(WSZ_DEFAULT_SHARE_SECURITY,
                             NULL,
                             &shareStruct.shi502_security_descriptor);
    _JumpIfError(hr, error, "myGetSDFromTemplate");

    hr = NetShareAdd(
        NULL,               // this computer
        502,                // SHARE_LEVEL_502 struct
        (BYTE *) &shareStruct,
        NULL);
    fCreated = (S_OK == hr);

    if (hr == (HRESULT) NERR_DuplicateShare)
    {
        SHARE_INFO_2* pstructDupShare = NULL;

        hr = NetShareGetInfo(
            NULL,
            const_cast<WCHAR *>(szShareName),
            2,
            (BYTE **) &pstructDupShare);
        _JumpIfError(hr, error, "NetShareGetInfo");

        if (0 == wcscmp(pstructDupShare->shi2_path, szSharePath))
        {
            // they're the same path, so we're okay!
            hr = S_OK;
        }
        else if (fOverwrite)
        {
            // not the same path, but we've been instructed to bash existing

            // remove offending share
            hr = NetShareDel(
                NULL,
                const_cast<WCHAR *>(szShareName),
                0);
            if (S_OK == hr)
            {
                // try again
                hr = NetShareAdd(
                    NULL,               // this computer
                    502,                // SHARE_LEVEL_502 struct
                    (BYTE *) &shareStruct,
                    NULL);
                fCreated = (S_OK == hr);
            }
        }
        if (NULL != pstructDupShare)
	{
            NetApiBufferFree(pstructDupShare);
	}
    }

    // if share does not exist by this time, we bail
    _JumpIfError(hr, error, "NetShareAdd");

    // TEST: is writable?
#define UNCPATH_TEMPLATE     L"\\\\%ws\\%ws\\write.tmp"

    hr = myGetMachineDnsName(&pwszTestComputerName);
    _JumpIfError(hr, error, "myGetMachineDnsName");

    // get the local machine name
    pwszTestUNCPath = (LPWSTR)LocalAlloc(LMEM_FIXED,
            (UINT)(( ARRAYSIZE(UNCPATH_TEMPLATE) +
              wcslen(pwszTestComputerName) +
              wcslen(szShareName) )
            *sizeof(WCHAR)));
    if (NULL == pwszTestUNCPath)
    {
	hr = E_OUTOFMEMORY;
	_JumpError(hr, error, "LocalAlloc");
    }

    // create UNC path
    swprintf(pwszTestUNCPath, UNCPATH_TEMPLATE, pwszTestComputerName, szShareName);

    hTestFile = CreateFile(
        pwszTestUNCPath,
        GENERIC_WRITE,
        FILE_SHARE_WRITE,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE,
        NULL);
    if (hTestFile == INVALID_HANDLE_VALUE)
    {
        hr = myHLastError();
        _JumpErrorStr(hr, error, "CreateFile (test for UNC translation)", pwszTestUNCPath);
    }

    // if we got this far, our test went well
    hr = S_OK;

error:
    // if created and then something went wrong, clean up
    if (fCreated && (hr != S_OK))
    {
        // don't mash hr
        HRESULT hr2;
        hr2 = NetShareDel(
            NULL,
            const_cast<WCHAR *>(szShareName),
            0);
        // ignore NetShareDel hr
        _PrintIfError(hr2, "NetShareDel");    // not fatal, might already be shared
    }

    if (INVALID_HANDLE_VALUE != hTestFile)
        CloseHandle(hTestFile);

    if (NULL != pwszTestComputerName)
        LocalFree(pwszTestComputerName);

    if (NULL != pwszTestUNCPath)
        LocalFree(pwszTestUNCPath);

    if(shareStruct.shi502_security_descriptor)
    {
        LocalFree(shareStruct.shi502_security_descriptor);
    }

    if(pfCreated)
        *pfCreated = fCreated;

    return hr;
}


HRESULT
vrModifyFileShares(
    IN BOOL fCreate,            // else Delete
    OPTIONAL OUT DWORD *pDisposition)
{
    HRESULT hr;
    WCHAR wszSystem32Dir[MAX_PATH];
    WCHAR wszRemark[512];
    WCHAR *pwszDirectory = NULL;
    DWORD Disposition = 0;
    BOOL  fCreated = FALSE;

    if (NULL != pDisposition)
    {
        *pDisposition = 0;
    }
    if (fCreate)
    {
        if (0 == GetSystemDirectory(wszSystem32Dir, ARRAYSIZE(wszSystem32Dir)))
        {
            hr = myHLastError();
            _JumpError(hr, error, "GetSystemDirectory");
        }
        hr = myBuildPathAndExt(
                        wszSystem32Dir,
                        wszCERTENROLLSHAREPATH,
                        NULL,
                        &pwszDirectory);
        _JumpIfError(hr, error, "myBuildPathAndExt");

        if (!LoadString(
                    g_hInstance,
                    IDS_FILESHARE_REMARK,
                    wszRemark,
                    ARRAYSIZE(wszRemark)))
        {
            hr = myHLastError();
            CSASSERT(S_OK != hr);
            _JumpError(hr, error, "LoadString");
        }

        hr = myAddShare(wszCERTENROLLSHARENAME,
                   wszRemark,
                   pwszDirectory,
                   TRUE,
                   &fCreated);
        if (S_OK == hr)
        {
            Disposition = fCreated? VFD_CREATED : VFD_EXISTS;
        }
        else if(HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE) == hr)
        {
            // Could not validate the share. Can happen if net cable is disconnected.
            // Put a warning message and ignore the error.
            Disposition = VFD_VERIFYERROR;
            hr = S_OK;
        }
		else
        {
            Disposition = VFD_CREATEERROR;
            _JumpErrorStr(hr, error, "NetShareAdd", wszCERTENROLLSHARENAME);
        }
    }
    else
    {
        hr = NetShareDel(NULL, wszCERTENROLLSHARENAME, NULL);
        CSASSERT(NERR_Success == S_OK);
        if (S_OK == hr)
        {
            Disposition = VFD_DELETED;
        }
        else if ((HRESULT) NERR_NetNameNotFound == hr)
        {
            Disposition = VFD_NOTFOUND;
            hr = S_OK;
        }
        else
        {
            Disposition = VFD_DELETEERROR;
            _JumpErrorStr(hr, error, "NetShareDel", wszCERTENROLLSHARENAME);
        }
    }
    NetShareDel(NULL, L"CertSrv", NULL);        // delete old share name

error:
    if (NULL != pDisposition)
    {
        *pDisposition = Disposition;
    }
    if (NULL != pwszDirectory)
    {
        LocalFree(pwszDirectory);
    }
    return(myHError(hr));
}


// For now, this writes the entry "CertUtil -vroot", and is not generalized
HRESULT
myWriteRunOnceEntry(
    IN BOOL fAdd // Add or Remove entry?
    )
{
    DWORD err;

    // Add certutil -vroot to runonce commands
    WCHAR szRunOnceCommand[] = L"certutil -vroot";
    HKEY hkeyRunOnce = NULL;
    DWORD dwDisposition;

    err = RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce",         // address of subkey name
        0,
        NULL,
        0,
        KEY_SET_VALUE,
        NULL,
        &hkeyRunOnce,
        &dwDisposition);
    _JumpIfError(err, error, "RegCreateKeyEx");

    // add or remove entry?
    if (fAdd)
    {
        err = RegSetValueEx(
            hkeyRunOnce,
            L"Certificate Services",
            0,
            REG_SZ,
            (BYTE *) szRunOnceCommand,
            sizeof(szRunOnceCommand));
        _JumpIfError(err, error, "RegSetValueEx");
    }
    else
    {
        err = RegDeleteValue(hkeyRunOnce, L"Certificate Services");
        _PrintIfError2(err, "RegDeleteValue", ERROR_FILE_NOT_FOUND);
	if (ERROR_FILE_NOT_FOUND == err)
	{
	    err = ERROR_SUCCESS;
	}
        _JumpIfError(err, error, "RegDeleteValue");
    }

error:
    if (hkeyRunOnce)
        RegCloseKey(hkeyRunOnce);

    return (myHError(err));
}


DWORD
vrWorkerThread(
    OPTIONAL IN OUT VOID *pvparms)
{
    HRESULT hr = S_OK;
    HRESULT hr2;
    VRFSPARMS *pparms = (VRFSPARMS *) pvparms;
    DWORD Disposition;
    BOOL fFailed = FALSE;

    CSASSERT(NULL != pparms);

    if ((VFF_CREATEFILESHARES | VFF_DELETEFILESHARES) & pparms->Flags)
    {
        hr = vrModifyFileShares(
            (VFF_CREATEFILESHARES & pparms->Flags)? TRUE : FALSE,
            &Disposition);
        _PrintIfError(hr, "vrModifyFileShares");
        if (NULL != pparms->pShareDisposition)
        {
            *pparms->pShareDisposition = Disposition;
        }
        if (VFD_CREATEERROR == Disposition || VFD_DELETEERROR == Disposition)
        {
            fFailed = TRUE;
        }
    }
    if ((VFF_CREATEVROOTS | VFF_DELETEVROOTS) & pparms->Flags)
    {
        BOOL fNTLM = FALSE;             // set fNTLM iff Enterprise CA

        if (IsEnterpriseCA(pparms->CAType))
        {
            fNTLM = TRUE;
        }

        hr2 = vrModifyVirtualRoots(
            (VFF_CREATEVROOTS & pparms->Flags)? TRUE : FALSE,
            fNTLM,
            &Disposition);
        _PrintIfError2(hr2, "vrModifyVirtualRoots", S_FALSE);
        if (S_OK == hr)
        {
            hr = hr2;
        }
        if (NULL != pparms->pVRootDisposition)
        {
            *pparms->pVRootDisposition = Disposition;
        }
        if (VFD_CREATEERROR == Disposition || VFD_DELETEERROR == Disposition)
        {
            fFailed = TRUE;
        }

        if (S_OK == hr)
        {
            if (VFF_CREATEVROOTS & pparms->Flags)
	    {
                DWORD ASPDisposition;
                BOOL fEnabledASP;

		hr2 = EnableASPInIIS(&fEnabledASP);
		_PrintIfError(hr2, "EnableASPInIIS");

                ASPDisposition = VFD_NOACTION;
                hr2 = SetCertSrvASPDependency();
                _PrintIfError(hr2, "SetCertSrvASPDependency");
                if (S_OK != hr2)
                {
                    ASPDisposition = VFD_CREATEERROR;
                }

		// enable ASP processing in IIS

		if (VFF_ENABLEASP & pparms->Flags)
		{
		    hr2 = EnableASPInIIS_New(&fEnabledASP);
		    _PrintIfError(hr2, "EnableASPInIIS_New");
		    if (S_OK == hr2)
		    {
			ASPDisposition = fEnabledASP? VFD_CREATED : VFD_EXISTS;
		    }
		}
                if (NULL != pparms->pVRootDisposition)
                {
                    *pparms->pVRootDisposition |= (ASPDisposition << 16);
                }
                if (VFD_CREATEERROR == ASPDisposition)
                {
                    fFailed = TRUE;
                }
            }
        }
    }

    if ((S_OK == hr && !fFailed) || ((VFF_DELETEVROOTS) & pparms->Flags)) // on success or removal
    {
        // remove "attempt vroot" flag so we don't try again

        if (VFF_CLEARREGFLAGIFOK & pparms->Flags)
        {
            DBGPRINT((DBG_SS_CERTLIBI, "clearing registry\n"));
            hr = SetSetupStatus(NULL, SETUP_ATTEMPT_VROOT_CREATE, FALSE);
            _JumpIfError(hr, error, "SetSetupStatus");
        }

	hr = myWriteRunOnceEntry(FALSE);    // worker thread deletes on success
	_JumpIfError(hr, error, "myWriteRunOnceEntry");
    }

error:

    LocalFree(pparms);
    DBGPRINT((DBG_SS_CERTLIBI, "vrWorkerThread returns %x\n", hr));
    return(myHError(hr));
}


//+------------------------------------------------------------------------
//  Function:   myModifyVirtualRootsAndFileShares
//
//  Synopsis:   Creates the virtual roots needed for cert server web pages.
//
//  Effects:    Creates IIS Virtual Roots
//
//  Arguments:  None.
//-------------------------------------------------------------------------

HRESULT
myModifyVirtualRootsAndFileShares(
    IN DWORD Flags,             // VFF_*: Create/Delete VRoots and/or Shares
    IN ENUM_CATYPES CAType,
    IN BOOL fAsynchronous,
    IN DWORD csecTimeOut,
    OPTIONAL OUT DWORD *pVRootDisposition,      // VFD_*
    OPTIONAL OUT DWORD *pShareDisposition)      // VFD_*
{
    HRESULT hr;
    HANDLE hThread = NULL;
    HMODULE hMod = NULL;
    DWORD ThreadId;
    DWORD dw;
    BOOL fEnable = TRUE;
    DWORD SetupStatus;
    VRFSPARMS *pparms = NULL;

    if (NULL != pVRootDisposition)
    {
        *pVRootDisposition = 0;
    }
    if (NULL != pShareDisposition)
    {
        *pShareDisposition = 0;
    }
    dw = (VFF_DELETEVROOTS | VFF_DELETEFILESHARES) & Flags;
    if (0 != dw && dw != Flags)
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Mixed VFF_DELETE* and create flags");
    }
    if (((VFF_CHECKREGFLAGFIRST | VFF_CLEARREGFLAGFIRST) & Flags) &&
        (VFF_SETREGFLAGFIRST & Flags))
    {
        hr = E_INVALIDARG;
        _JumpError(hr, error, "Mixed VFF_SETREGFLAGFIRST & VFF_*REGFLAGFIRST");
    }

    hr = GetSetupStatus(NULL, &SetupStatus);
    if (S_OK != hr)
    {
        _PrintError(hr, "GetSetupStatus(ignored)");
        hr = S_OK;
        SetupStatus = 0;
    }

    if (VFF_CHECKREGFLAGFIRST & Flags)
    {
        if (0 == (SETUP_ATTEMPT_VROOT_CREATE & SetupStatus))
        {
            fEnable = FALSE;
        }
    }
    if (VFF_CLEARREGFLAGFIRST & Flags)
    {
        // remove "attempt vroot" flag so we don't try again

        if (SETUP_ATTEMPT_VROOT_CREATE & SetupStatus)
        {
            hr = SetSetupStatus(NULL, SETUP_ATTEMPT_VROOT_CREATE, FALSE);
            _JumpIfError(hr, error, "SetSetupStatus");
        }
    }
    if (VFF_SETREGFLAGFIRST & Flags)
    {
        // set "attempt vroot" flag so we'll try again if necessary

        if (0 == (SETUP_ATTEMPT_VROOT_CREATE & SetupStatus))
        {
            hr = SetSetupStatus(NULL, SETUP_ATTEMPT_VROOT_CREATE, TRUE);
            _JumpIfError(hr, error, "SetSetupStatus");
        }
    }

    hr = S_OK;
    if (fEnable)
    {
        // only set RunOnce on a real attempt (worker thread clears this)
        if (VFF_SETRUNONCEIFERROR & Flags)
        {
            hr = myWriteRunOnceEntry(TRUE);
            _JumpIfError(hr, error, "myWriteRunOnceEntry");
        }

        pparms = (VRFSPARMS *) LocalAlloc(
            LMEM_FIXED | LMEM_ZEROINIT,
            sizeof(*pparms));
        if (NULL == pparms)
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "LocalAlloc");
        }

        pparms->Flags = Flags;
        pparms->CAType = CAType;
        pparms->csecTimeOut = csecTimeOut;
        pparms->fAsynchronous = fAsynchronous;
        if (!fAsynchronous)
        {
            pparms->pVRootDisposition = pVRootDisposition;
            pparms->pShareDisposition = pShareDisposition;
        }
        else
        {
            hMod = LoadLibrary(g_wszCertCliDotDll);
            if (NULL == hMod)
            {
                hr = myHLastError();
                _JumpError(hr, error, "LoadLibrary");
            }
        }

        hThread = CreateThread(
            NULL,       // lpThreadAttributes (Security Attr)
            0,          // dwStackSize
            vrWorkerThread,
            pparms,     // lpParameter
            0,          // dwCreationFlags
            &ThreadId);
        if (NULL == hThread)
        {
            hr = myHLastError();
            _JumpError(hr, error, "CreateThread");
        }

        pparms = NULL;          // freed by the new thread

        DBGPRINT((DBG_SS_CERTLIBI, "VRoot Worker Thread = %x\n", ThreadId));

        // asynch? proper thread creation is all we do
        if (fAsynchronous)
        {
            hr = S_OK;
            goto error;
        }

        // Wait for the worker thread to exit
        hr = WaitForSingleObject(
                   hThread,
                   (INFINITE == csecTimeOut) ? INFINITE : csecTimeOut * 1000 );
        DBGPRINT((DBG_SS_CERTLIBI, "Wait for worker thread returns %x\n", hr));
        if ((HRESULT) WAIT_OBJECT_0 == hr)
        {
            // worker thread returned.

            if (!GetExitCodeThread(hThread, (DWORD *) &hr))
            {
                hr = myHLastError();
                _JumpError(hr, error, "GetExitCodeThread");
            }
            DBGPRINT((DBG_SS_CERTLIBI, "worker thread exit: %x\n", hr));
            if (S_OK != hr)
            {
                // If not synchronous, leave DLL loaded...

                hMod = NULL;
                _JumpError(hr, error, "vrWorkerThread");
            }
        }
        else
        {
             // timeout: abandoning thread, leave the dll loaded
             hMod = NULL;
             _PrintError(hr, "WaitForSingleObject (ignored)");

             // whack error
             hr = S_OK;
        }

    }

error:
    if (NULL != pparms)
    {
        LocalFree(pparms);
    }
    if (NULL != hThread)
    {
        CloseHandle(hThread);
    }
    if (NULL != hMod)
    {
        FreeLibrary(hMod);
    }
    DBGPRINT((DBG_SS_CERTLIBI, "myModifyVirtualRootsAndFileShares returns %x\n", hr));
    return(myHError(hr));
}

//-------------------------------------------------------------------------
//
//  ASP/IIS related functions
//
//-------------------------------------------------------------------------

#define MD_ISAPI_RESTRICTION_LIST_OBSOLETE	(IIS_MD_HTTP_BASE+163)
METADATA_RECORD ASPRestrictionsMDData = 
{
    MD_ISAPI_RESTRICTION_LIST_OBSOLETE,
    0,
    IIS_MD_UT_SERVER,
    MULTISZ_METADATA,
    0,
    NULL,
    0
};

METADATA_RECORD ApplicationDependenciesMDData = 
{
    MD_APP_DEPENDENCIES,
    0,
    IIS_MD_UT_SERVER,
    MULTISZ_METADATA,
    0,
    NULL,
    0
};

METADATA_RECORD WebSvcExtRestrictionsMDData = 
{
    MD_WEB_SVC_EXT_RESTRICTION_LIST,
    0,
    IIS_MD_UT_SERVER,
    MULTISZ_METADATA,
    0,
    NULL,
    0
};

const WCHAR g_wchExtensionOff = L'0';
const WCHAR g_wchExtensionOn  = L'1';
LPCWSTR g_pcwszAspDll = L"asp.dll";


//+------------------------------------------------------------------------
//  Builds the full path to asp.dll
//-------------------------------------------------------------------------
HRESULT BuildASPDllFullPath(LPWSTR &rpwszAspPath)
{
    HRESULT hr;
    WCHAR wszAsp[MAX_PATH];
    LPCWSTR pcwszAsp = L"\\inetsrv\\asp.dll";

    if (0 == GetSystemDirectory(wszAsp, MAX_PATH))
    {
        hr = myHLastError();
        _JumpError(hr, error, "GetSystemDirectory");
    }

    rpwszAspPath = (LPWSTR)LocalAlloc(LMEM_FIXED, 
        sizeof(WCHAR)*(wcslen(wszAsp)+wcslen(pcwszAsp)+1));
    _JumpIfAllocFailed(rpwszAspPath, error);

    wcscpy(rpwszAspPath, wszAsp);
    wcscat(rpwszAspPath, pcwszAsp);

    hr = S_OK;

error:
    return hr;
}

//+------------------------------------------------------------------------
//  Saves the list of ASP restrictions to IIS metabase. IIS restriction
//  list it's a multisz that looks like this:
// 
//      "1","DLL1","DLL2"...
//   or
//      "0","DLL1","DLL2"...
//
//  When list starts with "1", the meaning is "enable all ASP DLLs
//  excluding the list that follows". When it begins with "0", it means
//  "disable all except the list".
//-------------------------------------------------------------------------
HRESULT SetASPRestrictions(CMultiSz& ASPRestrictionList)
{
    HRESULT hr;
    IMSAdminBase *pIMeta = NULL;
    METADATA_HANDLE hMetaRoot = NULL;
    void * pBuffer = NULL;
    DWORD cBuffer;
    bool fCoInit = false;

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = true;

    hr = ASPRestrictionList.Marshal(pBuffer, cBuffer);
    _JumpIfError(hr, error, "CMultiSz::Marshal");

    ASPRestrictionsMDData.pbMDData      = (unsigned char *)pBuffer;
    ASPRestrictionsMDData.dwMDDataLen   = cBuffer;

    hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (void **) &pIMeta);
    _JumpIfError(hr, error, "CoCreateInstance");

    hr = pIMeta->OpenKey(
        METADATA_MASTER_ROOT_HANDLE,
        g_wszW3SVC,
        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
        1000,
        &hMetaRoot);
    _JumpIfErrorStr(hr, error, "OpenKey", g_wszW3SVC);

    hr = pIMeta->SetData(hMetaRoot, L"", &ASPRestrictionsMDData);
    _JumpIfError(hr, error, "SetData");

    hr = pIMeta->CloseKey(hMetaRoot);
    _JumpIfError(hr, error, "CloseKey");

    hMetaRoot = NULL;

    hr = pIMeta->SaveData();
    _JumpIfError(hr, error, "SaveData");

error:
    LOCAL_FREE(pBuffer);

    ASPRestrictionsMDData.pbMDData      = NULL;
    ASPRestrictionsMDData.dwMDDataLen   = 0;

    if (NULL != hMetaRoot)
    {
        pIMeta->CloseKey(hMetaRoot);
    }
    if(pIMeta)
    {
        pIMeta->Release();
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    return hr;
}

//+------------------------------------------------------------------------
//  Loads the list of ASP restrictions from IIS metabase.
//-------------------------------------------------------------------------
HRESULT GetASPRestrictions(CMultiSz& ASPRestrictionList)
{
    HRESULT hr;
    IMSAdminBase *pIMeta = NULL;
    METADATA_HANDLE hMetaRoot = NULL;
    DWORD dwSize;
    bool fCoInit = false;

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = true;

    hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (void **) &pIMeta);
    _JumpIfError(hr, error, "CoCreateInstance");

    hr = pIMeta->OpenKey(
        METADATA_MASTER_ROOT_HANDLE,
        g_wszW3SVC,
        METADATA_PERMISSION_READ,
        1000,
        &hMetaRoot);
    _JumpIfErrorStr(hr, error, "OpenKey", g_wszW3SVC);

    hr = pIMeta->GetData(hMetaRoot, L"", &ASPRestrictionsMDData, &dwSize);
    if(MD_ERROR_DATA_NOT_FOUND==hr)
    {
        // value not set means ASP not enabled, return empty list
        hr = S_OK;
    }
    else
    {
        if(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
        {
            _JumpErrorStr(hr, error, "GetData", g_wszW3SVC);
        }

        hr = S_OK;

        ASPRestrictionsMDData.pbMDData = (unsigned char*) LocalAlloc(LMEM_FIXED, dwSize);
        _JumpIfAllocFailed(ASPRestrictionsMDData.pbMDData, error);

        ASPRestrictionsMDData.dwMDDataLen = dwSize;

        hr = pIMeta->GetData(hMetaRoot, L"", &ASPRestrictionsMDData, &dwSize);
        _JumpIfErrorStr(hr, error, "OpenKey", g_wszW3SVC);

        hr = ASPRestrictionList.Unmarshal(ASPRestrictionsMDData.pbMDData);
        _JumpIfError(hr, error, "Unmarshal");
    }

error:

    LOCAL_FREE(ASPRestrictionsMDData.pbMDData);
    
    ASPRestrictionsMDData.pbMDData      = NULL;
    ASPRestrictionsMDData.dwMDDataLen   = 0;

    if (NULL != hMetaRoot)
    {
        pIMeta->CloseKey(hMetaRoot);
    }
    if(pIMeta)
    {
        pIMeta->Release();
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    return hr;
}

//+------------------------------------------------------------------------
//
//	Verify if this is MSCEP setup specific
//
//
//+------------------------------------------------------------------------
HRESULT	SetupMSCEPForIIS(LPCWSTR pcwszExtension);

BOOL	IsMSCEPSetup(LPCWSTR pwsz, LPCWSTR pwszDLL)
{
	BOOL	fResult=FALSE;
	LPWSTR	pwchar=NULL;

	if((NULL == pwsz) || (NULL == pwszDLL))
		goto error;

	pwchar=wcsrchr(pwsz, L'\\');

	if(NULL == pwchar)
		goto error;

	pwchar++;

	if(0 != _wcsicmp(pwchar, pwszDLL))
		goto error;

	fResult=TRUE;

error:

	return fResult;
}

//+------------------------------------------------------------------------
//  Tests if this ISAPI extension is enabled in IIS.
//  If IIS restriction starts with a "1":
//      "1", "DLL1", "DLL2" ...
//  it means run all but specified DLLs; if we find the extension
//  in the list then it's disabled
//
//  If IIS restriction starts with a "0":
//      "0", "DLL1", "DLL2" ...
//  the meaning is disable all but specified DLLs; if we find
//  the extension then it's enabled
//-------------------------------------------------------------------------
HRESULT IsISAPIExtensionEnabled(
    LPCWSTR pcwszExtension,
    bool& rfEnabled)
{
    HRESULT hr;
    CMultiSz ASPRestrictionList;
    CMultiSzEnum ASPRestrictionListEnum;

    rfEnabled = false;

	//special case for mscep.dll.  Always return FALSE to 
	//proceed with the installation
	if(IsMSCEPSetup(pcwszExtension, g_wszMSCEP))
	{
		rfEnabled=FALSE;
		return S_OK;
	}

    hr = GetASPRestrictions(ASPRestrictionList);
    _JumpIfError(hr, error, "GetASPRestrictionList");
    
    if(!ASPRestrictionList.IsEmpty())
    {
        ASPRestrictionListEnum.Set(ASPRestrictionList);
        const CString *pStr = ASPRestrictionListEnum.Next();
        bool fRunAllExceptTheseDlls = false;

        if(0 == wcscmp(*pStr, L"1"))
        {
            fRunAllExceptTheseDlls = true;
        }

        for(pStr = ASPRestrictionListEnum.Next();
            pStr;
            pStr = ASPRestrictionListEnum.Next())
        {
            if(0 == _wcsicmp(pcwszExtension, *pStr))
                break;
        }

        // XOR: Enable if "1" is found but asp.dll not present or "0" (!"1")
        // is found but asp.dll present
        rfEnabled = fRunAllExceptTheseDlls ^ (NULL != pStr);
    }                          

    hr = S_OK;

error:
    return hr;
}

//+------------------------------------------------------------------------
//  Tests if ASP processing is enabled in IIS.
//-------------------------------------------------------------------------
HRESULT IsASPEnabledInIIS(
    bool& rfEnabled)
{
    HRESULT hr;
    LPWSTR pwszAsp = NULL;

    hr = BuildASPDllFullPath(pwszAsp);
    _JumpIfError(hr, error, "GetASPDllFullPath");

    hr = IsISAPIExtensionEnabled(
        pwszAsp,
        rfEnabled);
    _JumpIfErrorStr(hr, error, "GetASPDllFullPath", pwszAsp);

error:
    LOCAL_FREE(pwszAsp);
    return hr;
}

//+------------------------------------------------------------------------
//  Enables ISAPI extension in IIS.
//
//  - if list is empty/not found, set it to "0","extension", ie only enable 
//    this extension
//  - if list starts with "1", remove extension if found
//  - if list starts with "0", add extension if not already present
//-------------------------------------------------------------------------

#pragma warning(push)		// BUGBUG: nonstandard extension used : 'argument' : conversion from 'CString' to 'C &'
#pragma warning(disable: 4239)	// BUGBUG: nonstandard extension used : 'argument' : conversion from 'CString' to 'C &'
HRESULT
EnableISAPIExtension(
    IN LPCWSTR pcwszExtension,
    OUT BOOL *pfEnabledASP)
{
    HRESULT hr;
    CMultiSz ASPRestrictionList;
    CMultiSzEnum ASPRestrictionListEnum;
    CString *pStr;
    DWORD dwIndex;
    bool fUpdateIt = false;

    *pfEnabledASP = FALSE;

	//special case for mscep.dll.  
	if(IsMSCEPSetup(pcwszExtension, g_wszMSCEP))
	{
		hr=SetupMSCEPForIIS(pcwszExtension);
		_JumpIfError(hr, error, "SetupMSCEPForIIS");
	}


    hr = GetASPRestrictions(ASPRestrictionList);
    _JumpIfError(hr, error, "GetASPRestrictions");

    ASPRestrictionListEnum.Set(ASPRestrictionList);
    pStr = ASPRestrictionListEnum.Next();

    if(!pStr)
    {
        // list is empty, add "0"
        pStr = new CString(L"0");
        if(!pStr || pStr->IsEmpty())
        {
            hr = E_OUTOFMEMORY;
            _JumpError(hr, error, "new");
        }
        ASPRestrictionList.AddTail(pStr);
    }

    dwIndex = ASPRestrictionList.FindIndex(CString(pcwszExtension));
   
    if(0 == wcscmp(*pStr, L"0"))
    {
        // List means "disable all but the following DLLs". 
        // To enable it add ASP dll if not already there.

        if(DWORD_MAX == dwIndex)
        {
            CString * pAsp = new CString(pcwszExtension);
            if(!pAsp || pAsp->IsEmpty())
            {
                hr = E_OUTOFMEMORY;
                _JumpError(hr, error, "new");
            }
            ASPRestrictionList.AddTail(pAsp);
            fUpdateIt = true;
        }
    }
    else
    {
        // List means "enable all but the following DLLs", to enable it
        // remove extension if found
        dwIndex = ASPRestrictionList.FindIndex(CString(pcwszExtension));

        if(DWORD_MAX != dwIndex)
        {
            ASPRestrictionList.RemoveAt(dwIndex);
            fUpdateIt = true;
        }
    }

    if (fUpdateIt)
    {
        hr = SetASPRestrictions(ASPRestrictionList);
        _JumpIfError(hr, error, "SetASPRestrictions");  

	*pfEnabledASP = TRUE;
    }

error:
    return S_OK;
}
#pragma warning(pop)	// BUGBUG: nonstandard extension used : 'argument' : conversion from 'CString' to 'C &'


//+------------------------------------------------------------------------
//  Enables ASP processing in IIS.
//-------------------------------------------------------------------------

HRESULT
EnableASPInIIS(
    OUT BOOL *pfEnabledASP)
{
    HRESULT hr;
    LPWSTR pwszAsp = NULL;

    *pfEnabledASP = FALSE;

    hr = BuildASPDllFullPath(pwszAsp);
    _JumpIfError(hr, error, "GetASPDllFullPath");

    hr = EnableISAPIExtension(pwszAsp, pfEnabledASP);
    _JumpIfErrorStr(hr, error, "GetASPDllFullPath", pwszAsp);

error:
    LOCAL_FREE(pwszAsp);
    return S_OK;
}



//+------------------------------------------------------------------------
//  New APIs after IIS redesigning of enabling/disabling extensions
//-------------------------------------------------------------------------

HRESULT
SetMultiSzIISMetadata(
    METADATA_RECORD& MDRecord, 
    CMultiSz& MultiSz);

HRESULT
GetMultiSzIISMetadata(
    METADATA_RECORD& MDRecord, 
    CMultiSz& MultiSz);

//+------------------------------------------------------------------------
//  Searches for the websvc specified extension and turns it on if needed
//-------------------------------------------------------------------------
HRESULT
EnableWebSvcExtension(
    IN LPCWSTR pcwszExtDll, // e.g. "asp.dll"
    OUT BOOL *pfEnabled)
{
    HRESULT hr = S_OK;
    CMultiSz WebSvcExtRestrictions;
    CMultiSzEnum WebSvcExtRestrictionsEnum;
    CString *pstr;
    CString strTmp;
    CString strExtDll = pcwszExtDll;

    *pfEnabled = FALSE;

    _wcslwr(strExtDll.GetBuffer());  // we need to find case insensitive, we'll 
                                    // also wcslwr the strings from list

    hr = GetMultiSzIISMetadata(WebSvcExtRestrictionsMDData, WebSvcExtRestrictions);
    _JumpIfError(hr, error, "GetMultiSzIISMetadata");

    WebSvcExtRestrictionsEnum.Set(WebSvcExtRestrictions);
    
    for(pstr = WebSvcExtRestrictionsEnum.Next();
        pstr;
        pstr = WebSvcExtRestrictionsEnum.Next())
    {
        // create a copy so we don't modify the original string
        strTmp = *pstr;

        _wcslwr(strTmp.GetBuffer());

        if(NULL != wcsstr(strTmp, strExtDll))
        {
            if(g_wchExtensionOff == *(pstr->GetBuffer()))
            {
                *(pstr->GetBuffer()) = g_wchExtensionOn;
                *pfEnabled = TRUE;
            }
            break;
        }
    }

    if(!pstr)
    {
        hr = ERROR_NOT_FOUND;
        _JumpErrorStr(hr, error, "extension was not found in WebSvcExtRestrictions", pcwszExtDll);
    }

    if(TRUE == *pfEnabled)
    {
        hr = SetMultiSzIISMetadata(WebSvcExtRestrictionsMDData, WebSvcExtRestrictions);
        _JumpIfError(hr, error, "GetISAPIRestrictions");
    }

error:
    return hr;
}


//+------------------------------------------------------------------------
//  Enable ASP processing in IIS
//-------------------------------------------------------------------------
HRESULT
EnableASPInIIS_New(
    OUT BOOL *pfEnabledASP)
{
    HRESULT hr;
    LPWSTR pwszAsp = NULL;

    *pfEnabledASP = FALSE;

    hr = EnableWebSvcExtension(g_pcwszAspDll, pfEnabledASP);
    _JumpIfErrorStr(hr, error, "GetASPDllFullPath", pwszAsp);

error:
    LOCAL_FREE(pwszAsp);
    return S_OK;
}

//+------------------------------------------------------------------------
//  Stores a multisz property to IIS metabase root
//-------------------------------------------------------------------------
HRESULT
SetMultiSzIISMetadata(
    METADATA_RECORD& MDRecord, 
    CMultiSz& MultiSz)
{
    HRESULT hr;
    IMSAdminBase *pIMeta = NULL;
    METADATA_HANDLE hMetaRoot = NULL;
    void * pBuffer = NULL;
    DWORD cBuffer;
    bool fCoInit = false;

    CSASSERT(MULTISZ_METADATA == MDRecord.dwMDDataType);

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = true;

    hr = MultiSz.Marshal(pBuffer, cBuffer);
    _JumpIfError(hr, error, "CMultiSz::Marshal");

    CSASSERT(NULL == MDRecord.pbMDData);

    MDRecord.pbMDData      = (unsigned char *)pBuffer;
    MDRecord.dwMDDataLen   = cBuffer;

    hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (void **) &pIMeta);
    _JumpIfError(hr, error, "CoCreateInstance");

    hr = pIMeta->OpenKey(
        METADATA_MASTER_ROOT_HANDLE,
        g_wszW3SVC,
        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
        1000,
        &hMetaRoot);
    _JumpIfErrorStr(hr, error, "OpenKey", g_wszW3SVC);

    hr = pIMeta->SetData(hMetaRoot, L"", &MDRecord);
    _JumpIfError(hr, error, "SetData");

    hr = pIMeta->CloseKey(hMetaRoot);
    _JumpIfError(hr, error, "CloseKey");

    hMetaRoot = NULL;

    hr = pIMeta->SaveData();
    _JumpIfError(hr, error, "SaveData");

error:
    LOCAL_FREE(pBuffer);

    MDRecord.pbMDData      = NULL;
    MDRecord.dwMDDataLen   = 0;

    if (NULL != hMetaRoot)
    {
        pIMeta->CloseKey(hMetaRoot);
    }
    if(pIMeta)
    {
        pIMeta->Release();
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    return hr;
}

//+------------------------------------------------------------------------
//  Retrieves a multisz property IIS metabase root
//-------------------------------------------------------------------------
HRESULT
GetMultiSzIISMetadata(
    METADATA_RECORD& MDRecord, 
    CMultiSz& MultiSz)
{
    HRESULT hr;
    IMSAdminBase *pIMeta = NULL;
    METADATA_HANDLE hMetaRoot = NULL;
    DWORD dwSize = 0;
    bool fCoInit = false;

    CSASSERT(MULTISZ_METADATA == MDRecord.dwMDDataType);

    hr = CoInitialize(NULL);
    if (S_OK != hr && S_FALSE != hr)
    {
        _JumpError(hr, error, "CoInitialize");
    }
    fCoInit = true;

    hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (void **) &pIMeta);
    _JumpIfError(hr, error, "CoCreateInstance");

    hr = pIMeta->OpenKey(
        METADATA_MASTER_ROOT_HANDLE,
        g_wszW3SVC,
        METADATA_PERMISSION_READ,
        1000,
        &hMetaRoot);
    _JumpIfErrorStr(hr, error, "OpenKey", g_wszW3SVC);

    CSASSERT(NULL == MDRecord.pbMDData);
    CSASSERT(0 == MDRecord.dwMDDataLen);

    hr = pIMeta->GetData(hMetaRoot, L"", &MDRecord, &dwSize);

    if(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) != hr)
    {
        _JumpErrorStr(hr, error, "GetData", g_wszW3SVC);
    }

    hr = S_OK;

    MDRecord.pbMDData = (unsigned char*) LocalAlloc(LMEM_FIXED, dwSize);
    _JumpIfAllocFailed(MDRecord.pbMDData, error);

    MDRecord.dwMDDataLen = dwSize;

    hr = pIMeta->GetData(hMetaRoot, L"", &MDRecord, &dwSize);
    _JumpIfErrorStr(hr, error, "OpenKey", g_wszW3SVC);

    hr = MultiSz.Unmarshal(MDRecord.pbMDData);
    _JumpIfError(hr, error, "Unmarshal");

error:

    LOCAL_FREE(MDRecord.pbMDData);
    
    MDRecord.pbMDData      = NULL;
    MDRecord.dwMDDataLen   = 0;

    if (NULL != hMetaRoot)
    {
        pIMeta->CloseKey(hMetaRoot);
    }
    if(pIMeta)
    {
        pIMeta->Release();
    }
    if (fCoInit)
    {
        CoUninitialize();
    }
    return hr;
}

//+------------------------------------------------------------------------
//  Check if an ISAPI dependency is present in the list
//-------------------------------------------------------------------------
bool IsISAPIDependencySet(CMultiSz& ISAPIDependList, LPCWSTR pcwszDependency)
{
    return ISAPIDependList.Find(pcwszDependency, false); // false == case insensitive
}

//+------------------------------------------------------------------------
//  Add an ISAPI dependency to the list
//-------------------------------------------------------------------------
HRESULT AddISAPIDependency(CMultiSz& ISAPIDependList, LPCWSTR pcwszDependency)
{
    HRESULT hr = S_OK;
    CString *pStr;

    pStr = new CString(pcwszDependency);
    if(!pStr || pStr->IsEmpty())
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "new");
    }

    if(!ISAPIDependList.AddTail(pStr))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "CMultiSz::AddTail");
    }

error:
    if(S_OK != hr)
    {
        delete pStr;
    }

    return hr;
}

//+------------------------------------------------------------------------
//  Set an application dependency in IIS metabase
//-------------------------------------------------------------------------
HRESULT
SetApplicationDependency(LPCWSTR pcwszDependencyString)
{
    HRESULT hr;
    CMultiSz AppDependList;

    hr = GetMultiSzIISMetadata(ApplicationDependenciesMDData, AppDependList);
    _JumpIfError(hr, error, "GetISAPIRestrictions");

    if(!IsISAPIDependencySet(AppDependList, pcwszDependencyString))
    {
        hr = AddISAPIDependency(AppDependList, pcwszDependencyString);
        _JumpIfError(hr, error, "AddISAPIDependency");
    }

    hr = SetMultiSzIISMetadata(ApplicationDependenciesMDData, AppDependList);
    _JumpIfError(hr, error, "SetISAPIRestrictions");

error:
    return S_OK;
}

//+------------------------------------------------------------------------
//  Set CertSrv dependency on ASP in IIS metabase
//-------------------------------------------------------------------------
HRESULT
SetCertSrvASPDependency()
{
    HRESULT hr;
    CString strCertSrvASPDepend;
    LPCSTR pcwszASP = ";ASP";

    if(!strCertSrvASPDepend.LoadString(IDS_CERTIFICATE_SERVICES))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LoadString(IDS_CERTIFICATE_SERVICES)");
    }

    // build the dependency string "Certificate Services;ASP"
    strCertSrvASPDepend += pcwszASP;

    hr = SetApplicationDependency(strCertSrvASPDepend);
    _JumpIfError(hr, error, "SetApplicationDependency");

error:
    return S_OK;
}

//+------------------------------------------------------------------------
//  Tests if ASP processing is enabled in IIS.
//-------------------------------------------------------------------------
HRESULT IsASPEnabledInIIS_New(
    bool& rfEnabled)
{
    HRESULT hr;
    CMultiSz WebSvcExtRestrictions;
    CMultiSzEnum WebSvcExtRestrictionsEnum;
    CString *pstr;
    CString strTmp;

    rfEnabled = false;

    hr = GetMultiSzIISMetadata(WebSvcExtRestrictionsMDData, WebSvcExtRestrictions);
    _JumpIfError(hr, error, "GetMultiSzIISMetadata");

    WebSvcExtRestrictionsEnum.Set(WebSvcExtRestrictions);
    
    for(pstr = WebSvcExtRestrictionsEnum.Next();
        pstr;
        pstr = WebSvcExtRestrictionsEnum.Next())
    {
        // create a copy so we don't modify the original string
        strTmp = *pstr;

        _wcslwr(strTmp.GetBuffer());

        if(NULL != wcsstr(strTmp, g_pcwszAspDll))
        {
            if(g_wchExtensionOn == *(pstr->GetBuffer()))  // string format is "1,"path\asp.dll,..." if
                                                        // asp is enabled
            {
                rfEnabled = true;
            }
            break;
        }
    }

error:
    return hr;
}


//+------------------------------------------------------------------------
//
//
//  SetupMSCEPForIIS
//
//-------------------------------------------------------------------------
HRESULT	SetupMSCEPForIIS(LPCWSTR	pcwszExtension)
{
	HRESULT			hr=E_FAIL;
    CString			strMSCEPAppDepend;
	BOOL			fEnabled=FALSE;
    CMultiSz		WebSvcExtList;
	WCHAR			wszDescription[255];

	LPWSTR			pwszWebSvcExt=NULL;
	CString			*pstrWebSvcExt=NULL;

	if(NULL == pcwszExtension)
	{
		hr = E_INVALIDARG;
        _JumpError(hr, error, "CheckForInput");
	}

	//*******************************************************
	//	set up the ApplicationDepedencies in the format of 
	//	"ApplicationName";"GroupID"

    if(!strMSCEPAppDepend.LoadString(IDS_MSCEP))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "LoadString(IDS_MSCEP)");
    }

    // build the dependency string "Certificate Services;ASP"
    strMSCEPAppDepend += L";";
    strMSCEPAppDepend += g_wszMSCEPID;

	// add to the metadata if it does not exist
    hr = SetApplicationDependency(strMSCEPAppDepend);
    _JumpIfError(hr, error, "SetApplicationDependency");

	
	//*******************************************************
	//	set up the WebSvcExtRestrictionList in the format of 
	//	1,d:\windows\system32\certsrv\mscep\mscep.dll,0,GroupID,Description

	// turn on the enable bit if there exists an entry
	if(S_OK == (hr=EnableWebSvcExtension(g_wszMSCEP, &fEnabled)))
		goto error;

	// we have to add a new entry
	if(!LoadString(g_hInstance,
                    IDS_MSCEP_DES,
                    wszDescription,
                    ARRAYSIZE(wszDescription)))
	{
        hr = myHLastError();
        _JumpError(hr, error, "LoadString");
	}

	pwszWebSvcExt=(LPWSTR)LocalAlloc(LPTR, sizeof(WCHAR)* 
			(wcslen(pcwszExtension) + wcslen(g_wszMSCEPID) + wcslen(wszDescription) + 7));
	if(NULL == pwszWebSvcExt)
	{
		hr=E_OUTOFMEMORY;
        _JumpError(hr, error, "LocalAlloc");
	}

	wcscpy(pwszWebSvcExt, L"1,");
	wcscat(pwszWebSvcExt, pcwszExtension);
	wcscat(pwszWebSvcExt, L",0,");
	wcscat(pwszWebSvcExt, g_wszMSCEPID);
	wcscat(pwszWebSvcExt, L",");
	wcscat(pwszWebSvcExt, wszDescription);

    hr = GetMultiSzIISMetadata(WebSvcExtRestrictionsMDData, WebSvcExtList);
    _JumpIfError(hr, error, "GetMultiSzIISMetadata");

	pstrWebSvcExt=new CString(pwszWebSvcExt);
	if((NULL == pstrWebSvcExt) || (pstrWebSvcExt->IsEmpty()))
	{
		hr=E_OUTOFMEMORY;
        _JumpError(hr, error, "new");
	}

    if(!WebSvcExtList.AddTail(pstrWebSvcExt))
    {
        hr = E_OUTOFMEMORY;
        _JumpError(hr, error, "CMultiSz::AddTail");
    }

    hr = SetMultiSzIISMetadata(WebSvcExtRestrictionsMDData, WebSvcExtList);
    _JumpIfError(hr, error, "SetISAPIRestrictions");


	hr=S_OK;

error:

	if(pwszWebSvcExt)
		LocalFree(pwszWebSvcExt);

	if(S_OK != hr)
	{	
		if(pstrWebSvcExt)
			delete pstrWebSvcExt;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\autoenrl.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        autoenrl.cpp
//
// Contents:    Autoenrollment API implementation
//
// History:     3-Apr-98       petesk created
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop
#include "cainfoc.h"

#include <stdlib.h>
#include <ctype.h>
#include <windows.h>
#include <wincrypt.h>
#include <certca.h>

#define SHA_HASH_SIZE 20



//
// Build the CTL_ENTRY structure for
HRESULT BuildCTLEntry(
                 IN WCHAR ** awszCAs,
                 OUT PCTL_ENTRY *ppCTLEntry,
                 OUT DWORD *pcCTLEntry
                 )
{
    HRESULT         hr = S_OK;

    PCCERT_CONTEXT  pCertContext = NULL;
    DWORD           cbHash = SHA_HASH_SIZE;
    PCTL_ENTRY      pCTLEntry = NULL;
    HCAINFO         hCACurrent = NULL;
    DWORD           cCA = 0;
    PBYTE           pbHash;


    // Passing in NULL or a zero length list implies that
    // we do lazy evaluation of 'pick any'.  Therefore, the
    // ctl list should be zero size.

    if((ppCTLEntry == NULL) ||
        (pcCTLEntry == NULL))
    {
        hr = E_INVALIDARG;
        goto error;
    }

    if((awszCAs == NULL) || 
       (awszCAs[0] == NULL))           
    {
        *pcCTLEntry = 0;
        *ppCTLEntry = NULL;
        goto error;
    }

    cCA = 0;
    while(awszCAs[cCA])
    {
        cCA++;
    }
    pCTLEntry = (PCTL_ENTRY)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT,
                                       sizeof(CTL_ENTRY)*cCA + SHA_HASH_SIZE*cCA);

    if(pCTLEntry == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    pbHash = (PBYTE)(pCTLEntry + cCA); 
    
    cCA=0;
    while(awszCAs[cCA])
    {
        hr = CAFindByName(awszCAs[cCA], NULL, 0, &hCACurrent);
        if(hr != S_OK)
        {
            goto error;
        }

        hr = CAGetCACertificate(hCACurrent, &pCertContext);
        if(hr != S_OK)
        {
            goto error;
        }

        cbHash = SHA_HASH_SIZE;

        if(!CertGetCertificateContextProperty(pCertContext,
                                          CERT_SHA1_HASH_PROP_ID,
                                          pbHash,
                                          &cbHash))
        {
            hr = myHLastError();
            goto error;
        }

        pCTLEntry[cCA].SubjectIdentifier.cbData = cbHash;
        pCTLEntry[cCA].SubjectIdentifier.pbData = pbHash;
        pbHash += cbHash;
        CertFreeCertificateContext(pCertContext);
        pCertContext = NULL;

        cCA++;
        CACloseCA(hCACurrent);
    }

    *pcCTLEntry = cCA;
    *ppCTLEntry = pCTLEntry;
    pCTLEntry = NULL;

error:

    if (pCTLEntry)
    {
        LocalFree(pCTLEntry);
    }
    if(pCertContext)
    {
        CertFreeCertificateContext(pCertContext);
    }


    return hr;
}



HRESULT 
BuildAutoEnrollmentCTL(
             IN LPCWSTR pwszCertType,
             IN LPCWSTR pwszObjectID,
#if 0
             IN BOOL    fMachine,
#endif
             IN WCHAR ** awszCAs,
             IN PCMSG_SIGNED_ENCODE_INFO pSignerInfo, 
             OUT BYTE **ppbEncodedCTL,
             OUT DWORD *pcbEncodedCTL
             )
{
    HRESULT                 hr = S_OK;
    CTL_INFO                CTLInfo;
    LPSTR                   pszUsageIdentifier;
    CERT_EXTENSION          CertExt;
    CMSG_SIGNED_ENCODE_INFO SignerInfo;
#if 0
    PCERT_EXTENSIONS        pCertExtensions = NULL;
#endif
    PCMSG_SIGNED_ENCODE_INFO pSigner = NULL;
    

    HCERTTYPE               hCertType = NULL;

    ZeroMemory(&CTLInfo, sizeof(CTLInfo));
    ZeroMemory(&CertExt, sizeof(CertExt));
    ZeroMemory(&SignerInfo, sizeof(SignerInfo));

    if(pSignerInfo)
    {
        pSigner = pSignerInfo;
    }
    else
    {
        pSigner = &SignerInfo;
    }
#if 0
    hr = CAFindCertTypeByName(pwszCertType, 
                              NULL, 
                              (fMachine?CT_ENUM_MACHINE_TYPES | CT_FIND_LOCAL_SYSTEM:CT_ENUM_USER_TYPES), 
                              &hCertType);

    if (S_OK != hr)
    {
        goto error;
    }

    hr = CAGetCertTypeExtensions(hCertType, &pCertExtensions);
    if (S_OK != hr)
    {
        goto error;
    }
#endif
    // set up the CTL info
    CTLInfo.dwVersion = sizeof(CTLInfo);
    CTLInfo.SubjectUsage.cUsageIdentifier = 1;
    pszUsageIdentifier = szOID_AUTO_ENROLL_CTL_USAGE;
    CTLInfo.SubjectUsage.rgpszUsageIdentifier = &pszUsageIdentifier;


    CTLInfo.ListIdentifier.cbData = (wcslen(pwszCertType) + 1) * sizeof(WCHAR);
    
    if(pwszObjectID)
    {
        CTLInfo.ListIdentifier.cbData += (wcslen(pwszObjectID)+1) * sizeof(WCHAR);
    }

    CTLInfo.ListIdentifier.pbData = (BYTE *)LocalAlloc(LMEM_ZEROINIT, CTLInfo.ListIdentifier.cbData);
    if(CTLInfo.ListIdentifier.pbData == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    if(pwszObjectID)
    {
        wcscpy((LPWSTR)CTLInfo.ListIdentifier.pbData, pwszObjectID);
        wcscat((LPWSTR)CTLInfo.ListIdentifier.pbData, L"|");
    }

    // wcscat can be used as the memory is initialized to zero
    wcscat((LPWSTR)CTLInfo.ListIdentifier.pbData, pwszCertType);

    GetSystemTimeAsFileTime(&CTLInfo.ThisUpdate); 
    CTLInfo.SubjectAlgorithm.pszObjId = szOID_OIWSEC_sha1;

    hr = BuildCTLEntry(awszCAs,
                       &CTLInfo.rgCTLEntry,
                       &CTLInfo.cCTLEntry);
    if (S_OK != hr)
    {
        goto error;
    }
#if 0
    // add all the reg info as an extension
    CTLInfo.cExtension = pCertExtensions->cExtension;
    CTLInfo.rgExtension = pCertExtensions->rgExtension;
#endif
    CTLInfo.cExtension = 0;
    CTLInfo.rgExtension = NULL;

    // encode the CTL
    *pcbEncodedCTL = 0;
    SignerInfo.cbSize = sizeof(SignerInfo);
    if (!CryptMsgEncodeAndSignCTL(PKCS_7_ASN_ENCODING,
                                  &CTLInfo, &SignerInfo, 0,
                                  NULL, pcbEncodedCTL))
    {
	hr = myHLastError();
        goto error;
    }

    if (NULL == (*ppbEncodedCTL =
        (BYTE*)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, *pcbEncodedCTL)))
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    if (!CryptMsgEncodeAndSignCTL(PKCS_7_ASN_ENCODING,
                                  &CTLInfo, pSigner, 0,
                                  *ppbEncodedCTL, 
                                  pcbEncodedCTL))
    {
	hr = myHLastError();
        goto error;
    }

error:

    if(CTLInfo.rgCTLEntry)
    {
        LocalFree(CTLInfo.rgCTLEntry);
    }
    if(CTLInfo.ListIdentifier.pbData)
    {
        LocalFree(CTLInfo.ListIdentifier.pbData);
    }
#if 0
    if (pCertExtensions)
    {
        LocalFree(pCertExtensions);
    }
#endif
    if(hCertType)
    {
        CACloseCertType(hCertType);
    }
    return hr;
}


HRESULT 
CACreateAutoEnrollmentObjectEx(
             IN LPCWSTR                     pwszCertType,
             IN LPCWSTR                     wszObjectID,
             IN WCHAR **                    awszCAs,
             IN PCMSG_SIGNED_ENCODE_INFO    pSignerInfo,
             IN LPCSTR                      StoreProvider,
             IN DWORD                       dwFlags,
             IN const void *                pvPara)
{
    HRESULT     hr = S_OK;
    BYTE        *pbEncodedCTL = NULL;
    DWORD       cbEncodedCTL;
    HCERTSTORE  hStore = 0;
#if 0
    BOOL        fMachine = ((dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK) == CERT_SYSTEM_STORE_LOCAL_MACHINE);
#endif


    hr = BuildAutoEnrollmentCTL(pwszCertType,
                                wszObjectID,
#if 0
                                fMachine,
#endif
                                awszCAs,
                                pSignerInfo, 
                                &pbEncodedCTL,
                                &cbEncodedCTL
                                );
    if(hr != S_OK)
    {
        goto error;
    }

    // open the Trust store and fine the CTL based on the auto enrollment usage
    hStore = CertOpenStore(StoreProvider, 0, NULL, dwFlags, pvPara);

    if(hStore == NULL)
    {
	hr = myHLastError();
        goto error;
    }

    if (!CertAddEncodedCTLToStore(hStore, 
                                  X509_ASN_ENCODING,
                                  pbEncodedCTL, 
                                  cbEncodedCTL,
                                  CERT_STORE_ADD_REPLACE_EXISTING,
                                  NULL))
    {
	hr = myHLastError();
        goto error;
    }
error:

    if (pbEncodedCTL)
    {
        LocalFree(pbEncodedCTL);
    }

    if (hStore)
    {
        CertCloseStore(hStore, 0);
    }

    return hr;
}


HRESULT 
CACreateLocalAutoEnrollmentObject(
             IN LPCWSTR                     pwszCertType,
             IN WCHAR **                    awszCAs,
             IN PCMSG_SIGNED_ENCODE_INFO    pSignerInfo,
             IN DWORD                       dwFlags)
{
    HRESULT     hr = S_OK;
    BYTE        *pbEncodedCTL = NULL;
    DWORD       cbEncodedCTL;
    HCERTSTORE  hStore = 0;
#if 0
    BOOL        fMachine = ((dwFlags & CERT_SYSTEM_STORE_LOCATION_MASK) == CERT_SYSTEM_STORE_LOCAL_MACHINE);
#endif



    hr = BuildAutoEnrollmentCTL(pwszCertType,
                                NULL,
#if 0
                                fMachine,
#endif
                                awszCAs,
                                pSignerInfo, 
                                &pbEncodedCTL,
                                &cbEncodedCTL
                                );
    if(hr != S_OK)
    {
        goto error;
    }

    // open the Trust store and fine the CTL based on the auto enrollment usage
    hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_REGISTRY, 0, NULL, dwFlags, L"ACRS");

    if(hStore == NULL)
    {
	hr = myHLastError();
        goto error;
    }

    if (!CertAddEncodedCTLToStore(hStore, 
                                  X509_ASN_ENCODING,
                                  pbEncodedCTL, 
                                  cbEncodedCTL,
                                  CERT_STORE_ADD_REPLACE_EXISTING,
                                  NULL))
    {
	hr = myHLastError();
        goto error;
    }
error:

    if (pbEncodedCTL)
    {
        LocalFree(pbEncodedCTL);
    }

    if (hStore)
    {
        CertCloseStore(hStore, 0);
    }

    return hr;
}

//--------------------------------------------------------------------------------
//
//   CADeleteLocalAutoEnrollmentObject
//
//---------------------------------------------------------------------------------
HRESULT
CADeleteLocalAutoEnrollmentObject(
    IN LPCWSTR                              pwszCertType,
    IN OPTIONAL WCHAR **                    awszCAs,
    IN OPTIONAL PCMSG_SIGNED_ENCODE_INFO    pSignerInfo,
    IN DWORD                                dwFlags)
{

    HRESULT             hr=E_FAIL;
    CTL_FIND_USAGE_PARA CTLFindParam;
    LPSTR               pszUsageIdentifier=NULL;

    HCERTSTORE          hCertStore=NULL;
    PCCTL_CONTEXT       pCTLContext=NULL;   //no need to free the CTL since it is freed by the DeleteCTL call

           
    memset(&CTLFindParam, 0, sizeof(CTL_FIND_USAGE_PARA));


    if((NULL==pwszCertType)||(NULL!=awszCAs)||(NULL!=pSignerInfo))
    {
        hr=E_INVALIDARG;
        goto error;
    }

    //open the store based on dwFlags
    hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM_REGISTRY, 0, NULL, dwFlags, L"ACRS");

    if(NULL == hCertStore)
    {
	    hr = myHLastError();
        goto error;
    }

    //set up the find parameter
    CTLFindParam.cbSize=sizeof(CTLFindParam);

    CTLFindParam.SubjectUsage.cUsageIdentifier = 1;
    pszUsageIdentifier = szOID_AUTO_ENROLL_CTL_USAGE;
    CTLFindParam.SubjectUsage.rgpszUsageIdentifier = &pszUsageIdentifier;

    CTLFindParam.ListIdentifier.cbData=(wcslen(pwszCertType) + 1) * sizeof(WCHAR);
    CTLFindParam.ListIdentifier.pbData=(BYTE *)(pwszCertType);

    //only find CTLs with no signers
    CTLFindParam.pSigner=CTL_FIND_NO_SIGNER_PTR;

    //find the CTL based on the pwszCertType
    if(NULL == (pCTLContext=CertFindCTLInStore(
            hCertStore,                  
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,         
            0,                      
            CTL_FIND_USAGE,                       
            &CTLFindParam,                 
            NULL)))
    {
        hr=CRYPT_E_NOT_FOUND;
        goto error;
    }

    //delete the CTL.  The CTL is automatically freed
    if(!CertDeleteCTLFromStore(pCTLContext))
    {
	    hr = myHLastError();
        goto error;
    }

    hr=S_OK;

error:

    if(hCertStore)
        CertCloseStore(hCertStore, 0);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\assert.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        assert.cpp
//
// Contents:    Cert Server wrapper routines
//
//---------------------------------------------------------------------------

#include <pch.cpp>

#pragma hdrstop

#define DBG_CERTSRV_DEBUG_PRINT

#ifdef DBG_CERTSRV_DEBUG_PRINT

__inline VOID CSDbgBreakPoint(VOID)
{
    DebugBreak();
}


//+---------------------------------------------------------------------------
// Function:    CSPrintAssert, public
//
// Synopsis:    Display message and break
//
// Arguments:   [pszFailedAssertion] -- failed assertion in string form
//              [pszFileName] -- filename
//              [LineNumber]  -- line number
//              [pszMessage]  -- optional message
//
// Returns:     None
//----------------------------------------------------------------------------


char const *
csTrimPath(
    char const *pszFile)
{
    char const *psz;
    char *pszT;
    char const *pszTrim;
    static char s_path[MAX_PATH];

    if (NULL == pszFile)
    {
	pszFile = "null.cpp";
    }
    pszTrim = pszFile;
    psz = strrchr(pszFile, '\\');
    if (NULL != psz)
    {
        DWORD count = 1;

        while (count != 0 && psz > pszFile)
        {
            if (*--psz == '\\')
            {
                if (0 == strncmp(psz, "\\..\\", 4) ||
		    0 == strncmp(psz, "\\.\\", 3))
                {
                    count++;
                }
                else
                {
                    count--;
                    pszTrim = &psz[1];
                }
            }
        }
	if (strlen(pszTrim) < ARRAYSIZE(s_path))
	{
	    pszT = s_path;
	    while ('\0' != *pszTrim)
	    {
		if ('\\' == *pszTrim)
		{
		    if (0 == strncmp(pszTrim, "\\..\\", 4))
		    {
			pszTrim += 3;
			continue;
		    }
		    if (0 == strncmp(pszTrim, "\\.\\", 3))
		    {
			pszTrim += 2;
			continue;
		    }
		}
		*pszT++ = *pszTrim++;
	    }
	    *pszT = '\0';
	    pszTrim = s_path;
	}
    }
    return(pszTrim);
}


VOID
CSPrintAssert(
    IN char const *DBGPARMREFERENCED(pszFailedAssertion),
    IN char const *DBGPARMREFERENCED(pszFileName),
    IN ULONG DBGPARMREFERENCED(LineNumber),
    OPTIONAL IN char const *DBGPARMREFERENCED(pszMessage))
{
    BOOLEAN fReprint;

    do
    {
        fReprint = FALSE;
        DBGPRINT((
                DBG_SS_ASSERT,
                "\n"
                    "*** Certificate Services Assertion failed: %hs %hs\n"
                    "*** Source File: %hs, line %ld\n"
                    "\n",
                pszMessage == NULL? "" : pszMessage,
                pszFailedAssertion,
                csTrimPath(pszFileName),
                LineNumber));
        if (IsDebuggerPresent())
        {
#if i386
            _asm  xor  al,al
#endif
            CSDbgBreakPoint();
#if i386
            _asm  mov  byte ptr [fReprint],al
#endif
        }
    }
    while (fReprint);
}


VOID
CSPrintError(
    IN char const *pszMessage,
    OPTIONAL IN WCHAR const *pwszData,
    IN char const *DBGPARMREFERENCED(pszFile),
    IN DWORD DBGPARMREFERENCED(dwLine),
    IN HRESULT hr,
    IN HRESULT hrquiet)
{
    char acherr[1024];
    DBGCODE(WCHAR awchr[cwcHRESULTSTRING]);

    if (myShouldPrintError(hr, hrquiet))
    {
        if (NULL != pwszData)
        {
            LONG cch;
	    
#pragma prefast(disable:53, "PREfast bug 650")
	    cch = _snprintf(
			acherr,
			sizeof(acherr),
			"%hs(%ws)",
			pszMessage,
			pwszData);
#pragma prefast(enable:53, "re-enable")
	    if (0 > cch || sizeof(acherr) <= cch)
            {
                strcpy(&acherr[sizeof(acherr) - 4], "...");
            }
            pszMessage = acherr;
        }
        DBGPRINT((
                DBG_SS_ERROR,
                "%hs(%u): %hs: error %ws\n",
                csTrimPath(pszFile),
                dwLine,
                pszMessage,
                myHResultToString(awchr, hr)));
    }
}

#endif // DBG_CERTSRV_DEBUG_PRINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\alloc.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 1999
//
// File:        alloc.cpp
//
// Contents:    Cert Server debug implementation
//
//---------------------------------------------------------------------------

#include "pch.cpp"

#pragma hdrstop

#include <assert.h>
#include <psapi.h>

#define __dwFILE__	__dwFILE_CERTCLIB_ALLOC_CPP__


#if DBG_CERTSRV

#undef FormatMessageW
#undef LocalAlloc
#undef LocalReAlloc
#undef LocalFree

#undef CoTaskMemAlloc
#undef CoTaskMemRealloc
#undef CoTaskMemFree

#undef StringFromCLSID
#undef StringFromIID

#undef SysAllocString
#undef SysReAllocString
#undef SysAllocStringLen
#undef SysReAllocStringLen
#undef SysFreeString
#undef SysAllocStringByteLen
#undef PropVariantClear
#undef VariantClear
#undef VariantChangeType
#undef VariantChangeTypeEx
#undef AllocateAndInitializeSid
#undef FreeSid

#ifndef CSM_TRACEASSERT
#define CSM_TRACEASSERT		0x400
#endif

DWORD g_MemTrack = 0;

#define MTF_UNREGISTERED	0x00000002
#define MTF_ALLOCTRACE		0x00000004
#define MTF_FREETRACE		0x00000008
#define MTF_STACKTRACE		0x00000010

typedef struct _RMALLOC
{
    LONG cAlloc;
    LONG cAllocTotal;
} RMALLOC;

RMALLOC g_armAlloc[CSM_MAX];

#define C_BP_FRAME		16
#define C_BACK_TRACE_CHUNK	100
#define C_MEM_HEADER_CHUNK	100

typedef struct _BACKTRACE
{
    LONG   cAlloc;			// count of outstanding allocations
    LONG   cAllocTotal;			// count of total allocations
    LONG   cbAlloc;			// size of outstanding allocations
    LONG   cbAllocTotal;		// size of total allocations
    ULONG  apCaller[C_BP_FRAME];	// stack trace
} BACKTRACE;

typedef struct _MEMHEADER
{
    DWORD       iBackTrace;	// backtrace index
    VOID const *pvMemory;	// Pointer to memory block allocated
    LONG        cbMemory;	// Size of memory block allocated
    DWORD       Flags;		// Allocator flags
} MEMHEADER;

WCHAR s_wszProcess[MAX_PATH];


// critical section around myRegister APIs since they
// operate on global data structures
CRITICAL_SECTION g_critsecRegisterMemory;
BOOL g_fRegisterMemoryCritSecInit = FALSE;



VOID
RegisterMemoryEnterCriticalSection(VOID)
{
    HRESULT hr;
    
    __try
    {
	if (!g_fRegisterMemoryCritSecInit)
	{
	    InitializeCriticalSection(&g_critsecRegisterMemory);
	    g_fRegisterMemoryCritSecInit = TRUE;
	}
	EnterCriticalSection(&g_critsecRegisterMemory);
	if (s_wszProcess[0] == L'\0')
	{
	    GetModuleBaseName(
			GetCurrentProcess(),
			GetModuleHandle(NULL),
			s_wszProcess,
			ARRAYSIZE(s_wszProcess));
	    s_wszProcess[ARRAYSIZE(s_wszProcess) - 1] = L'\0';
	    if (s_wszProcess[0] == L'\0')
	    {
		wcscpy(s_wszProcess, L"???");
	    }

	}
    }
    __except(hr = myHEXCEPTIONCODE(), EXCEPTION_EXECUTE_HANDLER)
    {
    }
}


VOID
RegisterMemoryLeaveCriticalSection(VOID)
{
    if (g_fRegisterMemoryCritSecInit)
    {
	LeaveCriticalSection(&g_critsecRegisterMemory);
    }
}


VOID
RegisterMemoryDeleteCriticalSection()
{
    if (g_fRegisterMemoryCritSecInit)
    {
	DeleteCriticalSection(&g_critsecRegisterMemory);
	g_fRegisterMemoryCritSecInit = FALSE;
    }
}


BACKTRACE *g_rgbt = NULL;
DWORD g_cbtMax = 0;
DWORD g_cbt = 0;

MEMHEADER *g_rgmh = NULL;
DWORD g_cmhMax = 0;
DWORD g_cmh = 0;


MEMHEADER *
AllocMemHeader()
{
    if (g_cmh >= g_cmhMax)
    {
	DWORD cb = (C_MEM_HEADER_CHUNK + g_cmhMax) * sizeof(g_rgmh[0]);
	MEMHEADER *rgmhT;

	if (NULL == g_rgmh)
	{
	    rgmhT = (MEMHEADER *) LocalAlloc(LMEM_FIXED, cb);
	}
	else
	{
	    rgmhT = (MEMHEADER *) LocalReAlloc(g_rgmh, cb, LMEM_MOVEABLE);
	}
	if (NULL == rgmhT)
	{
	    DBGPRINTW((
		DBG_SS_CERTLIB,
		L"Error allocating memtrack header\n"));
	    return(NULL);
	}
	g_rgmh = rgmhT;
	g_cmhMax += C_MEM_HEADER_CHUNK;
    }
    return(&g_rgmh[g_cmh++]);
}


MEMHEADER *
LookupMemHeader(
    IN VOID const *pv)
{
    MEMHEADER *pmh;
    MEMHEADER *pmhEnd;

    pmh = g_rgmh;
    pmhEnd = &g_rgmh[g_cmh];

    while (pmh < pmhEnd)
    {
	if (pv == pmh->pvMemory)
	{
	    // Catch all activity on "interesting" blocks of memory.
	    // Ususally set in the debugger on a particular block of memory,
	    // to stop in the debugger when it is freed.

	    CSASSERT(0 == (CSM_TRACEASSERT & pmh->Flags));
	    return(pmh);
	}
	pmh++;
    }
    return(NULL);
}


VOID
FreeMemHeader(
    IN MEMHEADER *pmh)
{
    MEMHEADER *pmhLast;

    assert(1 <= g_cmh);
    pmhLast = &g_rgmh[g_cmh - 1];

    *pmh = *pmhLast;
    g_cmh--;
}


BACKTRACE *
AllocBackTrace(
    OUT DWORD *pibt)
{
    BOOL fRealloc = FALSE;
    BACKTRACE *rgbtOld = g_rgbt;
    BACKTRACE *pbtRet;
    
    if (g_cbt >= g_cbtMax)
    {
	DWORD cb = (C_BACK_TRACE_CHUNK + g_cbtMax) * sizeof(g_rgbt[0]);
	BACKTRACE *rgbtT;

	if (NULL == g_rgbt)
	{
	    rgbtT = (BACKTRACE *) LocalAlloc(LMEM_FIXED, cb);
	}
	else
	{
	    rgbtT = (BACKTRACE *) LocalReAlloc(g_rgbt, cb, LMEM_MOVEABLE);
	    fRealloc = TRUE;
	}
	if (NULL == rgbtT)
	{
	    DBGPRINTW((
		DBG_SS_CERTLIB,
		L"Error allocating memtrack backtrace\n"));
	    return(NULL);
	}
	g_rgbt = rgbtT;
	g_cbtMax += C_BACK_TRACE_CHUNK;
    }
    *pibt = g_cbt + 1;
    pbtRet = &g_rgbt[g_cbt++];

    if (fRealloc)
    {
	// Wait to DBGPRINT here to avoid recursing with inconsistent data.

	DBGPRINTW((
	    DBG_SS_CERTLIBI,
	    L"Realloc'd memtrack backtrace from %x to %x\n",
	    rgbtOld,
	    g_rgbt));
    }
    return(pbtRet);
}


BACKTRACE *
LookupBackTrace(
    IN BACKTRACE *pbtIn,
    OUT DWORD *pibt)
{
    BACKTRACE *pbt;
    BACKTRACE *pbtEnd;

    pbt = g_rgbt;
    pbtEnd = &g_rgbt[g_cbt];

    while (pbt < pbtEnd)
    {
	if (0 == memcmp(pbt->apCaller, pbtIn->apCaller, sizeof(pbt->apCaller)))
	{
	    *pibt = SAFE_SUBTRACT_POINTERS(pbt, g_rgbt) + 1;
	    return(pbt);
	}
	pbt++;
    }
    return(NULL);
}


BACKTRACE *
BackTraceFromIndex(
    IN DWORD ibt)
{
    BACKTRACE *pbt = NULL;

    if (0 == ibt)
    {
	DBGPRINTW((DBG_SS_CERTLIB, L"BackTraceFromIndex(0)\n"));
    }
    else if (g_cbt < ibt)
    {
	DBGPRINTW((
	    DBG_SS_CERTLIB,
	    L"BackTraceFromIndex(%u) -- out of range\n",
	    ibt));
    }
    else
    {
	pbt = &g_rgbt[ibt - 1];
    }
    return(pbt);
}


VOID
ReadEnvironmentFlags(VOID)
{
    HRESULT hr;
    DWORD MemTrack;
    DWORD cb;
    DWORD dwType;
    HKEY hkey = NULL;
    char *pszEnvVar;

    pszEnvVar = getenv(szCERTSRV_MEMTRACK);
    if (NULL != pszEnvVar)
    {
	g_MemTrack = (DWORD) strtol(pszEnvVar, NULL, 16);
    }
    else
    {
	hr = RegOpenKeyEx(
			HKEY_LOCAL_MACHINE,
			wszREGKEYCONFIGPATH,
			0,
			KEY_READ,
			&hkey);
	if (S_OK == hr)
	{
	    cb = sizeof(MemTrack);
	    hr = RegQueryValueEx(
			    hkey,
			    wszREGCERTSRVMEMTRACK,
			    0,
			    &dwType,
			    (BYTE *) &MemTrack,
			    &cb);
	    if (S_OK == hr && REG_DWORD == dwType && sizeof(MemTrack) == cb)
	    {
		g_MemTrack = MemTrack;
	    }
	}
    }

//error:
    if (NULL != hkey)
    {
	RegCloseKey(hkey);
    }
}


VOID
CaptureStackBackTrace(
    EXCEPTION_POINTERS *pep,
    ULONG cSkip,
    ULONG cFrames,
    ULONG *aeip)
{
    ZeroMemory(aeip, cFrames * sizeof(aeip[0]));

#if i386 == 1
    ULONG ieip, *pebp;
    ULONG *pebpMax = (ULONG *) MAXLONG; // 2 * 1024 * 1024 * 1024; // 2 gig - 1
    ULONG *pebpMin = (ULONG *) (64 * 1024);	// 64k

    if (pep == NULL)
    {
        ieip = 0;
        cSkip++;                    // always skip current frame
        pebp = ((ULONG *) &pep) - 2;
    }
    else
    {
        ieip = 1;
        assert(cSkip == 0);
        aeip[0] = pep->ContextRecord->Eip;
        pebp = (ULONG *) pep->ContextRecord->Ebp;
    }
    if (pebp >= pebpMin && pebp < pebpMax)
    {
        __try
        {
            for ( ; ieip < cSkip + cFrames; ieip++)
            {
                if (ieip >= cSkip)
                {
                    aeip[ieip - cSkip] = *(pebp + 1);  // save an eip
                }

                ULONG *pebpNext = (ULONG *) *pebp;
                if (pebpNext < pebp + 2 ||
		    pebpNext >= pebpMax - 1 ||
		    pebpNext >= pebp + (256 * 1024) / sizeof(pebp[0]))
                {
                    break;
                }
                pebp = pebpNext;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            ;
        }
    }
#endif // i386 == 1
}


WCHAR const *
wszAllocator(
    IN DWORD Flags)
{
    WCHAR const *pwsz;

    switch (~CSM_TRACEASSERT & Flags)
    {
	case CSM_LOCALALLOC:	pwsz = L"LocalAlloc";	  break;
	case CSM_COTASKALLOC:	pwsz = L"CoTaskMemAlloc"; break;
	case CSM_SYSALLOC:	pwsz = L"SysAllocString"; break;
	case CSM_MALLOC:	pwsz = L"malloc";	  break;
	case CSM_NEW:		pwsz = L"new";		  break;
	case CSM_NEW | CSM_GLOBALDESTRUCTOR:
				pwsz = L"new-global";	  break;
	case CSM_SID:		pwsz = L"allocSid";	  break;
	default:		pwsz = L"???";		  break;
    }
    return(pwsz);
}


WCHAR const *
wszFreeer(
    IN DWORD Flags)
{
    WCHAR const *pwsz;

    switch (~CSM_TRACEASSERT & Flags)
    {
	case CSM_LOCALALLOC:	pwsz = L"LocalFree";	 break;
	case CSM_COTASKALLOC:	pwsz = L"CoTaskMemFree"; break;
	case CSM_SYSALLOC:	pwsz = L"SysFreeString"; break;
	case CSM_MALLOC:	pwsz = L"free";		 break;
	case CSM_NEW:		pwsz = L"delete";	 break;
	case CSM_NEW | CSM_GLOBALDESTRUCTOR:
				pwsz = L"delete-global"; break;
	case CSM_SID:		pwsz = L"FreeSid";	 break;
	default:		pwsz = L"???";		 break;
    }
    return(pwsz);
}


VOID
DumpMemBlock(
    IN WCHAR const *pwsz,
    IN VOID const *pvMemory,
    IN DWORD cbMemory,
    IN DWORD Flags,
    IN DWORD ibt,
    OPTIONAL IN BACKTRACE const *pbt)
{
    DBGPRINTW((
	DBG_SS_CERTLIB,
	L"%ws%wspv=%-6x cb=%-4x f=%x(%ws) pbt[%d]=%x:\n",
	pwsz,
	L'\0' != *pwsz? L": " : L"",
	pvMemory,
	cbMemory,
	Flags,
	wszAllocator(Flags),
	ibt,
	pbt));

    if (NULL != pbt && DbgIsSSActive(DBG_SS_CERTLIB))
    {
	DBGPRINTW((MAXDWORD, L"%d: ", ibt));

        for (int i = 0; i < ARRAYSIZE(pbt->apCaller); i++)
        {
            if (NULL == pbt->apCaller[i])
	    {
                break;
	    }
            DBGPRINTW((MAXDWORD, L"ln %x;", pbt->apCaller[i]));
        }
        DBGPRINTW((MAXDWORD, L"\n"));
    }
}


VOID
myRegisterMemDump()
{
    MEMHEADER *pmh;
    MEMHEADER *pmhEnd;
    LONG cTotal;
    LONG cbTotal;

    cTotal = 0;
    cbTotal = 0;

    RegisterMemoryEnterCriticalSection();

    __try
    {
        pmh = g_rgmh;
        pmhEnd = &g_rgmh[g_cmh];

        while (pmh < pmhEnd)
        {
	    if (0 == (CSM_GLOBALDESTRUCTOR & pmh->Flags) ||
		(MTF_ALLOCTRACE & g_MemTrack))
	    {
		if (0 == cTotal)
		{
		    if (DbgIsSSActive(DBG_SS_CERTLIB))
		    {
			DBGPRINTW((MAXDWORD, L"\n"));
		    }
		    DBGPRINTW((
			DBG_SS_CERTLIB,
			L"%ws: Allocated Memory Blocks:\n",
			s_wszProcess));
		}
		cTotal++;
		cbTotal += pmh->cbMemory;

		DumpMemBlock(
			L"",
			pmh->pvMemory,
			pmh->cbMemory,
			pmh->Flags,
			pmh->iBackTrace,
			BackTraceFromIndex(pmh->iBackTrace));
	    }
	    pmh++;
        }
        if (0 != cTotal)
        {
	    DBGPRINTW((
		DBG_SS_CERTLIB,
		L"%ws: Total: c=%x cb=%x\n\n",
		s_wszProcess,
		cTotal,
		cbTotal));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    RegisterMemoryLeaveCriticalSection();
}


VOID *
_VariantMemory(
    IN PROPVARIANT const *pvar,
    OUT DWORD *pFlags,
    OPTIONAL OUT DWORD *pcb)
{
    VOID *pv = NULL;
    DWORD cb = 0;
    BOOL fString = FALSE;

    *pFlags = CSM_COTASKALLOC;
    if (NULL != pcb)
    {
	*pcb = 0;
    }
    switch (pvar->vt)
    {
	case VT_BSTR:
	    pv = pvar->bstrVal;
	    fString = TRUE;
	    *pFlags = CSM_SYSALLOC;
	    break;

	case VT_BYREF | VT_BSTR:
	    pv = *pvar->pbstrVal;
	    fString = TRUE;
	    *pFlags = CSM_SYSALLOC;
	    break;

	case VT_LPWSTR:
	    pv = pvar->pwszVal;
	    fString = TRUE;
	    break;

	case VT_BLOB:
	    pv = pvar->blob.pBlobData;
	    cb = pvar->blob.cbSize;
	    break;
    }
    if (NULL != pcb)
    {
	if (fString)
	{
	    cb = (wcslen((WCHAR const *) pv) + 1) * sizeof(WCHAR);
	}
	*pcb = cb;
    }
    return(pv);
}


VOID
myRegisterMemAlloc(
    IN VOID const *pv,
    IN LONG cb,
    IN DWORD Flags)
{
    BACKTRACE bt;
    MEMHEADER *pmh;
    BACKTRACE *pbt;
    DWORD FlagsIn = Flags;

    Flags &= ~CSM_TRACEASSERT;
    if (CSM_VARIANT == Flags)
    {
	pv = _VariantMemory((PROPVARIANT const *) pv, &Flags, (DWORD *) &cb);
	if (NULL == pv)
	{
	    return;	// nothing to register
	}
    }
    RegisterMemoryEnterCriticalSection();

    __try
    {
	static BOOL s_fFirst = TRUE;

        if (s_fFirst)
        {
	    ReadEnvironmentFlags();
	    s_fFirst = FALSE;
        }
        if (0 != g_MemTrack)
        {
            // Do not register NULL as an allocation
            CSASSERT(NULL != pv);

            // see if we already have a reference to this memory

            pmh = LookupMemHeader(pv);
            if (NULL != pmh)
            {
	        DBGPRINTW((
		    DBG_SS_CERTLIB,
		    L"%ws: Memory Leak: Tracked memory address reused. Previously allocated:\n",
		    s_wszProcess));
	        DumpMemBlock(
		        L"Memory leak",
		        pv,
		        pmh->cbMemory,
		        pmh->Flags,
			pmh->iBackTrace,
			BackTraceFromIndex(pmh->iBackTrace));

                CSASSERT(!"Tracked memory address reused");
                FreeMemHeader(pmh);
            }


	    pmh = AllocMemHeader();
	    if (NULL != pmh)
	    {
		DWORD ibt;

	        CaptureStackBackTrace(NULL, 0, C_BP_FRAME, bt.apCaller);

	        pbt = LookupBackTrace(&bt, &ibt);
	        if (NULL != pbt)
	        {
		    pbt->cAlloc++;
		    pbt->cAllocTotal++;
		    pbt->cbAlloc += cb;
		    pbt->cbAllocTotal += cb;
	        }
	        else
	        {
		    pbt = AllocBackTrace(&ibt);
		    if (NULL != pbt)
		    {
		        pbt->cAlloc = 1;
		        pbt->cAllocTotal = 1;
		        pbt->cbAlloc = cb;
		        pbt->cbAllocTotal = cb;
		        CopyMemory(pbt->apCaller, bt.apCaller, sizeof(pbt->apCaller));
		    }
	        }
	        if (NULL != pbt)
	        {
		    pmh->iBackTrace = ibt;
		    pmh->pvMemory = pv;
		    pmh->cbMemory = cb;
		    pmh->Flags = Flags | (CSM_TRACEASSERT & FlagsIn);

		    CSASSERT(ARRAYSIZE(g_armAlloc) > Flags);
		    g_armAlloc[Flags].cAlloc++;
		    g_armAlloc[Flags].cAllocTotal++;
		    if (MTF_ALLOCTRACE & g_MemTrack)
		    {
		        DBGPRINTW((
			    DBG_SS_CERTLIB,
			    L"Alloc: pmh=%x: pv=%x cb=%x f=%x(%ws) -- pbt[%d]=%x: c=%x, cb=%x\n",
			    pmh,
			    pmh->pvMemory,
			    pmh->cbMemory,
			    pmh->Flags,
			    wszAllocator(pmh->Flags),
			    SAFE_SUBTRACT_POINTERS(pbt, g_rgbt),
			    pbt,
			    pbt->cAlloc,
			    pbt->cbAlloc));
			if (MTF_STACKTRACE & g_MemTrack)
			{
			    DumpMemBlock(
				    L"Alloc Trace memory block",
				    pv,
				    pmh->cbMemory,	// cbMemory
				    pmh->Flags,		// Flags
				    pmh->iBackTrace,	// ibt
				    pbt);
			}
		    }
	        }
	        else
	        {
		    FreeMemHeader(pmh);
	        }
	    } // if no problem allocating pmh
        } // if g_MemTrack
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    RegisterMemoryLeaveCriticalSection();
}


VOID
myRegisterMemFree(
    IN VOID const *pv,
    IN DWORD Flags)
{
    MEMHEADER *pmh;

    if (NULL == pv)
    {
	return;
    }
    if (CSM_VARIANT == Flags)
    {
	pv = _VariantMemory((PROPVARIANT const *) pv, &Flags, NULL);
	if (NULL == pv)
	{
	    return;	// nothing to register
	}
    }
    RegisterMemoryEnterCriticalSection();
    CSASSERT(CSM_MAX > (~CSM_GLOBALDESTRUCTOR & Flags));

    __try
    {
        pmh = LookupMemHeader(pv);
        if (NULL != pmh)
        {
	    BACKTRACE *pbt = BackTraceFromIndex(pmh->iBackTrace);

	    if (CSM_GLOBALDESTRUCTOR & Flags)
	    {
		if ((CSM_GLOBALDESTRUCTOR | pmh->Flags) != Flags)
		{
		    BACKTRACE bt;

		    CaptureStackBackTrace(NULL, 0, C_BP_FRAME, bt.apCaller);
		    DumpMemBlock(
			    L"Wrong memory allocator for global destructor",
			    pv,
			    MAXDWORD,	// cbMemory
			    MAXDWORD,	// Flags
			    MAXDWORD,	// ibt
			    &bt);
		    CSASSERT(!"Wrong memory allocator for global destructor");
		}
		else
		{
		    pmh->Flags |= CSM_GLOBALDESTRUCTOR;
		}
	    }
	    else
	    {
		g_armAlloc[Flags].cAlloc--;

		pbt->cAlloc--;
		pbt->cbAlloc -= pmh->cbMemory;

		if (CSM_GLOBALDESTRUCTOR & pmh->Flags)
		{
		    Flags |= CSM_GLOBALDESTRUCTOR;
		}
		if (CSM_TRACEASSERT & pmh->Flags)
		{
		    Flags |= CSM_TRACEASSERT;
		}
		if (pmh->Flags != Flags)
		{
		    DBGPRINTW((
			DBG_SS_CERTLIB,
			L"%ws: Wrong memory allocator: Freed with %ws, Allocated by %ws\n",
			s_wszProcess,
			wszFreeer(Flags),
			wszAllocator(pmh->Flags)));
		    DumpMemBlock(
			    L"Wrong memory allocator",
			    pv,
			    pmh->cbMemory,
			    pmh->Flags,
			    pmh->iBackTrace,
			    BackTraceFromIndex(pmh->iBackTrace));
		    CSASSERT(pmh->Flags == Flags);
		}
		else if (MTF_FREETRACE & g_MemTrack)
		{
		    DBGPRINTW((
			DBG_SS_CERTLIB,
			L"Free: pmh=%x: pv=%x cb=%x f=%x(%ws) -- pbt[%d]=%x: c=%x, cb=%x\n",
			pmh,
			pv,
			pmh->cbMemory,
			pmh->Flags,
			wszAllocator(pmh->Flags),
			pmh->iBackTrace,
			pbt,
			pbt->cAlloc,
			pbt->cbAlloc));
		    if (MTF_STACKTRACE & g_MemTrack)
		    {
			BACKTRACE bt;

			CaptureStackBackTrace(NULL, 0, C_BP_FRAME, bt.apCaller);
			DumpMemBlock(
				L"Free Trace memory block(alloc)",
				pv,
				pmh->cbMemory,		// cbMemory
				pmh->Flags,		// Flags
				pmh->iBackTrace,	// ibt
				pbt);
			DumpMemBlock(
				L"Free Trace memory block(free)",
				pv,
				pmh->cbMemory,		// cbMemory
				pmh->Flags,		// Flags
				MAXDWORD,		// ibt
				&bt);
		    }
		}
		FreeMemHeader(pmh);
	    }
        }
        else if (MTF_UNREGISTERED & g_MemTrack)
        {
	    BACKTRACE bt;

	    CaptureStackBackTrace(NULL, 0, C_BP_FRAME, bt.apCaller);
	    DumpMemBlock(
		    L"Unregistered memory block",
		    pv,
		    MAXDWORD,	// cbMemory
		    MAXDWORD,	// Flags
		    MAXDWORD,	// ibt
		    &bt);
	    CSASSERT(!"Unregistered memory block");
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    RegisterMemoryLeaveCriticalSection();
}


DWORD
myFormatMessageW(
    IN DWORD dwFlags,
    IN LPCVOID lpSource,
    IN DWORD dwMessageId,
    IN DWORD dwLanguageId,
    OUT LPWSTR lpBuffer,
    IN DWORD nSize,
    IN va_list *Arguments)
{
    DWORD cwc;

    cwc = FormatMessage(
		    dwFlags,
		    lpSource,
		    dwMessageId,
		    dwLanguageId,
		    lpBuffer,
		    nSize,
		    Arguments);
    if (cwc != 0 && (FORMAT_MESSAGE_ALLOCATE_BUFFER & dwFlags))
    {
	myRegisterMemAlloc(
		    *(WCHAR **) lpBuffer,
		    (cwc + 1) * sizeof(WCHAR),
		    CSM_LOCALALLOC);
    }
    return(cwc);
}


HLOCAL
myLocalAlloc(
    IN UINT uFlags,
    IN UINT uBytes)
{
    HLOCAL hMem;

    // one of these should always be specified (see LocalAlloc specification)
    assert((LMEM_FIXED == (uFlags & LMEM_FIXED))  ||
           (LMEM_MOVEABLE == (uFlags & LMEM_MOVEABLE)) );

    hMem = LocalAlloc(uFlags, uBytes);
    if (NULL != hMem)
    {
	myRegisterMemAlloc(hMem, uBytes, CSM_LOCALALLOC);
    }
    return(hMem);
}


HLOCAL
myLocalReAlloc(
    IN HLOCAL hMem,
    IN UINT uBytes,
    IN UINT uFlags)
{
    HLOCAL hMemNew;

    // if realloc called without MOVEABLE flag, realloc can't relocate allocation
    assert(LMEM_MOVEABLE == (uFlags & LMEM_MOVEABLE));

    hMemNew = LocalReAlloc(hMem, uBytes, uFlags);
    if (NULL != hMemNew)
    {
	myRegisterMemFree(hMem, CSM_LOCALALLOC);
	myRegisterMemAlloc(hMemNew, uBytes, CSM_LOCALALLOC);
    }

    return(hMemNew);
}


HLOCAL
myLocalFree(
    IN HLOCAL hMem)
{
    myRegisterMemFree(hMem, CSM_LOCALALLOC);
    return(LocalFree(hMem));
}


VOID *
myCoTaskMemAlloc(
    IN ULONG cb)
{
    VOID *pv;

    pv = CoTaskMemAlloc(cb);
    if (NULL != pv)
    {
	myRegisterMemAlloc(pv, cb, CSM_COTASKALLOC);
    }
    return(pv);
}


VOID *
myCoTaskMemRealloc(
    IN VOID *pv,
    IN ULONG cb)
{
    VOID *pvNew;

    pvNew = CoTaskMemRealloc(pv, cb);
    if (NULL != pvNew)
    {
	myRegisterMemFree(pv, CSM_COTASKALLOC);
	myRegisterMemAlloc(pvNew, cb, CSM_COTASKALLOC);
    }
    return(pvNew);
}


VOID
myCoTaskMemFree(
    IN VOID *pv)
{
    myRegisterMemFree(pv, CSM_COTASKALLOC);
    CoTaskMemFree(pv);
}


HRESULT
myStringFromCLSID(
    IN REFCLSID rclsid,
    OUT LPOLESTR FAR *ppwsz)
{
    HRESULT hr;

    hr = StringFromCLSID(rclsid, ppwsz);
    _JumpIfError(hr, error, "StringFromCLSID");

    if (NULL != *ppwsz)
    {
	myRegisterMemAlloc(
		    *ppwsz, (wcslen(*ppwsz) + 1) * sizeof(WCHAR),
		    CSM_COTASKALLOC);
    }

error:
    return(hr);
}


HRESULT
myStringFromIID(
    IN REFIID rclsid,
    OUT LPOLESTR FAR *ppwsz)
{
    HRESULT hr;

    hr = StringFromIID(rclsid, ppwsz);
    _JumpIfError(hr, error, "StringFromIID");

    if (NULL != *ppwsz)
    {
	myRegisterMemAlloc(
		    *ppwsz, (wcslen(*ppwsz) + 1) * sizeof(WCHAR),
		    CSM_COTASKALLOC);
    }

error:
    return(hr);
}


BSTR
mySysAllocString(
    IN const OLECHAR *pwszIn)
{
    BSTR str;

    str = SysAllocString(pwszIn);
    if (NULL != str)
    {
	myRegisterMemAlloc(str, (wcslen(pwszIn) + 1) * sizeof(WCHAR), CSM_SYSALLOC);
    }
    return(str);
}


INT
mySysReAllocString(
    IN OUT BSTR *pstr,
    IN const OLECHAR *pwszIn)
{
    BSTR str = *pstr;
    INT i;

    i = SysReAllocString(pstr, pwszIn);
    if (i)
    {
	myRegisterMemFree(str, CSM_SYSALLOC);
	myRegisterMemAlloc(*pstr, (wcslen(pwszIn) + 1) * sizeof(WCHAR), CSM_SYSALLOC);
    }
    return(i);
}


BSTR
mySysAllocStringLen(
    IN const OLECHAR *pwcIn,
    IN UINT cwc)
{
    BSTR str;

    str = SysAllocStringLen(pwcIn, cwc);
    if (NULL != str)
    {
	myRegisterMemAlloc(str, cwc * sizeof(WCHAR), CSM_SYSALLOC);
    }
    return(str);
}


INT
mySysReAllocStringLen(
    IN OUT BSTR *pstr,
    IN const OLECHAR *pwcIn,
    IN UINT cwc)
{
    BSTR str = *pstr;
    INT i;

    i = SysReAllocStringLen(pstr, pwcIn, cwc);
    if (i)
    {
	myRegisterMemFree(str, CSM_SYSALLOC);
	myRegisterMemAlloc(*pstr, cwc * sizeof(WCHAR), CSM_SYSALLOC);
    }
    return(i);
}


VOID
mySysFreeString(
    IN BSTR str)
{
    if (NULL != str)
    {
	myRegisterMemFree(str, CSM_SYSALLOC);
    }
    SysFreeString(str);
}


BSTR
mySysAllocStringByteLen(
    LPCSTR pszIn,
    UINT cb)
{
    BSTR str;

    str = SysAllocStringByteLen(pszIn, cb);
    if (NULL != str)
    {
	myRegisterMemAlloc(str, cb, CSM_SYSALLOC);
    }
    return(str);
}


VOID
_RegisterVariantMemAlloc(
    IN PROPVARIANT *pvar)
{
    VOID *pv;
    DWORD Flags;
    DWORD cb;
    
    pv = _VariantMemory(pvar, &Flags, &cb);
    if (NULL != pv)
    {
	myRegisterMemAlloc(pv, cb, Flags);
    }
}


VOID
_RegisterVariantMemFree(
    IN PROPVARIANT *pvar)
{
    VOID *pv;
    DWORD Flags;
    
    pv = _VariantMemory(pvar, &Flags, NULL);
    if (NULL != pv)
    {
	myRegisterMemFree(pv, Flags);
    }
}


HRESULT
myPropVariantClear(
    IN PROPVARIANT *pvar)
{
    _RegisterVariantMemFree(pvar);
    return(PropVariantClear(pvar));
}


HRESULT
myVariantClear(
    IN VARIANTARG *pvar)
{
    _RegisterVariantMemFree((PROPVARIANT *) pvar);
    return(VariantClear(pvar));
}


HRESULT
myVariantChangeType(
    OUT VARIANTARG *pvarDest,
    IN VARIANTARG *pvarSrc,
    IN unsigned short wFlags,
    IN VARTYPE vt)
{
    HRESULT hr;

    // if converting in-place, memory will be freed by the API call

    if (pvarDest == pvarSrc)
    {
	_RegisterVariantMemFree((PROPVARIANT *) pvarSrc);
    }
    hr = VariantChangeType(pvarDest, pvarSrc, wFlags, vt);
    _RegisterVariantMemAlloc((PROPVARIANT *) pvarDest);
    return(hr);
}


HRESULT
myVariantChangeTypeEx(
    OUT VARIANTARG *pvarDest,
    IN VARIANTARG *pvarSrc,
    IN LCID lcid,
    IN unsigned short wFlags,
    IN VARTYPE vt)
{
    HRESULT hr;

    // if converting in-place, memory will be freed by the API call

    if (pvarDest == pvarSrc)
    {
	_RegisterVariantMemFree((PROPVARIANT *) pvarSrc);
    }
    hr = VariantChangeTypeEx(pvarDest, pvarSrc, lcid, wFlags, vt);
    _RegisterVariantMemAlloc((PROPVARIANT *) pvarDest);
    return(hr);
}


VOID *
myNew(
    IN size_t size)
{
    VOID *pv;
    
    pv = LocalAlloc(LMEM_FIXED, size);
    if (NULL != pv)
    {
	myRegisterMemAlloc(pv, size, CSM_NEW);
    }
    return(pv);
}


VOID
myDelete(
    IN VOID *pv)
{
    myRegisterMemFree(pv, CSM_NEW);
    LocalFree(pv);
}


BOOL
myAllocateAndInitializeSid(
    IN PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    IN BYTE nSubAuthorityCount,
    IN DWORD nSubAuthority0,
    IN DWORD nSubAuthority1,
    IN DWORD nSubAuthority2,
    IN DWORD nSubAuthority3,
    IN DWORD nSubAuthority4,
    IN DWORD nSubAuthority5,
    IN DWORD nSubAuthority6,
    IN DWORD nSubAuthority7,
    OUT PSID *ppSid)
{
    BOOL b;
    
    b = AllocateAndInitializeSid(
			pIdentifierAuthority,
			nSubAuthorityCount,
			nSubAuthority0,
			nSubAuthority1,
			nSubAuthority2,
			nSubAuthority3,
			nSubAuthority4,
			nSubAuthority5,
			nSubAuthority6,
			nSubAuthority7,
			ppSid);
    if (b && NULL != *ppSid)
    {
	myRegisterMemAlloc(*ppSid, 32, CSM_SID);
    }
    return(b);
}


VOID *
myFreeSid(
    IN PSID pSid)
{
    myRegisterMemFree(pSid, CSM_SID);
    return(FreeSid(pSid));
}

#endif // DBG_CERTSRV
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\services\ca\certclib\cainfo.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996 - 2001
//
// File:        cainfo.cpp
//
// Contents:    
//
//---------------------------------------------------------------------------
#include "pch.cpp"

#pragma hdrstop

#include <certca.h>
#include <cainfop.h>
#include <polreg.h>
#include <cainfoc.h>
#include <certtype.h>
#include "certacl.h"
#include "accctrl.h"


#include <winldap.h>

#define __dwFILE__	__dwFILE_CERTCLIB_CAINFO_CPP__

typedef struct _CA_DEFAULT_PROVIDER {
    DWORD dwFlags;
    LPWSTR wszName;
} CA_DEFAULT_PROVIDER;

CA_DEFAULT_PROVIDER g_DefaultProviders[] = 
{
    {0, MS_DEF_PROV_W},
    {0, MS_ENHANCED_PROV_W},
    {0, MS_DEF_RSA_SIG_PROV_W},
    {0, MS_DEF_RSA_SCHANNEL_PROV_W},
    {0, MS_DEF_DSS_PROV_W},
    {0, MS_DEF_DSS_DH_PROV_W},
    {0, MS_ENH_DSS_DH_PROV_W},
    {0, MS_DEF_DH_SCHANNEL_PROV_W},
    {0, MS_SCARD_PROV_W}
};

DWORD g_cDefaultProviders = sizeof(g_DefaultProviders)/sizeof(g_DefaultProviders[0]);

LPCWSTR
CAGetDN(
        IN HCAINFO hCAInfo
        )
{
CSASSERT(hCAInfo);
return ((CCAInfo*)hCAInfo)->GetDN();
}

HRESULT
CAFindByName(
        IN  LPCWSTR     wszCAName,
        IN  LPCWSTR     wszScope,
        IN  DWORD       fFlags,
        OUT HCAINFO *   phCAInfo
        )
{
    HRESULT hr = S_OK;
    WCHAR *wszQueryBase = L"(cn=";
    WCHAR *wszQuery = NULL;
    DWORD cQuery;
    
    if((wszCAName == NULL) || (phCAInfo == NULL))
    {
        return E_POINTER;
    }
    // Generate Query

    cQuery = wcslen(wszQueryBase) + wcslen(wszCAName) + 2; // 2 for ending paren and null
    wszQuery = (WCHAR *)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*cQuery);
    if(wszQuery == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    wcscpy(wszQuery, wszQueryBase);
    wcscat(wszQuery, wszCAName);
    wcscat(wszQuery, L")");

    if(fFlags & CA_FLAG_SCOPE_DNS)
    {
        hr = CCAInfo::FindDnsDomain(wszQuery, wszScope, fFlags, (CCAInfo **)phCAInfo);
    }
    else
    {
        hr = CCAInfo::Find(wszQuery, wszScope, fFlags, (CCAInfo **)phCAInfo);
    }
    if((hr == S_OK) && 
      (*phCAInfo == NULL))
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

error:
    if(wszQuery)
    {
        LocalFree(wszQuery);
    }

    return hr;
}


HRESULT
CAFindByCertType(
        IN  LPCWSTR     wszCertType,
        IN  LPCWSTR     wszScope,
        IN  DWORD       fFlags,
        OUT HCAINFO *   phCAInfo
        )
{
    HRESULT hr = S_OK;
    WCHAR *wszQueryBase = L"(" CA_PROP_CERT_TYPES L"=";
    WCHAR *wszQuery = NULL;
    DWORD cQuery;
    
    if((wszCertType == NULL) || (phCAInfo == NULL))
    {
        return E_POINTER;
    }
    // Generate Query

    cQuery = wcslen(wszQueryBase) + wcslen(wszCertType) + 2; // 2 for ending paren and null
    wszQuery = (WCHAR *)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*cQuery);
    if(wszQuery == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    wcscpy(wszQuery, wszQueryBase);
    wcscat(wszQuery, wszCertType);
    wcscat(wszQuery, L")");

    if(fFlags & CA_FLAG_SCOPE_DNS)
    {
        hr = CCAInfo::FindDnsDomain(wszQuery, wszScope, fFlags, (CCAInfo **)phCAInfo);
    }
    else
    {
        hr = CCAInfo::Find(wszQuery, wszScope, fFlags, (CCAInfo **)phCAInfo);
    }
    if(*phCAInfo == NULL)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

error:
    if(wszQuery)
    {
        LocalFree(wszQuery);
    }

    return hr;
}


HRESULT
CAFindByIssuerDN(
        IN  CERT_NAME_BLOB const *  pIssuerDN,
        IN  LPCWSTR                 wszScope,
        IN  DWORD                   fFlags,
        OUT HCAINFO *               phCAInfo
        )
{
    HRESULT hr = S_OK;
    WCHAR *wszQueryBase = wszLPAREN L"cACertificateDN=";
    WCHAR *wszQuery = NULL;
    WCHAR *wszNameStr = NULL;

    DWORD cQuery;
    
    if((pIssuerDN == NULL) || (phCAInfo == NULL))
    {
        return E_POINTER;
    }

    // Generate Query

    // Convert the CAPI2 name to a string

    hr = myCertNameToStr(
		X509_ASN_ENCODING,
		pIssuerDN,
                CERT_X500_NAME_STR |
		    CERT_NAME_STR_REVERSE_FLAG |
		    CERT_NAME_STR_NO_QUOTING_FLAG,
		&wszNameStr);
    _JumpIfError(hr, error, "myCertNameToStr");

    // Now quote that string with double quotes
    // two for ending paren and null, two for the double quotes

    cQuery = wcslen(wszQueryBase) + wcslen(wszNameStr) + 4;
    wszQuery = (WCHAR *)LocalAlloc(LMEM_FIXED, sizeof(WCHAR)*cQuery);
    if(wszQuery == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    wcscpy(wszQuery, wszQueryBase);
    //wcscat(wszQuery, L"\"");
    wcscat(wszQuery, wszNameStr);
    //wcscat(wszQuery, L"\"" wszRPAREN);
    wcscat(wszQuery, wszRPAREN);
    CSASSERT(cQuery - 1 == wcslen(wszQuery));

    if(fFlags & CA_FLAG_SCOPE_DNS)
    {
        hr = CCAInfo::FindDnsDomain(wszQuery, wszScope, fFlags, (CCAInfo **)phCAInfo);
    }
    else
    {
        hr = CCAInfo::Find(wszQuery, wszScope, fFlags, (CCAInfo **)phCAInfo);
    }

error:
    if(wszNameStr)
    {
        LocalFree(wszNameStr);
    }
    if(wszQuery)
    {
        LocalFree(wszQuery);
    }
    return hr;
}



HRESULT
CAEnumFirstCA(
    IN  LPCWSTR          wszScope,
    IN  DWORD            fFlags,
    OUT HCAINFO *        phCAInfo
    )
{
    HRESULT hr = S_OK;

    if(fFlags & CA_FLAG_SCOPE_DNS)
    {
        hr = CCAInfo::FindDnsDomain(NULL, wszScope, fFlags, (CCAInfo **)phCAInfo);
    }
    else
    {
        hr = CCAInfo::Find(NULL, wszScope, fFlags, (CCAInfo **)phCAInfo);
    }
    if (S_OK != hr)
    {
	    if (HRESULT_FROM_WIN32(ERROR_NETWORK_UNREACHABLE) != hr &&
	        HRESULT_FROM_WIN32(ERROR_WRONG_PASSWORD) != hr)
	    {
	        _PrintError3(
		        hr,
		        "FindDnsDomain/Find",
		        HRESULT_FROM_WIN32(ERROR_SERVER_DISABLED),
		        HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN));
	    }
	    goto error;
    }

error:
    return(hr);
}


HRESULT
CAEnumNextCA(
    IN  HCAINFO          hPrevCA,
    OUT HCAINFO *        phCAInfo
    )
{
    CCAInfo *pInfo;
    if(hPrevCA == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hPrevCA;

    return pInfo->Next((CCAInfo **)phCAInfo);
}




HRESULT 
CACreateNewCA(
        IN  LPCWSTR     wszCAName,
        IN  LPCWSTR     wszScope,
        IN  DWORD       fFlags,
        OUT HCAINFO *   phCAInfo
        )
{
    HRESULT hr = S_OK;
    
    if((wszCAName == NULL) || (phCAInfo == NULL))
    {
        return E_POINTER;
    }
    // Generate Query


    if(CA_FLAG_SCOPE_DNS & fFlags)
    {
        hr = CCAInfo::CreateDnsDomain(wszCAName, wszScope, (CCAInfo **)phCAInfo);
    }
    else
    {
        hr = CCAInfo::Create(wszCAName, wszScope, (CCAInfo **)phCAInfo);
    }


    return hr;
}


HRESULT 
CAUpdateCA(
        IN HCAINFO    hCAInfo
        )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->Update();
}


HRESULT 
CADeleteCA(
        IN HCAINFO    hCAInfo
        )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->Delete();
}

DWORD 
CACountCAs(IN  HCAINFO  hCAInfo)
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return 0;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->Count();
}


HRESULT
CACloseCA(IN HCAINFO hCAInfo)
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->Release();
}


HRESULT
CAGetCAProperty(
    IN  HCAINFO     hCAInfo,
    IN  LPCWSTR     wszPropertyName,
    OUT LPWSTR **   pawszPropertyValue)
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->GetProperty(wszPropertyName, pawszPropertyValue);
}


HRESULT
CAFreeCAProperty(
    IN  HCAINFO     hCAInfo,
    IN  LPWSTR *    awszPropertyValue
    )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->FreeProperty(awszPropertyValue);
}


HRESULT
CASetCAProperty(
    IN HCAINFO      hCAInfo,
    IN LPCWSTR     wszPropertyName,
    IN LPWSTR *    awszPropertyValue)
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->SetProperty(wszPropertyName, awszPropertyValue);
}

HRESULT 
CAGetCAFlags(
    IN  HCAINFO     hCAInfo,
    OUT DWORD *     pdwFlags
    )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }

    if(pdwFlags == NULL)
    {
        return E_POINTER;
    }

    pInfo = (CCAInfo *)hCAInfo;


    *pdwFlags = pInfo->GetFlags();
    return S_OK;
}

HRESULT 
CASetCAFlags(
    IN HCAINFO     hCAInfo,
    IN DWORD       dwFlags
    )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    pInfo->SetFlags(dwFlags);
    return S_OK;
}

HRESULT
CAGetCACertificate(
    IN  HCAINFO     hCAInfo,
    OUT PCCERT_CONTEXT *ppCert)
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->GetCertificate(ppCert);

}


HRESULT
CASetCACertificate(
    IN  HCAINFO     hCAInfo,
    IN PCCERT_CONTEXT pCert)
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->SetCertificate(pCert);
}



HRESULT 
CAGetCAExpiration(
                HCAINFO hCAInfo, 
                DWORD * pdwExpiration, 
                DWORD * pdwUnits
                )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->GetExpiration(pdwExpiration, pdwUnits);

}


HRESULT 
CASetCAExpiration(
                HCAINFO hCAInfo, 
                DWORD dwExpiration, 
                DWORD dwUnits
                )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->SetExpiration(dwExpiration, dwUnits);
}

HRESULT 
CASetCASecurity(
                     IN HCAINFO                 hCAInfo,
                     IN PSECURITY_DESCRIPTOR    pSD
                     )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->SetSecurity( pSD );
}


HRESULT 
CAGetCASecurity(
                     IN  HCAINFO                    hCAInfo,
                     OUT PSECURITY_DESCRIPTOR *     ppSD
                     )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->GetSecurity( ppSD ) ;
}

CERTCLIAPI
HRESULT
WINAPI
CAAccessCheck(
    IN  HCAINFO     hCAInfo,
    IN HANDLE       ClientToken
    )

{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->AccessCheck(ClientToken,CERTTYPE_ACCESS_CHECK_ENROLL);
}



CERTCLIAPI
HRESULT
WINAPI
CAAccessCheckEx(
    IN  HCAINFO     hCAInfo,
    IN HANDLE       ClientToken,
    IN DWORD        dwOption
    )

{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->AccessCheck(ClientToken,dwOption);
}


HRESULT
CAEnumCertTypesForCAEx(
    IN  HCAINFO     hCAInfo,
    IN  LPCWSTR     wszScope,
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;
    if(dwFlags & CA_FLAG_ENUM_ALL_TYPES)
    {
        return  CCertTypeInfo::Enum(wszScope, 
                                 dwFlags, 
                                 (CCertTypeInfo **)phCertType);
    }

    return pInfo->EnumSupportedCertTypesEx(wszScope,
                                         dwFlags, 
                                         (CCertTypeInfo **)phCertType);

}


HRESULT
CAEnumCertTypesForCA(
    IN  HCAINFO     hCAInfo,
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    )
{
    return CAEnumCertTypesForCAEx(hCAInfo,
                                  NULL,
                                  dwFlags,
                                  phCertType);
}



HRESULT 
CAAddCACertificateType(
                HCAINFO hCAInfo, 
                HCERTTYPE hCertType
                )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->AddCertType((CCertTypeInfo *)hCertType);
}


HRESULT 
CARemoveCACertificateType(
                HCAINFO hCAInfo, 
                HCERTTYPE hCertType
                )
{
    CCAInfo *pInfo;
    if(hCAInfo == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCAInfo *)hCAInfo;

    return pInfo->RemoveCertType((CCertTypeInfo *)hCertType);
}


//
// Certificate Type API's
//


HRESULT
CAEnumCertTypes(
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    )
{
    HRESULT hr;

    hr = CCertTypeInfo::Enum(NULL, 
                             dwFlags, 
                             (CCertTypeInfo **)phCertType);
    return hr;

}


HRESULT
CAEnumCertTypesEx(
    IN  LPCWSTR     wszScope,
    IN  DWORD       dwFlags,
    OUT HCERTTYPE * phCertType
    )
{
    HRESULT hr;

    hr = CCertTypeInfo::Enum(wszScope, 
                             dwFlags, 
                             (CCertTypeInfo **)phCertType);
    return hr;

}


HRESULT 
CAFindCertTypeByName(
        IN  LPCWSTR     wszCertType,
        IN  HCAINFO     hCAInfo,
        IN  DWORD       dwFlags,
        OUT HCERTTYPE * phCertType
        )
{
    HRESULT hr = S_OK;
    LPCWSTR awszTypes[2];
    if((wszCertType == NULL) || (phCertType == NULL))
    {
        return E_POINTER;
    }


    awszTypes[0] = wszCertType;
    awszTypes[1] = NULL;



    hr = CCertTypeInfo::FindByNames(awszTypes, 
                                   ((CT_FLAG_SCOPE_IS_LDAP_HANDLE & dwFlags)?(LPWSTR)hCAInfo:NULL), 
                                   dwFlags, 
                                   (CCertTypeInfo **)phCertType);
    if((hr == S_OK) && (*phCertType == NULL))
    {
         hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
    }

    return hr;
}


HRESULT 
CACreateCertType(
        IN  LPCWSTR             wszCertType,
        IN  LPCWSTR             wszScope,
        IN  DWORD,              // fFlags
        OUT HCERTTYPE *         phCertType
        )
{
    HRESULT hr = S_OK;
    
    if((wszCertType == NULL) || (phCertType == NULL))
    {
        return E_POINTER;
    }

    hr = CCertTypeInfo::Create(wszCertType, wszScope, (CCertTypeInfo **)phCertType);

    return hr;
}


HRESULT 
CAUpdateCertType(
        IN HCERTTYPE           hCertType
        )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->Update();
}


HRESULT 
CADeleteCertType(
        IN HCERTTYPE            hCertType
        )
{
    CCertTypeInfo *pInfo;
    if(hCertType == NULL)
    {
        return E_POINTER;
    }
    pInfo = (CCertTypeInfo *)hCertType;

    return pInfo->Delete();
}

//--------------------------------------------------------------------
//
//  CertTypeRetrieveClientToken
//
//--------------------------------------------------------------------
BOOL    CertTypeRetrieveClientToken(HANDLE  *phToken)
{
    HRESULT         hr = S_OK;

    HANDLE          hHandle = NULL;
    HANDLE          hClientToken = NULL;

    hHandle = GetCurrentThread();
    if (NULL == hHandle)
    {
        hr = myHLastError();
    }
    else
    {

        if (!OpenThreadToken(hHandle,
                             TOKEN_QUERY,
                             TRUE,  // open as self
                             &hClientToken))
        {
            hr = myHLastError();
            CloseHandle(hHandle);
            hHandle = NULL;
        }
    }

    if(hr != S_OK)
    {
        hHandle = GetCurrentProcess();
        if (NULL == hHandle)
        {
            hr = myHLastError();
        }
        else
        {
            HANDLE hProcessToken = NULL;
            hr = S_OK;


            if (!OpenProcessToken(hHandle,
                                 TOKEN_DUPLICATE,
                                 &hProcessToken))
            {
                hr = myHLastError();
                CloseHandle(hHandle);
                hHandle = NULL;
            }
            else
            {
                if(!DuplicateToken(hProcessToken,
                               SecurityImpersonation,
                               &hClientToken))
                {
                    hr = myHLastError();
                    CloseHandle(hHandle);
                    hHandle = NULL;
                }
                CloseHandle(hProcessToken);
            }
        }
    }


    if(S_OK == hr)
        *phToken = hClientToken;

    if(hHandle)
        CloseHandle(hHandle);

    return (S_OK == hr);
}


HRESULT
CACloneCertType(
    IN  HCERTTYPE            hCertType,
    IN  LPCWSTR              wszCertType,
    IN  LPCWSTR              wszFriendlyName,
    IN  LPVOID               pvldap,
    IN  DWORD                dwFlags,
    OUT HCERTTYPE *          phCertType
    )
{
    HRESULT                 hr=E_INVALIDARG;
    DWORD                   dwFindCT=CT_FLAG_NO_CACHE_LOOKUP | CT_ENUM_MACHINE_TYPES | CT_ENUM_USER_TYPES;
    LPWSTR                  awszProp[2];
    DWORD                   dwEnrollmentFlag=0;
    DWORD                   dwSubjectNameFlag=0;
    DWORD                   dwGeneralFlag=0;
    DWORD                   dwSubjectRequirement=CT_FLAG_SUBJECT_REQUIRE_DIRECTORY_PATH | 
                                         CT_FLAG_SUBJECT_REQUIRE_COMMON_NAME | 
                                         CT_FLAG_SUBJECT_REQUIRE_EMAIL |
                                         CT_FLAG_SUBJECT_REQUIRE_DNS_AS_CN;
    DWORD                   dwTokenUserSize=0;
    DWORD                   dwAbsSDSize=0;
    DWORD                   dwDaclSize=0;
    DWORD                   dwSaclSize=0;
    DWORD                   dwOwnerSize=0;
    DWORD                   dwPriGrpSize=0;
    DWORD                   dwRelSDSize=0;
    ACL_SIZE_INFORMATION	aclsizeinfo;
    DWORD					dwNewAclSize=0;
    ACE_HEADER				*pFirstAce=NULL;
    PACL					pAcl=NULL;
    BOOL					bAclPresent=FALSE;
    BOOL					bDefaultAcl=FALSE;
    DWORD					nIndex=0;
    BOOL                    fAddAce=TRUE;
	DWORD					dwCount=0;

    HANDLE                  hToken=NULL;
    TOKEN_USER              *pTokenUser=NULL;
    PSECURITY_DESCRIPTOR    pSID=NULL;
    PSECURITY_DESCRIPTOR    pAbsSD=NULL;
    ACL                     * pAbsDacl=NULL;
    ACL                     * pAbsSacl=NULL;
    SID                     * pAbsOwner=NULL;
    SID                     * pAbsPriGrp=NULL;
    PSECURITY_DESCRIPTOR    pNewSD=NULL;
    LPWSTR *                awszCN=NULL;
    HCERTTYPE               hNewCertType=NULL;
    ACL						*pNewDacl=NULL;
	DWORD					*pdwIndex=NULL;

    if((NULL==hCertType) || (NULL==wszCertType) || (NULL==phCertType))
        goto error;

    *phCertType=NULL;

    if(pvldap)
        dwFindCT |= CT_FLAG_SCOPE_IS_LDAP_HANDLE;

    //make sure the new name does not exit
    if(S_OK == CAFindCertTypeByName(
                    wszCertType,
                    (HCAINFO)pvldap,
                    dwFindCT,
                    &hNewCertType))
    {
        hr=CRYPT_E_EXISTS;
        goto error;
    }

    //get a new cert type handle
    if(S_OK != (hr = CAGetCertTypePropertyEx(hCertType,
                                            CERTTYPE_PROP_CN,
                                            &awszCN)))
        goto error;

    if((NULL==awszCN) || (NULL==awszCN[0]))
    {
        hr=HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        goto error;
    }


    if(S_OK != (hr = CAFindCertTypeByName(
                    (LPCWSTR)awszCN[0],
                    (HCAINFO)pvldap,
                    dwFindCT,
                    &hNewCertType)))
        goto error;

    if(NULL==hNewCertType)
    {
        hr=HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
        goto error;
    }

    //clone by setting the CN
    awszProp[0]=(LPWSTR)wszCertType;
    awszProp[1]=NULL;

    if(S_OK != (hr=CASetCertTypePropertyEx(
                    hNewCertType,
                    CERTTYPE_PROP_CN,
                    awszProp)))
        goto error;
                    

    //set the friendly name
    if(wszFriendlyName)
    {
        awszProp[0]=(LPWSTR)wszFriendlyName;
        awszProp[1]=NULL;

        if(S_OK != (hr=CASetCertTypePropertyEx(
                    hNewCertType,
                    CERTTYPE_PROP_FRIENDLY_NAME,
                    awszProp)))
            goto error;
    }

    //turn off autoenrollment bit
    if(0 == (CT_CLONE_KEEP_AUTOENROLLMENT_SETTING & dwFlags))
    {
        if(S_OK != (hr=CAGetCertTypeFlagsEx(
                        hNewCertType,
                        CERTTYPE_ENROLLMENT_FLAG,
                        &dwEnrollmentFlag)))
            goto error;

        dwEnrollmentFlag &= (~CT_FLAG_AUTO_ENROLLMENT);

        if(S_OK != (hr=CASetCertTypeFlagsEx(
                        hNewCertType,
                        CERTTYPE_ENROLLMENT_FLAG,
                        dwEnrollmentFlag)))
            goto error;
    }


    //turn off the subject name requirement for machien template
    if(0 == (CT_CLONE_KEEP_SUBJECT_NAME_SETTING & dwFlags))
    {
        if(S_OK != (hr=CAGetCertTypeFlagsEx(
                        hNewCertType,
                        CERTTYPE_GENERAL_FLAG,
                        &dwGeneralFlag)))
            goto error;


        if(CT_FLAG_MACHINE_TYPE & dwGeneralFlag)
        {
            if(S_OK != (hr=CAGetCertTypeFlagsEx(
                            hNewCertType,
                            CERTTYPE_SUBJECT_NAME_FLAG,
                            &dwSubjectNameFlag)))
                goto error;

            dwSubjectNameFlag &= (~dwSubjectRequirement);

            if(S_OK != (hr=CASetCertTypeFlagsEx(
                            hNewCertType,
                            CERTTYPE_SUBJECT_NAME_FLAG,
                            dwSubjectNameFlag)))
                goto error;

        }
    }


    //get the client token
    if(!CertTypeRetrieveClientToken(&hToken))
    {
        hr = myHLastError();
        goto error;
    }

    //get the client sid
    dwTokenUserSize=0;

    if(!GetTokenInformation(
        hToken,                             // handle to access token
        TokenUser,                          // token type
        NULL,                               // buffer
        0,                                  // size of buffer
        &dwTokenUserSize))                  // required buffer size
    {
        if (ERROR_INSUFFICIENT_BUFFER!=GetLastError()) 
        {
            hr = myHLastError();
            goto error;
        }
    }

    if(NULL==(pTokenUser=(TOKEN_USER *)LocalAlloc(LPTR, dwTokenUserSize)))
    {
        hr=E_OUTOFMEMORY;
        goto error;
    }

    if(!GetTokenInformation(
        hToken,                             // handle to access token
        TokenUser,                          // token type
        pTokenUser,                         // buffer
        dwTokenUserSize,                    // size of buffer
        &dwTokenUserSize))                  // required buffer size
    {
        hr = myHLastError();
        goto error;
    }


    //update the ACLs of the template to have the caller as the owner
    //of the ACL
    if(S_OK != (hr=CACertTypeGetSecurity(
                        hNewCertType,
                        &pSID)))
        goto error;

	//we will delete all ACCESS_DENIED ACEs for the caller 

    // get the (D)ACL from the security descriptor
    if (!GetSecurityDescriptorDacl(pSID, &bAclPresent, &pAcl, &bDefaultAcl)) 
	{
        hr = myHLastError();
        _JumpError(hr, error, "GetSecurityDescriptorDacl");
    }

    if(FALSE == bAclPresent)
	{
        hr=HRESULT_FROM_WIN32(ERROR_INVALID_SECURITY_DESCR);
		_JumpError(hr, error, "IsValidSecurityDescriptor");
	}

	// NULL acl -> allow all access
    if (NULL != pAcl) 
	{
		// find out how many ACEs
		memset(&aclsizeinfo, 0, sizeof(aclsizeinfo));
		if (!GetAclInformation(pAcl, &aclsizeinfo, sizeof(aclsizeinfo), AclSizeInformation)) 
		{
			hr = myHLastError();
			_JumpError(hr, error, "GetAclInformation");
		}

		pdwIndex=(DWORD *)LocalAlloc(LPTR, sizeof(DWORD) * (aclsizeinfo.AceCount));

		if(NULL==pdwIndex)
		{
			hr=E_OUTOFMEMORY;
			goto error;
		}

		memset(pdwIndex, 0, sizeof(DWORD) * (aclsizeinfo.AceCount));
		dwCount=0;

		for (nIndex=0; nIndex < aclsizeinfo.AceCount; nIndex++) 
		{
			ACE_HEADER					* pAceHeader=NULL;
			ACCESS_ALLOWED_ACE			* pAccessAce=NULL;
			PSID						pSid=NULL;

			if (!GetAce(pAcl, nIndex, (void**)&pAceHeader)) 
			{
				hr = myHLastError();
				_JumpError(hr, error, "GetAce");
			}

			// find the sid for this ACE
			if ((ACCESS_ALLOWED_ACE_TYPE != pAceHeader->AceType) && (ACCESS_DENIED_ACE_TYPE != pAceHeader->AceType))
			{
				// we are only interested in ace types
				continue;
			}

			// note that ACCESS_ALLOWED_ACE and ACCESS_DENIED_ACE are the same structurally.
			pAccessAce=(ACCESS_ALLOWED_ACE *)pAceHeader;

			pSid=((BYTE *)&(pAccessAce->SidStart));

			// make sure this is the sid we are looking for
			if (!EqualSid(pSid, (pTokenUser->User).Sid)) 
			{
				continue;
			}

			if(ACCESS_ALLOWED_ACE_TYPE == pAceHeader->AceType)
			{
				//change it to allowed for everything
				fAddAce=FALSE;

				pAceHeader->AceType=ACCESS_ALLOWED_ACE_TYPE;
				pAccessAce->Mask=(pAccessAce->Mask) | (ACTRL_CERTSRV_MANAGE_LESS_CONTROL_ACCESS);
			}
			else
			{
				//delete the denied ace
				if(ACCESS_DENIED_ACE_TYPE == pAceHeader->AceType)
				{
					pdwIndex[dwCount]=nIndex;
					dwCount++;
				}
			}
		}

		if(!Mak